#
# PySNMP MIB module CISCO-ENHANCED-IPSEC-FLOW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ENHANCED-IPSEC-FLOW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:56:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
CIPsecControlProtocol, CIPsecEncryptAlgorithm, CIPsecSpi, CIPsecEndPtType, CIPsecTunnelStatus, CIPsecNATTraversalMode, CIPsecDiffHellmanGrp, CIPsecProtocol, CIPsecEncapMode, CIPsecAuthAlgorithm, CIPsecPhase2SaDirection, CIPsecEncryptionKeySize, CIPsecCompAlgorithm, CIPsecPhase2TunnelIndex, CIPsecPmtu, CIPsecPhase1TunnelIndexOrZero = mibBuilder.importSymbols("CISCO-IPSEC-TC", "CIPsecControlProtocol", "CIPsecEncryptAlgorithm", "CIPsecSpi", "CIPsecEndPtType", "CIPsecTunnelStatus", "CIPsecNATTraversalMode", "CIPsecDiffHellmanGrp", "CIPsecProtocol", "CIPsecEncapMode", "CIPsecAuthAlgorithm", "CIPsecPhase2SaDirection", "CIPsecEncryptionKeySize", "CIPsecCompAlgorithm", "CIPsecPhase2TunnelIndex", "CIPsecPmtu", "CIPsecPhase1TunnelIndexOrZero")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoIpProtocol, CiscoPort = mibBuilder.importSymbols("CISCO-TC", "CiscoIpProtocol", "CiscoPort")
InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Bits, ModuleIdentity, Gauge32, iso, Counter64, Integer32, MibIdentifier, Counter32, IpAddress, ObjectIdentity, TimeTicks, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ModuleIdentity", "Gauge32", "iso", "Counter64", "Integer32", "MibIdentifier", "Counter32", "IpAddress", "ObjectIdentity", "TimeTicks", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
TimeStamp, DisplayString, TruthValue, TimeInterval, TextualConvention, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "TruthValue", "TimeInterval", "TextualConvention", "DateAndTime")
ciscoEnhancedIpsecFlowMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 432))
ciscoEnhancedIpsecFlowMIB.setRevisions(('2013-06-28 00:00', '2011-07-19 00:00', '2005-01-12 00:00', '2004-08-31 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoEnhancedIpsecFlowMIB.setRevisionsDescriptions(('Added ciscoEnhIPsecFlowPerformanceThroughputGroup group Added performanceUtilization to ceipSecFailReason', 'Added ciscoEnhIPsecFlowNotifCntlGroupSup01 control group with certificate objects: ceipSecNotifCntlCertExpiry ceipSecNotifCntlCertRenewal Added ciscoEnhIPsecFlowNotifGroupSup01 notification group with certificate objects: ciscoEnhIpsecFlowCertExpiry ciscoEnhIpsecFlowCertRenewal Added ciscoEnhIPsecFlowCertObjectGroup with certificate objects: ceipSecCertSubjectName ceipSecCertSerialNumber ceipSecCertIssuerName ceipSecCertRenewalStatus ceipSecCertExpiryStatus Added certificate groups and objects to ciscoEnhIPsecFlowMIBComplianceRev1', 'Added a new table, ceipSecTunnelSaTable', 'Initial version of this module.',))
if mibBuilder.loadTexts: ciscoEnhancedIpsecFlowMIB.setLastUpdated('201306280000Z')
if mibBuilder.loadTexts: ciscoEnhancedIpsecFlowMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoEnhancedIpsecFlowMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-ipsecmib@external.cisco.com')
if mibBuilder.loadTexts: ciscoEnhancedIpsecFlowMIB.setDescription("This is a MIB Module for monitoring the structures and status of IPSec-based networks. The MIB has been designed to be adopted as an IETF standard. Hence vendor-specific features of IPSec protocol are excluded from this MIB. Acronyms The following acronyms are used in this document: IPsec: Secure IP Protocol VPN: Virtual Private Network ISAKMP: Internet Security Association and Key Exchange Protocol IKE: Internet Key Exchange Protocol SA: Security Association (ref: rfc2408). SPI: Security Parameter Index is the pointer or identifier used in accessing SA attributes (ref: rfc2408). MM: Main Mode - the process of setting up a Phase 1 SA to secure the exchanges required to setup Phase 2 SAs QM: Quick Mode - the process of setting up Phase 2 Security Associations using a Phase 1 SA. Phase 1 Tunnel: An ISAKMP SA can be regarded as representing a flow of ISAKMP/IKE traffic. Hence an ISAKMP is referred to as a 'Phase 1 Tunnel' in this document. Control Tunnel: Another term for a Phase 1 Tunnel. Phase 2 Tunnel: An instance of a non-ISAKMP SA bundle in which all the SA share the same proxy identifiers (IDii,IDir) protect the same stream of application traffic. Such an SA bundle is termed a 'Phase 2 Tunnel'. Note that a Phase 2 tunnel may comprise different SA bundles and different number of SA bundles at different times (due to key refresh). MTU: Maximum Transmission Unit (of an IPsec tunnel). History of the MIB A precursor to this MIB was written by Tivoli and implemented in IBM Nways routers in 1999. During late 1999, Cisco adopted the MIB and together with Tivoli publised the IPsec Flow Monitor MIB in IETF IPsec WG in draft-ietf-ipsec-flow-monitoring-mib-00.txt. In 2000, the MIB was Cisco-ized and implemented this draft as CISCO-IPSEC-FLOW-MONITOR-MIB in IOS and VPN3000 platforms. With the evolution of IKEv2, the MIB was modified and presented to the IPsec WG again in May 2003 in draft-ietf-ipsec-flow-monitoring-mib-02.txt. With the emergence of multiple IPsec signaling protocols, it became apparent that the signaling aspects of IPsec need to be instrumented separately in their own right. Thus, the IPsec control attributes and metrics were separated out into CISCO-IPSEC-SIGNALING-MIB and CISCO-IKE-FLOW-MIB. This version of the draft is the version of the draft that models that IPsec data protocol, structures and activity alone. Overview of MIB The MIB contains four major groups of objects which are used to manage the IPsec Protocol. These groups include a Levels Group, a Phase-1 Group, a Phase-2 Group, a History Group, a Failure Group and a TRAP Control Group. The following table illustrates the structure of the IPsec MIB. The Phase 2 group models objects pertaining to IPsec data tunnels. The History group is to aid applications that do trending analysis. The Failure group is to enable an operator to do troubleshooting and debugging of the VPN Router. Further, counters are supported to aid detection of potential security violations. In addition to the three major MIB Groups, there are a number of Notifications. The following table illustrates the name and description of the IPsec TRAPs.")
ciscoEnhancedIpsecFlowMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 0))
ciscoEnhancedIpsecFlowMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1))
ciscoEnhancedIpsecFlowMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 2))
ceipSecPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1))
ceipSecHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2))
ceipSecFailures = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3))
ceipSecNotificationCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5))
ceipSecCertNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6))
ceipSecGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1))
ceipSecGlobalActiveTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 1), Gauge32()).setUnits('Tunnels').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalActiveTunnels.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalActiveTunnels.setDescription('The total number of currently active IPsec Phase-2 Tunnels.')
ceipSecGlobalPreviousTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 2), Counter64()).setUnits('Tunnels').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalPreviousTunnels.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalPreviousTunnels.setDescription('The total number of previously active IPsec Phase-2 Tunnels.')
ceipSecGlobalInOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 3), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInOctets.setDescription('A high capacity count of the total number of octets received by all current and previous IPsec Phase-2 Tunnels. This value is accumulated BEFORE determining whether or not the packet should be decompressed.')
ceipSecGlobalInDecompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 4), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInDecompOctets.setDescription('A high capacity count of the total number of decompressed octets received by all current and previous IPsec Phase-2 Tunnels. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ceipSecGlobalInOctets.')
ceipSecGlobalInPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 5), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInPkts.setDescription('The total number of packets received by all current and previous IPsec Phase-2 Tunnels.')
ceipSecGlobalInDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 6), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInDrops.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInDrops.setDescription('The total number of packets dropped during receive processing by all current and previous IPsec Phase-2 Tunnels. This count does NOT include packets dropped due to Anti-Replay processing.')
ceipSecGlobalInReplayDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 7), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInReplayDrops.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInReplayDrops.setDescription('The total number of packets dropped during receive processing due to Anti-Replay processing by all current and previous IPsec Phase-2 Tunnels.')
ceipSecGlobalInAuths = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 8), Counter64()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInAuths.setDescription("The total number of inbound authentication's performed by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalInAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 9), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInAuthFails.setDescription("The total number of inbound authentication's which ended in failure by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalInDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 10), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInDecrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInDecrypts.setDescription("The total number of inbound decryption's performed by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalInDecryptFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 11), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalInDecryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalInDecryptFails.setDescription("The total number of inbound decryption's which ended in failure by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 12), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutOctets.setDescription('A high capacity count of the total number of octets sent by all current and previous IPsec Phase-2 Tunnels. This value is accumulated AFTER determining whether or not the packet should be compressed.')
ceipSecGlobalOutUncompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 13), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutUncompOctets.setDescription('A high capacity count of the total number of uncompressed octets sent by all current and previous IPsec Phase-2 Tunnels. This value is accumulated BEFORE the packet is compressed. If compression is not being used, this value will match the value of ceipSecGlobalOutOctets.')
ceipSecGlobalOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 14), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutPkts.setDescription('The total number of packets sent by all current and previous IPsec Phase-2 Tunnels.')
ceipSecGlobalOutDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 15), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutDrops.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutDrops.setDescription('The total number of packets dropped during send processing by all current and previous IPsec Phase-2 Tunnels.')
ceipSecGlobalOutAuths = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 16), Counter64()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutAuths.setDescription("The total number of outbound authentication's performed by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalOutAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 17), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutAuthFails.setDescription("The total number of outbound authentication's which ended in failure by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalOutEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 18), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutEncrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutEncrypts.setDescription("The total number of outbound encryption's performed by all current and previous IPsec Phase-2 Tunnels.")
ceipSecCertSubjectName = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertSubjectName.setReference('RFC 3280 section 4.1.2.6 Subject RFC 3280 section 4.2.1.7 Subject Alternative Name')
if mibBuilder.loadTexts: ceipSecCertSubjectName.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertSubjectName.setDescription('This object provides the subject name from the X.509 certificate, or the alternate subject name if it is available. The subject name is formatted as a character string matching the output of a ssh-certview command-line application, except that the application sending the notification may limit the string length. Example Subject Name: C=US, OU=DEV, CN=Test-01 Example Subject Alternative Name: 2001:0022:0022:0020:0000:0000:0000:0102')
ceipSecCertSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertSerialNumber.setReference('RFC 3280 section 4.1.2.2 Serial number')
if mibBuilder.loadTexts: ceipSecCertSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertSerialNumber.setDescription('This object provides the serial number from the X.509 certificate. The serial number is formatted as a character string matching the output of a ssh-certview command-line application. The issuer name and the serial number identify a unique certificate. Example: 1000655533')
ceipSecCertIssuerName = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertIssuerName.setReference('RFC 3280 section 5.1.2.3 Issuer Name')
if mibBuilder.loadTexts: ceipSecCertIssuerName.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertIssuerName.setDescription('This object provides the issuer name from the X.509 certificate. The issuer name is formatted as a character string matching the output of a ssh-certview command-line application, except that the application sending the notification may limit the string length. The issuer name and the serial number identify a unique certificate. Example: C=US, O=Cisco, OU=MITG, CN=Lnx-Insta-RootCA-1')
ceipSecCertExpiryTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertExpiryTime.setReference('RFC 3280 section 4.1.2.5 Validity')
if mibBuilder.loadTexts: ceipSecCertExpiryTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertExpiryTime.setDescription('This object provides the validity notAfter time from the X.509 certificate. The notAfter time is the time after which the certificate is not valid. The time is formatted as a character string matching the output of a ssh-certview command-line application. Example: 2012 Apr 14th, 19:01:45 GMT')
ceipSecCertRenewalStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("renewalNotNeeded", 1), ("renewalRequestNeeded", 2), ("renewalRequested", 3), ("renewalSuccess", 4), ("renewalFailedUpdate", 5), ("renewalFailedExpired", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertRenewalStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertRenewalStatus.setDescription("This object provides the renewal status of the X.509 certificate on the application sending the notification. renewalNotNeeded(1) = certificate is OK and does not need to be renewed renewalRequestNeeded(2) = certificate renewal request is needed renewalRequested(3) = certificate renewal has been requested and the renewal process is proceeding renewalSuccess(4) = certificate has been renewed and will be OK (renewalNotNeeded) renewalFailedUpdate(5) = certificate renewal failed, but certificate is still usable until the validity expiration time provided in the notification, or otherwise restricted by the application renewalFailedExpired(6) = certificate is no longer valid, the current time is after the certificate's validity notAfter time, which is provided in this notification")
ceipSecCertExpiryStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("certOK", 1), ("certGoingExpired", 2), ("certExpired", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecCertExpiryStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecCertExpiryStatus.setDescription("This object provides the expiration status of the X.509 certificate on the application sending the notification. The notification is sent when the value of this object is changed from certOK(1) to certGoingExpired(2). certOK(1) = certificate is OK and is not within the configured time threshold for going to expire certGoingExpired(2) = certificate is within the configured time threshold for going to expire certExpired(3) = certificate has expired, the current time is after the certificate's validity notAfter time")
ceipSecGlobalOutEncryptFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 19), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutEncryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutEncryptFails.setDescription("The total number of outbound encryption's which ended in failure by all current and previous IPsec Phase-2 Tunnels.")
ceipSecGlobalProtocolUseFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 20), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalProtocolUseFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalProtocolUseFails.setDescription('The total number of protocol use failures which occurred during processing of all current and previously active IPsec Phase-2 Tunnels.')
ceipSecGlobalNoSaFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 21), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalNoSaFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalNoSaFails.setDescription('The total number of non-existent Security Association in failures which occurred during processing of all current and previous IPsec Phase-2 Tunnels.')
ceipSecGlobalSysCapFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 22), Counter64()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalSysCapFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalSysCapFails.setDescription('The total number of system capacity failures which occurred during processing of all current and previously active IPsec Phase-2 Tunnels.')
ceipSecGlobalOutCompressedPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 23), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutCompressedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutCompressedPkts.setDescription('The cumulative number of outbound packets across all IPsec flows terminating at this device which were successfully compressed.')
ceipSecGlobalOutCompSkippedPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 24), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutCompSkippedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutCompSkippedPkts.setDescription('The total number of outbound packets across all IPsec flows terminating at this devices that were to be compressed but which were skipped due to the compression hysteresis.')
ceipSecGlobalOutCompFailPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 25), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutCompFailPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutCompFailPkts.setDescription('The total number of outbound packets across all IPsec flows terminating at this device that failed compression because they grew in size after compression.')
ceipSecGlobalOutCompTooSmallPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 26), Counter64()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalOutCompTooSmallPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalOutCompTooSmallPkts.setDescription('The total number of outbound packets across all IPsec flows terminating at this device that were to be compressed but were smaller than the compression threshold size. This number is cumulative since the last system start.')
ceipSecGlobalThroughputUtilizatioinTimeInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 27), Unsigned32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalThroughputUtilizatioinTimeInterval.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalThroughputUtilizatioinTimeInterval.setDescription('The object is the length of the time interval to measure the throughtput utilization.')
ceipSecGlobalThroughputLastUpdatedTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 28), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalThroughputLastUpdatedTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalThroughputLastUpdatedTime.setDescription('The timestamp is the end of the last throughput utilization time interval.')
ceipSecGlobalLastAveragePacketSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 29), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalLastAveragePacketSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalLastAveragePacketSize.setDescription('This object is the average packet size in the last throughput utilization time interval that ended at ceipSecGlobalThroughputLastUpdatedTime.')
ceipSecGlobalLastThroughputInMbps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 30), Unsigned32()).setUnits('Mbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputInMbps.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputInMbps.setDescription('The object is the total throughput in Mbps in the last throughput utilization time interval that ended at ceipSecGlobalThroughputLastUpdatedTime.')
ceipSecGlobalLastThroughputInKpps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 31), Unsigned32()).setUnits('Kpps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputInKpps.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputInKpps.setDescription('The object is the total throughput in Kpps in the last throughput utilization time interval that ended at ceipSecGlobalThroughputLastUpdatedTime.')
ceipSecGlobalLastThroughputUtilization = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 32), Unsigned32()).setUnits('Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputUtilization.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalLastThroughputUtilization.setDescription('The object is the throughput utilization in percentage in the last performance utilization time interval that ended at ceipSecGlobalThroughputLastUpdatedTime.')
ceipSecGlobalPeakThroughputUtilization = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 33), Unsigned32()).setUnits('Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputUtilization.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputUtilization.setDescription('The object is the peak throughput utilization in percentage since the managed system is active. It was observed in the throughput utilization time interval that ended at ceipSecGlobalPeakThroughputDateAndTime.')
ceipSecGlobalPeakThroughputDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 34), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputDateAndTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputDateAndTime.setDescription('The date and time when ceipSecGlobalPeakThroughputUtilization is updated.')
ceipSecGlobalPeakThroughputInMbps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 35), Unsigned32()).setUnits('Mbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputInMbps.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalPeakThroughputInMbps.setDescription('The object indicates the peak value of throughput in Mbps.')
ceipSecGlobalPeakAvgPacketSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 1, 36), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecGlobalPeakAvgPacketSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecGlobalPeakAvgPacketSize.setDescription('This object indicates the average packet size in bytes in the throughput utilization time interval that ended at ceipSecGlobalPeakThroughputDateAndTime.')
ceipSecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2), )
if mibBuilder.loadTexts: ceipSecTunnelTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelTable.setDescription('The IPsec Phase-2 Tunnel Table. There is one entry in this table for each active IPsec Phase-2 Tunnel.')
ceipSecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunIndex"))
if mibBuilder.loadTexts: ceipSecTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelEntry.setDescription('Each entry contains the attributes associated with an active IPsec Phase-2 Tunnel.')
ceipSecTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 1), CIPsecPhase2TunnelIndex())
if mibBuilder.loadTexts: ceipSecTunIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunIndex.setDescription('The index of the IPsec Phase-2 Tunnel Table. The value of the index is a number which begins at 1 and is incremented with each tunnel that is created. The value of this object will wrap at 2,147,483,647. Since this object must correspond to a valid Phase-2 IPsec tunnel, this object may not assume the value of 0.')
ceipSecTunLocalAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunLocalAddressType.setDescription('The type of the IP address of the local endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunLocalAddress.setDescription('The IP address of the local endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunRemoteAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunRemoteAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunRemoteAddressType.setDescription('The type of the IP address of the remote endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunRemoteAddress.setDescription('The IP address of the remote endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunControlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 6), CIPsecControlProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunControlProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunControlProtocol.setDescription("Identifies the protocol used to setup and administer this Phase-2 IPsec tunnel. In case this tunnel was spawned by an IPsec signaling protocol, this MIB object contains the value of the object 'cisgIpsSgProtocol' defined in CISCO-IPSEC-SIGNALING-MIB in the table 'cisgIpsSgTunnelTable' in the row corresponding to the control tunnel. A value of 'cpManual' is indicative of a manually installed and administered Phase-2 tunnel.")
ceipSecTunControlTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 7), CIPsecPhase1TunnelIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunControlTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunControlTunnelIndex.setDescription("The index of the associated IPsec Phase-1 Tunnel. In case this tunnel was spawned by an IPsec signaling protocol, this MIB object contains the value of the object 'cisgIpsSgTunIndex' defined in CISCO-IPSEC-SIGNALING-MIB in the table 'cisgIpsSgTunnelTable' in the row corresponding to the control tunnel. A value of 0 identifies that this Phase-2 tunnel was setup manually.")
ceipSecTunControlTunnelAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunControlTunnelAlive.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunControlTunnelAlive.setDescription('An indicator which specifies whether or not the IPsec Phase-1 Tunnel that spawned this Phase-2 tunnel currently exists.')
ceipSecTunEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 9), CIPsecEncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunEncapMode.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunEncapMode.setDescription('The encapsulation mode used by the IPsec Phase-2 Tunnel.')
ceipSecTunNATTraversalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 10), CIPsecNATTraversalMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunNATTraversalMode.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunNATTraversalMode.setDescription("The encapsulation used by the IPsec Phase-2 tunnel for NAT traversal. The value of this object is constrained based on the value of the column 'ceipSecTunEncapMode'. If the value of 'ceipSecTunEncapMode' is 'encapTransport', then this object may not assume the values 'natEncapIPsecOverUdp' or 'natEncapIPsecOverTcp'.")
ceipSecTunLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('KBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunLifeSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunLifeSize.setDescription('The negotiated LifeSize of the IPsec Phase-2 Tunnel in kilobytes.')
ceipSecTunLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 12), Unsigned32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunLifeTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunLifeTime.setDescription('The negotiated LifeTime of the IPsec Phase-2 Tunnel in seconds. If the tunnel was setup manually, the value of this MIB element should be 0.')
ceipSecTunActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 13), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunActiveTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunActiveTime.setDescription('The length of time the IPsec Phase-2 Tunnel has been active in hundredths of seconds.')
ceipSecTunSaLifeSizeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 14), Unsigned32()).setUnits('KBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaLifeSizeThreshold.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaLifeSizeThreshold.setDescription('The security association LifeSize refresh threshold in kilobytes. If the tunnel was setup manually, the value of this MIB element should be 0.')
ceipSecTunSaLifeTimeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 15), Unsigned32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaLifeTimeThreshold.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaLifeTimeThreshold.setDescription('The security association LifeTime refresh threshold in seconds. If the tunnel was setup manually, the value of this MIB element should be 0.')
ceipSecTunTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 16), Counter32()).setUnits('QM Exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunTotalRefreshes.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunTotalRefreshes.setDescription('The total number of security association refreshes performed.')
ceipSecTunExpiredSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 17), Counter32()).setUnits('SAs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunExpiredSaInstances.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunExpiredSaInstances.setDescription('The total number of security associations which have expired. If the tunnel was setup manually, the value of this MIB element should be 0.')
ceipSecTunCurrentSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunCurrentSaInstances.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunCurrentSaInstances.setDescription('The number of security associations which are currently active or expiring.')
ceipSecTunInSaDHGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 19), CIPsecDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaDHGrp.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaDHGrp.setDescription("The Diffie Hellman Group used by the inbound security association of the IPsec Phase-2 Tunnel. If the tunnel was setup manually, the value of this MIB element would be `none'.")
ceipSecTunInSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 20), CIPsecEncryptAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaEncryptAlgo.setDescription('The encryption algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunInSaEncryptKeySize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 21), CIPsecEncryptionKeySize()).setUnits('Bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaEncryptKeySize.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaEncryptKeySize.setDescription("The key size in bits of the negotiated key to be used with the algorithm denoted by 'ceipSecTunInSaEncryptAlgo'. For DES and 3DES the key size is respectively 56 and 168. For AES, this will denote the negotiated key size.")
ceipSecTunInSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 22), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaAhAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaAhAuthAlgo.setDescription('The authentication algorithm used by the inbound authentication header (AH) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunInSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 23), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaEspAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaEspAuthAlgo.setDescription('The authentication algorithm used by the inbound ecapsulation security protocol (ESP) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunInSaDecompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 24), CIPsecCompAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInSaDecompAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInSaDecompAlgo.setDescription('The decompression algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunOutSaDHGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 25), CIPsecDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaDHGrp.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaDHGrp.setDescription("The Diffie Hellman Group used by the outbound security association of the IPsec Phase-2 Tunnel. If the tunnel was setup manually, the value of this MIB element would be 'none'.")
ceipSecTunOutSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 26), CIPsecEncryptAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaEncryptAlgo.setDescription('The encryption algorithm used by the outbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunOutSaEncryptKeySize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 27), CIPsecEncryptionKeySize()).setUnits('Bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaEncryptKeySize.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaEncryptKeySize.setDescription("The key size in bits of the negotiated key to be used with the algorithm denoted by 'ceipSecTunOutSaEncryptAlgo'. For DES and 3DES the key size is respectively 56 and 168. For AES, this will denote the negotiated key size.")
ceipSecTunOutSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 28), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaAhAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaAhAuthAlgo.setDescription('The authentication algorithm used by the outbound authentication header (AH) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunOutSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 29), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaEspAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaEspAuthAlgo.setDescription('The authentication algorithm used by the inbound encapsulation security protocol (ESP) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunOutSaCompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 30), CIPsecCompAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutSaCompAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutSaCompAlgo.setDescription('The compression algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunPmtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 31), CIPsecPmtu()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunPmtu.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunPmtu.setDescription('The Path MTU for this IPsec Phase-2 tunnel, which has been either learnt from the network or which has been specified by the administrator. The lower end of the range is 68 which is the minimum MTU for IPv4.')
ceipSecTunInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 32), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInOctets.setDescription('A high capacity count of the total number of octets received by this IPsec Phase-2 Tunnel. This value is accumulated BEFORE determining whether or not the packet should be decompressed.')
ceipSecTunInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInDecompOctets.setDescription('A high capacity count of the total number of decompressed octets received by this IPsec Phase-2 Tunnel. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ceipSecTunInOctets.')
ceipSecTunInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 34), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInPkts.setDescription('The total number of packets received by this IPsec Phase-2 Tunnel.')
ceipSecTunInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 35), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInDropPkts.setDescription('The total number of packets dropped during receive processing by this IPsec Phase-2 Tunnel. This count does NOT include packets dropped due to Anti-Replay processing.')
ceipSecTunInReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 36), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInReplayDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInReplayDropPkts.setDescription('The total number of packets dropped during receive processing due to Anti-Replay processing by this IPsec Phase-2 Tunnel.')
ceipSecTunInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 37), Counter32()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInAuths.setDescription("The total number of inbound authentication's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 38), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInAuthFails.setDescription("The total number of inbound authentication's which ended in failure by this IPsec Phase-2 Tunnel .")
ceipSecTunInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 39), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInDecrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInDecrypts.setDescription("The total number of inbound decryption's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 40), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunInDecryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunInDecryptFails.setDescription("The total number of inbound decryption's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 41), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutOctets.setDescription('A high capacity count of the total number of octets sent by this IPsec Phase-2 Tunnel. This value is accumulated AFTER determining whether or not the packet should be compressed.')
ceipSecTunOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutUncompOctets.setDescription('A high capacity count of the total number of uncompressed octets sent by this IPsec Phase-2 Tunnel. This value is accumulated BEFORE the packet is compressed. If compression is not being used, this value will match the value of ceipSecTunOutOctets.')
ceipSecTunOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 43), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutPkts.setDescription('The total number of packets sent by this IPsec Phase-2 Tunnel.')
ceipSecTunOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 44), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutDropPkts.setDescription('The total number of packets dropped during send processing by this IPsec Phase-2 Tunnel.')
ceipSecTunOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 45), Counter32()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutAuths.setDescription("The total number of outbound authentication's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 46), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutAuthFails.setDescription("The total number of outbound authentication's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 47), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutEncrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutEncrypts.setDescription("The total number of outbound encryption's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 48), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutEncryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutEncryptFails.setDescription("The total number of outbound encryption's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunOutCompressedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 49), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutCompressedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutCompressedPkts.setDescription('The total number of outbound packets which were successfully compressed.')
ceipSecTunOutCompSkippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 50), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutCompSkippedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutCompSkippedPkts.setDescription('The total number of outbound packets that were to be compressed but which were skipped due to the compression hysteresis.')
ceipSecTunOutCompFailPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 51), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutCompFailPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutCompFailPkts.setDescription('The total number of outbound packets that failed compression because they grew in size after compression.')
ceipSecTunOutCompTooSmallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 52), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunOutCompTooSmallPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunOutCompTooSmallPkts.setDescription('The total number of outbound packets that were to be compressed but were smaller than the compression threshold size.')
ceipSecIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 53), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecIfIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecIfIndex.setDescription('This object represents the ifIndex of an interface where this tunnel is created. Multiple IPsec tunnels can be created using the same interface.')
ceipSecTunStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 2, 1, 54), CIPsecTunnelStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecTunStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunStatus.setDescription('The status of the MIB table row. This object can be used to bring the tunnel down or force a rekeying. When the value is set to destroy(5), the SA bundle is destroyed and this row is deleted from this table. When the value is set to rekey(6), then rekeying is forced on this tunnel. When this MIB value is queried, the value of active(4) is always returned, if the instance exists. This object cannot be used to create a MIB table row.')
ceipSecEndPtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3), )
if mibBuilder.loadTexts: ceipSecEndPtTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtTable.setDescription('The IPsec Phase-2 Tunnel Endpoint Table. This table contains an entry for each active endpoint associated with an IPsec Phase-2 Tunnel.')
ceipSecEndPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunIndex"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtIndex"))
if mibBuilder.loadTexts: ceipSecEndPtEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtEntry.setDescription('An IPsec Phase-2 Tunnel Endpoint entry.')
ceipSecEndPtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecEndPtIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtIndex.setDescription('The number of the Endpoint associated with the IPsec Phase-2 Tunnel Table. The value of this index is a number which begins at one and is incremented with each Endpoint associated with an IPsec Phase-2 Tunnel. The value of this object will wrap at 4,294,967,295.')
ceipSecEndPtLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalName.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalName.setDescription('The DNS name of the local Endpoint.')
ceipSecEndPtLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 3), CIPsecEndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalType.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalType.setDescription('The type of identity for the local Endpoint.')
ceipSecEndPtLocalAddrType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalAddrType1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalAddrType1.setDescription("The type of the IP address for this local Endpoint's first IP address.")
ceipSecEndPtLocalAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalAddr1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalAddr1.setDescription("The local Endpoint's first IP address specification. If the local Endpoint type is single IP address, then this is the value of the IP address. If the local Endpoint type is IP subnet, then this is the value of the subnet. If the local Endpoint type is IP address range, then this is the value of beginning IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from ceipSecEndPtLocalType.")
ceipSecEndPtLocalAddrType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalAddrType2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalAddrType2.setDescription("The type of the IP address for this local Endpoint's second IP address.")
ceipSecEndPtLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalAddr2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalAddr2.setDescription("The local Endpoint's second IP address specification. If the local Endpoint type is single IP address, then this is the value of the IP address. If the local Endpoint type is IP subnet, then this is the value of the subnet mask. If the local Endpoint type is IP address range, then this is the value of ending IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from ceipSecEndPtLocalType.")
ceipSecEndPtLocalProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 8), CiscoIpProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalProtocol.setDescription("The protocol number of the local Endpoint's traffic.")
ceipSecEndPtLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 9), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtLocalPort.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtLocalPort.setDescription("The port number of the local Endpoint's traffic.")
ceipSecEndPtRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteName.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteName.setDescription('The DNS name of the remote Endpoint.')
ceipSecEndPtRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 11), CIPsecEndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteType.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteType.setDescription('The type of identity for the remote Endpoint.')
ceipSecEndPtRemoteAddrType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 12), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddrType1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddrType1.setDescription("The type of the IP address for this remote Endpoint's first IP address.")
ceipSecEndPtRemoteAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddr1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddr1.setDescription("The remote Endpoint's first IP address specification. If the remote Endpoint type is single IP address, then this is the value of the IP address. If the remote Endpoint type is IP subnet, then this is the value of the subnet. If the remote Endpoint type is IP address range, then this is the value of beginning IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from ceipSecEndPtRemoteType.")
ceipSecEndPtRemoteAddrType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 14), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddrType2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddrType2.setDescription("The type of the IP address for this remote Endpoint's second IP address.")
ceipSecEndPtRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 15), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddr2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteAddr2.setDescription("The remote Endpoint's second IP address specification. If the remote Endpoint type is single IP address, then this is the value of the IP address. If the remote Endpoint type is IP subnet, then this is the value of the subnet mask. If the remote Endpoint type is IP address range, then this is the value of ending IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from ceipSecEndPtRemoteType.")
ceipSecEndPtRemoteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 16), CiscoIpProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemoteProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemoteProtocol.setDescription("The protocol number of the remote Endpoint's traffic.")
ceipSecEndPtRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 3, 1, 17), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtRemotePort.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtRemotePort.setDescription("The port number of the remote Endpoint's traffic.")
ceipSecSaTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4), )
if mibBuilder.loadTexts: ceipSecSaTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaTable.setDescription('The IPsec Phase-2 Security Association Table. This table identifies the structure (in terms of component SAs) of each active Phase-2 IPsec tunnel. This table contains an entry for each active and expiring security association and maps each entry in the active Phase-2 tunnel table (ceipSecTunTable) into a number of entries in this table. The index of this table reflects the <destination-address, protocol, spi> rule for identifying Security Associations.')
ceipSecSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunIndex"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecSaProtocol"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecSaIndex"))
if mibBuilder.loadTexts: ceipSecSaEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaEntry.setDescription('Each entry contains the attributes associated with active and expiring IPsec Phase-2 security associations.')
ceipSecSaProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1, 1), CIPsecProtocol())
if mibBuilder.loadTexts: ceipSecSaProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaProtocol.setDescription('This column represents the security protocol (AH, ESP or IPComp) for which this security association was setup.')
ceipSecSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecSaIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaIndex.setDescription("The object, in the context of the IPsec tunnel 'ceipSecTunIndex', is an index of security associations comprising the Phase-2 IPsec tunnel represented by the tunnel index 'ceipSecTunIndex'. The value of this index is a number which begins at 1 and is incremented with each SPI associated with the corresponding IPsec Phase-2 Tunnel.")
ceipSecSaDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1, 3), CIPsecPhase2SaDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecSaDirection.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaDirection.setDescription('Phase-2 IPsec security associations are simplex. Hence a particular security association is used either for securing outgoing traffic or decoding incoming traffic. This column identifies the direction of the security association represented by this entry.')
ceipSecSaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1, 4), CIPsecSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecSaValue.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaValue.setDescription('This is the value of the Security Protection Index (SPI) assigned by the system to the security association represented by this entry.')
ceipSecSaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("expiring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecSaStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecSaStatus.setDescription("This column represents the status of the security association represented by this conceptual row. If the status of the SA is 'active', the SA is ready for active use. The status 'expiring' represents any of the various states that the security association transitions through before being purged.")
ceipSecTunnelSaTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5), )
if mibBuilder.loadTexts: ceipSecTunnelSaTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelSaTable.setDescription("The IPsec Phase-2 Tunnel Security Association Table. This table identifies the SAs that are currently associated with an active Phase-2 tunnel. This table contains an entry for each active or expiring security association (SA) which is associated with an ceipSecTunnelEntry in 'active' state and provides statistic information of this SA. There might be multiple SAs associated with one ceipSecTunnelEntry.")
ceipSecTunnelSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunIndex"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaProtocol"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaIndex"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaDirection"))
if mibBuilder.loadTexts: ceipSecTunnelSaEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelSaEntry.setDescription('Each entry contains the attributes and statistics associated with an active or expiring IPsec Phase-2 security associations.')
ceipSecTunSaProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 1), CIPsecProtocol())
if mibBuilder.loadTexts: ceipSecTunSaProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaProtocol.setDescription('This column represents the security protocol (AH, ESP or IPComp) for which this security association was setup.')
ceipSecTunSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecTunSaIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaIndex.setDescription("The object, in the context of the IPsec tunnel 'ceipSecTunIndex', is an index of security associations comprising the Phase-2 IPsec tunnel represented by the tunnel index 'ceipSecTunIndex'. The value of this index is a number which begins at 1 and is incremented with each SPI associated with the corresponding IPsec Phase-2 Tunnel.")
ceipSecTunSaDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 3), CIPsecPhase2SaDirection())
if mibBuilder.loadTexts: ceipSecTunSaDirection.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaDirection.setDescription('Phase-2 IPsec security associations are simplex. Hence a particular security association is used either for securing outgoing traffic or decoding incoming traffic. This column identifies the direction of the security association represented by this entry.')
ceipSecTunSaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 4), CIPsecSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaValue.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaValue.setDescription('This is the value of the Security Protection Index (SPI) assigned by the system to the security association represented by this entry.')
ceipSecTunSaIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 5), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaIfIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaIfIndex.setDescription('This object represents the ifIndex of an interface where a tunnel with ceipSecTunIndex is created. Multiple IPsec tunnels can be created using the same interface.')
ceipSecTunSaInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInOctets.setDescription('A high capacity count of the total number of octets received by using this SA. This value is accumulated BEFORE determining whether or not the packet should be decompressed.')
ceipSecTunSaInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInDecompOctets.setDescription('A high capacity count of the total number of decompressed octets received by using this SA. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ceipSecTunSaTunInOctets.')
ceipSecTunSaInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInPkts.setDescription('The total number of packets received by using this SA.')
ceipSecTunSaInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInDropPkts.setDescription('The total number of packets dropped during receive process by using this SA. This count does NOT include packets dropped due to Anti-Replay processing.')
ceipSecTunSaInReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInReplayDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInReplayDropPkts.setDescription('The total number of packets dropped during receive processing due to Anti-Replay processing by using this SA.')
ceipSecTunSaInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInAuths.setDescription("The total number of inbound authentication's performed by using this SA.")
ceipSecTunSaInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInAuthFails.setDescription("The total number of inbound authentication's which ended in failure by using this SA.")
ceipSecTunSaInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInDecrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInDecrypts.setDescription("The total number of inbound decryption's performed by this SA.")
ceipSecTunSaInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaInDecryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaInDecryptFails.setDescription("The total number of inbound decryption's which ended in failure by using this SA.")
ceipSecTunSaOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutOctets.setDescription('A high capacity count of the total number of octets sent by using this SA. This value is accumulated AFTER determining whether or not the packet should be compressed.')
ceipSecTunSaOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutUncompOctets.setDescription('A high capacity count of the total number of uncompressed octets sent by using this SA. This value is accumulated BEFORE the packet is compressed. If compression is not being used, this value will match the value of ceipSecTunSaTunOutOctets.')
ceipSecTunSaOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutPkts.setDescription('The total number of packets sent by using this SA.')
ceipSecTunSaOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutDropPkts.setDescription('The total number of packets dropped during send processing by using this SA.')
ceipSecTunSaOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutAuths.setDescription("The total number of outbound authentication's performed by using this SA.")
ceipSecTunSaOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutAuthFails.setDescription("The total number of outbound authentication's which ended in failure by using this SA.")
ceipSecTunSaOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutEncrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutEncrypts.setDescription("The total number of outbound encryption's performed by using this SA.")
ceipSecTunSaOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutEncryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutEncryptFails.setDescription("The total number of outbound encryption's which ended in failure by using this SA.")
ceipSecTunSaOutCompressedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutCompressedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutCompressedPkts.setDescription('The total number of outbound packets which were successfully compressed by using this SA.')
ceipSecTunSaOutCompSkippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutCompSkippedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutCompSkippedPkts.setDescription('The total number of outbound packets that were to be compressed but which were skipped due to the compression hysteresis when using this SA.')
ceipSecTunSaOutCompFailPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutCompFailPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutCompFailPkts.setDescription('The total number of outbound packets that failed compression because they grew in size after compression when using this SA.')
ceipSecTunSaOutCompTooSmallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaOutCompTooSmallPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaOutCompTooSmallPkts.setDescription('The total number of outbound packets that were to be compressed but were smaller than the compression threshold size when using this SA.')
ceipSecTunSaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("expiring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunSaStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunSaStatus.setDescription("This column represents the status of the security association represented by this conceptual row. If the status of the SA is 'active', the SA is ready for active use. The status 'expiring' represents any of the various states that the security association transitions through before being purged.")
ceipSecIfTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 6), )
if mibBuilder.loadTexts: ceipSecIfTunnelTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecIfTunnelTable.setDescription('The IPsec Phase-2 Tunnels to Interface association table. This table contains an entry for each active IPsec Phase-2 Tunnel created under an interface. Multiple IPsec Phase-2 Tunnels can be created using the same interface.')
ceipSecIfTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunIndex"))
if mibBuilder.loadTexts: ceipSecIfTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecIfTunnelEntry.setDescription('Each entry contains the IPsec Phase-2 Tunnel associated with an interface.')
ceipSecIfTunnelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 1, 6, 1, 1), CIPsecTunnelStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecIfTunnelStatus.setStatus('current')
if mibBuilder.loadTexts: ceipSecIfTunnelStatus.setDescription("This object corresponds to the status of a IPsec Phase-2 Tunnel in ceipSecTunnelTable indexed by ceipSecTunIndex. The valid status this object can have are 'active' and 'awaitCommit'.")
ceipSecHistGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 1))
ceipSecHistGlobalCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 1, 1))
ceipSecHistTableSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 1, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecHistTableSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecHistTableSize.setDescription("The window size of the IPsec Phase-2 History Tables. The IPsec Phase-2 History Tables are implemented as a sliding window in which only the last 'N' entries are maintained. This object is used specify the number of entries which will be maintained in the IPsec Phase-2 History Tables. An implementation may choose suitable minimum and maximum values for this element based on the local policy and available resources. If an SNMP SET request specifies a value outside this window for this element, in appropriate SNMP error code should be returned. Setting this value to zero is equivalent to deleting all conceptual rows in the archiving tables ('ceipSecHistTable' and 'ceipSecEndPtHistTable') and disabling the archiving of entries in the tables.")
ceipSecTunnelHistTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2), )
if mibBuilder.loadTexts: ceipSecTunnelHistTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelHistTable.setDescription("The IPsec Phase-2 Tunnel History Table. This table is conceptually a sliding window in which only the last 'N' entries are maintained, where 'N' is the value of the object 'ceipSecHistTableSize'. If the value of 'ceipSecHistTableSize' is 0, archiving of entries in this table is disabled.")
ceipSecTunnelHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistIndex"))
if mibBuilder.loadTexts: ceipSecTunnelHistEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunnelHistEntry.setDescription('Each entry contains the attributes associated with a previously active IPsec Phase-2 Tunnel.')
ceipSecTunHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecTunHistIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistIndex.setDescription('The index of the IPsec Phase-2 Tunnel History Table. The value of the index is a number which begins at one and is incremented with each tunnel that ends. The value of this object will wrap at 4,294,967,295.')
ceipSecTunHistTermReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("operRequest", 3), ("peerDelRequest", 4), ("peerLost", 5), ("applicationInitiated", 6), ("xauthFailure", 7), ("seqNumRollOver", 8), ("checkPointReq", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistTermReason.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistTermReason.setDescription('The reason the IPsec Phase-2 Tunnel was terminated. Possible reasons include: 1 = other 2 = normal termination 3 = operator request 4 = peer delete request was received 5 = contact with peer was lost 6 = applicationInitiated (eg: L2TP requesting the termination) 7 = failure of extended authentication 8 = local failure occurred 9 = operator initiated check point request')
ceipSecTunHistActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 3), CIPsecPhase2TunnelIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistActiveIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistActiveIndex.setDescription('The index of the previously active IPsec Phase-2 Tunnel. This object must correspond to an expired IPsec tunnel; hence this object may not assume the value of 0.')
ceipSecTunHistLocalAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistLocalAddressType.setDescription('The type of the IP address of the local endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunHistLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistLocalAddress.setDescription('The IP address of the local endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunHistRemoteAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistRemoteAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistRemoteAddressType.setDescription('The type of the IP address of the remote endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunHistRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistRemoteAddress.setDescription('The IP address of the remote endpoint for the IPsec Phase-2 Tunnel.')
ceipSecTunHistControlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 8), CIPsecControlProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistControlProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistControlProtocol.setDescription('Identifies the protocol that was used to setup and administer Phase-2 IPsec tunnel.')
ceipSecTunHistControlTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 9), CIPsecPhase1TunnelIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistControlTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistControlTunnelIndex.setDescription("The index of the IPsec Phase-1 Tunnel that spawned this Phase-2 tunnel (in case of IKE, this value would refer to 'csikeTunIndex' in the 'csikeTunnelTable'). If the IPsec tunnel corresponding to this entry was setup manually, the value of this object should be zero.")
ceipSecTunHistEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 10), CIPsecEncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistEncapMode.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistEncapMode.setDescription('The encapsulation mode used by the IPsec Phase-2 Tunnel.')
ceipSecTunHistNATTraversalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 11), CIPsecNATTraversalMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistNATTraversalMode.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistNATTraversalMode.setDescription('The encapsulation used by the IPsec Phase-2 tunnel corresponding to this conceptual row for NAT traversal.')
ceipSecTunHistLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('KBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistLifeSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistLifeSize.setDescription('The negotiated LifeSize of the IPsec Phase-2 Tunnel in kilobytes.')
ceipSecTunHistLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistLifeTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistLifeTime.setDescription('The negotiated LifeTime of the IPsec Phase-2 Tunnel in seconds.')
ceipSecTunHistStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistStartTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistStartTime.setDescription('The value of sysUpTime in hundredths of seconds when the IPsec Phase-2 Tunnel was started.')
ceipSecTunHistActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 15), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistActiveTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistActiveTime.setDescription('The length of time the IPsec Phase-2 Tunnel has been active in hundredths of seconds.')
ceipSecTunHistTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 16), Counter32()).setUnits('QM Exchanges').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistTotalRefreshes.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistTotalRefreshes.setDescription('The total number of security association refreshes performed.')
ceipSecTunHistTotalSas = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 17), Counter32()).setUnits('SAs').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistTotalSas.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistTotalSas.setDescription('The total number of security associations used during the life of the IPsec Phase-2 Tunnel.')
ceipSecTunHistInSaDHGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 18), CIPsecDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaDHGrp.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaDHGrp.setDescription('The Diffie Hellman Group used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistInSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 19), CIPsecEncryptAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaEncryptAlgo.setDescription('The encryption algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistInSaEncryptKeySize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 20), CIPsecEncryptionKeySize()).setUnits('Bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaEncryptKeySize.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaEncryptKeySize.setDescription('The size in bits of the key which was negotiated to be used with the encryption transform used with this tunnel denoted by ceipSecTunHistInSaEncryptAlgo. For DES and 3DES the key size is respectively 56 and 168. For AES, this will denote the negotiated key size.')
ceipSecTunHistInSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 21), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaAhAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaAhAuthAlgo.setDescription('The authentication algorithm used by the inbound authentication header (AH) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistInSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 22), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaEspAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaEspAuthAlgo.setDescription('The authentication algorithm used by the inbound encapsulation security protocol (ESP) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistInSaDecompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 23), CIPsecCompAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInSaDecompAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInSaDecompAlgo.setDescription('The decompression algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistOutSaDHGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 24), CIPsecDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaDHGrp.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaDHGrp.setDescription('The Diffie Hellman Group used by the outbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistOutSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 25), CIPsecEncryptAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaEncryptAlgo.setDescription('The encryption algorithm used by the outbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistOutSaEncryptKeySz = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 26), CIPsecEncryptionKeySize()).setUnits('Bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaEncryptKeySz.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaEncryptKeySz.setDescription('The size in bits of the key which was negotiated to be used with the encryption transform used with this tunnel denoted by ceipSecTunHistOutSaEncryptAlgo. For DES and 3DES the key size is respectively 56 and 168. For AES, this will denote the negotiated key size.')
ceipSecTunHistOutSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 27), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaAhAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaAhAuthAlgo.setDescription('The authentication algorithm used by the outbound authentication header (AH) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistOutSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 28), CIPsecAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaEspAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaEspAuthAlgo.setDescription('The authentication algorithm used by the inbound ecapsulation security protocol (ESP) security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistOutSaCompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 29), CIPsecCompAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutSaCompAlgo.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutSaCompAlgo.setDescription('The compression algorithm used by the inbound security association of the IPsec Phase-2 Tunnel.')
ceipSecTunHistPmtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 30), CIPsecPmtu()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistPmtu.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistPmtu.setDescription('The Path MTU that was determined for this IPsec Phase-2 tunnel.')
ceipSecTunHistInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInOctets.setDescription('A high capacity count of the total number of octets received by this IPsec Phase-2 Tunnel. This value is accumulated BEFORE determining whether or not the packet should be decompressed.')
ceipSecTunHistInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInDecompOctets.setDescription('A high capacity count of the total number of decompressed octets received by this IPsec Phase-2 Tunnel. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ceipSecTunInOctets.')
ceipSecTunHistInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 33), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInPkts.setDescription('The total number of packets received by this IPsec Phase-2 Tunnel.')
ceipSecTunHistInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 34), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInDropPkts.setDescription('The total number of packets dropped during receive processing by this IPsec Phase-2 Tunnel. This count does NOT include packets dropped due to Anti-Replay processing.')
ceipSecTunHistInReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 35), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInReplayDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInReplayDropPkts.setDescription('The total number of packets dropped during receive processing due to Anti-Replay processing by this IPsec Phase-2 Tunnel.')
ceipSecTunHistInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 36), Counter32()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInAuths.setDescription("The total number of inbound authentication's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunHistInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 37), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInAuthFails.setDescription("The total number of inbound authentication's which ended in failure by this IPsec Phase-2 Tunnel .")
ceipSecTunHistInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 38), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInDecrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInDecrypts.setDescription("The total number of inbound decryption's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunHistInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 39), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistInDecryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistInDecryptFails.setDescription("The total number of inbound decryption's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunHistOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutOctets.setDescription('A high capacity count of the total number of octets sent by this IPsec Phase-2 Tunnel. This value is accumulated AFTER determining whether or not the packet should be compressed.')
ceipSecTunHistOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 41), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutUncompOctets.setDescription("A high capacity count of the total number of uncompressed octets sent by this IPsec Phase-2 Tunnel. This value is accumulated BEFORE the packet is compressed. If compression is not being used, this value will match the value of 'ceipSecTunOutOctets'.")
ceipSecTunHistOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 42), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutPkts.setDescription('The total number of packets sent by this IPsec Phase-2 Tunnel.')
ceipSecTunHistOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 43), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutDropPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutDropPkts.setDescription('The total number of packets dropped during send processing by this IPsec Phase-2 Tunnel.')
ceipSecTunHistOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 44), Counter32()).setUnits('Events').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutAuths.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutAuths.setDescription("The total number of outbound authentication's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunHistOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 45), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutAuthFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutAuthFails.setDescription("The total number of outbound authentication's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunHistOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 46), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutEncrypts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutEncrypts.setDescription("The total number of outbound encryption's performed by this IPsec Phase-2 Tunnel.")
ceipSecTunHistOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 47), Counter32()).setUnits('Failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutEncryptFails.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutEncryptFails.setDescription("The total number of outbound encryption's which ended in failure by this IPsec Phase-2 Tunnel.")
ceipSecTunHistOutCompressedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 48), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutCompressedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutCompressedPkts.setDescription('The total number of outbound packets which were successfully compressed.')
ceipSecTunHistOutCompSkippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 49), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutCompSkippedPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutCompSkippedPkts.setDescription('The total number of outbound packets that were to be compressed but which were skipped due to the compression hysteresis.')
ceipSecTunHistOutCompFailPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 50), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutCompFailPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutCompFailPkts.setDescription('The total number of outbound packets that failed compression because they grew in size after compression.')
ceipSecTunHistOutCompSmallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 2, 1, 51), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecTunHistOutCompSmallPkts.setStatus('current')
if mibBuilder.loadTexts: ceipSecTunHistOutCompSmallPkts.setDescription('The total number of outbound packets that were to be compressed but were smaller than the compression threshold size.')
ceipSecEndPtHistTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3), )
if mibBuilder.loadTexts: ceipSecEndPtHistTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistTable.setDescription("The IPsec Phase-2 Tunnel Endpoint History Table. This table is conceptually a sliding window in which only the last 'N' entries are maintained, where 'N' is the value of the object 'ceipSecHistTableSize'. If the value of 'ceipSecHistTableSize' is 0, archiving of entries in this table is disabled.")
ceipSecEndPtHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistIndex"))
if mibBuilder.loadTexts: ceipSecEndPtHistEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistEntry.setDescription('Each entry contains the attributes associated with a previously active IPsec Phase-2 Tunnel Endpoint.')
ceipSecEndPtHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecEndPtHistIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistIndex.setDescription('The number of the previously active Endpoint associated with a IPsec Phase-2 Tunnel Table. The value of this index is a number which begins at one and is incremented with each Endpoint associated with an IPsec Phase-2 Tunnel. The value of this object will wrap at 4,294,967,295.')
ceipSecEndPtHistTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistTunIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistTunIndex.setDescription('The index of the previously active IPsec Phase-2 Tunnel Table.')
ceipSecEndPtHistActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistActiveIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistActiveIndex.setDescription('The index of the previously active Endpoint.')
ceipSecEndPtHistLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalName.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalName.setDescription('The DNS name of the local Endpoint.')
ceipSecEndPtHistLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 5), CIPsecEndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalType.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalType.setDescription('The type of identity for the local Endpoint.')
ceipSecEndPtHistLocalAddrType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddrType1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddrType1.setDescription("The type of the IP address for this local Endpoint's first IP address.")
ceipSecEndPtHistLocalAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddr1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddr1.setDescription("The local Endpoint's first IP address specification. If the local Endpoint type is single IP address, then this is the value of the IP address. If the local Endpoint type is IP subnet, then this is the value of the subnet. If the local Endpoint type is IP address range, then this is the value of beginning IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from cceipSecEndPtLocalType.")
ceipSecEndPtHistLocalAddrType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddrType2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddrType2.setDescription("The type of the IP address for this local Endpoint's second IP address.")
ceipSecEndPtHistLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddr2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalAddr2.setDescription("The local Endpoint's second IP address specification. If the local Endpoint type is single IP address, then this is the value of the IP address. If the local Endpoint type is IP subnet, then this is the value of the subnet mask. If the local Endpoint type is IP address range, then this is the value of ending IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from cceipSecEndPtLocalType.")
ceipSecEndPtHistLocalProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 10), CiscoIpProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalProtocol.setDescription("The protocol number of the local Endpoint's traffic.")
ceipSecEndPtHistLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 11), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistLocalPort.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistLocalPort.setDescription("The port number of the local Endpoint's traffic.")
ceipSecEndPtHistRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 12), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteName.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteName.setDescription('The DNS name of the remote Endpoint.')
ceipSecEndPtHistRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 13), CIPsecEndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteType.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteType.setDescription('The type of identity for the remote Endpoint.')
ceipSecEndPtHistRemoteAddrType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 14), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddrType1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddrType1.setDescription("The type of the IP address for this remote Endpoint's first IP address.")
ceipSecEndPtHistRemoteAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 15), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddr1.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddr1.setDescription("The remote Endpoint's first IP address specification. If the remote Endpoint type is single IP address, then this is the value of the IP address. If the remote Endpoint type is IP subnet, then this is the value of the subnet. If the remote Endpoint type is IP address range, then this is the value of beginning IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from cceipSecEndPtRemoteType.")
ceipSecEndPtHistRemoteAddrType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 16), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddrType2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddrType2.setDescription("The type of the IP address for this remote Endpoint's second IP address.")
ceipSecEndPtHistRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 17), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddr2.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteAddr2.setDescription("The remote Endpoint's second IP address specification. If the remote Endpoint type is single IP address, then this is the value of the IP address. If the remote Endpoint type is IP subnet, then this is the value of the subnet mask. If the remote Endpoint type is IP address range, then this is the value of ending IP address of the range. If the type is an IP address, a range or a subnet, the type of the address can be inferred from cceipSecEndPtRemoteType.")
ceipSecEndPtHistRemoteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 18), CiscoIpProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteProtocol.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemoteProtocol.setDescription("The protocol number of the remote Endpoint's traffic.")
ceipSecEndPtHistRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 2, 3, 1, 19), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecEndPtHistRemotePort.setStatus('current')
if mibBuilder.loadTexts: ceipSecEndPtHistRemotePort.setDescription("The port number of the remote Endpoint's traffic.")
ceipSecFailGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 1))
ceipSecFailGlobalCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 1, 1))
ceipSecFailTableSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 1, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecFailTableSize.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailTableSize.setDescription("The window size of the IPsec Phase-2 Failure Table. The IPsec Phase-2 Failure Tables are implemented as a sliding window in which only the last N entries are maintained. This object is used specify the number of entries which will be maintained in the IPsec Phase-2 Failure Tables. An implementation may choose suitable minimum and maximum values for this element based on the local policy and available resources. If an SNMP SET request specifies a value outside this window for this element, an appropriate SNMP error vode must be returned. Setting this value to zero is equivalent to deleting all conceptual rows in the archiving table 'ceipSecFailTable' and disabling the archiving of entries in these tables.")
ceipSecFailTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2), )
if mibBuilder.loadTexts: ceipSecFailTable.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailTable.setDescription('The IPsec Phase-2 Failure Table. This table is implemented as a sliding window in which only the last n entries are maintained. The maximum number of entries is specified by the ceipSecFailTableSize object.')
ceipSecFailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailIndex"))
if mibBuilder.loadTexts: ceipSecFailEntry.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailEntry.setDescription('Each entry contains the attributes associated with an IPsec Phase-1 failure.')
ceipSecFailIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ceipSecFailIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailIndex.setDescription('The IPsec Phase-2 Failure Table index. The value of the index is a number which begins at one and is incremented with each IPsec Phase-1 failure. The value of this object will wrap at 4,294,967,295.')
ceipSecFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("other", 1), ("internalError", 2), ("peerEncodingError", 3), ("proposalFailure", 4), ("protocolUseFail", 5), ("nonExistentSa", 6), ("decryptFailure", 7), ("encryptFailure", 8), ("inAuthFailure", 9), ("outAuthFailure", 10), ("compression", 11), ("sysCapExceeded", 12), ("peerDelRequest", 13), ("peerLost", 14), ("seqNumRollOver", 15), ("operRequest", 16), ("performanceUtilization", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailReason.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailReason.setDescription('The reason for the failure. Possible reasons include: 1 = other 2 = internal error occurred 3 = peer encoding error 4 = proposal failure 5 = protocol use failure 6 = non-existent security association 7 = decryption failure 8 = encryption failure 9 = inbound authentication failure 10 = outbound authentication failure 11 = compression failure 12 = system capacity failure 13 = peer delete request was received 14 = contact with peer was lost 15 = sequence number rolled over 16 = operator requested termination 17 = performance utilization exceeding the threshold.')
ceipSecFailTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailTime.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailTime.setDescription('The value of sysUpTime in hundredths of seconds at the time of the failure.')
ceipSecFailTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 4), CIPsecPhase2TunnelIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailTunnelIndex.setDescription('The Phase-2 Tunnel index (ceipSecTunIndex). If this conceptual row corresponds to an operation failure (that is, the failure of an established Phase-2 IPsec tunnel), then the value of this object may not be zero.')
ceipSecFailSaSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 5), CIPsecSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailSaSpi.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailSaSpi.setDescription('The security association SPI value. If this conceptual row corresponds to a setup failure (failure to establish the tunnel), the value of this MIB object is undefined.')
ceipSecFailPktSrcAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailPktSrcAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailPktSrcAddressType.setDescription("The type of the packet's source IP address.")
ceipSecFailPktSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailPktSrcAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailPktSrcAddress.setDescription("The packet's source IP address.")
ceipSecFailPktDstAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailPktDstAddressType.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailPktDstAddressType.setDescription("The type of the packet's destination IP address.")
ceipSecFailPktDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 3, 2, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceipSecFailPktDstAddress.setStatus('current')
if mibBuilder.loadTexts: ceipSecFailPktDstAddress.setDescription("The packet's destination IP address.")
ceipSecNotiCntlIpSecAllNotifs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotiCntlIpSecAllNotifs.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotiCntlIpSecAllNotifs.setDescription("This object sending any notification defined in this MIB module. That is, a particular notification 'foo' defined in this MIB module is enabled if and only if the expression (ceipSecNotiCntlIpSecAllNotifs && ceipSecNotiCntl<foo>) evaluates to 'true', where ceipSecNotiCntl<foo> is a notification defined in this MIB module.")
ceipSecNotifCntlIpSecTunnelStart = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecTunnelStart.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecTunnelStart.setDescription("This object defines the administrative state of sending the IPsec Phase-2 Tunnel Start TRAP. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowTunnelStart' is enabled.")
ceipSecNotifCntlIpSecTunnelStop = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecTunnelStop.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecTunnelStop.setDescription("This object defines the administrative state of sending the IPsec Phase-2 Tunnel Stop TRAP. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowTunnelStop' is enabled.")
ceipSecNotifCntlIpSecSysFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecSysFailure.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecSysFailure.setDescription("This object defines the administrative state of sending the IPsec Phase-2 System Failure TRAP. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowSysFailure' is enabled.")
ceipSecNotifCntlIpSecSetUpFail = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecSetUpFail.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecSetUpFail.setDescription("This object defines the administrative state of sending the IPsec Phase-2 Set Up Failure TRAP. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowSetupFail' is enabled.")
ceipSecNotifCntlIpSecBadSa = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecBadSa.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlIpSecBadSa.setDescription("This object defines the administrative state of sending the IPsec Phase-2 No Security Association trap. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowBadSa' is enabled.")
ceipSecNotifCntlCertExpiry = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlCertExpiry.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlCertExpiry.setDescription("This object defines the administrative state of sending the IPSec certificate expiry notification. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowCertExpiry' is enabled, otherwise notification 'ciscoEnhIpsecFlowCertExpiry' is disabled.")
ceipSecNotifCntlCertRenewal = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 432, 1, 5, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ceipSecNotifCntlCertRenewal.setStatus('current')
if mibBuilder.loadTexts: ceipSecNotifCntlCertRenewal.setDescription("This object defines the administrative state of sending the IPSec X.509 certificate renewal status notification. If the value of this object is 'true', the issuing of the notification 'ciscoEnhIpsecFlowCertRenewal' is enabled, otherwise notification 'ciscoEnhIpsecFlowCertRenewal' is disabled.")
ciscoEnhIpsecFlowTunnelStart = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 1)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLifeTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLifeSize"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowTunnelStart.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowTunnelStart.setDescription('This notification is generated when an IPsec Phase-2 Tunnel becomes active.')
ciscoEnhIpsecFlowTunnelStop = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 2)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistTermReason"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunActiveTime"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowTunnelStop.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowTunnelStop.setDescription('This notification is generated when an IPsec Phase-2 Tunnel becomes inactive.')
ciscoEnhIpsecFlowSysFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 3)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailReason"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddress"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowSysFailure.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowSysFailure.setDescription('This notification is generated when the processing for an IPsec Phase-2 Tunnel experiences an internal or system capacity error.')
ciscoEnhIpsecFlowSetupFail = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 4)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailReason"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddress"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowSetupFail.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowSetupFail.setDescription('This notification is generated when the setup for an IPsec Phase-2 Tunnel fails.')
ciscoEnhIpsecFlowBadSa = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 5)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailSaSpi"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowBadSa.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowBadSa.setDescription('This notification is generated when the managed entity receives an IPsec packet with a non-existent (non-existant in the local Security Association Database) SPI.')
ciscoEnhIpsecFlowCertExpiry = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 6)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSubjectName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSerialNumber"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertIssuerName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertExpiryTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertExpiryStatus"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowCertExpiry.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowCertExpiry.setDescription('This notification is generated to notify that an X.509 certificate is going to expire. The notification is triggered the time threshold configured on the application for notification before the certificate is going to expire, which is when the value of ceipSecCertExpiryStatus is changed from certOK(1) to certGoingExpired(2). The user should take action to renew the certificate identified in the notification prior to the certificate expiration, which is at the validity notAfter time provided in the notification.')
ciscoEnhIpsecFlowCertRenewal = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 432, 0, 7)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSubjectName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSerialNumber"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertIssuerName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertRenewalStatus"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertExpiryTime"))
if mibBuilder.loadTexts: ciscoEnhIpsecFlowCertRenewal.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIpsecFlowCertRenewal.setDescription('This notification is generated to report a status transition for an X.509 certificate renewal performed by the application. The notification is generated when the value of ceipSecCertRenewalStatus is changed from 1. renewalNotNeeded(1) to renewalRequestNeeded(2) or renewalRequested(3) 2. renewalRequestNeeded(2) to renewalRequested(3) 3. renewalRequested(3) to renewalSuccess(4) or renewalFailedUpdate(5) or renewalFailedExpired(6) 4. renewalFailedUpdate(5) to renewalFailedExpired(6)')
ciscoEnhIPsecFlowMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 1))
ciscoIPsecFlowMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2))
ciscoEnhIPsecFlowMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 1, 1)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowActivityGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreHistGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreFailGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowTunnelSaGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowHistoryGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowFailureGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifCntlGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowMIBCompliance = ciscoEnhIPsecFlowMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowMIBCompliance.setDescription('The compliance statement for SNMP entities pertaining to Phase-2 of IP Security Protocol.')
ciscoEnhIPsecFlowMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 1, 2)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowActivityGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreHistGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreFailGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowTunnelSaGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowHistoryGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowFailureGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifCntlGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifGroupSup01"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifCntlGroupSup01"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCertObjectGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowMIBComplianceRev1 = ciscoEnhIPsecFlowMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowMIBComplianceRev1.setDescription('The compliance statement for SNMP entities pertaining to Phase-2 of IP Security Protocol.')
ciscoEnhIPsecFlowMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 1, 3)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowActivityGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreHistGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCoreFailGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowTunnelSaGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowHistoryGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowFailureGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifCntlGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifGroupSup01"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowNotifCntlGroupSup01"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowCertObjectGroup"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIPsecFlowPerformanceThroughputGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowMIBComplianceRev2 = ciscoEnhIPsecFlowMIBComplianceRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowMIBComplianceRev2.setDescription('The compliance statement for SNMP entities pertaining to Phase-2 of IP Security Protocol.')
ciscoEnhIPsecFlowActivityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 1)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalActiveTunnels"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalPreviousTunnels"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInDecompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInDrops"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInReplayDrops"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInDecrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalInDecryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutUncompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutDrops"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutEncrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutEncryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalProtocolUseFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalNoSaFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalSysCapFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutCompressedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutCompSkippedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutCompFailPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalOutCompTooSmallPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunEncapMode"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLifeSize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLifeTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunActiveTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaLifeSizeThreshold"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaLifeTimeThreshold"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunTotalRefreshes"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunExpiredSaInstances"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunCurrentSaInstances"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaDHGrp"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaEncryptAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaAhAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaEspAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaDecompAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaDHGrp"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaEncryptAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaAhAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaEspAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaCompAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunPmtu"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInDecompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInReplayDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInDecrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInDecryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutUncompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutEncrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutEncryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutCompressedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutCompSkippedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutCompFailPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutCompTooSmallPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecIfIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunStatus"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunControlTunnelIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunControlProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunControlTunnelAlive"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunInSaEncryptKeySize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunOutSaEncryptKeySize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLocalAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunLocalAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunRemoteAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunRemoteAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunNATTraversalMode"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalAddrType1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalAddr1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalAddrType2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalAddr2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtLocalPort"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteAddrType1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteAddr1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteAddrType2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteAddr2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemoteProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtRemotePort"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecSaDirection"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecSaValue"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecSaStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowActivityGroup = ciscoEnhIPsecFlowActivityGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowActivityGroup.setDescription('This group consists of: 1) IPsec Phase-2 Global Statistics 2) IPsec Phase-2 Tunnel Table 3) IPsec Phase-2 Endpoint Table 4) IPsec Phase-2 Security Association Table')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowActivityGroup.setReference('rfc2408, rfc2407; rfc2409 section 5.5')
ciscoEnhIPsecFlowCoreHistGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 2)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecHistTableSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowCoreHistGroup = ciscoEnhIPsecFlowCoreHistGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowCoreHistGroup.setDescription('This group consists of the core (mandatory) objects pertaining to maintaining history of IPsec activity.')
ciscoEnhIPsecFlowHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 3)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistTermReason"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistActiveIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistEncapMode"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistLifeSize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistLifeTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistStartTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistActiveTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistTotalRefreshes"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistTotalSas"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaDHGrp"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaEncryptAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaAhAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaEspAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaDecompAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaDHGrp"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaEncryptAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaAhAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaEspAuthAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaCompAlgo"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistPmtu"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInDecompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInReplayDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInDecrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInDecryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutUncompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutEncrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutEncryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutCompressedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutCompSkippedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutCompFailPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutCompSmallPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistControlProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistControlTunnelIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistInSaEncryptKeySize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistOutSaEncryptKeySz"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistLocalAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistLocalAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistRemoteAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistRemoteAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunHistNATTraversalMode"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistTunIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistActiveIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalAddrType1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalAddr1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalAddrType2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalAddr2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistLocalPort"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteAddrType1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteAddr1"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteAddrType2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteAddr2"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemoteProtocol"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecEndPtHistRemotePort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowHistoryGroup = ciscoEnhIPsecFlowHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowHistoryGroup.setDescription('This group consists of objects that pertain to maintenance of history of IPsec Phase 2 activity.')
ciscoEnhIPsecFlowCoreFailGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 4)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailTableSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowCoreFailGroup = ciscoEnhIPsecFlowCoreFailGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowCoreFailGroup.setDescription('This group consists of the core (mandatory) objects pertaining to maintaining history of failure IPsec activity.')
ciscoEnhIPsecFlowFailureGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 5)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailReason"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailTunnelIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailSaSpi"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktSrcAddress"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddressType"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecFailPktDstAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowFailureGroup = ciscoEnhIPsecFlowFailureGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowFailureGroup.setDescription('This group consists of objects that pertain to maintenance of history of failures associated with Phase 2 IPsec activity.')
ciscoEnhIPsecFlowNotifCntlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 6)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotiCntlIpSecAllNotifs"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlIpSecTunnelStart"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlIpSecTunnelStop"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlIpSecSysFailure"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlIpSecSetUpFail"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlIpSecBadSa"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowNotifCntlGroup = ciscoEnhIPsecFlowNotifCntlGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowNotifCntlGroup.setDescription('This group of objects controls the sending of notifications pertaining to IPsec Phase-2 processing.')
ciscoEnhIPsecFlowNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 7)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowTunnelStart"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowTunnelStop"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowSysFailure"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowSetupFail"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowBadSa"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowNotifGroup = ciscoEnhIPsecFlowNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowNotifGroup.setDescription('This group contains the notifications pertaining to Phase-2 operations and data transfer.')
ciscoEnhIPsecFlowNotifGroup.setReference('rfc2408, rfc2407; rfc2409 section 5.5')
ciscoEnhIPsecFlowTunnelSaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 8)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaValue"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaIfIndex"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInDecompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInReplayDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInDecrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaInDecryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutUncompOctets"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutDropPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutAuths"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutAuthFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutEncrypts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutEncryptFails"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutCompressedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutCompSkippedPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutCompFailPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaOutCompTooSmallPkts"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecTunSaStatus"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecIfTunnelStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowTunnelSaGroup = ciscoEnhIPsecFlowTunnelSaGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowTunnelSaGroup.setDescription('This group consists of the Phase-2 IPsec tunnel Security Association and traffic information.')
ciscoEnhIPsecFlowNotifCntlGroupSup01 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 9)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlCertExpiry"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecNotifCntlCertRenewal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowNotifCntlGroupSup01 = ciscoEnhIPsecFlowNotifCntlGroupSup01.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowNotifCntlGroupSup01.setDescription('This supplement group of objects controls the sending of X.509 certificate IPSec notifications.')
ciscoEnhIPsecFlowNotifGroupSup01 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 10)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowCertExpiry"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ciscoEnhIpsecFlowCertRenewal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowNotifGroupSup01 = ciscoEnhIPsecFlowNotifGroupSup01.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowNotifGroupSup01.setDescription('This supplement group contains the X.509 certificate notifications for the IPSec MIB.')
ciscoEnhIPsecFlowCertObjectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 11)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSubjectName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertSerialNumber"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertIssuerName"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertExpiryTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertRenewalStatus"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecCertExpiryStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowCertObjectGroup = ciscoEnhIPsecFlowCertObjectGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowCertObjectGroup.setDescription('This group consists of objects to support X.509 certificates.')
ciscoEnhIPsecFlowPerformanceThroughputGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 432, 2, 2, 12)).setObjects(("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalThroughputUtilizatioinTimeInterval"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalThroughputLastUpdatedTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalLastAveragePacketSize"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalLastThroughputInMbps"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalLastThroughputInKpps"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalLastThroughputUtilization"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalPeakThroughputUtilization"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalPeakThroughputDateAndTime"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalPeakThroughputInMbps"), ("CISCO-ENHANCED-IPSEC-FLOW-MIB", "ceipSecGlobalPeakAvgPacketSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoEnhIPsecFlowPerformanceThroughputGroup = ciscoEnhIPsecFlowPerformanceThroughputGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoEnhIPsecFlowPerformanceThroughputGroup.setDescription('This group consists of objects to show the the performance utilization.')
mibBuilder.exportSymbols("CISCO-ENHANCED-IPSEC-FLOW-MIB", ceipSecEndPtRemoteType=ceipSecEndPtRemoteType, ciscoEnhIPsecFlowMIBCompliance=ciscoEnhIPsecFlowMIBCompliance, ceipSecTunSaLifeSizeThreshold=ceipSecTunSaLifeSizeThreshold, ceipSecGlobalOutEncrypts=ceipSecGlobalOutEncrypts, ceipSecTunOutAuthFails=ceipSecTunOutAuthFails, ceipSecTunHistInSaDecompAlgo=ceipSecTunHistInSaDecompAlgo, ceipSecFailTime=ceipSecFailTime, ciscoEnhIPsecFlowNotifGroupSup01=ciscoEnhIPsecFlowNotifGroupSup01, ceipSecTunnelSaTable=ceipSecTunnelSaTable, ciscoEnhIpsecFlowSysFailure=ciscoEnhIpsecFlowSysFailure, ceipSecCertNotification=ceipSecCertNotification, ceipSecTunRemoteAddressType=ceipSecTunRemoteAddressType, ceipSecTunOutCompFailPkts=ceipSecTunOutCompFailPkts, ceipSecIfTunnelTable=ceipSecIfTunnelTable, ceipSecTunControlTunnelAlive=ceipSecTunControlTunnelAlive, ceipSecTunHistControlProtocol=ceipSecTunHistControlProtocol, ceipSecFailPktSrcAddress=ceipSecFailPktSrcAddress, ceipSecGlobalInDecompOctets=ceipSecGlobalInDecompOctets, ceipSecTunSaProtocol=ceipSecTunSaProtocol, ceipSecTunHistNATTraversalMode=ceipSecTunHistNATTraversalMode, ceipSecTunOutSaEspAuthAlgo=ceipSecTunOutSaEspAuthAlgo, ceipSecFailPktDstAddress=ceipSecFailPktDstAddress, ciscoEnhancedIpsecFlowMIBNotifs=ciscoEnhancedIpsecFlowMIBNotifs, ceipSecGlobalLastAveragePacketSize=ceipSecGlobalLastAveragePacketSize, ceipSecTunLocalAddress=ceipSecTunLocalAddress, ceipSecFailTableSize=ceipSecFailTableSize, ceipSecEndPtLocalType=ceipSecEndPtLocalType, ceipSecGlobalOutCompFailPkts=ceipSecGlobalOutCompFailPkts, ceipSecFailReason=ceipSecFailReason, ceipSecTunHistInReplayDropPkts=ceipSecTunHistInReplayDropPkts, ceipSecTunHistTotalSas=ceipSecTunHistTotalSas, ceipSecNotifCntlIpSecTunnelStart=ceipSecNotifCntlIpSecTunnelStart, ceipSecTunHistActiveTime=ceipSecTunHistActiveTime, ceipSecTunHistOutEncryptFails=ceipSecTunHistOutEncryptFails, ciscoEnhIpsecFlowCertRenewal=ciscoEnhIpsecFlowCertRenewal, ciscoEnhIPsecFlowMIBCompliances=ciscoEnhIPsecFlowMIBCompliances, ceipSecTunInAuthFails=ceipSecTunInAuthFails, ceipSecTunHistLifeSize=ceipSecTunHistLifeSize, ceipSecTunHistInSaDHGrp=ceipSecTunHistInSaDHGrp, ceipSecEndPtHistRemoteName=ceipSecEndPtHistRemoteName, ceipSecTunOutSaEncryptKeySize=ceipSecTunOutSaEncryptKeySize, ceipSecTunHistStartTime=ceipSecTunHistStartTime, ceipSecEndPtHistEntry=ceipSecEndPtHistEntry, ceipSecCertSubjectName=ceipSecCertSubjectName, ceipSecGlobalPeakAvgPacketSize=ceipSecGlobalPeakAvgPacketSize, ceipSecTunSaIfIndex=ceipSecTunSaIfIndex, ceipSecTunnelHistTable=ceipSecTunnelHistTable, ceipSecTunControlProtocol=ceipSecTunControlProtocol, ceipSecNotificationCntl=ceipSecNotificationCntl, ceipSecTunOutSaDHGrp=ceipSecTunOutSaDHGrp, ceipSecEndPtHistLocalAddr1=ceipSecEndPtHistLocalAddr1, ceipSecTunOutPkts=ceipSecTunOutPkts, ceipSecGlobalProtocolUseFails=ceipSecGlobalProtocolUseFails, ceipSecEndPtLocalProtocol=ceipSecEndPtLocalProtocol, ceipSecTunSaOutAuths=ceipSecTunSaOutAuths, ceipSecTunPmtu=ceipSecTunPmtu, ceipSecCertRenewalStatus=ceipSecCertRenewalStatus, ceipSecEndPtLocalAddr1=ceipSecEndPtLocalAddr1, ceipSecEndPtHistRemoteAddr2=ceipSecEndPtHistRemoteAddr2, ceipSecFailGlobal=ceipSecFailGlobal, ceipSecNotifCntlIpSecSetUpFail=ceipSecNotifCntlIpSecSetUpFail, ceipSecCertSerialNumber=ceipSecCertSerialNumber, ceipSecTunOutEncrypts=ceipSecTunOutEncrypts, ceipSecTunSaValue=ceipSecTunSaValue, ceipSecTunEncapMode=ceipSecTunEncapMode, ceipSecGlobalOutCompTooSmallPkts=ceipSecGlobalOutCompTooSmallPkts, ceipSecTunInDecryptFails=ceipSecTunInDecryptFails, ceipSecSaTable=ceipSecSaTable, ceipSecTunSaOutDropPkts=ceipSecTunSaOutDropPkts, ceipSecTunOutAuths=ceipSecTunOutAuths, ceipSecTunSaInDecryptFails=ceipSecTunSaInDecryptFails, ceipSecTunHistInDecrypts=ceipSecTunHistInDecrypts, ceipSecGlobalInAuthFails=ceipSecGlobalInAuthFails, ceipSecIfIndex=ceipSecIfIndex, ceipSecTunOutCompSkippedPkts=ceipSecTunOutCompSkippedPkts, ceipSecTunHistOutUncompOctets=ceipSecTunHistOutUncompOctets, ceipSecSaIndex=ceipSecSaIndex, ceipSecGlobalOutEncryptFails=ceipSecGlobalOutEncryptFails, ceipSecTunHistOutAuths=ceipSecTunHistOutAuths, ceipSecTunInDropPkts=ceipSecTunInDropPkts, ceipSecTunSaOutUncompOctets=ceipSecTunSaOutUncompOctets, ceipSecTunnelEntry=ceipSecTunnelEntry, ceipSecTunInSaEspAuthAlgo=ceipSecTunInSaEspAuthAlgo, ceipSecTunInOctets=ceipSecTunInOctets, ciscoEnhIPsecFlowHistoryGroup=ciscoEnhIPsecFlowHistoryGroup, ceipSecTunInPkts=ceipSecTunInPkts, ceipSecTunInSaDHGrp=ceipSecTunInSaDHGrp, ceipSecTunHistActiveIndex=ceipSecTunHistActiveIndex, ceipSecTunHistInAuthFails=ceipSecTunHistInAuthFails, ceipSecTunOutSaCompAlgo=ceipSecTunOutSaCompAlgo, ceipSecEndPtLocalAddrType1=ceipSecEndPtLocalAddrType1, ceipSecTunHistEncapMode=ceipSecTunHistEncapMode, ceipSecTunInDecrypts=ceipSecTunInDecrypts, ceipSecTunHistInSaAhAuthAlgo=ceipSecTunHistInSaAhAuthAlgo, ceipSecTunInSaEncryptAlgo=ceipSecTunInSaEncryptAlgo, ceipSecTunOutEncryptFails=ceipSecTunOutEncryptFails, ceipSecEndPtRemoteAddrType1=ceipSecEndPtRemoteAddrType1, ciscoEnhancedIpsecFlowMIBObjects=ciscoEnhancedIpsecFlowMIBObjects, ceipSecHistTableSize=ceipSecHistTableSize, ceipSecEndPtHistLocalAddrType2=ceipSecEndPtHistLocalAddrType2, ciscoEnhIpsecFlowTunnelStart=ciscoEnhIpsecFlowTunnelStart, ceipSecSaProtocol=ceipSecSaProtocol, ceipSecTunHistTermReason=ceipSecTunHistTermReason, ceipSecTunOutDropPkts=ceipSecTunOutDropPkts, ceipSecTunHistInSaEncryptKeySize=ceipSecTunHistInSaEncryptKeySize, ceipSecTunHistOutAuthFails=ceipSecTunHistOutAuthFails, ceipSecGlobalInDecrypts=ceipSecGlobalInDecrypts, ceipSecTunIndex=ceipSecTunIndex, ceipSecTunHistPmtu=ceipSecTunHistPmtu, ceipSecTunHistInDecompOctets=ceipSecTunHistInDecompOctets, ceipSecGlobalOutCompressedPkts=ceipSecGlobalOutCompressedPkts, ceipSecGlobalOutUncompOctets=ceipSecGlobalOutUncompOctets, ceipSecEndPtHistRemoteType=ceipSecEndPtHistRemoteType, ceipSecCertExpiryTime=ceipSecCertExpiryTime, ceipSecEndPtHistRemoteAddrType2=ceipSecEndPtHistRemoteAddrType2, ceipSecNotifCntlIpSecSysFailure=ceipSecNotifCntlIpSecSysFailure, ceipSecEndPtHistRemoteProtocol=ceipSecEndPtHistRemoteProtocol, ceipSecGlobalOutOctets=ceipSecGlobalOutOctets, ceipSecTunSaOutCompressedPkts=ceipSecTunSaOutCompressedPkts, ceipSecTunnelTable=ceipSecTunnelTable, ciscoEnhIpsecFlowCertExpiry=ciscoEnhIpsecFlowCertExpiry, ceipSecEndPtHistLocalPort=ceipSecEndPtHistLocalPort, ceipSecEndPtRemoteAddrType2=ceipSecEndPtRemoteAddrType2, ceipSecHistory=ceipSecHistory, ceipSecTunHistOutEncrypts=ceipSecTunHistOutEncrypts, ceipSecTunNATTraversalMode=ceipSecTunNATTraversalMode, ceipSecTunExpiredSaInstances=ceipSecTunExpiredSaInstances, ceipSecTunInSaDecompAlgo=ceipSecTunInSaDecompAlgo, ceipSecSaEntry=ceipSecSaEntry, ceipSecTunSaInReplayDropPkts=ceipSecTunSaInReplayDropPkts, ceipSecTunHistOutCompressedPkts=ceipSecTunHistOutCompressedPkts, ceipSecEndPtHistRemoteAddr1=ceipSecEndPtHistRemoteAddr1, ceipSecTunSaStatus=ceipSecTunSaStatus, ceipSecTunSaOutEncryptFails=ceipSecTunSaOutEncryptFails, ceipSecIfTunnelEntry=ceipSecIfTunnelEntry, ciscoEnhIPsecFlowMIBComplianceRev1=ciscoEnhIPsecFlowMIBComplianceRev1, ceipSecGlobalThroughputLastUpdatedTime=ceipSecGlobalThroughputLastUpdatedTime, ceipSecTunLocalAddressType=ceipSecTunLocalAddressType, ceipSecFailSaSpi=ceipSecFailSaSpi, ceipSecEndPtHistLocalName=ceipSecEndPtHistLocalName, ceipSecTunCurrentSaInstances=ceipSecTunCurrentSaInstances, ceipSecTunInDecompOctets=ceipSecTunInDecompOctets, ceipSecEndPtRemoteName=ceipSecEndPtRemoteName, ceipSecEndPtHistIndex=ceipSecEndPtHistIndex, ceipSecTunHistOutCompFailPkts=ceipSecTunHistOutCompFailPkts, ceipSecTunInAuths=ceipSecTunInAuths, ceipSecPhaseTwo=ceipSecPhaseTwo, ceipSecTunHistOutSaCompAlgo=ceipSecTunHistOutSaCompAlgo, ciscoEnhIPsecFlowPerformanceThroughputGroup=ciscoEnhIPsecFlowPerformanceThroughputGroup, ceipSecTunHistOutPkts=ceipSecTunHistOutPkts, ceipSecFailEntry=ceipSecFailEntry, ceipSecTunRemoteAddress=ceipSecTunRemoteAddress, ceipSecTunSaOutCompFailPkts=ceipSecTunSaOutCompFailPkts, ceipSecSaDirection=ceipSecSaDirection, ceipSecTunHistControlTunnelIndex=ceipSecTunHistControlTunnelIndex, ciscoEnhIpsecFlowTunnelStop=ciscoEnhIpsecFlowTunnelStop, ciscoEnhIPsecFlowTunnelSaGroup=ciscoEnhIPsecFlowTunnelSaGroup, ceipSecEndPtLocalAddrType2=ceipSecEndPtLocalAddrType2, ceipSecGlobalInOctets=ceipSecGlobalInOctets, ceipSecTunOutOctets=ceipSecTunOutOctets, ceipSecNotiCntlIpSecAllNotifs=ceipSecNotiCntlIpSecAllNotifs, ceipSecTunInSaAhAuthAlgo=ceipSecTunInSaAhAuthAlgo, ceipSecTunHistOutDropPkts=ceipSecTunHistOutDropPkts, ceipSecTunHistOutOctets=ceipSecTunHistOutOctets, ciscoEnhIPsecFlowCertObjectGroup=ciscoEnhIPsecFlowCertObjectGroup, ceipSecTunSaLifeTimeThreshold=ceipSecTunSaLifeTimeThreshold, ceipSecGlobalStats=ceipSecGlobalStats, ceipSecTunActiveTime=ceipSecTunActiveTime, ceipSecTunnelSaEntry=ceipSecTunnelSaEntry, ceipSecTunHistOutSaAhAuthAlgo=ceipSecTunHistOutSaAhAuthAlgo, ciscoEnhIPsecFlowNotifCntlGroup=ciscoEnhIPsecFlowNotifCntlGroup, ceipSecEndPtLocalName=ceipSecEndPtLocalName, ceipSecTunOutSaEncryptAlgo=ceipSecTunOutSaEncryptAlgo, ceipSecTunHistInAuths=ceipSecTunHistInAuths, ceipSecEndPtHistLocalAddr2=ceipSecEndPtHistLocalAddr2, ceipSecGlobalOutCompSkippedPkts=ceipSecGlobalOutCompSkippedPkts, ceipSecEndPtIndex=ceipSecEndPtIndex, ceipSecEndPtRemoteAddr1=ceipSecEndPtRemoteAddr1, ceipSecTunnelHistEntry=ceipSecTunnelHistEntry, ceipSecTunHistOutSaEspAuthAlgo=ceipSecTunHistOutSaEspAuthAlgo, ceipSecEndPtHistLocalProtocol=ceipSecEndPtHistLocalProtocol, ciscoIPsecFlowMIBGroups=ciscoIPsecFlowMIBGroups, ceipSecEndPtLocalAddr2=ceipSecEndPtLocalAddr2, ceipSecTunHistOutCompSkippedPkts=ceipSecTunHistOutCompSkippedPkts, ceipSecTunSaInDropPkts=ceipSecTunSaInDropPkts, ceipSecTunOutSaAhAuthAlgo=ceipSecTunOutSaAhAuthAlgo, ceipSecTunHistInOctets=ceipSecTunHistInOctets, ceipSecTunHistLocalAddressType=ceipSecTunHistLocalAddressType, ceipSecGlobalOutDrops=ceipSecGlobalOutDrops, ceipSecGlobalPeakThroughputInMbps=ceipSecGlobalPeakThroughputInMbps, ceipSecEndPtEntry=ceipSecEndPtEntry, ciscoEnhIPsecFlowMIBComplianceRev2=ciscoEnhIPsecFlowMIBComplianceRev2, ceipSecTunHistInSaEspAuthAlgo=ceipSecTunHistInSaEspAuthAlgo, ceipSecGlobalOutAuths=ceipSecGlobalOutAuths, ceipSecGlobalNoSaFails=ceipSecGlobalNoSaFails, ceipSecTunSaInAuths=ceipSecTunSaInAuths, ceipSecFailPktDstAddressType=ceipSecFailPktDstAddressType, ciscoEnhIPsecFlowCoreFailGroup=ciscoEnhIPsecFlowCoreFailGroup, ceipSecTunSaOutPkts=ceipSecTunSaOutPkts, ceipSecTunHistInSaEncryptAlgo=ceipSecTunHistInSaEncryptAlgo, ceipSecTunSaOutCompTooSmallPkts=ceipSecTunSaOutCompTooSmallPkts, ceipSecTunSaInAuthFails=ceipSecTunSaInAuthFails, ceipSecTunHistOutSaDHGrp=ceipSecTunHistOutSaDHGrp, ceipSecFailPktSrcAddressType=ceipSecFailPktSrcAddressType, ciscoEnhIPsecFlowCoreHistGroup=ciscoEnhIPsecFlowCoreHistGroup, ceipSecEndPtHistActiveIndex=ceipSecEndPtHistActiveIndex, ceipSecGlobalInDrops=ceipSecGlobalInDrops, ceipSecFailIndex=ceipSecFailIndex, ceipSecTunHistOutCompSmallPkts=ceipSecTunHistOutCompSmallPkts, ceipSecTunHistRemoteAddressType=ceipSecTunHistRemoteAddressType, ceipSecGlobalThroughputUtilizatioinTimeInterval=ceipSecGlobalThroughputUtilizatioinTimeInterval, ciscoEnhIpsecFlowSetupFail=ciscoEnhIpsecFlowSetupFail, ceipSecTunSaInOctets=ceipSecTunSaInOctets, ceipSecEndPtHistLocalType=ceipSecEndPtHistLocalType, ceipSecEndPtHistRemotePort=ceipSecEndPtHistRemotePort, ceipSecTunTotalRefreshes=ceipSecTunTotalRefreshes, ceipSecGlobalInAuths=ceipSecGlobalInAuths, ceipSecEndPtHistTable=ceipSecEndPtHistTable, ceipSecGlobalPeakThroughputDateAndTime=ceipSecGlobalPeakThroughputDateAndTime, ceipSecTunInReplayDropPkts=ceipSecTunInReplayDropPkts, ceipSecTunSaOutCompSkippedPkts=ceipSecTunSaOutCompSkippedPkts, ceipSecTunSaDirection=ceipSecTunSaDirection, ceipSecNotifCntlIpSecBadSa=ceipSecNotifCntlIpSecBadSa, ceipSecGlobalOutAuthFails=ceipSecGlobalOutAuthFails, ceipSecTunOutUncompOctets=ceipSecTunOutUncompOctets, ciscoEnhancedIpsecFlowMIB=ciscoEnhancedIpsecFlowMIB, ceipSecTunHistOutSaEncryptKeySz=ceipSecTunHistOutSaEncryptKeySz, ceipSecGlobalLastThroughputInMbps=ceipSecGlobalLastThroughputInMbps, ceipSecGlobalOutPkts=ceipSecGlobalOutPkts, ciscoEnhIpsecFlowBadSa=ciscoEnhIpsecFlowBadSa, ceipSecSaStatus=ceipSecSaStatus, ceipSecEndPtHistRemoteAddrType1=ceipSecEndPtHistRemoteAddrType1, ceipSecTunHistIndex=ceipSecTunHistIndex, ceipSecHistGlobal=ceipSecHistGlobal, ceipSecGlobalPeakThroughputUtilization=ceipSecGlobalPeakThroughputUtilization, ceipSecGlobalInPkts=ceipSecGlobalInPkts, ceipSecTunSaInPkts=ceipSecTunSaInPkts, ciscoEnhIPsecFlowNotifCntlGroupSup01=ciscoEnhIPsecFlowNotifCntlGroupSup01, PYSNMP_MODULE_ID=ciscoEnhancedIpsecFlowMIB, ciscoEnhancedIpsecFlowMIBConform=ciscoEnhancedIpsecFlowMIBConform, ceipSecTunSaIndex=ceipSecTunSaIndex, ceipSecIfTunnelStatus=ceipSecIfTunnelStatus, ceipSecTunHistLocalAddress=ceipSecTunHistLocalAddress, ceipSecTunSaOutAuthFails=ceipSecTunSaOutAuthFails, ceipSecTunOutCompTooSmallPkts=ceipSecTunOutCompTooSmallPkts, ceipSecTunHistRemoteAddress=ceipSecTunHistRemoteAddress, ceipSecTunControlTunnelIndex=ceipSecTunControlTunnelIndex, ceipSecEndPtTable=ceipSecEndPtTable, ceipSecTunHistInPkts=ceipSecTunHistInPkts, ceipSecFailTable=ceipSecFailTable, ceipSecNotifCntlIpSecTunnelStop=ceipSecNotifCntlIpSecTunnelStop, ceipSecEndPtHistTunIndex=ceipSecEndPtHistTunIndex, ceipSecEndPtRemoteProtocol=ceipSecEndPtRemoteProtocol, ceipSecTunHistInDecryptFails=ceipSecTunHistInDecryptFails)
mibBuilder.exportSymbols("CISCO-ENHANCED-IPSEC-FLOW-MIB", ceipSecEndPtRemotePort=ceipSecEndPtRemotePort, ceipSecCertExpiryStatus=ceipSecCertExpiryStatus, ceipSecGlobalActiveTunnels=ceipSecGlobalActiveTunnels, ceipSecTunLifeTime=ceipSecTunLifeTime, ceipSecTunOutCompressedPkts=ceipSecTunOutCompressedPkts, ceipSecTunSaOutEncrypts=ceipSecTunSaOutEncrypts, ceipSecGlobalInReplayDrops=ceipSecGlobalInReplayDrops, ceipSecEndPtLocalPort=ceipSecEndPtLocalPort, ceipSecTunHistTotalRefreshes=ceipSecTunHistTotalRefreshes, ceipSecGlobalSysCapFails=ceipSecGlobalSysCapFails, ceipSecHistGlobalCntl=ceipSecHistGlobalCntl, ceipSecTunSaInDecrypts=ceipSecTunSaInDecrypts, ceipSecEndPtRemoteAddr2=ceipSecEndPtRemoteAddr2, ciscoEnhIPsecFlowNotifGroup=ciscoEnhIPsecFlowNotifGroup, ceipSecFailures=ceipSecFailures, ceipSecNotifCntlCertExpiry=ceipSecNotifCntlCertExpiry, ceipSecGlobalPreviousTunnels=ceipSecGlobalPreviousTunnels, ceipSecFailGlobalCntl=ceipSecFailGlobalCntl, ceipSecTunHistInDropPkts=ceipSecTunHistInDropPkts, ceipSecTunStatus=ceipSecTunStatus, ceipSecGlobalLastThroughputUtilization=ceipSecGlobalLastThroughputUtilization, ceipSecTunLifeSize=ceipSecTunLifeSize, ceipSecFailTunnelIndex=ceipSecFailTunnelIndex, ciscoEnhIPsecFlowFailureGroup=ciscoEnhIPsecFlowFailureGroup, ceipSecTunInSaEncryptKeySize=ceipSecTunInSaEncryptKeySize, ceipSecCertIssuerName=ceipSecCertIssuerName, ciscoEnhIPsecFlowActivityGroup=ciscoEnhIPsecFlowActivityGroup, ceipSecGlobalInDecryptFails=ceipSecGlobalInDecryptFails, ceipSecTunSaOutOctets=ceipSecTunSaOutOctets, ceipSecTunHistOutSaEncryptAlgo=ceipSecTunHistOutSaEncryptAlgo, ceipSecGlobalLastThroughputInKpps=ceipSecGlobalLastThroughputInKpps, ceipSecTunHistLifeTime=ceipSecTunHistLifeTime, ceipSecTunSaInDecompOctets=ceipSecTunSaInDecompOctets, ceipSecNotifCntlCertRenewal=ceipSecNotifCntlCertRenewal, ceipSecEndPtHistLocalAddrType1=ceipSecEndPtHistLocalAddrType1, ceipSecSaValue=ceipSecSaValue)

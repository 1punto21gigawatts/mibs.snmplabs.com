#
# PySNMP MIB module SBE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SBE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:00:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
MacAddress, = mibBuilder.importSymbols("RFC1230-MIB", "MacAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter32, NotificationType, Bits, ObjectIdentity, NotificationType, Gauge32, Unsigned32, IpAddress, enterprises, TimeTicks, ModuleIdentity, iso, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "NotificationType", "Bits", "ObjectIdentity", "NotificationType", "Gauge32", "Unsigned32", "IpAddress", "enterprises", "TimeTicks", "ModuleIdentity", "iso", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sbe = MibIdentifier((1, 3, 6, 1, 4, 1, 1055))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 1))
router = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2))
discovery = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 3))
fileMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 4))
modempool = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 6))
endOfSBEMib = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 65535))
syDateTime = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: syDateTime.setDescription('Default value on nX: zero On nX: stored in clock chip Format: Century, year, month, day, hour, min, sec. each occupies one octet in binary value.')
syRAMConfigurationChangedFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("same", 1), ("different", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syRAMConfigurationChangedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: syRAMConfigurationChangedFlag.setDescription("Default value on nX: set to 'same' when booted from flash, 'different' otherwise On nX: (not needed?) in ram, field trial 2 This field is used by Workshop to determine if the RAM image currently being executed on the nX product is identical to the image in the LX's flash. Whenever part of the RAM image is changed (currently only via SNMP), this value is set to 'different' by the LX.")
syConfigurationLockFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syConfigurationLockFlag.setStatus('mandatory')
if mibBuilder.loadTexts: syConfigurationLockFlag.setDescription("Default value on nX: 'unlocked(2)' This field is used by Workshop to determine whether the nX unit is enabled to allow configuration. When this field is set to locked(1), nX rejects the SET requests for all mib entries except this one. The status of this field is also indicated by the lock LED on nX.")
syModel = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syModel.setStatus('mandatory')
if mibBuilder.loadTexts: syModel.setDescription(' Default value on nX: factory setting On nX: in flash, field trial 1 The product name, hardware revision, firmware revision, and kernel revision for the nX Node product. E.G. SoHo/HW4/FW3/SW1.0V1.0 Product names - SoHo, Central, ROUTEMAN, ROUTEMANXL Hardware Rev - HW Revision number, e.g. HW4 Firmware Rev - FW Revision number, e.g. FW3 Kernel Rev - SW Release-number Version-number, e.g. SW1.0V1.0 Note: for Central we will define a second variable, syCoprocessorModel.')
syBootInfo = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 33280))).clone(namedValues=NamedValues(("normal-boot-from-LAN", 1), ("base-board-flash-corrupt", 2), ("missing-base-board-kernel-module", 4), ("daughter-board-flash-corrupt", 8), ("missing-daughter-board-kernel-module", 16), ("system-type-SoHo", 32), ("system-type-Central", 64), ("system-type-torte", 128), ("system-type-ROUTEMAN", 256), ("system-type-ROUTEMANXL", 512), ("system-type-ROUTEMANXLl", 33280)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syBootInfo.setStatus('deprecated')
if mibBuilder.loadTexts: syBootInfo.setDescription('THIS ITEM IS NOT IMPLEMENTED!')
syActivatedLevel = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syActivatedLevel.setStatus('mandatory')
if mibBuilder.loadTexts: syActivatedLevel.setDescription('Software feature activation level information. This entry is maintained and used by Workshop.')
sySerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sySerialNumber.setDescription('A manufacturing only mib that will return the serial number of the board. This function is reserved for manufacturing test and may change as needed by manufacturing.')
syBaseActivationLevel = MibScalar((1, 3, 6, 1, 4, 1, 1055, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 11, 12, 13, 14, 15, 16, 18, 20, 21, 23, 25, 27, 28))).clone(namedValues=NamedValues(("rOUTEMAN20Base", 1), ("soHo20Base", 2), ("central20Base", 4), ("rOUTEMANXL20Base", 6), ("soHoTest", 11), ("centralTest", 12), ("rOUTEMANTest", 13), ("rOUTEMANXLTest", 14), ("rOUTEMANXL201Base", 15), ("soHo21Base", 16), ("central21Base", 18), ("rOUTEMAN21Base", 20), ("rOUTEMANXL21Base", 21), ("soHo30Dormant", 23), ("central30Dormant", 25), ("rOUTEMAN30Dormant", 27), ("rOUTEMANX30Dormant", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syBaseActivationLevel.setStatus('mandatory')
if mibBuilder.loadTexts: syBaseActivationLevel.setDescription('Base level software feature information. This entry is maintained by the nX unit and used by Workshop.')
routsys = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 1))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 2))
ip = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 3))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 4))
wan = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 5))
destination = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 6))
user = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 7))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 8))
holiday = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 9))
snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 10))
event = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 2, 11))
syBootOrder = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syBootOrder.setStatus('mandatory')
if mibBuilder.loadTexts: syBootOrder.setDescription("enum values per octet: 1=Flash, 2=TFTP, 3=PCMCIA, 4=LAN, 0=none Default value on nX: (Flash) On nX: in flash This field has one octet for each boot source from which the nX product will attempt to boot. The first choice boot source is designated by the first byte, the second choice by the second byte, etc. In the first release there are only two boot choices, but future versions may have additional choices such as PCMCIA. If the nX detects that a boot choice is corrupted, it will ignore that choice and proceed to the next choice. The value 'none' is just used to fill any unused octets after the choices have been specified.")
syMtuMru = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syMtuMru.setStatus('mandatory')
if mibBuilder.loadTexts: syMtuMru.setDescription('Default value on nX: 1500 On nX: both ram and flash, field trial 2 This field specifies the maximum size frame that the nX product will send or receive, either on the LAN or on a WAN port. The maximum for Ethernet is 1500, 1492 for 802.3 with SNAP. This is used by the nX product to detect error frames (i.e. too long) and during PPP negotiation. The actual transfer size is negotiated, by destination, when the connection is first made.')
syEventToLogThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syEventToLogThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: syEventToLogThreshold.setDescription('Default value on nX: 3 On nX: both ram and flash, field trial 2 All events generated by the nX product have an associated severity level which ranges from 1 to 10. The nX product puts events of this threshold level and above into its internal circular log file. Other events are discarded.')
syEventToTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syEventToTrapThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: syEventToTrapThreshold.setDescription('Default value on nX: 6 On nX: both ram and flash, field trial 2 All events generated by the nX product have an associated severity level which ranges from 1 to 10. For events of this threshold level and above, the nX generates an SNMP trap.')
syControlOperation = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("none", 1), ("reboot", 2), ("clear-SNMP-statistics", 3), ("dialout", 4), ("hangup", 5), ("enable-port", 6), ("disable-port", 7), ("disable-port-after-call", 8), ("crash", 9), ("change-password", 10), ("ram-to-Flash", 11), ("start-tftp-download", 12), ("reset-port", 13), ("boot-override", 14), ("display-IP-Routes", 15), ("display-IPX-Networks", 16), ("display-IPX-Servers", 17), ("reboot-file-transfer", 18)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syControlOperation.setStatus('mandatory')
if mibBuilder.loadTexts: syControlOperation.setDescription("Default value on nX: 'none' On nX: in ram, field trial 1 except for Clear-SNMP-statistics and Disable-port-after-call which are field trial 2 This object is set whenever Workshop wants the nX to perform an operation. Upon completion of the operation, the nX sets the value back to 'none'. Some operations use Control Variables as parameters for the operation. Any Control Variables must be set in the same frame as the Control Operation to insure that they are not changed by another Workshop before the operation is performed. After a Control Operation is started, the values in the Control Variables may no longer be valid. Reboot When the value is 'reboot', the nX performs an immediate reboot. Clear-SNMP-statistics When the value is 'clear-SNMP-statistics', the nX resets to zero all MIB statistics fields. Dialout When the value is 'dialout', the nX performs a dialout to the destination identified in Control Variable String One. Hangup When the value is 'hangup', the nX hangs up the non-leased line connection for the Destination identified in Control Variable String One. Enable port When the value is 'enable-port', the nX enables the port identified by Control Variable Integer One. Disable port When the value is 'disable-port', the nX disables the port identified by Control Variable Integer One. Disable-port-after-call When the value is 'disable-port-after-call', the nX disables the port identified by Control Variable Integer One immediately after the current connection terminates. This option allows gracefully taking the nX out of operation (except for leased lines). This option is not applicable to leased lines. Crash When the value is 'crash', the nX stores its RAM memory contents to a PCMCIA card for off-line debugging. Change-password When the value is 'change-password', the nX changes both the RAM and Flash password for a user. The Control Variable String One contains the following zero terminated strings in order: User Name, old User Password, and new User Password. This is the only way to change passwords, except when defining a new user. RAM-to-Flash When the value is 'RAM-to-Flash', the nX stores object values in RAM into Flash. start-tftp-download Reset-port Hangup the port, if necessary and reinitialize the modem. Display-IP-Routes Show IP routes via event logger. Display-IPX-Networks Show IPX Networks via event logger. Display-IPX-Servers Show IPX Servers via event logger.")
syControlVariableStringOne = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syControlVariableStringOne.setStatus('mandatory')
if mibBuilder.loadTexts: syControlVariableStringOne.setDescription('Default Value on nX: N/A On nX: in ram, field trial 1 This object is used to store a DisplayString parameter to a control operation. Once the control operation is started, the value is unspecified.')
syControlVariableIntegerOne = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syControlVariableIntegerOne.setStatus('mandatory')
if mibBuilder.loadTexts: syControlVariableIntegerOne.setDescription('Default Value on nX: N/A On nX: in ram, field trial 1 This object is used to store an Integer parameter to a control operation. Once the control operation is started, the value is unspecified.')
syDialinAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3), ("paporchap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syDialinAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: syDialinAuthentication.setDescription("Default value on nX: 'none' On nX: both ram and flash. This field identifies the type of authentication negotiation that is to be performed during dialin to this destination.")
syEventToSpeakThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syEventToSpeakThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: syEventToSpeakThreshold.setDescription('Default value on nX: 6 On nX: both ram and flash, field trial 2 All events generated by the nX product have an associated severity level which ranges from 1 to 10. For events of this threshold level and above, the nX speaks the error code to the speaker.')
syNumberOfTimesToSpeak = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syNumberOfTimesToSpeak.setStatus('mandatory')
if mibBuilder.loadTexts: syNumberOfTimesToSpeak.setDescription('Default value on nX: 3 On nX: both ram and flash, field trial 2 This item specifies the number of times an error code is spoken')
sySaveRamToFlashState = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("updating", 1), ("idle", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sySaveRamToFlashState.setStatus('mandatory')
if mibBuilder.loadTexts: sySaveRamToFlashState.setDescription('This item specifies the state of the operation ram-to-Flash in the item syControlOperation. The valid states are: updating and idle. updating state indicates that a write to flash operation is in progress, idle state indicates idle.')
syDialbackRetryInterval = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syDialbackRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: syDialbackRetryInterval.setDescription('This item specifies the number of seconds to pause before the next dialback call from Soho will be made. Default = 10')
syDialbackRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syDialbackRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: syDialbackRetryLimit.setDescription('This item specifies the number of times that Soho will retry dialback call from Soho. Default is 3.')
syReverseCallbackTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syReverseCallbackTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: syReverseCallbackTimeout.setDescription('Default value on nX: 60 (seconds) Specifies the number of seconds to wait for an expected reverse callback before redialing.')
syBridgeConfiguredFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syBridgeConfiguredFlag.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeConfiguredFlag.setDescription("Default value on nX: 'yes' On nX: both ram and flash, field trial 2 If this object is 'no', syBridgeFilterFlag will be returned as 'other' by default regardless of the value that is previously set. If this is 'yes', syBridgeFilterFlag governs the bridging rule.")
syBridgeFilterFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("other", 1), ("include", 2), ("exclude", 4), ("all", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syBridgeFilterFlag.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeFilterFlag.setDescription("Default value on nX: 'all' On nX: both ram and flash, field trial 2 This value indicates the bridging rule for this nX product, whether to include or exclude packets for the protocols indicated in the Bridge Sub-Table. If the value is 'all', all protocols will be bridged. If the value is 'include', only the protocols listed in the Bridge Sub-Table are to be bridged over this port. If the value is 'exclude', all packets except for the protocols listed in the Bridge Sub-Table are to be bridged.")
syBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syBridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgePriority.setDescription('Default value on nX: 32768 On nX: both ram and flash Used by the Spanning Tree Algorithm to determine who is the root bridge in the network.')
syBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 2, 4), )
if mibBuilder.loadTexts: syBridgeTable.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeTable.setDescription('Bridge table - one copy')
syBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 2, 4, 1), ).setIndexNames((0, "SBE-MIB", "syBridgeProtocol"))
if mibBuilder.loadTexts: syBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeEntry.setDescription('The bridge table information for one protocol.')
syBridgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syBridgeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeStatus.setDescription('Indication of whether or not a valid entry.')
syBridgeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syBridgeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: syBridgeProtocol.setDescription('Default value on nX: none On nX: both ram and flash, field trial 2 This column item contains the protocol number for a protocol to be bridged. Bridging rules are governed by syBridgeFlag.')
mgrTimeoutForMACProtocolResponses = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrTimeoutForMACProtocolResponses.setStatus('mandatory')
if mibBuilder.loadTexts: mgrTimeoutForMACProtocolResponses.setDescription('Default value on nX: 5 On nX: both ram and flash This object specifies the number of seconds Workshop will wait for a response for a message sent to an nX product before assuming that the packet was lost. If this time elapses, Workshop will resend the packet. Normally this time will be very short, but if the nX product and Workshop are separated by slow WAN links, the time will have to be increased. The nX product does not use this value.')
mgrNumberOfRetriesForMACProtocolResponses = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrNumberOfRetriesForMACProtocolResponses.setStatus('mandatory')
if mibBuilder.loadTexts: mgrNumberOfRetriesForMACProtocolResponses.setDescription('Default value on nX: 3 On nX: both ram and flash This object specifies the number of times Workshop will retry sending to an nX product a message that timed out before assuming that the packet cannot be sent. If this count is reached, Workshop will stop trying to send the packet and assume that the unit is no longer responding (e.g. the connection has been terminated). The nX product does not use this value.')
mgrEventPollingInterval = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrEventPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mgrEventPollingInterval.setDescription("Default value on nX: 120 On nX: both ram and flash, field trial 2 This object specifies an interval, in seconds, at which Workshop will poll the nX product in order to obtain current data values with which to update displayed screens. The value of this object is most critical when the log file is being written to disk because if the interval is too long the nX product's circular log buffer may not be large enough to hold all events that occur between polls. (Hopefully, the nX will sequence number all log entries so Workshop can determine if some entries have been missed by Workshop.)")
holidayMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: holidayMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: holidayMaxEntries.setDescription('A value representing the maximum number of holiday entries in the holiday table.')
holidayTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 9, 2), )
if mibBuilder.loadTexts: holidayTable.setStatus('mandatory')
if mibBuilder.loadTexts: holidayTable.setDescription('Holiday table - one copy')
holidayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 9, 2, 1), ).setIndexNames((0, "SBE-MIB", "holidayDate"))
if mibBuilder.loadTexts: holidayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: holidayEntry.setDescription('The holiday information for one date.')
holidayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: holidayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: holidayStatus.setDescription('Indication of whether or not a valid entry.')
holidayDate = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 9, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: holidayDate.setStatus('mandatory')
if mibBuilder.loadTexts: holidayDate.setDescription('Default value on nX: 0 On nX: both ram and flash, field trial 2 This item specifies a day which is designated as a special dialout day. The nX uses the month and day.')
userMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: userMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: userMaxEntries.setDescription('A value representing the maximum number of user entries in the user table.')
userTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2), )
if mibBuilder.loadTexts: userTable.setStatus('mandatory')
if mibBuilder.loadTexts: userTable.setDescription('A list of user entries. The number of entries is given by the value of userNumber.')
userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1), ).setIndexNames((0, "SBE-MIB", "userName"))
if mibBuilder.loadTexts: userEntry.setStatus('mandatory')
if mibBuilder.loadTexts: userEntry.setDescription('A user entry containing objects of users.')
userStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userStatus.setStatus('mandatory')
if mibBuilder.loadTexts: userStatus.setDescription('A value representing the current status of the user entry for the index value, userName.')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('mandatory')
if mibBuilder.loadTexts: userName.setDescription('An octet string containing user supplied User Name which identifies a dialin user. On dialin, this is used as the login name for PAP or CHAP.')
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('mandatory')
if mibBuilder.loadTexts: userPassword.setDescription('A display string containing user supplied User Password for user identified by userName.')
userPermissions = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("none", 1), ("dial-in", 2), ("dial-out", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPermissions.setStatus('mandatory')
if mibBuilder.loadTexts: userPermissions.setDescription('A value representing the permissions the user identified by userName has, regarding access to the ports. If none(1) is specified, the user can neither dial out nor accept call. If dial-in(2) is specified, the user can dial-in. If dial-out(4) is specified, the user can dial-out. Specify dial-in(2) and dial-out(4) permissions for both dial-in and dial-out privileges.')
userCallbackType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userCallbackType.setStatus('mandatory')
if mibBuilder.loadTexts: userCallbackType.setDescription('A value specifiying the type of callback to be used when user identified by userName connects. If none(1) is specified, the connection is maintained, and no callback is performed. If fixed(2) is specified, the connection is terminated after the proper authentication of the user is performed. The number stored in userPhoneNo is used to dialback.')
userPhoneNo = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPhoneNo.setStatus('mandatory')
if mibBuilder.loadTexts: userPhoneNo.setDescription('A phone number that is to be used for dialback.')
userDialInMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userDialInMax.setStatus('mandatory')
if mibBuilder.loadTexts: userDialInMax.setDescription('A value representing the maximum time in minutes for a dialin connection.')
userIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 7, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: userIpAddress.setDescription(' A value representing the IP Address to be used for the PPP dial-in connection.')
wanPortTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1), )
if mibBuilder.loadTexts: wanPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortTable.setDescription("Each WAN port's information is contained in a row in a SNMP table. The following describes the columns in the table. Each row is uniquely identified by its Wan Port Number. (See also Port Sub-Data.)")
wanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2), ).setIndexNames((0, "SBE-MIB", "wanPortNumber"))
if mibBuilder.loadTexts: wanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortEntry.setDescription('The WAN table information for one WAN port.')
wanPortEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanPortEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortEntryStatus.setDescription('Indication of whether or not a valid entry.')
wanPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortNumber.setDescription('Default value on nX: ascending integer, one for each hardware WAN port: 1, 2, 3A, 3B, 4A, and 4B. On nX: both ram and flash, field trial 1 This field is used to identify the Wan port to which the information in this row of the table applies.')
wanPortEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPortEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortEnabled.setDescription("Default value on nX: disabled On nX: both ram and flash, field trial 1 If this value is 'enabled', the Wan port is enabled. If this value is 'disabled', if the Wan port is disabled.")
wanDefaultDialinIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDefaultDialinIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wanDefaultDialinIPAddress.setDescription('Default value on nX: all zero On nX: both ram and flash, field trial 1 If IP is configured, this field is required and is used as the default IP address of the WAN port on dialin unless overridden during dialin either by an IP address from the User Table or by PPP negotiation. The same value needs to be configured at the other end of the WAN link (this could be a cause of user error, but there is no way around it).')
wanDefaultDialinSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDefaultDialinSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: wanDefaultDialinSubnetMask.setDescription("Default value on nX: all zero Default value in Workshop: 1's, based on Default Dialin IP Address class On nX: both ram and flash, field trial 1 If the Default Dialin IP Address is used, this object is used as its Subnet Mask. Subnet masks allow the user to divide the local network into sub-networks by specifying a subnet mask. The subnet mask, combined with the Dialin IP Address field, determines which frames (packets) are sent across the WAN port during dialin. The subnet masks are all 1's from the left for a specified number of bits. On Workshop, the subnet mask will be entered as a number of bits from 0 to 32.")
wanDefaultIPXNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDefaultIPXNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wanDefaultIPXNetworkAddress.setDescription('Default value on nX: 0 On nX: in ram, field trial 1 If IPX is configured, this field indicates which IPX network address is being used by this port. The nX will automatically generate an address to be used during dialout and, during dialin, will accept the address from the calling node. (The nX products use the SAP tables they dynamically build to determined which network numbers are already in use.)')
wanDefaultDialinIPXNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDefaultDialinIPXNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wanDefaultDialinIPXNodeAddress.setDescription('Default value on nX: 0 On nX: in ram, field trial 1 If IPX is configured, this field specifies the IPX node address that is being used by this port. The nX will automatically generate an address to be used during dialout and, during dialin, will accept the address from the calling node.')
wanDialinAllowedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDialinAllowedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanDialinAllowedFlag.setDescription("Default value on nX : 'yes' On nX: both ram and flash, field trial 2 If this flag is 'yes', dialin access is allowed on this port.")
wanDialoutAllowedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDialoutAllowedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanDialoutAllowedFlag.setDescription("Default value on nX : 'yes' On nX: both ram and flash, field trial 2 If this flag is 'yes', dialout is allowed on this port.")
wanLinkLayerType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("async", 1), ("sync", 2), ("autosync", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanLinkLayerType.setStatus('mandatory')
if mibBuilder.loadTexts: wanLinkLayerType.setDescription('Default value on nX: async On nX: both ram and flash, field trial 1 This object identifies the type of communication link that is used by this WAN port. Some data link types require further qualification.')
wanLinkLayerNRZFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nrz", 1), ("nrzi", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanLinkLayerNRZFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanLinkLayerNRZFlag.setDescription('Default value on nX: nrz On nX: both ram and flash If appropriate for the Link Line Type, this flag identifies whether the line is nrz or nrzi. (See Destination NRZ Flag.)')
wanLinkLayerProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("ppp", 2), ("isdn", 3), ("x25", 4), ("framerelaydte", 5), ("framerelaydce", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanLinkLayerProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: wanLinkLayerProtocolType.setDescription('Default value on nX: ppp On nX: both ram and flash, This flag identifies whether the Link Line Type is ppp. Other options are not supported at this time.')
wanLinkDialupFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dialup", 1), ("dedicated", 2), ("dtr-dial", 3), ("isdn-dialup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanLinkDialupFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanLinkDialupFlag.setDescription('Default value on nX: dialup dtr-dial(3) is obsolete (3/4/96) On nX: both ram and flash, field trial 1 (may be encoded into Link Layer Type) If appropriate for the Link Line Type, this flag identifies whether the line is dialup (switched), dedicated, DTR dial, or ISDN dialup link.')
wanModemName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 51))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemName.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemName.setDescription('Default value on nX: empty On nX: both ram and flash, field trial 1 This object contains the ASCII name of the modem. It is used by Workshop to determine the initialization modem string and maximum speed for this modem. This object is not used by the nX product. (If possible on Workshop, this field will be changed to something shorter, like an integer - if not will try to combine with PCMCIA Card Name.)')
wanModemSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200))).clone(namedValues=NamedValues(("twelvehundred", 1200), ("twentyfourhundred", 2400), ("fortyeighthundred", 4800), ("ninetysixhundred", 9600), ("nineteentwelve", 19200), ("thirtyeigthfour", 38400), ("fiftysevensix", 57600), ("onefifteentwo", 115200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemSpeed.setDescription('Default value on nX: 9600 On nX: both ram and flash, field trial 1 This object contains an indicator of the speed at which the nX product should communicate with the modem. This value cannot be larger than that obtained from the Modem File using the Modem Name. (Note: The UART does not support 14400 or 28800 directly so a higher speed must be specified and hardware handshake will be used to prevent overruns.)')
wanModemInitializationString = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemInitializationString.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemInitializationString.setDescription('Default value on nX: empty On nX: both ram and flash, field trial 1 This object contains the ASCII string that is to be sent to the modem whenever the modem is to be initialized.')
wanModemDialPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemDialPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemDialPrefix.setDescription("Default value on nX: empty On nX: both ram and flash, field trial 1 This is set by the user. It contains the modem's dial command (e.g. ATDT or ATDP) possibly suffixed with the dial prefix, if any, to obtain an outside phone line. (Note that the user could include the dial prefix in the Destination Phone Number instead.) For example, at SBE this would be set to '8' if the nX product's phone lines were inside lines. This string is long so it can include other items, such as billing codes, if necessary. (Will contain codes to differentiate V.25 dialing from ATDT dialing.)")
wanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("pcmcia", 1), ("rs232", 2), ("v35", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPortType.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortType.setDescription('Default value on nX: determined by hardware Workshop no longer sets this field This value indicates whether the port is PCMCIA, or a D-shell connection - either RS232 or V.35.')
wanPCMCIACardName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPCMCIACardName.setStatus('mandatory')
if mibBuilder.loadTexts: wanPCMCIACardName.setDescription("Default value on nX: empty string if card not present, else product information from card On nX: from 'ram' (actually hardware), field trial 1 Workshop no longer display this field This object returns the product information read from a PCMCIA card. If the returned value is a 0 length string, then the PCMCIA slot is empty. (60 characters available from hardware.)")
wanIpRipReceiveAdvertisementFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpRipReceiveAdvertisementFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpRipReceiveAdvertisementFlag.setDescription("Default value on nX: 'yes' On nX: both ram and flash, field trial 2 If IP is configured, this object determines whether or not the nX product will accept IP RIP (Routing Information Protocol) from other routers on the network. Advertisements received will be added to the nX product's dynamic routing table.")
wanIpRipSendInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpRipSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpRipSendInterval.setDescription('Default value on nX: 30 On nX: both ram and flash, field trial 2 If IP is configured, this object determines time, in seconds, between nX broadcasts of the IP RIP destination information in its routing tables. If the value equals 0, RIP transmissions are not sent.')
wanIpxRipReceiveBroadcastFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpxRipReceiveBroadcastFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpxRipReceiveBroadcastFlag.setDescription("Default value on nX: ''yes' On nX: both ram and flash, field trial 2 If IPX is configured, this object determines whether or not the nX product will accept IPX RIP (Routing Information Protocol) from other routers on the network. Broadcasts received will be added to the nX product's dynamic routing table.")
wanIpxRipSendInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpxRipSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpxRipSendInterval.setDescription('Default value on nX: 60 On nX: both ram and flash, field trial 2 If IPX is configured, this object determines time, in seconds, between nX broadcasts of the IPX RIP destination information in its routing tables. If the value equals 0, RIP transmissions are not sent.')
wanIpxSapReceiveAdvertisementFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpxSapReceiveAdvertisementFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpxSapReceiveAdvertisementFlag.setDescription("Default value on nX: ''yes' On nX: both ram and flash, field trial 2 If IPX is configured, this object determines whether or not the nX product will accept IPX SAP advertisements from other routers on the network. Advertisements received will be added to the nX product's dynamic SAP table.")
wanIpxSapSendInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpxSapSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpxSapSendInterval.setDescription('Default value on nX: 60 On nX: both ram and flash, field trial 2 If IPX is configured, this object determines time, in seconds, between nX broadcasts of the IPX SAP information in its routing tables. If the value equals 0, SAP advertisements are not sent.')
wanIpxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIpxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: wanIpxNetbios.setDescription("Default value on nX: 'no' On nX: both ram and flash, field trial 2 If IPX is configured, this object determines if NetBIOS broadcasts are to be forwarded across interfaces. (It appears this is only needed if there is an application on the network that initiates a connection with a dialin client, see Shiva LanRover, page 10-6.)")
wanISDNSwitchType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29))).clone(namedValues=NamedValues(("other", 1), ("dss1", 2), ("etsi", 3), ("btnr", 4), ("dass2", 5), ("ess4", 6), ("ess5", 7), ("dms100", 8), ("ni1", 9), ("ni2", 10), ("ni3", 11), ("vn2", 12), ("vn3", 13), ("vn4", 14), ("vn6", 15), ("kdd", 16), ("ins64", 17), ("itr6", 18), ("cornet", 19), ("tad2", 20), ("tad30", 21), ("ts013", 22), ("ts014", 23), ("leased64s", 24), ("leasedS01", 25), ("leasedS02", 26), ("leasedH0", 27), ("leasedT1", 28), ("leasedE1", 29)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNSwitchType.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNSwitchType.setDescription('The particular protocol type supported by the switch providing access to the ISDN network to which this subscriber interface is connected. Note: this entry definition is borrowed from the isdnSubTblSwitchType of the ISDN MIB Internet Draft')
wanISDNCallingPhoneNoB1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNCallingPhoneNoB1.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNCallingPhoneNoB1.setDescription('Default value on nX: empty This item contains the calling phone number for the ISDN B1 channel. ')
wanISDNCallingPhoneNoB2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNCallingPhoneNoB2.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNCallingPhoneNoB2.setDescription('Default value on nX: empty This item contains the calling phone number for the ISDN B1 channel. ')
wanISDNSPID1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNSPID1.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNSPID1.setDescription('Default value on nX: empty This item contains the Service Profile Identifiers (SPID) for the ISDN B1 channel. ')
wanISDNSPID2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNSPID2.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNSPID2.setDescription('Default value on nX: empty This item contains the Service Profile Identifiers (SPID) for the ISDN B2 channel. ')
wanPortGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("group", 1), ("non-group", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanPortGroup.setStatus('mandatory')
if mibBuilder.loadTexts: wanPortGroup.setDescription('Default value on nX: non-group(2) This field is used to identify wether the Wan port is part of the Hunt Group. Port group is used as hunt group in TSD for reserving wan link capacity.')
wanISDNSubAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNSubAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNSubAddress1.setDescription('Default value on nX: empty This item contains the subaddress for the ISDN B1 channel. ')
wanISDNSubAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNSubAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNSubAddress2.setDescription('Default value on nX: empty This item contains the subaddress for the ISDN B2 channel. ')
wanISDNNTTCard = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNNTTCard.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNNTTCard.setDescription('Default value on nX: no(1) This item indicates whether this is an NTT ISDN card.')
wanISDNChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oneb", 1), ("twob", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNChannels.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNChannels.setDescription('Default value on nX: oneb(1) This item indicates the number B channels supported by the ISDN card.')
wanEnableDataCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanEnableDataCompression.setStatus('mandatory')
if mibBuilder.loadTexts: wanEnableDataCompression.setDescription('Default value on nX: no. this entry indicates whether to perform data compression over the ppp connection.')
wanISDNChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cs56", 1), ("cs64", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanISDNChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wanISDNChannelSpeed.setDescription('Default value on nX: cs64. This entry is used to configure the B channel speed of the ISDN card.')
wanUsageMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("routing", 1), ("modempool", 2), ("share", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanUsageMode.setStatus('mandatory')
if mibBuilder.loadTexts: wanUsageMode.setDescription('Default value on nX: 1 This value indicates how the port is used for modem pooling. If 2 or 3 is set, the GSN and SSN also must be set. Note: This is a bit mapped field.')
wanModemPoolGSN = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemPoolGSN.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemPoolGSN.setDescription('The General Service Name used for this port. Used for Modem pooling')
wanModemPoolSSN = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 1, 2, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanModemPoolSSN.setStatus('mandatory')
if mibBuilder.loadTexts: wanModemPoolSSN.setDescription('The Specific Service Name used for this port. Used for Modem pooling')
wanIPAddressTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 5, 2), )
if mibBuilder.loadTexts: wanIPAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanIPAddressTable.setDescription('WanIPAddress table - one copy')
wanIPAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 5, 2, 1), ).setIndexNames((0, "SBE-MIB", "wanIPAddress"))
if mibBuilder.loadTexts: wanIPAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanIPAddressEntry.setDescription(' ')
wanIPAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanIPAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wanIPAddressStatus.setDescription('Indication of whether or not a valid entry.')
wanIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wanIPAddress.setDescription('Default value on nX: 0 On nX: both ram and flash, field trial 2 This item specifies an IP address in the shared pool for remote dial-in user.')
wanStatPortTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3), )
if mibBuilder.loadTexts: wanStatPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortTable.setDescription("Each WAN port's State and Statistical information is contained in a row in a SNMP table")
wanStatPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1), ).setIndexNames((0, "SBE-MIB", "wanStatPortNumber"))
if mibBuilder.loadTexts: wanStatPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortEntry.setDescription('The WAN table information for one WAN port.')
wanStatPortEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortEntryStatus.setDescription('Indication of whether or not a valid entry. This entry is used only to maintain uniformity of all table structures. User can neither delete nor add any entries in the table. Upon query, nX shall always return valid.')
wanStatPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortNumber.setDescription('Same as in wanPortNumber.')
wanStatPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortState.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortState.setDescription('Default value on nX: disconnected.')
wanStatPortUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortUserName.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortUserName.setDescription('Currently connected Destination name or user name. Null if unknown.')
wanStatPortFrameTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortFrameTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortFrameTransmitted.setDescription('# of frames transmitted out of this port.')
wanStatPortFrameReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortFrameReceived.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortFrameReceived.setDescription('# of frames received from this port.')
wanStatPortTransmitError = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortTransmitError.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortTransmitError.setDescription('# of transmit errors detected at this port.')
wanStatPortReceiveError = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortReceiveError.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortReceiveError.setDescription('# of receive errors detected at this port.')
wanStatPortTransmitQueueFull = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortTransmitQueueFull.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortTransmitQueueFull.setDescription('# of times transmit queue full detected at this port.')
wanStatPortCallOriginated = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortCallOriginated.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortCallOriginated.setDescription('# of calls originated from this port. Includes both success and fail.')
wanStatPortCallAnswered = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortCallAnswered.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortCallAnswered.setDescription('# of answers succeeded at this port.')
wanStatPortNoDialTone = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortNoDialTone.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortNoDialTone.setDescription('# of calls failed due to no dial tone. also counted also in CallOriginated')
wanStatPortNoAnswer = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortNoAnswer.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortNoAnswer.setDescription('# of calls failed due to no answer from remote. also counted also in CallOriginated')
wanStatPortBusyDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortBusyDetected.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortBusyDetected.setDescription('# of calls failed due to line busy at remote. also counted also in CallOriginated')
wanStatPortNoCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanStatPortNoCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortNoCarrier.setDescription('# of calls failed due to no carrier. also counted also in CallOriginated')
wanStatPortModemSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortModemSignal.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortModemSignal.setDescription('Modem signal state. Bit masked DCD = 1, CTS =2, DTR = 4, RTS = 8, DSR =16 Bit state: 1 = On ')
wanStatPortConnDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dialin", 1), ("dialout", 2), ("dedicated", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortConnDirection.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortConnDirection.setDescription('Direction of the connection')
wanStatPortProtoUp = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 5, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanStatPortProtoUp.setStatus('mandatory')
if mibBuilder.loadTexts: wanStatPortProtoUp.setDescription('This item is a bit encoded value representing various protocols, which are currently up over this connection. The encoded values are: IP(1), IPX(2), Bridging(4), Compression(8). Any combinations of these values are valid.')
wanIPAddressMaxEntry = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanIPAddressMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanIPAddressMaxEntry.setDescription('maximum # of entry allowed in the wanIPAddressTable.')
ipConfiguredFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipConfiguredFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ipConfiguredFlag.setDescription("Default value on nX: 'no' On nX: both ram and flash, field trial 1 This object is 'no' if IP is not configured for this LX-Product, 'yes' if it is configured.")
ipLANAddress = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLANAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipLANAddress.setDescription("Default value on nX: 0 On nX: both ram and flash, field trial 1 If IP is configured, this object contains the IP address for the nX product's ethernet port and the nX product itself. The user must supply this value if IP is configured. When IP is configured this value must not be 0.")
ipLANSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLANSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipLANSubnetMask.setDescription("Default value on nX: N/A Default value in Workshop: 0 On nX: both ram and flash, field trial 1 If IP is configured, this object contains the subnet mask which the nX product will use for determining which packets are to be sent out over this LAN port. (A packet's IP address is 'anded' with the subnet mask and the result compared against the port's IP address. If there is a match, the packet is sent over the port, otherwise it isn't.)")
ipBroadcastAddress = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipBroadcastAddress.setDescription("Default value on nX: 0 Default value in Workshop: 0 On nX: both ram and flash, field trial 1 If IP is configured, this object contains the IP address which the nX product will use for sending broadcast data. (The nX listens for broadcast data on broadcast addresses with both 0's and all 1's). A zero value means no broadcasts can be sent. This is used for sending RIP advertisements and for indicating which broadcasts are to be forwarded across ports.")
ipDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ipDefaultGateway.setDescription('Default value on nX: N/A Default value in Workshop: 0 On nX: both ram and flash, field trial 2 If IP is configured, this object contains the network address to which the nX product will send all packets that it cannot determine a route for the packet from its routing tables (both static and dynamic).')
ipRipReceiveAdvertisementFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRipReceiveAdvertisementFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ipRipReceiveAdvertisementFlag.setDescription("Default value on nX: 'yes' On nX: both ram and flash, field trial 2 If IP is configured, this object determines whether or not the nX product will accept IP RIP (Routing Information Protocol) from other routers on the network. Advertisements received will be added to the nX product's dynamic routing table.")
ipRipSendInterval = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRipSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipRipSendInterval.setDescription('Default value on nX: 30 On nX: both ram and flash, field trial 2 If IP is configured, this object determines time, in seconds, between nX broadcasts of the IP RIP destination information in its routing tables. If the value equals 0, RIP transmissions are not sent.')
ipDefaultGatewayType = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("lan", 1), ("wan", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDefaultGatewayType.setStatus('mandatory')
if mibBuilder.loadTexts: ipDefaultGatewayType.setDescription('Default value on nX: NONE On nX: both ram and flash, field trial 2 If nX cannot determine a route for the packet from its routing table (both static and dynamic), the packet will be sent to a Default Gateway. If ipDefaultGatewayType is LAN, ipDefaultGateway address will be useed. Otherwise, the Default Gateway is located at WAN port, the packet will be forwarded to the destination defined in ipWanDestinationName or ipWanUserName.')
ipWanDestinationName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipWanDestinationName.setStatus('mandatory')
if mibBuilder.loadTexts: ipWanDestinationName.setDescription('Same as destName in the Destination Table.')
ipWanUserName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipWanUserName.setStatus('mandatory')
if mibBuilder.loadTexts: ipWanUserName.setDescription('Same as userName in the User Table.')
ipStaticRouteMaxEntry = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteMaxEntry.setDescription('maximum # of entry allowed in the ipStaticRouteTable. Default to 32.')
ipStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12), )
if mibBuilder.loadTexts: ipStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteTable.setDescription('IP Static Route table - one copy per IP port.')
ipDefaultGatewayIfType = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lan", 1), ("wan", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDefaultGatewayIfType.setStatus('mandatory')
if mibBuilder.loadTexts: ipDefaultGatewayIfType.setDescription('Default value on nX: NONE If nX cannot determine a route for the packet from its routing table (both static and dynamic), the packet will be sent to a Default Gateway. If ipDefaultGatewayType is LAN, ipDefaultGateway address will be useed. Otherwise, the Default Gateway is located at WAN port, the packet will be forwarded to the destination defined in ipWanDestinationName or ipWanUserName.')
ipBroadcastForwardTypes = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipBroadcastForwardTypes.setStatus('mandatory')
if mibBuilder.loadTexts: ipBroadcastForwardTypes.setDescription('Default value on nX: 0 This is a bit encoded value representing the types of IP broadcast forwarding over WAN to be enabled. This is a global setting for the NX. The mib entry destDialoutProtoSupport is used to control the IP broadcast forwarding to an invidual site. The encoded values are: NetBIOS(2), DNS(4), DHCP/BOOTP(8). Any combination of these values or NOBCASTFWD(1) are the only valid values.')
ipStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1), ).setIndexNames((0, "SBE-MIB", "ipStaticRouteDestinationAddress"))
if mibBuilder.loadTexts: ipStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteEntry.setDescription('The static route information for one route for this port.')
ipStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteStatus.setDescription('Indication of whether or not a valid entry.')
ipStaticRouteDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteDestinationAddress.setDescription("This is a destination network or host IP address. Packets that the nX product processes for this address will be routed as indicated by the remaining entries in this row. This value has already been 'anded' with the IP Destination Subnet Mask.")
ipStaticRouteDestinationSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteDestinationSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteDestinationSubnetMask.setDescription('Workshop should display by default the subnet mask based on class of destination IP address, the nX should not assume any default subnet value. This subnet mask is applied to destination address in packets processed by the nX product and then the resulting value is compared against the IP Destination Address. If a match is found, the packet is forwarded over the indicated destination interface.')
ipStaticRouteDestinationHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteDestinationHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteDestinationHopCount.setDescription('The value of this object indicates the number of hops between the nX product and the IP Destination Address. The hop count is often used as an indicator of the relative cost for using this route. This will be used by the LX to optimize the use of routes learned. By IP convention, if the hop count equals 16 the routing entry is disabled.')
ipStaticRouteDestinationName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteDestinationName.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteDestinationName.setDescription('Same as destName in the Destination Table.')
ipStaticRouteNetworkInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lan", 1), ("wan", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteNetworkInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteNetworkInterface.setDescription('Indication of which interface type to route this packet to. If LAN is defined, ipStaticRouteGateway must be defined. Otherwise, at least one of ipStaticRouteUserName and ipStaticRouteDestinationName must be defined.')
ipStaticRouteUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteUserName.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteUserName.setDescription('Same as userName in the User Table.')
ipStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 3, 12, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticRouteGateway.setDescription('This is the Gateway IP address of the static route.')
ipxConfiguredFlag = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipx-and-auto-learn-both-off", 1), ("ipx-off-and-auto-learn-on", 2), ("ipx-on-and-auto-learn-off", 3), ("ipx-and-auto-learn-both-on", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxConfiguredFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ipxConfiguredFlag.setDescription("Default value on nX: 'ipx-and-auto-learn-both-off (1)' On nX: both ram and flash, This object reflects the state of ipx and auto-learning configuration as described by the names of the values.")
ipxNetbios = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNetbios.setDescription("Default value on nX: no (1) This object reflects the state of NetBIOS (IPX Type20) frame forwarding for the NX. NetBIOS forwarding is enabled for a specific site only when this object is set to 'yes' and NetBIOS/IPX bit is set in the destDialoutProtoSupport object for the site.")
ipxMultiFrameTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9), )
if mibBuilder.loadTexts: ipxMultiFrameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameTable.setDescription('IPX multifram type support, the table contains fix size of 4 entries. They can not be added or deleted.')
ipxMultiFrameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9, 1), ).setIndexNames((0, "SBE-MIB", "ipxMultiFrameType"))
if mibBuilder.loadTexts: ipxMultiFrameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameEntry.setDescription('The community information for this community.')
ipxMultiFrameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxMultiFrameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameStatus.setDescription('Indication of whether or not a valid entry. User can only use Modify')
ipxMultiFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ieee-8022", 1), ("ieee-8023-raw", 2), ("ieee-8022-SNAP", 3), ("ethernet-II", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxMultiFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameType.setDescription('Default value on nX: IEEE 802.2')
ipxMultiFrameSelectFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxMultiFrameSelectFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameSelectFlag.setDescription('Default value on nX: there must be at least a entry is = yes')
ipxMultiFrameNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 4, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxMultiFrameNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxMultiFrameNetworkAddress.setDescription("Default value on nX: 0 If IPX Manual Set Network Address is set to 'yes', this object specifies the IPX Network Address that the nX product will use for packets sent to it. Normally the IPX Node Address is automatically taken from the network.")
ipxNetAddressAutoLearnStateCounter = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxNetAddressAutoLearnStateCounter.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNetAddressAutoLearnStateCounter.setDescription('Default value on nX: 0 If IPX is configured, and Auto learn is Yes. this object determines the time (in sec) remaining in the IPX auto learn phase. If the value is non-zero, nX auto learn is in progress. Workshop will continue to poll this mib item, and ipxMultiFrameTable.')
snmpCommunityNameTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 10, 1), )
if mibBuilder.loadTexts: snmpCommunityNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityNameTable.setDescription('Community name table')
snmpCommunityNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 10, 1, 1), ).setIndexNames((0, "SBE-MIB", "snmpCommunityName"))
if mibBuilder.loadTexts: snmpCommunityNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityNameEntry.setDescription('The community information for this community.')
snmpCommunityNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpCommunityNameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityNameStatus.setDescription('Indication of whether or not a valid entry.')
snmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityName.setDescription('Default value on nX: none On nX: both ram and flash, field trial 1 This item defines a community name to be recognized by the nX Product. For convenience of the user, Workshop will restrict community strings to be ASCII characters.')
snmpCommunityPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("readonly", 1), ("readwrite", 2), ("lanuser", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpCommunityPermission.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityPermission.setDescription('Default value on nX: Three rows are defined initially, one with each of the above permissions. On nX: both ram and flash This item defines the permission level for its associated Community Name.')
snmpMacServerTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 10, 2), )
if mibBuilder.loadTexts: snmpMacServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpMacServerTable.setDescription('SNMP MAC server table - one copy')
snmpMacServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 10, 2, 1), ).setIndexNames((0, "SBE-MIB", "snmpMacServerAddress"))
if mibBuilder.loadTexts: snmpMacServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpMacServerEntry.setDescription('The SNMP MAC server information for one server.')
snmpMacServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpMacServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpMacServerStatus.setDescription('Indication of whether or not a valid entry.')
snmpMacServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpMacServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: snmpMacServerAddress.setDescription('Default value on nX: none On nX: both ram and flash, field trial 1 This item contains the MAC address of the server to which SNMP traps are to be sent. A value of zero indicates no server.')
snmpIpServerTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 10, 3), )
if mibBuilder.loadTexts: snmpIpServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpIpServerTable.setDescription('SNMP IP server table - one copy')
snmpIpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 10, 3, 1), ).setIndexNames((0, "SBE-MIB", "snmpIpServerAddress"))
if mibBuilder.loadTexts: snmpIpServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpIpServerEntry.setDescription('The SNMP IP server information for one server.')
snmpIpServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpIpServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpIpServerStatus.setDescription('Indication of whether or not a valid entry.')
snmpIpServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 10, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpIpServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: snmpIpServerAddress.setDescription('Default value on nX: 0 On nX: both ram and flash, field trial 1 This item contains the IP address of the server to which SNMP traps are to be sent. A value of zero indicates no server.')
snmpCommunityNameMaxEntry = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 10, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityNameMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityNameMaxEntry.setDescription('Max # of entries allowed in snmpCommunityName table')
destTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1), )
if mibBuilder.loadTexts: destTable.setStatus('mandatory')
if mibBuilder.loadTexts: destTable.setDescription('Destination table - one copy')
destEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1), ).setIndexNames((0, "SBE-MIB", "destName"))
if mibBuilder.loadTexts: destEntry.setStatus('mandatory')
if mibBuilder.loadTexts: destEntry.setDescription('The information for one destination.')
destStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destStatus.setStatus('mandatory')
if mibBuilder.loadTexts: destStatus.setDescription('Indication of whether or not a valid entry.')
destName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: destName.setStatus('mandatory')
if mibBuilder.loadTexts: destName.setDescription("Default value on nX: none On nX: both ram and flash, field trial 1 This item contains a user supplied identification for this destination. This should be something meaningful to the user, such as 'Home Office'. In a later release, User Table entries will include a destination field for dialout.")
destType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lan-to-lan", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destType.setStatus('mandatory')
if mibBuilder.loadTexts: destType.setDescription('Default value on nX: Lan-to-Lan On nX: (not necessary in first release) both ram and flash, field trial 2 This item indicates whether the destination is a LAN or remote access. A Lan destination indicates Lan-to-Lan traffic over the link. All destinations are PPP serial communication. There will be other types, e.g. Remote-access, in later versions of the LX.')
destDialoutPhoneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutPhoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutPhoneNumber.setDescription('Default value on nX: empty On nX: both ram and flash, field trial 1 This item contains the phone number that is to be used to call the destination. This string contains just the AT command set characters for the phone number. During dialout, the nX forms the entire dialout string by prefixing this item with the Modem Dial Prefix.')
destDialoutProtoSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutProtoSupport.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutProtoSupport.setDescription('Default value on nX: 0 On nX: both ram and flash, This item is a bit encoded value representing various protocols to be enabled during the establishment of a WAN connection. The encoded values are: IP(1), IPX(2), Bridging(4), NetBIOS/IPX(8), IPBCASTFWD(16). Any combination of IP, IPX and Bridging is valid. NetBIOS/IPX is valid only if IPX bit is set. IPBCASTFWD is valid only if IP bit is set. Value zero is invalid')
destDialoutIpxSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutIpxSupport.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutIpxSupport.setDescription("NOTE: THIS FIELD IS NO LONGER IN USE. The field destDialoutProtoSupport is used to encode all protocols supported. Default value on nX: same as IP Configured Flag On nX: both ram and flash This item equals 'yes' if the dialout destination supports IPX, and 'no' otherwise. No IPX traffic will be routed or bridged to this destination if the value is 'no'. The IPX Configured Flag must be 'yes' for this field to be 'yes'.")
destDialoutModemSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200))).clone(namedValues=NamedValues(("twelvehundred", 1200), ("twentyfourhundred", 2400), ("fortyeighthundred", 4800), ("ninetysixhundred", 9600), ("nineteentwelve", 19200), ("thirtyeigthfour", 38400), ("fiftysevensix", 57600), ("onefifteentwo", 115200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutModemSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutModemSpeed.setDescription("Default value on nX: 'unspecified' On nX: both ram and flash, This item allows the user to override the Modem Speed set up for the port for dialout calls to this destination. If the value of this item is 'unspecified', then the Modem Speed for the port is used. The user might specify this to shorten the time it takes for the modems to negotiate speed.")
destPppMtuMru = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destPppMtuMru.setStatus('mandatory')
if mibBuilder.loadTexts: destPppMtuMru.setDescription("Default value on nX: 1500 On nX: both ram and flash, field trial 2 This field can be used to override the global MTR/MTU. The user should set this field if the destination or the Wan link has special requirements. Any value less than the minimum value allowed for a port's MTR/MRU will be interpreted as an unspecified value and the MTR/MRU value for the nX will be used. (Perhaps the user could be asked for line quality and the nX or Workshop automatically determine MTU/MRU.)")
destDialoutHandshake = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutHandshake.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutHandshake.setDescription("Default value on nX: 'none' On nX: both ram and flash, 'none' and 'PAP' for field trial 1 This field identifies the type of authorization negotiation that is to be performed during dialout to this destination. (On dialin, the handshake is determined by the caller.)")
destDialoutUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutUserName.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutUserName.setDescription("Default value on nX: 0 On nX: both ram and flash, field trial 1 This value identifies a User Name for PAP or CHAP dialout to this destination. This entry is only valid if Destination Handshake if a value other than 'none'.")
destDialoutPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutPassword.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutPassword.setDescription("Default value on nX: 0 On nX: both ram and flash, field trial 1 This value identifies the user password for PAP or CHAP dialout to this destination. This entry is only valid if Destination Handshake if a value other than 'none'.")
destPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destPorts.setStatus('mandatory')
if mibBuilder.loadTexts: destPorts.setDescription('Default Value on nX: 0. This field indicates the port number associated with this site, if the link characteristic wanLinkDialupFlag is set to dedicated(2).')
destMaximumDialoutConnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destMaximumDialoutConnectTime.setStatus('mandatory')
if mibBuilder.loadTexts: destMaximumDialoutConnectTime.setDescription('Default value on nX: 0 On nX: both ram and flash, field trial 1 This object contains, in minutes, the maximum time to leave this connection active for dialout. After the time elapses, the nX will automatically hangup the connection, assuming the user has not already manually terminated the connection. A value of zero means there is no time limit. For any given call, this time by be shortened because of a value in the User Maximum Dialout Connect Time object. (For dialin, the maximum connect time comes from the User Table.) (If we require a default user name for the destination, we could take the maximum dialout time from the User Table.)')
destDialoutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("dialing", 2), ("connected", 3), ("connection-failed", 4), ("disconnected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: destDialoutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutStatus.setDescription('Default value on nX: none This item is used by the Workshop to determine the status of a dialout for this destination.')
destDialoutSchedule = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(96, 96)).setFixedLength(96)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutSchedule.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutSchedule.setDescription("Default value on nX: 0 On nX: both ram and flash, field trial 2 This is a one-week bit map, with one bit for every 15 minutes. The string is organized a 8 groups of 12 bytes (96 bits), one group for each day of the week plus the 8th for all holidays, starting with Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Holiday. The first bit in each group is for midnight (12:00 AM) to 12:15 AM, the next for 12:15 AM to 12:30 AM, etc. If the bit for a time interval equals 1, a dialout connection to this destination is to be active during this time period. If the bit for a time interval equals 0, there is to be no dialout connection to this destination during this time period. This encoding of dialout times means dialout must be specified in 15 minutes intervals. (Depending on the user interface, Workshop may be able to reconstruct the user's input from this bit string. If it can't, it will be necessary to define an object that contains encoding for Workshop -- or change this object so it can be used by both the nX and Workshop.) This field does not apply to leased lines.")
destHolidaySchedule = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("normal", 1), ("nodialout", 2), ("sunday", 3), ("monday", 4), ("tuesday", 5), ("wednesday", 6), ("thursday", 7), ("friday", 8), ("saturday", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destHolidaySchedule.setStatus('mandatory')
if mibBuilder.loadTexts: destHolidaySchedule.setDescription("Default value on nX: 0 NO LONGER USED. This item specifies which day's dialout schedule is to be used for holidays. For example, this allows a person to specify that on holidays to use Sunday's dialout schedule. 'Normal' indicates that the day's standard dialout schedule is to be used. 'Nodialout' indicates that no dialout at all is to occur on holidays.")
destLinkLayerNRZFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nrz", 1), ("nrzi", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destLinkLayerNRZFlag.setStatus('mandatory')
if mibBuilder.loadTexts: destLinkLayerNRZFlag.setDescription('Default value on nX: nrz On nX: both ram and flash, field trial 1 (may be encoded into Link Layer Type) If appropriate for the Link Line Type, this flag identifies whether the line is nrz or nrzi. (See wan NRZ Flag.)')
destLinkLayerProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("ppp", 2), ("isdn", 3), ("x25", 4), ("framerelaydte", 5), ("framerelaydce", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destLinkLayerProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: destLinkLayerProtocolType.setDescription('Default value on nX: ppp On nX: both ram and flash, This flag identifies whether the Link Line Type is ppp. Other options are not supported at this time.')
destLinkDialupFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dialup", 1), ("dedicated", 2), ("dtr-dial", 3), ("isdn-dialup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destLinkDialupFlag.setStatus('mandatory')
if mibBuilder.loadTexts: destLinkDialupFlag.setDescription('Default value on nX: dialup On nX: both ram and flash, field trial 1 (may be encoded into Link Layer Type) If appropriate for the Link Line Type, this flag identifies whether the line is dialup (switched), dedicated, or DTR dial.')
destPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("pcmcia", 1), ("rs232", 2), ("v35", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destPortType.setStatus('mandatory')
if mibBuilder.loadTexts: destPortType.setDescription("Default value on nX: determined by hardware On nX: from 'ram' (actually hardware), field trial 2 This value indicates whether the dest port is PCMCIA, or a D-shell connection - either RS232 or V.35.")
destLinkLayerType = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("async", 1), ("sync", 2), ("autosync", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destLinkLayerType.setStatus('mandatory')
if mibBuilder.loadTexts: destLinkLayerType.setDescription('Default value on nX: async On nX: both ram and flash, field trial 1 This object identifies the type of communication link that is used by this destination. Some data link types require further qualification.')
destDialoutStatusData = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: destDialoutStatusData.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutStatusData.setDescription('It has the same format as the event messages: Message # : 2 bytes Date/Time stamping: 4 bytes (integer, msb first) Length: n bytes defining the size of the parameter list that folllows ( 0 is allowed) Message parameters: n bytes, associated with the message #. ')
destDialoutScheduleFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutScheduleFlag.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutScheduleFlag.setDescription('Default value on nX: disable ')
destDialinUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialinUserName.setStatus('mandatory')
if mibBuilder.loadTexts: destDialinUserName.setDescription(' This value identifies a User Name for PAP or CHAP dialin to this destination. ')
destDialinPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialinPassword.setStatus('mandatory')
if mibBuilder.loadTexts: destDialinPassword.setDescription(' This value identifies the user password for PAP or CHAP dialin to this destination.')
destMaximumDialinConnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destMaximumDialinConnectTime.setStatus('mandatory')
if mibBuilder.loadTexts: destMaximumDialinConnectTime.setDescription(' This object contains, in minutes, the maximum time to leave this connection active for dialin connections. After the time elapses, the nX will automatically hangup the connection, assuming the user has not already manually terminated the connection. A value of zero means there is no time limit.')
destTSDFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tsd", 1), ("non-tsd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destTSDFlag.setStatus('mandatory')
if mibBuilder.loadTexts: destTSDFlag.setDescription(' Default value on nX: non-tsd This entry defines this Destination (Site) to be either a TSD or non-TSD site. If TSD site, then destTSDInactivityTime, destTSDMaxTime, and destPortGroup are meaningful. ')
destTSDInactivityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destTSDInactivityTime.setStatus('mandatory')
if mibBuilder.loadTexts: destTSDInactivityTime.setDescription(' This object contains, in minutes, the maximum time. A value of zero means there is no time limit.')
destTSDMaxDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destTSDMaxDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: destTSDMaxDownTime.setDescription(' A value of zero means there is no time limit.')
destTSDPortGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destTSDPortGroup.setStatus('mandatory')
if mibBuilder.loadTexts: destTSDPortGroup.setDescription('Default value on nX: 0. This field is used to identify the Wan port # to which this TSD entry is assigned. port group #128 is used as hunt group in TSD for reserving wan link capacity.')
destManualDialCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destManualDialCallback.setStatus('mandatory')
if mibBuilder.loadTexts: destManualDialCallback.setDescription(' This item indicates whether callback is enabled in Manual Dial mode.')
destAllowDynamicIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destAllowDynamicIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: destAllowDynamicIPAddr.setDescription('this entry indicates whether the ip address provided by the remote router (through IPCP negotiation), for the use on the local WAN port, is permitted.')
destISDNChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oneb", 1), ("twob", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destISDNChannels.setStatus('mandatory')
if mibBuilder.loadTexts: destISDNChannels.setDescription('This entry indicates the number B channels supported by the ISDN card (configured from the port page).')
destDialoutPhoneNumber2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destDialoutPhoneNumber2.setStatus('mandatory')
if mibBuilder.loadTexts: destDialoutPhoneNumber2.setDescription('Default value on nX: empty This item contains the second phone number that is to be used to call the destination using the second ISDN B channel. This string contains just the AT command set characters for the phone number. During dialout, the nX forms the entire dialout string by prefixing this item with the Modem Dial Prefix.')
destTSDExpectCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destTSDExpectCallback.setStatus('mandatory')
if mibBuilder.loadTexts: destTSDExpectCallback.setDescription('Default value on nX: no Determines whether to expect a callback. If callback is expected, re-dial should delay as specified by syReverseCallbackDelay')
destMaxEntry = MibScalar((1, 3, 6, 1, 4, 1, 1055, 2, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: destMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: destMaxEntry.setDescription('Max # of entries allowed in Destination table')
destScriptTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3), )
if mibBuilder.loadTexts: destScriptTable.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptTable.setDescription('Destination script table')
destScriptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2), ).setIndexNames((0, "SBE-MIB", "destinationName"))
if mibBuilder.loadTexts: destScriptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptEntry.setDescription('Chat script information for a destination')
destScriptEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScriptEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptEntryStatus.setDescription('Indication of whether or not a valid entry.')
destinationName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: destinationName.setStatus('mandatory')
if mibBuilder.loadTexts: destinationName.setDescription('Same as destName in the Destination Table.')
destScriptUseFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScriptUseFlag.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptUseFlag.setDescription('This entry indicates whether the script associated with this site should be executed or not.')
destScriptTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScriptTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptTimeout.setDescription('This field specifies the total time limit allocated for the execution of the script to completion')
destScriptName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScriptName.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptName.setDescription('This entry contains the the name of the script.')
destScript = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScript.setStatus('mandatory')
if mibBuilder.loadTexts: destScript.setDescription('This entry contains the chat script identified by the entry destScriptName.')
destScriptStartupCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 6, 3, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destScriptStartupCmd.setStatus('mandatory')
if mibBuilder.loadTexts: destScriptStartupCmd.setDescription('This entry contains the command used to indicate the service type to the ISP, if required.')
eventTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 2, 11, 1), )
if mibBuilder.loadTexts: eventTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventTable.setDescription('Event table - one copy ')
eventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 2, 11, 1, 1), ).setIndexNames((0, "SBE-MIB", "eventGroupIndex"))
if mibBuilder.loadTexts: eventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventEntry.setDescription('The event information of one event data.')
eventGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eventGroupIndex.setDescription('index into the event log table entry. It is a reference point where the SNMP manager will issue the GET NEXT request to get the next group of events. nX needs to set this value to match the last SEQUENCE # that is returned in the eventData.')
eventData = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 2, 11, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventData.setStatus('mandatory')
if mibBuilder.loadTexts: eventData.setDescription('A group of event log entries. Each entry will be one event with the following format: Sequence #: 2 bytes Message # : 2 bytes Date/Time stamping: 4 bytes (integer, msb first) Length: n bytes defining the size of the parameter list that follows ( 0 is allowed) Message parameters: n bytes, associated with the message #. ')
discNodeName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: discNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: discNodeName.setDescription('The Node Name consists of the hardware type and MAC address as follows: SoHo-001122334455 for SoHo, Central001122334455 for Central Torte-001122334455 for Torte (not available) Rout-001122334455 for ROUTEMAN (1/2 meg version) RoutXL-001122334455 for ROUTEMANXL (1 meg version). ')
discModel = MibScalar((1, 3, 6, 1, 4, 1, 1055, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(256, 257, 258, 259, 260))).clone(namedValues=NamedValues(("soho", 256), ("central", 257), ("torte", 258), ("routeman", 259), ("routemanxl", 260)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: discModel.setStatus('mandatory')
if mibBuilder.loadTexts: discModel.setDescription('The Model contains a numeric identifier for the hardware model, as follows: 256 - SoHo, 257 - Central, 258 - Torte (not available), 259 - ROUTEMAN, 260 - ROUTEMANXL (1 meg version). ')
discProto = MibScalar((1, 3, 6, 1, 4, 1, 1055, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mac", 1), ("ip", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: discProto.setStatus('mandatory')
if mibBuilder.loadTexts: discProto.setDescription('The Discover Protocol is the protocol over which the last Get request was received from. ')
syFMOperation = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("beginCopy", 2), ("copyDone", 3), ("deleteFile", 4), ("renameFile", 5), ("listDir", 6), ("checkSum", 7), ("abortCopy", 8), ("getFileInfo", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syFMOperation.setStatus('mandatory')
if mibBuilder.loadTexts: syFMOperation.setDescription('This object is used to initiate a file management operation. Operations are as described below. If this object is read, other(1) will be returned.')
syFMTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syFMTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: syFMTimeStamp.setDescription('This specifies the value of sysUpTime when the most recent file management operation was initiated.')
syFMError = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 1), ("successful", 2), ("inProgress", 3), ("noResponse", 4), ("noFile", 5), ("noSpace", 6), ("noPermission", 7), ("timeout", 8), ("badChecksum", 9), ("badOperation", 10), ("aborted", 11), ("other", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syFMError.setStatus('mandatory')
if mibBuilder.loadTexts: syFMError.setDescription('This object identifies the results of the most recent attempt at a file operation. If no file operations have been attempted since the system was initialized, this object will have the value none(1).')
syFileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 4, 4))
syFileInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1055, 4, 5))
syFileInfoVersion = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 5, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: syFileInfoVersion.setStatus('mandatory')
if mibBuilder.loadTexts: syFileInfoVersion.setDescription('The version string from a module header. Example, $Release: 2.0.4a $File: lxkernel.gz $Type: kernelFile $DateTime: 07/09/96 19:11 $ProductType: SoHo $Lic: (C)1996 SBE,Inc $Release: is a three part number X.Y.Z, e.g. 2.0.4a $File: is up to 8.3 character file name, e.g. lxkernel.gz $Type: is kernelFile or moduleFile $DateTime: is Month/DayNumber/Year TimeOfDay $ProductType: is the hardware, e.g. SoHo, Central, Routeman, RoutXL $Lic: is (C) Year(s) SBE,Inc Sound files and internal configuration files have null syFileInfoVersion strings.')
syFileInfoChecksum = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: syFileInfoChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: syFileInfoChecksum.setDescription('This MIB entry is used to retrieve the Information related to a file on the nX File System. The File information contains version string, checksum and length of the file. Information in this field is mapped in to the file information structure by the nX and Workshop.')
syFileInfoLength = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 5, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: syFileInfoLength.setStatus('mandatory')
if mibBuilder.loadTexts: syFileInfoLength.setDescription('This MIB entry is used to retrieve the Information related to a file on the nX File System. The File information contains version string, checksum and length of the file. Information in this field is mapped in to the file information structure by the nX and Workshop.')
syDirTable = MibTable((1, 3, 6, 1, 4, 1, 1055, 4, 6), )
if mibBuilder.loadTexts: syDirTable.setStatus('mandatory')
if mibBuilder.loadTexts: syDirTable.setDescription('The directory entry of one file.')
syDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1), ).setIndexNames((0, "SBE-MIB", "syDirName"))
if mibBuilder.loadTexts: syDirEntry.setStatus('mandatory')
syDirStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("create-request", 2), ("under-creation", 3), ("invalid", 4), ("modify", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syDirStatus.setStatus('mandatory')
syDirName = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syDirName.setStatus('mandatory')
syDirCompressSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syDirCompressSize.setStatus('mandatory')
syDirVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syDirVersion.setStatus('mandatory')
syDirUncompressSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1055, 4, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syDirUncompressSize.setStatus('mandatory')
fileName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileName.setStatus('mandatory')
if mibBuilder.loadTexts: fileName.setDescription('This field contains a null terminated string in the format of nnnnnnnn.xxx (DOS format file name). The file name is used by the delete file operation, or the get file info operation.')
fileNameFrom = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileNameFrom.setStatus('mandatory')
if mibBuilder.loadTexts: fileNameFrom.setDescription('This field contains a null terminated string in the format of nnnnnnnn.xxx (DOS format file name). The file name is the old file name used by the rename file operation.')
fileNameTo = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileNameTo.setStatus('mandatory')
if mibBuilder.loadTexts: fileNameTo.setDescription('This field contains a null terminated string in the format of nnnnnnnn.xxx (DOS format file name). The file name is the new file name used by the rename file operation.')
fileTransferStatus = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inActive", 1), ("inProgress", 2), ("waitingCopy", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferStatus.setDescription('This identifies the current status of the file Transfer operation. If there is a transfer in progress, this object will have the value inProgress(2). Otherwise inactive(1) will be returned.')
fileTransferStartTime = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileTransferStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferStartTime.setDescription('This specifies the value of sysUpTime when the most recent file Transfer operation was initiated.')
fileTransferFileLength = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferFileLength.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferFileLength.setDescription('This specifies the total Data Length of current file being transferred, in bytes.')
fileTransferCheckSum = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferCheckSum.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferCheckSum.setDescription('This specifies the CCITT cyclic redundancy checksum of current file being transffered.')
fileTransferDirection = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("copyingFromLX", 2), ("copyingToLXRAM", 3), ("copyingToLXFlash", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileTransferDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferDirection.setDescription('This identifies the current direction of the file Transfer operation. If there is a transfer in progress, this object will have the value copyingFromLX(2), if file is being copied to the Box. Otherwise it will have copyingToLX(1). If no transfer in progress none will be returned.')
fileTransferLastRcvTime = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileTransferLastRcvTime.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferLastRcvTime.setDescription('This specifies the value of sysUpTime when the most recent file Object was received. This value is used to time out the File Transfer operation if no File Object is received within a timeout period.')
fileTransferRemoteAddr = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileTransferRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferRemoteAddr.setDescription('This object specifies the MAC Address of the Remote management stations which initiated the file transfer.')
fileTransferRemoteFileName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferRemoteFileName.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferRemoteFileName.setDescription('This specifies the path and name of a Remote file residing on the remote management station. sbeFileTransferRemoteAddr For LAN Boot this item MUST be 12 characters in length!')
fileTransferLocalFileName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferLocalFileName.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferLocalFileName.setDescription('This specifies the name of Local File being transferred. For the File Transfer TO the remote station this becomes the name of the source file. For the FROM operation this is the name of the local file where the new file will be stored. For LAN Boot this item MUST be 12 characters in length!')
fileTransferData = MibScalar((1, 3, 6, 1, 4, 1, 1055, 4, 4, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(532, 532)).setFixedLength(532)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferData.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferData.setDescription('This field contains the data of the file being transfered. The data has a header inside which contains information about the file being transfered and the current data block.')
modempoolEnabled = MibScalar((1, 3, 6, 1, 4, 1, 1055, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modempoolEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: modempoolEnabled.setDescription("Default value on nX: disabled On nX: both ram and flash, field trial 1 If this value is 'enabled', the modem pool is enabled. If this value is 'disabled', if the modem pool is disabled.")
modempoolNodeName = MibScalar((1, 3, 6, 1, 4, 1, 1055, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modempoolNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: modempoolNodeName.setDescription('The nodename contains the modem server name advertised in SAP and UDP broadcasts')
modempoolProtoSupport = MibScalar((1, 3, 6, 1, 4, 1, 1055, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modempoolProtoSupport.setStatus('mandatory')
if mibBuilder.loadTexts: modempoolProtoSupport.setDescription('Default value on nX: 0 On nX: both ram and flash, This item is a bit encoded value representing various protocols to be used for server advertisement. The encoded values are: IP(1), IPX(2). Any combination of these values is valid. Zero is invalid')
dummyStopperForWorkshopForGetNext = MibScalar((1, 3, 6, 1, 4, 1, 1055, 65535, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dummyStopperForWorkshopForGetNext.setStatus('mandatory')
mibBuilder.exportSymbols("SBE-MIB", wanDefaultDialinIPXNodeAddress=wanDefaultDialinIPXNodeAddress, wanPortTable=wanPortTable, destinationName=destinationName, ipRipSendInterval=ipRipSendInterval, destName=destName, destDialinUserName=destDialinUserName, userDialInMax=userDialInMax, destManualDialCallback=destManualDialCallback, userIpAddress=userIpAddress, syBootInfo=syBootInfo, snmpCommunityName=snmpCommunityName, wanPortEntryStatus=wanPortEntryStatus, syFileInfoVersion=syFileInfoVersion, wanStatPortTransmitQueueFull=wanStatPortTransmitQueueFull, holidayMaxEntries=holidayMaxEntries, fileTransferStartTime=fileTransferStartTime, wanISDNSubAddress2=wanISDNSubAddress2, fileTransferCheckSum=fileTransferCheckSum, syDialbackRetryInterval=syDialbackRetryInterval, wanStatPortModemSignal=wanStatPortModemSignal, fileTransferStatus=fileTransferStatus, destLinkLayerNRZFlag=destLinkLayerNRZFlag, destScriptTable=destScriptTable, wanStatPortNumber=wanStatPortNumber, ipxMultiFrameSelectFlag=ipxMultiFrameSelectFlag, modempoolNodeName=modempoolNodeName, wanIpxRipReceiveBroadcastFlag=wanIpxRipReceiveBroadcastFlag, destTable=destTable, destTSDMaxDownTime=destTSDMaxDownTime, modempoolProtoSupport=modempoolProtoSupport, ipWanUserName=ipWanUserName, snmpIpServerAddress=snmpIpServerAddress, wanLinkLayerType=wanLinkLayerType, snmpMacServerAddress=snmpMacServerAddress, syDialinAuthentication=syDialinAuthentication, wanIPAddressStatus=wanIPAddressStatus, ipx=ipx, sySaveRamToFlashState=sySaveRamToFlashState, wanIpxRipSendInterval=wanIpxRipSendInterval, holidayDate=holidayDate, destScript=destScript, holidayEntry=holidayEntry, eventGroupIndex=eventGroupIndex, syFileInfo=syFileInfo, fileNameFrom=fileNameFrom, sySerialNumber=sySerialNumber, userName=userName, destDialoutSchedule=destDialoutSchedule, discModel=discModel, routsys=routsys, destTSDFlag=destTSDFlag, destScriptUseFlag=destScriptUseFlag, wanISDNSPID1=wanISDNSPID1, discovery=discovery, snmpMacServerEntry=snmpMacServerEntry, fileTransferRemoteAddr=fileTransferRemoteAddr, syReverseCallbackTimeout=syReverseCallbackTimeout, wanStatPortEntryStatus=wanStatPortEntryStatus, ipLANSubnetMask=ipLANSubnetMask, syFMOperation=syFMOperation, destDialoutHandshake=destDialoutHandshake, wanStatPortReceiveError=wanStatPortReceiveError, syBridgeFilterFlag=syBridgeFilterFlag, syBridgeTable=syBridgeTable, snmpCommunityNameTable=snmpCommunityNameTable, fileTransferFileLength=fileTransferFileLength, ipStaticRouteUserName=ipStaticRouteUserName, ipStaticRouteStatus=ipStaticRouteStatus, ipStaticRouteDestinationSubnetMask=ipStaticRouteDestinationSubnetMask, wanISDNSubAddress1=wanISDNSubAddress1, wanStatPortFrameTransmitted=wanStatPortFrameTransmitted, wanStatPortProtoUp=wanStatPortProtoUp, endOfSBEMib=endOfSBEMib, fileName=fileName, snmpCommunityNameMaxEntry=snmpCommunityNameMaxEntry, destScriptName=destScriptName, wanIpxNetbios=wanIpxNetbios, syDialbackRetryLimit=syDialbackRetryLimit, wanModemInitializationString=wanModemInitializationString, wanStatPortCallOriginated=wanStatPortCallOriginated, wanStatPortCallAnswered=wanStatPortCallAnswered, wanModemDialPrefix=wanModemDialPrefix, ipConfiguredFlag=ipConfiguredFlag, destDialoutPhoneNumber2=destDialoutPhoneNumber2, wanPortEnabled=wanPortEnabled, ipLANAddress=ipLANAddress, wanISDNNTTCard=wanISDNNTTCard, ipxNetbios=ipxNetbios, fileTransferData=fileTransferData, wanDefaultIPXNetworkAddress=wanDefaultIPXNetworkAddress, fileTransferDirection=fileTransferDirection, wanStatPortBusyDetected=wanStatPortBusyDetected, ipStaticRouteNetworkInterface=ipStaticRouteNetworkInterface, syDirUncompressSize=syDirUncompressSize, destType=destType, wanLinkLayerNRZFlag=wanLinkLayerNRZFlag, wanStatPortTable=wanStatPortTable, destScriptStartupCmd=destScriptStartupCmd, destDialoutStatus=destDialoutStatus, syBridgeStatus=syBridgeStatus, wanPCMCIACardName=wanPCMCIACardName, destHolidaySchedule=destHolidaySchedule, syRAMConfigurationChangedFlag=syRAMConfigurationChangedFlag, destDialoutUserName=destDialoutUserName, ipxMultiFrameType=ipxMultiFrameType, destStatus=destStatus, destLinkDialupFlag=destLinkDialupFlag, ipStaticRouteMaxEntry=ipStaticRouteMaxEntry, destDialoutScheduleFlag=destDialoutScheduleFlag, syMtuMru=syMtuMru, syDirCompressSize=syDirCompressSize, fileNameTo=fileNameTo, wanPortNumber=wanPortNumber, wanIpRipSendInterval=wanIpRipSendInterval, snmpCommunityPermission=snmpCommunityPermission, destDialoutProtoSupport=destDialoutProtoSupport, ipStaticRouteEntry=ipStaticRouteEntry, userPermissions=userPermissions, wanUsageMode=wanUsageMode, snmpMacServerTable=snmpMacServerTable, syControlVariableIntegerOne=syControlVariableIntegerOne, wanDialoutAllowedFlag=wanDialoutAllowedFlag, destination=destination, wanIpRipReceiveAdvertisementFlag=wanIpRipReceiveAdvertisementFlag, ipxConfiguredFlag=ipxConfiguredFlag, syEventToTrapThreshold=syEventToTrapThreshold, fileTransferRemoteFileName=fileTransferRemoteFileName, mgrNumberOfRetriesForMACProtocolResponses=mgrNumberOfRetriesForMACProtocolResponses, wanISDNCallingPhoneNoB2=wanISDNCallingPhoneNoB2, ip=ip, userMaxEntries=userMaxEntries, wanLinkDialupFlag=wanLinkDialupFlag, sbe=sbe, ipStaticRouteDestinationAddress=ipStaticRouteDestinationAddress, destPortType=destPortType, ipWanDestinationName=ipWanDestinationName, wanIPAddressTable=wanIPAddressTable, destLinkLayerProtocolType=destLinkLayerProtocolType, snmpMacServerStatus=snmpMacServerStatus, syConfigurationLockFlag=syConfigurationLockFlag, event=event, wanStatPortConnDirection=wanStatPortConnDirection, syBridgeConfiguredFlag=syBridgeConfiguredFlag, ipxMultiFrameStatus=ipxMultiFrameStatus, modempool=modempool, wanEnableDataCompression=wanEnableDataCompression, eventEntry=eventEntry, wanISDNCallingPhoneNoB1=wanISDNCallingPhoneNoB1, wanISDNChannels=wanISDNChannels, destMaximumDialoutConnectTime=destMaximumDialoutConnectTime, wanModemPoolGSN=wanModemPoolGSN, syDirEntry=syDirEntry, destScriptEntryStatus=destScriptEntryStatus, user=user, ipxMultiFrameEntry=ipxMultiFrameEntry, userCallbackType=userCallbackType, eventData=eventData, fileTransferLocalFileName=fileTransferLocalFileName, syControlVariableStringOne=syControlVariableStringOne, snmpIpServerStatus=snmpIpServerStatus, discProto=discProto, destScriptTimeout=destScriptTimeout, wanISDNChannelSpeed=wanISDNChannelSpeed, wanIpxSapSendInterval=wanIpxSapSendInterval, syBridgeProtocol=syBridgeProtocol, destDialoutPhoneNumber=destDialoutPhoneNumber, destTSDInactivityTime=destTSDInactivityTime, syDirName=syDirName, fileTransferLastRcvTime=fileTransferLastRcvTime, userPassword=userPassword, modempoolEnabled=modempoolEnabled, ipDefaultGatewayIfType=ipDefaultGatewayIfType, snmpCommunityNameEntry=snmpCommunityNameEntry, wanLinkLayerProtocolType=wanLinkLayerProtocolType, destDialoutIpxSupport=destDialoutIpxSupport, holidayTable=holidayTable, syFileInfoChecksum=syFileInfoChecksum, wanModemName=wanModemName, syControlOperation=syControlOperation, ipDefaultGatewayType=ipDefaultGatewayType, fileMgmt=fileMgmt, wanModemPoolSSN=wanModemPoolSSN, ipBroadcastForwardTypes=ipBroadcastForwardTypes, discNodeName=discNodeName, snmpIpServerEntry=snmpIpServerEntry, destAllowDynamicIPAddr=destAllowDynamicIPAddr, syDirStatus=syDirStatus, syEventToLogThreshold=syEventToLogThreshold, eventTable=eventTable, wan=wan, snmpIpServerTable=snmpIpServerTable, syFileTransfer=syFileTransfer, wanStatPortNoAnswer=wanStatPortNoAnswer, holiday=holiday, syBridgeEntry=syBridgeEntry, userTable=userTable, wanStatPortEntry=wanStatPortEntry, destDialinPassword=destDialinPassword, destScriptEntry=destScriptEntry, destTSDPortGroup=destTSDPortGroup, wanDialinAllowedFlag=wanDialinAllowedFlag, syBootOrder=syBootOrder, userPhoneNo=userPhoneNo, manager=manager, ipStaticRouteGateway=ipStaticRouteGateway, destDialoutPassword=destDialoutPassword, system=system, userStatus=userStatus, syNumberOfTimesToSpeak=syNumberOfTimesToSpeak, wanStatPortNoDialTone=wanStatPortNoDialTone, mgrTimeoutForMACProtocolResponses=mgrTimeoutForMACProtocolResponses, wanStatPortTransmitError=wanStatPortTransmitError, wanISDNSPID2=wanISDNSPID2, syEventToSpeakThreshold=syEventToSpeakThreshold, dummyStopperForWorkshopForGetNext=dummyStopperForWorkshopForGetNext, userEntry=userEntry, syActivatedLevel=syActivatedLevel, destDialoutModemSpeed=destDialoutModemSpeed, destTSDExpectCallback=destTSDExpectCallback, ipDefaultGateway=ipDefaultGateway, router=router, syDateTime=syDateTime, syDirTable=syDirTable, wanStatPortUserName=wanStatPortUserName, syBaseActivationLevel=syBaseActivationLevel, wanIPAddress=wanIPAddress, ipxMultiFrameNetworkAddress=ipxMultiFrameNetworkAddress, wanIPAddressEntry=wanIPAddressEntry, wanStatPortFrameReceived=wanStatPortFrameReceived, syDirVersion=syDirVersion, wanISDNSwitchType=wanISDNSwitchType, destEntry=destEntry, holidayStatus=holidayStatus, snmp=snmp, syBridgePriority=syBridgePriority, ipRipReceiveAdvertisementFlag=ipRipReceiveAdvertisementFlag, destMaximumDialinConnectTime=destMaximumDialinConnectTime, syFMTimeStamp=syFMTimeStamp, wanDefaultDialinSubnetMask=wanDefaultDialinSubnetMask, destPppMtuMru=destPppMtuMru, snmpCommunityNameStatus=snmpCommunityNameStatus, syFileInfoLength=syFileInfoLength, ipStaticRouteTable=ipStaticRouteTable, wanIPAddressMaxEntry=wanIPAddressMaxEntry, wanPortType=wanPortType, ipxNetAddressAutoLearnStateCounter=ipxNetAddressAutoLearnStateCounter, wanPortGroup=wanPortGroup, ipBroadcastAddress=ipBroadcastAddress, wanStatPortState=wanStatPortState, wanStatPortNoCarrier=wanStatPortNoCarrier, ipStaticRouteDestinationName=ipStaticRouteDestinationName, destLinkLayerType=destLinkLayerType, destISDNChannels=destISDNChannels, syModel=syModel)
mibBuilder.exportSymbols("SBE-MIB", destPorts=destPorts, syFMError=syFMError, destDialoutStatusData=destDialoutStatusData, ipxMultiFrameTable=ipxMultiFrameTable, bridge=bridge, ipStaticRouteDestinationHopCount=ipStaticRouteDestinationHopCount, wanPortEntry=wanPortEntry, wanDefaultDialinIPAddress=wanDefaultDialinIPAddress, wanIpxSapReceiveAdvertisementFlag=wanIpxSapReceiveAdvertisementFlag, destMaxEntry=destMaxEntry, mgrEventPollingInterval=mgrEventPollingInterval, wanModemSpeed=wanModemSpeed)

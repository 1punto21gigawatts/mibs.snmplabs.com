#
# PySNMP MIB module TPLINK-SNMPRMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TPLINK-SNMPRMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:25:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Counter64, Unsigned32, MibIdentifier, ObjectIdentity, NotificationType, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ModuleIdentity, Counter32, iso, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "Unsigned32", "MibIdentifier", "ObjectIdentity", "NotificationType", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "ModuleIdentity", "Counter32", "iso", "Gauge32", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
tplinkSnmpMIBObjects, = mibBuilder.importSymbols("TPLINK-SNMP-MIB", "tplinkSnmpMIBObjects")
tpSnmpRmonControl = MibIdentifier((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2))
tpSnmpRmonStatisticsCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1))
tpSnmpRmonHistoryCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2))
tpSnmpRmonEventCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3))
tpSnmpRmonAlarmCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4))
class EntryStatus(TextualConvention, Integer32):
    description = 'The status of a table entry.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4))

tpSnmpRmonStatsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1), )
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlTable.setDescription('A list of SNMP RMON STATISTICS control entries.')
tpSnmpRmonStatsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonStatsCtrlIndex"))
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlEntry.setDescription(' RMON (Remote Monitoring), basing on SNMP (Simple Network Management Protocol) architecture, functions to monitor the network. Statistics Group, as one of the commonly used RMON Groups, is used to collect the statistics of interfaces. ')
tpSnmpRmonStatsCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlIndex.setDescription('The index of this entry.')
tpSnmpRmonStatsCtrlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1, 1, 2), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlDataSource.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlDataSource.setDescription('This object identifies the source of the data that this statistics entry is configured to analyze. This source can be any ethernet interface on this device. The source should be given as 1/0/1.')
tpSnmpRmonStatsCtrlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16)).clone('MibBrowser')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlOwner.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlOwner.setDescription('The owner of this entry.')
tpSnmpRmonStatsCtrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 1, 1, 1, 4), EntryStatus().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlRowStatus.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonStatsCtrlRowStatus.setDescription("The status column has four defined values: - 'valid(1)', which indicates that the conceptual row is available for using by the managed device; - 'createRequest(2)', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to valid(1), making it available for using by the managed device; - 'underCreation(3)', which indicates that the conceptual row is existing in the managed device but not working. - 'invalid(4)', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row.")
tpSnmpRmonHistoryCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1), )
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlTable.setDescription('A list of SNMP RMON hisotry control entries.')
tpSnmpRmonHistoryCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonHistoryCtrlIndex"))
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlEntry.setDescription(' History Group is one of the commonly used RMON (Remote Monitoring) Groups. After a history group is configured, the switch collects network statistics information periodically, based on which the management station can monitor network effectively.')
tpSnmpRmonHistoryCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlIndex.setDescription('The index of this entry.')
tpSnmpRmonHistoryCtrlSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlSourcePort.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlSourcePort.setDescription('The port from which the history samples were taken. Specify the port in form of 1/0/1.')
tpSnmpRmonHistoryCtrlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlInterval.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlInterval.setDescription(' The interval to take samplings from the port. 10sec-3600sec.')
tpSnmpRmonHistoryCtrlBucketsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlBucketsRequested.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlBucketsRequested.setDescription('The requested number of discrete time intervals over which data is to be saved in the part of the media-specific table associated with this historyControlEntry. ')
tpSnmpRmonHistoryCtrlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlOwner.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlOwner.setDescription('The name of the device or user that defined the entry.')
tpSnmpRmonHistoryCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryCtrlStatus.setDescription('Enable/Disable the corresponding sampling entry. disable(0), disable the history entry. enable(1), enable the history entry.')
tpSnmpRmonHistoryDataTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2), )
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataTable.setDescription('A list of SNMP RMON hisotry data entries.')
tpSnmpRmonHistoryDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonHistoryDataIndex"))
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataEntry.setDescription('Contains of the history data for a control entry')
tpSnmpRmonHistoryDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataIndex.setDescription('index')
tpSnmpRmonHistoryDataSampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataSampleIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataSampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same historyControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
tpSnmpRmonHistoryDataIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataIntervalStart.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataIntervalStart.setDescription(' The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
tpSnmpRmonHistoryDataDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataDropEvents.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataDropEvents.setDescription(' The total number of events in which packets were dropped by the probe due to lack of resources during this sampling interval. Note that this number is not necessarily the number of packets dropped, it is just the number of times this condition has been detected.')
tpSnmpRmonHistoryDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 5), Counter32()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataOctets.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataOctets.setDescription(' The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets)')
tpSnmpRmonHistoryDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 6), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataPkts.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataPkts.setDescription(' The number of packets (including bad packets) received during this sampling interval.')
tpSnmpRmonHistoryDataBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 7), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataBroadcastPkts.setDescription(' The number of good packets received during this sampling interval that were directed to the broadcast address.')
tpSnmpRmonHistoryDataMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 8), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataMulticastPkts.setDescription(' The number of good packets received during this sampling interval that were directed to the broadcast address.')
tpSnmpRmonHistoryDataCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 9), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataCRCAlignErrors.setDescription(' The number of packets received during this sampling interval that had a length (excluding framing bits but including FCS octets) between 64 and 1518 octets, inclusive, but had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
tpSnmpRmonHistoryDataUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 10), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataUndersizePkts.setDescription(' The number of packets received during this sampling interval that were less than 64 octets long (excluding framing bits but including FCS octets) and were otherwise well formed.')
tpSnmpRmonHistoryDataOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 11), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataOversizePkts.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataOversizePkts.setDescription(' The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets) but were otherwise well formed.')
tpSnmpRmonHistoryDataFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 12), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataFragments.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataFragments.setDescription(' The total number of packets received during this sampling interval that were less than 64 octets in length (excluding framing bits but including FCS octets) had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
tpSnmpRmonHistoryDataJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 13), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataJabbers.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataJabbers.setDescription(' The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
tpSnmpRmonHistoryDataCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 14), Counter32()).setUnits('Collisions').setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataCollisions.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataCollisions.setDescription(' The number of collion received during this sampling interval that')
tpSnmpRmonHistoryDataUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataUtilization.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonHistoryDataUtilization.setDescription(' The best estimate of the mean physical layer network utilization on this interface during this sampling interval, in hundredths of a percent.')
tpSnmpRmonEventCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1), )
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlTable.setDescription('A list of SNMP RMON EVENT control entries.')
tpSnmpRmonEventCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonEventCtrlIndex"))
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlEntry.setDescription(' RMON (Remote Monitoring), basing on SNMP (Simple Network Management Protocol) architecture, functions to monitor the network. Event Group, as one of the commonly used RMON Groups, is used to define RMON events. Alarms occur when an event is detected.')
tpSnmpRmonEventCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlIndex.setDescription('The index of this entry.')
tpSnmpRmonEventCtrlUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlUserName.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlUserName.setDescription('The name of the User or the community to which the event belongs.')
tpSnmpRmonEventCtrlDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlDesc.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlDesc.setDescription('Description which is given to the event for identification.')
tpSnmpRmonEventCtrlType = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmptrap", 3), ("logandtrap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlType.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlType.setDescription(' The event type, which determines the act way of the network device in response to an event. none(1),no processing. log(2),logging the event. snmptrap(3),sending trap messages to the management station. logandtrap(4),logging the event and sending trap messages to the management station.')
tpSnmpRmonEventCtrlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlOwner.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlOwner.setDescription('The name of the device or user that defined the entry.')
tpSnmpRmonEventCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventCtrlStatus.setDescription('Enable/Disable the corresponding event entry. disable(0),disable the event entry. enable(1),enable the event entry. ')
tpSnmpRmonEventLogTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2), )
if mibBuilder.loadTexts: tpSnmpRmonEventLogTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogTable.setDescription('A list of log that have been logged.')
tpSnmpRmonEventLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonEventLogEventIndex"), (0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonEventLogIndex"))
if mibBuilder.loadTexts: tpSnmpRmonEventLogEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogEntry.setDescription(' A set of data describing an event that has been logged. For example, an instance of the logDescription object might be named logDescription.6.47')
tpSnmpRmonEventLogEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonEventLogEventIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogEventIndex.setDescription(' The event entry that generated this log entry. The log identified by a particular value of this index is associated with the same eventEntry as identified by the same value of eventIndex.')
tpSnmpRmonEventLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonEventLogIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogIndex.setDescription(' An index that uniquely identifies an entry in the log table amongst those generated by the same eventEntries. These indexes are assigned beginning with 1 and increase by one with each new log entry. The association between values of logIndex and logEntries is fixed for the lifetime of each logEntry. The agent may choose to delete the oldest instances of logEntry as required because of lack of memory. It is an implementation-specific matter as to when this deletion may occur.')
tpSnmpRmonEventLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonEventLogTime.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogTime.setDescription('The value of sysUpTime when this log entry was created.')
tpSnmpRmonEventLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonEventLogDescription.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonEventLogDescription.setDescription(' An implementation dependent description of the event that activated this log entry.')
tpSnmpRmonAlarmCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1), )
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlTable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlTable.setDescription('A list of SNMP RMON EVENT control entries.')
tpSnmpRmonAlarmCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1), ).setIndexNames((0, "TPLINK-SNMPRMON-MIB", "tpSnmpRmonAlarmCtrlIndex"))
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlEntry.setDescription(' Alarm Group is one of the commonly used RMON Groups. RMON alarm management allows monitoring the specific alarm variables. When the value of a monitored variable exceeds the threshold, an alarm event is generated, which triggers the switch to act in the set way.')
tpSnmpRmonAlarmCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlIndex.setDescription('The index of this entry.')
tpSnmpRmonAlarmCtrlVariable = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("dropEvent", 3), ("recBytes", 4), ("recPackets", 5), ("bPackets", 6), ("mPackets", 7), ("crcAlignErr", 8), ("undersize", 9), ("oversize", 10), ("fragments", 11), ("jabbers", 12), ("collisions", 13), ("packet64Bytes", 14), ("packetFrom65to127", 15), ("packetFrom128to255", 16), ("packetFrom256to511", 17), ("packetFrom512to1023", 18), ("packetFrom1024to10240", 19)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlVariable.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlVariable.setDescription('The packet type that to be count.')
tpSnmpRmonAlarmCtrlStatisticsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStatisticsIndex.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStatisticsIndex.setDescription('The index of the statistics entry relative with this alarm entry.')
tpSnmpRmonAlarmCtrlSampleType = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlSampleType.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlSampleType.setDescription(' The method of sampling the selected variable and calculating the value to be compared against the thresholds. absoluteValue(1),compares the values directly with the thresholds at the end of the sampling interval. deltaValue(2),subtracts the last sampled value from the current value. The difference in the values is compared to the threshold.')
tpSnmpRmonAlarmCtrlRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlRisingThreshold.setDescription('The rising counter value that triggers the rise hold alarm.')
tpSnmpRmonAlarmCtrlRisingEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlRisingEvent.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlRisingEvent.setDescription(' The index of the corresponding event which will be triggered if the sampled value is larger than the Rise Hold.')
tpSnmpRmonAlarmCtrlFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlFallingThreshold.setDescription('The falling counter value that triggers the fall hold alarm.')
tpSnmpRmonAlarmCtrlFallingEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlFallingEvent.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlFallingEvent.setDescription(' The index of the corresponding event which will be triggered if the sampled value is lower than the Fall Hold. ')
tpSnmpRmonAlarmCtrlStartUp = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("risingAlarm", 1), ("fallingAlarm", 2), ("risingOrFallingAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStartUp.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStartUp.setDescription('Specify the type of the alarm. risingAlarm(1),When the sampled value exceeds the Rise Hold, an alarm event is triggered. fallingAlarm(2),When the sampled value is under the Fall Hold, an alarm event is triggered. risingOrFallingAlarm(3),The alarm event will be triggered either the sampled value exceeds the Rise Hold or is under the Fall Hold.')
tpSnmpRmonAlarmCtrlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlInterval.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlInterval.setDescription('The alarm interval time in seconds. 10sec-3600sec.')
tpSnmpRmonAlarmCtrlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlOwner.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlOwner.setDescription('The name of the device or user that defined the entry.')
tpSnmpRmonAlarmCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11863, 6, 32, 1, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: tpSnmpRmonAlarmCtrlStatus.setDescription('Enable/Disable the corresponding alarm entry. disable(0),disable the alarm entry. enable(1),enable the alarm entry')
mibBuilder.exportSymbols("TPLINK-SNMPRMON-MIB", tpSnmpRmonHistoryDataOversizePkts=tpSnmpRmonHistoryDataOversizePkts, tpSnmpRmonHistoryDataPkts=tpSnmpRmonHistoryDataPkts, tpSnmpRmonAlarmCtrlStartUp=tpSnmpRmonAlarmCtrlStartUp, tpSnmpRmonHistoryDataDropEvents=tpSnmpRmonHistoryDataDropEvents, tpSnmpRmonStatsCtrlDataSource=tpSnmpRmonStatsCtrlDataSource, tpSnmpRmonHistoryDataBroadcastPkts=tpSnmpRmonHistoryDataBroadcastPkts, tpSnmpRmonAlarmCtrlIndex=tpSnmpRmonAlarmCtrlIndex, tpSnmpRmonHistoryCtrlStatus=tpSnmpRmonHistoryCtrlStatus, tpSnmpRmonHistoryDataMulticastPkts=tpSnmpRmonHistoryDataMulticastPkts, tpSnmpRmonHistoryDataSampleIndex=tpSnmpRmonHistoryDataSampleIndex, tpSnmpRmonHistoryCtrlTable=tpSnmpRmonHistoryCtrlTable, tpSnmpRmonHistoryDataJabbers=tpSnmpRmonHistoryDataJabbers, tpSnmpRmonStatsCtrlIndex=tpSnmpRmonStatsCtrlIndex, tpSnmpRmonAlarmCtrlVariable=tpSnmpRmonAlarmCtrlVariable, tpSnmpRmonEventCtrlEntry=tpSnmpRmonEventCtrlEntry, tpSnmpRmonStatsCtrlEntry=tpSnmpRmonStatsCtrlEntry, tpSnmpRmonEventLogIndex=tpSnmpRmonEventLogIndex, tpSnmpRmonHistoryCtrlOwner=tpSnmpRmonHistoryCtrlOwner, tpSnmpRmonHistoryCtrlBucketsRequested=tpSnmpRmonHistoryCtrlBucketsRequested, tpSnmpRmonEventLogTable=tpSnmpRmonEventLogTable, tpSnmpRmonAlarmCtrlFallingEvent=tpSnmpRmonAlarmCtrlFallingEvent, tpSnmpRmonEventCtrlOwner=tpSnmpRmonEventCtrlOwner, tpSnmpRmonHistoryCtrlIndex=tpSnmpRmonHistoryCtrlIndex, tpSnmpRmonHistoryCtrl=tpSnmpRmonHistoryCtrl, tpSnmpRmonEventCtrl=tpSnmpRmonEventCtrl, tpSnmpRmonAlarmCtrlStatisticsIndex=tpSnmpRmonAlarmCtrlStatisticsIndex, tpSnmpRmonHistoryDataUndersizePkts=tpSnmpRmonHistoryDataUndersizePkts, tpSnmpRmonAlarmCtrlRisingEvent=tpSnmpRmonAlarmCtrlRisingEvent, tpSnmpRmonAlarmCtrlFallingThreshold=tpSnmpRmonAlarmCtrlFallingThreshold, tpSnmpRmonEventLogDescription=tpSnmpRmonEventLogDescription, tpSnmpRmonHistoryDataIntervalStart=tpSnmpRmonHistoryDataIntervalStart, tpSnmpRmonHistoryDataUtilization=tpSnmpRmonHistoryDataUtilization, tpSnmpRmonEventCtrlUserName=tpSnmpRmonEventCtrlUserName, tpSnmpRmonEventCtrlDesc=tpSnmpRmonEventCtrlDesc, tpSnmpRmonEventCtrlStatus=tpSnmpRmonEventCtrlStatus, tpSnmpRmonAlarmCtrl=tpSnmpRmonAlarmCtrl, tpSnmpRmonHistoryCtrlSourcePort=tpSnmpRmonHistoryCtrlSourcePort, tpSnmpRmonEventLogTime=tpSnmpRmonEventLogTime, tpSnmpRmonAlarmCtrlSampleType=tpSnmpRmonAlarmCtrlSampleType, tpSnmpRmonStatsCtrlRowStatus=tpSnmpRmonStatsCtrlRowStatus, tpSnmpRmonAlarmCtrlRisingThreshold=tpSnmpRmonAlarmCtrlRisingThreshold, tpSnmpRmonStatisticsCtrl=tpSnmpRmonStatisticsCtrl, tpSnmpRmonStatsCtrlTable=tpSnmpRmonStatsCtrlTable, tpSnmpRmonHistoryDataIndex=tpSnmpRmonHistoryDataIndex, tpSnmpRmonHistoryCtrlEntry=tpSnmpRmonHistoryCtrlEntry, tpSnmpRmonEventCtrlIndex=tpSnmpRmonEventCtrlIndex, tpSnmpRmonHistoryDataTable=tpSnmpRmonHistoryDataTable, tpSnmpRmonHistoryDataCollisions=tpSnmpRmonHistoryDataCollisions, tpSnmpRmonAlarmCtrlEntry=tpSnmpRmonAlarmCtrlEntry, tpSnmpRmonHistoryCtrlInterval=tpSnmpRmonHistoryCtrlInterval, tpSnmpRmonAlarmCtrlTable=tpSnmpRmonAlarmCtrlTable, tpSnmpRmonEventCtrlTable=tpSnmpRmonEventCtrlTable, EntryStatus=EntryStatus, tpSnmpRmonHistoryDataFragments=tpSnmpRmonHistoryDataFragments, tpSnmpRmonAlarmCtrlStatus=tpSnmpRmonAlarmCtrlStatus, tpSnmpRmonHistoryDataEntry=tpSnmpRmonHistoryDataEntry, tpSnmpRmonEventLogEntry=tpSnmpRmonEventLogEntry, tpSnmpRmonEventLogEventIndex=tpSnmpRmonEventLogEventIndex, tpSnmpRmonControl=tpSnmpRmonControl, tpSnmpRmonHistoryDataCRCAlignErrors=tpSnmpRmonHistoryDataCRCAlignErrors, tpSnmpRmonHistoryDataOctets=tpSnmpRmonHistoryDataOctets, tpSnmpRmonStatsCtrlOwner=tpSnmpRmonStatsCtrlOwner, tpSnmpRmonAlarmCtrlInterval=tpSnmpRmonAlarmCtrlInterval, tpSnmpRmonAlarmCtrlOwner=tpSnmpRmonAlarmCtrlOwner, tpSnmpRmonEventCtrlType=tpSnmpRmonEventCtrlType)

#
# PySNMP MIB module X25-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/X25-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:42:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
rs232PortIndex, = mibBuilder.importSymbols("RS232-MIB", "rs232PortIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Gauge32, iso, MibIdentifier, enterprises, IpAddress, NotificationType, Integer32, Bits, ModuleIdentity, ObjectIdentity, NotificationType, Counter64, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "iso", "MibIdentifier", "enterprises", "IpAddress", "NotificationType", "Integer32", "Bits", "ModuleIdentity", "ObjectIdentity", "NotificationType", "Counter64", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention")
ngcan = MibIdentifier((1, 3, 6, 1, 4, 1, 1978))
tiger = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2))
x25MIB = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 14))
x25L3 = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1))
x25Traps = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 14, 2))
x25L3Traps = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 14, 2, 1))
class X25CallParamIndex(Integer32):
    pass

class InterfaceIndex(Integer32):
    pass

class X121Address(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 20)

x25AdmnTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1), )
if mibBuilder.loadTexts: x25AdmnTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnTable.setDescription('This table contains configuration, channel assignments and statistics for an X.25 Packet Level Entity (PLE). The values are as last set by the administrator and/or the values actually in use by the PLE.')
x25AdmnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1), ).setIndexNames((0, "X25-MIB", "x25AdmnIndex"))
if mibBuilder.loadTexts: x25AdmnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnEntry.setDescription('Entries of x25AdmnTable.')
x25AdmnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnIndex.setDescription('The ifIndex value for the X.25 Interface.')
x25AdmnInterfaceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("dxe", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnInterfaceMode.setReference('10733 5.9 interfaceMode')
if mibBuilder.loadTexts: x25AdmnInterfaceMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnInterfaceMode.setDescription('Identifies DCE/DTE mode in which the interface operates. A value of dxe indicates the mode will be determined by XID negotiation.')
x25AdmnPacketSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnPacketSequencing.setReference('10733 extendedPacketSequencing; See ISO 8208 Section 7.1.1')
if mibBuilder.loadTexts: x25AdmnPacketSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnPacketSequencing.setDescription('The modulus of the packet sequence number space.')
x25AdmnRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRestartTimer.setReference('10733 5.9 restartTime See ISO 8208 Section 4.1, table 26')
if mibBuilder.loadTexts: x25AdmnRestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRestartTimer.setDescription('The T20 restart timer in milliseconds. UNITS: milliseconds')
x25AdmnCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnCallTimer.setReference('10733 callTime; See ISO 8208 Section 5.2.1, table 26')
if mibBuilder.loadTexts: x25AdmnCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnCallTimer.setDescription('The T21 Call timer in milliseconds. UNITS: milliseconds')
x25AdmnResetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnResetTimer.setReference('10733 resetTime; See ISO 8208 Section 8.1, table 26')
if mibBuilder.loadTexts: x25AdmnResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnResetTimer.setDescription('The T22 Reset timer in milliseconds. UNITS: milliseconds')
x25AdmnClearTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnClearTimer.setReference('10733 clearTime; See ISO 8208 Section 5.5.1, table 26')
if mibBuilder.loadTexts: x25AdmnClearTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnClearTimer.setDescription('The T23 Clear timer in milliseconds. UNITS: milliseconds')
x25AdmnWindowTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnWindowTimer.setReference('10733 5.10.1 windowTime (opt); See ISO 8208 Section 11.2.2, table 26')
if mibBuilder.loadTexts: x25AdmnWindowTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnWindowTimer.setDescription('The T24 window status transmission timer in milliseconds. A value of 0 indicates no window timer in use. UNITS: milliseconds')
x25AdmnDataRxmtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnDataRxmtTimer.setReference('10733 5.10.1 dataRetransmissionTime (opt); See ISO 8208 Section 11.2.1, table 26')
if mibBuilder.loadTexts: x25AdmnDataRxmtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnDataRxmtTimer.setDescription('The T25 data retransmission timer in milliseconds. A value of 0 indicates no data retransmission timer in use. UNITS: milliseconds')
x25AdmnInterruptTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnInterruptTimer.setReference('10733 interruptTime; See ISO 8208 Section 6.8.1, table 26')
if mibBuilder.loadTexts: x25AdmnInterruptTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnInterruptTimer.setDescription('The T26 interrupt timer in milliseconds. A value of 0 indicates no interrupt timer in use. UNITS: milliseconds')
x25AdmnRejectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRejectTimer.setReference('10733 5.10.1 dataRejectTime (opt); See ISO 8208 Section 13.4.1, table 26')
if mibBuilder.loadTexts: x25AdmnRejectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRejectTimer.setDescription('The T27 Reject retransmission timer in milliseconds. A value of 0 indicates no reject timer in use. UNITS: milliseconds')
x25AdmnRegistrationRequestTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRegistrationRequestTimer.setReference('10733 5.8.1 registrationRequestTime (opt) See ISO 8208 Section 13.1.1.1, table 26')
if mibBuilder.loadTexts: x25AdmnRegistrationRequestTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRegistrationRequestTimer.setDescription('The T28 registration timer in milliseconds. A value of 0 indicates no registration timer in use. UNITS: milliseconds')
x25AdmnRestartCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRestartCount.setReference('10733 5.9 restartCount; See ISO 8208 Section 4.1, table 27')
if mibBuilder.loadTexts: x25AdmnRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRestartCount.setDescription('The R20 restart retransmission count.')
x25AdmnResetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnResetCount.setReference('10733 resetCount; See section ISO 8208 8.1, table 27')
if mibBuilder.loadTexts: x25AdmnResetCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnResetCount.setDescription('The r22 Reset retransmission count.')
x25AdmnClearCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnClearCount.setReference('10733 clearCount; See ISO 8208 Section 5.5.1, table 27')
if mibBuilder.loadTexts: x25AdmnClearCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnClearCount.setDescription('The r23 Clear retransmission count.')
x25AdmnDataRxmtCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnDataRxmtCount.setReference('10733 5.10.1 dataRetransmissionCount (opt) See ISO 8208 Section 11.2.1, table 27')
if mibBuilder.loadTexts: x25AdmnDataRxmtCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnDataRxmtCount.setDescription('The R25 Data retransmission count. This value is irrelevant if the x25AdmnDataRxmtTimer indicates no timer in use.')
x25AdmnRejectCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRejectCount.setReference('10733 5.10.1 dataRejectCount (opt)')
if mibBuilder.loadTexts: x25AdmnRejectCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRejectCount.setDescription('The R27 reject retransmission count. This value is irrelevant if the x25AdmnRejectTimer indicates no timer in use.')
x25AdmnRegistrationRequestCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRegistrationRequestCount.setReference('10733 5.8.1 registrationRequestCount (opt); See ISO 8208 Section 13.1.1.1, table 27')
if mibBuilder.loadTexts: x25AdmnRegistrationRequestCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRegistrationRequestCount.setDescription('The R28 Registration retransmission Count. This value is irrelevant if the x25AdmnRegistrationRequestTimer indicates no timer in use.')
x25AdmnNumberPVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnNumberPVCs.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnNumberPVCs.setDescription('The number of PVC configured for this PLE. The PVCs use channel numbers from 1 to this number. Set to 0 for no PVCs.')
x25AdmnDefCallParamId = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 20), X25CallParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnDefCallParamId.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnDefCallParamId.setDescription('This identifies the instance of the x25CallParmIndex for the entry in the x25CallParmTable which contains the default call parameters for this PLE.')
x25AdmnProtocolVersionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ccitt-1976", 1), ("ccitt-1980", 2), ("ccitt-1984", 3), ("ccitt-1988", 4), ("ccitt-1992", 5), ("qllc", 6))).clone('ccitt-1992')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnProtocolVersionSupported.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnProtocolVersionSupported.setDescription('Identifies the version of the X.25 protocol this interface should support.')
x25AdmnRegistrationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("auto", 2), ("user", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRegistrationMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRegistrationMode.setDescription('Defines how registration exchanges are handled. A value of auto indicates that the DTE always sends empty request at connection time and that a DCE automatically answers incoming requests. A value of user indicates that registration packets are handled at the user level and the packet level still updates its internal configuration according to the the confirmation content.')
x25AdmnDiagnosticMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standard", 1), ("on", 2), ("off", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnDiagnosticMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnDiagnosticMode.setDescription('Controls the generation of diagnostic packets. A value of standard means send diagnostics if configured as a DCE only, as per CCITT specification. A value of on always sends diagnostic packets, and a value of off will never send diagnostic packets.')
x25AdmnInterruptSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnInterruptSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnInterruptSize.setDescription('Defines the maximum user data size in interrupt packets. Use 1 for networks compliant with 1980 CCITT recommendation and before, use 32 for 1984 and later compliant networks, any other value is used only when dealing with non CCITT compliant implementations.')
x25AdmnMaxTxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnMaxTxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnMaxTxWindow.setDescription('Specifies the maximum transmit window size that can be negotiated. 1 through 7 for modulo 8. 1 through 128 for modulo 128.')
x25AdmnMaxRxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnMaxRxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnMaxRxWindow.setDescription('Specifies the maximum receive window size that can be negotiated. 1 through 7 for modulo 8. 1 through 128 for modulo 128.')
x25AdmnFacilityLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(109)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnFacilityLength.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnFacilityLength.setDescription('Defines the maximum length of the Facility field. Use 63 for 1980 or earlier complience. Use 109 for 1984 and later compliant networks. Other value are used only when dealing with non CCITT compliant implementations.')
x25AdmnCallDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnCallDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnCallDataSize.setDescription('Defines the maximum length of the user data in call request/indication packets when fast select not used. Use 16 for CCITT complience. Other value are used only when dealing with non CCITT compliant implementations.')
x25AdmnFastSelectCallDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnFastSelectCallDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnFastSelectCallDataSize.setDescription('Defines the maximum length of the user data in call request/indication packets when fast select is used. Use 128 for CCITT complience. Other value are used only when dealing with non CCITT compliant implementations.')
x25AdmnExtendedClear = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("convert", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnExtendedClear.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnExtendedClear.setDescription('Controls support for extended clear format (allow addresses and facilities in clear/clear cf packets). A value of on means that the extended clear format is supported. A value of off means that the extended clear is not supported, receipt from the user is an error. A value of convert means accept extended clears from the user but convert them to short format before transmission to the network, accept whatever the network sends us. Note: The extended format is used in a clear if fast select is present in the facility field, no matter what the setting of this parameter is.')
x25AdmnCause = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("asis", 1), ("ccitt-80", 2), ("ccitt-84", 3), ("clear", 4))).clone('ccitt-84')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnCause.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnCause.setDescription('Controls how a cause field from the user is converted. A value of asis means send the user cause as is. A value of ccitt-80 means convert to 1980 format (clear if DTE, cause & 0x07F if DCE). A value of ccitt-84 means use 1984 format (0 or cause | 0x80 if DTE, cause & 0x07F if DCE). A value of clear means always clear the cause fields from the user.')
x25AdmnABit = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("ok", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnABit.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnABit.setDescription('x25AdmnABit defines how long addresses, (up to 17 digits,) are handled. A value of on, means always use the long address format. A value of off, means always use the short address format. A value of ok, means use the long format, but accept short addresses from the network.')
x25AdmnRRTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRRTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRRTrigger.setDescription('This defines when the frame level sends RR. 0: Only send RR when the window is full. Very inefficient as it always causes the remote to enter flow control situations. Not recommended. 1: Send RR when receiving one mode data packet would make the window full. Suggested value on modulo 7 point-to- point links with small transit delays. >=k: If the value of the parameter is greater than the window size, this causes RR packets to always be transmitted immediately as soon as a data packet is received. To obtain this mode of operation whatever the negitiated window size may be, it is suggested to set the value of this parameter to 128. < k: Use the specified value, 256: This special value causes RR packets transmission to occur whenever the receive window is half full. Where k is the value of lapbAdmnKWindowSize. (default = >=k)')
x25AdmnRRTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 320000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRRTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRRTimer.setDescription('This x25AdmnRRTimer only causes the transmission of an RR Packet when there are outstanding packets to acknowledge to the remote. When the transmission of RR packets to the remote is delayed because the x25AdmnRRTrigger value is set to a value within the receive window, this timer is used to force the transmission of RR packets after some time. Without this timer, delaying RR Packets would cause the last packets of a transaction never to be acknowledged. Please note that this timer is not similar to the T24 timer. The T24 timer causes an RR packet to be sent whenever no packet carrying an ack has been sent for a while. In addition, the duration of T24 is typically fairly large (60 seconds recommended), while this RR timer should be much smaller to ensure that packets are always acknowledged in a reasonable amount of time. Note: The time is in milliseconds. Note: Setting x25AdmnRRTrigger to a value outside of the receive window or setting this timer value to 0 force RR packets to always be transmitted as soon as a data packet is received from the remote without any delay. UNITS: milliseconds')
x25AdmnRRPiggy = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRRPiggy.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRRPiggy.setDescription("This specifies whether the frame level can 'piggyback' acknowledgements in I frames.")
x25AdmnTxRejectMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("rejectReset", 2), ("sendAlways", 3))).clone('reset')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnTxRejectMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnTxRejectMode.setDescription('Defines how packet level handles the reception of out of sequence data packets. A value of reset will reset the virtual circuit. A value of rejectReset will send reject packet if configured as a DTE. otherwise it will reset the virtual circuit. A value of sendAlways will cause a reject packet to always be sent, even when configured as a DCE. Note: CCITT compliance requires the selection of either reset or rejectReset. The CCITT does not allow a DCE to send a reject.')
x25AdmnRxRejectMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("retxReset", 2), ("retxAlways", 3))).clone('reset')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnRxRejectMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnRxRejectMode.setDescription('Defines how packet level handles the reception of reject packets. A value of reset will reset the virtual circuit. A value of retxReset will retransmit packets if configured as a DCE. otherwise it will reset the virtual circuit. A value of retxAlways will cause retransmition of data packets even when configured as a DTE. Note: CCITT compliance requires the selection of either reset or retxReset. The CCITT does not allow a DTE to retransmit.')
x25AdmnDBit = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("ok", 2), ("bill", 3))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnDBit.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnDBit.setDescription('Defines how packet level handles the D bit. A value of no indicates that the use of the D bit not allowed. A value of ok indicates that the use of the D bit is allowed. A value of bill indicates that the use of the D bit is allowed only if we are not billed for the call.')
x25AdmnR28Action = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fail", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdmnR28Action.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdmnR28Action.setDescription('Selects the packet level action after R28 expirations of the registration timer T28. A value of fail means the link is considered as non operational and is disconnected. The x25AdmnRegistrationMode parameter determine if the complete reconnection procedure is tried again. A value of ignore means: Go to the ready state using the default link configuration, as if the registration never occurred.')
x25ChannelLIC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLIC.setDescription('Lowest Incoming channel. A value of 0 indicates that no LCN is available.')
x25ChannelHIC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHIC.setDescription('Highest Incoming channel. A value of 4095 indicates that no LCN is available.')
x25ChannelLTC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLTC.setDescription('Lowest Two-way channel. A value of 0 indicates that no LCN is available.')
x25ChannelHTC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHTC.setDescription('Highest Two-way channel. A value of 0 indicates that no LCN is available.')
x25ChannelLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLOC.setDescription('Lowest outgoing channel. A value of 0 indicates that no LCN is available.')
x25ChannelHOC = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHOC.setDescription('Highest outgoing channel. A value of 0 indicates that no LCN is available.')
x25StatInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInCalls.setDescription('The number of Call Request/Indication packets received.')
x25StatInCallRefusals = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInCallRefusals.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInCallRefusals.setDescription('The number of incoming calls refused. This includes calls refused by the PLE and by higher layers. This also includes calls cleared because of restricted fast select.')
x25StatInProviderInitiatedClears = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInProviderInitiatedClears.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInProviderInitiatedClears.setDescription('The number of Clear Request/Indication packets sent.')
x25StatInRemotelyInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInRemotelyInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInRemotelyInitiatedResets.setDescription('The number of Reset Request/Indication packets received.')
x25StatInProviderInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInProviderInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInProviderInitiatedResets.setDescription('The number of Reset Request/Indication packets sent.')
x25StatInRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInRestarts.setDescription('The number of Restart Request/Indication packets received.')
x25StatInDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInDataPackets.setReference('10733 5.9 dataPacketsReceived.')
if mibBuilder.loadTexts: x25StatInDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInDataPackets.setDescription('The number of data packets received.')
x25StatInAccusedOfProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setReference('CD 10733 5.9 accusedOfProtocolError')
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setDescription('The number of packets received containing a procedure error cause code. These include clear, reset, restart, or diagnostic packets.')
x25StatInInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInInterrupts.setReference('10733 interruptPacketsReceived')
if mibBuilder.loadTexts: x25StatInInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInInterrupts.setDescription('The number of interrupt packets received by the PLE or over the PVC/VC.')
x25StatOutCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutCallAttempts.setReference('10733 5.9 callAttempts')
if mibBuilder.loadTexts: x25StatOutCallAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutCallAttempts.setDescription('The number of calls attempted.')
x25StatOutCallFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutCallFailures.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutCallFailures.setDescription('The number of call attempts which failed. This includes calls that were cleared because of restrictive fast select.')
x25StatOutInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutInterrupts.setReference('10733 InterruptPacketsSent')
if mibBuilder.loadTexts: x25StatOutInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutInterrupts.setDescription('The number of interrupt packets send by the PLE or over the PVC/VC.')
x25StatOutDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutDataPackets.setReference('10733 dataPacketSent')
if mibBuilder.loadTexts: x25StatOutDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutDataPackets.setDescription('The number of data packets sent by this PLE.')
x25StatPVCCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatPVCCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatPVCCircuits.setDescription('The number of active PVC circuits.')
x25StatSVCCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatSVCCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatSVCCircuits.setDescription('The number of active SVC Circuits. This includes call indications received but not yet acknowledged.')
x25StatRestartTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatRestartTimeouts.setReference('10733 5.9 restartTimeouts')
if mibBuilder.loadTexts: x25StatRestartTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatRestartTimeouts.setDescription('The number of times the T20 restart timer expired.')
x25StatCallTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatCallTimeouts.setReference('10733 5.9 callTimeouts')
if mibBuilder.loadTexts: x25StatCallTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatCallTimeouts.setDescription('The number of times the T21 call timer expired.')
x25StatResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatResetTimeouts.setReference('10733 5.9 resetTimeouts')
if mibBuilder.loadTexts: x25StatResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatResetTimeouts.setDescription('The number of times the T22 reset timer expired.')
x25StatClearTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatClearTimeouts.setReference('10733 5.9 clearTimeouts')
if mibBuilder.loadTexts: x25StatClearTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatClearTimeouts.setDescription('The number of times the T23 clear timer expired.')
x25StatDataRxmtTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setReference('10733 5.9 dataRetransmissionsTimerExpiries')
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setDescription('The number of times the T25 data timer expired.')
x25StatInterruptTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setReference('10733 5.9 interruptTimerExpires')
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setDescription('The number of times the T26 interrupt timer expired.')
x25StatRetryCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setReference('10733 5.9 retryCountsExceeded')
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setDescription('The number of times a retry counter was exhausted.')
x25StatClearCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatClearCountExceededs.setReference('10733 5.9 clearCountsExceeded')
if mibBuilder.loadTexts: x25StatClearCountExceededs.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatClearCountExceededs.setDescription('The number of times the R23 clear count was exceeded.')
x25AdminTrapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 1, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AdminTrapControl.setStatus('mandatory')
if mibBuilder.loadTexts: x25AdminTrapControl.setDescription('If enabled, it allows the system to generate x25Restart and x25VC traps')
x25CircuitTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2), )
if mibBuilder.loadTexts: x25CircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitTable.setDescription('These objects contain general information about a specific circuit of an X.25 PLE.')
x25CircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1), ).setIndexNames((0, "X25-MIB", "x25CircuitIndex"), (0, "X25-MIB", "x25CircuitChannel"))
if mibBuilder.loadTexts: x25CircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitEntry.setDescription('Entries of x25CircuitTable.')
x25CircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitIndex.setDescription('The ifIndex value for the X.25 Interface.')
x25CircuitChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitChannel.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitChannel.setDescription('The channel number for this circuit.')
x25CircuitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("inactive", 1), ("wait-for-setup", 2), ("received-call", 3), ("sent-call", 4), ("data-unused", 5), ("call-collision", 6), ("sent-user-clear", 7), ("sent-net-clear", 8), ("data", 9), ("sent-user-reset", 10), ("sent-net-reset", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitStatus.setDescription("This object reports the current status of the circuit. 'Network' refers to the X.25 network below this module. 'User Application' refers to the software module above this module. <User Application> - The software driving X.25 Level 3. <X.25 Packet Level Module> - This module. <Network> - LAPB --> X.25 Link. The state descriptions are as follows: inactive - VC is not active. wait-for-setup - VC is not active but ready for Call Setup. received-call - Received Call Request/Indication from the Network, awaiting User Application response. sent-call - Sent the network a Call Request/Indication, awaiting Network response. data-unused - Data Transfer (unused) call-collision - Call Collision - Sent the network a Call Request/Indication, received Call Request/Indication from the Network. sent-user-clear - Sent User Application a Clear request, awaiting a Clear confirm from the User Application. sent-net-clear - Sent the network a Clear Request/Indication, awaiting a Clear Confirm/Response from the Network. data - Data Transfer state. sent-user-reset - Sent the User Application a Reset request, awaiting a response from the User Application. sent-net-reset - Sent the Network a Reset Request/Indication, awaiting a response from the Network.")
x25CircuitEstablishTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitEstablishTime.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitEstablishTime.setDescription('The value of sysUpTime when the channel was associated with this circuit. For outgoing SVCs, this is the time the first call packet was sent. For incoming SVCs, this is the time the call indication was received. For PVCs this is the time the PVC was able to pass data to a higher layer entity without loss of data.')
x25CircuitDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("pvc", 3))).clone('pvc')).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitDirection.setReference('10733 direction')
if mibBuilder.loadTexts: x25CircuitDirection.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDirection.setDescription('The direction of the call that established this circuit.')
x25CircuitInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInOctets.setReference('5.11 octetsReceivedCounter')
if mibBuilder.loadTexts: x25CircuitInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInOctets.setDescription('The number of octets of user data delivered to upper layer.')
x25CircuitInPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInPdus.setReference('10733 5.11 dataPacketsReceived')
if mibBuilder.loadTexts: x25CircuitInPdus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInPdus.setDescription('The number of PDUs received for this circuit.')
x25CircuitInRemotelyInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setReference('10733 remotelyInitiatedResets')
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setDescription('The number of Resets received for this circuit with cause code of DTE initiated.')
x25CircuitInProviderInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setReference('10733 ProviderInitiatedResets')
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setDescription('The number of Resets received for this circuit with cause code other than DTE initiated.')
x25CircuitInInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInInterrupts.setReference('10733 interruptPacketsReceived')
if mibBuilder.loadTexts: x25CircuitInInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInInterrupts.setDescription('The number of interrupt packets received for this circuit.')
x25CircuitOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutOctets.setReference('10733 5.11 octetsSentCounter')
if mibBuilder.loadTexts: x25CircuitOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutOctets.setDescription('The number of octets of user data sent for this circuit.')
x25CircuitOutPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutPdus.setReference('10733 5.11 dataPacketsSent')
if mibBuilder.loadTexts: x25CircuitOutPdus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutPdus.setDescription('The number of PDUs sent for this circuit.')
x25CircuitOutInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setReference('10733 interruptPacketsSent')
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setDescription('The number of interrupt packets sent on this circuit.')
x25CircuitDataRetransmissionTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setReference('10733 5.11 dataRetransmissionTimerExpiries')
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setDescription('The number of times the T25 data retransmission timer expired for this circuit.')
x25CircuitResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setReference('10733 5.11 resetTimeouts')
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setDescription('The number of times the T22 reset timer expired for this circuit.')
x25CircuitInterruptTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setReference('10733 interruptTimerExpiries')
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setDescription('The number of times the T26 Interrupt timer expired for this circuit.')
x25CircuitCallParamId = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitCallParamId.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCallParamId.setDescription('This identifies the instance of the x25CallParmIndex for the entry in the x25CallParmTable which contains the call parameters in use with this circuit. The entry referenced must contain the values that are currently in use by the circuit rather than proposed values. A value of NULL indicates the circuit is a PVC or is using all the default parameters.')
x25CircuitCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 18), X121Address().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCalledAddress.setDescription('The Called X.121 Address in the Incoming or Outgoing Call packets.')
x25CircuitCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 19), X121Address().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCallingAddress.setDescription('The Calling X.121 Address in the Incoming or Outgoing Call packets.')
x25CircuitOriginallyCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 20), X121Address().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setReference('10733 originallyCalledAddress')
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setDescription('For incoming calls, this is the address in the call Redirection or Call Deflection Notification facility if the call was deflected or redirected, otherwise it will be called address from the call indication packet. For outgoing calls, this is the address from the call request packet. This will be zero length for PVCs.')
x25CircuitDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitDescr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDescr.setDescription("A descriptive string associated with this circuit. This provides a place for the agent to supply any descriptive information it knows about the use or owner of the circuit. The agent may return the process identifier and user name for the process using the circuit. Alternative the agent may return the name of the configuration entry that caused a bridge to establish the circuit. A zero length value indicates the agent doesn't have any additional information.")
x25CircuitRNRReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-rnr", 1), ("rnr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitRNRReceive.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitRNRReceive.setDescription('This element shows whether a receive RNR (from the network) condition exits.')
x25CircuitRNRSent = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-rnr", 1), ("rnr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitRNRSent.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitRNRSent.setDescription('This element shows whether a sent RNR (to the network) condition exits.')
x25CircuitTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("reset", 1), ("clear", 2), ("sent-rr2rnr", 3), ("sent-rnr2rr", 4), ("recv-rr2rnr", 5), ("recv-rnr2rr", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitTrapType.setDescription('The type of event that caused the trap to occur. reset - generated whenever that packet type is sent or received. clear - generated whenever that packet type is sent or received. sent-rr2rnr - generated whenever an RNR packet is transmitted, causing a flow control condition. sent-rnr2rr - generated whenever an RR packet is transmitted ending a flow control condition. recv-rr2rnr - generated whenever an RNR packet is received, causing a flow control condition. recv-rnr2rr - generated whenever an RR packet is received ending a flow control condition.')
x25CircuitTrapCause = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitTrapCause.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitTrapCause.setDescription('The cause field of the message that caused the trap to occur.')
x25CircuitTrapDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitTrapDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitTrapDiagnostic.setDescription('The diagnostic field of the message that caused the trap to occur.')
x25CallParmTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3), )
if mibBuilder.loadTexts: x25CallParmTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmTable.setDescription('These objects contain the parameters that can be varied between X.25 calls. The entries in this table are independent of the PLE. There exists only one of these tables for the entire system. The indexes for the entries are independent of any PLE or any circuit. Other tables reference entries in this table. Entries in this table can be used for default PLE parameters, for parameters to use to place/answer a call, for the parameters currently in use for a circuit, or parameters that were used by a circuit. The number of references to a given set of parameters can be found in the x25CallParmRefCount object sharing the same instance identifier with the parameters. The value of this reference count also affects the access of the objects in this table. An object in this table with the same instance identifier as the instance identifier of an x25CallParmRefCount must be consider associated with that reference count. An object with an associated reference count of zero can be written (if its MAX-ACCESS clause allows it). An object with an associated reference count greater than zero can not be written (regardless of the MAX-ACCESS clause). This ensures that a set of call parameters being referenced from another table can not be modified or changed in a ways inappropriate for continued use by that table.')
x25CallParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1), ).setIndexNames((0, "X25-MIB", "x25CallParmIndex"))
if mibBuilder.loadTexts: x25CallParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmEntry.setDescription('Entries of x25CallParmTable.')
x25CallParmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmIndex.setDescription('A value that distinguishes this entry from another entry. Entries in this table are referenced from other objects which identify call parameters. It is impossible to know which other objects in the MIB reference entries in the table by looking at this table. Because of this, changes to parameters must be accomplished by creating a new entry in this table and then changing the referencing table to identify the new entry. Note that an agent will only use the values in this table when another table is changed to reference those values. The number of other tables that reference an index object in this table can be found in x25CallParmRefCount. The value of the reference count will affect the writability of the objects as explained above. Entries in this table which have a reference count of zero maybe deleted at the convence of the agent. Care should be taken by the agent to give the NMS sufficient time to create a reference to newly created entries. Should a Management Station not find a free index with which to create a new entry, it may feel free to delete entries with a reference count of zero. However in doing so the Management Station much realize it may impact other Management Stations.')
x25CallParmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmStatus.setDescription('The status of this call parameter entry. See RFC 1271 for details of usage.')
x25CallParmRefCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmRefCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmRefCount.setDescription('The number of references know by a management station to exist to this set of call parameters. This is the number of other objects that have returned a value of, and will return a value of, the index for this set of call parameters. Examples of such objects is the x25AdmnDefCallParamId object defined above.')
x25CallParmInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInPacketSize.setDescription('The default receive packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE means use a default size of 128.')
x25CallParmOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setDescription('The default transmit packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use a default size of 128.')
x25CallParmInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25CallParmInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInWindowSize.setDescription('The receive window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25CallParmOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setDescription('The transmit window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25CallParmAcceptReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("alwaysAccept", 2), ("alwaysRefuse", 3), ("onlyIfNotBilled", 4))).clone('alwaysRefuse')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setReference('10733 acceptReverseCharging')
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setDescription('An enumeration defining if the PLE will accept or refuse charges. A value of default for a circuit means use the PLE default value. A value of alwaysRefuse is only used for the PLE default and indicates the PLE will never accept reverse charging. A value of default for a PLE default means refuse.')
x25CallParmProposeReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("reverse", 2), ("local", 3))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.6')
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setDescription('An enumeration defining if the PLE should propose reverse or local charging. The value of default for a circuit means use the PLE default. The value of default for the PLE default means use local.')
x25CallParmFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("default", 1), ("alwaysReject", 2), ("onlyIncomming", 3), ("onlyOutgoing", 4), ("alwaysAccept", 5), ("onlyIfNotBilled", 6))).clone('alwaysReject')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmFastSelect.setReference('10733 fastSelect; Sec ISO 8208 Section 15.2.2.6')
if mibBuilder.loadTexts: x25CallParmFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmFastSelect.setDescription('Expresses preference for use of fast select facility. The value of default for a circuit is the PLE default. A value of default for the PLE means alwaysReject. A value of alwaysReject indicates a circuit may not use fast select.')
x25CallParmInThruPutClasSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("tcReserved1", 1), ("tcReserved2", 2), ("tc75", 3), ("tc150", 4), ("tc300", 5), ("tc600", 6), ("tc1200", 7), ("tc2400", 8), ("tc4800", 9), ("tc9600", 10), ("tc19200", 11), ("tc48000", 12), ("tc64000", 13), ("tcReserved14", 14), ("tcReserved15", 15), ("tcReserved0", 16), ("tcNone", 17), ("tcDefault", 18))).clone('tcNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setReference('See ISO 8208 Section 15.2.2.2, table 18')
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setDescription('The incoming throughput class to negotiate. A value of tcDefault for a circuit means use the PLE default. A value of tcDefault for the PLE default means tcNone. A value of tcNone means do not negotiate throughtput class.')
x25CallParmOutThruPutClasSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("tcReserved1", 1), ("tcReserved2", 2), ("tc75", 3), ("tc150", 4), ("tc300", 5), ("tc600", 6), ("tc1200", 7), ("tc2400", 8), ("tc4800", 9), ("tc9600", 10), ("tc19200", 11), ("tc48000", 12), ("tc64000", 13), ("tcReserved14", 14), ("tcReserved15", 15), ("tcReserved0", 16), ("tcNone", 17), ("tcDefault", 18))).clone('tcNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setReference('See ISO 8208 Section 15.2.2.2, table 18')
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setDescription('The outgoing throughput class to negotiate. A value of tcDefault for a circuit means use the PLE default. A value of tcDefault for the PLE default means use tcNone. A value of tcNone means do not negotiate throughtput class.')
x25CallParmCug = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCug.setReference('See ISO 8208 Section 15.2.2.3')
if mibBuilder.loadTexts: x25CallParmCug.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCug.setDescription('The Closed User Group to specify. This consists of two or four octets containing the characters 0 through 9. A zero length string indicates no facility requested. A string length of three containing the characters DEF for a circuit means use the PLE default, (the PLE default parameter may not reference an entry of DEF.)')
x25CallParmCugoa = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCugoa.setReference('See ISO 8208 Section 15.2.2.4')
if mibBuilder.loadTexts: x25CallParmCugoa.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCugoa.setDescription('The Closed User Group with Outgoing Access to specify. This consists of two or four octets containing the characters 0 through 9. A string length of three containing the characters DEF for a circuit means use the PLE default (the PLE default parameters may not reference an entry of DEF). A zero length string indicates no facility requested.')
x25CallParmBcug = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmBcug.setReference('See ISO 8208 Section 15.2.2.5')
if mibBuilder.loadTexts: x25CallParmBcug.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmBcug.setDescription('The Bilateral Closed User Group to specify. This consists of two octets containing the characters 0 through 9. A string length of three containing the characters DEF for a circuit means use the PLE default (the PLE default parameter may not reference an entry of DEF). A zero length string indicates no facility requested.')
x25CallParmNui = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmNui.setReference('See ISO 8208 Section 15.2.2.7')
if mibBuilder.loadTexts: x25CallParmNui.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmNui.setDescription('The Network User Identifier facility. This is binary value to be included immediately after the length field. The PLE will supply the length octet. A zero length string indicates no facility requested. This value is ignored for the PLE default parameters entry.')
x25CallParmChargingInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("noFacility", 2), ("noChargingInfo", 3), ("chargingInfo", 4))).clone('noFacility')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmChargingInfo.setReference('See ISO 8208 Section 15.2.2.8')
if mibBuilder.loadTexts: x25CallParmChargingInfo.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmChargingInfo.setDescription('The charging Information facility. A value of default for a circuit means use the PLE default. The value of default for the default PLE parameters means use noFacility. The value of noFacility means do not include a facility.')
x25CallParmRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmRpoa.setReference('See ISO 8208, section 15.2.2.9')
if mibBuilder.loadTexts: x25CallParmRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmRpoa.setDescription('The RPOA facility. The octet string contains n * 4 sequences of the characters 0-9 to specify a facility with n entries. The octet string containing the 3 characters DEF for a circuit specifies use of the PLE default (the entry for the PLE default may not contain DEF). A zero length string indicates no facility requested.')
x25CallParmTrnstDly = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65537)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmTrnstDly.setReference('See ISO 8208, Section 15.2.2.13')
if mibBuilder.loadTexts: x25CallParmTrnstDly.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmTrnstDly.setDescription('The Transit Delay Selection and Indication value. A value of 65536 indicates no facility requested. A value of 65537 for a circuit means use the PLE default (the PLE default parameters entry may not use the value 65537). The value 65535 may only be used to indicate the value in use by a circuit.')
x25CallParmCallingExt = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCallingExt.setReference('See ISO 8208 Section 15.3.2.1')
if mibBuilder.loadTexts: x25CallParmCallingExt.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCallingExt.setDescription('The Calling Extension facility. This contains one of the following: A sequence of hex digits with the value to be put in the facility. These digits will be converted to binary by the agent and put in the facility. These octets do not include the length octet. A value containing the three character DEF for a circuit means use the PLE default, (the entry for the PLE default parameters may not use the value DEF). A zero length string indicates no facility requested.')
x25CallParmCalledExt = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCalledExt.setReference('See ISO 8208 Section 15.3.2.2')
if mibBuilder.loadTexts: x25CallParmCalledExt.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCalledExt.setDescription('The Called Extension facility. This contains one of the following: A sequence of hex digits with the value to be put in the facility. These digits will be converted to binary by the agent and put in the facility. These octets do not include the length octet. A value containing the three character DEF for a circuit means use the PLE default, (the entry for the PLE default parameters may not use the value DEF). A zero length string indicates no facility requested.')
x25CallParmInMinThuPutCls = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setReference('See ISO 8208 Section 15.3.2.3')
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setDescription('The minimum input throughput Class. A value of 17 for a circuit means use the PLE default (the PLE parameters entry may not use this value). A value of 16 indicates no facility requested.')
x25CallParmOutMinThuPutCls = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setReference('See ISO 8208 Section 15.3.2.3')
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setDescription('The minimum output throughput Class. A value of 17 for a circuit means use the PLE default (the PLE parameters entry may not use this value). A value of 16 indicates no facility requested.')
x25CallParmEndTrnsDly = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setReference('See ISO 8208 Section 15.3.2.4')
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setDescription('The End-to-End Transit Delay to negotiate. An octet string of length 2, 4, or 6 contains the facility encoded as specified in ISO/IEC 8208 section 15.3.2.4. An octet string of length 3 containing the three character DEF for a circuit means use the PLE default (the entry for the PLE default can not contain the characters DEF). A zero length string indicates no facility requested.')
x25CallParmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmPriority.setReference('See ISO 8208 Section 15.3.2.5')
if mibBuilder.loadTexts: x25CallParmPriority.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmPriority.setDescription('The priority facility to negotiate. The octet string encoded as specified in ISO/IEC 8208 section 15.3.2.5. A zero length string indicates no facility requested. The entry for the PLE default parameters must be zero length.')
x25CallParmProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmProtection.setReference('See ISO 8208 Section 15.3.2.5')
if mibBuilder.loadTexts: x25CallParmProtection.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmProtection.setDescription('A string contains the following: A hex string containing the value for the protection facility. This will be converted from hex to the octets actually in the packet by the agent. The agent will supply the length field and the length octet is not contained in this string. An string containing the 3 characters DEF for a circuit means use the PLE default (the entry for the PLE default parameters may not use the value DEF). A zero length string mean no facility requested.')
x25CallParmExptData = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("noExpeditedData", 2), ("expeditedData", 3))).clone('noExpeditedData')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmExptData.setReference('See ISO 8208 Section 15.3.2.7')
if mibBuilder.loadTexts: x25CallParmExptData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmExptData.setDescription('The Expedited Data facility to negotiate. A value of default for a circuit means use the PLE default value. The entry for the PLE default parameters may not have the value default.')
x25CallParmUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmUserData.setReference('See ISO 8208 Section 12.2.1.1.6, 12.2.1.2')
if mibBuilder.loadTexts: x25CallParmUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmUserData.setDescription('The call user data as placed in the packet. A zero length string indicates no call user data. If both the circuit call parameters and the PLE default have call user data defined, the data from the circuit call parameters will be used. If only the PLE has data defined, the PLE entry will be used. If neither the circuit call parameters or the PLE default entry has a value, no call user data will be sent.')
x25CallParmCallingNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setReference('See ISO 8206 Section 15.1, category b')
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setDescription('The calling network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25CallParmCalledNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setReference('See ISO 8206 Section 15.1, category c')
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setDescription('The called network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25CallParmInMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInMaxPktSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmInMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInMaxPktSize.setDescription('The maximum receive packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE means use a default size of 128.')
x25CallParmOutMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 14, 1, 3, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutMaxPktSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmOutMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutMaxPktSize.setDescription('The maximum transmit packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use a default size of 128.')
x25Restart = NotificationType((1, 3, 6, 1, 4, 1, 1978, 2, 14, 2, 1) + (0,1)).setObjects(("X25-MIB", "x25AdmnIndex"), ("RS232-MIB", "rs232PortIndex"))
if mibBuilder.loadTexts: x25Restart.setDescription('This trap means the X.25 PLE completed a link restart packet has been sent and: a) a restart packet was received (Restart Collision) b) a restart confirm packet was received. c) the Restart retransmission counter (R20) expires. The packet module now considers the link to be established and ready for Virtual Circuit establishment.')
x25VC = NotificationType((1, 3, 6, 1, 4, 1, 1978, 2, 14, 2, 1) + (0,2)).setObjects(("X25-MIB", "x25CircuitIndex"), ("X25-MIB", "x25CircuitChannel"), ("X25-MIB", "x25CircuitTrapType"), ("X25-MIB", "x25CircuitTrapCause"), ("X25-MIB", "x25CircuitTrapDiagnostic"), ("RS232-MIB", "rs232PortIndex"))
if mibBuilder.loadTexts: x25VC.setDescription('Sent if a virtual circuit needs to send a trap for one of its reasons listed in x25CircuitTrapType.')
mibBuilder.exportSymbols("X25-MIB", InterfaceIndex=InterfaceIndex, x25Restart=x25Restart, x25CallParmRefCount=x25CallParmRefCount, x25AdmnInterfaceMode=x25AdmnInterfaceMode, x25AdmnRxRejectMode=x25AdmnRxRejectMode, x25StatOutDataPackets=x25StatOutDataPackets, x25StatInAccusedOfProtocolErrors=x25StatInAccusedOfProtocolErrors, x25AdmnFacilityLength=x25AdmnFacilityLength, x25CallParmFastSelect=x25CallParmFastSelect, x25CallParmChargingInfo=x25CallParmChargingInfo, x25MIB=x25MIB, x25AdmnMaxTxWindow=x25AdmnMaxTxWindow, x25CircuitDescr=x25CircuitDescr, x25AdmnR28Action=x25AdmnR28Action, x25AdmnEntry=x25AdmnEntry, x25CallParmInWindowSize=x25CallParmInWindowSize, x25CallParmCug=x25CallParmCug, x25CallParmCalledNetworkFacilities=x25CallParmCalledNetworkFacilities, x25AdmnCallTimer=x25AdmnCallTimer, x25AdmnResetTimer=x25AdmnResetTimer, x25CircuitDirection=x25CircuitDirection, x25AdmnMaxRxWindow=x25AdmnMaxRxWindow, x25AdmnTxRejectMode=x25AdmnTxRejectMode, x25AdmnClearCount=x25AdmnClearCount, x25AdmnRRTrigger=x25AdmnRRTrigger, x25StatInProviderInitiatedClears=x25StatInProviderInitiatedClears, x25CallParmEndTrnsDly=x25CallParmEndTrnsDly, x25ChannelLTC=x25ChannelLTC, x25CircuitRNRSent=x25CircuitRNRSent, x25CallParmOutPacketSize=x25CallParmOutPacketSize, x25StatOutInterrupts=x25StatOutInterrupts, x25AdmnABit=x25AdmnABit, x25CircuitEntry=x25CircuitEntry, x25CircuitInInterrupts=x25CircuitInInterrupts, x25CallParmProtection=x25CallParmProtection, x25CircuitCallingAddress=x25CircuitCallingAddress, x25StatInterruptTimeouts=x25StatInterruptTimeouts, x25CallParmAcceptReverseCharging=x25CallParmAcceptReverseCharging, x25CircuitTable=x25CircuitTable, x25StatPVCCircuits=x25StatPVCCircuits, x25ChannelLIC=x25ChannelLIC, x25CallParmTable=x25CallParmTable, x25CircuitOutInterrupts=x25CircuitOutInterrupts, x25StatInProviderInitiatedResets=x25StatInProviderInitiatedResets, x25CircuitTrapCause=x25CircuitTrapCause, x25StatInCallRefusals=x25StatInCallRefusals, x25CallParmIndex=x25CallParmIndex, x25Traps=x25Traps, x25CallParmOutMaxPktSize=x25CallParmOutMaxPktSize, x25AdmnExtendedClear=x25AdmnExtendedClear, x25CircuitChannel=x25CircuitChannel, x25CallParmProposeReverseCharging=x25CallParmProposeReverseCharging, x25StatResetTimeouts=x25StatResetTimeouts, x25AdmnRegistrationRequestCount=x25AdmnRegistrationRequestCount, x25ChannelHIC=x25ChannelHIC, x25CallParmInPacketSize=x25CallParmInPacketSize, x25CallParmUserData=x25CallParmUserData, x25CircuitInPdus=x25CircuitInPdus, x25StatInRestarts=x25StatInRestarts, x25CallParmInMaxPktSize=x25CallParmInMaxPktSize, x25CircuitResetTimeouts=x25CircuitResetTimeouts, x25CircuitDataRetransmissionTimeouts=x25CircuitDataRetransmissionTimeouts, x25CallParmPriority=x25CallParmPriority, x25CircuitCalledAddress=x25CircuitCalledAddress, x25ChannelHTC=x25ChannelHTC, x25StatInCalls=x25StatInCalls, x25StatOutCallAttempts=x25StatOutCallAttempts, x25StatDataRxmtTimeouts=x25StatDataRxmtTimeouts, x25StatRestartTimeouts=x25StatRestartTimeouts, x25CallParmCallingExt=x25CallParmCallingExt, x25StatClearTimeouts=x25StatClearTimeouts, x25AdmnDataRxmtTimer=x25AdmnDataRxmtTimer, x25AdmnNumberPVCs=x25AdmnNumberPVCs, x25CallParmExptData=x25CallParmExptData, x25CallParmCalledExt=x25CallParmCalledExt, x25StatOutCallFailures=x25StatOutCallFailures, x25CallParmRpoa=x25CallParmRpoa, x25AdmnRestartCount=x25AdmnRestartCount, x25CallParmOutThruPutClasSize=x25CallParmOutThruPutClasSize, x25CallParmOutMinThuPutCls=x25CallParmOutMinThuPutCls, x25CircuitInterruptTimeouts=x25CircuitInterruptTimeouts, x25CircuitIndex=x25CircuitIndex, x25AdmnClearTimer=x25AdmnClearTimer, x25AdmnProtocolVersionSupported=x25AdmnProtocolVersionSupported, x25CircuitInProviderInitiatedResets=x25CircuitInProviderInitiatedResets, x25AdmnTable=x25AdmnTable, x25StatRetryCountExceededs=x25StatRetryCountExceededs, x25CallParmTrnstDly=x25CallParmTrnstDly, x25StatSVCCircuits=x25StatSVCCircuits, x25StatClearCountExceededs=x25StatClearCountExceededs, x25AdmnRestartTimer=x25AdmnRestartTimer, x25CallParmStatus=x25CallParmStatus, x25CircuitTrapType=x25CircuitTrapType, x25CallParmNui=x25CallParmNui, x25CallParmInMinThuPutCls=x25CallParmInMinThuPutCls, x25ChannelHOC=x25ChannelHOC, x25AdmnDBit=x25AdmnDBit, ngcan=ngcan, x25CallParmEntry=x25CallParmEntry, x25CircuitInRemotelyInitiatedResets=x25CircuitInRemotelyInitiatedResets, x25CallParmBcug=x25CallParmBcug, x25StatCallTimeouts=x25StatCallTimeouts, x25AdmnIndex=x25AdmnIndex, X121Address=X121Address, x25AdmnRejectCount=x25AdmnRejectCount, x25AdmnResetCount=x25AdmnResetCount, x25AdmnRRTimer=x25AdmnRRTimer, x25AdmnInterruptTimer=x25AdmnInterruptTimer, x25VC=x25VC, x25AdminTrapControl=x25AdminTrapControl, x25AdmnFastSelectCallDataSize=x25AdmnFastSelectCallDataSize, x25AdmnCallDataSize=x25AdmnCallDataSize, x25L3Traps=x25L3Traps, x25CircuitTrapDiagnostic=x25CircuitTrapDiagnostic, x25AdmnRegistrationRequestTimer=x25AdmnRegistrationRequestTimer, x25AdmnInterruptSize=x25AdmnInterruptSize, x25AdmnRejectTimer=x25AdmnRejectTimer, x25CircuitOutOctets=x25CircuitOutOctets, x25StatInRemotelyInitiatedResets=x25StatInRemotelyInitiatedResets, x25CircuitRNRReceive=x25CircuitRNRReceive, x25CallParmOutWindowSize=x25CallParmOutWindowSize, x25AdmnDefCallParamId=x25AdmnDefCallParamId, x25AdmnPacketSequencing=x25AdmnPacketSequencing, x25CircuitOriginallyCalledAddress=x25CircuitOriginallyCalledAddress, x25AdmnWindowTimer=x25AdmnWindowTimer, x25CircuitInOctets=x25CircuitInOctets, x25StatInDataPackets=x25StatInDataPackets, x25StatInInterrupts=x25StatInInterrupts, x25AdmnRRPiggy=x25AdmnRRPiggy, x25ChannelLOC=x25ChannelLOC, x25CircuitEstablishTime=x25CircuitEstablishTime, x25AdmnRegistrationMode=x25AdmnRegistrationMode, x25AdmnDiagnosticMode=x25AdmnDiagnosticMode, x25L3=x25L3, x25CircuitCallParamId=x25CircuitCallParamId, x25CallParmCallingNetworkFacilities=x25CallParmCallingNetworkFacilities, x25AdmnDataRxmtCount=x25AdmnDataRxmtCount, x25CircuitStatus=x25CircuitStatus, x25CircuitOutPdus=x25CircuitOutPdus, X25CallParamIndex=X25CallParamIndex, x25CallParmCugoa=x25CallParmCugoa, x25CallParmInThruPutClasSize=x25CallParmInThruPutClasSize, x25AdmnCause=x25AdmnCause, tiger=tiger)

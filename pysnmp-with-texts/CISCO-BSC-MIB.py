#
# PySNMP MIB module CISCO-BSC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-BSC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, Counter32, IpAddress, ModuleIdentity, Counter64, TimeTicks, ObjectIdentity, MibIdentifier, Bits, Integer32, iso, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "Counter32", "IpAddress", "ModuleIdentity", "Counter64", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Bits", "Integer32", "iso", "Unsigned32")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
ciscoBscMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 36))
ciscoBscMIB.setRevisions(('2004-08-25 00:00', '1997-01-25 00:00', '1995-08-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoBscMIB.setRevisionsDescriptions(("Added 'generic' value to the bscPortRole object for BSC generic support.", 'Added support for BSTUN over Frame-relay, Extended address and 3780 dial-in.', 'Minor cleanups to pacify mib compiler.',))
if mibBuilder.loadTexts: ciscoBscMIB.setLastUpdated('200408250000Z')
if mibBuilder.loadTexts: ciscoBscMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoBscMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W. Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-bisync@cisco.com')
if mibBuilder.loadTexts: ciscoBscMIB.setDescription("The MIB module for BSC. Overview of BSC MIB MIB description The BSC MIB provides the configuration and operational information on Cisco's Binary Synchronous Communications implementation. The following entities are managed: 1) BSC ports (serial interfaces) 2) BSC Control Units (stations on a port) The BSC ports are identified by the interface index, and additional information about this interface can be obtained from the Cisco Serial Interface MIB. The BSC Control Units are identified by the Control Unit address; this is the address used by BSTUN to route the BSC traffic - it is therefore equivalent to the bstunRouteStationAddress in the bstunRouteTable MIB. ")
bscObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 1))
bscPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1))
bscControlUnits = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2))
bscExtAddresses = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 3))
bscPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1), )
if mibBuilder.loadTexts: bscPortTable.setStatus('current')
if mibBuilder.loadTexts: bscPortTable.setDescription('A list of port (serial interfaces) which have been configured to support a BSC BSTUN group.')
bscPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bscPortEntry.setStatus('current')
if mibBuilder.loadTexts: bscPortEntry.setDescription('Status and parameter values for a port.')
bscPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("contention", 3), ("dialContention", 4), ("generic", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortRole.setStatus('current')
if mibBuilder.loadTexts: bscPortRole.setDescription("The router's DLC role to the attached node. If the bscPortRole is primary, this implies that the port is connected to a remote secondary device. If the role is generic, this indicates that the port will be running framed bisynchronous frames with an unknown protocol. If this object does not have the value 'contention' then bscPortVirtualAddress will not be instantiated. If this object does not have the value 'dialContention' then bscPortContentionDialTimeout will not be instantiated.")
bscPortCodeSet = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ebcdic", 1), ("ascii", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortCodeSet.setStatus('current')
if mibBuilder.loadTexts: bscPortCodeSet.setDescription('The code set used for the line controls.')
bscPortPause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortPause.setStatus('current')
if mibBuilder.loadTexts: bscPortPause.setDescription('For primary, it is the minimum time to be taken for a cycle round the active poll table; if this time has not elapsed when the bottom of the poll table is reached, then polling will pause until this timer expires. A value of zero means there will be no pause between cycles round the poll table. For secondary, the pause time out is the delay taken before sending a response to a poll when it has no data frame to send. The units are tenths of a second. The default is 10 (1 second).')
bscPortServlim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortServlim.setStatus('current')
if mibBuilder.loadTexts: bscPortServlim.setDescription('This parameter is valid for primary only. It is the number of times the active poll table will be cycled before a non-responding control unit will be polled. The default is 3.')
bscPortPollTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortPollTimeout.setStatus('current')
if mibBuilder.loadTexts: bscPortPollTimeout.setDescription('This parameter is valid for primary only. It is the time that the primary will wait for a response to a poll or select. The units are tenths of a second. The default is 10 (1 second).')
bscPortRecoveryRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortRecoveryRetries.setStatus('current')
if mibBuilder.loadTexts: bscPortRecoveryRetries.setDescription('This is the number of times that a recovery sequence will be retried before the connection is considered to have failed. The default is 5.')
bscPortUnknownControlUnitsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortUnknownControlUnitsReceived.setStatus('current')
if mibBuilder.loadTexts: bscPortUnknownControlUnitsReceived.setDescription('Count of frames received from the serial interface with an unsupported control unit address. If this value is non-zero it indicates a problem in the configuration.')
bscPortSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortSoftErrors.setStatus('current')
if mibBuilder.loadTexts: bscPortSoftErrors.setDescription('Count of soft errors; these are errors which have been recovered. This includes CRC errors received, frames which were retransmitted for any reason (NAK received or the wrong ACK received), etc. This count is a measure of the quality of the port/line, but should be considered in relation to the amount of traffic on the port (frames or bytes sent and received). This count includes all control unit soft errors on this port, plus errors which were not for a specific control unit.')
bscPortHardErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortHardErrors.setStatus('current')
if mibBuilder.loadTexts: bscPortHardErrors.setDescription('Count of hard errors; these are errors which have not been recovered after bscPortRecoveryRetries number of retries, and therefore the connection has been terminated. These errors could be caused by a hardware error in the line or in the remote device; or possibly the bscPortRecoveryRetries value is set too low for the quality of the line. This count includes all control unit hard errors on this port, plus errors which were not for a specific control unit.')
bscPortProtocolViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortProtocolViolations.setStatus('current')
if mibBuilder.loadTexts: bscPortProtocolViolations.setDescription('Count of protocol violations. This counter is incremented when an unexpected BSC Data Link Control character is received from the remote device; that is, the control character is invalid in the current state of the local BSC FSM. This indicates that there is an incompatibility between the two implementations of the BSC protocol. This count includes all control unit protocol violations on this port, plus errors which were not for a specific control unit.')
bscPortHostTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3000))).setUnits('deciseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortHostTimeout.setStatus('current')
if mibBuilder.loadTexts: bscPortHostTimeout.setDescription('This parameter is valid for interfaces configured secondary which additionally are running local-acknowledgement. If the configuration does not match the value will be shown as zero. It is the time the interface will wait for a poll from the host before putting the CU on the inactive list. The default is 60 seconds.')
bscPortSpecPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortSpecPoll.setStatus('current')
if mibBuilder.loadTexts: bscPortSpecPoll.setDescription('This parameter is valid for primary, local-acknowledgement interfaces only. It is set to TRUE when the interface is configured to treat specific polls as general polls. If the configuration cannot support this value, it will be set to FALSE. The default is FALSE.')
bscPortVirtualAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortVirtualAddress.setStatus('current')
if mibBuilder.loadTexts: bscPortVirtualAddress.setDescription('This parameter is valid for contention only. It is the address to be used for this interface when the remote peer router is being used as a concentrator. The default is 01.')
bscPortContentionDialTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: bscPortContentionDialTimeout.setStatus('current')
if mibBuilder.loadTexts: bscPortContentionDialTimeout.setDescription('This parameter is valid for dialContention only. It is the amount of time an interface can be quiescent before return the interface to the dial-in pool. The default is 5 seconds.')
bscControlUnitTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1), )
if mibBuilder.loadTexts: bscControlUnitTable.setStatus('current')
if mibBuilder.loadTexts: bscControlUnitTable.setDescription('A table containing information about specific Control Units.')
bscCUEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-BSC-MIB", "bscCUAddress"))
if mibBuilder.loadTexts: bscCUEntry.setStatus('current')
if mibBuilder.loadTexts: bscCUEntry.setDescription('The information regarding a single Control Unit.')
bscCUAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: bscCUAddress.setStatus('current')
if mibBuilder.loadTexts: bscCUAddress.setDescription('This value is the poll address of the BSC Control Unit. This address must be unique within a BSTUN Group.')
bscCUState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUState.setStatus('current')
if mibBuilder.loadTexts: bscCUState.setDescription('State of the BSC Control Unit; when active this indicates that the remote Control Unit is polling or responding to polls.')
bscCUBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUBytesSent.setStatus('current')
if mibBuilder.loadTexts: bscCUBytesSent.setDescription('Count of sent bytes (octets). Includes all control characters.')
bscCUBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUBytesReceived.setStatus('current')
if mibBuilder.loadTexts: bscCUBytesReceived.setDescription('Count of received bytes (octets). Includes all control characters.')
bscCUTotalFramesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUTotalFramesSent.setStatus('current')
if mibBuilder.loadTexts: bscCUTotalFramesSent.setDescription('Count of sent frames (blocks). Includes all control frames.')
bscCUTotalFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUTotalFramesReceived.setStatus('current')
if mibBuilder.loadTexts: bscCUTotalFramesReceived.setDescription('Count of received frames (blocks). Includes all control frames.')
bscCUDataFramesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUDataFramesSent.setStatus('current')
if mibBuilder.loadTexts: bscCUDataFramesSent.setDescription('Count of sent data frames (blocks).')
bscCUDataFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUDataFramesReceived.setStatus('current')
if mibBuilder.loadTexts: bscCUDataFramesReceived.setDescription('Count of received data frames (blocks).')
bscCUSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUSoftErrors.setStatus('current')
if mibBuilder.loadTexts: bscCUSoftErrors.setDescription('Count of soft errors; these are errors which have been recovered. This includes CRC errors received, frames which were retransmitted for any reason (NAK received or the wrong ACK received), etc. This count is a measure of the quality of the connection, but should be considered in relation to the amount of traffic on the connection (frames or bytes sent and received).')
bscCUHardErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUHardErrors.setStatus('current')
if mibBuilder.loadTexts: bscCUHardErrors.setDescription('Count of hard errors; these are errors which have not been recovered after bscPortRecoveryRetries number of retries, and therefore the connection has been terminated. These errors could be caused by a hardware error in the link or in the remote device; or possibly the bscPortRecoveryRetries value is set too low for the quality of the connection.')
bscCUProtocolViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscCUProtocolViolations.setStatus('current')
if mibBuilder.loadTexts: bscCUProtocolViolations.setDescription('Count of protocol violations. This counter is incremented when an unexpected BSC Data Link Control character is received from the remote device; that is, the control character is invalid in the current state of the local BSC FSM. This indicates that there is an incompatibility between the two implementations of the BSC protocol.')
bscExtAddressTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 3, 1), )
if mibBuilder.loadTexts: bscExtAddressTable.setStatus('current')
if mibBuilder.loadTexts: bscExtAddressTable.setDescription("List of all addresses configured by the bsc extended-address command. This applies only to interfaces with an ifType of 'bsc'. The address entries must be unique per interface.")
bscExtAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-BSC-MIB", "bscExtPollAddress"))
if mibBuilder.loadTexts: bscExtAddressEntry.setStatus('current')
if mibBuilder.loadTexts: bscExtAddressEntry.setDescription('The information regarding a single extended addresses.')
bscExtPollAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: bscExtPollAddress.setStatus('current')
if mibBuilder.loadTexts: bscExtPollAddress.setDescription('The poll address of the station configured by the bsc extended-address command.')
bscExtSelectAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 36, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bscExtSelectAddress.setStatus('current')
if mibBuilder.loadTexts: bscExtSelectAddress.setDescription('The select address of the station configured by the bsc extended-address command.')
bscMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 3))
bscMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 1))
bscMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 2))
bscMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 1, 1)).setObjects(("CISCO-BSC-MIB", "bscPortsGroup"), ("CISCO-BSC-MIB", "bscControlUnitsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscMibCompliance = bscMibCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: bscMibCompliance.setDescription('The compliance statement for BSTUN.')
bscMibComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 1, 2)).setObjects(("CISCO-BSC-MIB", "bscPortsGroupRev1"), ("CISCO-BSC-MIB", "bscControlUnitsGroup"), ("CISCO-BSC-MIB", "bscExtAddressGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscMibComplianceRev1 = bscMibComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: bscMibComplianceRev1.setDescription('The compliance statement for all Cisco Systems that implement BSC functions.')
bscPortsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 2, 1)).setObjects(("CISCO-BSC-MIB", "bscPortRole"), ("CISCO-BSC-MIB", "bscPortCodeSet"), ("CISCO-BSC-MIB", "bscPortPause"), ("CISCO-BSC-MIB", "bscPortServlim"), ("CISCO-BSC-MIB", "bscPortPollTimeout"), ("CISCO-BSC-MIB", "bscPortRecoveryRetries"), ("CISCO-BSC-MIB", "bscPortUnknownControlUnitsReceived"), ("CISCO-BSC-MIB", "bscPortSoftErrors"), ("CISCO-BSC-MIB", "bscPortHardErrors"), ("CISCO-BSC-MIB", "bscPortProtocolViolations"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscPortsGroup = bscPortsGroup.setStatus('obsolete')
if mibBuilder.loadTexts: bscPortsGroup.setDescription('A collection of objects providing information about BSC enabled interfaces.')
bscControlUnitsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 2, 2)).setObjects(("CISCO-BSC-MIB", "bscCUState"), ("CISCO-BSC-MIB", "bscCUBytesSent"), ("CISCO-BSC-MIB", "bscCUBytesReceived"), ("CISCO-BSC-MIB", "bscCUTotalFramesSent"), ("CISCO-BSC-MIB", "bscCUTotalFramesReceived"), ("CISCO-BSC-MIB", "bscCUDataFramesSent"), ("CISCO-BSC-MIB", "bscCUDataFramesReceived"), ("CISCO-BSC-MIB", "bscCUSoftErrors"), ("CISCO-BSC-MIB", "bscCUHardErrors"), ("CISCO-BSC-MIB", "bscCUProtocolViolations"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscControlUnitsGroup = bscControlUnitsGroup.setStatus('current')
if mibBuilder.loadTexts: bscControlUnitsGroup.setDescription('A collection of objects providing information about BSC Control Units .')
bscPortsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 2, 3)).setObjects(("CISCO-BSC-MIB", "bscPortRole"), ("CISCO-BSC-MIB", "bscPortCodeSet"), ("CISCO-BSC-MIB", "bscPortPause"), ("CISCO-BSC-MIB", "bscPortServlim"), ("CISCO-BSC-MIB", "bscPortPollTimeout"), ("CISCO-BSC-MIB", "bscPortRecoveryRetries"), ("CISCO-BSC-MIB", "bscPortUnknownControlUnitsReceived"), ("CISCO-BSC-MIB", "bscPortSoftErrors"), ("CISCO-BSC-MIB", "bscPortHardErrors"), ("CISCO-BSC-MIB", "bscPortProtocolViolations"), ("CISCO-BSC-MIB", "bscPortHostTimeout"), ("CISCO-BSC-MIB", "bscPortSpecPoll"), ("CISCO-BSC-MIB", "bscPortVirtualAddress"), ("CISCO-BSC-MIB", "bscPortContentionDialTimeout"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscPortsGroupRev1 = bscPortsGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bscPortsGroupRev1.setDescription('A collection of objects providing information about BSC enabled interfaces.')
bscExtAddressGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 36, 3, 2, 4)).setObjects(("CISCO-BSC-MIB", "bscExtSelectAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bscExtAddressGroup = bscExtAddressGroup.setStatus('current')
if mibBuilder.loadTexts: bscExtAddressGroup.setDescription('A collection of objects providing information about BSC extended addresses.')
mibBuilder.exportSymbols("CISCO-BSC-MIB", bscPortCodeSet=bscPortCodeSet, bscPortEntry=bscPortEntry, bscCUDataFramesReceived=bscCUDataFramesReceived, bscPortTable=bscPortTable, bscExtAddressTable=bscExtAddressTable, bscMibCompliances=bscMibCompliances, bscPortRecoveryRetries=bscPortRecoveryRetries, bscPortSoftErrors=bscPortSoftErrors, bscPortsGroup=bscPortsGroup, bscPortsGroupRev1=bscPortsGroupRev1, bscControlUnits=bscControlUnits, bscCUProtocolViolations=bscCUProtocolViolations, bscPortServlim=bscPortServlim, bscObjects=bscObjects, bscCUSoftErrors=bscCUSoftErrors, bscMibComplianceRev1=bscMibComplianceRev1, ciscoBscMIB=ciscoBscMIB, bscPortHostTimeout=bscPortHostTimeout, bscMibCompliance=bscMibCompliance, bscCUBytesSent=bscCUBytesSent, bscCUHardErrors=bscCUHardErrors, PYSNMP_MODULE_ID=ciscoBscMIB, bscExtAddressGroup=bscExtAddressGroup, bscPortSpecPoll=bscPortSpecPoll, bscCUEntry=bscCUEntry, bscControlUnitsGroup=bscControlUnitsGroup, bscPortHardErrors=bscPortHardErrors, bscExtSelectAddress=bscExtSelectAddress, bscCUDataFramesSent=bscCUDataFramesSent, bscPortProtocolViolations=bscPortProtocolViolations, bscCUTotalFramesReceived=bscCUTotalFramesReceived, bscCUTotalFramesSent=bscCUTotalFramesSent, bscCUAddress=bscCUAddress, bscPortUnknownControlUnitsReceived=bscPortUnknownControlUnitsReceived, bscPortContentionDialTimeout=bscPortContentionDialTimeout, bscControlUnitTable=bscControlUnitTable, bscExtAddressEntry=bscExtAddressEntry, bscCUBytesReceived=bscCUBytesReceived, bscPortRole=bscPortRole, bscPorts=bscPorts, bscPortVirtualAddress=bscPortVirtualAddress, bscMibGroups=bscMibGroups, bscPortPause=bscPortPause, bscCUState=bscCUState, bscPortPollTimeout=bscPortPollTimeout, bscMibConformance=bscMibConformance, bscExtAddresses=bscExtAddresses, bscExtPollAddress=bscExtPollAddress)

#
# PySNMP MIB module HM2-WWAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-WWAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
HmEnabledStatus, HmLargeDisplayString, HmTimeSeconds1970, HmActionValue, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmEnabledStatus", "HmLargeDisplayString", "HmTimeSeconds1970", "HmActionValue", "hm2ConfigurationMibs")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, IpAddress, MibIdentifier, ModuleIdentity, Counter64, ObjectIdentity, Bits, Integer32, Unsigned32, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "IpAddress", "MibIdentifier", "ModuleIdentity", "Counter64", "ObjectIdentity", "Bits", "Integer32", "Unsigned32", "NotificationType", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hm2WwanMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 125))
hm2WwanMib.setRevisions(('2015-05-29 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2WwanMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2WwanMib.setLastUpdated('201505291200Z')
if mibBuilder.loadTexts: hm2WwanMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2WwanMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 - 7127 -14 -0 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2WwanMib.setDescription('This MIB defines the SNMP interface for Hirschmann WWAN implementation.')
hm2WwanMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 0))
hm2WwanMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1))
hm2WwanGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1))
hm2WwanDataGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2))
hm2WwanSimCardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3))
hm2WwanInformationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4))
class Hm2CellularNetworks(TextualConvention, Integer32):
    description = 'Cellular Networks list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("auto", 1), ("gsm", 2), ("umts", 3), ("lte", 4), ("gsmumts", 5), ("gsmlte", 6), ("umtslte", 7))

class Hm2TechnologyLevel(TextualConvention, Integer32):
    description = 'Cellular Networks Technology levels.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("lte", 1), ("utms", 2))

class Hm2AuthType(TextualConvention, Integer32):
    description = 'WWAN Data Authentication list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("pap", 2), ("chap", 3), ("papchap", 4))

class Hm2PdpType(TextualConvention, Integer32):
    description = 'WWAN Data IP Addressing types.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("ipv4", 1), ("ipv6", 2), ("ipv4v6", 3))

class Hm2ConnectionStatus(TextualConvention, Integer32):
    description = 'WWAN Data Connection Status list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("inactive", 1), ("active", 2), ("idle", 3), ("reconnecting", 4), ("failure", 5))

class Hm2LimitUnit(TextualConvention, Integer32):
    description = 'WWAN Data Plan measuring unit.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("kb", 1), ("mb", 2), ("gb", 3))

class Hm2SimCardRole(TextualConvention, Integer32):
    description = 'WWAN Sim Card Role.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("auto", 1), ("primary", 2), ("backup", 3))

class Hm2SimCardStatus(TextualConvention, Integer32):
    description = 'WWAN Sim Card Status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("simPresent", 1), ("simAbsent", 2), ("simLocked", 3), ("simUnlocked", 4), ("simInactive", 5), ("simActive", 6))

class Hm2Pin1Status(TextualConvention, Integer32):
    description = 'WWAN Sim Card Pin1 Status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("notVerified", 1), ("verified", 2), ("blocked", 3), ("disabled", 4), ("wrongCode", 5))

class Hm2RegistrationStatus(TextualConvention, Integer32):
    description = 'WWAN Sim Card Registration Status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("notRegistered", 1), ("registering", 2), ("registered", 3), ("failure", 4))

class Hm2RoamingStatus(TextualConvention, Integer32):
    description = 'WWAN Carrier Roaming Status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("home", 1), ("roaming", 2), ("roamingDisabled", 3))

class Hm2TrapBits(TextualConvention, Bits):
    description = 'Traps enable/disable bit list.'
    status = 'current'
    namedValues = NamedValues(("roamingActive", 0), ("ltePersistenceSwitch", 1), ("cellularRegistrationFailed", 2), ("dataConnectionSetup", 3), ("dataPlanWarningThreshold", 4), ("simPin1Status", 5), ("failoverConnectionBackupSim", 6), ("failoverRegistrationBackupSim", 7), ("failoverRoamingBackupSim", 8), ("failoverDataLimitBackupSim", 9), ("failoverRegistrationModemReset", 10))

hm2WwanAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanAdminStatus.setDescription('WWAN Global mode operation change.')
hm2WwanCellularSelection = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 2), Hm2CellularNetworks().clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanCellularSelection.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularSelection.setDescription("Cellular network selection supported combinations. 'auto' value means all supported networks (GSM/UMTS/LTE).")
hm2WwanLtePersistence = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 4), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanLtePersistence.setStatus('current')
if mibBuilder.loadTexts: hm2WwanLtePersistence.setDescription('When an LTE capable device is connected to a non-LTE network it may not handover to an LTE network when one becomes available if data is being continuously transmitted or received. Enabling this function will insure that a connection over LTE will be maintained whenever LTE is available.')
hm2WwanLtePersistenceInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanLtePersistenceInterval.setStatus('current')
if mibBuilder.loadTexts: hm2WwanLtePersistenceInterval.setDescription('The number of seconds after which LTE Persistence switch will be attempted. A 0 value means switch without waiting. This time interval is needed to avoid intermittent switches.')
hm2WwanFailoverTechnologyLevel = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 6), Hm2TechnologyLevel().clone('utms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanFailoverTechnologyLevel.setStatus('current')
if mibBuilder.loadTexts: hm2WwanFailoverTechnologyLevel.setDescription('Desired cellular technology limit. If the current cellular network technology falls below this level then failover can be triggered. This mib node is meant to be used in conjunction with hm2WwanBackupSimTechnologyLevel failover scenario.')
hm2WwanBackupSimFailoverConnection = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 7), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverConnection.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverConnection.setDescription('Switch to Backup SIM card when data connection fails.')
hm2WwanBackupSimFailoverRegistration = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 8), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRegistration.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRegistration.setDescription('Switch to Backup SIM when registration fails.')
hm2WwanBackupSimFailoverRoaming = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 9), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRoaming.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRoaming.setDescription('Switch to Backup SIM when roaming is detected.')
hm2WwanBackupSimFailoverDataLimit = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 10), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverDataLimit.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverDataLimit.setDescription('Switch to Backup SIM card when data limit is reached and switch to Primary SIM when data limit is recovered.')
hm2WwanModemResetFailoverRegistration = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 11), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanModemResetFailoverRegistration.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemResetFailoverRegistration.setDescription('Attempt a Modem reset if both Primary and Backup SIM cards report registration failures. Backup SIM card registration failure might not be needed depending if hm2WwanBackupSimFailoverRegistration is enabled or if the SIM is physical present.')
hm2WwanBackupSimTechnologyLevel = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 12), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanBackupSimTechnologyLevel.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimTechnologyLevel.setDescription('Switch to Backup SIM card when current cellular technology drops bellow a limit. Configure limit with hm2WwanFailoverTechnologyLevel.')
hm2WwanFailoverCycle = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 13), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanFailoverCycle.setStatus('current')
if mibBuilder.loadTexts: hm2WwanFailoverCycle.setDescription('By default hm2WwanBackupSimFailoverConnection hm2WwanBackupSimFailoverRegistration will not fallback to using the Primary SIM card if failure is encountered on the Backup SIM card. This mib node will allow falling back to Primary SIM card if Backup SIM card is unable to register or create a connection. The cycled fallback will be done after 60 seconds.')
hm2WwanSetTrap = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 1, 14), Hm2TrapBits().clone(namedValues=NamedValues(("roamingActive", 0), ("ltePersistenceSwitch", 1), ("cellularRegistrationFailed", 2), ("dataConnectionSetup", 3), ("dataPlanWarningThreshold", 4), ("simPin1Status", 5), ("failoverConnectionBackupSim", 6), ("failoverRegistrationBackupSim", 7), ("failoverRoamingBackupSim", 8), ("failoverDataLimitBackupSim", 9), ("failoverRegistrationModemReset", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSetTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSetTrap.setDescription('A bitmap string serving as a enable/disable method for the trap events defined by the WWAN notifications. All traps are enabled by default.')
hm2WwanDataConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1), )
if mibBuilder.loadTexts: hm2WwanDataConnectionTable.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionTable.setDescription('This table contains configuration options for each WWAN Data connection per SIM card.')
hm2WwanDataConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1), ).setIndexNames((0, "HM2-WWAN-MIB", "hm2WwanDataConnectionSimId"))
if mibBuilder.loadTexts: hm2WwanDataConnectionEntry.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionEntry.setDescription('The entries of the table.')
hm2WwanDataConnectionSimId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: hm2WwanDataConnectionSimId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionSimId.setDescription("SIM ID for which this connection entry belongs to. Also used as the table's index.")
hm2WwanDataConnectionAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 2), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionAdminStatus.setDescription('Operational mode of the connection.')
hm2WwanDataConnectionApn = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionApn.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionApn.setDescription("Access Point Name used to identify the data connection's gateway name in the carriers network. If empty then the default APN configured on the SIM card will be used.")
hm2WwanDataConnectionApnCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionApnCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionApnCurrent.setDescription('Current Access Point Name used for data connections. If hm2WwanDataConnectionApn is empty then the value shown here represents the automatically detected APN stored on the Sim Card.')
hm2WwanDataConnectionUser = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionUser.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionUser.setDescription('User name used for authentication when settting up a new data connection. Empty value means its not required.')
hm2WwanDataConnectionPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionPassword.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionPassword.setDescription('Pasword asociated with the user name used for authentication when settting up a new data connection. Not readable by the user.')
hm2WwanDataConnectionAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 7), Hm2AuthType().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionAuth.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionAuth.setDescription('The type of authentication used when setting up a data connection.')
hm2WwanDataConnectionPdpType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 8), Hm2PdpType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionPdpType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionPdpType.setDescription('The IP type of the data connection to set up. It can be IPv4 or IPv6. Currently only IPv4 is supported.')
hm2WwanDataConnectionIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 9), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressType.setDescription('hm2WwanDataConnectionIpAddress value type, either IPv4 or IPv6.')
hm2WwanDataConnectionIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 10), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddress.setDescription('Manual IP address to be used for configuring a new data connection. If 0.0.0.0 then a dynamic IP Address will be assigned by the carrier.')
hm2WwanDataConnectionDnsPrimaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 11), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryType.setDescription('hm2WwanDataConnectionDnsPrimary value type, either IPv4 or IPv6.')
hm2WwanDataConnectionDnsPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 12), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimary.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimary.setDescription('Manual IP address to be used for configuring the primary DNS server address for the data connection. If 0.0.0.0 then a dynamic DNS IP Address will be assigned by the carrier.')
hm2WwanDataConnectionDnsSecondaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 13), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryType.setDescription('hm2WwanDataConnectionDnsSecondary value type, either IPv4 or IPv6.')
hm2WwanDataConnectionDnsSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 14), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondary.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondary.setDescription('Manual IP address to be used for configuring the secondary DNS server address for the data connection. If 0.0.0.0 then a dynamic DNS IP Address will be assigned by the carrier.')
hm2WwanDataConnectionIpAddressCurrentType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 15), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressCurrentType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressCurrentType.setDescription('hm2WwanDataConnectionIpAddressCurrent value type, either IPv4 or IPv6.')
hm2WwanDataConnectionIpAddressCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 16), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionIpAddressCurrent.setDescription('The IP Address that the WWAN data interface is currently using.')
hm2WwanDataConnectionDnsPrimaryCurrentType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 17), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryCurrentType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryCurrentType.setDescription('hm2WwanDataConnectionDnsPrimaryCurrent value type, either IPv4 or IPv6.')
hm2WwanDataConnectionDnsPrimaryCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsPrimaryCurrent.setDescription('The Primary DNS Address that the WWAN data interface is currently using.')
hm2WwanDataConnectionDnsSecondaryCurrentType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 19), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryCurrentType.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryCurrentType.setDescription('hm2WwanDataConnectionDnsSecondaryCurrent value type, either IPv4 or IPv6.')
hm2WwanDataConnectionDnsSecondaryCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 20), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionDnsSecondaryCurrent.setDescription('The Secondary DNS Address that the WWAN data interface is currently using.')
hm2WwanDataConnectionMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(552, 1500)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionMtu.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionMtu.setDescription('Maximum Transmision Unit used when sending IP packets over the WWAN data interface.')
hm2WwanDataConnectionFailedRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataConnectionFailedRetry.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionFailedRetry.setDescription("How many times should a failed WWAN data connection attempt to try reconnecting before aborting and using fallback options or logging error. A value of 0 means no retry attempts and a value of -1 means 'infinite' attempts.")
hm2WwanDataConnectionFailedRetryCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionFailedRetryCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionFailedRetryCurrent.setDescription('The current number o data reconnect attempts made. Can only be lower or equal to hm2WwanDataConnectionFailedRetry. Value 0 means no retries have been made.')
hm2WwanDataConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 24), Hm2ConnectionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionStatus.setDescription("Current status of this WWAN Data connection. If in 'Error' state then a reason for the error will be found under hm2WwanDataConnectionStatusErrorReason.")
hm2WwanDataConnectionStatusErrorReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 25), HmLargeDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionStatusErrorReason.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionStatusErrorReason.setDescription("The reason why this WWAN Data connection is in 'Error' state.")
hm2WwanDataConnectionActivatedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionActivatedCount.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionActivatedCount.setDescription('How many times this WWAN Data connection was successfuly established.')
hm2WwanDataConnectionStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionStartTime.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionStartTime.setDescription('Time in seconds since Jan 1, 1970.')
hm2WwanDataConnectionUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionUpTime.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionUpTime.setDescription('Time in seconds since this connection is active.')
hm2WwanDataConnectionTotalUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 1, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataConnectionTotalUpTime.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionTotalUpTime.setDescription('Total time in which this connection was active.')
hm2WwanDataPlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2), )
if mibBuilder.loadTexts: hm2WwanDataPlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanTable.setDescription('This table contains configuration options for each WWAN Data Plan per SIM card.')
hm2WwanDataPlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1), ).setIndexNames((0, "HM2-WWAN-MIB", "hm2WwanDataPlanSimId"))
if mibBuilder.loadTexts: hm2WwanDataPlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanEntry.setDescription('The entries of the table.')
hm2WwanDataPlanSimId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: hm2WwanDataPlanSimId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanSimId.setDescription("SIM ID for which this connection entry belongs. Also used as the table's index.")
hm2WwanDataPlanMonthlyLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyLimit.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyLimit.setDescription('The amount of data that the carrier will charge as per a WWAN data contract per month. A value 0 means unlimited.')
hm2WwanDataPlanLimitMeasureUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 3), Hm2LimitUnit().clone('kb')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanLimitMeasureUnit.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanLimitMeasureUnit.setDescription('Which measure unit is used to interpret the volume of the data traffic. Possible units are: Kilobytes, Megabytes, Gigabytes.')
hm2WwanDataPlanWarningThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanWarningThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanWarningThreshold.setDescription('The percentage of the volume of data that when reached will generate a warning. A value of 0 will disable the warning.')
hm2WwanDataPlanReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 5), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanReset.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanReset.setDescription("Manually reset the data plan counters. Only the value 'action(2)' can be written and when read 'noop(1)' will always be returned.")
hm2WwanDataPlanResetDay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanResetDay.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanResetDay.setDescription('Which day of the month will be used to auto reset the data plan counters. A value of 0 will disable the reset action. The reset action will be performed at 00:00am in the selected day.')
hm2WwanDataPlanLastReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 7), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPlanLastReset.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanLastReset.setDescription('Time in seconds since Jan 1st, 1970 when the last data plan counters were resetted.')
hm2WwanDataPlanCutoffThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 8), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanDataPlanCutoffThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanCutoffThreshold.setDescription('The percentage of the volume of used data that when reached will completely disable any data connections associated with this SIM ID. A value of 0 will disable the cutoff.')
hm2WwanDataPlanMonthlyUsageTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyUsageTx.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyUsageTx.setDescription('The amount of data that was transmitted since last reset. The measure unit is the same as hm2WwanDataPlanLimitMeasureUnit.')
hm2WwanDataPlanMonthlyUsageRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyUsageRx.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanMonthlyUsageRx.setDescription('The amount of data that was received since last reset. The measure unit is the same as hm2WwanDataPlanLimitMeasureUnit.')
hm2WwanDataPacketStatsTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3), )
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTable.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTable.setDescription('This table contains packet statistics for each WWAN Data connection per SIM card.')
hm2WwanDataPacketStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1), ).setIndexNames((0, "HM2-WWAN-MIB", "hm2WwanDataPacketStatsSimId"))
if mibBuilder.loadTexts: hm2WwanDataPacketStatsEntry.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsEntry.setDescription('The entries of the table.')
hm2WwanDataPacketStatsSimId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: hm2WwanDataPacketStatsSimId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsSimId.setDescription("SIM ID for which this data connection packet statistics entry belongs to. Also used as the table's index.")
hm2WwanDataPacketStatsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxOk.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxOk.setDescription('The number of successfully transmitted data packets.')
hm2WwanDataPacketStatsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxOk.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxOk.setDescription('The number of successfully received data packets.')
hm2WwanDataPacketStatsTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxErrors.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxErrors.setDescription('The number of errors encountered during packet transmission.')
hm2WwanDataPacketStatsRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxErrors.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxErrors.setDescription('The number of errors encountered during packet reception.')
hm2WwanDataPacketStatsTxOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxOverflows.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxOverflows.setDescription('The number of overflows encountered during packet transmission.')
hm2WwanDataPacketStatsRxOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxOverflows.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxOverflows.setDescription('The number of overflows encountered during packet reception.')
hm2WwanDataPacketStatsTxBytesOk = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxBytesOk.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxBytesOk.setDescription('The number of successfully transmitted bytes.')
hm2WwanDataPacketStatsRxBytesOk = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxBytesOk.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxBytesOk.setDescription('The number of successfully received bytes.')
hm2WwanDataPacketStatsTxDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxDropped.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsTxDropped.setDescription('The number of packets dropped during transmission.')
hm2WwanDataPacketStatsRxDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 2, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxDropped.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPacketStatsRxDropped.setDescription('The number of packets dropped during reception.')
hm2WwanSimCardTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1), )
if mibBuilder.loadTexts: hm2WwanSimCardTable.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardTable.setDescription('This table contains configuration options for each WWAN SIM card.')
hm2WwanSimCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1), ).setIndexNames((0, "HM2-WWAN-MIB", "hm2WwanSimCardSimId"))
if mibBuilder.loadTexts: hm2WwanSimCardEntry.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardEntry.setDescription('The entries of the table.')
hm2WwanSimCardSimId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: hm2WwanSimCardSimId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardSimId.setDescription("SIM ID for which this connection entry belongs. Also used as the table's index.")
hm2WwanSimCardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 2), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardAdminStatus.setDescription('Sim Card enable/disable function.')
hm2WwanSimCardRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 3), Hm2SimCardRole().clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardRole.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardRole.setDescription("The role this Sim Card will be assigned. The role is important for failover scenarios configured under General Configuration Group. 'auto' setting will automatically choose a role.")
hm2WwanSimCardRoleCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 4), Hm2SimCardRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardRoleCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardRoleCurrent.setDescription('The role this Sim Card is currently using.')
hm2WwanSimCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 5), Hm2SimCardStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardStatus.setDescription('Sim Card Status information: * simPresent: the SIM is physicaly present. * simAbsent: the SIM is physicaly absent. * simLocked: the SIM is physicaly present but was not unlocked using PIN1. * simUnlocked: the SIM is physicaly present and it was unlocked unsing PIN1. * simInactive: the sim is physicaly present but it is not used for data connections. * simActive: the sim is physicaly present and is used for data connections.')
hm2WwanSimCardSetActive = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 6), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardSetActive.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardSetActive.setDescription('Manual operation to set the active status of this sim card. When in active state this sim card will be used for establishing data connections.')
hm2WwanSimCardPin1 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(4, 8)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardPin1.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1.setDescription("Sim Card's PIN1 code. PIN1 is used to unlock main Sim functions which will allow Network Carrier Registration.")
hm2WwanSimCardPin1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 8), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardPin1Mode.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1Mode.setDescription("Allows to enable or disable PIN1 code. With PIN1 disabled the Sim Card will automatically unlock all it's functions.")
hm2WwanSimCardPin1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 9), Hm2Pin1Status()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardPin1Status.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1Status.setDescription('Pin1 status information: * NotVerified: Pin1 was not verified. * Verified: Pin1 was successfuly verified. * Blocked: Wrong Pin1 was used too many times and the Sim Card blocked it. * Disabled: Pin1 was manually disabled or the Sim Card does not requires it. * WrongCode: The configured Pin1 code is not accepted by the Sim Card unlock function.')
hm2WwanSimCardPin1VerifyTries = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardPin1VerifyTries.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1VerifyTries.setDescription('The amount of times a wrong Pin1 code can be used to unlock the Sim Card until it is blocked.')
hm2WwanSimCardPin1UnblockTries = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardPin1UnblockTries.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1UnblockTries.setDescription('The amount of times a wrong PUK1 code can be entered to unblock a PIN1 code.')
hm2WwanSimCardPuk1 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardPuk1.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPuk1.setDescription("PUK1 code is used to unblock a PIN1 code. Writing a PUK1 value will attempt to unblock a PIN1 code if the PIN1 code is in 'Blocked' state. PUK1 code will not be saved. hm2WwanSimCardPin1UnblockTries is a counter on how many times a wrong PUK1 code can be entered. Empty value write operation will be ignored. New PIN code configured during the unblock operation will be the current PIN1 stored in hm2WwanSimCardPin1 mib.")
hm2WwanSimCardRoamingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 13), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardRoamingMode.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardRoamingMode.setDescription('Roaming will allow the modem to perform registration with carriers other than the one that emitted the current SIM card. Data connections established when attached to Roaming partners will probably incur additional costs.')
hm2WwanSimCardIccid = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 14), SnmpAdminString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(22, 22), )).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2WwanSimCardIccid.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardIccid.setDescription("Integrated Circuit Card Identifier is the international SIM's identifier. This value is preserved over reboots so that when a new SIM is inserted the operation can be detected and the settings relevant for the old SIM can be resetted. The user can only read this mib value.")
hm2WwanSimCardImsi = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 3, 1, 1, 15), SnmpAdminString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(15, 15), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanSimCardImsi.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardImsi.setDescription('International Mobile Subscriber Identity is an individual identifier on operator networks. Mobile network operators connect mobile phone calls and communicate with their market SIM cards using their IMSIs.')
hm2WwanCellularInformationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1))
hm2WwanModemInformationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 2))
hm2WwanCellularActiveSimId = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularActiveSimId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularActiveSimId.setDescription('The Sim Card id for the current active SIM.')
hm2WwanCellularRegistration = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 2), Hm2RegistrationStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularRegistration.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularRegistration.setDescription("The current status of the Sim's Carrier Registration.")
hm2WwanCellularOperator = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularOperator.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularOperator.setDescription('Network Operator Name')
hm2WwanCellularNetwork = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 4), Hm2CellularNetworks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularNetwork.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularNetwork.setDescription('Current Cellular Network Technology being used.')
hm2WwanCellularMcc = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularMcc.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularMcc.setDescription('Mobile Country Code is a 3 digits code used to identify the country where the Public Land Mobile Network (PLMN) resides.')
hm2WwanCellularMnc = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularMnc.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularMnc.setDescription('Mobile Network Code is a 2 to 3 digits code used to identify the Public Land Mobile Network (PLMN) in that country.')
hm2WwanCellularLac = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularLac.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularLac.setDescription('Location area code together with PLMN (MCC + MNC) creates an internationally unique identifier known as Location Area Identity (LAI). The LAI is used for location updating of the mobile subscribers.')
hm2WwanCellularBsic = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularBsic.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularBsic.setDescription('Base Station Identity Code is a code used in WWAN networks to uniquely identify a base station.')
hm2WwanCellularCellId = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularCellId.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularCellId.setDescription('The identifier of the current used WWAN Cell.')
hm2WwanCellularBand = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularBand.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularBand.setDescription('The current Cellular Band used for radio transmissions.')
hm2WwanCellularChannel = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularChannel.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularChannel.setDescription('The current channel number within the Cellular Band used for radio transmissions.')
hm2WwanCellularSignalStrength = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularSignalStrength.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularSignalStrength.setDescription('In GSM/UMTS mobile networks signal strength is based on RSSI (Received Signal Strength Indication) value measuring the power level being received by the antena. The higher the RSSI the stronger the signal.')
hm2WwanCellularSignalStrengthLte = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularSignalStrengthLte.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularSignalStrengthLte.setDescription('In LTE mobile networks signal strength is based on RSRP (Reference Signal Received Power) value.')
hm2WwanCellularSignalQuality = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularSignalQuality.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularSignalQuality.setDescription('UMTS signal quality indicator based on ECIO (Energy to Interference Ratio).')
hm2WwanCellularSignalQualityLte = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularSignalQualityLte.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularSignalQualityLte.setDescription('LTE signal quality indicator based on RSRQ (Reference Signal Received Quality).')
hm2WwanCellularRscp = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularRscp.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularRscp.setDescription('UMTS Received Signal Code Power is used as an indication of signal strength, as a handover criterion, in downlink power control and to calculate path loss.')
hm2WwanCellularRoamingStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 17), Hm2RoamingStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularRoamingStatus.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularRoamingStatus.setDescription('Current Roaming status: * Home: registration done in home network. * Roaming: registration done in partner network in roaming mode. Roaming has to be admin enabled. * RoamingDisabled: no home network detected and Roaming is admin disabled.')
hm2WwanCellularBitErrorRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularBitErrorRate.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularBitErrorRate.setDescription('Cellular transmission error rate displayed in percentage.')
hm2WwanCellularCurrentTxRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularCurrentTxRate.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularCurrentTxRate.setDescription('Current channel TX rate displayed in kbps.')
hm2WwanCellularCurrentRxRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularCurrentRxRate.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularCurrentRxRate.setDescription('Current channel RX rate displayed in kbps.')
hm2WwanCellularMaxTxRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularMaxTxRate.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularMaxTxRate.setDescription('Maximum channel TX rate that can be achieved, displayed in kbps.')
hm2WwanCellularMaxRxRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanCellularMaxRxRate.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCellularMaxRxRate.setDescription('Maximum channel RX rate that can be achieved, displayed in kbps.')
hm2WwanModemManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 2, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanModemManufacturer.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemManufacturer.setDescription('Radio Modem Manufacturer')
hm2WwanModemModel = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 2, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanModemModel.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemModel.setDescription('The model of the Radio Modem.')
hm2WwanModemRevision = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 2, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanModemRevision.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemRevision.setDescription('Modem Software version and revision.')
hm2WwanModemImei = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 125, 1, 4, 2, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2WwanModemImei.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemImei.setDescription('Internation Mobile Equipment Identity is a unique number given to mobile capable devices.')
hm2WwanRoamingActiveTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 1)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularRoamingStatus"), ("HM2-WWAN-MIB", "hm2WwanCellularOperator"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"))
if mibBuilder.loadTexts: hm2WwanRoamingActiveTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanRoamingActiveTrap.setDescription('Notification generated whenever Roaming status will become active.')
hm2WwanLtePersistenceSwitchTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 2)).setObjects(("HM2-WWAN-MIB", "hm2WwanLtePersistence"), ("HM2-WWAN-MIB", "hm2WwanLtePersistenceInterval"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"))
if mibBuilder.loadTexts: hm2WwanLtePersistenceSwitchTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanLtePersistenceSwitchTrap.setDescription('Notification generated when LTE Persistence function will perform a switch back to LTE.')
hm2WwanCelluarRegistrationFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 3)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularRegistration"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"))
if mibBuilder.loadTexts: hm2WwanCelluarRegistrationFailedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanCelluarRegistrationFailedTrap.setDescription('Notification generated whenever a Cellular Network Registration failure occurs.')
hm2WwanDataConnectionSetupTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 4)).setObjects(("HM2-WWAN-MIB", "hm2WwanDataConnectionStatus"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanDataConnectionApnCurrent"))
if mibBuilder.loadTexts: hm2WwanDataConnectionSetupTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataConnectionSetupTrap.setDescription('Notification generated whenever a Cellular Data Connection will change its status.')
hm2WwanDataPlanWarningThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 5)).setObjects(("HM2-WWAN-MIB", "hm2WwanDataPlanWarningThreshold"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanDataPlanMonthlyLimit"), ("HM2-WWAN-MIB", "hm2WwanDataPlanLimitMeasureUnit"), ("HM2-WWAN-MIB", "hm2WwanDataPlanMonthlyUsageTx"), ("HM2-WWAN-MIB", "hm2WwanDataPlanMonthlyUsageRx"))
if mibBuilder.loadTexts: hm2WwanDataPlanWarningThresholdTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanDataPlanWarningThresholdTrap.setDescription('Notification generated when the Data Plan Warning Threshold is reached. The trap is resent after each 25% of remaining data is consumed all the way up until the Data Plan Limit is reached.')
hm2WwanSimCardPin1StatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 6)).setObjects(("HM2-WWAN-MIB", "hm2WwanSimCardPin1Status"), ("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"), ("HM2-WWAN-MIB", "hm2WwanSimCardStatus"))
if mibBuilder.loadTexts: hm2WwanSimCardPin1StatusTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanSimCardPin1StatusTrap.setDescription('Notification generated whenever SIM Card PIN1 access functions are used and their status changes.')
hm2WwanBackupSimFailoverConnectionTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 7)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"))
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverConnectionTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverConnectionTrap.setDescription('Notification generated whenever a data connection on the Primary SIM Card fails and a failover to Backup SIM Card is done.')
hm2WwanBackupSimFailoverRegistrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 8)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"))
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRegistrationTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRegistrationTrap.setDescription('Notification generated whenever a cellular network registration the Primary SIM Card fails and a failover to Backup SIM Card is done.')
hm2WwanBackupSimFailoverRoamingTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 9)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"))
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRoamingTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverRoamingTrap.setDescription('Notification generated whenever a cellular network registration to a Roaming Carrier is detected on the Primary SIM Card and as a result a failover to the Backup SIM Card is done.')
hm2WwanBackupSimFailoverDataLimitTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 10)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"))
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverDataLimitTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanBackupSimFailoverDataLimitTrap.setDescription('Notification generated when the current Data Plan Limit is reached and a failover to the Backup SIM Card is done.')
hm2WwanModemResetFailoverRegistrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 125, 0, 11)).setObjects(("HM2-WWAN-MIB", "hm2WwanCellularActiveSimId"), ("HM2-WWAN-MIB", "hm2WwanSimCardRoleCurrent"))
if mibBuilder.loadTexts: hm2WwanModemResetFailoverRegistrationTrap.setStatus('current')
if mibBuilder.loadTexts: hm2WwanModemResetFailoverRegistrationTrap.setDescription('Notification generated when cellular network registration fails on the Primary SIM Card and also the fallback to Backup SIM Card registration fails.')
mibBuilder.exportSymbols("HM2-WWAN-MIB", hm2WwanDataPlanLastReset=hm2WwanDataPlanLastReset, hm2WwanDataConnectionIpAddress=hm2WwanDataConnectionIpAddress, hm2WwanBackupSimFailoverDataLimit=hm2WwanBackupSimFailoverDataLimit, hm2WwanModemModel=hm2WwanModemModel, Hm2RegistrationStatus=Hm2RegistrationStatus, hm2WwanCelluarRegistrationFailedTrap=hm2WwanCelluarRegistrationFailedTrap, hm2WwanLtePersistenceInterval=hm2WwanLtePersistenceInterval, hm2WwanSimCardPin1Mode=hm2WwanSimCardPin1Mode, hm2WwanDataConnectionPdpType=hm2WwanDataConnectionPdpType, hm2WwanModemImei=hm2WwanModemImei, hm2WwanBackupSimFailoverRegistrationTrap=hm2WwanBackupSimFailoverRegistrationTrap, hm2WwanCellularActiveSimId=hm2WwanCellularActiveSimId, hm2WwanSimCardAdminStatus=hm2WwanSimCardAdminStatus, Hm2TrapBits=Hm2TrapBits, hm2WwanSetTrap=hm2WwanSetTrap, hm2WwanCellularBitErrorRate=hm2WwanCellularBitErrorRate, hm2WwanDataConnectionDnsSecondary=hm2WwanDataConnectionDnsSecondary, hm2WwanDataPlanCutoffThreshold=hm2WwanDataPlanCutoffThreshold, hm2WwanDataPlanReset=hm2WwanDataPlanReset, hm2WwanCellularMcc=hm2WwanCellularMcc, hm2WwanSimCardPuk1=hm2WwanSimCardPuk1, hm2WwanDataConnectionDnsSecondaryType=hm2WwanDataConnectionDnsSecondaryType, hm2WwanSimCardImsi=hm2WwanSimCardImsi, hm2WwanModemRevision=hm2WwanModemRevision, hm2WwanDataPlanMonthlyUsageTx=hm2WwanDataPlanMonthlyUsageTx, hm2WwanFailoverCycle=hm2WwanFailoverCycle, Hm2TechnologyLevel=Hm2TechnologyLevel, hm2WwanDataPacketStatsTxDropped=hm2WwanDataPacketStatsTxDropped, hm2WwanSimCardSimId=hm2WwanSimCardSimId, hm2WwanDataConnectionPassword=hm2WwanDataConnectionPassword, PYSNMP_MODULE_ID=hm2WwanMib, hm2WwanSimCardRoleCurrent=hm2WwanSimCardRoleCurrent, hm2WwanDataConnectionApnCurrent=hm2WwanDataConnectionApnCurrent, hm2WwanCellularRscp=hm2WwanCellularRscp, hm2WwanCellularCurrentTxRate=hm2WwanCellularCurrentTxRate, hm2WwanRoamingActiveTrap=hm2WwanRoamingActiveTrap, Hm2ConnectionStatus=Hm2ConnectionStatus, hm2WwanCellularBand=hm2WwanCellularBand, hm2WwanDataConnectionStartTime=hm2WwanDataConnectionStartTime, hm2WwanDataGroup=hm2WwanDataGroup, hm2WwanSimCardPin1Status=hm2WwanSimCardPin1Status, hm2WwanCellularSignalQualityLte=hm2WwanCellularSignalQualityLte, hm2WwanBackupSimFailoverRoamingTrap=hm2WwanBackupSimFailoverRoamingTrap, hm2WwanDataPlanEntry=hm2WwanDataPlanEntry, hm2WwanSimCardRole=hm2WwanSimCardRole, hm2WwanSimCardPin1VerifyTries=hm2WwanSimCardPin1VerifyTries, hm2WwanDataConnectionIpAddressCurrentType=hm2WwanDataConnectionIpAddressCurrentType, hm2WwanCellularCurrentRxRate=hm2WwanCellularCurrentRxRate, hm2WwanDataConnectionDnsSecondaryCurrent=hm2WwanDataConnectionDnsSecondaryCurrent, hm2WwanInformationGroup=hm2WwanInformationGroup, hm2WwanDataPacketStatsRxOk=hm2WwanDataPacketStatsRxOk, hm2WwanDataPacketStatsRxErrors=hm2WwanDataPacketStatsRxErrors, hm2WwanSimCardGroup=hm2WwanSimCardGroup, hm2WwanDataPacketStatsRxBytesOk=hm2WwanDataPacketStatsRxBytesOk, hm2WwanDataConnectionDnsPrimaryType=hm2WwanDataConnectionDnsPrimaryType, hm2WwanBackupSimFailoverConnectionTrap=hm2WwanBackupSimFailoverConnectionTrap, hm2WwanFailoverTechnologyLevel=hm2WwanFailoverTechnologyLevel, hm2WwanDataConnectionAdminStatus=hm2WwanDataConnectionAdminStatus, hm2WwanDataConnectionIpAddressType=hm2WwanDataConnectionIpAddressType, hm2WwanDataConnectionMtu=hm2WwanDataConnectionMtu, hm2WwanDataConnectionIpAddressCurrent=hm2WwanDataConnectionIpAddressCurrent, hm2WwanSimCardPin1=hm2WwanSimCardPin1, hm2WwanDataPacketStatsTable=hm2WwanDataPacketStatsTable, hm2WwanSimCardIccid=hm2WwanSimCardIccid, Hm2SimCardRole=Hm2SimCardRole, hm2WwanDataConnectionTable=hm2WwanDataConnectionTable, hm2WwanCellularSignalQuality=hm2WwanCellularSignalQuality, hm2WwanModemResetFailoverRegistration=hm2WwanModemResetFailoverRegistration, hm2WwanBackupSimTechnologyLevel=hm2WwanBackupSimTechnologyLevel, hm2WwanCellularMaxTxRate=hm2WwanCellularMaxTxRate, hm2WwanDataPlanSimId=hm2WwanDataPlanSimId, hm2WwanDataConnectionFailedRetry=hm2WwanDataConnectionFailedRetry, hm2WwanDataPlanMonthlyUsageRx=hm2WwanDataPlanMonthlyUsageRx, hm2WwanDataConnectionDnsPrimaryCurrentType=hm2WwanDataConnectionDnsPrimaryCurrentType, hm2WwanSimCardEntry=hm2WwanSimCardEntry, hm2WwanSimCardPin1UnblockTries=hm2WwanSimCardPin1UnblockTries, Hm2CellularNetworks=Hm2CellularNetworks, Hm2LimitUnit=Hm2LimitUnit, hm2WwanBackupSimFailoverConnection=hm2WwanBackupSimFailoverConnection, hm2WwanCellularRegistration=hm2WwanCellularRegistration, hm2WwanDataConnectionApn=hm2WwanDataConnectionApn, hm2WwanSimCardRoamingMode=hm2WwanSimCardRoamingMode, hm2WwanCellularCellId=hm2WwanCellularCellId, hm2WwanDataPacketStatsTxBytesOk=hm2WwanDataPacketStatsTxBytesOk, hm2WwanDataConnectionFailedRetryCurrent=hm2WwanDataConnectionFailedRetryCurrent, hm2WwanDataPlanLimitMeasureUnit=hm2WwanDataPlanLimitMeasureUnit, hm2WwanDataConnectionActivatedCount=hm2WwanDataConnectionActivatedCount, hm2WwanDataPlanWarningThresholdTrap=hm2WwanDataPlanWarningThresholdTrap, hm2WwanDataConnectionSimId=hm2WwanDataConnectionSimId, hm2WwanDataConnectionDnsPrimaryCurrent=hm2WwanDataConnectionDnsPrimaryCurrent, hm2WwanMib=hm2WwanMib, hm2WwanCellularOperator=hm2WwanCellularOperator, hm2WwanCellularLac=hm2WwanCellularLac, hm2WwanGeneralGroup=hm2WwanGeneralGroup, hm2WwanDataPacketStatsRxDropped=hm2WwanDataPacketStatsRxDropped, hm2WwanCellularInformationGroup=hm2WwanCellularInformationGroup, hm2WwanDataPacketStatsEntry=hm2WwanDataPacketStatsEntry, hm2WwanSimCardStatus=hm2WwanSimCardStatus, hm2WwanModemManufacturer=hm2WwanModemManufacturer, hm2WwanSimCardTable=hm2WwanSimCardTable, hm2WwanLtePersistence=hm2WwanLtePersistence, hm2WwanDataConnectionTotalUpTime=hm2WwanDataConnectionTotalUpTime, hm2WwanLtePersistenceSwitchTrap=hm2WwanLtePersistenceSwitchTrap, hm2WwanAdminStatus=hm2WwanAdminStatus, Hm2SimCardStatus=Hm2SimCardStatus, hm2WwanDataConnectionUpTime=hm2WwanDataConnectionUpTime, hm2WwanCellularSignalStrength=hm2WwanCellularSignalStrength, hm2WwanDataConnectionUser=hm2WwanDataConnectionUser, hm2WwanCellularRoamingStatus=hm2WwanCellularRoamingStatus, hm2WwanBackupSimFailoverDataLimitTrap=hm2WwanBackupSimFailoverDataLimitTrap, hm2WwanMibNotifications=hm2WwanMibNotifications, hm2WwanCellularMaxRxRate=hm2WwanCellularMaxRxRate, hm2WwanDataConnectionAuth=hm2WwanDataConnectionAuth, hm2WwanModemInformationGroup=hm2WwanModemInformationGroup, hm2WwanBackupSimFailoverRegistration=hm2WwanBackupSimFailoverRegistration, hm2WwanCellularSignalStrengthLte=hm2WwanCellularSignalStrengthLte, hm2WwanBackupSimFailoverRoaming=hm2WwanBackupSimFailoverRoaming, hm2WwanDataPlanWarningThreshold=hm2WwanDataPlanWarningThreshold, hm2WwanCellularBsic=hm2WwanCellularBsic, hm2WwanDataConnectionDnsSecondaryCurrentType=hm2WwanDataConnectionDnsSecondaryCurrentType, hm2WwanDataPacketStatsTxErrors=hm2WwanDataPacketStatsTxErrors, hm2WwanDataConnectionDnsPrimary=hm2WwanDataConnectionDnsPrimary, hm2WwanDataPacketStatsTxOverflows=hm2WwanDataPacketStatsTxOverflows, hm2WwanDataPacketStatsRxOverflows=hm2WwanDataPacketStatsRxOverflows, hm2WwanCellularSelection=hm2WwanCellularSelection, Hm2Pin1Status=Hm2Pin1Status, Hm2PdpType=Hm2PdpType, hm2WwanSimCardPin1StatusTrap=hm2WwanSimCardPin1StatusTrap, Hm2RoamingStatus=Hm2RoamingStatus, hm2WwanDataConnectionEntry=hm2WwanDataConnectionEntry, hm2WwanDataConnectionStatus=hm2WwanDataConnectionStatus, hm2WwanDataConnectionStatusErrorReason=hm2WwanDataConnectionStatusErrorReason, hm2WwanSimCardSetActive=hm2WwanSimCardSetActive, hm2WwanDataPlanMonthlyLimit=hm2WwanDataPlanMonthlyLimit, hm2WwanDataPlanTable=hm2WwanDataPlanTable, hm2WwanCellularNetwork=hm2WwanCellularNetwork, hm2WwanMibObjects=hm2WwanMibObjects, hm2WwanModemResetFailoverRegistrationTrap=hm2WwanModemResetFailoverRegistrationTrap, hm2WwanDataPlanResetDay=hm2WwanDataPlanResetDay, Hm2AuthType=Hm2AuthType, hm2WwanCellularChannel=hm2WwanCellularChannel, hm2WwanDataPacketStatsSimId=hm2WwanDataPacketStatsSimId, hm2WwanCellularMnc=hm2WwanCellularMnc, hm2WwanDataPacketStatsTxOk=hm2WwanDataPacketStatsTxOk, hm2WwanDataConnectionSetupTrap=hm2WwanDataConnectionSetupTrap)

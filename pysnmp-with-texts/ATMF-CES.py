#
# PySNMP MIB module ATMF-CES (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATMF-CES
# Produced by pysmi-0.3.4 at Wed May  1 11:31:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
iso, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32, Counter64, ModuleIdentity, Unsigned32, IpAddress, Integer32, enterprises, Gauge32, Bits, MibIdentifier, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32", "Counter64", "ModuleIdentity", "Unsigned32", "IpAddress", "Integer32", "enterprises", "Gauge32", "Bits", "MibIdentifier", "ObjectIdentity", "TimeTicks")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
atmfCES = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 2, 2))
atmfCES.setRevisions(('1995-02-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atmfCES.setRevisionsDescriptions(('The MIB Module to describe the DS1/E1Circuit Emulation Interworking Function (Version 1.0) Note: The new Version 2 CES MIB replaces this earlier Version 1 CES MIB which exists as the (deprecated) first branch from the overall atmfCESmib object.',))
if mibBuilder.loadTexts: atmfCES.setLastUpdated('9611050000Z')
if mibBuilder.loadTexts: atmfCES.setOrganization('ATM Forum Circuit Emulation Working Group')
if mibBuilder.loadTexts: atmfCES.setContactInfo('The ATM Forum 2570 West El Camino Real, Suite 304 Mountain View, CA 94040-1313 USA Phone: +1 415-949-6700 Fax: +1 415-949-6705 info@atmforum.com')
if mibBuilder.loadTexts: atmfCES.setDescription('The MIB module used to describe the Circuit Emulation Interworking Function (Version 2.0)')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfCESmib = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 2))
class VpiInteger(TextualConvention, Integer32):
    description = 'An integer large enough to hold a VPI'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 4095)

class VciInteger(TextualConvention, Integer32):
    description = 'An integer large enough to hold a VCI'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class CESConnectionPort(TextualConvention, Integer32):
    description = "Indicates the port associated with a Circuit Emulation connection. Objects of this type are always defined as part of a set that includes fooPort CESConnectionPort fooVpi VpiInteger fooVci VciInteger The interpretation of these objects is as follows: 1. If no connection exists, 'fooPort' has a value of 0. Because Interface table entries always have 'ifIndex' values greater than 0, 'fooPort' reliably serves as a 'connection exists' flag. If no connection exists, 'fooVpi' and 'fooVci' are not relevant and have a value of 0. 2. If a PVC or SVC exists, 'fooPort' is defined to have the value of the MIB-II/RFC1573 'ifIndex' of the ATM interface associated with the VCC. The ifType associated with such an ifIndex value is either atm(37) or atmLogical(80). 'fooVpi' and 'fooVci' will contain its VPI/VCI."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are: no address (0 octets), E.164 (8 octets), and NSAP-encoded ATM Endsystem Address (20 octets). Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    displayHint = '1x'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
atmfCESObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1))
atmfCESConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1), )
if mibBuilder.loadTexts: atmfCESConfTable.setStatus('current')
if mibBuilder.loadTexts: atmfCESConfTable.setDescription('The CES configuration table used to manage interworking between CBR interfaces or channels and ATM Virtual Channel Links (VCLs). The reverse mapping is shown in the atmfCESMappingTable.')
atmfCESConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1), ).setIndexNames((0, "ATMF-CES", "atmfCESCbrIndex"))
if mibBuilder.loadTexts: atmfCESConfEntry.setStatus('current')
if mibBuilder.loadTexts: atmfCESConfEntry.setDescription('An entry in the CES configuration table. There is one entry in the table per CES entity, mapping one CBR interface, channel, or bundle to an ATM VCL. Creation of a row in this table with a non-zero atmfCESAtmIndex causes a corresponding entry in the atmVclTable of the ATM-MIB (RFC1695) to be created.')
atmfCESCbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: atmfCESCbrIndex.setStatus('current')
if mibBuilder.loadTexts: atmfCESCbrIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the CBR interface, channel, or bundle that is being cross-connected to an ATM VCL.")
atmfCESAtmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 2), CESConnectionPort()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESAtmIndex.setStatus('current')
if mibBuilder.loadTexts: atmfCESAtmIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM Port interface mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The distinguished value zero indicates that no ATM interface has been specified.")
atmfCESAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 3), VpiInteger()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESAtmVpi.setStatus('current')
if mibBuilder.loadTexts: atmfCESAtmVpi.setDescription('The value of this object is equal to the VPI used by the ATM VCL mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The value is not relevant if no ATM interface has been specified (i.e., atmfCESAtmIndex is set to zero).')
atmfCESAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 4), VciInteger()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESAtmVci.setStatus('current')
if mibBuilder.loadTexts: atmfCESAtmVci.setDescription('The value of this object is equal to the VCI used by the ATM VCL mapped through this CES IWF to a CBR interface. This value is overwritten whenever an active or passive SVC is established. The distinguished value zero indicates that no ATM VCL has been specified.')
atmfCESCbrService = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unstructured", 1), ("structured", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESCbrService.setStatus('current')
if mibBuilder.loadTexts: atmfCESCbrService.setDescription('Define if DSx/Ex service isas structured or unstructurednot. A structured(2) interface is some nx64kbKbps. An unstructured (1) interface is 1.544Mbps, 2.048Mbps, 6.312Mbps, 44.736 Mbps, or 34.368 Mbps. unstructured(1) passes all bits through the ATM network. strucutured(2) passes data bits through the ATM network, and may also pass signalling bits At this time, only unstructured mode is defined for the 44.736 Mbps and 34.368 Mbps services.')
atmfCESCbrClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("synchronous", 1), ("srts", 2), ("adaptive", 3))).clone('synchronous')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESCbrClockMode.setStatus('current')
if mibBuilder.loadTexts: atmfCESCbrClockMode.setDescription('Define if DSx/Ex service clocking mode. This maps into transmit clock source of CBR interface. For structured modes this value, if present, must be set to synchronous(1).')
atmfCESCas = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("basic", 1), ("e1Cas", 2), ("ds1SfCas", 3), ("ds1EsfCas", 4), ("j2Cas", 5))).clone('basic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESCas.setStatus('current')
if mibBuilder.loadTexts: atmfCESCas.setDescription('This parameter selects which AAL1 Format should be used: Basic does not carry CAS bits, and uses a single 125 usec frame. e1Cas, ds1SfCas, dS1EsfCas and j2Cas carry CAS bits in a multiframe structure for E1, DS1 SF, DS1 ESF and J2 respectively. This applies to structured interfaces only. Default is basic (1). For unstructured interfaces this value, if present, must be set to the default of basic (1).')
atmfCESPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESPartialFill.setStatus('current')
if mibBuilder.loadTexts: atmfCESPartialFill.setDescription('If partial cell fill is used, the number of user octets per cell must be set with this parameter. Setting this parameter to zero disables partial cell fill, and causes all cells to be completely filled before they are sent.')
atmfCESBufMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(128)).setUnits('10 usec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESBufMaxSize.setStatus('current')
if mibBuilder.loadTexts: atmfCESBufMaxSize.setDescription('Define maximum size in 10 microsecond increments of the reassembly buffer. Some implementations may want allow the maximum buffer size to be programmed to a size less than the physical limit to reduce the maximum delay through a circuit.')
atmfCESCdvRxT = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(100)).setUnits('10 usec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESCdvRxT.setStatus('current')
if mibBuilder.loadTexts: atmfCESCdvRxT.setDescription('The maximum cell arrival jitter in 10 usec increments that the reassembly process will tolerate in the cell stream without producing errors on the CBR service interface.')
atmfCESCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535)).clone(2500)).setUnits('msec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESCellLossIntegrationPeriod.setStatus('current')
if mibBuilder.loadTexts: atmfCESCellLossIntegrationPeriod.setDescription('The time in milliseconds for the cell loss integration period. If a cells are continuously lost for this period of time, atmfCESCellLossStatus is set to loss (2). The default definition is 2500.')
atmfCESConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("pvc", 2), ("activeSvc", 3), ("passiveSvc", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESConnType.setStatus('current')
if mibBuilder.loadTexts: atmfCESConnType.setDescription("The type of ATM connectivity between associated CES IWF's. Valid values are: other - none of the types specified below pvc - supporting connectivity is a permanent virtual connection activeSvc - attempt calls whenever none established passiveSvc - accept calls")
atmfCESLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 13), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESLocalAddr.setStatus('current')
if mibBuilder.loadTexts: atmfCESLocalAddr.setDescription('The ATM address of the local CES IWF process. This address may be used by the automatic SVC establishment procedures to identify the intended recipient CES IWF of an incoming automatic SVC call request. Optionally, the MAX-ACCESS of this object may be read-only, for those implementations where it is not desired to manually configure this address.')
atmfCESAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmfCESAdminStatus.setDescription('The desired administrative status of the CES interworking function. The up and down states indicate that the traffic flow is enabled or disabled respectively across the CES interworking function.')
atmfCESOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmfCESOperStatus.setDescription('The operational status of the CES interworking function. The up and down states indicate that the traffic flow is enabled or disabled respectively across the CES interworking function. The unknown state indicates that the state of the CES interworking function cannot be determined. The state will be down or unknown if the supporting CBR or ATM interfaces are down or unknown, respectively.')
atmfCESConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 1, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmfCESConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmfCESConfRowStatus.setDescription('This object is used to create new rows in this table, modify existing rows, and to delete existing rows.')
atmfCESMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 2), )
if mibBuilder.loadTexts: atmfCESMappingTable.setStatus('current')
if mibBuilder.loadTexts: atmfCESMappingTable.setDescription('The CES mapping table used to show the mapping from ATM VCLs to CBR interfaces or channels. The mapping and interworking functions are configured in the atmfCESConfTable.')
atmfCESMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 2, 1), ).setIndexNames((0, "ATMF-CES", "atmfCESAtmIndex"), (0, "ATMF-CES", "atmfCESAtmVpi"), (0, "ATMF-CES", "atmfCESAtmVci"))
if mibBuilder.loadTexts: atmfCESMappingEntry.setStatus('current')
if mibBuilder.loadTexts: atmfCESMappingEntry.setDescription('An entry in the CES mapping table. There is one entry in the table corresponding to each active row in the atmfCESConfTable for which there is a non-zero atmfCESAtmIndex.')
atmfCESMappingCbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESMappingCbrIndex.setStatus('current')
if mibBuilder.loadTexts: atmfCESMappingCbrIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the CBR interface, channel, or bundle that is being cross-connected to an ATM VCL. Examples of the ifType value for the CBR entity are ds1(18), ds3(30), ds0(81), or ds0bundle(82).")
atmfCESStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3), )
if mibBuilder.loadTexts: atmfCESStatsTable.setStatus('current')
if mibBuilder.loadTexts: atmfCESStatsTable.setDescription('The CES AAL1 statistical data table.')
atmfCESStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1), )
atmfCESConfEntry.registerAugmentions(("ATMF-CES", "atmfCESStatsEntry"))
atmfCESStatsEntry.setIndexNames(*atmfCESConfEntry.getIndexNames())
if mibBuilder.loadTexts: atmfCESStatsEntry.setStatus('current')
if mibBuilder.loadTexts: atmfCESStatsEntry.setDescription('An entry in the CES AAL1 Stats table. There is one entry in this table corresponding to each entry in the atmfCESConfTable.')
atmfCESReassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESReassCells.setStatus('current')
if mibBuilder.loadTexts: atmfCESReassCells.setDescription('This count gives the number of cells played out to the CES Service Interface. It excludes cells that were discarded for any reason, including cells that were not used due to being declared misinserted, or discarded while the reassembler was waiting to achieve synchronization.')
atmfCESHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESHdrErrors.setStatus('current')
if mibBuilder.loadTexts: atmfCESHdrErrors.setDescription('The count of the number of AAL1 header errors detected, including those corrected. Header errors include correctable and uncorrectable CRC, plus bad parity.')
atmfCESPointerReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESPointerReframes.setStatus('current')
if mibBuilder.loadTexts: atmfCESPointerReframes.setDescription('This records the count of the number of events in which the AAL1 reassembler found that an SDT pointer is not where it is expected, and the pointer must be reacquired. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
atmfCESPointerParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESPointerParityErrors.setStatus('current')
if mibBuilder.loadTexts: atmfCESPointerParityErrors.setDescription('This records the count of the number of events in which the AAL1 reassembler detects a parity check failure at the point where a structured data pointer is expected. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
atmfCESAal1SeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESAal1SeqErrors.setStatus('current')
if mibBuilder.loadTexts: atmfCESAal1SeqErrors.setDescription("Number of times that the sequence number of an incoming AAL1 Type 1 SAR-PDU causes a transition from the 'sync' state to the 'out of sequence' state, as defined by ITU-T I.363.1.")
atmfCESLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESLostCells.setStatus('current')
if mibBuilder.loadTexts: atmfCESLostCells.setDescription('Number of lost cells, as detected by the AAL1 sequence number processing, for example. This records the count of the number of cells detected as lost in the network prior to the destination CES IWF AAL1 layer processing.')
atmfCESMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmfCESMisinsertedCells.setDescription('Number of AAL1 sequence violations which the AAL Convergence sublayer interprets as a misinserted cell, as defined by ITU-T I.363.1.')
atmfCESBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESBufUnderflows.setStatus('current')
if mibBuilder.loadTexts: atmfCESBufUnderflows.setDescription('Number of buffer underflows. This records the count of the number of times the CES reassembly buffer underflows. In the case of a continuous underflow caused by a loss of ATM cell flow, a single buffer underflow should be counted. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer), then either buffer underflow will cause this count to be incremented.')
atmfCESBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESBufOverflows.setStatus('current')
if mibBuilder.loadTexts: atmfCESBufOverflows.setDescription('Number of buffer overflows. This records the count of the number of times the CES reassembly buffer overflows. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer, then either buffer overflow will cause this count to be incremented ')
atmfCESCellLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoss", 1), ("loss", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESCellLossStatus.setStatus('current')
if mibBuilder.loadTexts: atmfCESCellLossStatus.setDescription('When cells are continuously lost for the number of milliseconds specified by atmfCESCellLossIntegrationPeriod, the value is set to loss (2). When cells are no longer lost, the value is set to noLoss (1).')
atmfCESActiveSvcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4), )
if mibBuilder.loadTexts: atmfCESActiveSvcTable.setStatus('current')
if mibBuilder.loadTexts: atmfCESActiveSvcTable.setDescription('The table used to manage active SVCs established across ATM networks between CES entities.')
atmfCESActiveSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1), ).setIndexNames((0, "ATMF-CES", "atmfCESCbrIndex"))
if mibBuilder.loadTexts: atmfCESActiveSvcEntry.setStatus('current')
if mibBuilder.loadTexts: atmfCESActiveSvcEntry.setDescription("An entry in the CES active SVC table. There is one entry in the table corresponding to each active row in the atmfCESConfTable for which the atmfCESConnType takes the value 'activeSvc'.")
atmfCESRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 1), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfCESRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: atmfCESRemoteAddr.setDescription('The ATM address supporting the corresponding far end CES IWF process. If no address is supplied, no attempts to establish the active SVC are initiated.')
atmfCESFirstRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfCESFirstRetryInterval.setStatus('current')
if mibBuilder.loadTexts: atmfCESFirstRetryInterval.setDescription('The time to wait before attempting to establish the SVC after the first failed call attempt. The time to wait between subsequent call attempts may differ to implement a backoff scheme. Zero represents an infinite interval indicating no retries.')
atmfCESRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESRetryTimer.setStatus('current')
if mibBuilder.loadTexts: atmfCESRetryTimer.setDescription('Indicates the current value of the retry timer for this connection. When the value reaches zero an attempt will be made to establish the active SVC. When the timer is not running, the value zero shall be returned.')
atmfCESRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfCESRetryLimit.setStatus('current')
if mibBuilder.loadTexts: atmfCESRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful call setup attempts can be made before stopping the attempt to set up the connection. If this limit is reached then management action will be required (e.g. setting atmfCESActiveSvcRestart to 'restart') to initiate a new attempt to establish the connection. A value of zero indicates no limit - the attempts will continue until successful. If this object is not present, no limit on call attempts is assumed.")
atmfCESRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESRetryFailures.setStatus('current')
if mibBuilder.loadTexts: atmfCESRetryFailures.setDescription('Indicates how many attempts to establish the connection have failed. This count is reset whenever a connection is successfully established or the active SVC is restarted.')
atmfCESActiveSvcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfCESActiveSvcRestart.setStatus('current')
if mibBuilder.loadTexts: atmfCESActiveSvcRestart.setDescription("When the value is set to 'restart' the active SVC is released if necessary and a new setup procedure is begun. As a result of this action, the atmfCESActiveSvcOperStatus object transitions to 'establishmentInProgress' (if not already in this state) and the atmfCESRetryFailures object is cleared. When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
atmfCESActiveSvcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4), ("noAddressSupplied", 5), ("lowerLayerDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESActiveSvcOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmfCESActiveSvcOperStatus.setDescription("Describes the status of the active SVC. Valid values are: other - none of the types specified below establishmentInProgress - connection is not operational, but call attempts are ongoing connected - connection is currently operational retriesExhausted - retry limit has been reached and call attempts have ceased noAddressSupplied - no remote address has been configured, so no call attempts are initiated lowerLayerDown - underlying CES IWF is not operational When the row is not 'active', the value of this object is 'other'.")
atmfCESLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESLastReleaseCause.setStatus('current')
if mibBuilder.loadTexts: atmfCESLastReleaseCause.setDescription('Value of the Cause field of the Cause information element in the last RELEASE signalling message received for this active SVC. Indicates the reason for the release.')
atmfCESLastReleaseDiagnostics = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 1, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfCESLastReleaseDiagnostics.setStatus('current')
if mibBuilder.loadTexts: atmfCESLastReleaseDiagnostics.setDescription('Value of the first 8 bytes of diagnostic information from the Cause field of the Cause information element in the last RELEASE signalling message received for this active SVC.')
atmfCESConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2))
atmfCESGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1))
atmfCESCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 2))
atmfCESCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 2, 1)).setObjects(("ATMF-CES", "atmfCESBasicConfigGroup"), ("ATMF-CES", "atmfCESBasicStatsGroup"), ("ATMF-CES", "atmfCESStructConfigGroup"), ("ATMF-CES", "atmfCESStructStatsGroup"), ("ATMF-CES", "atmfCESSvcConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESCompliance = atmfCESCompliance.setStatus('current')
if mibBuilder.loadTexts: atmfCESCompliance.setDescription('The compliance statement for SNMP entities which support the ATM Forum Circuit Emulation Services.')
atmfCESBasicConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 1)).setObjects(("ATMF-CES", "atmfCESAtmIndex"), ("ATMF-CES", "atmfCESAtmVpi"), ("ATMF-CES", "atmfCESAtmVci"), ("ATMF-CES", "atmfCESCbrService"), ("ATMF-CES", "atmfCESCbrClockMode"), ("ATMF-CES", "atmfCESBufMaxSize"), ("ATMF-CES", "atmfCESCdvRxT"), ("ATMF-CES", "atmfCESCellLossIntegrationPeriod"), ("ATMF-CES", "atmfCESConnType"), ("ATMF-CES", "atmfCESConfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESBasicConfigGroup = atmfCESBasicConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESBasicConfigGroup.setDescription('A collection of objects providing configuration information for generic Circuit Emulation Service IWFs.')
atmfCESOptionalConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 2)).setObjects(("ATMF-CES", "atmfCESAdminStatus"), ("ATMF-CES", "atmfCESOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESOptionalConfigGroup = atmfCESOptionalConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESOptionalConfigGroup.setDescription('A collection of optional objects providing configuration information for generic Circuit Emulation Service IWFs.')
atmfCESBasicStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 3)).setObjects(("ATMF-CES", "atmfCESReassCells"), ("ATMF-CES", "atmfCESHdrErrors"), ("ATMF-CES", "atmfCESBufUnderflows"), ("ATMF-CES", "atmfCESBufOverflows"), ("ATMF-CES", "atmfCESCellLossStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESBasicStatsGroup = atmfCESBasicStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESBasicStatsGroup.setDescription('A collection of objects providing statistics information for generic Circuit Emulation Service IWFs.')
atmfCESOptionalStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 4)).setObjects(("ATMF-CES", "atmfCESAal1SeqErrors"), ("ATMF-CES", "atmfCESLostCells"), ("ATMF-CES", "atmfCESMisinsertedCells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESOptionalStatsGroup = atmfCESOptionalStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESOptionalStatsGroup.setDescription('A collection of optional objects providing statistics information for generic Circuit Emulation Service IWFs.')
atmfCESStructConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 5)).setObjects(("ATMF-CES", "atmfCESCas"), ("ATMF-CES", "atmfCESPartialFill"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESStructConfigGroup = atmfCESStructConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESStructConfigGroup.setDescription('A collection of objects providing configuration information for Structured DS1, E1 or J2 Nx64 kbit/s Service IWFs.')
atmfCESStructStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 6)).setObjects(("ATMF-CES", "atmfCESPointerReframes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESStructStatsGroup = atmfCESStructStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESStructStatsGroup.setDescription('A collection of objects providing statistics information for Structured DS1, E1 or J2 Nx64 kbit/s Service IWFs.')
atmfCESOptionalStructStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 7)).setObjects(("ATMF-CES", "atmfCESPointerParityErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESOptionalStructStatsGroup = atmfCESOptionalStructStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESOptionalStructStatsGroup.setDescription('A collection of optional objects providing statistics information for Structured DS1, E1 or J2 Nx64 kbit/s Service IWFs.')
atmfCESMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 8)).setObjects(("ATMF-CES", "atmfCESMappingCbrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESMappingGroup = atmfCESMappingGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESMappingGroup.setDescription('A collection of objects providing information about the mapping from ATM VCLs to CBR interfaces or channels.')
atmfCESSvcConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 9)).setObjects(("ATMF-CES", "atmfCESLocalAddr"), ("ATMF-CES", "atmfCESRemoteAddr"), ("ATMF-CES", "atmfCESFirstRetryInterval"), ("ATMF-CES", "atmfCESRetryTimer"), ("ATMF-CES", "atmfCESRetryFailures"), ("ATMF-CES", "atmfCESActiveSvcRestart"), ("ATMF-CES", "atmfCESActiveSvcOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESSvcConfigGroup = atmfCESSvcConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESSvcConfigGroup.setDescription('A collection of objects providing SVC connection establishment support configuration information for CES IWFs.')
atmfCESOptionalSvcConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 2, 2, 2, 1, 10)).setObjects(("ATMF-CES", "atmfCESRetryLimit"), ("ATMF-CES", "atmfCESLastReleaseCause"), ("ATMF-CES", "atmfCESLastReleaseDiagnostics"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmfCESOptionalSvcConfigGroup = atmfCESOptionalSvcConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmfCESOptionalSvcConfigGroup.setDescription('A collection of optional objects providing SVC connection establishment support configuration information for CES IWFs.')
mibBuilder.exportSymbols("ATMF-CES", atmfCESConfTable=atmfCESConfTable, atmfCESCbrService=atmfCESCbrService, PYSNMP_MODULE_ID=atmfCES, atmfCESOperStatus=atmfCESOperStatus, atmfCESBufUnderflows=atmfCESBufUnderflows, VpiInteger=VpiInteger, atmfCESStructConfigGroup=atmfCESStructConfigGroup, atmForum=atmForum, atmfCESAtmVpi=atmfCESAtmVpi, atmfCESCas=atmfCESCas, atmfCESPartialFill=atmfCESPartialFill, atmfCESConfEntry=atmfCESConfEntry, atmfCESLastReleaseCause=atmfCESLastReleaseCause, atmfCESCbrClockMode=atmfCESCbrClockMode, atmfCESPointerParityErrors=atmfCESPointerParityErrors, atmfCESmib=atmfCESmib, atmForumNetworkManagement=atmForumNetworkManagement, atmfCESReassCells=atmfCESReassCells, atmfCESLastReleaseDiagnostics=atmfCESLastReleaseDiagnostics, atmfCESObjects=atmfCESObjects, atmfCESCompliance=atmfCESCompliance, atmfCESOptionalSvcConfigGroup=atmfCESOptionalSvcConfigGroup, atmfCESStatsEntry=atmfCESStatsEntry, atmfCESConnType=atmfCESConnType, atmfCESLocalAddr=atmfCESLocalAddr, atmfCESMappingTable=atmfCESMappingTable, atmfCESCompliances=atmfCESCompliances, atmfCESHdrErrors=atmfCESHdrErrors, atmfCESActiveSvcEntry=atmfCESActiveSvcEntry, atmfCESRetryFailures=atmfCESRetryFailures, atmfCESConfRowStatus=atmfCESConfRowStatus, atmfCESMisinsertedCells=atmfCESMisinsertedCells, atmfCESOptionalStructStatsGroup=atmfCESOptionalStructStatsGroup, atmfCESCellLossStatus=atmfCESCellLossStatus, atmfCESBufMaxSize=atmfCESBufMaxSize, atmfCESFirstRetryInterval=atmfCESFirstRetryInterval, atmfCESActiveSvcTable=atmfCESActiveSvcTable, atmfCESRetryTimer=atmfCESRetryTimer, atmfCESSvcConfigGroup=atmfCESSvcConfigGroup, atmfCES=atmfCES, atmfCESAal1SeqErrors=atmfCESAal1SeqErrors, atmfCESAtmVci=atmfCESAtmVci, AtmAddr=AtmAddr, atmfCESBasicStatsGroup=atmfCESBasicStatsGroup, atmfCESLostCells=atmfCESLostCells, atmfCESMappingEntry=atmfCESMappingEntry, atmfCESGroups=atmfCESGroups, atmfCESStatsTable=atmfCESStatsTable, atmfCESConformance=atmfCESConformance, atmfCESBasicConfigGroup=atmfCESBasicConfigGroup, atmfCESStructStatsGroup=atmfCESStructStatsGroup, atmfCESAtmIndex=atmfCESAtmIndex, atmfCESCellLossIntegrationPeriod=atmfCESCellLossIntegrationPeriod, atmfCESBufOverflows=atmfCESBufOverflows, atmfCESMappingCbrIndex=atmfCESMappingCbrIndex, atmfCESCdvRxT=atmfCESCdvRxT, atmfCESOptionalConfigGroup=atmfCESOptionalConfigGroup, atmfCESOptionalStatsGroup=atmfCESOptionalStatsGroup, atmfCESRetryLimit=atmfCESRetryLimit, CESConnectionPort=CESConnectionPort, atmfCESAdminStatus=atmfCESAdminStatus, atmfCESActiveSvcOperStatus=atmfCESActiveSvcOperStatus, atmfCESMappingGroup=atmfCESMappingGroup, atmfCESRemoteAddr=atmfCESRemoteAddr, atmfCESActiveSvcRestart=atmfCESActiveSvcRestart, atmfCESCbrIndex=atmfCESCbrIndex, VciInteger=VciInteger, atmfCESPointerReframes=atmfCESPointerReframes)

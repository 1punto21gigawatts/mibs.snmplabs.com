#
# PySNMP MIB module CISCO-ATM-SIG-DIAG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM-SIG-DIAG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:50:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "InterfaceIndexOrZero")
ServiceCategory, PnniPortId, PnniNodeId = mibBuilder.importSymbols("PNNI-MIB", "ServiceCategory", "PnniPortId", "PnniNodeId")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
MibIdentifier, TimeTicks, Integer32, iso, IpAddress, Unsigned32, Counter32, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, ObjectIdentity, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "TimeTicks", "Integer32", "iso", "IpAddress", "Unsigned32", "Counter32", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "ObjectIdentity", "ModuleIdentity")
TimeStamp, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "RowStatus", "DisplayString", "TextualConvention")
ciscoAtmSigDiagMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 78))
ciscoAtmSigDiagMIB.setRevisions(('1997-07-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoAtmSigDiagMIB.setRevisionsDescriptions(('Initial version of the MIB for diagnosis of failures of ATM signalling requests.',))
if mibBuilder.loadTexts: ciscoAtmSigDiagMIB.setLastUpdated('9707280000Z')
if mibBuilder.loadTexts: ciscoAtmSigDiagMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoAtmSigDiagMIB.setContactInfo(' Cisco Systems Customer Service Postal: 250 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoAtmSigDiagMIB.setDescription('The MIB module to facilitate the diagnosis of failures of ATM Signalling requests. Through this MIB, an ATM device retains information for one, or possibly more, connection setup failure records. Each record stores information about those connection setup failures which match a set of selection criteria, such as particular Calling or Called ATM Addresses.')
ciscoSigFailMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 1))
class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are: no address (0 octets), E.164 (8 octets), and NSAP (20 octets). Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    displayHint = '1x'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
csfBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 1))
csfFilterControl = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csfFilterControl.setStatus('current')
if mibBuilder.loadTexts: csfFilterControl.setDescription("This object enables or disables the call failure filtering feature in the ATM device. When this object is modified from 'enable' to 'disable' the records in the csfRecordTable are not removed but filtering is stopped in the device.")
csfFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2))
csfFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1), )
if mibBuilder.loadTexts: csfFilterTable.setStatus('current')
if mibBuilder.loadTexts: csfFilterTable.setDescription('The table whose entries describe the filtering criteria for recording failed connection setup requests.')
csfFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-ATM-SIG-DIAG-MIB", "csfFilterIndex"))
if mibBuilder.loadTexts: csfFilterEntry.setStatus('current')
if mibBuilder.loadTexts: csfFilterEntry.setDescription("Each entry in this table corresponds to a filtering criteria based on which the rejected calls are recorded. This selection criteria is applied against all connection setup failures generated/detected at this ATM device. Only connection setup failures which match against all of the entry's criteria are recorded in the csfRecordTable. A new entry can be created by specifying a csfFilterIndex value that is currently not being used and also using an appropriate value (createAndGo or createAndWait) for the csfFilterRowStatus object. If a particular call failure matches multiple entries in the csfRecordTable then multiple entries will be created in the csfRecordTable for each of the matched entries in the csfFilterTable . An entry in the csfFilterTable could also be created via the command line interface, available on the ATM devices.")
csfFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)))
if mibBuilder.loadTexts: csfFilterIndex.setStatus('current')
if mibBuilder.loadTexts: csfFilterIndex.setDescription('An arbitrary integer uniquely identifying a filtering criteria.')
csfFilterScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("localRejects", 1), ("remoteRejects", 2), ("allRejects", 3))).clone('allRejects')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterScope.setStatus('current')
if mibBuilder.loadTexts: csfFilterScope.setDescription('This object restricts the scope of the filter to calls which where rejected either within the system in which the filtering is in progress or to calls which were rejected on external ATM devices but transited through the device in which filtering is in progress.')
csfFilterConnKind = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterConnKind.setStatus('current')
if mibBuilder.loadTexts: csfFilterConnKind.setDescription('This object enables the user to track failures of soft permanent virtual channel connections, soft permanent virtual path connections, switched virtual channel connections, and/or switched virtual path connections.')
csfFilterConnCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterConnCastType.setStatus('current')
if mibBuilder.loadTexts: csfFilterConnCastType.setDescription('This object restricts the scope of the filter based on the type of topology of connections (point-to-point or point-to-multipoint). ')
csfFilterServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterServiceCategory.setStatus('current')
if mibBuilder.loadTexts: csfFilterServiceCategory.setDescription('This object restricts the scope of the filter to calls belonging to service categories represented by this object. ')
csfFilterInInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterInInterface.setStatus('current')
if mibBuilder.loadTexts: csfFilterInInterface.setDescription('This object restricts the scope of the filter to calls which entered the ATM device through the port represented by this object It has the value 0, or the ifIndex value of an ATM Interface. The value zero indicates that the scope of the filter is not restricted by the incoming port. ')
csfFilterOutInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterOutInterface.setStatus('current')
if mibBuilder.loadTexts: csfFilterOutInterface.setDescription('This object restricts the scope of the filter to calls which exited the ATM device through the port represented by this object It has the value 0, or the ifIndex value of an ATM Interface. The value zero indicates that the scope of the filter is not restricted by the outgoing port. To track calls failed locally in the ATM device in which the call failure tracking is in progress ,the csfFilterScope object should be used , in which case the value of this object need not be changed from its default value. ')
csfFilterCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterCause.setReference("ATM Forum's UNI3.0/3.1 Specification. ")
if mibBuilder.loadTexts: csfFilterCause.setStatus('current')
if mibBuilder.loadTexts: csfFilterCause.setDescription('This object restricts the scope of the filter to calls which were cleared with the cause code represented by this object. The values are the same as the clear code values mentioned in the ATM forum UNI specifications.The value zero indicates that the scope of the filter is not restricted by the cause code value.')
csfFilterCallingParty = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 9), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterCallingParty.setStatus('current')
if mibBuilder.loadTexts: csfFilterCallingParty.setDescription('The combination of this object and the corresponding instance of csfFilterCallingPartyMask is one selection criteria for this record. To match this selection criteria, a failed connection setup must have a Calling Party Address which has the same length as, and is equal in value to csfFilterCallingParty for all bits that are 1 in the value of csfFilterCallingPartyMask. When the default value for the object is retained then the rejected call will match this filtering criteria for any calling address in the rejected call. ')
csfFilterCallingPartyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterCallingPartyMask.setStatus('current')
if mibBuilder.loadTexts: csfFilterCallingPartyMask.setDescription('The combination of this object and the corresponding instance of csfFilterCallingParty is one selection criteria for this record. To match this selection criteria, a failed connection setup must have a Calling Party Address which equals the value of csfFilterCallingParty for all bit positions identified by the value of csfFilterCallingPartyMask. If the mask value is shorter than the length of csfFilterCallingParty, then it is extended with zero bits to be the required length. If the default value for this object is retained then the rejected call will match this filtering criterion if and only if the calling address in the call matches the csfFilterCallingParty for this entry. ')
csfFilterCalledParty = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 11), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterCalledParty.setStatus('current')
if mibBuilder.loadTexts: csfFilterCalledParty.setDescription('The combination of this object and the corresponding instance of csfFilterCalledPartyMask is one selection criteria for this record. To match this selection criteria, a failed connection setup must have a called party address which has the same length as, and is equal in value to csfFilterCalledParty for all bits that are 1 in the value of csfFilterCalledPartyMask. When the default value for the object is retained then the rejected call will match this filtering criteria for any called address in the call. ')
csfFilterCalledPartyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterCalledPartyMask.setStatus('current')
if mibBuilder.loadTexts: csfFilterCalledPartyMask.setDescription('The combination of this object and the corresponding instance of csfFilterCalledParty is one selection criteria for this record. To match this selection criteria, a failed connection setup must have a Calling Party Address which equals the value of csfFilterCalledParty for all bit positions identified by the value of csfFilterCalledPartyMask. If the mask value is shorter than the length of csfFilterCalledParty, then it is extended with zero bits to be the required length. If the default value for this object is retained then the rejected call will match this filtering criterion if and only if the calling address in the call matches the csfFilterCallingParty for this entry. ')
csfFilterMaxRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterMaxRecords.setStatus('current')
if mibBuilder.loadTexts: csfFilterMaxRecords.setDescription("The maximum number of entries that are desired in the csfRecordTable on behalf of this entry. The agent will not create more than this number of entries in the table,but may choose to create fewer entries in the csfRecordTable for any reason including the lack of resources. The agent will however dedicate resources for a minimum number of entries in the csfRecordTable ,to take care of temporary memory allocation failures in the system. In case of memory allocation failures the agent will utilize these dedicated resources for the creation of the new entries. If memory resource failures continue and the dedicated resources are exhausted then the records in the csfRecordTable are pruned such that the oldest entries are removed to make way for the new entries. A value '-1' will indicate no upper limit for the number of records stored. The manager can set this object to -1 if overwriting of records is not desired. The new value for this object will take effect immediately. If this object is set to a value less than the number of entries thats currently present in the csfRecordTable corresponding to this entry, then the oldest entries in the csfRecordTable will be deleted so that their number equals the new value of this object. If the value of this object is changed from -1 to any other positive value then the entries will be pruned such that only the first n records collected for this entry are retained in the csfRecordTable, n being the new value of this object. ")
csfFilterAgeTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterAgeTimeout.setStatus('current')
if mibBuilder.loadTexts: csfFilterAgeTimeout.setDescription("The number of seconds left for this entry to age out. On expiry of this timer filtering is disabled for this entry. The display records in the csfRecordTable corresponding to this entry are retained. When the timer expires the object will have a value zero. The management station can restart filtering for this entry by setting this object to a positive value. When the object is set to zero, filtering is stopped for this entry. When the management station modifies this object , the currently running timer,if any, is aborted and a timer is started with the new value of this object. The value '-1' will indicate an infinite timeout value. ")
csfFilterPurge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("purge", 1), ("noop", 2))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterPurge.setStatus('current')
if mibBuilder.loadTexts: csfFilterPurge.setDescription("The object provides a facility for the user to purge the records in the csfRecordTable corresponding to this entry. When the value is set to 'purge', the records in the csfRecordTable corresponding to this entry are purged. When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
csfFilterNumMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfFilterNumMatches.setStatus('current')
if mibBuilder.loadTexts: csfFilterNumMatches.setDescription('A monotonically increasing counter to keep track of the number of call failures that matched this entry for the entire lifetime of this entry. ')
csfFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 2, 1, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csfFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: csfFilterRowStatus.setDescription("Indicates the status of this row. Used according to the row installation and removal conventions. This object can be used to temporarily inactivate an entry in the table. When this object is set to a value 'notInService' filtering is stopped for the corresponding row. Any records that have been stored in the csfRecordTable corresponding to this entry will not be released. Any writeable objects in the row can be modified when the row is active. All values will take effect immediately.")
csfRecordGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3))
csfRecordTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1), )
if mibBuilder.loadTexts: csfRecordTable.setStatus('current')
if mibBuilder.loadTexts: csfRecordTable.setDescription('The table in which the failures of ATM Signalling connection setup requests are recorded.')
csfRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-ATM-SIG-DIAG-MIB", "csfFilterIndex"), (0, "CISCO-ATM-SIG-DIAG-MIB", "csfRecordIndex"))
if mibBuilder.loadTexts: csfRecordEntry.setStatus('current')
if mibBuilder.loadTexts: csfRecordEntry.setDescription("An entry representing one connection setup request failure record. The csfRecordFilterIndex represents the index into the csfFilterTable whose entry is the filtering criteria applied against all connection setup failures generated/detected at this ATM device. Only connection setup failures which match against all of the filtering entry's criteria are recorded in the table. There could be multiple entries for each filtering criteria. The csfFilterMaxRecords indicates the number of records to be stored for the corresponding csfFilterTable entry.")
csfRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: csfRecordIndex.setStatus('current')
if mibBuilder.loadTexts: csfRecordIndex.setDescription('An arbitrary integer used to distinguish between multiple records for the same filtering criteria. ')
csfRecordScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localReject", 1), ("remoteReject", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordScope.setStatus('current')
if mibBuilder.loadTexts: csfRecordScope.setDescription('This object indicates the location of the call failure.')
csfRecordConnKind = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("softPvcc", 1), ("softPvpc", 2), ("switchedVcc", 3), ("switchedVpc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordConnKind.setStatus('current')
if mibBuilder.loadTexts: csfRecordConnKind.setDescription('This object represents the use of call control of the rejected connection. ')
csfRecordConnCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("p2p", 1), ("p2mp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordConnCastType.setStatus('current')
if mibBuilder.loadTexts: csfRecordConnCastType.setDescription('This object represents the type of topology of the rejected call (point-to-point or point-to-multipoint).')
csfRecordConnIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("addPartyReject", 1), ("setupReject", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordConnIndicator.setStatus('current')
if mibBuilder.loadTexts: csfRecordConnIndicator.setDescription('Indicates whether this record was created due to an add party failure or a setup failure. ')
csfRecordServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 6), ServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordServiceCategory.setStatus('current')
if mibBuilder.loadTexts: csfRecordServiceCategory.setDescription('This object represents the service category used by the call. ')
csfRecordInInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordInInterface.setStatus('current')
if mibBuilder.loadTexts: csfRecordInInterface.setDescription('The IfIndex of the incoming port on which this call was received by the ATM device.')
csfRecordOutInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordOutInterface.setStatus('current')
if mibBuilder.loadTexts: csfRecordOutInterface.setDescription('The IfIndex of the outgoing port ,if available, through which this call was routed to the network. The distinguished value zero indicates that the call was rejected before any outgoing interface was chosen.')
csfRecordCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCause.setReference("ATM Forum's UNI3.0/3.1 Specification. ")
if mibBuilder.loadTexts: csfRecordCause.setStatus('current')
if mibBuilder.loadTexts: csfRecordCause.setDescription('This object identifies the reason for the call failure. When a PNNI Crankback information element is included in the call clearing message, this object contains the crankback cause. In all other cases, the values are the same as the cause code values defined for the Cause information element.')
csfRecordDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordDiags.setReference("ATM Forum's UNI3.0/3.1 Specification. ")
if mibBuilder.loadTexts: csfRecordDiags.setStatus('current')
if mibBuilder.loadTexts: csfRecordDiags.setDescription("This object contains the contents of the diagnostics fields from the Cause information element. When the value of csfRecordCause is 49,'Quality of Service unavailable', the diagnostics are taken from the PNNI Crankback information element instead of the cause information element.")
csfRecordCallingParty = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 11), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCallingParty.setStatus('current')
if mibBuilder.loadTexts: csfRecordCallingParty.setDescription('Indicates the ATM adddress of the calling party in the rejected call.')
csfRecordCallingPartySubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 12), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCallingPartySubAddress.setStatus('current')
if mibBuilder.loadTexts: csfRecordCallingPartySubAddress.setDescription('Indicates the ATM sub-adddress of the calling party in the rejected call. The presence of a sub address is not mandatory. If the calling sub-addresses is not present in the call then this object will have a null value.')
csfRecordCalledParty = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 13), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCalledParty.setStatus('current')
if mibBuilder.loadTexts: csfRecordCalledParty.setDescription('Indicates the ATM address of the called party in the rejected call. ')
csfRecordCalledPartySubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 14), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCalledPartySubAddress.setStatus('current')
if mibBuilder.loadTexts: csfRecordCalledPartySubAddress.setDescription('Indicates the ATM sub-adddress of the called party in the rejected call. The presence of a sub address is not mandatory. If the called sub-address is not present in the call then this object will have a null value.')
csfRecordCrankBackTransitType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("blockedIncomingPort", 1), ("blockedNode", 2), ("blockedLink", 3), ("noCrankBack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCrankBackTransitType.setStatus('current')
if mibBuilder.loadTexts: csfRecordCrankBackTransitType.setDescription("This object identifies the type of blockage in case of a blocked call. This object has a value 'noCrankBack' if the call was cleared without a crankback information element.")
csfRecordCrankBackNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 16), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCrankBackNodeId.setStatus('current')
if mibBuilder.loadTexts: csfRecordCrankBackNodeId.setDescription("This object depends on the csfRecordCrankBackTransitType object. When that object value is 'blockedNode', csfRecordCrankBackNodeId indicates the node ID of the blocked node. When the csfRecordCrankBackTransitType object value is 'blockedLink', this object indicates the node ID of the logical node preceding the link at which the call/connection was blocked. When the csfRecordCrankBackTransitType object value is 'blockedIncomingPort' or 'noCrankBack', this object is set to null.")
csfRecordCrankBackPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 17), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCrankBackPortId.setStatus('current')
if mibBuilder.loadTexts: csfRecordCrankBackPortId.setDescription("When the csfRecordCrankBackTransitType object value is 'blockedLink', this object identifies a logical port of the blocked link's preceeding node identifier. The distinguished value zero indicates that no port is specified. For all values of csfRecordCrankBackTransitType other than 'blockedLink', this object is set to zero.")
csfRecordCrankBackSucceedingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 18), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordCrankBackSucceedingNodeId.setStatus('current')
if mibBuilder.loadTexts: csfRecordCrankBackSucceedingNodeId.setDescription("This object depends on the csfRecordCrankBackTransitType object. If the csfRecordCrankBackNodeId object value is 'blockedLink' then the value of this object will identify the logical node succeeding a link at which the call/connection was blocked. This object does not have a meaning if the call is cleared without a crankback information element and thus set to null. ")
csfRecordTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 1, 1, 19), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfRecordTimeStamp.setStatus('current')
if mibBuilder.loadTexts: csfRecordTimeStamp.setDescription('The time at which this record entry was created.')
csfDtlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2), )
if mibBuilder.loadTexts: csfDtlTable.setStatus('current')
if mibBuilder.loadTexts: csfDtlTable.setDescription("The table in which the Designated Transit List (DTL)stacks (i.e., source routes) of failed calls are recorded. Each DTL identifies a source route through a single peer group. DTL's are represented as a series of logical Node IDs and logical Port IDs.")
csfDtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-ATM-SIG-DIAG-MIB", "csfFilterIndex"), (0, "CISCO-ATM-SIG-DIAG-MIB", "csfRecordIndex"), (0, "CISCO-ATM-SIG-DIAG-MIB", "csfDtlEntryIndex"))
if mibBuilder.loadTexts: csfDtlEntry.setStatus('current')
if mibBuilder.loadTexts: csfDtlEntry.setDescription('A segment of the DTL stack. The complete DTL stack is formed by traversing the rows of the table for which the csfFilterIndex and csfRecordIndex are the same. Level transitions are indicated using the csfDtlLinkType. Since the entries in the table are linked to the entries of the csfFilterTable ,the entries are added and removed from the table as and when the corresponding entries in the csfFilterTable are added and removed.')
csfDtlEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)))
if mibBuilder.loadTexts: csfDtlEntryIndex.setStatus('current')
if mibBuilder.loadTexts: csfDtlEntryIndex.setDescription('The index in the current DTL stack of this entry. This index represents the the order of this entry in the DTL stack.')
csfDtlNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2, 1, 2), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfDtlNodeId.setStatus('current')
if mibBuilder.loadTexts: csfDtlNodeId.setDescription('Each entry in the DTL table corresponds to a node/port tuple based on which a source route through the peer group is built. This object represents the node id in the tuple ')
csfDtlPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2, 1, 3), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfDtlPortId.setStatus('current')
if mibBuilder.loadTexts: csfDtlPortId.setDescription('Each entry in the DTL table corresponds to a node/port tuple based on which a source route through the peer group is built. This object represents the port id in the tuple ')
csfDtlLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 78, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("horizontal", 2), ("uplink", 3), ("last", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csfDtlLinkType.setStatus('current')
if mibBuilder.loadTexts: csfDtlLinkType.setDescription("The type of link out from the node identified by csfDtlNodeId. This is well defined even if the specific port is not specified. A value 'horizontal' indicates a normal link within the containing peer group. A value 'uplink' indicates a link going up a level. A value 'last' indicates that this is the last entry in the DTL stack. 'invalid' indicates an invalid link.")
ciscoSigFailMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 3))
ciscoSigFailMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 3, 1))
ciscoSigFailMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 78, 3, 2))
ciscoSigFailMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 78, 3, 1, 1)).setObjects(("CISCO-ATM-SIG-DIAG-MIB", "ciscoSigFailGeneralGroup"), ("CISCO-ATM-SIG-DIAG-MIB", "ciscoSigFailMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSigFailMIBCompliance = ciscoSigFailMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoSigFailMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco ATM Signalling Diagnostic MIB')
ciscoSigFailGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 78, 3, 2, 1)).setObjects(("CISCO-ATM-SIG-DIAG-MIB", "csfFilterControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSigFailGeneralGroup = ciscoSigFailGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSigFailGeneralGroup.setDescription('A collection of objects which help in diagnosing ATM signalling failures.')
ciscoSigFailMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 78, 3, 2, 2)).setObjects(("CISCO-ATM-SIG-DIAG-MIB", "csfFilterScope"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterConnKind"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterConnCastType"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterServiceCategory"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterInInterface"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterOutInterface"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterCause"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterCallingParty"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterCallingPartyMask"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterCalledParty"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterCalledPartyMask"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterMaxRecords"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterAgeTimeout"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterPurge"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterNumMatches"), ("CISCO-ATM-SIG-DIAG-MIB", "csfFilterRowStatus"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordScope"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordConnKind"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordConnCastType"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordConnIndicator"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordServiceCategory"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordInInterface"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordOutInterface"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCause"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordDiags"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCallingParty"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCallingPartySubAddress"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCalledParty"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCalledPartySubAddress"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCrankBackTransitType"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCrankBackNodeId"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCrankBackSucceedingNodeId"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordCrankBackPortId"), ("CISCO-ATM-SIG-DIAG-MIB", "csfRecordTimeStamp"), ("CISCO-ATM-SIG-DIAG-MIB", "csfDtlNodeId"), ("CISCO-ATM-SIG-DIAG-MIB", "csfDtlPortId"), ("CISCO-ATM-SIG-DIAG-MIB", "csfDtlLinkType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSigFailMIBGroup = ciscoSigFailMIBGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSigFailMIBGroup.setDescription('A collection of objects which help in diagnosing ATM signalling failures.')
mibBuilder.exportSymbols("CISCO-ATM-SIG-DIAG-MIB", AtmAddr=AtmAddr, csfRecordTable=csfRecordTable, csfRecordTimeStamp=csfRecordTimeStamp, csfRecordServiceCategory=csfRecordServiceCategory, csfRecordCrankBackPortId=csfRecordCrankBackPortId, csfDtlPortId=csfDtlPortId, csfRecordConnCastType=csfRecordConnCastType, csfFilterGroup=csfFilterGroup, csfRecordDiags=csfRecordDiags, ciscoSigFailMIBGroups=ciscoSigFailMIBGroups, csfFilterServiceCategory=csfFilterServiceCategory, csfRecordScope=csfRecordScope, ciscoSigFailGeneralGroup=ciscoSigFailGeneralGroup, csfRecordCalledPartySubAddress=csfRecordCalledPartySubAddress, csfRecordConnKind=csfRecordConnKind, csfFilterCallingPartyMask=csfFilterCallingPartyMask, csfRecordIndex=csfRecordIndex, csfFilterConnCastType=csfFilterConnCastType, csfDtlTable=csfDtlTable, csfRecordCallingParty=csfRecordCallingParty, ciscoSigFailMIBConformance=ciscoSigFailMIBConformance, csfRecordInInterface=csfRecordInInterface, csfRecordCalledParty=csfRecordCalledParty, csfRecordOutInterface=csfRecordOutInterface, csfDtlEntryIndex=csfDtlEntryIndex, csfFilterIndex=csfFilterIndex, csfFilterCause=csfFilterCause, csfFilterAgeTimeout=csfFilterAgeTimeout, csfRecordGroup=csfRecordGroup, csfFilterCallingParty=csfFilterCallingParty, csfFilterNumMatches=csfFilterNumMatches, csfRecordConnIndicator=csfRecordConnIndicator, csfRecordCause=csfRecordCause, csfFilterEntry=csfFilterEntry, csfFilterCalledParty=csfFilterCalledParty, csfFilterRowStatus=csfFilterRowStatus, csfRecordCrankBackTransitType=csfRecordCrankBackTransitType, ciscoSigFailMIBGroup=ciscoSigFailMIBGroup, ciscoSigFailMIBObjects=ciscoSigFailMIBObjects, csfFilterScope=csfFilterScope, csfFilterOutInterface=csfFilterOutInterface, csfDtlLinkType=csfDtlLinkType, ciscoSigFailMIBCompliance=ciscoSigFailMIBCompliance, csfRecordCrankBackNodeId=csfRecordCrankBackNodeId, ciscoSigFailMIBCompliances=ciscoSigFailMIBCompliances, csfFilterControl=csfFilterControl, csfFilterPurge=csfFilterPurge, csfDtlNodeId=csfDtlNodeId, csfFilterInInterface=csfFilterInInterface, csfFilterCalledPartyMask=csfFilterCalledPartyMask, PYSNMP_MODULE_ID=ciscoAtmSigDiagMIB, csfRecordCallingPartySubAddress=csfRecordCallingPartySubAddress, csfRecordEntry=csfRecordEntry, csfBaseGroup=csfBaseGroup, csfRecordCrankBackSucceedingNodeId=csfRecordCrankBackSucceedingNodeId, csfDtlEntry=csfDtlEntry, csfFilterConnKind=csfFilterConnKind, csfFilterTable=csfFilterTable, ciscoAtmSigDiagMIB=ciscoAtmSigDiagMIB, csfFilterMaxRecords=csfFilterMaxRecords)

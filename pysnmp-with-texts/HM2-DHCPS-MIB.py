#
# PySNMP MIB module HM2-DHCPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-DHCPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
HmEnabledStatus, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmEnabledStatus", "hm2ConfigurationMibs")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Bits, Unsigned32, ModuleIdentity, ObjectIdentity, Counter64, Integer32, iso, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, IpAddress, Gauge32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Bits", "Unsigned32", "ModuleIdentity", "ObjectIdentity", "Counter64", "Integer32", "iso", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "IpAddress", "Gauge32", "NotificationType")
TextualConvention, RowStatus, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "MacAddress")
hm2DhcpsMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 91))
hm2DhcpsMib.setRevisions(('2012-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2DhcpsMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2DhcpsMib.setLastUpdated('201203160000Z')
if mibBuilder.loadTexts: hm2DhcpsMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2DhcpsMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2DhcpsMib.setDescription('Hirschmann DHCP server MIB. Copyright (C) 2012. All Rights Reserved.')
hm2DHCPServerMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 0))
hm2DHCPServerMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1))
hm2DHCPServerSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 3))
hm2DHCPServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1))
hm2DHCPServerConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1))
hm2DHCPServerLeaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2))
hm2DHCPServerInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 3))
hm2DHCPServerCounterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4))
hm2DHCPServerMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DHCPServerMode.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerMode.setDescription('Enable or disable DHCP server global.')
hm2DHCPServerMaxPoolEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerMaxPoolEntries.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerMaxPoolEntries.setDescription('Maximum possible entries in hm2DHCPServerPoolTable.')
hm2DHCPServerMaxLeaseEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerMaxLeaseEntries.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerMaxLeaseEntries.setDescription('Maximum possible entries in hm2DHCPServerLeaseTable.')
hm2DHCPServerPoolTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5), )
if mibBuilder.loadTexts: hm2DHCPServerPoolTable.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolTable.setDescription('A table containing the DHCP server pools.')
hm2DHCPServerPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1), ).setIndexNames((0, "HM2-DHCPS-MIB", "hm2DHCPServerPoolIndex"))
if mibBuilder.loadTexts: hm2DHCPServerPoolEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolEntry.setDescription('A logical row in the hm2DHCPServerPoolTable.')
hm2DHCPServerPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerPoolIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolIndex.setDescription('The index of hm2DHCPServerPoolTable.')
hm2DHCPServerPoolStartIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolStartIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolStartIpAddress.setDescription('The IPv4 address of the first address in the range. The value of hm2DHCPServerPoolStartIpAddress MUST be less than or equal to the value of hm2DHCPServerPoolEndIpAddress.')
hm2DHCPServerPoolEndIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolEndIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolEndIpAddress.setDescription('The IPv4 address of the last address in the range. The value of hm2DHCPServerPoolEndIpAddress MUST be greater than or equal to the value of hm2DHCPServerPoolStartIpAddress.')
hm2DHCPServerPoolLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 4), Unsigned32().clone(86400)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolLeaseTime.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolLeaseTime.setDescription("The pools lease time in number of seconds. A value of 4294967295 SHOULD be used for leases that have a lease time which is 'infinite' and for BOOTP leases.")
hm2DHCPServerPoolFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 5), Bits().clone(namedValues=NamedValues(("interface", 0), ("mac", 1), ("gateway", 2), ("clientid", 3), ("remoteid", 4), ("circuitid", 5), ("dynamic", 6), ("vlanid", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolFlags.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolFlags.setDescription('This object shows the parameters that are used to lease the IP Address.')
hm2DHCPServerPoolIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolIfIndex.setDescription('The index of the interface.')
hm2DHCPServerPoolMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 7), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolMacAddress.setDescription('The MAC Address of the entry that is used to lease the IP Address.')
hm2DHCPServerPoolGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolGateway.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolGateway.setDescription('The IPv4 address of the Gatewayinterface that is used to lease the IP Address.')
hm2DHCPServerPoolClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 9), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolClientId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolClientId.setDescription('The Client Identifier of the entry that is used to lease the IP Address.')
hm2DHCPServerPoolRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 10), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolRemoteId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolRemoteId.setDescription('The Remote Identifier of the entry that is used to lease the IP Address. The Remote Identifier must be send in Option 82 as defined in RFC 3046.')
hm2DHCPServerPoolCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 11), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolCircuitId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolCircuitId.setDescription('The Cicuit Identifier of the entry that is used to lease the IP Address. The Circuit Identifier must be send in Option 82 as defined in RFC 3046.')
hm2DHCPServerPoolHirschmannClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 12), HmEnabledStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolHirschmannClient.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolHirschmannClient.setDescription('Enable or disable Hirschmann Multicast.')
hm2DHCPServerPoolVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolVlanId.setDescription('The Vlan ID of the entry that is used to lease the IP Address. A value of -1 corresponds to management vlan (the default), any other value (1-4042) represents a specific VLAN')
hm2DHCPServerPoolOptionConfFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionConfFileName.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionConfFileName.setDescription('Full specified name of the configuration file e.g. tftp://192.9.200.1/cfg/config1.sav. An empty string zeros the SNAME and the FILE field in the DHCP header.')
hm2DHCPServerPoolOptionGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 31), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionGateway.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionGateway.setDescription('The IPv4 address of the Gateway. A value of 0 disables the attachment of the option field in the DHCP message.')
hm2DHCPServerPoolOptionNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 32), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionNetmask.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionNetmask.setDescription('The subnet mask. A value of 0 disables the attachment of the option field in the DHCP message.')
hm2DHCPServerPoolOptionWINS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 33), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionWINS.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionWINS.setDescription('The IPv4 address of the WINS Server. A value of 0 disables the attachment of the option field in the DHCP message.')
hm2DHCPServerPoolOptionDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 34), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionDNS.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionDNS.setDescription('The IPv4 address of the DNS Server. A value of 0 disables the attachment of the option field in the DHCP message.')
hm2DHCPServerPoolOptionHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionHostname.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolOptionHostname.setDescription('The name of the client (Option 12). An empty string disables the attachment of the option field in the DHCP message.')
hm2DHCPServerPoolMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("config", 2), ("ttdp", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DHCPServerPoolMethod.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolMethod.setDescription('The source of the DHCP Server Pool. User can set the object to none(1), config(2), ttdp(3).')
hm2DHCPServerPoolErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 99), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerPoolErrorStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolErrorStatus.setDescription('The error Code by create a new Pool.')
hm2DHCPServerPoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 1, 5, 1, 100), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DHCPServerPoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerPoolRowStatus.setDescription('This object indicates the status of this entry.')
hm2DHCPServerLeaseTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1), )
if mibBuilder.loadTexts: hm2DHCPServerLeaseTable.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseTable.setDescription('A table containing the DHCP server leases.')
hm2DHCPServerLeaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1), ).setIndexNames((0, "HM2-DHCPS-MIB", "hm2DHCPServerLeasePoolIndex"), (0, "HM2-DHCPS-MIB", "hm2DHCPServerLeaseIpAddress"))
if mibBuilder.loadTexts: hm2DHCPServerLeaseEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseEntry.setDescription('A logical row in the hm2DHCPServerLeaseTable.')
hm2DHCPServerLeasePoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeasePoolIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeasePoolIndex.setDescription('The index of the hm2DHCPServerPoolTable above.')
hm2DHCPServerLeaseIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseIpAddress.setDescription('This is an IP address from the pool with index hm2DHCPServerLeasePoolIndex.')
hm2DHCPServerLeaseState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bootp", 1), ("offering", 2), ("requesting", 3), ("bound", 4), ("renewing", 5), ("rebinding", 6), ("declined", 7), ("released", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseState.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseState.setDescription('The state of the lease.')
hm2DHCPServerLeaseTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseTimeRemaining.setDescription('The remaining time of the lease configured in hm2DHCPServerPoolLeaseTime.')
hm2DHCPServerLeaseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseIfIndex.setDescription('The interface index where the lease is currently active.')
hm2DHCPServerLeaseClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseClientMacAddress.setDescription('The MAC Address of the entry that has leased the IP Address.')
hm2DHCPServerLeaseGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseGateway.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseGateway.setDescription('The IPv4 address of the Gatewayinterface that was used to lease the IP Address.')
hm2DHCPServerLeaseClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseClientId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseClientId.setDescription('The Client Identifier of the entry that was used to lease the IP Address.')
hm2DHCPServerLeaseRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseRemoteId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseRemoteId.setDescription('The Remote Identifier of the entry that was used to lease the IP Address.')
hm2DHCPServerLeaseCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseCircuitId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseCircuitId.setDescription('The Cicuit Identifier of the entry that was used to lease the IP Address.')
hm2DHCPServerLeaseStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseStartTime.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseStartTime.setDescription('Lease start Time.')
hm2DHCPServerLeaseAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("release", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DHCPServerLeaseAction.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseAction.setDescription('Manually release this ip address for new assignment.')
hm2DHCPServerLeaseVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerLeaseVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerLeaseVlanId.setDescription('The Vlan ID of the entry that is used to lease the IP Address. A value of -1 corresponds to management vlan (the default), any other value (1-4042) represents a specific VLAN')
hm2DHCPServerIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 3, 1), )
if mibBuilder.loadTexts: hm2DHCPServerIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerIfConfigTable.setDescription('A table containing current configuration information for each interface.')
hm2DHCPServerIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 3, 1, 1), ).setIndexNames((0, "HM2-DHCPS-MIB", "hm2DHCPServerIfConfigIndex"))
if mibBuilder.loadTexts: hm2DHCPServerIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerIfConfigEntry.setDescription('A logical row in the hm2DHCPServerIfConfigTable.')
hm2DHCPServerIfConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 3, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerIfConfigIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerIfConfigIndex.setDescription('The index of the interface.')
hm2DHCPServerIfConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 3, 1, 1, 2), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DHCPServerIfConfigMode.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerIfConfigMode.setDescription('Enable or disable DHCP server on this interface.')
hm2DHCPServerCounterIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2), )
if mibBuilder.loadTexts: hm2DHCPServerCounterIfTable.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterIfTable.setDescription('A table containing current configuration information for each interface.')
hm2DHCPServerCounterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1), ).setIndexNames((0, "HM2-DHCPS-MIB", "hm2DHCPServerCounterIfIndex"))
if mibBuilder.loadTexts: hm2DHCPServerCounterIfEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterIfEntry.setDescription('A logical row in the hm2DHCPServerCounterIfTable.')
hm2DHCPServerCounterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterIfIndex.setDescription('The index of the interface.')
hm2DHCPServerCounterBootpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpRequests.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpRequests.setDescription('The number of packets received that contain a Message Type of 1 (BOOTREQUEST) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
hm2DHCPServerCounterBootpInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpInvalids.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpInvalids.setDescription('The number of packets received that do not contain a Message Type of 1 (BOOTREQUEST) in the first octet or are not valid BOOTP packets (e.g., too short, invalid field in packet header).')
hm2DHCPServerCounterBootpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpReplies.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpReplies.setDescription('The number of packets sent that contain a Message Type of 2 (BOOTREPLY) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
hm2DHCPServerCounterBootpDroppedUnknownClients = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpDroppedUnknownClients.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpDroppedUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not recognizing or not providing service to the hardware address received in the incoming packet.')
hm2DHCPServerCounterBootpDroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpDroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterBootpDroppedNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
hm2DHCPServerCounterDhcpv4Discovers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Discovers.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Discovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets received.')
hm2DHCPServerCounterDhcpv4Offers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Offers.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Offers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets sent.')
hm2DHCPServerCounterDhcpv4Requests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Requests.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Requests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets received.')
hm2DHCPServerCounterDhcpv4Declines = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Declines.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Declines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets received.')
hm2DHCPServerCounterDhcpv4Acks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Acks.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Acks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
hm2DHCPServerCounterDhcpv4Naks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Naks.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Naks.setDescription('The number of DHCPNACK (option 53 with value 6) packets sent.')
hm2DHCPServerCounterDhcpv4Releases = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Releases.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Releases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets received.')
hm2DHCPServerCounterDhcpv4Informs = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Informs.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Informs.setDescription('The number of DHCPINFORM (option 53 with value 8) packets received.')
hm2DHCPServerCounterDhcpv4ForcedRenews = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4ForcedRenews.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4ForcedRenews.setDescription('The number of DHCPFORCERENEW (option 53 with value 9) packets sent.')
hm2DHCPServerCounterDhcpv4Invalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Invalids.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4Invalids.setDescription('The number of DHCP packets received whose DHCP message type (i.e., option number 53) is not understood or handled by the server.')
hm2DHCPServerCounterDhcpv4DroppedUnknownClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4DroppedUnknownClient.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4DroppedUnknownClient.setDescription('The number of DHCP packets dropped due to the server not recognizing or not providing service to the client-id and/or hardware address received in the incoming packet.')
hm2DHCPServerCounterDhcpv4DroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4DroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterDhcpv4DroppedNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
hm2DHCPServerCounterMiscOtherDhcpServer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 91, 1, 1, 4, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DHCPServerCounterMiscOtherDhcpServer.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerCounterMiscOtherDhcpServer.setDescription('The number of BOOTP and DHCP packets from another DHCP server seen on this interface.')
hm2DHCPServerRowStatusInvalidConfigurationErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 91, 3, 1))
if mibBuilder.loadTexts: hm2DHCPServerRowStatusInvalidConfigurationErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerRowStatusInvalidConfigurationErrorReturn.setDescription('DHCP Server pool with index {0} cannot be enabled, errors in data entry.')
hm2DHCPServerConflictDHCPRrelayErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 91, 3, 2))
if mibBuilder.loadTexts: hm2DHCPServerConflictDHCPRrelayErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2DHCPServerConflictDHCPRrelayErrorReturn.setDescription('{0} and {1} cannot be active at the same time.')
mibBuilder.exportSymbols("HM2-DHCPS-MIB", hm2DHCPServerPoolMacAddress=hm2DHCPServerPoolMacAddress, hm2DHCPServerLeaseAction=hm2DHCPServerLeaseAction, hm2DHCPServerIfConfigIndex=hm2DHCPServerIfConfigIndex, hm2DHCPServerMibNotifications=hm2DHCPServerMibNotifications, hm2DHCPServerConfigGroup=hm2DHCPServerConfigGroup, hm2DHCPServerCounterMiscOtherDhcpServer=hm2DHCPServerCounterMiscOtherDhcpServer, hm2DHCPServerCounterDhcpv4Discovers=hm2DHCPServerCounterDhcpv4Discovers, hm2DHCPServerLeaseStartTime=hm2DHCPServerLeaseStartTime, hm2DHCPServerPoolLeaseTime=hm2DHCPServerPoolLeaseTime, hm2DHCPServerPoolErrorStatus=hm2DHCPServerPoolErrorStatus, hm2DHCPServerCounterIfTable=hm2DHCPServerCounterIfTable, hm2DHCPServerLeaseEntry=hm2DHCPServerLeaseEntry, hm2DHCPServerCounterBootpDroppedUnknownClients=hm2DHCPServerCounterBootpDroppedUnknownClients, hm2DHCPServerPoolEntry=hm2DHCPServerPoolEntry, hm2DHCPServerIfConfigMode=hm2DHCPServerIfConfigMode, hm2DHCPServerCounterBootpReplies=hm2DHCPServerCounterBootpReplies, hm2DHCPServerLeaseGroup=hm2DHCPServerLeaseGroup, hm2DHCPServerLeaseClientId=hm2DHCPServerLeaseClientId, hm2DHCPServerCounterIfIndex=hm2DHCPServerCounterIfIndex, hm2DHCPServerCounterDhcpv4Naks=hm2DHCPServerCounterDhcpv4Naks, hm2DHCPServerPoolVlanId=hm2DHCPServerPoolVlanId, hm2DHCPServerIfConfigEntry=hm2DHCPServerIfConfigEntry, hm2DHCPServerCounterDhcpv4ForcedRenews=hm2DHCPServerCounterDhcpv4ForcedRenews, hm2DHCPServerPoolOptionWINS=hm2DHCPServerPoolOptionWINS, hm2DHCPServerInterfaceGroup=hm2DHCPServerInterfaceGroup, hm2DHCPServerPoolOptionNetmask=hm2DHCPServerPoolOptionNetmask, hm2DHCPServerCounterDhcpv4Acks=hm2DHCPServerCounterDhcpv4Acks, hm2DHCPServerCounterDhcpv4Releases=hm2DHCPServerCounterDhcpv4Releases, PYSNMP_MODULE_ID=hm2DhcpsMib, hm2DHCPServerPoolRemoteId=hm2DHCPServerPoolRemoteId, hm2DHCPServerPoolTable=hm2DHCPServerPoolTable, hm2DHCPServerSNMPExtensionGroup=hm2DHCPServerSNMPExtensionGroup, hm2DHCPServerPoolEndIpAddress=hm2DHCPServerPoolEndIpAddress, hm2DHCPServerLeaseTable=hm2DHCPServerLeaseTable, hm2DHCPServerLeaseState=hm2DHCPServerLeaseState, hm2DHCPServerMibObjects=hm2DHCPServerMibObjects, hm2DHCPServerPoolRowStatus=hm2DHCPServerPoolRowStatus, hm2DHCPServerCounterDhcpv4Declines=hm2DHCPServerCounterDhcpv4Declines, hm2DHCPServerCounterDhcpv4DroppedNotServingSubnet=hm2DHCPServerCounterDhcpv4DroppedNotServingSubnet, hm2DHCPServerLeasePoolIndex=hm2DHCPServerLeasePoolIndex, hm2DHCPServerPoolMethod=hm2DHCPServerPoolMethod, hm2DHCPServerIfConfigTable=hm2DHCPServerIfConfigTable, hm2DHCPServerCounterDhcpv4Requests=hm2DHCPServerCounterDhcpv4Requests, hm2DhcpsMib=hm2DhcpsMib, hm2DHCPServerRowStatusInvalidConfigurationErrorReturn=hm2DHCPServerRowStatusInvalidConfigurationErrorReturn, hm2DHCPServerCounterIfEntry=hm2DHCPServerCounterIfEntry, hm2DHCPServerCounterBootpDroppedNotServingSubnet=hm2DHCPServerCounterBootpDroppedNotServingSubnet, hm2DHCPServerMaxLeaseEntries=hm2DHCPServerMaxLeaseEntries, hm2DHCPServerLeaseIfIndex=hm2DHCPServerLeaseIfIndex, hm2DHCPServerPoolIndex=hm2DHCPServerPoolIndex, hm2DHCPServerCounterBootpInvalids=hm2DHCPServerCounterBootpInvalids, hm2DHCPServerPoolStartIpAddress=hm2DHCPServerPoolStartIpAddress, hm2DHCPServerPoolFlags=hm2DHCPServerPoolFlags, hm2DHCPServerCounterDhcpv4Informs=hm2DHCPServerCounterDhcpv4Informs, hm2DHCPServerGroup=hm2DHCPServerGroup, hm2DHCPServerCounterGroup=hm2DHCPServerCounterGroup, hm2DHCPServerPoolOptionGateway=hm2DHCPServerPoolOptionGateway, hm2DHCPServerLeaseGateway=hm2DHCPServerLeaseGateway, hm2DHCPServerPoolHirschmannClient=hm2DHCPServerPoolHirschmannClient, hm2DHCPServerLeaseClientMacAddress=hm2DHCPServerLeaseClientMacAddress, hm2DHCPServerCounterDhcpv4Invalids=hm2DHCPServerCounterDhcpv4Invalids, hm2DHCPServerMode=hm2DHCPServerMode, hm2DHCPServerPoolClientId=hm2DHCPServerPoolClientId, hm2DHCPServerLeaseIpAddress=hm2DHCPServerLeaseIpAddress, hm2DHCPServerCounterDhcpv4DroppedUnknownClient=hm2DHCPServerCounterDhcpv4DroppedUnknownClient, hm2DHCPServerPoolIfIndex=hm2DHCPServerPoolIfIndex, hm2DHCPServerLeaseRemoteId=hm2DHCPServerLeaseRemoteId, hm2DHCPServerConflictDHCPRrelayErrorReturn=hm2DHCPServerConflictDHCPRrelayErrorReturn, hm2DHCPServerLeaseTimeRemaining=hm2DHCPServerLeaseTimeRemaining, hm2DHCPServerPoolOptionDNS=hm2DHCPServerPoolOptionDNS, hm2DHCPServerCounterBootpRequests=hm2DHCPServerCounterBootpRequests, hm2DHCPServerLeaseVlanId=hm2DHCPServerLeaseVlanId, hm2DHCPServerPoolCircuitId=hm2DHCPServerPoolCircuitId, hm2DHCPServerPoolGateway=hm2DHCPServerPoolGateway, hm2DHCPServerPoolOptionHostname=hm2DHCPServerPoolOptionHostname, hm2DHCPServerLeaseCircuitId=hm2DHCPServerLeaseCircuitId, hm2DHCPServerCounterDhcpv4Offers=hm2DHCPServerCounterDhcpv4Offers, hm2DHCPServerMaxPoolEntries=hm2DHCPServerMaxPoolEntries, hm2DHCPServerPoolOptionConfFileName=hm2DHCPServerPoolOptionConfFileName)

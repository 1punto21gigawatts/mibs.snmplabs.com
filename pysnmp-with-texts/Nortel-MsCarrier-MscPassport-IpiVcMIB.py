#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-IpiVcMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-IpiVcMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
Integer32, RowStatus, DisplayString, StorageType, Counter32, Unsigned32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Integer32", "RowStatus", "DisplayString", "StorageType", "Counter32", "Unsigned32")
NonReplicated, DigitString, Hex, EnterpriseDateAndTime = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "NonReplicated", "DigitString", "Hex", "EnterpriseDateAndTime")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, ObjectIdentity, Counter32, TimeTicks, NotificationType, iso, Unsigned32, Counter64, ModuleIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "ObjectIdentity", "Counter32", "TimeTicks", "NotificationType", "iso", "Unsigned32", "Counter64", "ModuleIdentity", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ipiVcMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53))
mscIpivc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51))
mscIpivcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1), )
if mibBuilder.loadTexts: mscIpivcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpivc components.')
mscIpivcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"))
if mibBuilder.loadTexts: mscIpivcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivc component.')
mscIpivcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivc components. These components can be added and deleted.')
mscIpivcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcStorageType.setDescription('This variable represents the storage type value for the mscIpivc tables.')
mscIpivcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpivcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcIndex.setDescription('This variable represents the index for the mscIpivc tables.')
mscIpivcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 10), )
if mibBuilder.loadTexts: mscIpivcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcProvTable.setDescription('This group contains the provisionable attributes for the IpiVc component.')
mscIpivcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"))
if mibBuilder.loadTexts: mscIpivcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcProvEntry.setDescription('An entry in the mscIpivcProvTable.')
mscIpivcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcIpAddress.setDescription('This IP Address represents the IP address of the IP interface.')
mscIpivcMaximumNumberOfLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(24, 24)).clone(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcMaximumNumberOfLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcMaximumNumberOfLcn.setDescription('This attribute contains the maximum number of LCNs that can be setup to the IP Interface over Vc. It defines the maximum number of calls that the external network management systems can setup to IpiVc simultaneously.')
mscIpivcDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2))
mscIpivcDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1), )
if mibBuilder.loadTexts: mscIpivcDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpivcDna components.')
mscIpivcDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"))
if mibBuilder.loadTexts: mscIpivcDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivcDna component.')
mscIpivcDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivcDna components. These components cannot be added nor deleted.')
mscIpivcDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaStorageType.setDescription('This variable represents the storage type value for the mscIpivcDna tables.')
mscIpivcDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpivcDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIndex.setDescription('This variable represents the index for the mscIpivcDna tables.')
mscIpivcDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 10), )
if mibBuilder.loadTexts: mscIpivcDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaAddressTable.setDescription("DnaAddress group contains attributes common to all Dna's. Every Dna used in the network is defined with this group 0f 2 attributes. String of address digits is complemented by type of address and Npi. These attributes are used to interpret format of the address digits.")
mscIpivcDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"))
if mibBuilder.loadTexts: mscIpivcDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaAddressEntry.setDescription('An entry in the mscIpivcDnaAddressTable.')
mscIpivcDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet svitched data networks.')
mscIpivcDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDataNetworkAddress.setDescription('Dna attribute contains digits which form unique identifier of the customer. It is the equivalent of the telephone number in the telephone network. MaximumLenOfDna is 15digits.')
mscIpivcDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11), )
if mibBuilder.loadTexts: mscIpivcDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaOutgoingOptionsTable.setDescription('DnaOutOptionsProv group defines call options of a Dna for calls which are made out of the interface represented by Dna. All these options are not used for calls arriving to the interface represented by Dna.')
mscIpivcDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"))
if mibBuilder.loadTexts: mscIpivcDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaOutgoingOptionsEntry.setDescription('An entry in the mscIpivcDnaOutgoingOptionsTable.')
mscIpivcDnaOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaOutCalls.setDescription("This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) can be made using this particular DNA. If set to a value of disallowed, then outgoing calls cannot be made using this DNA - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for DNAs in that outgoing calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this DNA to be useable.")
mscIpivcDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('throughput')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaOutDefaultPathSensitivity.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpivcDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of path sensitivity to network for all outgoing calls using this particular Dna. The chosen default class of path sensitivity applies to all outgoing calls established using this Dna. This attribute, if set to a value of throughput, indicates that the default class is throughput sensitive. If set to a value of delay, then the default class is delay sensitive. The default of outDefaultPathSensitivity is throughput.')
mscIpivcDnaOutPathSensitivityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaOutPathSensitivityOverRide.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpivcDnaOutPathSensitivityOverRide.setDescription('If this attribute is set to in the call request, the called end will use the calling end provisioning data on path sensitivity to override its own provisioning data. The default of outPathSensitivityOverRide is no.')
mscIpivcDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It is overRidden by the transferPriority provisioned in the DLCI Direct Call sub- component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of defaultTransferPriority is normal.')
mscIpivcDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. For more information about transfer priority, please refer to the previous attribute defaultTransferPriority. The default of transferPriorityOverRide is no.')
mscIpivcDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12), )
if mibBuilder.loadTexts: mscIpivcDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncomingOptionsTable.setDescription('DnaIncOptions defines set of options for incoming calls. These options are used for calls arriving to the interface represented by Dna. For calls originated from the interfasce, IncomingOptions attributes are not used.')
mscIpivcDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"))
if mibBuilder.loadTexts: mscIpivcDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncomingOptionsEntry.setDescription('An entry in the mscIpivcDnaIncomingOptionsTable.')
mscIpivcDnaIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then incoming calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for DNAs in that incoming calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this DNA to be useable.")
mscIpivcDnaIncHighPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncHighPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncHighPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming high priority, reverse charged calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute, together with the incNormalPriorityReverseChargeCalls attribute corresponds to the CCITT 'Reverse Charging Acceptance' feature for DNAs in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscIpivcDnaIncNormalPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncNormalPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncNormalPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming normal priority, reverse charged calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute, together with the incHighPriorityReverseChargeCalls attribute corresponds to the CCITT 'Reverse Charging Acceptance' feature for DNAs in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscIpivcDnaIncIntlNormalCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncIntlNormalCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncIntlNormalCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international normal charged calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) are allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscIpivcDnaIncIntlReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncIntlReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncIntlReverseCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international reverse charged calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) are allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscIpivcDnaIncFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncFastSelect.setDescription("This attribute specifies whether fast select calls may be received. This attribute, if set to a value of allowed indicates that incoming fast select calls (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Fast Select Acceptance' feature for DNAs in that incoming fast select calls are accepted if this attribute is set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscIpivcDnaIncSameService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncSameService.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncSameService.setDescription('This attribute, if set to a value of allowed indicates that incoming calls from the same service type (eg: X.25, ITI, SNA) (from the network to the DTE) can be made to this DNA. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscIpivcDnaIncChargeTransfer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncChargeTransfer.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncChargeTransfer.setDescription('This attribute, if set to a value of yes indicates that the charges for incoming normal charged calls from a DTE with the same NIC (calls from the network to the DTE) will be transferred to the called DTE. If set to a value of no, then charges will not be transferred. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscIpivcDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTEs that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this DNA - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Incoming Access' feature for DNAs in that incoming access is granted if this attribute is set to a value of allowed.")
mscIpivcDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13), )
if mibBuilder.loadTexts: mscIpivcDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCallOptionsTable.setDescription('DnaCallOptions group defines additional options for calls not related directly to direction of a call.')
mscIpivcDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"))
if mibBuilder.loadTexts: mscIpivcDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCallOptionsEntry.setDescription('An entry in the mscIpivcDnaCallOptionsTable.')
mscIpivcDnaServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31))).clone(namedValues=NamedValues(("gsp", 0), ("x25", 1), ("enhancedIti", 2), ("ncs", 3), ("mlti", 4), ("sm", 5), ("ici", 6), ("dsp3270", 7), ("iam", 8), ("mlhi", 9), ("term3270", 10), ("iti", 11), ("bsi", 13), ("hostIti", 14), ("x75", 15), ("hdsp3270", 16), ("api3201", 20), ("sdlc", 21), ("snaMultiHost", 22), ("redirectionServ", 23), ("trSnaTpad", 24), ("offnetNui", 25), ("gasServer", 26), ("vapServer", 28), ("vapAgent", 29), ("frameRelay", 30), ("ipiVc", 31))).clone('ipiVc')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaServiceCategory.setDescription('This attribute is computed based on the type of service within which this DNA is configured. It is placed into the Service Category attributes in the accounting record by both ends of the VC.')
mscIpivcDnaPacketSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0100")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaPacketSizes.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaPacketSizes.setDescription("This attribute indicates the allowable packet sizes supported for calls setup using this DNA. To set a given packet size to be allowed on the DNA, the packet size is entered, and the corresponding bit in the structure is set to a value of 1. To set a given packet size to be disallowed on the DNA, the packet size is entered preceeded with the '~' character, and the corresponding bit in the structure is set to a value of 0. CCITT recommends that packet size 128 always be supported. Description of bits: n16(0) n32(1) n64(2) n128(3) n256(4) n512(5) n1024(6) n2048(7) n4096(8)")
mscIpivcDnaDefaultRecvFrmNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n2048')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkPacketSize.setDescription('This attribute indicates the default local receive packet size from network to DTE for all calls using this particular DNA.')
mscIpivcDnaDefaultSendToNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n2048')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkPacketSize.setDescription('This attribute indicates the default local send packet size from DTE to network for all calls using this particular DNA.')
mscIpivcDnaDefaultRecvFrmNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkThruputClass.setDescription('This attribute indicates the default receive throughput class for all calls using this particular DNA.')
mscIpivcDnaDefaultSendToNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkThruputClass.setDescription('This attribute indicates the default send throughput class for all calls using this particular DNA.')
mscIpivcDnaDefaultRecvFrmNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultRecvFrmNetworkWindowSize.setDescription('This attribute indicates the default number of data packets that can be received by the DTE from the DCE before more packets can be received. This view is oriented with respect to the DTE.')
mscIpivcDnaDefaultSendToNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaDefaultSendToNetworkWindowSize.setDescription('This attribute indicates the number of data packets that can be transmitted from the DTE to the DCE and must be acknowledged before more packets can be transmitted.')
mscIpivcDnaPacketSizeNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("endToEnd", 0), ("local", 1))).clone('local')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaPacketSizeNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaPacketSizeNegotiation.setDescription('This attribute, if set to a value of local indicates that packet sizes can be negotiated locally at the interface irrespective of the remote interface. If set to a value of endtoEnd, then local negotiation is not permitted and packet sizes are negotiated between 2 ends of Vc.')
mscIpivcDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator. This attribute is returned by the local VC in the accounting record for all calls setup using this particular DNA.')
mscIpivcDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaServiceExchange.setDescription('This attribute is an arbitrary number, Data Service Exchange, as entered by the network operator and reported in accounting record. It is converted into an internal 8-bit integer value for use in the accounting record as well as in various X.25 and X.75 Tariff utilities.')
mscIpivcDnaCugFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("basic", 0), ("extended", 1))).clone('basic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugFormat.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugFormat.setDescription('This attribute specifies which cug format is used when DTE signals CUG indices, basic or extended. This attribute, if set to a value of extended indicates that the DTE signals and receives CUG indices in extended CUG format. If set to a value of basic, then the DTE signals and receives CUG indices in the basic CUG format.')
mscIpivcDnaCug0AsNonCugCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCug0AsNonCugCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCug0AsNonCugCall.setDescription('This attribute, if set to a value of allowed indicates that when a CUG index of 0 is signalled in a call request packet, the call is treated as a non-CUG call. If this attribute is set to a value of disallowed, then a CUG index of 0 is treated as an index, and an attempt is made to find the particular CUG corresponding with the DNA.')
mscIpivcDnaFastSelectCallsOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 13, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaFastSelectCallsOnly.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaFastSelectCallsOnly.setDescription('This attribute, if set to a value of yes, indicates that the service is permitted restricted fast select calls only in both the incoming and the outgoing directions using this DNA. If set to a value of no, then non fast select calls are permitted as well.')
mscIpivcDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2))
mscIpivcDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1), )
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpivcDnaCug components.')
mscIpivcDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaCugIndex"))
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivcDnaCug component.')
mscIpivcDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivcDnaCug components. These components cannot be added nor deleted.')
mscIpivcDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugStorageType.setDescription('This variable represents the storage type value for the mscIpivcDnaCug tables.')
mscIpivcDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpivcDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugIndex.setDescription('This variable represents the index for the mscIpivcDnaCug tables.')
mscIpivcDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10), )
if mibBuilder.loadTexts: mscIpivcDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugCugOptionsTable.setDescription("This group defines options for Dna closed user group. Attributes in this group define options associated with interlockCode. Dna's with the same Cug (interlockCode) can make calls within this group. Various combinations which permit or prevent calls in the same Cug group are defined here.")
mscIpivcDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDnaCugIndex"))
if mibBuilder.loadTexts: mscIpivcDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugCugOptionsEntry.setDescription('An entry in the mscIpivcDnaCugCugOptionsTable.')
mscIpivcDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugType.setDescription('This attribute specifies the CUG type - the CUG is either a national CUG, or an international CUG. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National CUGs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the CUG is a national CUG, in which case, the DNIC should be left at its default value of BCD.0000 since it is not part of a national CUG. If this attribute is set to international, then the CUG is an international CUG, in which case, the DNIC should be set appropriately as part of the CUG interlock code.')
mscIpivcDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugDnic.setDescription('This attribute specifies the DNIC (Data Network ID Code) of the Cug by which packet networks are identified if the Cug is an International Cug - it is specified as 4 BCD digits. This attribute is not applicable if the Cug is a National Cug, as specified by the Cug TYPE attribute. There are usually 1 or 2 DNICs assigned per country, for public networks. The U.S. is an exception where each BOC has a DNIC. Also, a group of private networks can have its own DNIC. DNIC value is not an arbitrary number. It is assigned by international aggreement and controlled by CCITT.')
mscIpivcDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugInterlockCode.setDescription("This attribute specifies the Cug Identifier of a national or international Cug call. It is an arbitrary number and it also can be called Cug in some descriptions. Interfaces (Dna's) defined with this number can make calls to Dna's with the same interlockCode.")
mscIpivcDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugOutCalls.setDescription("This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE into the network) can be made using this particular CUG. If set to a value of disallowed, then outgoing calls cannot be made using this CUG - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for CUGs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
mscIpivcDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) can be made using this particular CUG. If set to a value of disallowed, then incoming calls cannot be made using this CUG - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for CUGs in that incoming calls are barred if this attribute is set to a value of disallowed.")
mscIpivcDnaCugPrivileged = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 2, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDnaCugPrivileged.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDnaCugPrivileged.setDescription('This attribute, if set to a value of yes indicates that this CUG is a privileged CUG. In DPN, at least one side of a call setup within a CUG must have the CUG as a privileged CUG. If set to a value of no, then the CUG is not privileged. If both the local DTE and the remote DTE subscribe to the CUG, but it is not privileged, then the call will be cleared. This attribute is typically used for a host DTE which must accept calls from many other DTEs in which case the other DTEs cannot call one another, but can call the host. In this example, the host would have the privileged CUG, and the other DTEs would belong to the same CUG, but it would not be privileged.')
mscIpivcDr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3))
mscIpivcDrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1), )
if mibBuilder.loadTexts: mscIpivcDrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpivcDr components.')
mscIpivcDrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDrIndex"))
if mibBuilder.loadTexts: mscIpivcDrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivcDr component.')
mscIpivcDrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivcDr components. These components can be added and deleted.')
mscIpivcDrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcDrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcDrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrStorageType.setDescription('This variable represents the storage type value for the mscIpivcDr tables.')
mscIpivcDrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpivcDrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrIndex.setDescription('This variable represents the index for the mscIpivcDr tables.')
mscIpivcDrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 10), )
if mibBuilder.loadTexts: mscIpivcDrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrProvTable.setDescription('This group contains the provisionable attributes for setting up a default route on the IpiVc service.')
mscIpivcDrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcDrIndex"))
if mibBuilder.loadTexts: mscIpivcDrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrProvEntry.setDescription('An entry in the mscIpivcDrProvTable.')
mscIpivcDrCallingIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDrCallingIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrCallingIpAddress.setDescription('The field specifies the IP Address of the remote end, which issues the X.25 call.')
mscIpivcDrCallingNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDrCallingNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrCallingNumberingPlanIndicator.setDescription('This field specifies the numbering plan of the address.')
mscIpivcDrCallingDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 3, 10, 1, 3), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpivcDrCallingDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcDrCallingDataNetworkAddress.setDescription('This field specifies the address (in Binary Coded Decimal BCD format) assigned to the remote end.')
mscIpivcLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4))
mscIpivcLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1), )
if mibBuilder.loadTexts: mscIpivcLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscIpivcLcn components.')
mscIpivcLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"))
if mibBuilder.loadTexts: mscIpivcLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivcLcn component.')
mscIpivcLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivcLcn components. These components cannot be added nor deleted.')
mscIpivcLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnStorageType.setDescription('This variable represents the storage type value for the mscIpivcLcn tables.')
mscIpivcLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 39)))
if mibBuilder.loadTexts: mscIpivcLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnIndex.setDescription('This variable represents the index for the mscIpivcLcn tables.')
mscIpivcLcnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10), )
if mibBuilder.loadTexts: mscIpivcLcnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscIpivcLcnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"))
if mibBuilder.loadTexts: mscIpivcLcnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnStateEntry.setDescription('An entry in the mscIpivcLcnStateTable.')
mscIpivcLcnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpivcLcnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpivcLcnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpivcLcnAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscIpivcLcnProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscIpivcLcnControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscIpivcLcnAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscIpivcLcnStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscIpivcLcnUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscIpivcLcnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11), )
if mibBuilder.loadTexts: mscIpivcLcnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains status of the internal IP network interface.')
mscIpivcLcnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"))
if mibBuilder.loadTexts: mscIpivcLcnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnOperEntry.setDescription('An entry in the mscIpivcLcnOperTable.')
mscIpivcLcnIpInterfaceDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnIpInterfaceDevice.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnIpInterfaceDevice.setDescription('The status of the internal IP network interface is inactive until an IP packet is exchanged between a Network Management Station and the internal IP network interface (via the LCN). At this point, the status changes to active.')
mscIpivcLcnDestinationIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnDestinationIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnDestinationIpAddress.setDescription('This attribute specifies the IP address of the remote network device connected to this interface. The destinationIpAddress default is 0.0.0.0, until the first data packet is received from the remote end.')
mscIpivcLcnPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnPacketsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnPacketsSent.setDescription('This attribute counts the number of IP packets sent from this interface.')
mscIpivcLcnPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnPacketsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnPacketsReceived.setDescription('This attribute counts the number of IP packets received from the remote network device.')
mscIpivcLcnDiscardTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnDiscardTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnDiscardTxPackets.setDescription('This attribute counts the number of IP packets destined to the remote end which were discarded by the interface.')
mscIpivcLcnDiscardRcvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnDiscardRcvPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnDiscardRcvPackets.setDescription('This attribute counts number of IP packets received from the remote end which were discarded by this interface.')
mscIpivcLcnVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2))
mscIpivcLcnVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1), )
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscIpivcLcnVc components.')
mscIpivcLcnVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnVcIndex"))
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatusEntry.setDescription('A single entry in the table represents a single mscIpivcLcnVc component.')
mscIpivcLcnVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpivcLcnVc components. These components cannot be added nor deleted.')
mscIpivcLcnVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpivcLcnVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcStorageType.setDescription('This variable represents the storage type value for the mscIpivcLcnVc tables.')
mscIpivcLcnVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpivcLcnVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcIndex.setDescription('This variable represents the index for the mscIpivcLcnVc tables.')
mscIpivcLcnVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10), )
if mibBuilder.loadTexts: mscIpivcLcnVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCadTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group represents operational call data related to General Vc. It can be displayed only for General Vc which is created by application.')
mscIpivcLcnVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnVcIndex"))
if mibBuilder.loadTexts: mscIpivcLcnVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCadEntry.setDescription('An entry in the mscIpivcLcnVcCadTable.')
mscIpivcLcnVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcType.setDescription('This attribute displays the type of call, pvc or svc. type is provided at provisioning time.')
mscIpivcLcnVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscIpivcLcnVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscIpivcLcnVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscIpivcLcnVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscIpivcLcnVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscIpivcLcnVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscIpivcLcnVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscIpivcLcnVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscIpivcLcnVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscIpivcLcnVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscIpivcLcnVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscIpivcLcnVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscIpivcLcnVcLocalRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcLocalRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcLocalRxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
mscIpivcLcnVcLocalTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcLocalTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcLocalTxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
mscIpivcLcnVcLocalTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcLocalTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcLocalTxWindowSize.setDescription('This attribute displays the send window size provided on incoming call packets or the default when a call request packet does not explicitly provide the window size.')
mscIpivcLcnVcLocalRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcLocalRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcLocalRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets or the default when a call request does not explicitly provide the window sizes.')
mscIpivcLcnVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPathReliability.setDescription('This attribute displays the path reliability.')
mscIpivcLcnVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscIpivcLcnVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscIpivcLcnVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscIpivcLcnVcSubnetTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetTxPktSize.setDescription('This attribute displays the locally negotiated size of the data packets on this Vc.')
mscIpivcLcnVcSubnetTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetTxWindowSize.setDescription('This attribute displays the current send window size of Vc.')
mscIpivcLcnVcSubnetRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRxPktSize.setDescription('This attribute displays the locally negotiated size of receive packets.')
mscIpivcLcnVcSubnetRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets and to the default when a call request does not explicitly provide the window sizes.')
mscIpivcLcnVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcMaxSubnetPktSize.setDescription('This attribute displays the maximum packet size allowed on Vc.')
mscIpivcLcnVcTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcTransferPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcTransferPriorityToNetwork.setDescription('This attribute displays the priority in which data is transferred to the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput.')
mscIpivcLcnVcTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcTransferPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcTransferPriorityFromNetwork.setDescription('This attribute displays the priority in which data is transferred from the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, and the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, and the routing metric is set to throughput.')
mscIpivcLcnVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11), )
if mibBuilder.loadTexts: mscIpivcLcnVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcIntdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscIpivcLcnVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnVcIndex"))
if mibBuilder.loadTexts: mscIpivcLcnVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcIntdEntry.setDescription('An entry in the mscIpivcLcnVcIntdTable.')
mscIpivcLcnVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpivcLcnVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscIpivcLcnVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscIpivcLcnVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscIpivcLcnVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscIpivcLcnVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscIpivcLcnVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscIpivcLcnVcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12), )
if mibBuilder.loadTexts: mscIpivcLcnVcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** ... Statistics(Stats) This group defines general attributes collected by general Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods.')
mscIpivcLcnVcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiVcMIB", "mscIpivcLcnVcIndex"))
if mibBuilder.loadTexts: mscIpivcLcnVcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcStatsEntry.setDescription('An entry in the mscIpivcLcnVcStatsTable.')
mscIpivcLcnVcAckStackingTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcAckStackingTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcAckStackingTimeouts.setDescription('This attribute counts the number of ack stacking timer expiries. It is used as an indicator of the acknowledgment behavior across the subnet when ack stacking is in effect. If it expires often, usually this means end users will experience longer delay. The ack stacking timer specifies how long the Vc will wait before finally sending the subnet acknowledgment. if this attribute is set to a value of 0, then the Vc will automatically return acknowledgment packets without delay. If this attribute is set to a value other than zero, then the Vc will wait for this amount of time in an attempt to piggyback the acknowledgment packet on another credit or data packet. If the Vc cannot piggyback the acknowledgment packet within this time, then the packet is returned without piggybacking.')
mscIpivcLcnVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcOutOfRangeFrmFromSubnet.setDescription('This attribute counts the number of subnet frames discarded due to the sequence number being out of range. Two Categories apply for the General Vc 1) lost Acks (previous Range) 2) unexpected Packets (next Range) Vc internally maintains its own sequence number of packet order and sequencing. Due to packet retransmission, Vc may receive duplicate packets that have the same Vc internal sequence number. Only 1 copy is accepted by the Vc and other copies of the same packets are detected through this count. This attribute can be used to record the frequency of packet retransmission due to Vc and other part of the subnet.')
mscIpivcLcnVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcDuplicatesFromSubnet.setDescription('This attribute counts the number of subnet packets discarded due to duplication. It is used to detect software error fault or duplication caused by retransmitting.')
mscIpivcLcnVcFrmRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcFrmRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcFrmRetryTimeouts.setDescription('This attribute counts the number of frames which have retransmission time-out. If packets from Vc into the subnet are discarded by the subnet, the source Vc will not receive any acknowledgment. The retransmission timer then expires and packets will be retransmitted again. Note that the Vc idle probe may be retransmitted and is included in this count. This statistics does not show the distribution of how many times packets are retransmitted (e.g. first retransmission results in successful packet forwarding).')
mscIpivcLcnVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPeakRetryQueueSize.setDescription('This attribute indicates the peak size of the retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest body of unacknowledged packets.')
mscIpivcLcnVcPeakOoSeqQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPeakOoSeqQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPeakOoSeqQueueSize.setDescription('This attribute indicates the peak size of the out of sequence queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets.')
mscIpivcLcnVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPeakOoSeqFrmForwarded.setDescription('This attribute indicates the peak size of the sequence packet queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets, which by the receipt of an expected packet have been transformed to expected packets. The number of times this peak is reached is not recorded as it is traffic dependent.')
mscIpivcLcnVcPeakStackedAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcPeakStackedAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcPeakStackedAcksRx.setDescription('This attribute indicates the peak size of wait acks. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest collective acknowledgment.')
mscIpivcLcnVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcSubnetRecoveries.setDescription('This attribute counts the number of successful Vc recovery attempts. This attribute is used as an indicator of how many times the Vc path is broken but can be recovered. This attribute is useful to record the number of network path failures.')
mscIpivcLcnVcWindowClosuresToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcWindowClosuresToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcWindowClosuresToSubnet.setDescription('This attribute counts the number of window closures to subnet. A packet may have been sent into the subnet but its acknowledgment from the remote Vc has not yet been received. This is a 8 bit sequence number.This number is useful in detecting whether the Vc is sending any packet into the subnet.')
mscIpivcLcnVcWindowClosuresFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcWindowClosuresFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcWindowClosuresFromSubnet.setDescription('This attribute counts the number of window closures from subnet. This attribute is useful in detecting whether the Vc is receiving any packet from the subnet.')
mscIpivcLcnVcWrTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 51, 4, 2, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpivcLcnVcWrTriggers.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpivcLcnVcWrTriggers.setDescription('This attribute displays the number of times the Vc stays within the W-R region. The W-R region is a value used to determined the timing of credit transmission. Should the current window size be beneath this value, the credits will be transmitted immediately. Otherwise, they will be transmitted later with actual data. The wrTriggers statistic is therefore used to analyze the flow control and credit mechanism.')
ipiVcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 1))
ipiVcGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 1, 1))
ipiVcGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 1, 1, 3))
ipiVcGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 1, 1, 3, 2))
ipiVcCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 3))
ipiVcCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 3, 1))
ipiVcCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 3, 1, 3))
ipiVcCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 53, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpiVcMIB", mscIpivcLcnVcPeakOoSeqFrmForwarded=mscIpivcLcnVcPeakOoSeqFrmForwarded, mscIpivcLcnRowStatus=mscIpivcLcnRowStatus, mscIpivcLcnAvailabilityStatus=mscIpivcLcnAvailabilityStatus, mscIpivcLcnVcElapsedTimeTillNow=mscIpivcLcnVcElapsedTimeTillNow, mscIpivcLcnPacketsSent=mscIpivcLcnPacketsSent, mscIpivcLcnVcAckStackingTimeouts=mscIpivcLcnVcAckStackingTimeouts, mscIpivcLcnRowStatusEntry=mscIpivcLcnRowStatusEntry, mscIpivc=mscIpivc, mscIpivcDnaAddressTable=mscIpivcDnaAddressTable, mscIpivcLcnAlarmStatus=mscIpivcLcnAlarmStatus, mscIpivcDnaCugType=mscIpivcDnaCugType, mscIpivcDnaIncSameService=mscIpivcDnaIncSameService, mscIpivcLcnStateTable=mscIpivcLcnStateTable, mscIpivcLcnVcPreviousDiagnosticCode=mscIpivcLcnVcPreviousDiagnosticCode, ipiVcCapabilitiesCA02A=ipiVcCapabilitiesCA02A, mscIpivcLcnIpInterfaceDevice=mscIpivcLcnIpInterfaceDevice, mscIpivcRowStatusEntry=mscIpivcRowStatusEntry, mscIpivcDnaComponentName=mscIpivcDnaComponentName, mscIpivcDrRowStatusTable=mscIpivcDrRowStatusTable, mscIpivcDrCallingDataNetworkAddress=mscIpivcDrCallingDataNetworkAddress, mscIpivcLcnVcOutOfRangeFrmFromSubnet=mscIpivcLcnVcOutOfRangeFrmFromSubnet, mscIpivcLcnVcTransferPriorityFromNetwork=mscIpivcLcnVcTransferPriorityFromNetwork, mscIpivcLcnVcCalledLcn=mscIpivcLcnVcCalledLcn, mscIpivcDnaStorageType=mscIpivcDnaStorageType, mscIpivcDnaTransferPriorityOverRide=mscIpivcDnaTransferPriorityOverRide, mscIpivcLcnVcLocalTxPktSize=mscIpivcLcnVcLocalTxPktSize, mscIpivcDrProvEntry=mscIpivcDrProvEntry, mscIpivcLcnVcCallingNpi=mscIpivcLcnVcCallingNpi, mscIpivcLcnVcComponentName=mscIpivcLcnVcComponentName, mscIpivcDnaDefaultRecvFrmNetworkPacketSize=mscIpivcDnaDefaultRecvFrmNetworkPacketSize, mscIpivcDnaOutgoingOptionsEntry=mscIpivcDnaOutgoingOptionsEntry, mscIpivcLcnVcLocalRxPktSize=mscIpivcLcnVcLocalRxPktSize, mscIpivcLcnUsageState=mscIpivcLcnUsageState, mscIpivcRowStatusTable=mscIpivcRowStatusTable, mscIpivcDnaDefaultTransferPriority=mscIpivcDnaDefaultTransferPriority, mscIpivcLcnVcCallReferenceNumber=mscIpivcLcnVcCallReferenceNumber, ipiVcGroup=ipiVcGroup, mscIpivcDnaPacketSizes=mscIpivcDnaPacketSizes, mscIpivcDnaAddressEntry=mscIpivcDnaAddressEntry, mscIpivcLcnVcAccountingEnabled=mscIpivcLcnVcAccountingEnabled, mscIpivcProvEntry=mscIpivcProvEntry, mscIpivcDnaAccountClass=mscIpivcDnaAccountClass, mscIpivcDnaCugStorageType=mscIpivcDnaCugStorageType, mscIpivcDnaCugCugOptionsEntry=mscIpivcDnaCugCugOptionsEntry, mscIpivcDrCallingNumberingPlanIndicator=mscIpivcDrCallingNumberingPlanIndicator, ipiVcMIB=ipiVcMIB, mscIpivcLcnVcRowStatus=mscIpivcLcnVcRowStatus, mscIpivcDna=mscIpivcDna, mscIpivcDnaIncIntlReverseCharge=mscIpivcDnaIncIntlReverseCharge, mscIpivcDnaCugComponentName=mscIpivcDnaCugComponentName, mscIpivcDnaPacketSizeNegotiation=mscIpivcDnaPacketSizeNegotiation, mscIpivcDnaIncNormalPriorityReverseCharge=mscIpivcDnaIncNormalPriorityReverseCharge, mscIpivcDnaIncFastSelect=mscIpivcDnaIncFastSelect, mscIpivcLcnControlStatus=mscIpivcLcnControlStatus, mscIpivcDnaRowStatusEntry=mscIpivcDnaRowStatusEntry, mscIpivcDnaIncIntlNormalCharge=mscIpivcDnaIncIntlNormalCharge, mscIpivcDrProvTable=mscIpivcDrProvTable, mscIpivcLcnVcIntdEntry=mscIpivcLcnVcIntdEntry, mscIpivcLcnVcPeakStackedAcksRx=mscIpivcLcnVcPeakStackedAcksRx, mscIpivcLcnComponentName=mscIpivcLcnComponentName, mscIpivcStorageType=mscIpivcStorageType, mscIpivcDnaDefaultSendToNetworkThruputClass=mscIpivcDnaDefaultSendToNetworkThruputClass, mscIpivcDnaFastSelectCallsOnly=mscIpivcDnaFastSelectCallsOnly, mscIpivcLcnDiscardTxPackets=mscIpivcLcnDiscardTxPackets, mscIpivcLcnVcDiagnosticCode=mscIpivcLcnVcDiagnosticCode, mscIpivcLcnVcMaxSubnetPktSize=mscIpivcLcnVcMaxSubnetPktSize, mscIpivcDnaCugRowStatusTable=mscIpivcDnaCugRowStatusTable, ipiVcCapabilitiesCA02=ipiVcCapabilitiesCA02, mscIpivcLcnVcDuplicatesFromSubnet=mscIpivcLcnVcDuplicatesFromSubnet, mscIpivcLcnVcFastSelectCall=mscIpivcLcnVcFastSelectCall, mscIpivcLcnVcSubnetRxPktSize=mscIpivcLcnVcSubnetRxPktSize, mscIpivcDnaServiceExchange=mscIpivcDnaServiceExchange, mscIpivcLcnVcPeakOoSeqQueueSize=mscIpivcLcnVcPeakOoSeqQueueSize, ipiVcCapabilitiesCA=ipiVcCapabilitiesCA, mscIpivcDnaIncCalls=mscIpivcDnaIncCalls, ipiVcCapabilities=ipiVcCapabilities, mscIpivcDnaDefaultRecvFrmNetworkWindowSize=mscIpivcDnaDefaultRecvFrmNetworkWindowSize, ipiVcGroupCA=ipiVcGroupCA, mscIpivcLcnVcSubnetRecoveries=mscIpivcLcnVcSubnetRecoveries, ipiVcGroupCA02A=ipiVcGroupCA02A, mscIpivcLcnStateEntry=mscIpivcLcnStateEntry, mscIpivcDnaDefaultRecvFrmNetworkThruputClass=mscIpivcDnaDefaultRecvFrmNetworkThruputClass, mscIpivcLcnDiscardRcvPackets=mscIpivcLcnDiscardRcvPackets, mscIpivcDnaCallOptionsEntry=mscIpivcDnaCallOptionsEntry, mscIpivcLcnVcWindowClosuresFromSubnet=mscIpivcLcnVcWindowClosuresFromSubnet, mscIpivcDrCallingIpAddress=mscIpivcDrCallingIpAddress, mscIpivcDnaIncAccess=mscIpivcDnaIncAccess, ipiVcGroupCA02=ipiVcGroupCA02, mscIpivcLcnVcStatsEntry=mscIpivcLcnVcStatsEntry, mscIpivcDr=mscIpivcDr, mscIpivcLcnUnknownStatus=mscIpivcLcnUnknownStatus, mscIpivcLcnVcPathReliability=mscIpivcLcnVcPathReliability, mscIpivcLcnVcLocalTxWindowSize=mscIpivcLcnVcLocalTxWindowSize, mscIpivcIndex=mscIpivcIndex, mscIpivcDnaCallOptionsTable=mscIpivcDnaCallOptionsTable, mscIpivcLcnVcCadTable=mscIpivcLcnVcCadTable, mscIpivcDnaOutgoingOptionsTable=mscIpivcDnaOutgoingOptionsTable, mscIpivcDrComponentName=mscIpivcDrComponentName, mscIpivcLcnVcLocalRxWindowSize=mscIpivcLcnVcLocalRxWindowSize, mscIpivcDnaCugIncCalls=mscIpivcDnaCugIncCalls, mscIpivcDnaIncChargeTransfer=mscIpivcDnaIncChargeTransfer, mscIpivcLcnVcCalledNpi=mscIpivcLcnVcCalledNpi, mscIpivcLcnVcPeakRetryQueueSize=mscIpivcLcnVcPeakRetryQueueSize, mscIpivcDrIndex=mscIpivcDrIndex, mscIpivcLcnVcWrTriggers=mscIpivcLcnVcWrTriggers, mscIpivcDnaCugInterlockCode=mscIpivcDnaCugInterlockCode, mscIpivcDnaDefaultSendToNetworkPacketSize=mscIpivcDnaDefaultSendToNetworkPacketSize, mscIpivcDnaOutPathSensitivityOverRide=mscIpivcDnaOutPathSensitivityOverRide, mscIpivcLcnOperationalState=mscIpivcLcnOperationalState, mscIpivcComponentName=mscIpivcComponentName, mscIpivcLcn=mscIpivcLcn, mscIpivcLcnVcSegmentsRx=mscIpivcLcnVcSegmentsRx, mscIpivcDnaCugDnic=mscIpivcDnaCugDnic, mscIpivcDnaOutDefaultPathSensitivity=mscIpivcDnaOutDefaultPathSensitivity, mscIpivcRowStatus=mscIpivcRowStatus, mscIpivcDnaCug0AsNonCugCall=mscIpivcDnaCug0AsNonCugCall, mscIpivcDnaCugCugOptionsTable=mscIpivcDnaCugCugOptionsTable, mscIpivcLcnVcAccountingEnd=mscIpivcLcnVcAccountingEnd, mscIpivcDnaIncHighPriorityReverseCharge=mscIpivcDnaIncHighPriorityReverseCharge, mscIpivcDnaOutCalls=mscIpivcDnaOutCalls, mscIpivcDnaCugRowStatus=mscIpivcDnaCugRowStatus, mscIpivcLcnVcSubnetTxPktSize=mscIpivcLcnVcSubnetTxPktSize, mscIpivcLcnVcSegmentSize=mscIpivcLcnVcSegmentSize, mscIpivcLcnVcTransferPriorityToNetwork=mscIpivcLcnVcTransferPriorityToNetwork, mscIpivcDrRowStatus=mscIpivcDrRowStatus, mscIpivcLcnVcWindowClosuresToSubnet=mscIpivcLcnVcWindowClosuresToSubnet, mscIpivcDnaRowStatusTable=mscIpivcDnaRowStatusTable, mscIpivcLcnDestinationIpAddress=mscIpivcLcnDestinationIpAddress, mscIpivcLcnVcFrmRetryTimeouts=mscIpivcLcnVcFrmRetryTimeouts, mscIpivcLcnVcSegmentsSent=mscIpivcLcnVcSegmentsSent, mscIpivcDnaCugRowStatusEntry=mscIpivcDnaCugRowStatusEntry, mscIpivcDnaIncomingOptionsEntry=mscIpivcDnaIncomingOptionsEntry, mscIpivcLcnVcIntdTable=mscIpivcLcnVcIntdTable, mscIpivcLcnVcStartTime=mscIpivcLcnVcStartTime, mscIpivcLcnVcState=mscIpivcLcnVcState, mscIpivcProvTable=mscIpivcProvTable, mscIpivcLcnVcType=mscIpivcLcnVcType, mscIpivcLcnVcStatsTable=mscIpivcLcnVcStatsTable, mscIpivcDnaCugOutCalls=mscIpivcDnaCugOutCalls, mscIpivcIpAddress=mscIpivcIpAddress, mscIpivcLcnVcPriority=mscIpivcLcnVcPriority, mscIpivcLcnOperTable=mscIpivcLcnOperTable, mscIpivcLcnVcIndex=mscIpivcLcnVcIndex, mscIpivcLcnVcCallReferenceNumberDecimal=mscIpivcLcnVcCallReferenceNumberDecimal, mscIpivcDnaIncomingOptionsTable=mscIpivcDnaIncomingOptionsTable, mscIpivcDnaCugFormat=mscIpivcDnaCugFormat, mscIpivcLcnVcCadEntry=mscIpivcLcnVcCadEntry, mscIpivcLcnVcStorageType=mscIpivcLcnVcStorageType, mscIpivcDnaDefaultSendToNetworkWindowSize=mscIpivcDnaDefaultSendToNetworkWindowSize, mscIpivcLcnStandbyStatus=mscIpivcLcnStandbyStatus, mscIpivcDnaDataNetworkAddress=mscIpivcDnaDataNetworkAddress, mscIpivcLcnProceduralStatus=mscIpivcLcnProceduralStatus, mscIpivcLcnVc=mscIpivcLcnVc, mscIpivcLcnVcCallingLcn=mscIpivcLcnVcCallingLcn, mscIpivcDnaServiceCategory=mscIpivcDnaServiceCategory, mscIpivcLcnPacketsReceived=mscIpivcLcnPacketsReceived, mscIpivcLcnVcSubnetRxWindowSize=mscIpivcLcnVcSubnetRxWindowSize, mscIpivcDnaCugIndex=mscIpivcDnaCugIndex, mscIpivcLcnStorageType=mscIpivcLcnStorageType, mscIpivcMaximumNumberOfLcn=mscIpivcMaximumNumberOfLcn, mscIpivcDrStorageType=mscIpivcDrStorageType, mscIpivcDnaCug=mscIpivcDnaCug, mscIpivcLcnVcPreviousState=mscIpivcLcnVcPreviousState, mscIpivcLcnVcSubnetTxWindowSize=mscIpivcLcnVcSubnetTxWindowSize, mscIpivcDnaCugPrivileged=mscIpivcDnaCugPrivileged, mscIpivcDrRowStatusEntry=mscIpivcDrRowStatusEntry, mscIpivcLcnAdminState=mscIpivcLcnAdminState, mscIpivcDnaNumberingPlanIndicator=mscIpivcDnaNumberingPlanIndicator, mscIpivcLcnIndex=mscIpivcLcnIndex, mscIpivcLcnVcCallingDna=mscIpivcLcnVcCallingDna, mscIpivcLcnRowStatusTable=mscIpivcLcnRowStatusTable, mscIpivcLcnOperEntry=mscIpivcLcnOperEntry, mscIpivcLcnVcRowStatusEntry=mscIpivcLcnVcRowStatusEntry, mscIpivcDnaRowStatus=mscIpivcDnaRowStatus, mscIpivcLcnVcRowStatusTable=mscIpivcLcnVcRowStatusTable, mscIpivcLcnVcCalledDna=mscIpivcLcnVcCalledDna, mscIpivcDnaIndex=mscIpivcDnaIndex)

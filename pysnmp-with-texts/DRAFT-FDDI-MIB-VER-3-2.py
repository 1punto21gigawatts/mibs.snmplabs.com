#
# PySNMP MIB module DRAFT-FDDI-MIB-VER-3-2 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DRAFT-FDDI-MIB-VER-3-2
# Produced by pysmi-0.3.4 at Wed May  1 12:54:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, experimental, IpAddress, TimeTicks, Unsigned32, Bits, MibIdentifier, Gauge32, ModuleIdentity, Integer32, ObjectIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "experimental", "IpAddress", "TimeTicks", "Unsigned32", "Bits", "MibIdentifier", "Gauge32", "ModuleIdentity", "Integer32", "ObjectIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
fddi = MibIdentifier((1, 3, 6, 1, 3, 8))
fddimib = MibIdentifier((1, 3, 6, 1, 3, 8, 73))
class FddiTimeNano(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class FddiTimeMilli(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class FddiResourceId(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class FddiSMTStationIdType(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class FddiMACLongAddressType(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

fddimibSMT = MibIdentifier((1, 3, 6, 1, 3, 8, 73, 1))
fddimibMAC = MibIdentifier((1, 3, 6, 1, 3, 8, 73, 2))
fddimibMACCounters = MibIdentifier((1, 3, 6, 1, 3, 8, 73, 3))
fddimibPATH = MibIdentifier((1, 3, 6, 1, 3, 8, 73, 4))
fddimibPORT = MibIdentifier((1, 3, 6, 1, 3, 8, 73, 5))
fddimibSMTNumber = MibScalar((1, 3, 6, 1, 3, 8, 73, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTNumber.setDescription("The number of SMT implementations (regardless of their current state) on this network management application entity. The value for this variable must remain constant at least from one re- initialization of the entity's network management system to the next re-initialization.")
fddimibSMTTable = MibTable((1, 3, 6, 1, 3, 8, 73, 1, 2), )
if mibBuilder.loadTexts: fddimibSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTTable.setDescription('A list of SMT entries. The number of entries shall not exceed the value of fddimibSMTNumber.')
fddimibSMTEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 1, 2, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibSMTIndex"))
if mibBuilder.loadTexts: fddimibSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTEntry.setDescription('An SMT entry containing information common to a given SMT.')
fddimibSMTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTIndex.setDescription("A unique value for each SMT. The value for each SMT must remain constant at least from one re- initialization of the entity's network management system to the next re-initialization.")
fddimibSMTStationId = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 2), FddiSMTStationIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTStationId.setReference('ANSI { fddiSMT 11 }')
if mibBuilder.loadTexts: fddimibSMTStationId.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTStationId.setDescription('Used to uniquely identify an FDDI station.')
fddimibSMTOpVersionId = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTOpVersionId.setReference('ANSI { fddiSMT 13 }')
if mibBuilder.loadTexts: fddimibSMTOpVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTOpVersionId.setDescription('The version that this station is using for its operation (refer to ANSI 7.1.2.2). The value of this variable is 2 for this SMT revision.')
fddimibSMTHiVersionId = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTHiVersionId.setReference('ANSI { fddiSMT 14 }')
if mibBuilder.loadTexts: fddimibSMTHiVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTHiVersionId.setDescription('The highest version of SMT that this station supports (refer to ANSI 7.1.2.2).')
fddimibSMTLoVersionId = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTLoVersionId.setReference('ANSI { fddiSMT 15 }')
if mibBuilder.loadTexts: fddimibSMTLoVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTLoVersionId.setDescription('The lowest version of SMT that this station supports (refer to ANSI 7.1.2.2).')
fddimibSMTUserData = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTUserData.setReference('ANSI { fddiSMT 17 }')
if mibBuilder.loadTexts: fddimibSMTUserData.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTUserData.setDescription('This variable contains 32 octets of user defined information. The information shall be an ASCII string.')
fddimibSMTMIBVersionId = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTMIBVersionId.setReference('ANSI { fddiSMT 18 }')
if mibBuilder.loadTexts: fddimibSMTMIBVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTMIBVersionId.setDescription('The version of the FDDI MIB of this station. The value of this variable is 1 for this SMT revision.')
fddimibSMTMACCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTMACCts.setReference('ANSI { fddiSMT 21 }')
if mibBuilder.loadTexts: fddimibSMTMACCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTMACCts.setDescription('The number of MACs in this station or concentrator.')
fddimibSMTNonMasterCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTNonMasterCts.setReference('ANSI { fddiSMT 22 }')
if mibBuilder.loadTexts: fddimibSMTNonMasterCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTNonMasterCts.setDescription('The value of this variable is the number of A, B, and S ports in this station or concentrator.')
fddimibSMTMasterCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTMasterCts.setReference('ANSI { fddiSMT 23 }')
if mibBuilder.loadTexts: fddimibSMTMasterCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTMasterCts.setDescription('The number of M Ports in a node. If the node is not a concentrator, the value of the variable is zero.')
fddimibSMTAvailablePaths = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTAvailablePaths.setReference('ANSI { fddiSMT 24 }')
if mibBuilder.loadTexts: fddimibSMTAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTAvailablePaths.setDescription('A value that indicates the PATH types available in the station. The value is a sum. This value initially takes the value zero, then for each type of PATH that this node has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 For example, a station having Primary and Local PATHs available would have a value of 5 (2**0 + 2**2).')
fddimibSMTConfigCapabilities = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTConfigCapabilities.setReference('ANSI { fddiSMT 25 }')
if mibBuilder.loadTexts: fddimibSMTConfigCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTConfigCapabilities.setDescription("A value that indicates the configuration capabilities of a node. The 'Hold Available' bit indicates the support of the optional Hold Function, which is controlled by fddiSMTConfigPolicy. The 'CF-Wrap-AB' bit indicates that the station has the capability of performing a wrap_ab (refer to ANSI SMT 9.7.2.2). The value is a sum. This value initially takes the value zero, then for each of the configuration policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power holdAvailable 0 CF-Wrap-AB 1 ")
fddimibSMTConfigPolicy = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTConfigPolicy.setReference('ANSI { fddiSMT 26 }')
if mibBuilder.loadTexts: fddimibSMTConfigPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTConfigPolicy.setDescription("A value that indicates the configuration policies currently desired in a node. 'Hold' is one of the terms used for the Hold Flag, an optional ECM flag used to enable the optional Hold policy. The value is a sum. This value initially takes the value zero, then for each of the configuration policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power configurationhold 0 ")
fddimibSMTConnectionPolicy = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTConnectionPolicy.setReference('ANSI { fddiSMT 27 }')
if mibBuilder.loadTexts: fddimibSMTConnectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTConnectionPolicy.setDescription("A value representing the connection policies in effect in a node. A station sets the corresponding bit for each of the connection types that it rejects. The letter designations, X and Y, in the 'rejectX-Y' names have the following significance: X represents the PC-Type of the local PORT and Y represents the PC_Type of the adjacent PORT (PC_Neighbor). The evaluation of Connection- Policy (PC-Type, PC-Neighbor) is done to determine the setting of T- Val(3) in the PC-Signalling sequence (refer to ANSI 9.6.3). Note that Bit 15, (rejectM-M), is always set and cannot be cleared. The value is a sum. This value initially takes the value zero, then for each of the connection policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power rejectA-A 0 rejectA-B 1 rejectA-S 2 rejectA-M 3 rejectB-A 4 rejectB-B 5 rejectB-S 6 rejectB-M 7 rejectS-A 8 rejectS-B 9 rejectS-S 10 rejectS-M 11 rejectM-A 12 rejectM-B 13 rejectM-S 14 rejectM-M 15 ")
fddimibSMTTNotify = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTTNotify.setReference('ANSI { fddiSMT 29 }')
if mibBuilder.loadTexts: fddimibSMTTNotify.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTTNotify.setDescription('The timer, expressed in seconds, used in the Neighbor Notification protocol. It has a range of 2 seconds to 30 seconds, and its default value is 30 seconds (refer to ANSI SMT 8.2).')
fddimibSMTStatRptPolicy = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTStatRptPolicy.setReference('ANSI { fddiSMT 30 }')
if mibBuilder.loadTexts: fddimibSMTStatRptPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTStatRptPolicy.setDescription('If true, indicates that the node will generate Status Reporting Frames for its implemented events and conditions. It has an initial value of true. This variable determines the value of the SR_Enable Flag (refer to ANSI SMT 8.3.2.1).')
fddimibSMTTraceMaxExpiration = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 17), FddiTimeMilli()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTTraceMaxExpiration.setReference('ANSI { fddiSMT 31 }')
if mibBuilder.loadTexts: fddimibSMTTraceMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTTraceMaxExpiration.setDescription('Reference Trace_Max (refer to ANSI SMT 9.4.4.2.2).')
fddimibSMTBypassPresent = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTBypassPresent.setReference('ANSI { fddiSMT 34 }')
if mibBuilder.loadTexts: fddimibSMTBypassPresent.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTBypassPresent.setDescription('A flag indicating if the station has a bypass on its AB port pair.')
fddimibSMTECMState = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ec0", 1), ("ec1", 2), ("ec2", 3), ("ec3", 4), ("ec4", 5), ("ec5", 6), ("ec6", 7), ("ec7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTECMState.setReference('ANSI { fddiSMT 41 }')
if mibBuilder.loadTexts: fddimibSMTECMState.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTECMState.setDescription('Indicates the current state of the ECM state machine (refer to ANSI SMT 9.5.2).')
fddimibSMTCFState = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("cf0", 1), ("cf1", 2), ("cf2", 3), ("cf3", 4), ("cf4", 5), ("cf5", 6), ("cf6", 7), ("cf7", 8), ("cf8", 9), ("cf9", 10), ("cf10", 11), ("cf11", 12), ("cf12", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTCFState.setReference('ANSI { fddiSMT 42 }')
if mibBuilder.loadTexts: fddimibSMTCFState.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTCFState.setDescription('The attachment configuration for the station or concentrator (refer to ANSI SMT 9.7.2.2).')
fddimibSMTRemoteDisconnectFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTRemoteDisconnectFlag.setReference('ANSI { fddiSMT 44 }')
if mibBuilder.loadTexts: fddimibSMTRemoteDisconnectFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTRemoteDisconnectFlag.setDescription('A flag indicating that the station was remotely disconnected from the network as a result of receiving an fddiSMTAction, disconnect (refer to ANSI SMT 6.4.5.3) in a Parameter Management Frame. A station requires a Connect Action to rejoin and clear the flag (refer to ANSI SMT 6.4.5.2).')
fddimibSMTStationStatus = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("concatenated", 1), ("separated", 2), ("thru", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTStationStatus.setReference('ANSI { fddiSMT 45 }')
if mibBuilder.loadTexts: fddimibSMTStationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTStationStatus.setDescription('The current status of the primary and secondary paths within this station.')
fddimibSMTPeerWrapFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTPeerWrapFlag.setReference('ANSI { fddiSMT 46 }')
if mibBuilder.loadTexts: fddimibSMTPeerWrapFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTPeerWrapFlag.setDescription('This variable assumes the value of the PeerWrapFlag in CFM (refer to ANSI SMT 9.7.2.4.4).')
fddimibSMTTimeStamp = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 24), FddiTimeMilli()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTTimeStamp.setReference('ANSI { fddiSMT 51 }')
if mibBuilder.loadTexts: fddimibSMTTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTTimeStamp.setDescription('This variable assumes the value of TimeStamp (refer to ANSI SMT 8.3.2.1).')
fddimibSMTTransitionTimeStamp = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 25), FddiTimeMilli()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibSMTTransitionTimeStamp.setReference('ANSI { fddiSMT 52 }')
if mibBuilder.loadTexts: fddimibSMTTransitionTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTTransitionTimeStamp.setDescription('This variable assumes the value of TransitionTimeStamp (refer to ANSI SMT 8.3.2.1).')
fddimibSMTStationAction = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("connect", 2), ("disconnect", 3), ("path-Test", 4), ("self-Test", 5), ("disable-a", 6), ("disable-b", 7), ("disable-m", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibSMTStationAction.setReference('ANSI { fddiSMT 60 }')
if mibBuilder.loadTexts: fddimibSMTStationAction.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibSMTStationAction.setDescription("This object, when read, always returns a value of other(1). The behavior of setting this variable to each of the acceptable values is as follows: other(1): Results in a badValue error. connect(2): Generates a Connect signal to ECM to begin a connection sequence. See ANSI Ref 9.4.2. disconnect(3): Generates a Disconnect signal to ECM. see ANSI Ref 9.4.2. path-Test(4): Initiates a station Path_Test. The Path_Test variable (see ANSI Ref 9.4.1) is set to 'Testing'. The results of this action are not specified in this standard. self-Test(5): Initiates a station Self_Test. The results of this action are not specified in this standard. disable-a(6): Causes a PC_Disable on the A port if the A port mode is peer. disable-b(7): Causes a PC_Disable on the B port if the B port mode is peer. disable-m(8): Causes a PC_Disable on all M ports. Attempts to set this object to all other values results in a badValue error. The result of setting this variable to path-Test(4) or self- Test(5) is implementation-specific.")
fddimibMACNumber = MibScalar((1, 3, 6, 1, 3, 8, 73, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACNumber.setDescription("The total number of MAC implementations (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
fddimibMACTable = MibTable((1, 3, 6, 1, 3, 8, 73, 2, 2), )
if mibBuilder.loadTexts: fddimibMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTable.setDescription('A list of MAC entries. The number of entries shall not exceed the value of fddimibMACNumber.')
fddimibMACEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 2, 2, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibMACSMTIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibMACIndex"))
if mibBuilder.loadTexts: fddimibMACEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACEntry.setDescription('A MAC entry containing information common to a given MAC.')
fddimibMACSMTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACSMTIndex.setDescription('The value of the SMT index associated with this MAC.')
fddimibMACIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACIndex.setReference('ANSI { fddiMAC 34 }')
if mibBuilder.loadTexts: fddimibMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACIndex.setDescription('Index variable for uniquely identifying the MAC object instances, which is the same as the corresponding resource index in SMT.')
fddimibMACIfIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACIfIndex.setReference('MIB-II')
if mibBuilder.loadTexts: fddimibMACIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACIfIndex.setDescription('The value of the MIB-II ifIndex corresponding to this MAC. If none is applicable, 0 is returned.')
fddimibMACFrameStatusFunctions = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACFrameStatusFunctions.setReference('ANSI { fddiMAC 11 }')
if mibBuilder.loadTexts: fddimibMACFrameStatusFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACFrameStatusFunctions.setDescription("Indicates the MAC's optional Frame Status processing functions. The value is a sum. This value initially takes the value zero, then for each function present, 2 raised to a power is added to the sum. The powers are according to the following table: function Power fs-repeating 0 fs-setting 1 fs-clearing 2 ")
fddimibMACTMaxCapability = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 5), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTMaxCapability.setReference('ANSI { fddiMAC 13 }')
if mibBuilder.loadTexts: fddimibMACTMaxCapability.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTMaxCapability.setDescription('Indicates the maximum time value of fddiMACTMax that this MAC can support.')
fddimibMACTVXCapability = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 6), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTVXCapability.setReference('ANSI { fddiMAC 14 }')
if mibBuilder.loadTexts: fddimibMACTVXCapability.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTVXCapability.setDescription('Indicates the maximum time value of fddiMACTvxValue that this MAC can support.')
fddimibMACAvailablePaths = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACAvailablePaths.setReference('ANSI { fddiMAC 22 }')
if mibBuilder.loadTexts: fddimibMACAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACAvailablePaths.setDescription('Indicates the paths available for this MAC (refer to ANSI SMT 9.7.7). The value is a sum. This value initially takes the value zero, then for each type of PATH that this MAC has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 ')
fddimibMACCurrentPath = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("isolated", 1), ("local", 2), ("secondary", 3), ("primary", 4), ("concatenated", 5), ("thru", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACCurrentPath.setReference('ANSI { fddiMAC 23 }')
if mibBuilder.loadTexts: fddimibMACCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACCurrentPath.setDescription('Indicates the Path into which this MAC is currently inserted (refer to ANSI 9.7.7).')
fddimibMACUpstreamNbr = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 9), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACUpstreamNbr.setReference('ANSI { fddiMAC 24 }')
if mibBuilder.loadTexts: fddimibMACUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACUpstreamNbr.setDescription("The MAC's upstream neighbor's long individual MAC address. It has an initial value of the SMT- Unknown-MAC Address and is only modified as specified by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1 and 8.2).")
fddimibMACDownstreamNbr = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 10), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACDownstreamNbr.setReference('ANSI { fddiMAC 25 }')
if mibBuilder.loadTexts: fddimibMACDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACDownstreamNbr.setDescription("The MAC's downstream neighbor's long individual MAC address. It has an initial value of the SMT- Unknown-MAC Address and is only modified as specified by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1 and 8.2).")
fddimibMACOldUpstreamNbr = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 11), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACOldUpstreamNbr.setReference('ANSI { fddiMAC 26 }')
if mibBuilder.loadTexts: fddimibMACOldUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACOldUpstreamNbr.setDescription("The previous value of the MAC's upstream neighbor's long individual MAC address. It has an initial value of the SMT-Unknown- MAC Address and is only modified as specified by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1 and 8.2).")
fddimibMACOldDownstreamNbr = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 12), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACOldDownstreamNbr.setReference('ANSI { fddiMAC 27 }')
if mibBuilder.loadTexts: fddimibMACOldDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACOldDownstreamNbr.setDescription("The previous value of the MAC's downstream neighbor's long individual MAC address. It has an initial value of the SMT- Unknown-MAC Address and is only modified as specified by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1 and 8.2).")
fddimibMACDupAddressTest = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pass", 2), ("fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACDupAddressTest.setReference('ANSI { fddiMAC 29 }')
if mibBuilder.loadTexts: fddimibMACDupAddressTest.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACDupAddressTest.setDescription('The Duplicate Address Test flag, Dup_Addr_Test (refer to ANSI 8.2).')
fddimibMACRequestedPaths = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibMACRequestedPaths.setReference('ANSI { fddiMAC 32 }')
if mibBuilder.loadTexts: fddimibMACRequestedPaths.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACRequestedPaths.setDescription('List of permitted Paths which specifies the Path(s) into which the MAC may be inserted (refer to ansi SMT 9.7). The value is a sum which represents the individual paths that are desired. This value initially takes the value zero, then for each type of PATH that this node is, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power local 0 secondary-alternate 1 primary-alternate 2 concatenated-alternate 3 secondary-preferred 4 primary-preferred 5 concatenated-preferred 6 thru 7 ')
fddimibMACDownstreamPORTType = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACDownstreamPORTType.setReference('ANSI { fddiMAC 33 }')
if mibBuilder.loadTexts: fddimibMACDownstreamPORTType.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACDownstreamPORTType.setDescription('Indicates the PC-Type of the first port that is downstream of this MAC (the exit port).')
fddimibMACSMTAddress = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 16), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACSMTAddress.setReference('ANSI { fddiMAC 41 }')
if mibBuilder.loadTexts: fddimibMACSMTAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACSMTAddress.setDescription('The 48-bit individual address of the MAC used for SMT frames.')
fddimibMACTReq = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 17), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTReq.setReference('ANSI { fddiMAC 51 }')
if mibBuilder.loadTexts: fddimibMACTReq.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTReq.setDescription('This variable is the T_Req_value passed to the MAC. Without having detected a duplicate, the time value of this variable shall assume the maximum supported time value which is less than or equal to the time value of fddiPATHMaxT-Req. When a MAC has an address detected as a duplicate, it may use a time value for this variable greater than the time value of fddiPATHTMaxLowerBound. A station shall cause claim when the new T_Req may cause the value of T_Neg to change in the claim process, (i.e., time value new T_Req < T_Neg, or old T_Req = T_Neg).')
fddimibMACTNeg = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 18), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTNeg.setReference('ANSI { fddiMAC 52 }')
if mibBuilder.loadTexts: fddimibMACTNeg.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTNeg.setDescription('It is reported as a FddiTimeNano number.')
fddimibMACTMax = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 19), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTMax.setReference('ANSI { fddiMAC 53 }')
if mibBuilder.loadTexts: fddimibMACTMax.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTMax.setDescription('This variable is the T_Max_value passed to the MAC. The time value of this variable shall assume the minimum suported time value which is greater than or equal to the time value of fddiPATHT- MaxLowerBound')
fddimibMACTvxValue = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 20), FddiTimeNano()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTvxValue.setReference('ANSI { fddiMAC 54 }')
if mibBuilder.loadTexts: fddimibMACTvxValue.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTvxValue.setDescription('This variable is the TVX_value passed to the MAC. The time value of this variable shall assume the minimum suported time value which is greater than or equal to the time value of fddiPATHTVXLowerBound.')
fddimibMACFrameCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACFrameCts.setReference('ANSI { fddiMAC 71 }')
if mibBuilder.loadTexts: fddimibMACFrameCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACFrameCts.setDescription('A count of the number of frames received by this MAC (refer to ANSI MAC 7.5.1).')
fddimibMACCopiedCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACCopiedCts.setReference('ANSI { fddiMAC 72 }')
if mibBuilder.loadTexts: fddimibMACCopiedCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACCopiedCts.setDescription("A count that should as closely as possible match the number of frames addressed to (A bit set) and successfully copied into the station's receive buffers (C bit set) by this MAC (refer to ANSI MAC 7.5). Note that this count does not include MAC frames.")
fddimibMACTransmitCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTransmitCts.setReference('ANSI { fddiMAC 73 }')
if mibBuilder.loadTexts: fddimibMACTransmitCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTransmitCts.setDescription('A count that should as closely as possible match the number of frames transmitted by this MAC (refer to ANSI MAC 7.5). Note that this count does not include MAC frames.')
fddimibMACErrorCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACErrorCts.setReference('ANSI { fddiMAC 81 }')
if mibBuilder.loadTexts: fddimibMACErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACErrorCts.setDescription('A count of the number of frames that were detected in error by this MAC that had not been detected in error by another MAC (refer to ANSI MAC 7.5.2).')
fddimibMACLostCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACLostCts.setReference('ANSI { fddiMAC 82 }')
if mibBuilder.loadTexts: fddimibMACLostCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACLostCts.setDescription('A count of the number of instances that this MAC detected a format error during frame reception such that the frame was stripped (refer to ANSI MAC 7.5.3).')
fddimibMACFrameErrorThreshold = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibMACFrameErrorThreshold.setReference('ANSI { fddiMAC 95 }')
if mibBuilder.loadTexts: fddimibMACFrameErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACFrameErrorThreshold.setDescription('A threshold for determining when a MAC Condition report (see ANSI 8.3.1.1) shall be generated. Stations not supporting variable thresholds shall have a value of 0 and a range of (0..0).')
fddimibMACFrameErrorRatio = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACFrameErrorRatio.setReference('ANSI { fddiMAC 96 }')
if mibBuilder.loadTexts: fddimibMACFrameErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACFrameErrorRatio.setDescription('This variable is the value of the ratio, ((delta fddiMACLostCts + delta fddiMACErrorCts) / (delta fddiMACFrameCts + delta fddiMACLostCts )) * 2**16 ')
fddimibMACRMTState = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("rm0", 1), ("rm1", 2), ("rm2", 3), ("rm3", 4), ("rm4", 5), ("rm5", 6), ("rm6", 7), ("rm7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACRMTState.setReference('ANSI { fddiMAC 111 }')
if mibBuilder.loadTexts: fddimibMACRMTState.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACRMTState.setDescription('Indicates the current state of the RMT State Machine (refer to ANSI 10.3.2).')
fddimibMACDaFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACDaFlag.setReference('ANSI { fddiMAC 112 }')
if mibBuilder.loadTexts: fddimibMACDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACDaFlag.setDescription('The RMT flag Duplicate Address Flag, DA_Flag (refer to ANSI 10.2.1.2).')
fddimibMACUnaDaFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACUnaDaFlag.setReference('ANSI { fddiMAC 113 }')
if mibBuilder.loadTexts: fddimibMACUnaDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACUnaDaFlag.setDescription('A flag, UNDA_Flag (refer to ANSI 8.2.2.1), set when the upstream neighbor reports a duplicate address condition. Cleared when the condition clears.')
fddimibMACFrameErrorFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACFrameErrorFlag.setReference('ANSI { fddiMAC 114 }')
if mibBuilder.loadTexts: fddimibMACFrameErrorFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACFrameErrorFlag.setDescription('Indicates the MAC Frame Error Condition is present when set. Cleared when the condition clears and on station initialization.')
fddimibMACMAUnitdataAvailable = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACMAUnitdataAvailable.setReference('ANSI { fddiMAC 116 }')
if mibBuilder.loadTexts: fddimibMACMAUnitdataAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACMAUnitdataAvailable.setDescription('This variable shall take on the value of the MAC_Avail flag defined in RMT.')
fddimibMACHardwarePresent = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACHardwarePresent.setReference('ANSI { fddiMAC 117 }')
if mibBuilder.loadTexts: fddimibMACHardwarePresent.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACHardwarePresent.setDescription('This variable indicates the presence of underlying hardware support for this MAC object. If the value of this object is false(2), the reporting of the objects in this entry may be handled in an implementation-specific manner.')
fddimibMACMAUnitdataEnable = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibMACMAUnitdataEnable.setReference('ANSI { fddiMAC 118 }')
if mibBuilder.loadTexts: fddimibMACMAUnitdataEnable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACMAUnitdataEnable.setDescription('This attribute determines the value of the MA_UNITDATA_Enable flag in RMT. The default and initial value of this flag is true(1).')
fddimibMACCountersTable = MibTable((1, 3, 6, 1, 3, 8, 73, 3, 1), )
if mibBuilder.loadTexts: fddimibMACCountersTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACCountersTable.setDescription('A list of MAC Counters entries. The number of entries shall not exceed the value of fddimibMACNumber.')
fddimibMACCountersEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 3, 1, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibMACSMTIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibMACIndex"))
if mibBuilder.loadTexts: fddimibMACCountersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACCountersEntry.setDescription('A MAC Counters entry containing information common to a given MAC.')
fddimibMACTokenCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTokenCts.setReference('ANSI { fddiMAC 74 }')
if mibBuilder.loadTexts: fddimibMACTokenCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTokenCts.setDescription('A count that should as closely as possible match the number of times the station has received a token (total of non- restricted and restricted) on this MAC (see ANSI MAC 7.4). This count is valuable for determination of network load.')
fddimibMACTvxExpiredCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACTvxExpiredCts.setReference('ANSI { fddiMAC 83 }')
if mibBuilder.loadTexts: fddimibMACTvxExpiredCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACTvxExpiredCts.setDescription('A count that should as closely as possible match the number of times that TVX has expired.')
fddimibMACNotCopiedCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACNotCopiedCts.setReference('ANSI { fddiMAC 84 }')
if mibBuilder.loadTexts: fddimibMACNotCopiedCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACNotCopiedCts.setDescription('A count that should as closely as possible match the number of frames that were addressed to this MAC but were not copied into its receive buffers (see ANSI MAC 7.5). For example, this might occur due to local buffer congestion. Because of implementation considerations, this count may not match the actual number of frames not copied. It is not a requirement that this count be exact. Note that this count does not include MAC frames.')
fddimibMACLateCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACLateCts.setReference('ANSI { fddiMAC 85 }')
if mibBuilder.loadTexts: fddimibMACLateCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACLateCts.setDescription('A count that should as closely as possible match the number of TRT expirations since this MAC was reset or a token was received (refer to ANSI MAC 7.4.5).')
fddimibMACRingOpCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACRingOpCts.setReference('ANSI { fddiMAC 86 }')
if mibBuilder.loadTexts: fddimibMACRingOpCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACRingOpCts.setDescription("The count of the number of times the ring has entered the 'Ring_Operational' state from the 'Ring Not Operational' state. This count is updated when a SM_MA_STATUS.Indication of a change in the Ring_Operational status occurs (refer to ANSI 6.1.4). Because of implementation considerations, this count may be less than the actual RingOp_Ct. It is not a requirement that this count be exact.")
fddimibMACNotCopiedRatio = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACNotCopiedRatio.setReference('ANSI { fddiMAC 105 }')
if mibBuilder.loadTexts: fddimibMACNotCopiedRatio.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACNotCopiedRatio.setDescription('This variable is the value of the ratio: (delta fddiMACNotCopiedCts / (delta fddiMACCopiedCts + delta fddiMACNotCopiedCts )) * 2**16 ')
fddimibMACNotCopiedFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibMACNotCopiedFlag.setReference('ANSI { fddiMAC 115 }')
if mibBuilder.loadTexts: fddimibMACNotCopiedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACNotCopiedFlag.setDescription('Indicates that the Not Copied condition is present when read as true(1). Set to false(2) when the condition clears and on station initialization.')
fddimibMACNotCopiedThreshold = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibMACNotCopiedThreshold.setReference('ANSI { fddiMAC 103 }')
if mibBuilder.loadTexts: fddimibMACNotCopiedThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibMACNotCopiedThreshold.setDescription('A threshold for determining when a MAC condition report shall be generated. Stations not supporting variable thresholds shall have a value of 0 and a range of (0..0).')
fddimibPATHNumber = MibScalar((1, 3, 6, 1, 3, 8, 73, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHNumber.setDescription("The total number of PATHs possible (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
fddimibPATHTable = MibTable((1, 3, 6, 1, 3, 8, 73, 4, 2), )
if mibBuilder.loadTexts: fddimibPATHTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHTable.setDescription('A list of PATH entries. The number of entries shall not exceed the value of fddimibPATHNumber.')
fddimibPATHEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 4, 2, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPATHSMTIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPATHIndex"))
if mibBuilder.loadTexts: fddimibPATHEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHEntry.setDescription('A PATH entry containing information common to a given PATH.')
fddimibPATHSMTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHSMTIndex.setDescription('The value of the SMT index associated with this PATH.')
fddimibPATHIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHIndex.setReference('ANSI { fddiPATH 11 }')
if mibBuilder.loadTexts: fddimibPATHIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHIndex.setDescription('Index variable for uniquely identifying the primary, secondary and local PATH object instances. Local PATH object instances are represented with integer values 3 to 255.')
fddimibPATHTVXLowerBound = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 2, 1, 3), FddiTimeNano()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPATHTVXLowerBound.setReference('ANSI { fddiPATH 21 }')
if mibBuilder.loadTexts: fddimibPATHTVXLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHTVXLowerBound.setDescription('Specifies the minimum time value of fddiMACTvxValue that shall be used by any MAC that is configured in this path. The operational value of fddiMACTvxValue is managed by settting this variable. This variable has the time value range of: 0 < fddimibPATHTVXLowerBound < fddimibPATHMaxTReq Changes to this variable shall either satisfy the time value relationship: fddimibPATHTVXLowerBound <= fddimibMACTVXCapability of each of the MACs currently on the path, or be considered out of range. The initial value of fddimibPATHTVXLowerBound shall be 2500 nsec (2.5 ms).')
fddimibPATHTMaxLowerBound = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 2, 1, 4), FddiTimeNano()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPATHTMaxLowerBound.setReference('ANSI { fddiPATH 22 }')
if mibBuilder.loadTexts: fddimibPATHTMaxLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHTMaxLowerBound.setDescription('Specifies the minimum time value of fddiMACTMax that shall be used by any MAC that is configured in this path. The operational value of fddiMACTMax is managed by setting this variable. This variable has the time value range of: fddimibPATHMaxTReq <= fddimibPATHTMaxLowerBound and an absolute time value range of: 10000nsec (10 msec) <= fddimibPATHTMaxLowerBound Changes to this variable shall either satisfy the time value relationship: fddimibPATHTMaxLowerBound < fddimibMACTMaxCapability of each of the MACs currently on the path, or be considered out of range. The initial value of fddimibPATHTMaxLowerBound shall be 165000 nsec (165 msec).')
fddimibPATHMaxTReq = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 2, 1, 5), FddiTimeNano()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPATHMaxTReq.setReference('ANSI { fddiPATH 23 }')
if mibBuilder.loadTexts: fddimibPATHMaxTReq.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHMaxTReq.setDescription('Specifies the maximum time value of fddiMACT-Req that shall be used by any MAC that is configured in this path. The operational value of fddiMACT- Req is managed by setting this variable. This variable has the time value range of: fddimibPATHTVXLowerBound < fddimibPATHMaxTReq <= fddimibPATHTMaxLowerBound. The default value of fddimibPATHMaxTReq is 165000 nsec (165 msec).')
fddimibPATHConfigTable = MibTable((1, 3, 6, 1, 3, 8, 73, 4, 3), )
if mibBuilder.loadTexts: fddimibPATHConfigTable.setReference('ANSI { fddiPATH 18 }')
if mibBuilder.loadTexts: fddimibPATHConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigTable.setDescription('A table of Path configuration entries. This table lists all the resources that may be in this Path.')
fddimibPATHConfigEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 4, 3, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPATHConfigSMTIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPATHConfigPATHIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPATHConfigTokenOrder"))
if mibBuilder.loadTexts: fddimibPATHConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigEntry.setDescription('A collection of objects containing information for a given PATH Configuration entry.')
fddimibPATHConfigSMTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigSMTIndex.setDescription('The value of the SMT index associated with this configuration entry.')
fddimibPATHConfigPATHIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigPATHIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigPATHIndex.setDescription('The value of the PATH resource index associated with this configuration entry.')
fddimibPATHConfigTokenOrder = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigTokenOrder.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigTokenOrder.setDescription('An object associated with Token order for this entry. Thus if the token passes resources a, b, c and d, in that order, then the value of this object for these resources would be 1, 2, 3 and 4 respectively.')
fddimibPATHConfigResourceType = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("mac", 2), ("port", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigResourceType.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigResourceType.setDescription('The type of resource associated with this configuration entry.')
fddimibPATHConfigResourceIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigResourceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigResourceIndex.setDescription('The value of the SMT resource index used to refer to the instance of this MAC or Port resource.')
fddimibPATHConfigCurrentPath = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("isolated", 1), ("local", 2), ("secondary", 3), ("primary", 4), ("concatenated", 5), ("thru", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPATHConfigCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPATHConfigCurrentPath.setDescription('The current insertion status for this resource on this Path.')
fddimibPORTNumber = MibScalar((1, 3, 6, 1, 3, 8, 73, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTNumber.setDescription("The total number of PORT implementations (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
fddimibPORTTable = MibTable((1, 3, 6, 1, 3, 8, 73, 5, 2), )
if mibBuilder.loadTexts: fddimibPORTTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTTable.setDescription('A list of PORT entries. The number of entries shall not exceed the value of fddimibPORTNumber.')
fddimibPORTEntry = MibTableRow((1, 3, 6, 1, 3, 8, 73, 5, 2, 1), ).setIndexNames((0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPORTSMTIndex"), (0, "DRAFT-FDDI-MIB-VER-3-2", "fddimibPORTIndex"))
if mibBuilder.loadTexts: fddimibPORTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTEntry.setDescription('A PORT entry containing information common to a given PORT.')
fddimibPORTSMTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTSMTIndex.setDescription('The value of the SMT index associated with this PORT.')
fddimibPORTIndex = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTIndex.setReference('ANSI { fddiPORT 29 }')
if mibBuilder.loadTexts: fddimibPORTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTIndex.setDescription("A unique value for each PORT within a given SMT, which is the same as the corresponding resource index in SMT. The value for each PORT must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
fddimibPORTMyType = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTMyType.setReference('ANSI { fddiPORT 12 }')
if mibBuilder.loadTexts: fddimibPORTMyType.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTMyType.setDescription("The value of the PORT's PC_Type (refer to ANSI 9.4.1, and 9.6.3.2).")
fddimibPORTNeighborType = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTNeighborType.setReference('ANSI { fddiPORT 13 }')
if mibBuilder.loadTexts: fddimibPORTNeighborType.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTNeighborType.setDescription('The type of the remote PORT as determined in PCM. This variable has an initial value of none, and is only modified in PC_RCode(3)_Actions (refer to ANSI SMT 9.6.3.2).')
fddimibPORTConnectionPolicies = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPORTConnectionPolicies.setReference('ANSI { fddiPORT 14 }')
if mibBuilder.loadTexts: fddimibPORTConnectionPolicies.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTConnectionPolicies.setDescription("A value representing the PORT's connection policies desired in the node. The value of pc- mac-lct is a term used in the PC_MAC_LCT Flag (see 9.4.3.2). The value of pc-mac-loop is a term used in the PC_MAC_Loop Flag. The value is a sum. This value initially takes the value zero, then for each PORT policy, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power pc-mac-lct 0 pc-mac-loop 1 ")
fddimibPORTMACIndicated = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tVal9FalseRVal9False", 1), ("tVal9FalseRVal9True", 2), ("tVal9TrueRVal9False", 3), ("tVal9TrueRVal9True", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTMACIndicated.setReference('ANSI { fddiPORT 15 }')
if mibBuilder.loadTexts: fddimibPORTMACIndicated.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTMACIndicated.setDescription('The indications (T_Val(9), R_Val(9)) in PC- Signalling, of the intent to place a MAC in the output token path to a PORT (refer to ANSI SMT 9.6.3.2.).')
fddimibPORTCurrentPath = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ce0", 1), ("ce1", 2), ("ce2", 3), ("ce3", 4), ("ce4", 5), ("ce5", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTCurrentPath.setReference('ANSI { fddiPORT 16 }')
if mibBuilder.loadTexts: fddimibPORTCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTCurrentPath.setDescription('Indicates the Path(s) into which this PORT is currently inserted.')
fddimibPORTRequestedPaths = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPORTRequestedPaths.setReference('ANSI { fddiPORT 17 }')
if mibBuilder.loadTexts: fddimibPORTRequestedPaths.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTRequestedPaths.setDescription("This variable is a list of permitted Paths where each list element defines the Port's permitted Paths. The first octet corresponds to 'none', the second octet to 'tree', and the third octet to 'peer'.")
fddimibPORTMACPlacement = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 9), FddiResourceId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTMACPlacement.setReference('ANSI { fddiPORT 18 }')
if mibBuilder.loadTexts: fddimibPORTMACPlacement.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTMACPlacement.setDescription('Indicates the MAC, if any, whose transmit path exits the station via this PORT. The value shall be zero if there is no MAC associated with the PORT. Otherwise, the MACIndex of the MAC will be the value of the variable.')
fddimibPORTAvailablePaths = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTAvailablePaths.setReference('ANSI { fddiPORT 19 }')
if mibBuilder.loadTexts: fddimibPORTAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTAvailablePaths.setDescription('Indicates the Paths which are available to this Port. In the absence of faults, the A and B Ports will always have both the Primary and Secondary Paths available. The value is a sum. This value initially takes the value zero, then for each type of PATH that this port has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 ')
fddimibPORTPMDClass = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("multimode", 1), ("single-mode1", 2), ("single-mode2", 3), ("sonet", 4), ("low-cost-fiber", 5), ("twisted-pair", 6), ("unknown", 7), ("unspecified", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTPMDClass.setReference('ANSI { fddiPORT 22 }')
if mibBuilder.loadTexts: fddimibPORTPMDClass.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTPMDClass.setDescription('This variable indicates the type of PMD entity associated with this port.')
fddimibPORTConnectionCapabilities = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTConnectionCapabilities.setReference('ANSI { fddiPORT 23 }')
if mibBuilder.loadTexts: fddimibPORTConnectionCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTConnectionCapabilities.setDescription('A value that indicates the connection capabilities of the port. The pc-mac-lct bit indicates that the station has the capability of setting the PC_MAC_LCT Flag. The pc-mac-loop bit indicates that the station has the capability of setting the PC_MAC_Loop Flag (refer to ANSI 9.4.3.2). The value is a sum. This value initially takes the value zero, then for each capability that this port has, 2 raised to a power is added to the sum. The powers are according to the following table: capability Power pc-mac-lct 0 pc-mac-loop 1 ')
fddimibPORTBSFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTBSFlag.setReference('ANSI { fddiPORT 33 }')
if mibBuilder.loadTexts: fddimibPORTBSFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTBSFlag.setDescription('This variable assumes the value of the BS_Flag (refer to ANSI SMT 9.4.3.3).')
fddimibPORTLCTFailCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTLCTFailCts.setReference('ANSI { fddiPORT 42 }')
if mibBuilder.loadTexts: fddimibPORTLCTFailCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLCTFailCts.setDescription('The count of the consecutive times the link confidence test (LCT) has failed during connection management (refer to ANSI 9.4.1).')
fddimibPORTLerEstimate = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTLerEstimate.setReference('ANSI { fddiPORT 51 }')
if mibBuilder.loadTexts: fddimibPORTLerEstimate.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLerEstimate.setDescription('A long term average link error rate. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm (refer to ANSI SMT 9.4.7.5.).')
fddimibPORTLemRejectCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTLemRejectCts.setReference('ANSI { fddiPORT 52 }')
if mibBuilder.loadTexts: fddimibPORTLemRejectCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLemRejectCts.setDescription('A link error monitoring count of the times that a link has been rejected.')
fddimibPORTLemCts = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTLemCts.setReference('ANSI { fddiPORT 53 }')
if mibBuilder.loadTexts: fddimibPORTLemCts.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLemCts.setDescription('The aggregate link error monitor error count, set to zero only on station initialization.')
fddimibPORTLerCutoff = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPORTLerCutoff.setReference('ANSI { fddiPORT 58 }')
if mibBuilder.loadTexts: fddimibPORTLerCutoff.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLerCutoff.setDescription('The link error rate estimate at which a link connection will be broken. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm (default of 7).')
fddimibPORTLerAlarm = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPORTLerAlarm.setReference('ANSI { fddiPORT 59 }')
if mibBuilder.loadTexts: fddimibPORTLerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLerAlarm.setDescription('The link error rate estimate at which a link connection will generate an alarm. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm of the estimate (default of 8).')
fddimibPORTConnectState = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("connecting", 2), ("standby", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTConnectState.setReference('ANSI { fddiPORT 61 }')
if mibBuilder.loadTexts: fddimibPORTConnectState.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTConnectState.setDescription('An indication of the connect state of this PORT and is equal to the value of Connect_State (refer to ANSI 9.4.1)')
fddimibPORTPCMState = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("pc0", 1), ("pc1", 2), ("pc2", 3), ("pc3", 4), ("pc4", 5), ("pc5", 6), ("pc6", 7), ("pc7", 8), ("pc8", 9), ("pc9", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTPCMState.setReference('ANSI { fddiPORT 62 }')
if mibBuilder.loadTexts: fddimibPORTPCMState.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTPCMState.setDescription("The state of this Port's PCM state machine refer to ANSI SMT 9.6.2).")
fddimibPORTPCWithhold = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("m-m", 2), ("otherincompatible", 3), ("pathnotavailable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTPCWithhold.setReference('ANSI { fddiPORT 63 }')
if mibBuilder.loadTexts: fddimibPORTPCWithhold.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTPCWithhold.setDescription('The value of PC_Withhold (refer to ANSI SMT 9.4.1).')
fddimibPORTLerFlag = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTLerFlag.setReference('ANSI { fddiPORT 64 }')
if mibBuilder.loadTexts: fddimibPORTLerFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTLerFlag.setDescription('The condition becomes active when the value of fddiPORTLerEstimate is less than or equal to fddiPORTLerAlarm. This will be reported with the Status Report Frames (SRF) (refer to ANSI SMT 7.2.7 and 8.3).')
fddimibPORTHardwarePresent = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddimibPORTHardwarePresent.setReference('ANSI { fddiPORT 65 }')
if mibBuilder.loadTexts: fddimibPORTHardwarePresent.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTHardwarePresent.setDescription('This variable indicates the presence of underlying hardware support for this Port object. If the value of this object is false(2), the reporting of the objects in this entry may be handled in an implementation-specific manner.')
fddimibPORTAction = MibTableColumn((1, 3, 6, 1, 3, 8, 73, 5, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("maintPORT", 2), ("enablePORT", 3), ("disablePORT", 4), ("startPORT", 5), ("stopPORT", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddimibPORTAction.setReference('ANSI { fddiPORT 70 }')
if mibBuilder.loadTexts: fddimibPORTAction.setStatus('mandatory')
if mibBuilder.loadTexts: fddimibPORTAction.setDescription("Causes a Control signal to be generated with a control_action of 'Signal' and the 'variable' parameter set with the appropriate value (i.e., PC_Maint, PC_Enable, PC_Disable, PC_Start, or PC_Stop) (refer to ANSI 9.4.2).")
mibBuilder.exportSymbols("DRAFT-FDDI-MIB-VER-3-2", fddimibMACTransmitCts=fddimibMACTransmitCts, fddimibPORTRequestedPaths=fddimibPORTRequestedPaths, fddimibPATHConfigTable=fddimibPATHConfigTable, fddimibPORTLemCts=fddimibPORTLemCts, fddimibMACTMaxCapability=fddimibMACTMaxCapability, fddimibMACIfIndex=fddimibMACIfIndex, fddimibPATHTVXLowerBound=fddimibPATHTVXLowerBound, fddimibPORTIndex=fddimibPORTIndex, fddimibMACAvailablePaths=fddimibMACAvailablePaths, fddimibMACCounters=fddimibMACCounters, fddimibPORTLerAlarm=fddimibPORTLerAlarm, fddimibPORTConnectionCapabilities=fddimibPORTConnectionCapabilities, fddimibPORTConnectionPolicies=fddimibPORTConnectionPolicies, fddimibPATHConfigEntry=fddimibPATHConfigEntry, fddimibPORTPCMState=fddimibPORTPCMState, fddimibPORTBSFlag=fddimibPORTBSFlag, fddimibMACDaFlag=fddimibMACDaFlag, fddimibSMTConnectionPolicy=fddimibSMTConnectionPolicy, fddimibPORTEntry=fddimibPORTEntry, fddimibSMTUserData=fddimibSMTUserData, fddimibMACHardwarePresent=fddimibMACHardwarePresent, fddimibPATHNumber=fddimibPATHNumber, fddimibPATHIndex=fddimibPATHIndex, fddimibSMTRemoteDisconnectFlag=fddimibSMTRemoteDisconnectFlag, fddimibPORTCurrentPath=fddimibPORTCurrentPath, fddimibMACFrameErrorRatio=fddimibMACFrameErrorRatio, fddi=fddi, fddimibMACUnaDaFlag=fddimibMACUnaDaFlag, fddimibMACTvxValue=fddimibMACTvxValue, fddimibSMTCFState=fddimibSMTCFState, fddimibMACNotCopiedFlag=fddimibMACNotCopiedFlag, fddimibMACOldUpstreamNbr=fddimibMACOldUpstreamNbr, FddiResourceId=FddiResourceId, fddimibMACUpstreamNbr=fddimibMACUpstreamNbr, fddimibSMTMACCts=fddimibSMTMACCts, fddimibMACRingOpCts=fddimibMACRingOpCts, fddimib=fddimib, fddimibMACFrameStatusFunctions=fddimibMACFrameStatusFunctions, fddimibSMTConfigPolicy=fddimibSMTConfigPolicy, fddimibPATHConfigPATHIndex=fddimibPATHConfigPATHIndex, fddimibMACDupAddressTest=fddimibMACDupAddressTest, fddimibPORTNeighborType=fddimibPORTNeighborType, fddimibSMTECMState=fddimibSMTECMState, fddimibPORTLCTFailCts=fddimibPORTLCTFailCts, fddimibSMT=fddimibSMT, fddimibSMTConfigCapabilities=fddimibSMTConfigCapabilities, fddimibMACNotCopiedRatio=fddimibMACNotCopiedRatio, fddimibPATHMaxTReq=fddimibPATHMaxTReq, fddimibSMTMIBVersionId=fddimibSMTMIBVersionId, FddiTimeNano=FddiTimeNano, fddimibSMTLoVersionId=fddimibSMTLoVersionId, fddimibMACLostCts=fddimibMACLostCts, fddimibPORTAction=fddimibPORTAction, fddimibMACDownstreamNbr=fddimibMACDownstreamNbr, fddimibPATHTable=fddimibPATHTable, fddimibMACMAUnitdataEnable=fddimibMACMAUnitdataEnable, fddimibMACCountersEntry=fddimibMACCountersEntry, fddimibSMTStatRptPolicy=fddimibSMTStatRptPolicy, fddimibSMTHiVersionId=fddimibSMTHiVersionId, FddiSMTStationIdType=FddiSMTStationIdType, fddimibPORTPMDClass=fddimibPORTPMDClass, fddimibPORTLemRejectCts=fddimibPORTLemRejectCts, fddimibMACRMTState=fddimibMACRMTState, fddimibPATHSMTIndex=fddimibPATHSMTIndex, fddimibMACTNeg=fddimibMACTNeg, fddimibSMTNonMasterCts=fddimibSMTNonMasterCts, fddimibSMTMasterCts=fddimibSMTMasterCts, fddimibPORTMACPlacement=fddimibPORTMACPlacement, fddimibPORTNumber=fddimibPORTNumber, fddimibMACMAUnitdataAvailable=fddimibMACMAUnitdataAvailable, fddimibMACFrameErrorFlag=fddimibMACFrameErrorFlag, fddimibMACLateCts=fddimibMACLateCts, fddimibSMTOpVersionId=fddimibSMTOpVersionId, fddimibMACTVXCapability=fddimibMACTVXCapability, fddimibPATHConfigResourceType=fddimibPATHConfigResourceType, fddimibMACFrameCts=fddimibMACFrameCts, fddimibSMTStationId=fddimibSMTStationId, fddimibPATHTMaxLowerBound=fddimibPATHTMaxLowerBound, fddimibSMTStationStatus=fddimibSMTStationStatus, fddimibSMTNumber=fddimibSMTNumber, fddimibMACSMTAddress=fddimibMACSMTAddress, fddimibPORTLerEstimate=fddimibPORTLerEstimate, fddimibMACTMax=fddimibMACTMax, FddiTimeMilli=FddiTimeMilli, fddimibMACNotCopiedCts=fddimibMACNotCopiedCts, fddimibPORTTable=fddimibPORTTable, fddimibSMTIndex=fddimibSMTIndex, fddimibMACCurrentPath=fddimibMACCurrentPath, fddimibMACDownstreamPORTType=fddimibMACDownstreamPORTType, fddimibPATH=fddimibPATH, fddimibMACNumber=fddimibMACNumber, fddimibPORTSMTIndex=fddimibPORTSMTIndex, fddimibMACIndex=fddimibMACIndex, fddimibPORTHardwarePresent=fddimibPORTHardwarePresent, fddimibSMTAvailablePaths=fddimibSMTAvailablePaths, fddimibMACTReq=fddimibMACTReq, fddimibPORTPCWithhold=fddimibPORTPCWithhold, FddiMACLongAddressType=FddiMACLongAddressType, fddimibMACNotCopiedThreshold=fddimibMACNotCopiedThreshold, fddimibPORTLerCutoff=fddimibPORTLerCutoff, fddimibPORTLerFlag=fddimibPORTLerFlag, fddimibPATHConfigCurrentPath=fddimibPATHConfigCurrentPath, fddimibSMTTNotify=fddimibSMTTNotify, fddimibMACCopiedCts=fddimibMACCopiedCts, fddimibPORTAvailablePaths=fddimibPORTAvailablePaths, fddimibSMTTable=fddimibSMTTable, fddimibPORTMACIndicated=fddimibPORTMACIndicated, fddimibMACErrorCts=fddimibMACErrorCts, fddimibPATHConfigSMTIndex=fddimibPATHConfigSMTIndex, fddimibPORTConnectState=fddimibPORTConnectState, fddimibSMTTimeStamp=fddimibSMTTimeStamp, fddimibMACEntry=fddimibMACEntry, fddimibSMTBypassPresent=fddimibSMTBypassPresent, fddimibSMTStationAction=fddimibSMTStationAction, fddimibMACCountersTable=fddimibMACCountersTable, fddimibSMTEntry=fddimibSMTEntry, fddimibPATHConfigTokenOrder=fddimibPATHConfigTokenOrder, fddimibMACOldDownstreamNbr=fddimibMACOldDownstreamNbr, fddimibPORT=fddimibPORT, fddimibMACTvxExpiredCts=fddimibMACTvxExpiredCts, fddimibPATHConfigResourceIndex=fddimibPATHConfigResourceIndex, fddimibMACTokenCts=fddimibMACTokenCts, fddimibSMTTraceMaxExpiration=fddimibSMTTraceMaxExpiration, fddimibMACFrameErrorThreshold=fddimibMACFrameErrorThreshold, fddimibMACSMTIndex=fddimibMACSMTIndex, fddimibSMTTransitionTimeStamp=fddimibSMTTransitionTimeStamp, fddimibSMTPeerWrapFlag=fddimibSMTPeerWrapFlag, fddimibMACRequestedPaths=fddimibMACRequestedPaths, fddimibMAC=fddimibMAC, fddimibPORTMyType=fddimibPORTMyType, fddimibPATHEntry=fddimibPATHEntry, fddimibMACTable=fddimibMACTable)

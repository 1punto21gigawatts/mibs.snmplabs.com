#
# PySNMP MIB module MPLS-VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-VPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:52:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
bgp4PathAttrIpAddrPrefix, bgp4PathAttrIpAddrPrefixLen, bgp4PathAttrPeer = mibBuilder.importSymbols("BGP4-MIB", "bgp4PathAttrIpAddrPrefix", "bgp4PathAttrIpAddrPrefixLen", "bgp4PathAttrPeer")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
IpAddress, Gauge32, NotificationType, Counter64, iso, Integer32, Counter32, ObjectIdentity, Unsigned32, experimental, TimeTicks, Bits, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Gauge32", "NotificationType", "Counter64", "iso", "Integer32", "Counter32", "ObjectIdentity", "Unsigned32", "experimental", "TimeTicks", "Bits", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, TruthValue, TimeStamp, StorageType, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue", "TimeStamp", "StorageType", "TextualConvention", "DisplayString")
VPNId, = mibBuilder.importSymbols("VPN-TC-STD-MIB", "VPNId")
mplsVpnMIB = ModuleIdentity((1, 3, 6, 1, 3, 118))
mplsVpnMIB.setRevisions(('2011-03-26 12:00', '2001-02-28 12:00', '2002-01-26 12:00', '2001-11-13 12:00', '2001-10-15 12:00', '2001-10-05 12:00', '2001-07-17 12:00', '2001-07-10 12:00', '2001-06-19 12:00', '2001-05-30 12:00', '2000-09-30 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsVpnMIB.setRevisionsDescriptions(('Changed to import VPNId from VPN-TC-STD-MIB instead of PPVPN-TC-MIB. ', "mplsVpnVrfRouteIfIndex changed to InterfaceIndexOrZero. mplsVpnIfVpnRouteDistProtocol BITS changed to start at 0. Changed notifications to not include indexes. Those indexes' MAX-ACESS changed to not-accessible. Fixed description of mplsVpnIfLabelEdgeType and mplsVpnVrfConfLastChanged. ", 'Removed indexes from notifications. Changed mplsVpnVrfRouteTos to not-accessible as it is used as an index.', 'MPLS PPVPN MIB now assigned IANA experimental 118. Changed mplsVpnVrfRouteTarget from not-accessible to read-create. ', 'Fixed compilation errors from last version. Changed mplsVpnIfVpnRouteDistProtocol to be a BITS structure to allow more than one to be selected. Changed mplsIfDown -> mplsVrfIfDown Changed mplsIfUp -> mplsVrfIfUp ', 'Added integer index and removed route distinguisher index from mplsVpnVrfRouteTargetTable. Removed mplsVpn ifType; simply use mpls(166) ifType for MPLS VPN-enabled interfaces instead. Removed interface and protocol-related objects from mplsVpnVrfTable. Moved mplsVpnVrfConfMaxPossibleRoutes from mplsVpnVrfTable to scalar object. Removed mplsVpnActiveVrfInterfaces scalar object. Removed mplsVpnVrfUpTime object from mplsVpnVrfTable. Added MplsVpnVrfBgpNbrPrefixTable providing a linkage with the bgp4PathAttrTable of the BGPv4 MIB.', "Removed mplsVpnVrfRouteTargetImport/Export from route target table, and modified indexing to better reflect N <> R distribution policy. Also added new object called mplsVpnVrfRouteTargetType which denotes import/export policy for the specified route target. Added mplsVpnIfConfRowStatus which allows for an interface to be associated with a VPN through SNMP configuration. Added VrfName to index of VrfInterfaceConfEntry which allows interfaces to be associated with the appropriate VRF. Modified description of mplsVpnVrfConfMaxPossibleRoutes and mplsVpnVrfConfMaxRoutes to allow for undetermined value. Removed 'both' enumerated value in mplsVpnVrfBgpNbrRole. Updated example to reflect these changes.", 'Renamed mplsNumVrfSecViolationThreshExceeded to mplsNumVrfSecIllglLblThrshExcd, and removed mplsVpnIfConfIndex from varbind. Changed MplsVpnId TC from SnmpAdminString to OCTET STRING. Added mplsVpnVrfSecIllegalLblRcvThrsh to mplsVpnVrfSecEntry. Changed duplicate mplsVpnVrfRouteTargetImport in mplsVpnVrfRouteTargetEntry INDEX to mplsVpnVrfRouteTargetExport.', 'Fixed several compile errors.', 'Updated most of document and MIB to reflect comments from WG.', 'Initial draft version.',))
if mibBuilder.loadTexts: mplsVpnMIB.setLastUpdated('201103261200Z')
if mibBuilder.loadTexts: mplsVpnMIB.setOrganization('Provider Provisioned Virtual Private Networks Working Group.')
if mibBuilder.loadTexts: mplsVpnMIB.setContactInfo(' Thomas D. Nadeau tnadeau@cisco.com Luyuan Fang luyuanfang@att.com Stephen Brannon Fabio M. Chiussi fabio@bell-labs.com Joseph Dube jdube@avici.com Martin Tatham martin.tatham@bt.com Harmen van der Linde hvdl@att.com Comments and discussion to ppvpn@ietf.org')
if mibBuilder.loadTexts: mplsVpnMIB.setDescription('This MIB contains managed object definitions for the Multiprotocol Label Switching (MPLS)/Border Gateway Protocol (BGP) Virtual Private Networks (VPNs) as defined in : Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, RFC3031, January 2001.')
class MplsVpnName(TextualConvention, OctetString):
    reference = "RFC 2685 [VPN-RFC2685] Fox B., et al, 'Virtual Private Networks Identifier', September 1999."
    description = 'An identifier that is assigned to each MPLS/BGP VPN and is used to uniquely identify it. This is assigned by the system operator or NMS and SHOULD be unique throughout the MPLS domain. If this is the case, then this identifier can then be used at any LSR within a specific MPLS domain to identify this MPLS/BGP VPN. It may also be possible to preserve the uniqueness of this identifier across MPLS domain boundaries, in which case this identifier can then be used to uniquely identify MPLS/BGP VPNs on a more global basis. This object MAY be set to the VPN ID as defined in RFC 2685.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class MplsVpnRouteDistinguisher(TextualConvention, OctetString):
    description = 'Syntax for a route distinguisher and route target.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 256)

mplsVpnNotifications = MibIdentifier((1, 3, 6, 1, 3, 118, 0))
mplsVpnObjects = MibIdentifier((1, 3, 6, 1, 3, 118, 1))
mplsVpnScalars = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 1))
mplsVpnConf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 2))
mplsVpnPerf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 3))
mplsVpnRoute = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 4))
mplsVpnConformance = MibIdentifier((1, 3, 6, 1, 3, 118, 3))
mplsVpnConfiguredVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConfiguredVrfs.setStatus('current')
if mibBuilder.loadTexts: mplsVpnConfiguredVrfs.setDescription('The number of VRFs which are configured on this node.')
mplsVpnActiveVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnActiveVrfs.setStatus('current')
if mibBuilder.loadTexts: mplsVpnActiveVrfs.setDescription('The number of VRFs which are active on this node. That is, those VRFs whose corresponding mplsVpnVrfOperStatus object value is equal to operational (1).')
mplsVpnConnectedInterfaces = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConnectedInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnConnectedInterfaces.setDescription('Total number of interfaces connected to a VRF.')
mplsVpnNotificationEnable = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsVpnNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnNotificationEnable.setDescription('If this object is true, then it enables the generation of all notifications defined in this MIB.')
mplsVpnVrfConfMaxPossibleRoutes = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxPossibleRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMaxPossibleRoutes.setDescription('Denotes maximum number of routes which the device will allow all VRFs jointly to hold. If this value is set to 0, this indicates that the device is unable to determine the absolute maximum. In this case, the configured maximum MAY not actually be allowed by the device.')
mplsVpnVrfConfRouteMaxThreshTime = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 6), Unsigned32().clone(600)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfRouteMaxThreshTime.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfRouteMaxThreshTime.setDescription('Denotes the interval in seconds, at which the route max threshold notification will be re-issued after the maximum value has been exceeded (or has been reached if mplsVpnVrfConfMaxRoutes and mplsVpnVrfConfHighRouteThreshold are equal) and the initial notification has been issued. This value is intended to prevent continuous generation of notifications by an agent in the event that routes are continually added to a VRF after it has reached its maximum value. The default value is 10 minutes (600 seconds). If this value is set to 0, the agent should only issue a single notification at the time that the maxium threshold has been reached, and should not issue any more notifications until the value of routes has fallen below the configured threshold value.')
mplsVpnIfConfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 1), )
if mibBuilder.loadTexts: mplsVpnIfConfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfConfTable.setDescription('This table specifies per-interface MPLS capability and associated information.')
mplsVpnIfConfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 1, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnIfConfIndex"))
if mibBuilder.loadTexts: mplsVpnIfConfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfConfEntry.setDescription('An entry in this table is created by an LSR for every interface capable of supporting MPLS/BGP VPN. Each entry in this table is meant to correspond to an entry in the Interfaces Table.')
mplsVpnIfConfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsVpnIfConfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: mplsVpnIfConfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfConfIndex.setDescription('This is a unique index for an entry in the MplsVPNInterfaceConfTable. A non-zero index for an entry indicates the ifIndex for the corresponding interface entry in the MPLS-VPN-layer in the ifTable. Note that this table does not necessarily correspond one-to-one with all entries in the Interface MIB having an ifType of MPLS-layer; rather, only those which are enabled for MPLS/BGP VPN functionality.')
mplsVpnIfLabelEdgeType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("providerEdge", 1), ("customerEdge", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnIfLabelEdgeType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfLabelEdgeType.setDescription('Either the providerEdge(0) (PE) or customerEdge(1) (CE) bit MUST be set.')
mplsVpnIfVpnClassification = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfVpnClassification.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfVpnClassification.setDescription("Denotes whether this link participates in a carrier-of-carrier's, enterprise, or inter-provider scenario.")
mplsVpnIfVpnRouteDistProtocol = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 4), Bits().clone(namedValues=NamedValues(("none", 0), ("bgp", 1), ("ospf", 2), ("rip", 3), ("isis", 4), ("other", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfVpnRouteDistProtocol.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfVpnRouteDistProtocol.setDescription('Denotes the route distribution protocol across the PE-CE link. Note that more than one routing protocol may be enabled at the same time.')
mplsVpnIfConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfConfStorageType.setDescription('The storage type for this entry.')
mplsVpnIfConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfConfRowStatus.setDescription('The row status for this entry. This value is used to create a row in this table, signifying that the specified interface is to be associated with the specified interface. If this operation succeeds, the interface will have been associated, otherwise the agent would not allow the association. If the agent only allows read-only operations on this table, it will create entries in this table as they are created.')
mplsVpnVrfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 2), )
if mibBuilder.loadTexts: mplsVpnVrfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfTable.setDescription('This table specifies per-interface MPLS/BGP VPN VRF Table capability and associated information. Entries in this table define VRF routing instances associated with MPLS/VPN interfaces. Note that multiple interfaces can belong to the same VRF instance. The collection of all VRF instances comprises an actual VPN.')
mplsVpnVrfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 2, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"))
if mibBuilder.loadTexts: mplsVpnVrfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
mplsVpnVrfName = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 1), MplsVpnName())
if mibBuilder.loadTexts: mplsVpnVrfName.setReference('RFC 2685 [VPN-RFC2685] Fox B., et al, `Virtual Private Networks Identifier`, September 1999.')
if mibBuilder.loadTexts: mplsVpnVrfName.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfName.setDescription('The human-readable name of this VPN. This MAY be equivalent to the RFC2685 VPN-ID, but may also vary. If it is set to the VPN ID, it MUST be equivalent to the value of mplsVpnVrfVpnId. It is strongly recommended that all sites supporting VRFs that are part of the same VPN use the same naming convention for VRFs as well as the same VPN ID.')
mplsVpnVrfVpnId = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 2), VPNId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfVpnId.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfVpnId.setDescription('The VPN ID as specified in RFC 2685. If a VPN ID as not been specified for this VRF, then this variable SHOULD be set to an empty string.')
mplsVpnVrfDescription = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfDescription.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfDescription.setDescription('The human-readable description of this VRF.')
mplsVpnVrfRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 4), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDistinguisher.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDistinguisher.setDescription('The route distinguisher for this VRF.')
mplsVpnVrfCreationTime = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfCreationTime.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfCreationTime.setDescription('The time at which this VRF entry was created.')
mplsVpnVrfOperStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfOperStatus.setDescription('Denotes whether a VRF is operational or not. A VRF is up(1) when at least one interface associated with the VRF, which ifOperStatus is up(1). A VRF is down(2) when: a. There does not exist at least one interface whose ifOperStatus is up(1). b. There are no interfaces associated with the VRF.')
mplsVpnVrfActiveInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfActiveInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfActiveInterfaces.setDescription('Total number of interfaces connected to this VRF with ifOperStatus = up(1). This counter should be incremented when: a. When the ifOperStatus of one of the connected interfaces changes from down(2) to up(1). b. When an interface with ifOperStatus = up(1) is connected to this VRF. This counter should be decremented when: a. When the ifOperStatus of one of the connected interfaces changes from up(1) to down(2). b. When one of the connected interfaces with ifOperStatus = up(1) gets disconnected from this VRF.')
mplsVpnVrfAssociatedInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfAssociatedInterfaces.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfAssociatedInterfaces.setDescription('Total number of interfaces connected to this VRF (independent of ifOperStatus type).')
mplsVpnVrfConfMidRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMidRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMidRouteThreshold.setDescription('Denotes mid-level water marker for the number of routes which this VRF may hold.')
mplsVpnVrfConfHighRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfHighRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfHighRouteThreshold.setDescription('Denotes high-level water marker for the number of routes which this VRF may hold.')
mplsVpnVrfConfMaxRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfMaxRoutes.setDescription('Denotes maximum number of routes which this VRF is configured to hold. This value MUST be less than or equal to mplsVrfMaxPossibleRoutes unless it is set to 0.')
mplsVpnVrfConfLastChanged = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfLastChanged.setDescription('The value of sysUpTime at the time of the last change of this table entry, which includes changes of VRF parameters defined in this table or addition or deletion of interfaces associated with this VRF.')
mplsVpnVrfConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsVpnVrfConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 14), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfConfStorageType.setDescription('The storage type for this entry.')
mplsVpnVrfRouteTargetTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 3), )
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetTable.setDescription('This table specifies per-VRF route target association. Each entry identifies a connectivity policy supported as part of a VPN.')
mplsVpnVrfRouteTargetEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 3, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetType"))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetEntry.setDescription(' An entry in this table is created by an LSR for each route target configured for a VRF supporting a MPLS/BGP VPN instance. The indexing provides an ordering per-VRF instance.')
mplsVpnVrfRouteTargetIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetIndex.setDescription('Auxiliary index for route-targets configured for a particular VRF.')
mplsVpnVrfRouteTargetType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("import", 1), ("export", 2), ("both", 3))))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetType.setDescription('The route target export distribution type.')
mplsVpnVrfRouteTarget = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 4), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTarget.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTarget.setDescription('The route target distribution policy.')
mplsVpnVrfRouteTargetDescr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetDescr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetDescr.setDescription('Description of the route target.')
mplsVpnVrfRouteTargetRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetRowStatus.setDescription('Row status for this entry.')
mplsVpnVrfBgpNbrAddrTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 4), )
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrTable.setDescription('Each entry in this table specifies a per-interface MPLS/EBGP neighbor.')
mplsVpnVrfBgpNbrAddrEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 4, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnIfConfIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpNbrIndex"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
mplsVpnVrfBgpNbrIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrIndex.setDescription('This is a unique tertiary index for an entry in the MplsVpnVrfBgpNbrAddrEntry Table.')
mplsVpnVrfBgpNbrRole = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ce", 1), ("pe", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRole.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRole.setDescription('Denotes the role played by this EBGP neighbor with respect to this VRF.')
mplsVpnVrfBgpNbrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrType.setDescription('Denotes the address family of the PE address.')
mplsVpnVrfBgpNbrAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddr.setDescription('Denotes the EBGP neighbor address.')
mplsVpnVrfBgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsVpnVrfBgpNbrStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrStorageType.setDescription('The storage type for this entry.')
mplsVpnVrfBgpNbrPrefixTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 5), )
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixTable.setDescription('This table specifies per-VRF vpnv4 multi-protocol prefixes supported by BGP.')
mplsVpnVrfBgpNbrPrefixEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 5, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "BGP4-MIB", "bgp4PathAttrIpAddrPrefix"), (0, "BGP4-MIB", "bgp4PathAttrIpAddrPrefixLen"), (0, "BGP4-MIB", "bgp4PathAttrPeer"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixEntry.setDescription('An entry in this table is created by an LSR for every BGP prefix associated with a VRF supporting a MPLS/BGP VPN. The indexing provides an ordering of BGP prefixes per VRF.')
mplsVpnVrfBgpPAtrPeer = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 1), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrPeer.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrPeer.setDescription('The IP address of the peer where the path information was learned.')
mplsVpnVrfBgpPAtrIpAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 2), Integer32())
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefixLen.setDescription('Length in bits of the IP address prefix in the Network Layer Reachability Information field.')
mplsVpnVrfBgpPAtrIpAddrPrefix = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefix.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefix.setDescription('An IP address prefix in the Network Layer Reachability Information field. This object is an IP address containing the prefix with length specified by mplsVpnVrfBgpPAtrIpAddrPrefixLen. Any bits beyond the length specified by mplsVpnVrfBgpPAtrIpAddrPrefixLen are zeroed.')
mplsVpnVrfBgpPAtrOrigin = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrOrigin.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrOrigin.setDescription('The ultimate origin of the path information.')
mplsVpnVrfBgpPAtrASPathSegment = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrASPathSegment.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrASPathSegment.setDescription('The sequence of AS path segments. Each AS path segment is represented by a triple <type, length, value>. The type is a 1-octet field which has two possible values: 1 AS_SET: unordered set of ASs a route in the UPDATE message has traversed 2 AS_SEQUENCE: ordered set of ASs a route in the UPDATE message has traversed. The length is a 1-octet field containing the number of ASs in the value field. The value field contains one or more AS numbers, each AS is represented in the octet string as a pair of octets according to the following algorithm: first-byte-of-pair = ASNumber / 256; second-byte-of-pair = ASNumber & 255;')
mplsVpnVrfBgpPAtrNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrNextHop.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrNextHop.setDescription('The address of the border router that should be used for the destination network.')
mplsVpnVrfBgpPAtrMultiExitDisc = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrMultiExitDisc.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrMultiExitDisc.setDescription('This metric is used to discriminate between multiple exit points to an adjacent autonomous system. A value of -1 indicates the absence of this attribute.')
mplsVpnVrfBgpPAtrLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrLocalPref.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrLocalPref.setDescription("The originating BGP4 speaker's degree of preference for an advertised route. A value of -1 indicates the absence of this attribute.")
mplsVpnVrfBgpPAtrAtomicAggregate = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lessSpecificRrouteNotSelected", 1), ("lessSpecificRouteSelected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAtomicAggregate.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAtomicAggregate.setDescription('Whether or not the local system has selected a less specific route without selecting a more specific route.')
mplsVpnVrfBgpPAtrAggregatorAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAS.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAS.setDescription('The AS number of the last BGP4 speaker that performed route aggregation. A value of zero (0) indicates the absence of this attribute.')
mplsVpnVrfBgpPAtrAggregatorAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAddr.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAddr.setDescription('The IP address of the last BGP4 speaker that performed route aggregation. A value of 0.0.0.0 indicates the absence of this attribute.')
mplsVpnVrfBgpPAtrCalcLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrCalcLocalPref.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrCalcLocalPref.setDescription('The degree of preference calculated by the receiving BGP4 speaker for an advertised route. A value of -1 indicates the absence of this attribute.')
mplsVpnVrfBgpPAtrBest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrBest.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrBest.setDescription('An indication of whether or not this route was chosen as the best BGP4 route.')
mplsVpnVrfBgpPAtrUnknown = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrUnknown.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrUnknown.setDescription('One or more path attributes not understood by this BGP4 speaker. Size zero (0) indicates the absence of such attribute(s). Octets beyond the maximum size, if any, are not recorded by this object.')
mplsVpnVrfSecTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 6), )
if mibBuilder.loadTexts: mplsVpnVrfSecTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecTable.setDescription('This table specifies per MPLS/BGP VPN VRF Table security features.')
mplsVpnVrfSecEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 6, 1), )
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfSecEntry"))
mplsVpnVrfSecEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsVpnVrfSecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN. Each entry in this table is used to indicate security-related information for each VRF entry.')
mplsVpnVrfSecIllegalLblVltns = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblVltns.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblVltns.setDescription('Indicates the number of illegally received labels on this VPN/VRF.')
mplsVpnVrfSecIllegalLblRcvThrsh = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblRcvThrsh.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblRcvThrsh.setDescription('The number of illegally received labels above which this notification is issued.')
mplsVpnVrfPerfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 3, 1), )
if mibBuilder.loadTexts: mplsVpnVrfPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfTable.setDescription('This table specifies per MPLS/BGP VPN VRF Table performance information.')
mplsVpnVrfPerfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 3, 1, 1), )
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfPerfEntry"))
mplsVpnVrfPerfEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsVpnVrfPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN.')
mplsVpnVrfPerfRoutesAdded = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesAdded.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesAdded.setDescription('Indicates the number of routes added to this VPN/VRF over the coarse of its lifetime.')
mplsVpnVrfPerfRoutesDeleted = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesDeleted.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesDeleted.setDescription('Indicates the number of routes removed from this VPN/VRF.')
mplsVpnVrfPerfCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfCurrNumRoutes.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfPerfCurrNumRoutes.setDescription('Indicates the number of routes currently used by this VRF.')
mplsVpnVrfRouteTable = MibTable((1, 3, 6, 1, 3, 118, 1, 4, 1), )
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setReference('1. RFC 1213 Section 6.6, The IP Group. 2. RFC 2096 ')
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setDescription('This table specifies per-interface MPLS/BGP VPN VRF Table routing information. Entries in this table define VRF routing entries associated with the specified MPLS/VPN interfaces. Note that this table contains both BGP and IGP routes, as both may appear in the same VRF.')
mplsVpnVrfRouteEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 4, 1, 1), ).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteDest"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteMask"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTos"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteNextHop"))
if mibBuilder.loadTexts: mplsVpnVrfRouteEntry.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteEntry.setDescription('An entry in this table is created by an LSR for every route present configured (either dynamically or statically) within the context of a specific VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
mplsVpnVrfRouteDest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 1), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfRouteDest.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bit-wise logical-AND of x with the value of the corresponding instance of the mplsVpnVrfRouteMask object is not equal to x.')
mplsVpnVrfRouteDestAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDestAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteDestAddrType.setDescription('The address type of the mplsVpnVrfRouteDest entry.')
mplsVpnVrfRouteMask = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 3), InetAddress())
if mibBuilder.loadTexts: mplsVpnVrfRouteMask.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the mplsVpnVrfRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the mplsVpnVrfRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bit-wise logical-AND of x with the value of the corresponding instance of the mplsVpnVrfRouteDest object is not equal to mplsVpnVrfRouteDest.')
mplsVpnVrfRouteMaskAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMaskAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMaskAddrType.setDescription('The address type of mplsVpnVrfRouteMask.')
mplsVpnVrfRouteTos = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 5), Unsigned32())
if mibBuilder.loadTexts: mplsVpnVrfRouteTos.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTos.setDescription('The IP TOS Field is used to specify the policy to be applied to this route. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30.')
mplsVpnVrfRouteNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHop.setDescription('On remote routes, the address of the next system en route; Otherwise, 0.0.0.0. .')
mplsVpnVrfRouteNextHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 7), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAddrType.setDescription('The address type of the mplsVpnVrfRouteNextHopAddrType object.')
mplsVpnVrfRouteIfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. If this value is set to 0, this indicates that no interface is associated with this route.')
mplsVpnVrfRouteType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4) refers to a route for that the next hop is not the final destination. Routes which do not result in traffic forwarding or rejection should not be displayed even if the implementation keeps them stored internally. reject (2) refers to a route which, if matched, discards the message as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
mplsVpnVrfRouteProto = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteProto.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway rout- ing protocols is not intended to imply that hosts should support those protocols.')
mplsVpnVrfRouteAge = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfRouteAge.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
mplsVpnVrfRouteInfo = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 12), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteInfo.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsi- ble for this route, as determined by the value specified in the route's mplsVpnVrfRouteProto value. If this information is not present, its value SHOULD be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identif-ier, and any implementation conforming to ASN.1 and the Basic Encoding Rules must be able to generate and recognize this value.")
mplsVpnVrfRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. When this object is unknown or not relevant its value should be set to zero.")
mplsVpnVrfRouteMetric1 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. If this metric is not used, its value should be set to -1.")
mplsVpnVrfRouteMetric2 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. If this metric is not used, its value should be set to -1.")
mplsVpnVrfRouteMetric3 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. If this metric is not used, its value should be set to -1.")
mplsVpnVrfRouteMetric4 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. If this metric is not used, its value should be set to -1.")
mplsVpnVrfRouteMetric5 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's mplsVpnVrfRouteProto value. If this metric is not used, its value should be set to -1.")
mplsVpnVrfRouteRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteRowStatus.setDescription('Row status for this table. It is used according to row installation and removal conventions.')
mplsVpnVrfRouteStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 20), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteStorageType.setDescription('Storage type value.')
mplsVrfIfUp = NotificationType((1, 3, 6, 1, 3, 118, 0, 1)).setObjects(("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"))
if mibBuilder.loadTexts: mplsVrfIfUp.setStatus('current')
if mibBuilder.loadTexts: mplsVrfIfUp.setDescription('This notification is generated when: a. The ifOperStatus of an interface associated with a VRF changes to the up(1) state. b. When an interface with ifOperStatus = up(1) is associated with a VRF.')
mplsVrfIfDown = NotificationType((1, 3, 6, 1, 3, 118, 0, 2)).setObjects(("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"))
if mibBuilder.loadTexts: mplsVrfIfDown.setStatus('current')
if mibBuilder.loadTexts: mplsVrfIfDown.setDescription('This notification is generated when: a. The ifOperStatus of an interface associated with a VRF changes to the down(1) state. b. When an interface with ifOperStatus = up(1) state is disassociated with a VRF.')
mplsNumVrfRouteMidThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 3)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMidRouteThreshold"))
if mibBuilder.loadTexts: mplsNumVrfRouteMidThreshExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfRouteMidThreshExceeded.setDescription('This notification is generated when the number of routes contained by the specified VRF exceeds the value indicated by mplsVrfMidRouteThreshold. A single notification MUST be generated when this threshold is exceeded, and no other notifications of this type should be issued until the value of mplsVpnVrfPerfCurrNumRoutes has fallen below that of mplsVpnVrfConfMidRouteThreshold.')
mplsNumVrfRouteMaxThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 4)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfHighRouteThreshold"))
if mibBuilder.loadTexts: mplsNumVrfRouteMaxThreshExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfRouteMaxThreshExceeded.setDescription('This notification is generated when the number of routes contained by the specified VRF reaches or attempts to exceed the maximum allowed value as indicated by mplsVrfMaxRouteThreshold. In cases where mplsVpnVrfConfHighRouteThreshold is set to the same value as mplsVpnVrfConfMaxRoutes, mplsVpnVrfConfHighRouteThreshold need not be exceeded; rather, just reached for this notification to be issued. Note that mplsVpnVrfConfRouteMaxThreshTime denotes the interval at which the this notification will be re-issued after the maximum value has been exceeded (or reached if mplsVpnVrfConfMaxRoutes and mplsVpnVrfConfHighRouteThreshold are equal) and the initial notification has been issued. This value is intended to prevent continuous generation of notifications by an agent in the event that routes are continually added to a VRF after it has reached its maximum value. The default value is 10 minutes. If this value is set to 0, the agent should only issue a single notification at the time that the maximum threshold has been reached, and should not issue any more notifications until the value of routes has fallen below the configured threshold value.')
mplsNumVrfSecIllglLblThrshExcd = NotificationType((1, 3, 6, 1, 3, 118, 0, 5)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblVltns"))
if mibBuilder.loadTexts: mplsNumVrfSecIllglLblThrshExcd.setStatus('current')
if mibBuilder.loadTexts: mplsNumVrfSecIllglLblThrshExcd.setDescription('This notification is generated when the number of illegal label violations on a VRF as indicated by mplsVpnVrfSecIllegalLblVltns has exceeded mplsVpnVrfSecIllegalLblRcvThrsh. The threshold is not included in the varbind here because the value of mplsVpnVrfSecIllegalLblVltns should be one greater than the threshold at the time this notification is issued.')
mplsVpnGroups = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 1))
mplsVpnCompliances = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 2))
mplsVpnModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 118, 3, 2, 1)).setObjects(("MPLS-VPN-MIB", "mplsVpnScalarGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfGroup"), ("MPLS-VPN-MIB", "mplsVpnIfGroup"), ("MPLS-VPN-MIB", "mplsVpnPerfGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPrefixGroup"), ("MPLS-VPN-MIB", "mplsVpnSecGroup"), ("MPLS-VPN-MIB", "mplsVpnNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnModuleCompliance = mplsVpnModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsVpnModuleCompliance.setDescription('Compliance statement for agents that support the MPLS VPN MIB.')
mplsVpnScalarGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 1)).setObjects(("MPLS-VPN-MIB", "mplsVpnConfiguredVrfs"), ("MPLS-VPN-MIB", "mplsVpnActiveVrfs"), ("MPLS-VPN-MIB", "mplsVpnConnectedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnNotificationEnable"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxPossibleRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfRouteMaxThreshTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnScalarGroup = mplsVpnScalarGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnScalarGroup.setDescription('Collection of scalar objects required for MPLS VPN management.')
mplsVpnVrfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 2)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfVpnId"), ("MPLS-VPN-MIB", "mplsVpnVrfDescription"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteDistinguisher"), ("MPLS-VPN-MIB", "mplsVpnVrfCreationTime"), ("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfActiveInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfAssociatedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMidRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfConfHighRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfLastChanged"), ("MPLS-VPN-MIB", "mplsVpnVrfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfConfStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfGroup = mplsVpnVrfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfGroup.setDescription('Collection of objects needed for MPLS VPN VRF management.')
mplsVpnIfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 3)).setObjects(("MPLS-VPN-MIB", "mplsVpnIfLabelEdgeType"), ("MPLS-VPN-MIB", "mplsVpnIfVpnClassification"), ("MPLS-VPN-MIB", "mplsVpnIfVpnRouteDistProtocol"), ("MPLS-VPN-MIB", "mplsVpnIfConfStorageType"), ("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnIfGroup = mplsVpnIfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnIfGroup.setDescription('Collection of objects needed for MPLS VPN interface management.')
mplsVpnPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 4)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesAdded"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesDeleted"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnPerfGroup = mplsVpnPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnPerfGroup.setDescription('Collection of objects needed for MPLS VPN performance information.')
mplsVpnVrfBgpNbrGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 5)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRole"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrType"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfBgpNbrGroup = mplsVpnVrfBgpNbrGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrGroup.setDescription('Collection of objects needed for MPLS VPN bgp neighbor-related information.')
mplsVpnVrfBgpPrefixGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 6)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrOrigin"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrASPathSegment"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrNextHop"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrMultiExitDisc"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAtomicAggregate"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAggregatorAS"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAggregatorAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrCalcLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrBest"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrUnknown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfBgpPrefixGroup = mplsVpnVrfBgpPrefixGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfBgpPrefixGroup.setDescription('Collection of objects needed for MPLS VPN bgp neighbor-related information.')
mplsVpnSecGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 7)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblVltns"), ("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblRcvThrsh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnSecGroup = mplsVpnSecGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnSecGroup.setDescription('Collection of objects needed for MPLS VPN security-related information.')
mplsVpnVrfRouteGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 8)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfRouteDestAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMaskAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHop"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteIfIndex"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteProto"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteAge"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteInfo"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAS"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric1"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric2"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric3"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric4"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric5"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfRouteGroup = mplsVpnVrfRouteGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteGroup.setDescription('Objects required for VRF route table management.')
mplsVpnVrfRouteTargetGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 9)).setObjects(("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetDescr"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTarget"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnVrfRouteTargetGroup = mplsVpnVrfRouteTargetGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetGroup.setDescription('Objects required for VRF route target management.')
mplsVpnNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 118, 3, 1, 10)).setObjects(("MPLS-VPN-MIB", "mplsVrfIfUp"), ("MPLS-VPN-MIB", "mplsVrfIfDown"), ("MPLS-VPN-MIB", "mplsNumVrfRouteMidThreshExceeded"), ("MPLS-VPN-MIB", "mplsNumVrfRouteMaxThreshExceeded"), ("MPLS-VPN-MIB", "mplsNumVrfSecIllglLblThrshExcd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsVpnNotificationGroup = mplsVpnNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsVpnNotificationGroup.setDescription('Objects required for MPLS VPN notifications.')
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVrfIfDown=mplsVrfIfDown, mplsVpnIfConfEntry=mplsVpnIfConfEntry, mplsVpnVrfConfMidRouteThreshold=mplsVpnVrfConfMidRouteThreshold, mplsVpnVrfRouteMask=mplsVpnVrfRouteMask, mplsVpnVrfBgpPAtrCalcLocalPref=mplsVpnVrfBgpPAtrCalcLocalPref, mplsVpnVrfPerfTable=mplsVpnVrfPerfTable, mplsVpnVrfBgpPAtrOrigin=mplsVpnVrfBgpPAtrOrigin, mplsVpnVrfSecIllegalLblRcvThrsh=mplsVpnVrfSecIllegalLblRcvThrsh, mplsVpnVrfRouteStorageType=mplsVpnVrfRouteStorageType, mplsVpnVrfRouteNextHopAddrType=mplsVpnVrfRouteNextHopAddrType, mplsVpnVrfBgpPAtrIpAddrPrefixLen=mplsVpnVrfBgpPAtrIpAddrPrefixLen, mplsVpnScalars=mplsVpnScalars, mplsVpnVrfRouteIfIndex=mplsVpnVrfRouteIfIndex, mplsNumVrfRouteMaxThreshExceeded=mplsNumVrfRouteMaxThreshExceeded, mplsVpnVrfGroup=mplsVpnVrfGroup, mplsVpnVrfRouteMaskAddrType=mplsVpnVrfRouteMaskAddrType, mplsVpnNotifications=mplsVpnNotifications, mplsVpnVrfBgpNbrRowStatus=mplsVpnVrfBgpNbrRowStatus, mplsNumVrfSecIllglLblThrshExcd=mplsNumVrfSecIllglLblThrshExcd, mplsVpnVrfBgpPAtrAtomicAggregate=mplsVpnVrfBgpPAtrAtomicAggregate, mplsVpnVrfRouteEntry=mplsVpnVrfRouteEntry, mplsVpnVrfRouteMetric5=mplsVpnVrfRouteMetric5, mplsVpnVrfBgpPAtrIpAddrPrefix=mplsVpnVrfBgpPAtrIpAddrPrefix, mplsVpnVrfBgpNbrRole=mplsVpnVrfBgpNbrRole, mplsVpnVrfBgpNbrPrefixEntry=mplsVpnVrfBgpNbrPrefixEntry, mplsVpnNotificationGroup=mplsVpnNotificationGroup, mplsVpnVrfOperStatus=mplsVpnVrfOperStatus, mplsVpnVrfConfMaxRoutes=mplsVpnVrfConfMaxRoutes, mplsVpnVrfRouteTargetType=mplsVpnVrfRouteTargetType, mplsVpnVrfSecIllegalLblVltns=mplsVpnVrfSecIllegalLblVltns, mplsVpnVrfBgpNbrAddrTable=mplsVpnVrfBgpNbrAddrTable, mplsVpnVrfRouteDistinguisher=mplsVpnVrfRouteDistinguisher, mplsVpnCompliances=mplsVpnCompliances, mplsVpnVrfConfMaxPossibleRoutes=mplsVpnVrfConfMaxPossibleRoutes, mplsVpnVrfSecTable=mplsVpnVrfSecTable, mplsVrfIfUp=mplsVrfIfUp, mplsVpnVrfBgpPAtrAggregatorAS=mplsVpnVrfBgpPAtrAggregatorAS, mplsVpnVrfRouteAge=mplsVpnVrfRouteAge, mplsVpnVrfBgpNbrGroup=mplsVpnVrfBgpNbrGroup, mplsVpnRoute=mplsVpnRoute, mplsVpnIfConfStorageType=mplsVpnIfConfStorageType, mplsVpnVrfPerfCurrNumRoutes=mplsVpnVrfPerfCurrNumRoutes, mplsVpnIfVpnClassification=mplsVpnIfVpnClassification, mplsVpnVrfPerfRoutesDeleted=mplsVpnVrfPerfRoutesDeleted, mplsVpnGroups=mplsVpnGroups, mplsVpnVrfSecEntry=mplsVpnVrfSecEntry, mplsVpnVrfDescription=mplsVpnVrfDescription, mplsVpnIfConfIndex=mplsVpnIfConfIndex, mplsVpnVrfRouteTable=mplsVpnVrfRouteTable, mplsNumVrfRouteMidThreshExceeded=mplsNumVrfRouteMidThreshExceeded, mplsVpnVrfRouteGroup=mplsVpnVrfRouteGroup, mplsVpnIfGroup=mplsVpnIfGroup, mplsVpnVrfRouteMetric4=mplsVpnVrfRouteMetric4, PYSNMP_MODULE_ID=mplsVpnMIB, mplsVpnVrfAssociatedInterfaces=mplsVpnVrfAssociatedInterfaces, mplsVpnVrfTable=mplsVpnVrfTable, mplsVpnConf=mplsVpnConf, mplsVpnConformance=mplsVpnConformance, mplsVpnVrfRouteMetric1=mplsVpnVrfRouteMetric1, mplsVpnVrfRouteTargetDescr=mplsVpnVrfRouteTargetDescr, mplsVpnVrfEntry=mplsVpnVrfEntry, mplsVpnIfLabelEdgeType=mplsVpnIfLabelEdgeType, mplsVpnIfVpnRouteDistProtocol=mplsVpnIfVpnRouteDistProtocol, mplsVpnVrfBgpPAtrMultiExitDisc=mplsVpnVrfBgpPAtrMultiExitDisc, mplsVpnVrfRouteDest=mplsVpnVrfRouteDest, mplsVpnVrfBgpPAtrNextHop=mplsVpnVrfBgpPAtrNextHop, mplsVpnMIB=mplsVpnMIB, mplsVpnVrfRouteInfo=mplsVpnVrfRouteInfo, mplsVpnVrfBgpPAtrBest=mplsVpnVrfBgpPAtrBest, mplsVpnVrfBgpPAtrUnknown=mplsVpnVrfBgpPAtrUnknown, mplsVpnVrfRouteMetric3=mplsVpnVrfRouteMetric3, mplsVpnVrfBgpPAtrLocalPref=mplsVpnVrfBgpPAtrLocalPref, mplsVpnPerfGroup=mplsVpnPerfGroup, mplsVpnVrfBgpNbrIndex=mplsVpnVrfBgpNbrIndex, mplsVpnVrfBgpNbrAddrEntry=mplsVpnVrfBgpNbrAddrEntry, mplsVpnVrfPerfEntry=mplsVpnVrfPerfEntry, mplsVpnVrfRouteTargetRowStatus=mplsVpnVrfRouteTargetRowStatus, mplsVpnScalarGroup=mplsVpnScalarGroup, mplsVpnVrfConfHighRouteThreshold=mplsVpnVrfConfHighRouteThreshold, mplsVpnPerf=mplsVpnPerf, mplsVpnVrfRouteProto=mplsVpnVrfRouteProto, mplsVpnVrfName=mplsVpnVrfName, mplsVpnVrfConfRouteMaxThreshTime=mplsVpnVrfConfRouteMaxThreshTime, mplsVpnVrfCreationTime=mplsVpnVrfCreationTime, mplsVpnVrfActiveInterfaces=mplsVpnVrfActiveInterfaces, mplsVpnObjects=mplsVpnObjects, mplsVpnVrfVpnId=mplsVpnVrfVpnId, mplsVpnVrfRouteTargetTable=mplsVpnVrfRouteTargetTable, mplsVpnVrfConfLastChanged=mplsVpnVrfConfLastChanged, mplsVpnVrfBgpPAtrAggregatorAddr=mplsVpnVrfBgpPAtrAggregatorAddr, mplsVpnSecGroup=mplsVpnSecGroup, mplsVpnVrfBgpNbrAddr=mplsVpnVrfBgpNbrAddr, mplsVpnVrfRouteTos=mplsVpnVrfRouteTos, mplsVpnVrfRouteTargetGroup=mplsVpnVrfRouteTargetGroup, mplsVpnActiveVrfs=mplsVpnActiveVrfs, mplsVpnVrfRouteMetric2=mplsVpnVrfRouteMetric2, MplsVpnName=MplsVpnName, mplsVpnVrfRouteNextHop=mplsVpnVrfRouteNextHop, mplsVpnVrfPerfRoutesAdded=mplsVpnVrfPerfRoutesAdded, MplsVpnRouteDistinguisher=MplsVpnRouteDistinguisher, mplsVpnVrfRouteDestAddrType=mplsVpnVrfRouteDestAddrType, mplsVpnVrfRouteType=mplsVpnVrfRouteType, mplsVpnVrfConfRowStatus=mplsVpnVrfConfRowStatus, mplsVpnVrfRouteTarget=mplsVpnVrfRouteTarget, mplsVpnModuleCompliance=mplsVpnModuleCompliance, mplsVpnVrfRouteTargetIndex=mplsVpnVrfRouteTargetIndex, mplsVpnVrfRouteRowStatus=mplsVpnVrfRouteRowStatus, mplsVpnIfConfTable=mplsVpnIfConfTable, mplsVpnVrfBgpNbrPrefixTable=mplsVpnVrfBgpNbrPrefixTable, mplsVpnVrfBgpPrefixGroup=mplsVpnVrfBgpPrefixGroup, mplsVpnVrfBgpPAtrASPathSegment=mplsVpnVrfBgpPAtrASPathSegment, mplsVpnVrfRouteNextHopAS=mplsVpnVrfRouteNextHopAS, mplsVpnNotificationEnable=mplsVpnNotificationEnable, mplsVpnConnectedInterfaces=mplsVpnConnectedInterfaces, mplsVpnVrfConfStorageType=mplsVpnVrfConfStorageType, mplsVpnConfiguredVrfs=mplsVpnConfiguredVrfs, mplsVpnIfConfRowStatus=mplsVpnIfConfRowStatus, mplsVpnVrfRouteTargetEntry=mplsVpnVrfRouteTargetEntry, mplsVpnVrfBgpNbrType=mplsVpnVrfBgpNbrType, mplsVpnVrfBgpPAtrPeer=mplsVpnVrfBgpPAtrPeer, mplsVpnVrfBgpNbrStorageType=mplsVpnVrfBgpNbrStorageType)

#
# PySNMP MIB module ITOUCH-BRIDGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ITOUCH-BRIDGE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:57:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
dot1dTpFdbAddress, MacAddress = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dTpFdbAddress", "MacAddress")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
iTouch, = mibBuilder.importSymbols("ITOUCH-MIB", "iTouch")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, ObjectIdentity, MibIdentifier, Integer32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, Bits, Unsigned32, TimeTicks, Counter64, Gauge32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ObjectIdentity", "MibIdentifier", "Integer32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "Bits", "Unsigned32", "TimeTicks", "Counter64", "Gauge32", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
bridgeDep = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 5))
xBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 19))
xBridgeSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 19, 1))
xBridgeProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 19, 3))
xBridgeFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 19, 4))
bridgeState = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeState.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeState.setDescription('Controls whether the bridge will perform bridging.')
bridgeEarlyLoopState = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeEarlyLoopState.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEarlyLoopState.setDescription('Controls whether the bridge will implement the early loop detection algorithm of restarting the Spanning Tree Protocol when a packet is received from a source on one interface when the source was learned on a different interface.')
bridgeEarlyLoopCount = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeEarlyLoopCount.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEarlyLoopCount.setDescription('The number of times that an early loop was detected while the early loop state was enabled.')
bridgeEarlyLoopAddress = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeEarlyLoopAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEarlyLoopAddress.setDescription('The last address to cause an early loop to be detected while the early loop state was enabled.')
bridgeSpanningTreeState = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeSpanningTreeState.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeSpanningTreeState.setDescription('Controls whether the bridge will run the Spanning Tree Protocol.')
bridgeFilterDiscardTimeout = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(43200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeFilterDiscardTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterDiscardTimeout.setDescription('The number of seconds before an inactive filter is deleted. Learned filters become inactive when the use timeout (dot1dTpAgingTime) has been exceeded.')
bridgeTopologyState = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stable", 1), ("changing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeTopologyState.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTopologyState.setDescription("Indicates whether the Spanning Tree Protocol's topology is stable or changing.")
bridgeTopologyChangeAddr = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeTopologyChangeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTopologyChangeAddr.setDescription('The ethernet address of the last bridge from which a Topology Change Notification packet was received.')
bridgeProtocolFilterState = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeProtocolFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolFilterState.setDescription('Controls whether protocol filtering is active.')
bridgeProtocolDefaultPriority = MibScalar((1, 3, 6, 1, 4, 1, 33, 19, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 101))).clone(namedValues=NamedValues(("low", 1), ("medium", 3), ("high", 5), ("discard", 101))).clone('medium')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeProtocolDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolDefaultPriority.setDescription('Controls the default priority if no entry exists for the protocol.')
bridgeProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 33, 19, 3, 3), )
if mibBuilder.loadTexts: bridgeProtocolTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolTable.setDescription('A list of bridge protocol filters.')
bridgeProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1), ).setIndexNames((0, "ITOUCH-BRIDGE-MIB", "bridgeProtocolProtocol"))
if mibBuilder.loadTexts: bridgeProtocolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolEntry.setDescription('Bridge protocol filter entry.')
bridgeProtocolProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeProtocolProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolProtocol.setDescription('The protocol type associated with the entry. The value 65536 is for all 802.3 MAC frames.')
bridgeProtocolName = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeProtocolName.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolName.setDescription('The name associated with the protocol.')
bridgeProtocolPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 101))).clone(namedValues=NamedValues(("low", 1), ("medium", 3), ("high", 5), ("discard", 101))).clone('medium')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeProtocolPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolPriority.setDescription('The priority or action to take with the protocol.')
bridgeProtocolUses = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeProtocolUses.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolUses.setDescription('The number of times the filter has been used.')
bridgeProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtocolStatus.setDescription("The status of the protocol entry. Set to 'invalid' to remove the entry.")
bridgeFilterTable = MibTable((1, 3, 6, 1, 4, 1, 33, 19, 4, 1), )
if mibBuilder.loadTexts: bridgeFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterTable.setDescription('A list of bridge filters.')
bridgeFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 19, 4, 1, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dTpFdbAddress"))
if mibBuilder.loadTexts: bridgeFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterEntry.setDescription('Bridge filter entry.')
bridgeFilterForwardSubPort = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 4, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeFilterForwardSubPort.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterForwardSubPort.setDescription('The unique identifier from which the address has been seen within the port. It is the DLCI for frame relay or VC for X25.')
bridgeFilterUses = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeFilterUses.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterUses.setDescription('The number of times the filter has been used for forwarding packets.')
bridgeFilterAge = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeFilterAge.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterAge.setDescription('The number of seconds that a learned filter has been active or inactive. This value has no meaning for non-learned filters.')
bridgeFilterLinkTable = MibTable((1, 3, 6, 1, 4, 1, 33, 19, 4, 2), )
if mibBuilder.loadTexts: bridgeFilterLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterLinkTable.setDescription('Bridge filtering characteristics of all links.')
bridgeFilterLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 19, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bridgeFilterLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterLinkEntry.setDescription('Bridge filtering characteristics of a specific link.')
bridgeFilterLinkOverflowCam = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 19, 4, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeFilterLinkOverflowCam.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeFilterLinkOverflowCam.setDescription('Identifies the number of extra entries in a hardware assist filter CAM that the user wants to have available to cover CAM entry overflow conditions. If filtering hardware is present, this field defaults to 400. Otherwise, it is zero.')
mibBuilder.exportSymbols("ITOUCH-BRIDGE-MIB", bridgeProtocolEntry=bridgeProtocolEntry, xBridgeFilter=xBridgeFilter, bridgeFilterLinkTable=bridgeFilterLinkTable, bridgeFilterTable=bridgeFilterTable, bridgeProtocolName=bridgeProtocolName, bridgeEarlyLoopAddress=bridgeEarlyLoopAddress, bridgeProtocolFilterState=bridgeProtocolFilterState, bridgeState=bridgeState, bridgeEarlyLoopCount=bridgeEarlyLoopCount, bridgeFilterUses=bridgeFilterUses, bridgeEarlyLoopState=bridgeEarlyLoopState, bridgeFilterEntry=bridgeFilterEntry, bridgeDep=bridgeDep, bridgeProtocolTable=bridgeProtocolTable, bridgeSpanningTreeState=bridgeSpanningTreeState, bridgeProtocolPriority=bridgeProtocolPriority, bridgeFilterAge=bridgeFilterAge, bridgeTopologyState=bridgeTopologyState, xBridgeProtocol=xBridgeProtocol, bridgeFilterLinkOverflowCam=bridgeFilterLinkOverflowCam, bridgeProtocolUses=bridgeProtocolUses, bridgeFilterDiscardTimeout=bridgeFilterDiscardTimeout, bridgeTopologyChangeAddr=bridgeTopologyChangeAddr, bridgeFilterLinkEntry=bridgeFilterLinkEntry, bridgeProtocolStatus=bridgeProtocolStatus, xBridge=xBridge, bridgeProtocolProtocol=bridgeProtocolProtocol, xBridgeSystem=xBridgeSystem, bridgeFilterForwardSubPort=bridgeFilterForwardSubPort, bridgeProtocolDefaultPriority=bridgeProtocolDefaultPriority)

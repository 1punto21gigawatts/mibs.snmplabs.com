#
# PySNMP MIB module DLINK-3100-TIMESYNCHRONIZATION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DLINK-3100-TIMESYNCHRONIZATION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:49:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
rnd, = mibBuilder.importSymbols("DLINK-3100-MIB", "rnd")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, ObjectIdentity, TimeTicks, Unsigned32, Counter32, Gauge32, Integer32, NotificationType, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "TimeTicks", "Unsigned32", "Counter32", "Gauge32", "Integer32", "NotificationType", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "iso", "Counter64")
RowStatus, TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "DisplayString")
rlTimeSynchronization = ModuleIdentity((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92))
rlTimeSynchronization.setRevisions(('2009-06-18 00:24', '2007-09-06 00:24', '2003-11-23 00:24',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlTimeSynchronization.setRevisionsDescriptions(('Added support in DHCP timezone option.', 'Added rlClockStatus', 'Initial revision',))
if mibBuilder.loadTexts: rlTimeSynchronization.setLastUpdated('200408030024Z')
if mibBuilder.loadTexts: rlTimeSynchronization.setOrganization('DLINK-3100 Computer Communication Ltd.')
if mibBuilder.loadTexts: rlTimeSynchronization.setContactInfo('www.dlink.com')
if mibBuilder.loadTexts: rlTimeSynchronization.setDescription('The MIB module describes the private MIB for SNTP & TIME definitions.')
rlTimeSyncMethodMode = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1))
rlSntpNtpClient = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2))
rlSntpNtpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1))
rlSntpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2))
rlNtpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 3))
class NTPTimeStamp(TextualConvention, OctetString):
    reference = "D.L. Mills, 'Network Time Protocol (Version 3)', RFC-1305, March 1992, Section 3.1"
    description = 'NTP timestamps are represented as a 64-bit unsigned fixed-point number, in seconds relative to 00:00 on 1 January 1900. The integer part is in the first 32 bits and the fraction part is in the last 32 bits.'
    status = 'current'
    displayHint = '4d.4d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class NTPSignedTimeValue(TextualConvention, OctetString):
    description = 'The time in seconds that could represent signed quantities like time delay with respect to some source. This textual-convention is specific to DLINK-3100 implementation of NTP where 32-bit integers are used for such quantities. The signed integer part is in the first 16 bits and the fraction part is in the last 16 bits.'
    status = 'current'
    displayHint = '2d.2d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class NTPStratum(TextualConvention, Integer32):
    reference = "D.L. Mills, 'Network Time Protocol (Version 3)', RFC-1305, March 1992, Section 2.2"
    description = 'Indicates the stratum of the clock. The stratum defines the accuracy of a time server. Higher the stratum, lower the accuracy. 0, unspecified 1, primary reference (e.g., calibrated atomic clock, radio clock) 2-255, secondary reference (via NTP)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class RlTimeSyncMethod(TextualConvention, Integer32):
    description = 'Method to be used for time synchronization in the device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("sntp", 2), ("ntp", 3))

class RlDaylightSavingTimeMode(TextualConvention, Integer32):
    description = 'Daylight Saving Time - Recurring/Date/None.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("recurring", 1), ("date", 2), ("none", 3))

rlTimeSyncMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTimeSyncMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlTimeSyncMibVersion.setDescription('TimeSync Mib Version.')
rndTimeSyncManagedTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedTime.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedTime.setDescription('The time will be sent in the format hhmmss')
rndTimeSyncManagedDate = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedDate.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedDate.setDescription('The date will be sent in the format ddmmyy')
rndTimeSyncManagedDateTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedDateTime.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedDateTime.setDescription('The date and time will be sent in the format ddmmyyhhmmss')
rlTimeSyncMethod = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 5), RlTimeSyncMethod().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeSyncMethod.setStatus('current')
if mibBuilder.loadTexts: rlTimeSyncMethod.setDescription('Method to be used for time synchronization in the device.')
rlTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZone.setStatus('current')
if mibBuilder.loadTexts: rlTimeZone.setDescription('Offset from Greenwich time (format [+/-]hh:mm).')
rlTimeZoneCode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneCode.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneCode.setDescription('Code definition for current TimeZone.')
rlDaylightSavingTimeMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 8), RlDaylightSavingTimeMode().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeMode.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeMode.setDescription('Daylight Saving Time - Recurring/Date/None.')
rlDaylightSavingTimeStart = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeStart.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeStart.setDescription('Daylight Saving Time start date. In recurring mode (format 1): week wday month hh:mm In recurring mode (format 2): RJul n hh:mm In date mode: month day year hh:mm week: 0-6 (0=First, 6=Last) wday: 1-7 (Sunday-Saturday) month: 1-12 (January-December) day: 1-31 year: 0-99 (2000-2099) hh: 0-23 (hours) mm: 0-59 (minutes) n: 0-365 (zero-based Julian day of the year. Leap days shall be counted, and it is possible to refer to February 29). Format 2 for recurring mode is used only in the dynamic entry and should not be used in the static entry (with index 1).')
rlDaylightSavingTimeEnd = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeEnd.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeEnd.setDescription('Daylight Saving Time start date. In recurring mode (format 1): week wday month hh:mm In recurring mode (format 2): RJul n hh:mm In date mode: month day year hh:mm week: 0-6 (0=First, 6=Last) wday: 1-7 (Sunday-Saturday) month: 1-12 (January-December) day: 1-31 year: 0-99 (2000-2099) hh: 0-23 (hours) mm: 0-59 (minutes) n: 0-365 (zero-based Julian day of the year. Leap days shall be counted, and it is possible to refer to February 29). Format 2 for recurring mode is used only in the dynamic entry and should not be used in the static entry (with index 1).')
rlDaylightSavingTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 11), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeOffset.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeOffset.setDescription('Daylight Saving Time - The number of minutes to add to the clock during summer time.')
rlDaylightSavingTimeCode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeCode.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeCode.setDescription('Code definition for current Daylight Saving Time.')
rlTZDSTOffset = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTZDSTOffset.setStatus('current')
if mibBuilder.loadTexts: rlTZDSTOffset.setDescription('Local Time Zone and Daylight Saving Time offset in seconds.')
rlTimeZoneName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneName.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneName.setDescription('Human readable string describing Local Time Zone and Daylight Saving Time.')
rlTimeZoneTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15), )
if mibBuilder.loadTexts: rlTimeZoneTable.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTable.setDescription('TimeZone information.')
rlTimeZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlTimeZoneIndex"))
if mibBuilder.loadTexts: rlTimeZoneEntry.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneEntry.setDescription('The row definition for this table.')
rlTimeZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: rlTimeZoneIndex.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneIndex.setDescription('Entry index. A row with index 2 will be existing in case the DHCP timezone is supported, and will contain Timezone and Summertime dynamic values. Using index 2 in SET operations is allowed only for SNMP inner clients (SNMPServ users), on condition that DHCP timezone option is supported.')
rlTimeZoneTimeSyncMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 2), RlTimeSyncMethod().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneTimeSyncMethod.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTimeSyncMethod.setDescription('Method to be used for time synchronization in the device.')
rlTimeZoneTimeZoneOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneTimeZoneOffset.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTimeZoneOffset.setDescription('Offset from Greenwich time (format [+/-]hh:mm).')
rlTimeZoneTimeZoneCode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneTimeZoneCode.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTimeZoneCode.setDescription('Code definition for current TimeZone.')
rlTimeZoneDaylightSavingTimeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 5), RlDaylightSavingTimeMode().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeMode.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeMode.setDescription('Daylight Saving Time - Recurring/Date/None.')
rlTimeZoneDaylightSavingTimeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeStart.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeStart.setDescription('Daylight Saving Time start date. In recurring mode (format 1): week wday month hh:mm In recurring mode (format 2): RJul n hh:mm In date mode: month day year hh:mm week: 0-6 (0=First, 6=Last) wday: 1-7 (Sunday-Saturday) month: 1-12 (January-December) day: 1-31 year: 0-99 (2000-2099) hh: 0-23 (hours) mm: 0-59 (minutes) n: 0-365 (zero-based Julian day of the year. Leap days shall be counted, and it is possible to refer to February 29). Format 2 for recurring mode is used only in the dynamic entry and should not be used in the static entry (with index 1).')
rlTimeZoneDaylightSavingTimeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeEnd.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeEnd.setDescription('Daylight Saving Time start date. In recurring mode (format 1): week wday month hh:mm In recurring mode (format 2): RJul n hh:mm In date mode: month day year hh:mm week: 0-6 (0=First, 6=Last) wday: 1-7 (Sunday-Saturday) month: 1-12 (January-December) day: 1-31 year: 0-99 (2000-2099) hh: 0-23 (hours) mm: 0-59 (minutes) n: 0-365 (zero-based Julian day of the year. Leap days shall be counted, and it is possible to refer to February 29). Format 2 for recurring mode is used only in the dynamic entry and should not be used in the static entry (with index 1).')
rlTimeZoneDaylightSavingTimeOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 8), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeOffset.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeOffset.setDescription('Daylight Saving Time - The number of minutes to add to the clock during summer time.')
rlTimeZoneDaylightSavingTimeCode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeCode.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDaylightSavingTimeCode.setDescription('Code definition for current Daylight Saving Time.')
rlTimeZoneTZDSTOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTimeZoneTZDSTOffset.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTZDSTOffset.setDescription('Local Time Zone and Daylight Saving Time offset in seconds.')
rlTimeZoneTimeZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneTimeZoneName.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneTimeZoneName.setDescription('Human readable string describing Local Time Zone and Daylight Saving Time.')
rlTimeZoneDataType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2))).clone('static')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTimeZoneDataType.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDataType.setDescription('The type of data in this entry: static or dynamic.')
rlTimeZoneDataSourceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 15, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneDataSourceIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneDataSourceIfIndex.setDescription('IfIndex of the interface through which the dynamic data of this row has been learned. The value of this field will be 0 if rlTimeZoneTimeDataType is static (since it is relevant only for dynamic entry), and this is the only value allowed for SET in this case.')
rlClockStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("manuallySet", 2), ("synchronizedBySntp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlClockStatus.setStatus('current')
if mibBuilder.loadTexts: rlClockStatus.setDescription("Current status of the clock. The value 'invalid' means time is meaninglesss, since it has neither been manually configured nor achieved as a result of SNTP synchronization.")
rlDhcpTimezoneOptionEnabled = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 1, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDhcpTimezoneOptionEnabled.setStatus('current')
if mibBuilder.loadTexts: rlDhcpTimezoneOptionEnabled.setDescription('Specifies whether the DHCP Timezone option (DHCPv4 option 100) is supported in the system. Setting this value to FALSE, will clear Timezone and Summertime dynamic configuration, so that: 1) rlTimeZoneTimeZoneCode and rlTimeZoneDaylightSavingTimeCode length will be 0 for rlTimeZoneEntry whose index = 2 (dynamic entry). 2) the operative values of Timezone and Summertime will be those statically configured. Thus, GET operations on the following MIB scalars will result is static values: rlTimeZone, rlTimeZoneCode, rlDaylightSavingTimeMode, rlDaylightSavingTimeStart, rlDaylightSavingTimeEnd, rlDaylightSavingTimeOffset, rlDaylightSavingTimeCode, rlTZDSTOffset.')
class RlSntpNtpSyncType(TextualConvention, Integer32):
    description = 'Method to be used for time synchronization in the device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("unicast", 2), ("anycast", 3), ("broadcast", 4))

class RlSntpNtpSyncEntryType(TextualConvention, Integer32):
    description = 'Entry in rlSntpNtpConfigSrvTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("primaryPollSrv", 1), ("syncSrv", 2))

rlSntpNtpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpMibVersion.setDescription('SntpNtp Mib Version.')
rlSntpNtpConfigMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("unicast", 2), ("anycast", 3), ("multicast", 4), ("unicastAnycast", 5), ("unicastMulticast", 6), ("anycastMulticast", 7), ("unicastAnycastMulticast", 8))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigMode.setDescription('Current configuration operational mode of SNTP/NTP client.')
rlSntpNtpConfigSysStratum = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSysStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSysStratum.setDescription('The stratum of the local clock. If the value is set to 1, i.e., this is a primary reference, then the Primary-Clock procedure described in Section 3.4.6, in RFC-1305 is invoked.')
rlSntpNtpConfigPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 4), Integer32().clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpNtpConfigPollInterval.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPollInterval.setDescription('Period of time (in seconds) between succesive attempts to perform an update via SNTP.')
rlSntpNtpConfigPrimaryPollSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvAddr.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvAddr.setDescription('Ip Address of a trusted SNTP server for polling.')
rlSntpNtpConfigPrimaryPollSrvMrid = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvMrid.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvMrid.setDescription('The mrid of the primary server.')
rlSntpNtpConfigPrimaryPollSrvIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvIfIndex.setDescription('The interface addressed of the primary server.')
rlSntpNtpConfigPrimaryPollSrvStratum = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 8), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvStratum.setDescription('The stratum of the primary polling server.')
rlSntpNtpConfigSyncSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvAddr.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvAddr.setDescription('Ip Address of the synced server.')
rlSntpNtpConfigSyncSrvMrid = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvMrid.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvMrid.setDescription('The mrid of the synced server.')
rlSntpNtpConfigSyncSrvIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvIfIndex.setDescription('The interface addressed of the synced server.')
rlSntpNtpConfigSyncSrvType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 12), RlSntpNtpSyncType().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvType.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvType.setDescription('Synced server type.')
rlSntpNtpConfigSyncSrvStratum = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 13), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvStratum.setDescription('The stratum of the synced server.')
rlSntpNtpConfigRetryTimeout = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigRetryTimeout.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigRetryTimeout.setDescription('SNTP/NTP requests Retry Interval.')
rlSntpNtpConfigRetryCnt = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigRetryCnt.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigRetryCnt.setDescription('SNTP/NTP requests Retry Count.')
rlSntpNtpConfigSrvTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16), )
if mibBuilder.loadTexts: rlSntpNtpConfigSrvTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvTable.setDescription('A table containing information about config servers.')
rlSntpNtpConfigSrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpNtpConfigSrvEntryType"))
if mibBuilder.loadTexts: rlSntpNtpConfigSrvEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvEntry.setDescription('Entry in rlSntpNtpConfigSrvTable.')
rlSntpNtpConfigSrvEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 1), RlSntpNtpSyncEntryType())
if mibBuilder.loadTexts: rlSntpNtpConfigSrvEntryType.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvEntryType.setDescription('Server type: Synchronize Server or Primary Poll Server.')
rlSntpNtpConfigSrvInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvInetAddressType.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvInetAddressType.setDescription('Server inet address type.')
rlSntpNtpConfigSrvInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvInetAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvInetAddress.setDescription('Server inet address.')
rlSntpNtpConfigSrvMrid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvMrid.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvMrid.setDescription('The mrid of the server.')
rlSntpNtpConfigSrvIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvIfIndex.setDescription('The interface addressed of the server.')
rlSntpNtpConfigSrvSyncType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 6), RlSntpNtpSyncType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvSyncType.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvSyncType.setDescription('The type of synchronization.')
rlSntpNtpConfigSrvStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 1, 16, 1, 7), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSrvStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSrvStratum.setDescription('The stratum of the synced server.')
rlSntpClientMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("active", 2), ("passive", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpClientMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpClientMode.setDescription('Current operational mode of SNTP client.')
rlSntpUnicastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpUnicastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpUnicastAdminState.setDescription('SNTP Unicast Administrative state - Enable/Disable SNTP. In case of reinitializing polling or time synchronization this MIB is modified. The MIB can be enabled even thought it is already enabled.')
rlSntpBroadcastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastAdminState.setDescription('SNTP Broadcast Administrative state - Enable/Disable SNTP. In case of reinitializing polling or time synchronization this MIB is modified. The MIB can be enabled even thought it is already enabled.')
rlSntpAnycastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastAdminState.setDescription('SNTP Anycast Administrative state - Enable/Disable SNTP. In case of reinitializing polling or time synchronization this MIB is modified. The MIB can be enabled even thought it is already enabled.')
rlSntpUnicastPollState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpUnicastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpUnicastPollState.setDescription('SNTP Unicast poll state - TRUE for polled.')
rlSntpBroadcastPollState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastPollState.setDescription('SNTP Broadcast poll state - TRUE for polled.')
rlSntpAnycastPollState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastPollState.setDescription('SNTP Anycast poll state - TRUE for polled.')
rlSntpAuthenticationState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationState.setDescription('SNTP authentication state- Enable/Disable SNTP.')
rlTimeValidFlag = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeValidFlag.setStatus('current')
if mibBuilder.loadTexts: rlTimeValidFlag.setDescription('Is time valid.')
rlSntpConfigBroadcastTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10), )
if mibBuilder.loadTexts: rlSntpConfigBroadcastTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigBroadcastTable.setDescription('A table containing broadcast mode information per interface.')
rlSntpBroadcastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpBroadcastIfIndex"))
if mibBuilder.loadTexts: rlSntpBroadcastEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastEntry.setDescription('Private paramters for interface: sntp status, broadcast mode.')
rlSntpBroadcastIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpBroadcastIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastIfIndex.setDescription('The interface addressed by this entry.')
rlSntpBroadcastIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastIfAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastIfAdminState.setDescription('SNTP interface Adminstrative state- Enable/Disable SNTP. In case of reinitializing polling or time synchronization this MIB is modified. The MIB can be enabled even thought it is already enabled.')
rlSntpBroadcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("receive", 2), ("send", 3), ("receiveSend", 4))).clone('receiveSend')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastMode.setDescription('SNTP/NTP Broadcast Mode. none - no broadcast SNTP packets are received or sent. Receive - host only receive SNTP packets that were sent to broadcast address (were not directed to the host). This is multicast mode in the RFC. Send - host only send SNTP packets and wait for replies directed to the host. This is anycast mode in the RFC. ReceiveSend - host receive broadcast messages (destination is broadcast address in the received messages) and send SNTP packets to wait for replies directed to the host (destination address of the reply is the host address). This mode combines anycast and multicast modes in the RFC.')
rlSntpBroadcastPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpBroadcastStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 6), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastStratum.setDescription('The stratum of this server.')
rlSntpBroadcastLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 7), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastLastResp.setDescription('SNTP Broadcast Last Response Time')
rlSntpBroadcastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastStatus.setDescription('The Operational State of the remote IP Address of the SNTP Broadcast. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpBroadcastOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 9), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpBroadcastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 10), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpBroadcastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 10, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastRowStatus.setDescription('The Status of this SNTP broadcast interface information.')
rlSntpConfigAnycastTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11), )
if mibBuilder.loadTexts: rlSntpConfigAnycastTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigAnycastTable.setDescription('A table containing anycast information per interface.')
rlSntpAnycastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpAnycastIfIndex"))
if mibBuilder.loadTexts: rlSntpAnycastEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastEntry.setDescription('Private paramters for interface: server info.')
rlSntpAnycastIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpAnycastIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastIfIndex.setDescription('The interface addressed by this entry.')
rlSntpAnycastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpAnycastStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastStratum.setDescription('The stratum of this server.')
rlSntpAnycastLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 4), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastLastResp.setDescription('SNTP Anycast Last Response Time')
rlSntpAnycastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastStatus.setDescription('The Operational State of the remote IP Address of the SNTP Anycast. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpAnycastOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 6), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpAnycastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 7), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpAnycastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 11, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastRowStatus.setDescription('The Status of this SNTP anycast interface information.')
rlSntpConfigServerTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12), )
if mibBuilder.loadTexts: rlSntpConfigServerTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigServerTable.setDescription('A table containing trusted SNTP servers to be queried in unicast or broadcast mode.')
rlSntpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpServerAddress"))
if mibBuilder.loadTexts: rlSntpServerEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerEntry.setDescription('A trusted server.')
rlSntpServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 1), IpAddress())
if mibBuilder.loadTexts: rlSntpServerAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpServerPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpServerStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerStratum.setDescription('The stratum of this server.')
rlSntpServerLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 4), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerLastResp.setDescription('SNTP Server Last Response Time')
rlSntpServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerStatus.setDescription('The Operational State of the remote IP Address of the SNTP Server. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpServersOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 6), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServersOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpServersDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 7), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServersDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpServersKeyIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServersKeyIdentifier.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersKeyIdentifier.setDescription('Authentication key identifier. The valid range is 1-4294967295. Value zero, means no authentication is being done.')
rlSntpServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 12, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerRowStatus.setDescription('The Status of this SNTP server information.')
rlSntpConfigAuthenticationTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13), )
if mibBuilder.loadTexts: rlSntpConfigAuthenticationTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigAuthenticationTable.setDescription('A table authentication keys.')
rlSntpAuthenticationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpAuthenticationKeyID"))
if mibBuilder.loadTexts: rlSntpAuthenticationEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationEntry.setDescription('Keys information for authenticationof NTP packets.')
rlSntpAuthenticationKeyID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyID.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyID.setDescription('The key identifier. Valid rabge for key identifier is 1-4294967295.')
rlSntpAuthenticationKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyValue.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyValue.setDescription('Key value.')
rlSntpAuthenticationKeyState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyState.setDescription('Authentication key state - Enable/Disable key.')
rlSntpAuthenticationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 13, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationRowStatus.setDescription('The Status of this Authentication key information.')
rlSntpPort = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(123)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpPort.setStatus('current')
if mibBuilder.loadTexts: rlSntpPort.setDescription('User defined SNTP port.')
rlSntpConfigBroadcastInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15), )
if mibBuilder.loadTexts: rlSntpConfigBroadcastInetTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigBroadcastInetTable.setDescription('A table containing broadcast mode information per interface.')
rlSntpBroadcastInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpBroadcastInetIfIndex"))
if mibBuilder.loadTexts: rlSntpBroadcastInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetEntry.setDescription('Private paramters for interface: sntp status, broadcast mode.')
rlSntpBroadcastInetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpBroadcastInetIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetIfIndex.setDescription('The interface addressed by this entry.')
rlSntpBroadcastInetIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastInetIfAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetIfAdminState.setDescription('SNTP interface Adminstrative state- Enable/Disable SNTP. In case of reinitializing polling or time synchronization this MIB is modified. The MIB can be enabled even thought it is already enabled.')
rlSntpBroadcastInetMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("receive", 2), ("send", 3), ("receiveSend", 4))).clone('receiveSend')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastInetMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetMode.setDescription('SNTP/NTP Broadcast Mode. none - no broadcast SNTP packets are received or sent. Receive - host only receive SNTP packets that were sent to broadcast address (were not directed to the host). This is multicast mode in the RFC. Send - host only send SNTP packets and wait for replies directed to the host. This is anycast mode in the RFC. ReceiveSend - host receive broadcast messages (destination is broadcast address in the received messages) and send SNTP packets to wait for replies directed to the host (destination address of the reply is the host address). This mode combines anycast and multicast modes in the RFC.')
rlSntpBroadcastInetPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastInetPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpBroadcastInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetAddressType.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetAddressType.setDescription('Inet Address Type of a trusted SNTP server.')
rlSntpBroadcastInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetAddress.setDescription('Inet Address of a trusted SNTP server.')
rlSntpBroadcastInetStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 7), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetStratum.setDescription('The stratum of this server.')
rlSntpBroadcastInetLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 8), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetLastResp.setDescription('SNTP Broadcast Last Response Time')
rlSntpBroadcastInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetStatus.setDescription('The Operational State of the remote IP Address of the SNTP Broadcast. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpBroadcastInetOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 10), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpBroadcastInetDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 11), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastInetDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpBroadcastInetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 15, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastInetRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastInetRowStatus.setDescription('The Status of this SNTP broadcast interface information.')
rlSntpConfigAnycastInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16), )
if mibBuilder.loadTexts: rlSntpConfigAnycastInetTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigAnycastInetTable.setDescription('A table containing anycast information per interface.')
rlSntpAnycastInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpAnycastInetIfIndex"))
if mibBuilder.loadTexts: rlSntpAnycastInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetEntry.setDescription('Private paramters for interface: server info.')
rlSntpAnycastInetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpAnycastInetIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetIfIndex.setDescription('The interface addressed by this entry.')
rlSntpAnycastInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetAddressType.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetAddressType.setDescription('Inet Address Type of a trusted SNTP server.')
rlSntpAnycastInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetAddress.setDescription('Inet Address of a trusted SNTP server.')
rlSntpAnycastInetStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 4), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetStratum.setDescription('The stratum of this server.')
rlSntpAnycastInetLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 5), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetLastResp.setDescription('SNTP Anycast Last Response Time')
rlSntpAnycastInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetStatus.setDescription('The Operational State of the remote IP Address of the SNTP Anycast. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpAnycastInetOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 7), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpAnycastInetDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 8), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastInetDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpAnycastInetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 16, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastInetRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastInetRowStatus.setDescription('The Status of this SNTP anycast interface information.')
rlSntpConfigServerInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17), )
if mibBuilder.loadTexts: rlSntpConfigServerInetTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigServerInetTable.setDescription('A table containing trusted SNTP servers to be queried in unicast or broadcast mode.')
rlSntpServerInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1), ).setIndexNames((0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpServerInetAddressType"), (0, "DLINK-3100-TIMESYNCHRONIZATION-MIB", "rlSntpServerInetAddress"))
if mibBuilder.loadTexts: rlSntpServerInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetEntry.setDescription('A trusted server.')
rlSntpServerInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlSntpServerInetAddressType.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetAddressType.setDescription('Inet Address Type of a trusted SNTP server.')
rlSntpServerInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlSntpServerInetAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetAddress.setDescription('Inet Address of a trusted SNTP server.')
rlSntpServerInetPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerInetPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpServerInetStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 4), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerInetStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetStratum.setDescription('The stratum of this server.')
rlSntpServerInetLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 5), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerInetLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetLastResp.setDescription('SNTP Server Last Response Time')
rlSntpServerInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetStatus.setDescription('The Operational State of the remote IP Address of the SNTP Server. unknown - requests were not sent yet. inProcess - replies were not received yet. up - server sent SNTP packets. down - server stopped sending SNTP packets.')
rlSntpServerInetOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 7), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerInetOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetOffset.setDescription("The estimated offset of the server's clock relative to the local clock, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpServerInetDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 8), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerInetDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetDelay.setDescription("The estimated round-trip delay of the server's clock relative to the local clock over the network path between them, in seconds. The host determines the value of this object using the algorithm described in RFC 2030.")
rlSntpServerInetKeyIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerInetKeyIdentifier.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetKeyIdentifier.setDescription('Authentication key identifier. The valid range is 1-4294967295. Value zero, means no authentication is being done.')
rlSntpServerInetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 92, 2, 2, 17, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerInetRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerInetRowStatus.setDescription('The Status of this SNTP server information.')
mibBuilder.exportSymbols("DLINK-3100-TIMESYNCHRONIZATION-MIB", NTPTimeStamp=NTPTimeStamp, rlSntpBroadcastRowStatus=rlSntpBroadcastRowStatus, rlSntpServerInetStratum=rlSntpServerInetStratum, rlTimeZoneTZDSTOffset=rlTimeZoneTZDSTOffset, rlSntpConfigBroadcastTable=rlSntpConfigBroadcastTable, rlSntpNtpConfigSrvEntryType=rlSntpNtpConfigSrvEntryType, rlDaylightSavingTimeMode=rlDaylightSavingTimeMode, rlSntpAnycastIfIndex=rlSntpAnycastIfIndex, rlSntpAnycastStratum=rlSntpAnycastStratum, rlSntpNtpConfigSrvMrid=rlSntpNtpConfigSrvMrid, rlSntpBroadcastIfAdminState=rlSntpBroadcastIfAdminState, rlSntpNtpConfigSrvInetAddress=rlSntpNtpConfigSrvInetAddress, rlSntpAnycastInetRowStatus=rlSntpAnycastInetRowStatus, rlSntpNtpConfig=rlSntpNtpConfig, NTPStratum=NTPStratum, rlSntpBroadcastInetDelay=rlSntpBroadcastInetDelay, rlSntpNtpConfigRetryTimeout=rlSntpNtpConfigRetryTimeout, rlSntpAnycastInetStatus=rlSntpAnycastInetStatus, rlSntpAnycastAddress=rlSntpAnycastAddress, rlSntpServerInetLastResp=rlSntpServerInetLastResp, rlSntpBroadcastInetAddressType=rlSntpBroadcastInetAddressType, rlTimeSyncMethodMode=rlTimeSyncMethodMode, rlSntpBroadcastInetLastResp=rlSntpBroadcastInetLastResp, rlNtpConfig=rlNtpConfig, rlSntpServerPolled=rlSntpServerPolled, RlSntpNtpSyncEntryType=RlSntpNtpSyncEntryType, rlTimeZoneEntry=rlTimeZoneEntry, rlSntpAnycastInetIfIndex=rlSntpAnycastInetIfIndex, rlSntpBroadcastPollState=rlSntpBroadcastPollState, PYSNMP_MODULE_ID=rlTimeSynchronization, rlDaylightSavingTimeStart=rlDaylightSavingTimeStart, rlSntpNtpConfigSrvIfIndex=rlSntpNtpConfigSrvIfIndex, rlSntpAnycastInetLastResp=rlSntpAnycastInetLastResp, rlSntpAuthenticationEntry=rlSntpAuthenticationEntry, rlSntpAnycastLastResp=rlSntpAnycastLastResp, rlSntpConfigAnycastTable=rlSntpConfigAnycastTable, rlSntpAnycastRowStatus=rlSntpAnycastRowStatus, rlSntpConfigServerInetTable=rlSntpConfigServerInetTable, rlSntpBroadcastDelay=rlSntpBroadcastDelay, rlTimeZoneIndex=rlTimeZoneIndex, rlTimeZoneDaylightSavingTimeCode=rlTimeZoneDaylightSavingTimeCode, rlSntpAnycastInetStratum=rlSntpAnycastInetStratum, rlSntpNtpConfigSyncSrvIfIndex=rlSntpNtpConfigSyncSrvIfIndex, rlSntpAnycastOffset=rlSntpAnycastOffset, rlSntpServerInetKeyIdentifier=rlSntpServerInetKeyIdentifier, RlDaylightSavingTimeMode=RlDaylightSavingTimeMode, rlSntpAnycastStatus=rlSntpAnycastStatus, rlSntpServersOffset=rlSntpServersOffset, rlSntpBroadcastInetAddress=rlSntpBroadcastInetAddress, rndTimeSyncManagedTime=rndTimeSyncManagedTime, RlSntpNtpSyncType=RlSntpNtpSyncType, rlSntpNtpConfigPollInterval=rlSntpNtpConfigPollInterval, rlSntpAnycastInetOffset=rlSntpAnycastInetOffset, rlSntpConfig=rlSntpConfig, rlDaylightSavingTimeEnd=rlDaylightSavingTimeEnd, rlSntpBroadcastInetIfAdminState=rlSntpBroadcastInetIfAdminState, rlSntpConfigServerTable=rlSntpConfigServerTable, rlSntpServerInetEntry=rlSntpServerInetEntry, rlSntpNtpConfigSyncSrvMrid=rlSntpNtpConfigSyncSrvMrid, rlSntpServerAddress=rlSntpServerAddress, rlTimeValidFlag=rlTimeValidFlag, rlSntpAuthenticationRowStatus=rlSntpAuthenticationRowStatus, rlSntpUnicastPollState=rlSntpUnicastPollState, rlSntpNtpConfigSyncSrvAddr=rlSntpNtpConfigSyncSrvAddr, rlSntpNtpConfigSyncSrvType=rlSntpNtpConfigSyncSrvType, rlSntpBroadcastInetOffset=rlSntpBroadcastInetOffset, rlTimeZoneCode=rlTimeZoneCode, rlSntpBroadcastStratum=rlSntpBroadcastStratum, rlSntpAuthenticationKeyState=rlSntpAuthenticationKeyState, rlSntpAnycastDelay=rlSntpAnycastDelay, rlSntpAnycastInetDelay=rlSntpAnycastInetDelay, rlSntpConfigAuthenticationTable=rlSntpConfigAuthenticationTable, rlTimeZoneDaylightSavingTimeOffset=rlTimeZoneDaylightSavingTimeOffset, rlSntpClientMode=rlSntpClientMode, rlSntpBroadcastInetPolled=rlSntpBroadcastInetPolled, rlSntpBroadcastAdminState=rlSntpBroadcastAdminState, rlSntpBroadcastPolled=rlSntpBroadcastPolled, rlSntpBroadcastInetStatus=rlSntpBroadcastInetStatus, rlSntpBroadcastLastResp=rlSntpBroadcastLastResp, rndTimeSyncManagedDate=rndTimeSyncManagedDate, rlClockStatus=rlClockStatus, rlSntpServersDelay=rlSntpServersDelay, rlSntpBroadcastEntry=rlSntpBroadcastEntry, rlTimeZone=rlTimeZone, rlSntpNtpConfigRetryCnt=rlSntpNtpConfigRetryCnt, rlSntpBroadcastInetIfIndex=rlSntpBroadcastInetIfIndex, rlSntpConfigAnycastInetTable=rlSntpConfigAnycastInetTable, rlSntpServerInetRowStatus=rlSntpServerInetRowStatus, rlSntpServerInetPolled=rlSntpServerInetPolled, rlSntpBroadcastMode=rlSntpBroadcastMode, rlSntpServerInetAddress=rlSntpServerInetAddress, rlSntpServerInetOffset=rlSntpServerInetOffset, rlSntpNtpConfigPrimaryPollSrvIfIndex=rlSntpNtpConfigPrimaryPollSrvIfIndex, rlSntpBroadcastAddress=rlSntpBroadcastAddress, rlTimeZoneDataType=rlTimeZoneDataType, rlTimeSyncMethod=rlTimeSyncMethod, rlSntpNtpConfigMode=rlSntpNtpConfigMode, rlSntpBroadcastIfIndex=rlSntpBroadcastIfIndex, rlSntpBroadcastInetStratum=rlSntpBroadcastInetStratum, rlSntpBroadcastInetRowStatus=rlSntpBroadcastInetRowStatus, rlTimeZoneDaylightSavingTimeStart=rlTimeZoneDaylightSavingTimeStart, rlSntpNtpConfigPrimaryPollSrvAddr=rlSntpNtpConfigPrimaryPollSrvAddr, rlSntpServerRowStatus=rlSntpServerRowStatus, rlTimeZoneTimeZoneOffset=rlTimeZoneTimeZoneOffset, rlTimeSynchronization=rlTimeSynchronization, rlSntpServersKeyIdentifier=rlSntpServersKeyIdentifier, NTPSignedTimeValue=NTPSignedTimeValue, rlSntpServerStatus=rlSntpServerStatus, rlSntpNtpConfigPrimaryPollSrvMrid=rlSntpNtpConfigPrimaryPollSrvMrid, rlSntpServerInetAddressType=rlSntpServerInetAddressType, rlSntpAnycastEntry=rlSntpAnycastEntry, rlDaylightSavingTimeCode=rlDaylightSavingTimeCode, rlSntpAnycastAdminState=rlSntpAnycastAdminState, rlTimeZoneTimeZoneName=rlTimeZoneTimeZoneName, RlTimeSyncMethod=RlTimeSyncMethod, rlSntpBroadcastOffset=rlSntpBroadcastOffset, rlSntpConfigBroadcastInetTable=rlSntpConfigBroadcastInetTable, rlTimeZoneTable=rlTimeZoneTable, rlSntpNtpConfigSrvSyncType=rlSntpNtpConfigSrvSyncType, rlTimeZoneDaylightSavingTimeEnd=rlTimeZoneDaylightSavingTimeEnd, rlSntpPort=rlSntpPort, rlSntpServerStratum=rlSntpServerStratum, rlTimeZoneDataSourceIfIndex=rlTimeZoneDataSourceIfIndex, rlSntpServerEntry=rlSntpServerEntry, rlSntpAnycastInetEntry=rlSntpAnycastInetEntry, rlSntpNtpConfigSrvEntry=rlSntpNtpConfigSrvEntry, rlSntpNtpClient=rlSntpNtpClient, rlDhcpTimezoneOptionEnabled=rlDhcpTimezoneOptionEnabled, rlSntpAuthenticationState=rlSntpAuthenticationState, rlSntpAuthenticationKeyID=rlSntpAuthenticationKeyID, rlTimeSyncMibVersion=rlTimeSyncMibVersion, rlSntpAnycastPollState=rlSntpAnycastPollState, rndTimeSyncManagedDateTime=rndTimeSyncManagedDateTime, rlSntpNtpConfigSrvStratum=rlSntpNtpConfigSrvStratum, rlSntpBroadcastInetEntry=rlSntpBroadcastInetEntry, rlSntpNtpConfigSrvInetAddressType=rlSntpNtpConfigSrvInetAddressType, rlTimeZoneTimeSyncMethod=rlTimeZoneTimeSyncMethod, rlTimeZoneDaylightSavingTimeMode=rlTimeZoneDaylightSavingTimeMode, rlSntpNtpConfigSrvTable=rlSntpNtpConfigSrvTable, rlSntpServerLastResp=rlSntpServerLastResp, rlSntpNtpConfigPrimaryPollSrvStratum=rlSntpNtpConfigPrimaryPollSrvStratum, rlSntpBroadcastInetMode=rlSntpBroadcastInetMode, rlSntpNtpConfigSysStratum=rlSntpNtpConfigSysStratum, rlSntpBroadcastStatus=rlSntpBroadcastStatus, rlSntpAnycastInetAddressType=rlSntpAnycastInetAddressType, rlSntpUnicastAdminState=rlSntpUnicastAdminState, rlDaylightSavingTimeOffset=rlDaylightSavingTimeOffset, rlSntpNtpConfigSyncSrvStratum=rlSntpNtpConfigSyncSrvStratum, rlTZDSTOffset=rlTZDSTOffset, rlTimeZoneName=rlTimeZoneName, rlTimeZoneTimeZoneCode=rlTimeZoneTimeZoneCode, rlSntpServerInetDelay=rlSntpServerInetDelay, rlSntpNtpMibVersion=rlSntpNtpMibVersion, rlSntpAnycastInetAddress=rlSntpAnycastInetAddress, rlSntpAuthenticationKeyValue=rlSntpAuthenticationKeyValue, rlSntpServerInetStatus=rlSntpServerInetStatus)

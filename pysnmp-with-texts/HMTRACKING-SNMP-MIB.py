#
# PySNMP MIB module HMTRACKING-SNMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HMTRACKING-SNMP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
hmConfiguration, = mibBuilder.importSymbols("HMPRIV-MGMT-SNMP-MIB", "hmConfiguration")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Counter32, TimeTicks, MibIdentifier, Bits, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, NotificationType, ModuleIdentity, Gauge32, IpAddress, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter32", "TimeTicks", "MibIdentifier", "Bits", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "NotificationType", "ModuleIdentity", "Gauge32", "IpAddress", "iso")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
hmTracking = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 14, 15))
hmTracking.setRevisions(('2007-09-13 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmTracking.setRevisionsDescriptions(('First release in SMIv2',))
if mibBuilder.loadTexts: hmTracking.setLastUpdated('200709131200Z')
if mibBuilder.loadTexts: hmTracking.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmTracking.setContactInfo('Customer Support Postal: Hirschmann Automation and Control GmbH Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Tel: +49 7127 14 1981 Web: http://www.hicomcenter.com/ E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmTracking.setDescription('The Hirschmann Private Tracking MIB definitions for Platform devices.')
hmTrackingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 15, 1))
hmTrackingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1), )
if mibBuilder.loadTexts: hmTrackingTable.setStatus('current')
if mibBuilder.loadTexts: hmTrackingTable.setDescription('This table contains variables to define an entry in the Hirschmann Tracking database.')
hmTrackingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1), ).setIndexNames((0, "HMTRACKING-SNMP-MIB", "hmTrackId"))
if mibBuilder.loadTexts: hmTrackingEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrackingEntry.setDescription('The entry of the hmTrackingTable.')
hmTrackId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackId.setStatus('current')
if mibBuilder.loadTexts: hmTrackId.setDescription('The id of an object being tracked.')
hmTrackRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 2), RowStatus().clone('notReady')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmTrackRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmTrackRowStatus.setDescription('Defines the status of the Tracking database entry. Set to createAndWait(5) to create a new row. Set to destroy(6) to delete an entry. Set to notInService(2) to change an entry. Reads as active(1) if the tracked object exists and is trackable, notReady(3) otherwise.')
hmTrackType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("interface", 2), ("ping", 3), ("logical", 4))).clone('undefined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackType.setStatus('current')
if mibBuilder.loadTexts: hmTrackType.setDescription('The kind of an object being tracked.')
hmTrackState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackState.setStatus('current')
if mibBuilder.loadTexts: hmTrackState.setDescription('Shows if the tracked object is currently UP or DOWN.')
hmTrackNumberOfChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackNumberOfChanges.setStatus('current')
if mibBuilder.loadTexts: hmTrackNumberOfChanges.setDescription('The number of state changes after an object being tracked, entered its operational state. If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value.')
hmTrackTimeSinceLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackTimeSinceLastChange.setStatus('current')
if mibBuilder.loadTexts: hmTrackTimeSinceLastChange.setDescription('The time difference to the last state change of an object being tracked (in hundredths of a second). If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value.')
hmTrackIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackIfNumber.setStatus('current')
if mibBuilder.loadTexts: hmTrackIfNumber.setDescription('The number of the interface being tracked. The number of the interface to send ping packets. For ping objects the value 65535 is used to show that no valid interface number has been set. It cannot be written.')
hmTrackIfLinkUpDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackIfLinkUpDelay.setStatus('current')
if mibBuilder.loadTexts: hmTrackIfLinkUpDelay.setDescription('If a link-up recovers within this delay, the tracked object is not considered as up.')
hmTrackIfLinkDownDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackIfLinkDownDelay.setStatus('current')
if mibBuilder.loadTexts: hmTrackIfLinkDownDelay.setDescription('If a link-down recovers within this delay, the tracked object is not considered as down.')
hmTrackPingIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingIpAddress.setDescription('The IP address of the router being monitored.')
hmTrackPingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingInterval.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingInterval.setDescription('The number of seconds between the pings to the target IP address.')
hmTrackPingMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingMiss.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingMiss.setDescription('This specifies the number of consecutive ping misses until the tracked object is considered to be down.')
hmTrackPingSuccess = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingSuccess.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingSuccess.setDescription('This specifies the number of consecutive ping successes until the tracked object is considered to be up.')
hmTrackPingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(100)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingTimeout.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingTimeout.setDescription('This specifies the timeout in milliseconds for a ping reply. After the timeout the ping reply is considered as lost.')
hmTrackPingTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackPingTTL.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingTTL.setDescription('This specifies the time to live for a ping request packet.')
hmTrackPingBestRouteIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 16), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackPingBestRouteIfNumber.setStatus('current')
if mibBuilder.loadTexts: hmTrackPingBestRouteIfNumber.setDescription('This shows the number of the interface which belongs to the best route. The interface number is zero if the best route is not used to send ping packets.')
hmTrackLogicalOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("and", 1), ("or", 2))).clone('or')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackLogicalOperator.setStatus('current')
if mibBuilder.loadTexts: hmTrackLogicalOperator.setDescription('Defines the logical operation performed on the instances')
hmTrackSendStateChangeTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrackSendStateChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hmTrackSendStateChangeTrap.setDescription('Enables or disables the sending of a trap when hmTrackState changes')
hmTrackingApplicationTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 2), )
if mibBuilder.loadTexts: hmTrackingApplicationTable.setStatus('current')
if mibBuilder.loadTexts: hmTrackingApplicationTable.setDescription('This table contains information about registered applications, for each object being tracked.')
hmTrackingApplicationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 2, 1), ).setIndexNames((0, "HMTRACKING-SNMP-MIB", "hmTrackId"), (0, "HMTRACKING-SNMP-MIB", "hmTrackAppId"))
if mibBuilder.loadTexts: hmTrackingApplicationEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrackingApplicationEntry.setDescription('The entry of the hmTrackingApplicationTable.')
hmTrackAppId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 2, 1, 2), Integer32())
if mibBuilder.loadTexts: hmTrackAppId.setStatus('current')
if mibBuilder.loadTexts: hmTrackAppId.setDescription('The id of an application which tracks an object.')
hmTrackAppName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrackAppName.setStatus('current')
if mibBuilder.loadTexts: hmTrackAppName.setDescription('The name of the registered application.')
hmTrackLogicalInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 3), )
if mibBuilder.loadTexts: hmTrackLogicalInstanceTable.setStatus('current')
if mibBuilder.loadTexts: hmTrackLogicalInstanceTable.setDescription('This table contains information the tracking instances that are combined into a logical tracking instance.')
hmTrackLogicalInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 3, 1), ).setIndexNames((0, "HMTRACKING-SNMP-MIB", "hmTrackId"), (0, "HMTRACKING-SNMP-MIB", "hmTrackLogicalInstanceId"))
if mibBuilder.loadTexts: hmTrackLogicalInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrackLogicalInstanceEntry.setDescription('The entry of the hmTrackLogicalInstanceTable.')
hmTrackLogicalInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 3, 1, 2), Integer32())
if mibBuilder.loadTexts: hmTrackLogicalInstanceId.setStatus('current')
if mibBuilder.loadTexts: hmTrackLogicalInstanceId.setDescription('The id of an object that is a member of the logical tracking object.')
hmTrackLogicInstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 3, 1, 3), RowStatus().clone('notReady')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmTrackLogicInstRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmTrackLogicInstRowStatus.setDescription('Defines the status of the Logic Tracking member entry. Set to createAndGo(4) to create a new row. Set to destroy(6) to delete an entry. Reads as active(1) if the row exists.')
hmTrackEvent = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 0))
if mibBuilder.loadTexts: hmTrackEvent.setStatus('current')
if mibBuilder.loadTexts: hmTrackEvent.setDescription('The events of hmTrackEvent.')
hmTrackStatusChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 15, 1, 0, 1)).setObjects(("HMTRACKING-SNMP-MIB", "hmTrackId"), ("HMTRACKING-SNMP-MIB", "hmTrackRowStatus"), ("HMTRACKING-SNMP-MIB", "hmTrackState"))
if mibBuilder.loadTexts: hmTrackStatusChangeEvent.setStatus('current')
if mibBuilder.loadTexts: hmTrackStatusChangeEvent.setDescription('Sent when the state of a tracking instance changes between up and down.')
mibBuilder.exportSymbols("HMTRACKING-SNMP-MIB", hmTrackNumberOfChanges=hmTrackNumberOfChanges, hmTrackingApplicationTable=hmTrackingApplicationTable, hmTrackSendStateChangeTrap=hmTrackSendStateChangeTrap, hmTrackEvent=hmTrackEvent, hmTrackLogicalInstanceTable=hmTrackLogicalInstanceTable, hmTrackType=hmTrackType, hmTrackLogicalOperator=hmTrackLogicalOperator, hmTrackingEntry=hmTrackingEntry, hmTrackLogicInstRowStatus=hmTrackLogicInstRowStatus, hmTrackTimeSinceLastChange=hmTrackTimeSinceLastChange, hmTrackPingIpAddress=hmTrackPingIpAddress, hmTrackAppId=hmTrackAppId, hmTrackingGroup=hmTrackingGroup, hmTrackPingInterval=hmTrackPingInterval, hmTrackPingMiss=hmTrackPingMiss, hmTracking=hmTracking, hmTrackPingTimeout=hmTrackPingTimeout, hmTrackLogicalInstanceId=hmTrackLogicalInstanceId, hmTrackingApplicationEntry=hmTrackingApplicationEntry, hmTrackPingSuccess=hmTrackPingSuccess, hmTrackPingBestRouteIfNumber=hmTrackPingBestRouteIfNumber, hmTrackAppName=hmTrackAppName, hmTrackIfLinkDownDelay=hmTrackIfLinkDownDelay, hmTrackPingTTL=hmTrackPingTTL, hmTrackIfNumber=hmTrackIfNumber, hmTrackingTable=hmTrackingTable, PYSNMP_MODULE_ID=hmTracking, hmTrackState=hmTrackState, hmTrackStatusChangeEvent=hmTrackStatusChangeEvent, hmTrackLogicalInstanceEntry=hmTrackLogicalInstanceEntry, hmTrackId=hmTrackId, hmTrackRowStatus=hmTrackRowStatus, hmTrackIfLinkUpDelay=hmTrackIfLinkUpDelay)

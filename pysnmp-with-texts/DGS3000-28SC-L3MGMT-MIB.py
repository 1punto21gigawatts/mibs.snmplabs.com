#
# PySNMP MIB module DGS3000-28SC-L3MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DGS3000-28SC-L3MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:45:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, ModuleIdentity, Counter64, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Bits, Gauge32, ObjectIdentity, Integer32, NotificationType, TimeTicks, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ModuleIdentity", "Counter64", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Bits", "Gauge32", "ObjectIdentity", "Integer32", "NotificationType", "TimeTicks", "IpAddress")
TextualConvention, PhysAddress, MacAddress, RowStatus, DisplayString, TruthValue, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "PhysAddress", "MacAddress", "RowStatus", "DisplayString", "TruthValue", "TimeStamp")
dlink_Dgs3000Proj_DGS3000_28SCax, = mibBuilder.importSymbols("SWDGS3000PRIMGMT-MIB", "dlink-Dgs3000Proj-DGS3000-28SCax")
swL3MgmtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3))
if mibBuilder.loadTexts: swL3MgmtMIB.setLastUpdated('201408180000Z')
if mibBuilder.loadTexts: swL3MgmtMIB.setOrganization(' ')
if mibBuilder.loadTexts: swL3MgmtMIB.setContactInfo(' ')
if mibBuilder.loadTexts: swL3MgmtMIB.setDescription('The Structure of Layer 3 Network Management Information for the proprietary enterprise.')
class NodeAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class NetAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

swL3IpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2))
swL3RelayMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3))
swL3IpCtrlMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1))
swL3IpFdbMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2))
swL3RelayDnsMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2))
class VrId(TextualConvention, Integer32):
    description = 'A number which, along with an interface index (ifIndex), serves to uniquely identify a virtual router on a given VRRP router. A set of one or more associated addresses is assigned to a VRID.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 255)

swL3IpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3), )
if mibBuilder.loadTexts: swL3IpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlTable.setDescription('This table contains IP interface information.')
swL3IpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3IpCtrlInterfaceName"))
if mibBuilder.loadTexts: swL3IpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlEntry.setDescription('A list of information about a specific IP interface.')
swL3IpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setDescription('This object indicates the name of the IP interface.')
swL3IpCtrlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setDescription('This object uniquely identifies the IP interface number in the swL3IpCtrlTable.')
swL3IpCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setDescription('The IP address of the interface. This object only can take the value of the unicast IP address.')
swL3IpCtrlIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setDescription('The IP net mask for this interface.')
swL3IpCtrlVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setDescription("This object indicates the IP control entry's VLAN name. The VLAN name in each entry must be unique in the IP Control Table.")
swL3IpCtrlProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlProxyArp.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlProxyArp.setDescription('This object indicates enable/disable of the proxy ARP function for IPv4.')
swL3IpCtrlSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlSecondary.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlSecondary.setDescription('When this is true(1), the IP address is the secondary IP. When false(2), the IP address is the primary IP.')
swL3IpCtrlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("bootp", 3), ("dhcp", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlMode.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlMode.setDescription('This object indicates the IP operation mode. other(1) - This entry is currently in use but the conditions under which it will remain are determined by each of the following values. bootp(3) - The IP address will be set automatically from a BOOTP server. dhcp(4) - The IP address will be set automatically from a DHCP server.')
swL3IpCtrlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlAdminState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlAdminState.setDescription('The state of the IP interface.')
swL3IpCtrlIpv4AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv4AdminState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv4AdminState.setDescription('The IPv4 admin state of the IP interface. The default state is determined by project. This state will only be effective when the swL3IpCtrlAdminState is enabled.')
swL3IpCtrlIpv6AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv6AdminState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6AdminState.setDescription('The IPv6 admin state of the IP interface. The default state is determined by project. This state will only be effective when the swL3IpCtrlAdminState is enabled.')
swL3IpCtrlIpv6LinkLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 14), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAddress.setDescription('The IPv6 link local address for this interface.')
swL3IpCtrlIpv6LinkLocalPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalPrefixLen.setDescription('The IPv6 prefix length for this IPv6 link local address.')
swL3IpCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating, modifying, and deleting instances of the objects in this table.')
swL3IpCtrlIpv6LinkLocalAutoState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAutoState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAutoState.setDescription('The state of the IPv6 link local auto.')
swL3IpCtrlLocalProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlLocalProxyArp.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlLocalProxyArp.setDescription('This object indicates enable/disable of the local proxy ARP function for IPv4.')
swL3IpCtrlIpMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 19), Integer32().clone(1500)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlIpMtu.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpMtu.setDescription('The MTU is the largest size of the IP datagram which may be transferred using a specific data link connection. The MTU value is a design parameter of a LAN and is a mutually agreed value (i.e. both ends of a link agree to use the same specific value) for most WAN links. The MTU range is based on the chip of the current device. The suggested minimum value is 1500 bytes. The suggested maximum value is the size of the jumbo frame minus 36. The suggested default setting is 1500 bytes.')
swL3IpCtrlDhcpv6ClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientState.setDescription('The object indicates the state of the DHCPv6 client.')
swL3IpCtrlIpDirectedBroadcastState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDirectedBroadcastState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDirectedBroadcastState.setDescription('The object indicates the state of the IP Directed Broadcast.')
swL3IpCtrlIpDhcpOption12State = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12State.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12State.setDescription('Enable or disable insertion of option 12 in the DHCPDISCOVER and DHCPREQUEST message.')
swL3IpCtrlIpDhcpOption12HostName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12HostName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12HostName.setDescription('Specify the host name to be inserted in the DHCPDISCOVER and DHCPREQUEST message. The specified host name must start with a letter, end with a letter or digit, and have only letters, digits, and hyphen as interior characters; the maximal length is 63. By default, the host name is empty. When set an empty host name, means to clear the host name setting and use the default value to encode option 12.')
swL3IpCtrlDhcpv6ClientPDState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDState.setDescription('The state of the Dhcpv6 Client PD.')
swL3IpCtrlDhcpv6ClientPDPrefixName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixName.setDescription("This object indicates the name for the DHCPv6 Client PD. If the swL3IpCtrlDhcpv6ClientPDState is disabled, this object will be clear and can't write.")
swL3IpCtrlDhcpv6ClientPDPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 26), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefix.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefix.setDescription('The IPv6 prefix obtained form delegation router.')
swL3IpCtrlDhcpv6ClientPDPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixLen.setDescription('The IPv6 prefix length for the prefix obtained from delegation router.')
swL3IpCtrlIpv6AutoConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv6AutoConfigState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6AutoConfigState.setDescription('The state of IPv6 stateless adddress autoconfig.')
swL3IpCtrlIpv6AutoConfigDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 29), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv6AutoConfigDefault.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6AutoConfigDefault.setDescription('When this is true(1), a default route will be installed into ipv6 routing table. When false(2), no default route will be installed.')
swL3IpCtrlDhcpv6ClientRapidCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 30), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientRapidCommit.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientRapidCommit.setDescription('When this is true(1), Allows the two-message exchange method for address assignment.')
swL3IpCtrlDhcpv6ClientPDRapidCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 3, 1, 31), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDRapidCommit.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDRapidCommit.setDescription('When this is true(1), Allows the two-message exchange method for prefix assignment.')
swL3Ipv6CtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4), )
if mibBuilder.loadTexts: swL3Ipv6CtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlTable.setDescription('This table contains IPv6 information of an IP interface.')
swL3Ipv6CtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6CtrlInterfaceName"))
if mibBuilder.loadTexts: swL3Ipv6CtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlEntry.setDescription('A list of IPv6 information about a specific IP interface.')
swL3Ipv6CtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6CtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlInterfaceName.setDescription('This object indicates the name of the IP interface.')
swL3Ipv6CtrlMaxReassmblySize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6CtrlMaxReassmblySize.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlMaxReassmblySize.setDescription('Maximum Reassembly Size of the IP interface.')
swL3Ipv6CtrlNsRetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlNsRetransTimer.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlNsRetransTimer.setDescription("Neighbor solicitation's retransmit timer. The unit is set in milliseconds.")
swL3Ipv6CtrlRaState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaState.setDescription('Neighbor solicited state.')
swL3Ipv6CtrlRaMinRtrAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1350))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMinRtrAdvInterval.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMinRtrAdvInterval.setDescription('The minimum time allowed between sending unsolicited multicast Router Advertisements from the interface. The unit is set in seconds. It must be no less than 3 seconds and no greater than .75 * MaxRtrAdvInterval. Default value: 0.33 * MaxRtrAdvInterval')
swL3Ipv6CtrlRaMaxRtrAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMaxRtrAdvInterval.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMaxRtrAdvInterval.setDescription('The maximum time allowed between sending unsolicited multicast Router Advertisements from the interface. The unit is set in seconds.')
swL3Ipv6CtrlRaLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaLifeTime.setDescription('Indicates the lifetime of the router as the default router.')
swL3Ipv6CtrlRaReachableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaReachableTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaReachableTime.setDescription('Indicates the amount of time that a node can consider a neighboring node reachable after receiving a reachability confirmation.')
swL3Ipv6CtrlRaRetransTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaRetransTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaRetransTime.setDescription('Indicates the amount of time between retransmissions of neighbor solicited messages. The unit is set in millisecond.')
swL3Ipv6CtrlRaHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaHopLimit.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaHopLimit.setDescription('Indicates the default value of the hop limit field in the IPv6 header for packets sent by hosts that receive this RA message.')
swL3Ipv6CtrlRaManagedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaManagedFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaManagedFlag.setDescription('When enabled, it indicates that hosts receiving this RA must use a stateful address configuration protocol to obtain an address in the addition to the addresses derived from the stateless address configuration.')
swL3Ipv6CtrlRaOtherConfigFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaOtherConfigFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaOtherConfigFlag.setDescription('When enabled, it indicates that hosts receiving this RA must use a stateful address configuration protocol to obtain an on-link address configuration information.')
swL3Ipv6CtrlDadRetransNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlDadRetransNum.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlDadRetransNum.setDescription('Indicates the value of duplicate address detection attempt number')
swL3Ipv6AddressCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5), )
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlTable.setDescription('This table contains IPv6 address information for each IP interface.')
swL3Ipv6AddressCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6AddressCtrlInterfaceName"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6Address"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6AddressCtrlPrefixLen"))
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlEntry.setDescription('A list of information about a specific IPv6 address.')
swL3Ipv6AddressCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlInterfaceName.setDescription('This object indicates the name of the IP interface. ')
swL3Ipv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6Address.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6Address.setDescription('Specify the IPv6 address.')
swL3Ipv6AddressCtrlPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPrefixLen.setDescription('Indicates the prefix length of this IPv6 address.')
swL3Ipv6AddressCtrlPreferredLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPreferredLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPreferredLifeTime.setDescription('Indicates the number of seconds that an address, based on the specified prefix, using the stateless address configuration, remains in preferred state. For an infinite valid lifetime, the value can be set to 0xffffffff.')
swL3Ipv6AddressCtrlValidLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlValidLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlValidLifeTime.setDescription('Indicates the number of seconds that an address, based on the specified prefix, using the stateless address configuration, remains valid. For an infinite valid lifetime, the value can be set to 0xffffffff.')
swL3Ipv6AddressCtrlOnLinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlOnLinkFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlOnLinkFlag.setDescription('When enabled, the address implied by the specified prefix is available on the link where the RA message is received.')
swL3Ipv6AddressCtrlAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAutonomousFlag.setDescription('When enabled, the specified prefix will be used to create an autonomous address configuration.')
swL3Ipv6AddressCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating, modifying, and deleting instances of the objects in this table.')
swL3Ipv6AddressCtrlAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("dhcpv6", 2), ("stateless", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAddressType.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAddressType.setDescription('This object indicates the type of the IPv6 address. manual(1): the IPv6 address is configured by user. dhcpv6(2): the IPv6 address is assigned by DHCPv6 server. stateless(3): the IPv6 address is assigned by router advertisement.')
swL3Ipv6DHCPv6CPDAddrCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6), )
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlTable.setDescription('This table contain the information of the IPv6 address which based on DHCPv6 client PD.')
swL3Ipv6DHCPv6CPDAddrCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlPrefixName"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen"))
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlEntry.setDescription('A list of information about a specific DHCPv6 Client PD IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName.setDescription('This object indicates the name of the IP interface. ')
swL3Ipv6DHCPv6CPDAddrCtrlPrefixName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixName.setDescription('This object indicates the name of the prefix based on which the IPv6 address will be generate. ')
swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1, 3), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr.setDescription('Specify the suffix of the IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen.setDescription('Indicates the prefix length of this IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating and deleting instances of the objects in this table.')
swL3IpCtrlAllIpIfState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlAllIpIfState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlAllIpIfState.setDescription('This object indicates all interface function state of the device. (except the loopback interface)')
swL3LoopBackIpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8), )
if mibBuilder.loadTexts: swL3LoopBackIpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlTable.setDescription('This table contains loopback IP interface information.')
swL3LoopBackIpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3LoopBackIpCtrlInterfaceName"))
if mibBuilder.loadTexts: swL3LoopBackIpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlEntry.setDescription('A list of information about a specific loopback IP interface.')
swL3LoopBackIpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlInterfaceName.setDescription('This object indicates the name of the loopback IP interface.')
swL3LoopBackIpCtrlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIfIndex.setDescription('This object uniquely identifies the loopback IP interface number in the swL3LoopBackIpCtrlTable.')
swL3LoopBackIpCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIpAddr.setDescription('The IP address of the loopback interface. This object only can take the value of the unicast IP address.')
swL3LoopBackIpCtrlIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlIpSubnetMask.setDescription('The IP net mask for this loopback interface.')
swL3LoopBackIpCtrlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlAdminState.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlAdminState.setDescription('The state of the loopback IP interface.')
swL3LoopBackIpCtrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 1, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3LoopBackIpCtrlRowStatus.setStatus('current')
if mibBuilder.loadTexts: swL3LoopBackIpCtrlRowStatus.setDescription('This variable displays the status of the entry. The status is used for creating, modifying, and deleting instances of the objects in this table.')
swL3IpFdbInfoTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1), )
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setDescription('A table that contains forwarding and/or filtering information. This information is used by the switch in determining how to propagate the received IP packets.')
swL3IpFdbInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3IpFdbInfoIpAddr"))
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setDescription('Information about a specific IP address for which the bridge has some forwarding and/or filtering information.')
swL3IpFdbInfoIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setDescription('A IP address for which switch has forwarding and/or filtering information.')
swL3IpFdbInfoIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setDescription('A IP net mask for this interface for which the switch has forwarding and/or filtering information.')
swL3IpFdbInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setDescription("Either the value '0', or the port number of the port on which packet having a IP address equal to the value of the corresponding instance of swL3IpFdbInfoIpAddr has been seen. A value of '0' indicates that the port number has not been learned but that switch does have some forwarding/filtering information about this address.")
swL3IpFdbInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoType.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoType.setDescription('The status of this entry.')
swL3IpArpAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpArpAgingTime.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpAgingTime.setDescription('The timeout period in minutes for aging out dynamically learned ARP information.')
swL3IpStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5), )
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setDescription("This entity's IP static Routing table.")
swL3IpStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3IpStaticRouteDest"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3IpStaticRouteMask"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3IpStaticRouteNextHop"))
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setDescription("A particular route to a particular destination, under a particular policy. Once an entry is built,it shouldn't be modified.That is,it just supports create and delete actions.")
swL3IpStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteMask object is not equal to x.')
swL3IpStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setDescription('Indicate the mask to be logical-AND with the destination address before being compared to the value in the swL3IpStaticRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the swL3IpStaticRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteDest object is not equal to swL3IpStaticRouteDest.')
swL3IpStaticRouteBkupState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2), ("none", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteBkupState.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteBkupState.setDescription('The routing state for this route.The value SHOULD be primary(1), backup(2) or none(3).')
swL3IpStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setDescription('Specifies the IP address for the next hop router. An IP address of 255.255.255.255 denotes a Null interface as the next hop.')
swL3IpStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setDescription('Specifies the routing metric for this route.')
swL3IpStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3), ("active", 4), ("inActive", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry resides in the table. active(4) - the nextHop of this entry exists in the ARP table. inActive(5) - the next hop of this entry does not exist in the ARP table.')
swL3IpStaticRouteWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteWeight.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteWeight.setDescription('Specifies the weight value. Used for the weighted multipath.')
swL3IpStaticRouteInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteInterfaceName.setDescription('Specifies the name of the IP interface.')
swL3IpStaticRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteCost.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteCost.setDescription('Specifies the cost of the Route Entry.')
swL3RelayDnsState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsState.setDescription('This object indicates if the DNS Relay function is enabled or disabled.')
swL3RelayDnsPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setDescription('This object indicates the address of the primary DNS server.')
swL3RelayDnsSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setDescription('This object indicates the address of the secondary DNS server.')
swL3RelayDnsCacheState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setDescription('This object indicates DNS Relay cache is enabled or disabled.')
swL3RelayDnsStaticTableState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setDescription('This object indicates DNS Relay static table is enabled or disabled.')
swL3RelayDnsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 6), )
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setDescription('This table displays the current DNS relay static table.')
swL3RelayDnsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 6, 1), ).setIndexNames((0, "DGS3000-28SC-L3MGMT-MIB", "swL3RelayDnsCtrlDomainName"), (0, "DGS3000-28SC-L3MGMT-MIB", "swL3RelayDnsCtrlIpAddr"))
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setDescription('A list of information display the current DNS relay static table.')
swL3RelayDnsCtrlDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setDescription('The domain name of the entry.')
swL3RelayDnsCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setDescription('The IP address of the entry.')
swL3RelayDnsCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 133, 5, 1, 3, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
mibBuilder.exportSymbols("DGS3000-28SC-L3MGMT-MIB", swL3IpCtrlVlanName=swL3IpCtrlVlanName, swL3RelayDnsCacheState=swL3RelayDnsCacheState, swL3Ipv6Address=swL3Ipv6Address, swL3IpStaticRouteMetric=swL3IpStaticRouteMetric, swL3IpStaticRouteNextHop=swL3IpStaticRouteNextHop, swL3Ipv6CtrlRaRetransTime=swL3Ipv6CtrlRaRetransTime, swL3Ipv6CtrlRaManagedFlag=swL3Ipv6CtrlRaManagedFlag, swL3RelayDnsState=swL3RelayDnsState, swL3IpFdbMgmt=swL3IpFdbMgmt, swL3Ipv6CtrlRaMaxRtrAdvInterval=swL3Ipv6CtrlRaMaxRtrAdvInterval, swL3IpCtrlDhcpv6ClientState=swL3IpCtrlDhcpv6ClientState, swL3Ipv6CtrlRaOtherConfigFlag=swL3Ipv6CtrlRaOtherConfigFlag, swL3Ipv6CtrlMaxReassmblySize=swL3Ipv6CtrlMaxReassmblySize, swL3IpCtrlAllIpIfState=swL3IpCtrlAllIpIfState, swL3IpCtrlIpDirectedBroadcastState=swL3IpCtrlIpDirectedBroadcastState, swL3IpArpAgingTime=swL3IpArpAgingTime, NodeAddress=NodeAddress, swL3LoopBackIpCtrlIpAddr=swL3LoopBackIpCtrlIpAddr, swL3RelayDnsCtrlTable=swL3RelayDnsCtrlTable, swL3Ipv6DHCPv6CPDAddrCtrlPrefixName=swL3Ipv6DHCPv6CPDAddrCtrlPrefixName, swL3IpMgmt=swL3IpMgmt, swL3Ipv6AddressCtrlPrefixLen=swL3Ipv6AddressCtrlPrefixLen, swL3Ipv6CtrlRaState=swL3Ipv6CtrlRaState, swL3RelayDnsCtrlEntry=swL3RelayDnsCtrlEntry, swL3IpStaticRouteDest=swL3IpStaticRouteDest, swL3IpCtrlMgmt=swL3IpCtrlMgmt, swL3IpCtrlProxyArp=swL3IpCtrlProxyArp, swL3IpCtrlIpv4AdminState=swL3IpCtrlIpv4AdminState, swL3IpStaticRouteWeight=swL3IpStaticRouteWeight, swL3RelayDnsSecondaryServer=swL3RelayDnsSecondaryServer, swL3IpCtrlInterfaceName=swL3IpCtrlInterfaceName, swL3IpFdbInfoEntry=swL3IpFdbInfoEntry, swL3IpCtrlSecondary=swL3IpCtrlSecondary, swL3IpCtrlIpDhcpOption12State=swL3IpCtrlIpDhcpOption12State, swL3IpCtrlDhcpv6ClientPDPrefix=swL3IpCtrlDhcpv6ClientPDPrefix, swL3LoopBackIpCtrlRowStatus=swL3LoopBackIpCtrlRowStatus, swL3IpFdbInfoTable=swL3IpFdbInfoTable, swL3IpCtrlDhcpv6ClientPDState=swL3IpCtrlDhcpv6ClientPDState, swL3LoopBackIpCtrlIfIndex=swL3LoopBackIpCtrlIfIndex, swL3LoopBackIpCtrlAdminState=swL3LoopBackIpCtrlAdminState, swL3Ipv6AddressCtrlAutonomousFlag=swL3Ipv6AddressCtrlAutonomousFlag, swL3Ipv6AddressCtrlAddressType=swL3Ipv6AddressCtrlAddressType, swL3IpCtrlIpDhcpOption12HostName=swL3IpCtrlIpDhcpOption12HostName, swL3IpCtrlIfIndex=swL3IpCtrlIfIndex, swL3Ipv6CtrlRaMinRtrAdvInterval=swL3Ipv6CtrlRaMinRtrAdvInterval, swL3Ipv6CtrlRaHopLimit=swL3Ipv6CtrlRaHopLimit, swL3LoopBackIpCtrlInterfaceName=swL3LoopBackIpCtrlInterfaceName, swL3IpCtrlDhcpv6ClientRapidCommit=swL3IpCtrlDhcpv6ClientRapidCommit, swL3IpCtrlIpAddr=swL3IpCtrlIpAddr, swL3Ipv6CtrlTable=swL3Ipv6CtrlTable, swL3IpFdbInfoPort=swL3IpFdbInfoPort, swL3RelayDnsCtrlState=swL3RelayDnsCtrlState, swL3IpCtrlIpv6AutoConfigDefault=swL3IpCtrlIpv6AutoConfigDefault, swL3IpStaticRouteTable=swL3IpStaticRouteTable, swL3IpCtrlTable=swL3IpCtrlTable, swL3LoopBackIpCtrlEntry=swL3LoopBackIpCtrlEntry, swL3IpFdbInfoIpSubnetMask=swL3IpFdbInfoIpSubnetMask, swL3IpCtrlDhcpv6ClientPDPrefixName=swL3IpCtrlDhcpv6ClientPDPrefixName, swL3IpStaticRouteEntry=swL3IpStaticRouteEntry, swL3Ipv6CtrlRaLifeTime=swL3Ipv6CtrlRaLifeTime, swL3Ipv6AddressCtrlInterfaceName=swL3Ipv6AddressCtrlInterfaceName, swL3IpCtrlEntry=swL3IpCtrlEntry, swL3Ipv6AddressCtrlState=swL3Ipv6AddressCtrlState, swL3IpStaticRouteStatus=swL3IpStaticRouteStatus, swL3Ipv6DHCPv6CPDAddrCtrlState=swL3Ipv6DHCPv6CPDAddrCtrlState, swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr=swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr, swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen=swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen, swL3RelayDnsPrimaryServer=swL3RelayDnsPrimaryServer, swL3RelayMgmt=swL3RelayMgmt, NetAddress=NetAddress, swL3MgmtMIB=swL3MgmtMIB, swL3LoopBackIpCtrlTable=swL3LoopBackIpCtrlTable, swL3LoopBackIpCtrlIpSubnetMask=swL3LoopBackIpCtrlIpSubnetMask, swL3RelayDnsStaticTableState=swL3RelayDnsStaticTableState, swL3IpCtrlIpv6LinkLocalPrefixLen=swL3IpCtrlIpv6LinkLocalPrefixLen, swL3Ipv6AddressCtrlOnLinkFlag=swL3Ipv6AddressCtrlOnLinkFlag, swL3Ipv6CtrlInterfaceName=swL3Ipv6CtrlInterfaceName, swL3IpCtrlLocalProxyArp=swL3IpCtrlLocalProxyArp, swL3RelayDnsMgmt=swL3RelayDnsMgmt, swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName=swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName, swL3IpCtrlIpv6LinkLocalAddress=swL3IpCtrlIpv6LinkLocalAddress, swL3Ipv6CtrlRaReachableTime=swL3Ipv6CtrlRaReachableTime, swL3IpStaticRouteBkupState=swL3IpStaticRouteBkupState, swL3RelayDnsCtrlDomainName=swL3RelayDnsCtrlDomainName, swL3IpCtrlState=swL3IpCtrlState, swL3IpCtrlIpMtu=swL3IpCtrlIpMtu, swL3IpCtrlAdminState=swL3IpCtrlAdminState, swL3IpStaticRouteCost=swL3IpStaticRouteCost, swL3IpFdbInfoType=swL3IpFdbInfoType, swL3IpCtrlIpv6LinkLocalAutoState=swL3IpCtrlIpv6LinkLocalAutoState, swL3Ipv6CtrlDadRetransNum=swL3Ipv6CtrlDadRetransNum, swL3IpCtrlIpSubnetMask=swL3IpCtrlIpSubnetMask, swL3IpCtrlMode=swL3IpCtrlMode, PYSNMP_MODULE_ID=swL3MgmtMIB, swL3IpCtrlIpv6AdminState=swL3IpCtrlIpv6AdminState, swL3RelayDnsCtrlIpAddr=swL3RelayDnsCtrlIpAddr, swL3IpCtrlDhcpv6ClientPDPrefixLen=swL3IpCtrlDhcpv6ClientPDPrefixLen, swL3IpCtrlDhcpv6ClientPDRapidCommit=swL3IpCtrlDhcpv6ClientPDRapidCommit, swL3Ipv6DHCPv6CPDAddrCtrlTable=swL3Ipv6DHCPv6CPDAddrCtrlTable, swL3Ipv6CtrlNsRetransTimer=swL3Ipv6CtrlNsRetransTimer, swL3Ipv6AddressCtrlPreferredLifeTime=swL3Ipv6AddressCtrlPreferredLifeTime, swL3IpCtrlIpv6AutoConfigState=swL3IpCtrlIpv6AutoConfigState, swL3IpStaticRouteMask=swL3IpStaticRouteMask, swL3IpStaticRouteInterfaceName=swL3IpStaticRouteInterfaceName, swL3Ipv6AddressCtrlValidLifeTime=swL3Ipv6AddressCtrlValidLifeTime, swL3IpFdbInfoIpAddr=swL3IpFdbInfoIpAddr, swL3Ipv6DHCPv6CPDAddrCtrlEntry=swL3Ipv6DHCPv6CPDAddrCtrlEntry, swL3Ipv6AddressCtrlTable=swL3Ipv6AddressCtrlTable, swL3Ipv6AddressCtrlEntry=swL3Ipv6AddressCtrlEntry, swL3Ipv6CtrlEntry=swL3Ipv6CtrlEntry, VrId=VrId)

#
# PySNMP MIB module Wellfleet-WFMPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-WFMPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:42:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Gauge32, Counter64, ObjectIdentity, Bits, NotificationType, Unsigned32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "Counter64", "ObjectIdentity", "Bits", "NotificationType", "Unsigned32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "iso", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfmpsObjects, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfmpsObjects")
wfmpsEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1), )
if mibBuilder.loadTexts: wfmpsEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEntryTable.setDescription('MPS base entry table. ')
wfmpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsSlot"))
if mibBuilder.loadTexts: wfmpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEntry.setDescription('An MPS base entry description')
wfmpsDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDelete.setDescription('Indication to create or delete an MPS base Entry from the MIB ')
wfmpsDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDisable.setDescription('Enables or Disables MPS Subsystem.')
wfmpsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCct.setDescription('This corresponds to the circuit number associated with the ATM Driver ')
wfmpsCacheIpOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsCacheIpOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCacheIpOverRide.setDescription(' Indicates whether the wfmps defined MPS Egress Cache reverification timer over rides the timer defined by the wfIpInterfaceHostCache.i If on, overide and use the timer defined by wfmpsCacheReverifyTimer if off, use the timer defined by wfIpInterfaceHostCache. ')
wfmpsCacheReverifyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 120, 180, 240, 300, 600, 900, 1200))).clone(namedValues=NamedValues(("timeroff", 1), ("timer120", 120), ("timer180", 180), ("timer240", 240), ("timer300", 300), ("timer600", 600), ("timer900", 900), ("timer1200", 1200))).clone('timer120')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsCacheReverifyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCacheReverifyTimer.setDescription(' A range of values to specify the timer value for MPS Egress Cache reverification. This value is of significance, only when wfmpsCacheIpOverRide is turned on.')
wfmpsAddrGenerateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsAddrGenerateMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsAddrGenerateMode.setDescription("Indicates whether this MPS's address should be generated automatically or manually.")
wfmpsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2), )
if mibBuilder.loadTexts: wfmpsConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsConfigTable.setDescription('The MPOA Server Configuration Table. This table represents the configuration information for all MPOA Servers which this agent manages.')
wfmpsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsCnfSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsCnfIndex"))
if mibBuilder.loadTexts: wfmpsConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsConfigEntry.setDescription('MPOA Server Configuration Entry. Each entry contains configuration information for one MPOA Server Control.')
wfmpsCnfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsCnfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCnfDelete.setDescription('Indication to create or delete an MPS Config Entry from the MIB ')
wfmpsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsRowStatus.setDescription("This object allows creation and deletion of MPOA Servers. Within each conceptual wfmpsConfigTable row, objects which are writable may be modified regardless of the value of wfmpsRowStatus. It is not necessary to set a row's status to 'notInService' first. A row cannot be created, unless the wfmpsAtmCtrlAddress in this table is unique. When an MPOA Server is created via this object, it will initially have 'wfmpsOperStatus' = 'initialState'")
wfmpsCnfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsCnfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCnfIndex.setDescription("A value which uniquely identifies this conceptual row in the wfmpsConfigTable. The 'wfmpsNextIndex' object needs to be used to determine the value of this object. A row cannot be added, unless wfmpsCtrlAtmAddr is unique. In the event of an MPS re-initialization, the value of this wfmpsIndex must remain the same. However, in the event of an agent re-initialization, this value does not need to be preserved.")
wfmpsConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsConfigMode.setDescription('Indicates whether this MPS should auto-configure the next time it is (re-)initialized. In automatic(1) mode the LECS is contacted and requests are made for the MPS-p* parameters as indicated by wfmpsConfigMask. In manual(2) mode, the values of the configuration parameters are obtained from the wfmpsConfigTable and the wfmpsProtocolTable.')
wfmpsCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsCtrlAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCtrlAtmAddr.setDescription("The MPS's Control ATM Address. There exists one Control ATM Address per MPS, therefore, the value of this entry is unique within the table.")
wfmpsKeepAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsKeepAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsKeepAliveTime.setDescription('MPS-p1 Keep-alive time is max interval between the MPS sending MPOA Keep-Alives in seconds.')
wfmpsKeepAliveLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1000)).clone(35)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsKeepAliveLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsKeepAliveLifeTime.setDescription('MPS-p2 Keep-Alive Lifetime The length of time an MPC may consider a Keep-Alive valid in seconds. This value must be at least three times the wfmpsKeepAliveTime (MPS-p1).')
wfmpsInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsInitialRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsInitialRetryTime.setDescription('MPS-p4 is initial value in seconds for the MPOA retry mechanism.')
wfmpsRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsRetryTimeMaximum.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: wfmpsRetryTimeMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsRetryTimeMaximum.setDescription('MPS-p5 cumulative max value in seconds for Retry Time (MPS-p4).')
wfmpsGiveupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsGiveupTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsGiveupTime.setDescription('MPS-p6 Give Up Time. Minimum time in seconds to wait before giving up on a pending resolution request.')
wfmpsDefaultHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDefaultHoldingTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDefaultHoldingTime.setDescription('MPS-p7 Default Holding Time in minutes. The default Holding Time used in NHRP Resolution Replies. An egress MPS may use local information to determine a more appropriate Holding Time.')
wfmpsCnfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsCnfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsCnfSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsInitialCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 500)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsInitialCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsInitialCacheSize.setDescription('Indicates the amount of memory to allocate initially to accomadate the cache entries. ')
wfmpsMaxCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMaxCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMaxCacheSize.setDescription('Maximum number of Ingress/Egress cache entries allowed ')
wfmpsLECSAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsLECSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsLECSAddress.setDescription('The LE Config Server Address to be used. If left(or set) to NULL_VAL the well-known LECS ATM address will be used.')
wfmpsDebugMsgLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugMsgLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugMsgLevel.setDescription('Debug Levels - This attribute is used to assign the level of DEBUG message to be logged for each MPS.')
wfmpsConfigMpsName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 2, 1, 17), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsConfigMpsName.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsConfigMpsName.setDescription('User name for the MPS')
wfmpsActualTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3), )
if mibBuilder.loadTexts: wfmpsActualTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualTable.setDescription('A read-only table containing identification, status, and operational information about the MPOA Servers this agent manages.')
wfmpsActualEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsActSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsActIndex"))
if mibBuilder.loadTexts: wfmpsActualEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualEntry.setDescription("An entry in the MPS Actual Table. An entry represents a specific MPOA Server's status and operation information.")
wfmpsActIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActIndex.setDescription(' This is the mps index ')
wfmpsActualState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("initialState", 2), ("unknown", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualState.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualState.setDescription('This object indicates the current operational status of the MPOA Server.')
wfmpsDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsDiscontinuityTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this MPS's counters experienced a discontinuity. The relevant counters are the specific instances associated with this MPS. If discontinuities have not occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
wfmpsActualConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualConfigMode.setDescription('Indicates whether this MPS auto-configured when it started was last (re-)initialized. In automatic(1) mode the LECS was contacted and all the MPS-p* parameters were downloaded. In manual(2) mode, either the LECS could not be contacted (if wfmpsConfigMode is automatic) or local over rides are being used (wfmpsConfigMode is manual). if wfmpsConfigMode is automatic and wfmpsActualConfigMode is manual, then the initial values are the MIB defaults. As always, any values can be set, however, if wfmpsConfigMode is automatic, those changes will be lost on the next restart.')
wfmpsActualKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualKeepAlive.setDescription('The maximum amount of time in seconds this MPS waits between sending MPOA Keep-Alives.')
wfmpsActualKeepAliveLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualKeepAliveLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualKeepAliveLifeTime.setDescription('The length of time in seconds this MPS considers a Keep-Alive valid.')
wfmpsActualInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualInitialRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualInitialRetryTime.setDescription('The actual initial value in seconds for the MPOA retry mechanism.')
wfmpsActualRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 300)).clone(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualRetryTimeMaximum.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: wfmpsActualRetryTimeMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualRetryTimeMaximum.setDescription('The actual cumulative max value in seconds for Retry Time.')
wfmpsActualGiveupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300)).clone(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualGiveupTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualGiveupTime.setDescription('Minimum time in seconds that this MPS waits before giving up on a pending resolution request.')
wfmpsActualDefaultHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualDefaultHoldingTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualDefaultHoldingTime.setDescription('The actual Holding Time in minutes used in NHRP Resolution Replies.')
wfmpsActSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsActualCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 3, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsActualCtrlAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsActualCtrlAtmAddr.setDescription("The Actual MPS's Control ATM Address. There exists one Control ATM Address per MPS, therefore, the value of this entry is unique within the table.")
wfmpsStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4), )
if mibBuilder.loadTexts: wfmpsStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatisticsTable.setDescription('This table represents the statistical information for the MPSs, which this agent manages.')
wfmpsStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsStatSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsStatIndex"))
if mibBuilder.loadTexts: wfmpsStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatisticsEntry.setDescription('Each row in this table contains statistics for one MPOA server.')
wfmpsStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatIndex.setDescription(' This is the mps index ')
wfmpsStatRxMpoaResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaResolveRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaResolveRequests.setDescription('The number of MPOA Resolve Requests received by this MPS which are translated to NHRP resolve requests. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of wfmpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyAcks.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyAcks.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE Code of 0x00 - Success. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufECResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufECResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufECResources.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE Code of 0x81 - Insufficient resources to accept egress cache entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufSCResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufSCResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufSCResources.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE Code of 0x82 - Insufficent resources to accept shortcut. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufEitherResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufEitherResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyInsufEitherResources.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE CODE of 0x83 - Insufficient resources to accept either shortcut or egress cache entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedInetProt.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedInetProt.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE CODE of 0x84 - Unsupported Internetwork Layer protocol. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE CODE of 0x85 - Unsupported MAC layer encapsulation. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnspecifiedOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnspecifiedOther.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyUnspecifiedOther.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which contain the MPOA CIE CODE of 0x88 - Unspecified/Other. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaResolveReplyOther = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyOther.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaResolveReplyOther.setDescription('The number of MPOA Resolve Replies transmitted by this MPS which are not counted above. NOTE - this would include NHRP errors. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatGiveupTimeExpireds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatGiveupTimeExpireds.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatGiveupTimeExpireds.setDescription('The number of times the MPS Give up Time (MPS-p6) has expired while waiting for a reply from a re-originated MPOA resolution request, i.e. a reply for a translated NHRP resolution request. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaImpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaImpRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaImpRequests.setDescription('The number of MPOA Cache Imposition Requests transmitted by this MPS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyAcks.setDescription('The number of successful MPOA Cache Imposition Replies received by this MPS which contain an MPOA CIE Code of 0x00, Success. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufECResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufECResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufECResources.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x81, Insufficient resources to accept egress cache entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufSCResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufSCResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufSCResources.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x82 - Insufficient resources to accept shortcut. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufEitherResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufEitherResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyInsufEitherResources.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x83 - Insufficient resources to accept either shortcut or egress cache entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedInetProt.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedInetProt.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x84 - Unsupported Internetwork Layer protocol. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x85 - Unsupported MAC layer encapsulation. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnspecifiedOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnspecifiedOther.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyUnspecifiedOther.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which contain the MPOA CIE Code of 0x88 - Unspecified/Other. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaImpReplyOther = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyOther.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaImpReplyOther.setDescription('The number of MPOA Cache Imposition Replies received by this MPS which are not counted previously. NOTE - this would include NHRP errors. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxMpoaEgressCachePurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxMpoaEgressCachePurgeRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxMpoaEgressCachePurgeRequests.setDescription('The number of MPOA Egress Cache Purges Requests received by this MPS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaEgressCachePurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaEgressCachePurgeReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaEgressCachePurgeReplies.setDescription('The number of MPOA Egress Cache Purge Replies transmitted by this MPS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxMpoaTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxMpoaTriggers.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: wfmpsStatTxMpoaTriggers.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxMpoaTriggers.setDescription('The number of MPOA Trigger messages transmitted by this MPS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxNhrpResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveRequests.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveRequests.setDescription('Total count of MPOA Resolution Requests received by the Ingress MPS which were translated to NHRP Resolution Requests and transmitted to the NHS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxNhrpResolveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveReplies.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveReplies.setDescription('Total count of NHRP Resolution Replies received by the Ingress. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatRxNhrpResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveRequests.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatRxNhrpResolveRequests.setDescription('Total count of NHRP Resolution Requests received by the Egress MPS from the NHS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatTxNhrpResolveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveReplies.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.7.2.1 MPOA Trigger')
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatTxNhrpResolveReplies.setDescription('Total count of NHRP Resolution Replies transmitted by the Egress MPS to the NHS. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPS, and at other times, as indicated by the value of mpsDiscontinuityTime.')
wfmpsStatSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 4, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsStatSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsStatSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5), )
if mibBuilder.loadTexts: wfmpsProtocolTable.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot), Section 4.1.1.1 MPS Parameters')
if mibBuilder.loadTexts: wfmpsProtocolTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtocolTable.setDescription('List of protocols, per MPS, for which MPOA resolution is enabled.')
wfmpsProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsProtSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsProtIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsInternetworkLayerProtocol"))
if mibBuilder.loadTexts: wfmpsProtocolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtocolEntry.setDescription('Each row indicates one protocol for which an MPS will perform MPOA resolution. If the corresponding MPS entry in wfmpsStatusTable has wfmpsActualConfigMode set to automatic, and the appropriate bit in wfmpsActualConfigMask (MPS-p3, bit 3) is set to 1, then values retrieved from the LECS are reflected in this table and the wfmpsLECSValue object will be (1) true. Also, the user can create rows which appropriately correspond to the MPS denoted by wfmpsIndex, and the wfmpsLECSValue object will be set to (2) false. NOTE - if the LECS does not return information for the MPS-p3 parameter, or if in manual mode, the user should create at least one entry for the corresponding MPS. Both, LECS and user-created rows may exist in this Table. This means that if the MPS was last re-initialized in in automatic mode (see wfmpsActualConfigMode), the set of rows is a union of values retreived from the LECS and manually configured.')
wfmpsProtocolDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsProtocolDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtocolDelete.setDescription('Indication to create or delete an MPS Protocol Entry from the MIB ')
wfmpsProtocolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsProtocolRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtocolRowStatus.setDescription("This object allows network managers to enable resolution for the 'wfmpsInternetworkLayerProtocol'.")
wfmpsProtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsProtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtIndex.setDescription(' This is the mps index ')
wfmpsInternetworkLayerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsInternetworkLayerProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsInternetworkLayerProtocol.setDescription('MPS-p3 A protocol on which to perform MPOA resolution.')
wfmpsLECSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsLECSValue.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsLECSValue.setDescription('This object reflects if the current entry is due to a retrieval from the LECS or not. If this entry is due to the LECS, then true(1) is the value for this object, otherwise, false (2).')
wfmpsProtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsProtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsProtSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsMappingTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6), )
if mibBuilder.loadTexts: wfmpsMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMappingTable.setDescription("A table mapping the 'lecIndex' values of LANE Clients to the 'wfmpsIndex' values of corresponding MPOA Servers.")
wfmpsMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpslecIndex"))
if mibBuilder.loadTexts: wfmpsMappingEntry.setReference('LAN Emulation Client Management Specification. af-lane-0044-000.')
if mibBuilder.loadTexts: wfmpsMappingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMappingEntry.setDescription('Each row defines one lecIndex --> wfmpsIndex mapping. The wfmpsIndex that a lecIndex maps to is not necessarily unique. In other words, there can be multiple LECs associated with one MPS.')
wfmpsMappingDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMappingDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMappingDelete.setDescription('Indication to create or delete an MPS Mapping Entry from the MIB ')
wfmpsMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMappingRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMappingRowStatus.setDescription('Allows creation, enabling/disabling of this row.')
wfmpslecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpslecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpslecIndex.setDescription('Mapped lec index. ')
wfmpsMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMapIndex.setDescription('The wfmpsMapIndex of the MPOA Server that is associated with this LEC. The wfmpsMapIndex corresponds to the wfmpsIndex.')
wfmpsMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMapSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsIngressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7), )
if mibBuilder.loadTexts: wfmpsIngressCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheTable.setDescription('This table tracks all the Ingress Cache information of the MPSs which this agents manages.')
wfmpsIngressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsIngressSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsIngressIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsIngressMpcIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsIngressCacheDestInternetworkAddrType"), (0, "Wellfleet-WFMPS-MIB", "wfmpsIngressCacheDestAddr"))
if mibBuilder.loadTexts: wfmpsIngressCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheEntry.setDescription("A entry contains parameters and state variables for a row in a MPS's Ingress Cache.")
wfmpsIngressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressIndex.setDescription(' This is the mps index ')
wfmpsIngressMpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressMpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressMpcIndex.setDescription(' This is the mpc index ')
wfmpsIngressCacheDestInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheDestInternetworkAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheDestInternetworkAddrType.setDescription('The type of internetwork layer address of the Destination Address.')
wfmpsIngressCacheDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheDestAddr.setDescription('The Ingress MPS Destination Internetwork Layer Address.')
wfmpsIngressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCachePrefixLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCachePrefixLen.setDescription('The Prefix Length of the wfmpsIngressCacheDestAddr.')
wfmpsIngressCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheState.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheState.setDescription('The state of this entry.')
wfmpsIngressCacheSrcInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheSrcInternetworkAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheSrcInternetworkAddrType.setDescription('The type of internetwork layer address of the Source Address.')
wfmpsIngressCacheSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheSrcAddr.setDescription('The Ingress MPS Source Internetwork Layer Address.')
wfmpsIngressCacheSourceMpcAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheSourceMpcAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheSourceMpcAtmAddr.setDescription("The ATM Adress from the source of this MPOA request. In other words, the Ingress MPC's Control Atm Address.")
wfmpsIngressCacheResolvedAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheResolvedAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheResolvedAtmAddr.setDescription('The ATM Adress which has been resolved by an Egress MPC.')
wfmpsIngressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheHoldTime.setDescription('Time interval that this value is valid.')
wfmpsIngressCacheMpoaRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheMpoaRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheMpoaRequestId.setDescription('The request ID contained in the MPOA resolution request from the local Ingress MPC.')
wfmpsIngressCacheNhrpRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheNhrpRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheNhrpRequestId.setDescription('The request ID which this MPS generates to identify the NHRP resolution request.')
wfmpsIngressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressCacheServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressCacheServiceCategory.setDescription('The request ID which this MPS generates to identify the NHRP resolution request.')
wfmpsIngressSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 7, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsIngressSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsIngressSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsEgressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8), )
if mibBuilder.loadTexts: wfmpsEgressCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheTable.setDescription('This table contains information regarding the Egress MPOA Server Cache Table.')
wfmpsEgressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsEgressSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsEgressIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsEgressMpcIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsEgressCacheId"))
if mibBuilder.loadTexts: wfmpsEgressCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheEntry.setDescription("An entry represents an entry in the MPS's Egress cache Table which keeps track of the state of the impositions.")
wfmpsEgressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressIndex.setDescription(' This is the mps index ')
wfmpsEgressMpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressMpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressMpcIndex.setDescription(' This is the mpc index ')
wfmpsEgressCacheId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheId.setDescription('The id which identifies this cache entry.')
wfmpsEgressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheHoldTime.setDescription('Time interval that this value is valid.')
wfmpsEgressCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheState.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Appendix I.4 Egress MPS Control State MAchine.')
if mibBuilder.loadTexts: wfmpsEgressCacheState.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheState.setDescription('The state of the entry.')
wfmpsEgressCacheDataLinkHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheDataLinkHeader.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheDataLinkHeader.setDescription('Data-Link Layer Header.')
wfmpsEgressCacheElanId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheElanId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheElanId.setDescription('The elan id that this Cache Imposition is sent on')
wfmpsEgressCacheSourceClientAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheSourceClientAtmAddr.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 45.')
if mibBuilder.loadTexts: wfmpsEgressCacheSourceClientAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheSourceClientAtmAddr.setDescription("The Ingress NHC's Atm Address used in the original cache imposition.")
wfmpsEgressCacheNhrpRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheNhrpRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheNhrpRequestId.setDescription('The request id from the original NHRP Resolution Request, may be only useful in the Resolving State.')
wfmpsEgressCacheMpoaRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheMpoaRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheMpoaRequestId.setDescription("The new request id which is generated for this imposition's request, may be only useful in the Resolving State.")
wfmpsEgressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheServiceCategory.setReference('Lane V2 LUNI TLVs')
if mibBuilder.loadTexts: wfmpsEgressCacheServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheServiceCategory.setDescription('The service categories supported for this shortcut')
wfmpsEgressCacheNextHopInternetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheNextHopInternetworkAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheNextHopInternetworkAddrType.setDescription('The NextHop protocol address type.')
wfmpsEgressCacheNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressCacheNextHopAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressCacheNextHopAddr.setDescription('The NextHop protocol address.')
wfmpsEgressSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 8, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsEgressSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsEgressSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsMpcTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9), )
if mibBuilder.loadTexts: wfmpsMpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpcTable.setDescription('A table contains information about the MPCs that these MPSs know about.')
wfmpsMpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsMpcSlot"), (0, "Wellfleet-WFMPS-MIB", "wfmpsMpsIndex"), (0, "Wellfleet-WFMPS-MIB", "wfmpsMpcIndex"))
if mibBuilder.loadTexts: wfmpsMpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpcEntry.setDescription('Each row defines one MPC identified by an index and its control ATM address.')
wfmpsMpsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsMpsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpsIndex.setDescription('Local Index (instance )of the Mps. ')
wfmpsMpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpcIndex.setDescription('The local index for the mpc represented by this entry')
wfmpsMpcCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMpcCtrlAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpcCtrlAtmAddr.setDescription('MPC control ATM address.')
wfmpsMpcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 9, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsMpcSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsMpcSlot.setDescription('The Slot number of the slot on which this MPS is instantiated.')
wfmpsDebugTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10), )
if mibBuilder.loadTexts: wfmpsDebugTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugTable.setDescription('The MPOA Server Debug Message Creation Table. This table represents the attributes necessary to send a message to the approprieate MPS gates for debug purpose.')
wfmpsDebugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1), ).setIndexNames((0, "Wellfleet-WFMPS-MIB", "wfmpsDebugSlot"))
if mibBuilder.loadTexts: wfmpsDebugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugEntry.setDescription('MPOA Server Debugd Entry. Each entry contains identity of the MPS being Debugged.')
wfmpsDebugSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfmpsDebugSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugSlot.setDescription('The Slot number of the slot on which this MPS is ainstantiated.')
wfmpsDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugIndex.setDescription('A value which uniquely identifies an mps being debugged.')
wfmpsDebugDestGid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mpsProc", 1), ("mpsCtrl", 2), ("mpsVCC", 3), ("mpsMstr", 4))).clone('mpsProc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugDestGid.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugDestGid.setDescription(' Send the message to the gate specified.')
wfmpsDebugMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugMsg.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugMsg.setDescription('Send the gived message to DestId.')
wfmpsDebugSendEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugSendEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugSendEnable.setDescription('Send the message if enabled.')
wfmpsDebugSignalNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugSignalNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugSignalNum.setDescription('Send the given signal to DestId.')
wfmpsDebugSignalSendEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfmpsDebugSignalSendEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfmpsDebugSignalSendEnable.setDescription('Send the Signal if enabled.')
mibBuilder.exportSymbols("Wellfleet-WFMPS-MIB", wfmpsMappingEntry=wfmpsMappingEntry, wfmpsProtocolEntry=wfmpsProtocolEntry, wfmpsEgressCacheNextHopAddr=wfmpsEgressCacheNextHopAddr, wfmpsStatRxMpoaImpReplyInsufSCResources=wfmpsStatRxMpoaImpReplyInsufSCResources, wfmpsDisable=wfmpsDisable, wfmpsActualTable=wfmpsActualTable, wfmpsProtSlot=wfmpsProtSlot, wfmpsEgressCacheId=wfmpsEgressCacheId, wfmpsConfigTable=wfmpsConfigTable, wfmpsIngressCacheEntry=wfmpsIngressCacheEntry, wfmpsEgressCacheEntry=wfmpsEgressCacheEntry, wfmpsStatRxMpoaImpReplyInsufECResources=wfmpsStatRxMpoaImpReplyInsufECResources, wfmpsEgressCacheNextHopInternetworkAddrType=wfmpsEgressCacheNextHopInternetworkAddrType, wfmpsStatTxNhrpResolveRequests=wfmpsStatTxNhrpResolveRequests, wfmpsStatisticsEntry=wfmpsStatisticsEntry, wfmpsEgressCacheDataLinkHeader=wfmpsEgressCacheDataLinkHeader, wfmpsActualGiveupTime=wfmpsActualGiveupTime, wfmpsCct=wfmpsCct, wfmpsCacheIpOverRide=wfmpsCacheIpOverRide, wfmpsMpcEntry=wfmpsMpcEntry, wfmpsRowStatus=wfmpsRowStatus, wfmpsEgressCacheTable=wfmpsEgressCacheTable, wfmpsStatTxNhrpResolveReplies=wfmpsStatTxNhrpResolveReplies, wfmpsStatTxMpoaResolveReplyUnspecifiedOther=wfmpsStatTxMpoaResolveReplyUnspecifiedOther, wfmpsIngressCacheHoldTime=wfmpsIngressCacheHoldTime, wfmpsStatSlot=wfmpsStatSlot, wfmpsActualInitialRetryTime=wfmpsActualInitialRetryTime, wfmpsIngressCacheTable=wfmpsIngressCacheTable, wfmpsStatRxMpoaResolveRequests=wfmpsStatRxMpoaResolveRequests, wfmpsActualState=wfmpsActualState, wfmpsInternetworkLayerProtocol=wfmpsInternetworkLayerProtocol, wfmpsStatTxMpoaResolveReplyOther=wfmpsStatTxMpoaResolveReplyOther, wfmpsActualKeepAliveLifeTime=wfmpsActualKeepAliveLifeTime, wfmpsStatRxMpoaImpReplyInsufEitherResources=wfmpsStatRxMpoaImpReplyInsufEitherResources, wfmpsConfigMpsName=wfmpsConfigMpsName, wfmpsEgressMpcIndex=wfmpsEgressMpcIndex, wfmpsStatRxMpoaEgressCachePurgeRequests=wfmpsStatRxMpoaEgressCachePurgeRequests, wfmpsDelete=wfmpsDelete, wfmpsStatTxMpoaResolveReplyInsufECResources=wfmpsStatTxMpoaResolveReplyInsufECResources, wfmpsStatRxMpoaImpReplyAcks=wfmpsStatRxMpoaImpReplyAcks, wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps=wfmpsStatTxMpoaResolveReplyUnsupportedMacEncaps, wfmpsProtIndex=wfmpsProtIndex, wfmpsStatTxMpoaEgressCachePurgeReplies=wfmpsStatTxMpoaEgressCachePurgeReplies, wfmpsDebugDestGid=wfmpsDebugDestGid, wfmpsProtocolTable=wfmpsProtocolTable, wfmpsEgressCacheState=wfmpsEgressCacheState, wfmpsMpcCtrlAtmAddr=wfmpsMpcCtrlAtmAddr, wfmpsStatTxMpoaResolveReplyAcks=wfmpsStatTxMpoaResolveReplyAcks, wfmpsMapSlot=wfmpsMapSlot, wfmpsMpcSlot=wfmpsMpcSlot, wfmpsConfigEntry=wfmpsConfigEntry, wfmpsMappingDelete=wfmpsMappingDelete, wfmpsDebugEntry=wfmpsDebugEntry, wfmpsDebugIndex=wfmpsDebugIndex, wfmpsCnfDelete=wfmpsCnfDelete, wfmpsDebugSlot=wfmpsDebugSlot, wfmpsEntryTable=wfmpsEntryTable, wfmpsMpcTable=wfmpsMpcTable, wfmpsDiscontinuityTime=wfmpsDiscontinuityTime, wfmpsCacheReverifyTimer=wfmpsCacheReverifyTimer, wfmpsKeepAliveTime=wfmpsKeepAliveTime, wfmpsIngressCacheNhrpRequestId=wfmpsIngressCacheNhrpRequestId, wfmpsIngressCacheDestAddr=wfmpsIngressCacheDestAddr, wfmpsIngressCacheMpoaRequestId=wfmpsIngressCacheMpoaRequestId, wfmpsEgressIndex=wfmpsEgressIndex, wfmpsDebugSignalNum=wfmpsDebugSignalNum, wfmpsLECSAddress=wfmpsLECSAddress, wfmpsStatRxMpoaImpReplyUnsupportedInetProt=wfmpsStatRxMpoaImpReplyUnsupportedInetProt, wfmpsDebugMsg=wfmpsDebugMsg, wfmpsDebugSignalSendEnable=wfmpsDebugSignalSendEnable, wfmpsMappingRowStatus=wfmpsMappingRowStatus, wfmpsDebugMsgLevel=wfmpsDebugMsgLevel, wfmpsIngressCacheServiceCategory=wfmpsIngressCacheServiceCategory, wfmpsMappingTable=wfmpsMappingTable, wfmpsProtocolDelete=wfmpsProtocolDelete, wfmpsMapIndex=wfmpsMapIndex, wfmpsStatTxMpoaImpRequests=wfmpsStatTxMpoaImpRequests, wfmpsEgressCacheMpoaRequestId=wfmpsEgressCacheMpoaRequestId, wfmpsLECSValue=wfmpsLECSValue, wfmpsIngressCacheSourceMpcAtmAddr=wfmpsIngressCacheSourceMpcAtmAddr, wfmpsActualRetryTimeMaximum=wfmpsActualRetryTimeMaximum, wfmpsInitialRetryTime=wfmpsInitialRetryTime, wfmpsEgressSlot=wfmpsEgressSlot, wfmpsEgressCacheHoldTime=wfmpsEgressCacheHoldTime, wfmpsStatRxNhrpResolveRequests=wfmpsStatRxNhrpResolveRequests, wfmpsMpcIndex=wfmpsMpcIndex, wfmpsActIndex=wfmpsActIndex, wfmpsStatisticsTable=wfmpsStatisticsTable, wfmpsDebugTable=wfmpsDebugTable, wfmpsStatGiveupTimeExpireds=wfmpsStatGiveupTimeExpireds, wfmpsEgressCacheSourceClientAtmAddr=wfmpsEgressCacheSourceClientAtmAddr, wfmpsStatRxNhrpResolveReplies=wfmpsStatRxNhrpResolveReplies, wfmpsStatTxMpoaTriggers=wfmpsStatTxMpoaTriggers, wfmpsDebugSendEnable=wfmpsDebugSendEnable, wfmpsEgressCacheNhrpRequestId=wfmpsEgressCacheNhrpRequestId, wfmpsActualCtrlAtmAddr=wfmpsActualCtrlAtmAddr, wfmpsIngressIndex=wfmpsIngressIndex, wfmpsIngressCacheDestInternetworkAddrType=wfmpsIngressCacheDestInternetworkAddrType, wfmpsGiveupTime=wfmpsGiveupTime, wfmpsIngressSlot=wfmpsIngressSlot, wfmpsIngressMpcIndex=wfmpsIngressMpcIndex, wfmpsRetryTimeMaximum=wfmpsRetryTimeMaximum, wfmpsAddrGenerateMode=wfmpsAddrGenerateMode, wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps=wfmpsStatRxMpoaImpReplyUnsupportedMacEncaps, wfmpsEgressCacheElanId=wfmpsEgressCacheElanId, wfmpsInitialCacheSize=wfmpsInitialCacheSize, wfmpsConfigMode=wfmpsConfigMode, wfmpsStatRxMpoaImpReplyUnspecifiedOther=wfmpsStatRxMpoaImpReplyUnspecifiedOther, wfmpsActualEntry=wfmpsActualEntry, wfmpsMpsIndex=wfmpsMpsIndex, wfmpsStatTxMpoaResolveReplyInsufEitherResources=wfmpsStatTxMpoaResolveReplyInsufEitherResources, wfmpsStatTxMpoaResolveReplyInsufSCResources=wfmpsStatTxMpoaResolveReplyInsufSCResources, wfmpsIngressCacheSrcAddr=wfmpsIngressCacheSrcAddr, wfmpsStatIndex=wfmpsStatIndex, wfmpsIngressCacheState=wfmpsIngressCacheState, wfmpsSlot=wfmpsSlot, wfmpsIngressCacheResolvedAtmAddr=wfmpsIngressCacheResolvedAtmAddr, wfmpsKeepAliveLifeTime=wfmpsKeepAliveLifeTime, wfmpsMaxCacheSize=wfmpsMaxCacheSize, wfmpsStatTxMpoaResolveReplyUnsupportedInetProt=wfmpsStatTxMpoaResolveReplyUnsupportedInetProt, wfmpsIngressCachePrefixLen=wfmpsIngressCachePrefixLen, wfmpsCnfSlot=wfmpsCnfSlot, wfmpsCtrlAtmAddr=wfmpsCtrlAtmAddr, wfmpsEgressCacheServiceCategory=wfmpsEgressCacheServiceCategory, wfmpsDefaultHoldingTime=wfmpsDefaultHoldingTime, wfmpsActualConfigMode=wfmpsActualConfigMode, wfmpsIngressCacheSrcInternetworkAddrType=wfmpsIngressCacheSrcInternetworkAddrType, wfmpslecIndex=wfmpslecIndex, wfmpsCnfIndex=wfmpsCnfIndex, wfmpsEntry=wfmpsEntry, wfmpsActualKeepAlive=wfmpsActualKeepAlive, wfmpsActualDefaultHoldingTime=wfmpsActualDefaultHoldingTime, wfmpsProtocolRowStatus=wfmpsProtocolRowStatus, wfmpsStatRxMpoaImpReplyOther=wfmpsStatRxMpoaImpReplyOther, wfmpsActSlot=wfmpsActSlot)

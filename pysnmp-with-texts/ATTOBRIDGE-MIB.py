#
# PySNMP MIB module ATTOBRIDGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATTOBRIDGE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, experimental, IpAddress, enterprises, Integer32, TimeTicks, ObjectIdentity, Unsigned32, NotificationType, MibIdentifier, Gauge32, Counter32, iso, Bits, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "experimental", "IpAddress", "enterprises", "Integer32", "TimeTicks", "ObjectIdentity", "Unsigned32", "NotificationType", "MibIdentifier", "Gauge32", "Counter32", "iso", "Bits", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
attotech = MibIdentifier((1, 3, 6, 1, 4, 1, 4547))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 4547, 1))
bridge = ModuleIdentity((1, 3, 6, 1, 4, 1, 4547, 1, 2))
if mibBuilder.loadTexts: bridge.setLastUpdated('200509200000Z')
if mibBuilder.loadTexts: bridge.setOrganization('ATTO Technology, Inc.')
if mibBuilder.loadTexts: bridge.setContactInfo('ATTO')
if mibBuilder.loadTexts: bridge.setDescription('Bridge Custom MIB')
bridgeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 4547, 1, 2, 1))
bridgeStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2))
bridgeTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3))
trapsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapsEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: trapsEnabled.setDescription('Indicates whether traps are enabled or disabled.')
snmpUpdatesEnabled = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpUpdatesEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: snmpUpdatesEnabled.setDescription('Indicates whether SNMP updates are enabled or disabled.')
snmpExtendedEnabled = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpExtendedEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: snmpExtendedEnabled.setDescription('Indicates whether extended SNMP is enabled or disabled.')
tempSensorTable = MibTable((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 1), )
if mibBuilder.loadTexts: tempSensorTable.setStatus('mandatory')
if mibBuilder.loadTexts: tempSensorTable.setDescription('The temperature sensor table stores information about the bridge temperature sensor.')
tempSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 1, 1), ).setIndexNames((0, "ATTOBRIDGE-MIB", "tempSensorIndex"))
if mibBuilder.loadTexts: tempSensorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tempSensorEntry.setDescription('The temperature sensor table stores information about the bridge temperature sensor.')
tempSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tempSensorIndex.setDescription('Used to index the sensor in the temperature sensor table.')
tempSensorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("critical", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tempSensorStatus.setDescription('The current status of the sensor (normal, warning or critical).')
temperature = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: temperature.setStatus('mandatory')
if mibBuilder.loadTexts: temperature.setDescription('The current temperature of the sensor.')
voltageSensorTable = MibTable((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 2), )
if mibBuilder.loadTexts: voltageSensorTable.setStatus('mandatory')
if mibBuilder.loadTexts: voltageSensorTable.setDescription('The voltage sensor table stores information about the bridge voltage sensor.')
voltageSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 2, 1), ).setIndexNames((0, "ATTOBRIDGE-MIB", "voltageSensorIndex"))
if mibBuilder.loadTexts: voltageSensorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voltageSensorEntry.setDescription('The voltage sensor table stores information about the bridge voltage sensor.')
voltageSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voltageSensorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voltageSensorIndex.setDescription('Used to index the sensor in the voltage sensor table.')
voltageSensorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("critical", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voltageSensorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voltageSensorStatus.setDescription('The current status of the sensor (normal, warning or critical).')
voltage = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voltage.setStatus('mandatory')
if mibBuilder.loadTexts: voltage.setDescription('The current voltage of the sensor.')
deviceCount = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceCount.setStatus('mandatory')
if mibBuilder.loadTexts: deviceCount.setDescription('Number of devices present.')
deviceCacheTable = MibTable((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5), )
if mibBuilder.loadTexts: deviceCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceCacheTable.setDescription('The device table stores information about the devices attached to the bridge.')
deviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1), ).setIndexNames((0, "ATTOBRIDGE-MIB", "deviceCacheIndex"))
if mibBuilder.loadTexts: deviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: deviceEntry.setDescription('The device table stores information about the devices attached to the bridge.')
deviceCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceCacheIndex.setStatus('mandatory')
if mibBuilder.loadTexts: deviceCacheIndex.setDescription('Used to index the device table.')
deviceSource = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSource.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSource.setDescription('A string representing the source interface, meaning the interface exposed to the host.')
deviceDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceDestination.setStatus('mandatory')
if mibBuilder.loadTexts: deviceDestination.setDescription('A string representing the destination interface, meaning the interface of the target device.')
deviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceType.setDescription('Device type (i.e. DISK, TAPE, etc.) of attached device.')
deviceVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceVendor.setStatus('mandatory')
if mibBuilder.loadTexts: deviceVendor.setDescription('Vendor name of attached device, from inquiry data.')
deviceProduct = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceProduct.setStatus('mandatory')
if mibBuilder.loadTexts: deviceProduct.setDescription('Product name of attached device, from inquiry data.')
deviceRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRevision.setStatus('mandatory')
if mibBuilder.loadTexts: deviceRevision.setDescription('Revision of attached device, from inquiry data.')
deviceState = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("offline", 0), ("online", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceState.setStatus('mandatory')
if mibBuilder.loadTexts: deviceState.setDescription('The current state of the device (online, offline, or unknown).')
errorCount = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorCount.setStatus('mandatory')
if mibBuilder.loadTexts: errorCount.setDescription('Number of errors that have occured since last bridge power-on or reset.')
errorsSinceUpdate = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorsSinceUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: errorsSinceUpdate.setDescription('Number of errors that have occured since last MIB scan, which is approximately every 15sec.')
errorTable = MibTable((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8), )
if mibBuilder.loadTexts: errorTable.setStatus('mandatory')
if mibBuilder.loadTexts: errorTable.setDescription('The Device Error table stores information about errors that have occurred with the devices attached to the bridge.')
errorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1), ).setIndexNames((0, "ATTOBRIDGE-MIB", "errorIndex"))
if mibBuilder.loadTexts: errorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: errorEntry.setDescription('The Device Error table stores information about errors that have occurred with the devices attached to the bridge.')
errorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: errorIndex.setDescription('Used to index the error device table.')
errorDateStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorDateStamp.setStatus('mandatory')
if mibBuilder.loadTexts: errorDateStamp.setDescription('Date at which the error occurred.')
errorTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: errorTimeStamp.setDescription('Time at which the error occurred.')
errorInitiator = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorInitiator.setStatus('mandatory')
if mibBuilder.loadTexts: errorInitiator.setDescription('A string representing the initiator which issued the failed command.')
errorSource = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorSource.setStatus('mandatory')
if mibBuilder.loadTexts: errorSource.setDescription('A string representing the source interface, meaning the interface exposed to the host, which is associated with the error.')
errorOpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorOpCode.setStatus('mandatory')
if mibBuilder.loadTexts: errorOpCode.setDescription('OpCode of the command which failed.')
errorSenseKey = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorSenseKey.setStatus('mandatory')
if mibBuilder.loadTexts: errorSenseKey.setDescription('Sense Key returned as a result of the failed command.')
errorASC = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorASC.setStatus('mandatory')
if mibBuilder.loadTexts: errorASC.setDescription('ASC returned as a result of the failed command.')
errorASCQ = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorASCQ.setStatus('mandatory')
if mibBuilder.loadTexts: errorASCQ.setDescription('ASCQ returned as a result of the failed command.')
errorLogSense = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 2, 8, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorLogSense.setStatus('mandatory')
if mibBuilder.loadTexts: errorLogSense.setDescription('Log Sense returned as a result of the failed command.')
trapMaxClients = MibScalar((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapMaxClients.setStatus('mandatory')
if mibBuilder.loadTexts: trapMaxClients.setDescription('The maximum number of SNMP trap recipients supported by the unit.')
trapClientTable = MibTable((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3), )
if mibBuilder.loadTexts: trapClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientTable.setDescription('A table containing a row for each IP address/port number that traps will be sent to.')
trapClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1), ).setIndexNames((0, "ATTOBRIDGE-MIB", "trapClientIndex"))
if mibBuilder.loadTexts: trapClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientEntry.setDescription('Ip/Port pair for a specific client.')
trapClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientIndex.setDescription('Used to index a trap client in the trapClientTable.')
trapClientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapClientIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientIpAddress.setDescription('The IP address of a client registered for traps in dotted notation.')
trapClientPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapClientPort.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientPort.setDescription('The UDP port to send traps for this host. Normally this would be the standard trap port (162). This object is an index and must be specified to create a row in this table.')
trapClientFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("critical", 2), ("warning", 3), ("informational", 4), ("all", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapClientFilter.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientFilter.setDescription("This value defines the trap severity filter for this trap host. The unit will send traps to this host that have a severity level less than or equal to this value. The default value of this object is 'warning'.")
trapClientRowState = MibTableColumn((1, 3, 6, 1, 4, 1, 4547, 1, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rowDestroy", 1), ("rowInactive", 2), ("rowActive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapClientRowState.setStatus('mandatory')
if mibBuilder.loadTexts: trapClientRowState.setDescription('Specifies the state of the row. rowDestroy READ : Can never happen WRITE : Remove this row from the table. rowInactive READ : Indicates that this row does not exist, but that traps are not enabled to be sent to the target. WRITE : If the row does not exist, and the agent allows writes to the trap table, then a new row is created. The values of the optional columns will be set to default values. Traps are not enabled to be sent to the target. If the row already existed, then traps are disabled from being sent to the target. rowActive READ : Indicates that this row exists, and that traps are enabled to be sent to the target. WRITE : If the row does not exist, and the agent allows writes to the trap table, then a new row is created. The values of the optional columns will be set to default traps. If the row already exists then traps are enabled to be sent to the target. A value of rowActive or rowInactive must be specified to create a row in the table.')
bridgeTempStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 4547) + (0,1)).setObjects(("ATTOBRIDGE-MIB", "tempSensorIndex"), ("ATTOBRIDGE-MIB", "tempSensorStatus"), ("ATTOBRIDGE-MIB", "temperature"))
if mibBuilder.loadTexts: bridgeTempStatusChanged.setDescription('The bridgeTempStatusChanged trap supports notification of temperature status changes in the bridge. The following information is returned: tempSensorIndex - the sensor of concern tempSensorStatus - the current status of the sensor (normal, warning, critical) temperature - current temperature of the sensor Recommended severity level (for filtering): warning')
bridgeVoltageStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 4547) + (0,2)).setObjects(("ATTOBRIDGE-MIB", "voltageSensorIndex"), ("ATTOBRIDGE-MIB", "voltageSensorStatus"), ("ATTOBRIDGE-MIB", "voltage"))
if mibBuilder.loadTexts: bridgeVoltageStatusChanged.setDescription('The bridgeVoltageStatusChanged trap supports notification of temperature status changes in the bridge. The following information is returned: voltageSensorIndex - the sensor of concern voltageSensorStatus - the current status of the sensor (normal, warning, critical) voltage - current temperature of the sensor Recommended severity level (for filtering): warning')
bridgeDeviceTransition = NotificationType((1, 3, 6, 1, 4, 1, 4547) + (0,4)).setObjects(("ATTOBRIDGE-MIB", "deviceCacheIndex"), ("ATTOBRIDGE-MIB", "deviceSource"), ("ATTOBRIDGE-MIB", "deviceState"))
if mibBuilder.loadTexts: bridgeDeviceTransition.setDescription('The bridgeDeviceTransition trap supports notification of device online/offline status changes in the bridge. The following information is returned: deviceCacheIndex - the device of concern deviceSource - the description of the source device deviceState - the current state of the device Recommended severity level (for filtering): informational')
bridgeDeviceError = NotificationType((1, 3, 6, 1, 4, 1, 4547) + (0,5)).setObjects(("ATTOBRIDGE-MIB", "errorSource"), ("ATTOBRIDGE-MIB", "errorOpCode"), ("ATTOBRIDGE-MIB", "errorSenseKey"), ("ATTOBRIDGE-MIB", "errorASC"), ("ATTOBRIDGE-MIB", "errorASCQ"), ("ATTOBRIDGE-MIB", "errorsSinceUpdate"))
if mibBuilder.loadTexts: bridgeDeviceError.setDescription('The bridgeDeviceTransition trap supports notification of device online/offline status changes in the bridge. The following information is returned: errorSource - the description of the source device errorOpCode - the offending command errorSenseKey - the sense key returned by the device errorASC - the ASC returned by the device errorASCQ - the ASCQ returned by the device errorsSinceUpdate - the number of errors in the past 15sec Recommended severity level (for filtering): informational')
mibBuilder.exportSymbols("ATTOBRIDGE-MIB", voltage=voltage, tempSensorStatus=tempSensorStatus, trapClientEntry=trapClientEntry, deviceProduct=deviceProduct, deviceDestination=deviceDestination, errorCount=errorCount, trapClientTable=trapClientTable, voltageSensorEntry=voltageSensorEntry, trapClientRowState=trapClientRowState, deviceCount=deviceCount, errorASCQ=errorASCQ, attotech=attotech, trapClientPort=trapClientPort, errorInitiator=errorInitiator, trapsEnabled=trapsEnabled, trapClientFilter=trapClientFilter, temperature=temperature, errorSource=errorSource, bridgeVoltageStatusChanged=bridgeVoltageStatusChanged, deviceEntry=deviceEntry, deviceType=deviceType, bridgeConfig=bridgeConfig, deviceCacheTable=deviceCacheTable, deviceSource=deviceSource, errorSenseKey=errorSenseKey, bridgeDeviceError=bridgeDeviceError, bridgeTrapInfo=bridgeTrapInfo, trapMaxClients=trapMaxClients, snmpUpdatesEnabled=snmpUpdatesEnabled, trapClientIndex=trapClientIndex, bridgeTempStatusChanged=bridgeTempStatusChanged, errorASC=errorASC, bridgeStatus=bridgeStatus, bridge=bridge, tempSensorIndex=tempSensorIndex, errorsSinceUpdate=errorsSinceUpdate, PYSNMP_MODULE_ID=bridge, errorLogSense=errorLogSense, voltageSensorTable=voltageSensorTable, tempSensorEntry=tempSensorEntry, trapClientIpAddress=trapClientIpAddress, errorIndex=errorIndex, products=products, errorTimeStamp=errorTimeStamp, voltageSensorIndex=voltageSensorIndex, snmpExtendedEnabled=snmpExtendedEnabled, tempSensorTable=tempSensorTable, errorOpCode=errorOpCode, bridgeDeviceTransition=bridgeDeviceTransition, deviceCacheIndex=deviceCacheIndex, voltageSensorStatus=voltageSensorStatus, errorDateStamp=errorDateStamp, deviceRevision=deviceRevision, errorEntry=errorEntry, deviceVendor=deviceVendor, deviceState=deviceState, errorTable=errorTable)

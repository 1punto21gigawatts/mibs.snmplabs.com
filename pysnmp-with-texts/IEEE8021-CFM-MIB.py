#
# PySNMP MIB module IEEE8021-CFM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IEEE8021-CFM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:13:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
ieee802dot1mibs, IEEE8021VlanIndex = mibBuilder.importSymbols("IEEE8021-TC-MIB", "ieee802dot1mibs", "IEEE8021VlanIndex")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
LldpPortIdSubtype, LldpChassisId, LldpChassisIdSubtype, LldpPortId = mibBuilder.importSymbols("LLDP-MIB", "LldpPortIdSubtype", "LldpChassisId", "LldpChassisIdSubtype", "LldpPortId")
VlanIdOrNone, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIdOrNone", "VlanId")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter64, iso, MibIdentifier, ModuleIdentity, Unsigned32, Integer32, Gauge32, IpAddress, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Bits, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Integer32", "Gauge32", "IpAddress", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Bits", "TimeTicks")
MacAddress, DisplayString, TAddress, TimeInterval, TDomain, RowStatus, TruthValue, TimeStamp, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "TAddress", "TimeInterval", "TDomain", "RowStatus", "TruthValue", "TimeStamp", "TextualConvention")
ieee8021CfmMib = ModuleIdentity((1, 3, 111, 2, 802, 1, 1, 8))
ieee8021CfmMib.setRevisions(('2014-12-15 00:00', '2011-02-27 00:00', '2008-11-18 00:00', '2008-10-15 00:00', '2007-06-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ieee8021CfmMib.setRevisionsDescriptions(('Published as part of IEEE Std 802.1Q 2014 revision. Cross references updated and corrected.', 'Addition of support for ICC format and minor edits as part of 2011 revision of IEEE Std 802.1Q.', 'Added new columns to the dot1agCfmMepTable to support new MEP functionality required for PBB-TE support. Modified dot1agCfmMepDbTable to support new functionality requried for PBB-TE. Modified conformance clauses to indicate objects needed for PBB-TE support.', 'The IEEE8021-CFM-MIB Module was originally included in IEEE 802.1ag-2007. Some objects in this module are deprecated and replaced by objects in the IEEE8021-CFM-V2-MIB module defined in 802.1ap. This revision is included in IEEE 802.1ap', 'Included in IEEE 802.1ag-2007 ',))
if mibBuilder.loadTexts: ieee8021CfmMib.setLastUpdated('201412150000Z')
if mibBuilder.loadTexts: ieee8021CfmMib.setOrganization('IEEE 802.1 Working Group')
if mibBuilder.loadTexts: ieee8021CfmMib.setContactInfo('WG-URL: http://grouper.ieee.org/groups/802/1/index.html WG-EMail: stds-802-1@ieee.org Contact: IEEE 802.1 Working Group Chair Postal: C/O IEEE 802.1 Working Group IEEE Standards Association 445 Hoes Lane P.O. Box 1331 Piscataway NJ 08855-1331 USA E-mail: STDS-802-1-L@LISTSERV.IEEE.ORG ')
if mibBuilder.loadTexts: ieee8021CfmMib.setDescription('Connectivity Fault Management module. Unless otherwise indicated, the references in this MIB module are to IEEE Std 802.1Q-2014. Copyright (C) IEEE (2014). This version of this MIB module is part of IEEE Syd 802.1Q; see the draft itself for full legal notices.')
dot1agNotifications = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 0))
dot1agMIBObjects = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1))
dot1agCfmConformance = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2))
dot1agCfmStack = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 1))
dot1agCfmDefaultMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 2))
dot1agCfmVlan = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 3))
dot1agCfmConfigErrorList = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 4))
dot1agCfmMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 5))
dot1agCfmMa = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 6))
dot1agCfmMep = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 7))
class Dot1agCfmMaintDomainNameType(TextualConvention, Integer32):
    reference = '21.6.5, Table 21 19'
    description = 'A value that represents a type (and thereby the format) of a Dot1agCfmMaintDomainName. The value can be one of the following: ieeeReserved(0) Reserved for definition by IEEE 802.1 recommend to not use zero unless absolutely needed. none(1) No format specified, usually because there is not (yet) a Maintenance Domain Name. In this case, a zero length OCTET STRING for the Domain Name field is acceptable. dnsLikeName(2) Domain Name like string, globally unique text string derived from a DNS name. macAddrAndUint(3) MAC address + 2-octet (unsigned) integer. charString(4) RFC2579 DisplayString, except that the character codes 0-31 (decimal) are not used. ieeeReserved(xx) Reserved for definition by IEEE 802.1 xx values can be [5..31] and [64..255] ituReserved(xx) Reserved for definition by ITU-T Y.1731 xx values range from [32..63] To support future extensions, the Dot1agCfmMaintDomainNameType textual convention SHOULD NOT be subtyped in object type definitions. It MAY be subtyped in compliance statements in order to require only a subset of these address types for a compliant implementation. Implementations MUST ensure that Dot1agCfmMaintDomainNameType objects and any dependent objects (e.g., Dot1agCfmMaintDomainName objects) are consistent. An inconsistentValue error MUST be generated if an attempt to change an Dot1agCfmMaintDomainNameType object would, for example, lead to an undefined Dot1agCfmMaintDomainName value. In particular, Dot1agCfmMaintDomainNameType/Dot1agCfmMaintDomainName pairs MUST be changed together if the nameType changes. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("dnsLikeName", 2), ("macAddressAndUint", 3), ("charString", 4))

class Dot1agCfmMaintDomainName(TextualConvention, OctetString):
    reference = '21.6.5'
    description = "Denotes a generic Maintenance Domain Name. A Dot1agCfmMaintDomainName value is always interpreted within the context of a Dot1agCfmMaintDomainNameType value. Every usage of the Dot1agCfmMaintDomainName textual convention is required to specify the Dot1agCfmMaintDomainNameType object that provides the context. It is suggested that the Dot1agCfmMaintDomainNameType object be logically registered before the object(s) that use the Dot1agCfmMaintDomainName textual convention, if they appear in the same logical row. The value of a Dot1agCfmMaintDomainName object MUST always be consistent with the value of the associated Dot1agCfmMaintDomainNameType object. Attempts to set an Dot1agCfmMaintDomainName object to a value inconsistent with the associated Dot1agCfmMaintDomainNameType MUST fail with an inconsistentValue error. When this textual convention is used as the syntax of an index object, there may be issues with the limit of 128 sub-identifiers specified in SMIv2, IETF STD 58. In this case, the object definition MUST include a 'SIZE' clause to limit the number of potential instance sub-identifiers; otherwise the applicable constraints MUST be stated in the appropriate conceptual row DESCRIPTION clauses, or in the surrounding documentation if there is no single DESCRIPTION clause that is appropriate. A value of none(1) in the associated Dot1agCfmMaintDomainNameType object means that no Maintenance Domain name is present, and the contents of the Dot1agCfmMaintDomainName object are meaningless. See the DESCRIPTION of the Dot1agCfmMaintAssocNameType TEXTUAL-CONVENTION for a discussion of the length limits on the Maintenance Domain name and Maintenance Association name. "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 43)

class Dot1agCfmMaintAssocNameType(TextualConvention, Integer32):
    reference = '21.6.5.4, Table 21 20'
    description = 'A value that represents a type (and thereby the format) of a Dot1agCfmMaintAssocName. The value can be one of the following: ieeeReserved(0) Reserved for definition by IEEE 802.1 recommend to not use zero unless absolutely needed. primaryVid(1) Primary VLAN ID. 12 bits represented in a 2-octet integer: - least significant 4 bits of the first byte contains the most significant 4 bits of the 12 bits primary VID - second byte contains the least significant 8 bits of the primary VID 0 1 2 3 4 5 6 7 8 +-+-+-+-+-+-+-+-+ |0 0 0 0| (MSB) | +-+-+-+-+-+-+-+-+ | VID LSB | +-+-+-+-+-+-+-+-+ charString(2) RFC2579 DisplayString, except that the character codes 0-31 (decimal) are not used. (1..45) octets unsignedInt16 (3) 2-octet integer/big endian rfc2685VpnId(4) RFC 2685 VPN ID 3 octet VPN authority Organizationally Unique Identifier (OUI) or Company Identifier (CID) followed by 4 octet VPN index identifying VPN according to the OUI or CID: 0 1 2 3 4 5 6 7 8 +-+-+-+-+-+-+-+-+ |VPN OUI/CID MSB| +-+-+-+-+-+-+-+-+ |VPN OUI/CID | +-+-+-+-+-+-+-+-+ |VPN OUI/CID LSB| +-+-+-+-+-+-+-+-+ |VPN Index (MSB)| +-+-+-+-+-+-+-+-+ | VPN Index | +-+-+-+-+-+-+-+-+ | VPN Index | +-+-+-+-+-+-+-+-+ |VPN Index (LSB)| +-+-+-+-+-+-+-+-+ ieeeReserved(xx) Reserved for definition by IEEE 802.1 xx values can be [5..31] and [64..255] iccFormat(32) ICC-based format as specified in ITU-T Y.1731 ituReserved(xx) Reserved for definition by ITU-T Y.1731 xx values range from [33..63] To support future extensions, the Dot1agCfmMaintAssocNameType textual convention SHOULD NOT be subtyped in object type definitions. It MAY be subtyped in compliance statements in order to require only a subset of these address types for a compliant implementation. Implementations MUST ensure that Dot1agCfmMaintAssocNameType objects and any dependent objects (e.g., Dot1agCfmMaintAssocName objects) are consistent. An inconsistentValue error MUST be generated if an attempt to change an Dot1agCfmMaintAssocNameType object would, for example, lead to an undefined Dot1agCfmMaintAssocName value. In particular, Dot1agCfmMaintAssocNameType/Dot1agCfmMaintAssocName pairs MUST be changed together if the nameType changes. The Maintenance Domain name and Maintenance Association name, when put together into the CCM PDU, MUST total 48 octets or less. If the Dot1agCfmMaintDomainNameType object contains none(1), then the Dot1agCfmMaintAssocName object MUST be 45 octets or less in length. Otherwise, the length of the Dot1agCfmMaintDomainName object plus the length of the Dot1agCfmMaintAssocName object, added together, MUST total less than or equal to 44 octets. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 32))
    namedValues = NamedValues(("primaryVid", 1), ("charString", 2), ("unsignedInt16", 3), ("rfc2865VpnId", 4), ("iccFormat", 32))

class Dot1agCfmMaintAssocName(TextualConvention, OctetString):
    reference = '21.6.5.4, 21.6.5.5, 21.6.5.6'
    description = "Denotes a generic Maintenance Association Name. It is the part of the Maintenance Association Identifier which is unique within the Maintenance Domain Name and is appended to the Maintenance Domain Name to form the Maintenance Association Identifier (MAID). A Dot1agCfmMaintAssocName value is always interpreted within the context of a Dot1agCfmMaintAssocNameType value. Every usage of the Dot1agCfmMaintAssocName textual convention is required to specify the Dot1agCfmMaintAssocNameType object that provides the context. It is suggested that the Dot1agCfmMaintAssocNameType object be logically registered before the object(s) that use the Dot1agCfmMaintAssocName textual convention, if they appear in the same logical row. The value of a Dot1agCfmMaintAssocName object MUST always be consistent with the value of the associated Dot1agCfmMaintAssocNameType object. Attempts to set an Dot1agCfmMaintAssocName object to a value inconsistent with the associated Dot1agCfmMaintAssocNameType MUST fail with an inconsistentValue error. When this textual convention is used as the syntax of an index object, there may be issues with the limit of 128 sub-identifiers specified in SMIv2, IETF STD 58. In this case, the object definition MUST include a 'SIZE' clause to limit the number of potential instance sub-identifiers; otherwise the applicable constraints MUST be stated in the appropriate conceptual row DESCRIPTION clauses, or in the surrounding documentation if there is no single DESCRIPTION clause that is appropriate. "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 45)

class Dot1agCfmMDLevel(TextualConvention, Integer32):
    reference = '18.3, 21.4.1'
    description = "Integer identifying the Maintenance Domain Level (MD Level). Higher numbers correspond to higher Maintenance Domains, those with the greatest physical reach, with the highest values for customers' CFM PDUs. Lower numbers correspond to lower Maintenance Domains, those with more limited physical reach, with the lowest values for CFM PDUs protecting single Bridges or physical links. "
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class Dot1agCfmMDLevelOrNone(TextualConvention, Integer32):
    reference = '18.3, 12.14.3.1.3:c'
    description = "Integer identifying the Maintenance Domain Level (MD Level). Higher numbers correspond to higher Maintenance Domains, those with the greatest physical reach, with the highest values for customers' CFM packets. Lower numbers correspond to lower Maintenance Domains, those with more limited physical reach, with the lowest values for CFM PDUs protecting single Bridges or physical links. The value (-1) is reserved to indicate that no MA Level has been assigned. "
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 7), )
class Dot1agCfmMpDirection(TextualConvention, Integer32):
    reference = '12.14.6.3.2:c'
    description = 'Indicates the direction in which the Maintenance association (MEP or MIP) faces on the Bridge Port: down(1) Sends Continuity Check Messages away from the MAC Relay Entity. up(2) Sends Continuity Check Messages towards the MAC Relay Entity. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("down", 1), ("up", 2))

class Dot1agCfmPortStatus(TextualConvention, Integer32):
    reference = '12.14.7.6.3:f, 20.19.3, 21.5.4'
    description = 'An enumerated value from he Port Status TLV from the last CCM received from the last MEP. It indicates the ability of the Bridge Port on which the transmitting MEP resides to pass ordinary data, regardless of the status of the MAC (Table 21-10). psNoPortStateTLV(0) Indicates either that no CCM has been received or that no port status TLV was present in the last CCM received. psBlocked(1) Ordinary data cannot pass freely through the port on which the remote MEP resides. Value of enableRmepDefect is equal to false. psUp(2): Ordinary data can pass freely through the port on which the remote MEP resides. Value of enableRmepDefect is equal to true. NOTE: A 0 value is used for psNoPortStateTLV, so that additional code points can be added in a manner consistent with the Dot1agCfmInterfaceStatus textual convention. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("psNoPortStateTLV", 0), ("psBlocked", 1), ("psUp", 2))

class Dot1agCfmInterfaceStatus(TextualConvention, Integer32):
    reference = '12.14.7.6.3:g, 20.19.4, 21.5.5'
    description = 'An enumerated value from the Interface Status TLV from the last CCM received from the last MEP. It indicates the status of the Interface within which the MEP transmitting the CCM is configured, or the next lower Interface in the Interface Stack, if the MEP is not configured within an Interface. isNoInterfaceStatusTLV(0) Indicates either that no CCM has been received or that no interface status TLV was present in the last CCM received. isUp(1) The interface is ready to pass packets. isDown(2) The interface cannot pass packets isTesting(3) The interface is in some test mode. isUnknown(4) The interface status cannot be determined for some reason. isDormant(5) The interface is not in a state to pass packets but is in a pending state, waiting for some external event. isNotPresent(6) Some component of the interface is missing isLowerLayerDown(7) The interface is down due to state of the lower layer interfaces NOTE: A 0 value is used for isNoInterfaceStatusTLV, so that these code points can be kept consistent with new code points added to ifOperStatus in the IF-MIB. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("isNoInterfaceStatusTLV", 0), ("isUp", 1), ("isDown", 2), ("isTesting", 3), ("isUnknown", 4), ("isDormant", 5), ("isNotPresent", 6), ("isLowerLayerDown", 7))

class Dot1agCfmHighestDefectPri(TextualConvention, Integer32):
    reference = '12.14.7.7.2, 20.1.2, 20.35.9 '
    description = 'An enumerated value, equal to the contents of the variable highestDefect (20.35.9 and Table 20-1), indicating the highest-priority defect that has been present since the MEP Fault Notification Generator State Machine was last in the FNG_RESET state, either: none(0) no defects since FNG_RESET defRDICCM(1) DefRDICCM defMACstatus(2) DefMACstatus defRemoteCCM(3) DefRemoteCCM defErrorCCM(4) DefErrorCCM defXconCCM(5) DefXconCCM The value 0 is used for no defects so that additional higher priority values can be added, if needed, at a later time, and so that these values correspond with those in Dot1agCfmLowestAlarmPri. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("defRDICCM", 1), ("defMACstatus", 2), ("defRemoteCCM", 3), ("defErrorCCM", 4), ("defXconCCM", 5))

class Dot1agCfmLowestAlarmPri(TextualConvention, Integer32):
    reference = '12.14.7.1.3:k, 20.9.5'
    description = 'An integer value specifying the lowest priority defect that is allowed to generate a Fault Alarm (20.9.5), either: allDef(1) DefRDICCM, DefMACstatus, DefRemoteCCM, DefErrorCCM, and DefXconCCM; macRemErrXcon(2) Only DefMACstatus, DefRemoteCCM, DefErrorCCM, and DefXconCCM (default); remErrXcon(3) Only DefRemoteCCM, DefErrorCCM, and DefXconCCM; errXcon(4) Only DefErrorCCM and DefXconCCM; xcon(5) Only DefXconCCM; or noXcon(6) No defects DefXcon or lower are to be reported; '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("allDef", 1), ("macRemErrXcon", 2), ("remErrXcon", 3), ("errXcon", 4), ("xcon", 5), ("noXcon", 6))

class Dot1agCfmMepId(TextualConvention, Unsigned32):
    reference = '3.114, 19.2.1'
    description = 'Maintenance association Endpoint Identifier (MEPID): A small integer, unique over a given Maintenance Association, identifying a specific MEP. '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 8191)

class Dot1agCfmMepIdOrZero(TextualConvention, Unsigned32):
    reference = '19.2.1'
    description = 'Maintenance association Endpoint Identifier (MEPID): A small integer, unique over a given Maintenance Association, identifying a specific MEP. The special value 0 is allowed to indicate special cases, for example that no MEPID is configured. Whenever an object is defined with this SYNTAX, then the DESCRIPTION clause of such an object MUST specify what the special value of 0 means. '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), )
class Dot1agCfmMhfCreation(TextualConvention, Integer32):
    reference = '12.14.5.1.3:c, 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs. The valid values are: defMHFnone(1) No MHFs can be created for this VID. defMHFdefault(2) MHFs can be created on this VID on any Bridge port through which this VID can pass. defMHFexplicit(3) MHFs can be created for this VID only on Bridge ports through which this VID can pass, and only if a MEP is created at some lower MD Level. defMHFdefer(4) The creation of MHFs is determined by the corresponding Maintenance Domain variable (dot1agCfmMaCompMhfCreation). '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3), ("defMHFdefer", 4))

class Dot1agCfmIdPermission(TextualConvention, Integer32):
    reference = '12.14.6.1.3:d, 21.5.3'
    description = 'Indicates what, if anything, is to be included in the Sender ID TLV transmitted in CCMs, LBMs, LTMs, and LTRs. The valid values are: sendIdNone(1) The Sender ID TLV is not to be sent. sendIdChassis(2) The Chassis ID Length, Chassis ID Subtype, and Chassis ID fields of the Sender ID TLV are to be sent. sendIdManage(3) The Management Address Length and Management Address of the Sender ID TLV are to be sent. sendIdChassisManage(4) The Chassis ID Length, Chassis ID Subtype, Chassis ID, Management Address Length and Management Address fields are all to be sent. sendIdDefer(5) The contents of the Sender ID TLV are determined by the corresponding Maintenance Domain variable (dot1agCfmMaCompIdPermission). '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4), ("sendIdDefer", 5))

class Dot1agCfmCcmInterval(TextualConvention, Integer32):
    reference = '12.14.6.1.3:e, 20.8.1, 21.6.1.3'
    description = "Indicates the interval at which CCMs are sent by a MEP. The possible values are: intervalInvalid(0) No CCMs are sent (disabled). interval300Hz(1) CCMs are sent every 3 1/3 milliseconds (300Hz). interval10ms(2) CCMs are sent every 10 milliseconds. interval100ms(3) CCMs are sent every 100 milliseconds. interval1s(4) CCMs are sent every 1 second. interval10s(5) CCMs are sent every 10 seconds. interval1min(6) CCMs are sent every minute. interval10min(7) CCMs are sent every 10 minutes. Note: enumerations start at zero to match the 'CCM Interval field' protocol field. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("intervalInvalid", 0), ("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7))

class Dot1agCfmFngState(TextualConvention, Integer32):
    reference = '12.14.7.1.3:f, 20.35'
    description = 'Indicates the diferent states of the MEP Fault Notification Generator State Machine. fngReset(1) No defect has been present since the dot1agCfmMepFngResetTime timer expired, or since the state machine was last reset. fngDefect(2) A defect is present, but not for a long enough time to be reported (dot1agCfmMepFngAlarmTime). fngReportDefect(3) A momentary state during which the defect is reported by sending a dot1agCfmFaultAlarm notification, if that action is enabled. fngDefectReported(4) A defect is present, and some defect has been reported. fngDefectClearing(5) No defect is present, but the dot1agCfmMepFngResetTime timer has not yet expired. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("fngReset", 1), ("fngDefect", 2), ("fngReportDefect", 3), ("fngDefectReported", 4), ("fngDefectClearing", 5))

class Dot1agCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '12.14.7.5.3:g, 20.41.2.5, 21.9.5, Table 21 27'
    description = 'Possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class Dot1agCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '12.14.7.5.3:g, 20.41.2.6, 21.9.8.1, Table 21 30'
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("ingNoTlv", 0), ("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class Dot1agCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '12.14.7.5.3:o, 20.41.2.10, 21.9.9.1, Table 21 32'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("egrNoTlv", 0), ("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class Dot1agCfmRemoteMepState(TextualConvention, Integer32):
    reference = '12.14.7.6.3:b, 20.22'
    description = 'Operational state of the remote MEP state machine. This state machine monitors the reception of valid CCMs from a remote MEP with a specific MEPID. It uses a timer that expires in 3.5 times the length of time indicated by the dot1agCfmMaNetCcmInterval object. rMepIdle(1) Momentary state during reset. rMepStart(2) The timer has not expired since the state machine was reset, and no valid CCM has yet been received. rMepFailed(3) The timer has expired, both since the state machine was reset, and since a valid CCM was received. rMepOk(4) The timer has not expired since a valid CCM was received. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("rMepIdle", 1), ("rMepStart", 2), ("rMepFailed", 3), ("rMepOk", 4))

class Dot1afCfmIndexIntegerNextFree(TextualConvention, Unsigned32):
    description = 'An integer that may be used as a new Index in a table. The special value of 0 indicates that no more new entries can be created in the relevant table. When a MIB is used for configuration, an object with this SYNTAX always contains a legal value (if non-zero) for an index that is not currently used in the relevant table. The Command Generator (Network Management Application) reads this variable and uses the (non-zero) value read when creating a new row with an SNMP SET. When the SET is performed, the Command Responder (agent) MUST determine whether the value is indeed still unused; Two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds and the Command Responder (agent) changes the value of this object, according to an implementation-specific algorithm. If the value is in use, however, the SET fails. The Network Management Application MUST then re-read this variable to obtain a new usable value. An OBJECT-TYPE definition using this SYNTAX MUST specify the relevant table for which the object is providing this functionality. '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class Dot1agCfmMepDefects(TextualConvention, Bits):
    reference = '12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q, 12.14.7.1.3:r, 12.14.7.1.3:s.'
    description = 'A MEP can detect and report a number of defects, and multiple defects can be present at the same time. These defects are: bDefRDICCM(0) A remote MEP is reported the RDI bit in its last CCM. bDefMACstatus(1) Either some remote MEP is reporting its Interface Status TLV as not isUp, or all remote MEPs are reporting a Port Status TLV that contains some value other than psUp. bDefRemoteCCM(2) The MEP is not receiving valid CCMs from at least one of the remote MEPs. bDefErrorCCM(3) The MEP has received at least one invalid CCM whose CCM Interval has not yet timed out. bDefXconCCM(4) The MEP has received at least one CCM from either another MAID or a lower MD Level whose CCM Interval has not yet timed out. '
    status = 'current'
    namedValues = NamedValues(("bDefRDICCM", 0), ("bDefMACstatus", 1), ("bDefRemoteCCM", 2), ("bDefErrorCCM", 3), ("bDefXconCCM", 4))

class Dot1agCfmConfigErrors(TextualConvention, Bits):
    reference = '12.14.4.1.3:b, 22.2.3, 22.2.4'
    description = "While making the MIP creation evaluation described in 22.2.3, the management entity can encounter errors in the configuration. These are possible errors that can be encountered: CFMleak(0) MA x is associated with a specific VID list, one or more of the VIDs in MA x can pass through the Bridge Port, no Down MEP is configured on any Bridge Port for MA x, and some other MA y, at a higher MD Level than MA x, and associated with at least one of the VID(s) also in MA x, does have a MEP configured on the Bridge Port. conflictingVids(1) MA x is associated with a specific VID list, an Up MEP is configured on MA x on the Bridge Port, and some other MA y, associated with at least one of the VID(s) also in MA x, also has an Up MEP configured on some Bridge Port. ExcessiveLevels(2) The number of different MD Levels at which MIPs are to be created on this port exceeds the Bridge's capabilities (22.3). OverlappedLevels(3) A MEP is created for one VID at one MD Level, but a MEP is configured on another VID at that MD Level or higher, exceeding the Bridge's capabilities. "
    status = 'current'
    namedValues = NamedValues(("cfmLeak", 0), ("conflictingVids", 1), ("excessiveLevels", 2), ("overlappedLevels", 3))

class Dot1agCfmPbbComponentIdentifier(TextualConvention, Unsigned32):
    reference = '12.3 l)'
    description = 'A Provider Backbone Bridge (PBB) can comprise a number of components, each of which can be managed in a manner essentially equivalent to an 802.1Q Bridge. In order to access these components easily, an index is used in a number of tables. If any two tables are indexed by Dot1agCfmPbbComponentIdentifier, then entries in those tables indexed by the same value of Dot1agCfmPbbComponentIdentifier correspond to the same component. '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

dot1agCfmStackTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1), )
if mibBuilder.loadTexts: dot1agCfmStackTable.setReference('12.14.2')
if mibBuilder.loadTexts: dot1agCfmStackTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackTable.setDescription('There is one CFM Stack table per Bridge. It permits the retrieval of information about the Maintenance Points configured on any given interface. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmStackifIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackVlanIdOrNone"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackMdLevel"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackDirection"))
if mibBuilder.loadTexts: dot1agCfmStackEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackEntry.setDescription('The Stack table entry **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackifIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setReference('12.14.2.1.2:a')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setDescription('This object represents the Bridge Port or aggregated port on which MEPs or MHFs might be configured. Upon a restart of the system, the system SHALL, if necessary, change the value of this variable, and rearrange the dot1agCfmStackTable, so that it indexes the entry in the interface table with the same value of ifAlias that it indexed before the system restart. If no such entry exists, then the system SHALL delete all entries in the dot1agCfmStackTable with the interface index. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackVlanIdOrNone = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 2), VlanIdOrNone())
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setReference('12.14.2.1.2:d, 22.1.7')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setDescription('VLAN ID to which the MP is attached, or 0, if none. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 3), Dot1agCfmMDLevel())
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setReference('12.14.2.1.2:b')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setDescription('MD Level of the Maintenance Point. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 4), Dot1agCfmMpDirection())
if mibBuilder.loadTexts: dot1agCfmStackDirection.setReference('12.14.2.1.2:c')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setDescription('Direction in which the MP faces on the Bridge Port **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setReference('12.14.2.1.3:b')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setDescription('The index of the Maintenance Domain in the dot1agCfmMdTable to which the MP is associated, or 0, if none. ')
dot1agCfmStackMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setReference('12.14.2.1.3:c')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setDescription('The index of the MA in the dot1agCfmMaNetTable and dot1agCfmMaCompTable to which the MP is associated, or 0, if none. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmStackMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 7), Dot1agCfmMepIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMepId.setReference('12.14.2.1.3:d **NOTE: this object is deprecated due to re-indexing of the table. ')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setDescription('If an MEP is configured, the MEPID, else 0')
dot1agCfmStackMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setReference('12.14.2.1.3:e')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setDescription('MAC address of the MP. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmVlanTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1), )
if mibBuilder.loadTexts: dot1agCfmVlanTable.setReference('12.14.3.1.3:a, 12.14.3.2.2:a, 12.14.5.3.2:c, 12.14.6.1.3:b, 22.1.5.')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setDescription('This table defines the association of VIDs into VLANs. There is an entry in this table, for each component of the Bridge, for each VID that is: a) a VID belonging to a VLAN associated with more than one VID; and b) not the Primary VLAN of that VID. The entry in this table contains the Primary VID of the VLAN. By default, this table is empty, meaning that every VID is the Primary VID of a single-VID VLAN. VLANs that are associated with only one VID SHOULD NOT have an entry in this table. The writable objects in this table need to be persistent upon reboot or restart of a device. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmVlanEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmVlanComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmVlanVid"))
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setDescription('The VLAN table entry. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmVlanComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setDescription('The Bridge component within the system to which the information in this dot1agCfmVlanEntry applies. If the system is not a Bridge, or if only one component is present in the Bridge, then this variable (index) MUST be equal to 1. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmVlanVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 2), VlanId())
if mibBuilder.loadTexts: dot1agCfmVlanVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanVid.setDescription('This is a VLAN ID belonging to a VLAN that is associated with more than one VLAN ID, and this is not the Primary VID of the VLAN. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmVlanPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 3), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setDescription("This is the Primary VLAN ID of the VLAN with which this entry's dot1agCfmVlanVid is associated. This value MUST not equal the value of dot1agCfmVlanVid. **NOTE: this object is deprecated due to re-indexing of the table. ")
dot1agCfmVlanRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setDescription('The status of the row. The writable columns in a row can not be changed if the row is active. All columns MUST have a valid value before a row can be activated. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmDefaultMdDefLevel = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 1), Dot1agCfmMDLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setReference('12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setDescription('A value indicating the MD Level at which MHFs are to be created, and Sender ID TLV transmission by those MHFs is to be controlled, for each dot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdLevel object contains the value -1. After this initialization, this object needs to be persistent upon reboot or restart of a device. ')
dot1agCfmDefaultMdDefMhfCreation = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 2), Dot1agCfmMhfCreation().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))).clone('defMHFnone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setReference('12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setDescription('A value indicating if the Management entity can create MHFs (MIP Half Function) for the VID, for each dot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdMhfCreation object contains the value defMHFdefer. Since, in this variable, there is no encompassing Maintenance Domain, the value defMHFdefer is not allowed. After this initialization, this object needs to be persistent upon reboot or restart of a device. ')
dot1agCfmDefaultMdDefIdPermission = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 3), Dot1agCfmIdPermission().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4))).clone('sendIdNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setReference('12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setDescription('Enumerated value indicating what, if anything, is to be included in the Sender ID TLV (21.5.3) transmitted by MHFs created by the Default Maintenance Domain, for each dot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdIdPermission object contains the value sendIdDefer. Since, in this variable, there is no encompassing Maintenance Domain, the value sendIdDefer is not allowed. After this initialization, this object needs to be persistent upon reboot or restart of a device. ')
dot1agCfmDefaultMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4), )
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setReference('12.14.3')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setDescription("For each Bridge component, the Default MD Level Managed Object controls MHF creation for VIDs that are not attached to a specific Maintenance Association Managed Object, and Sender ID TLV transmission by those MHFs. For each Bridge Port, and for each VLAN ID whose data can pass through that Bridge Port, an entry in this table is used by the algorithm in 22.2.3 only if there is no entry in the Maintenance Association table defining an MA for the same VLAN ID and MD Level as this table's entry, and on which MA an Up MEP is defined. If there exists such an MA, that MA's objects are used by the algorithm in 22.2.3 in place of this table entry's objects. The agent maintains the value of dot1agCfmDefaultMdStatus to indicate whether this entry is overridden by an MA. When first initialized, the agent creates this table automatically with entries for all VLAN IDs, with the default values specified for each object. After this initialization, the writable objects in this table need to be persistent upon reboot or restart of a device. **NOTE: this object is deprecated due to re-indexing of the table. ")
dot1agCfmDefaultMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmDefaultMdComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmDefaultMdPrimaryVid"))
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setDescription('The Default MD Level table entry. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmDefaultMdComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setDescription('The Bridge component within the system to which the information in this dot1agCfmDefaultMdEntry applies. If the system is not a Bridge, or if only one component is present in the Bridge, then this variable (index) MUST be equal to 1. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmDefaultMdPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 2), VlanId())
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setDescription("The Primary VID of the VLAN to which this entry's objects apply. **NOTE: this object is deprecated due to re-indexing of the table. ")
dot1agCfmDefaultMdStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setReference('12.14.3.1.3:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setDescription("State of this Default MD Level table entry. True if there is no entry in the Maintenance Association table defining an MA for the same VLAN ID and MD Level as this table's entry, and on which MA an Up MEP is defined, else false. **NOTE: this object is deprecated due to re-indexing of the table. ")
dot1agCfmDefaultMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 4), Dot1agCfmMDLevelOrNone().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setReference('12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setDescription("A value indicating the MD Level at which MHFs are to be created, and Sender ID TLV transmission by those MHFs is to be controlled, for the VLAN to which this entry's objects apply. If this object has the value -1, the MD Level for MHF creation for this VLAN is controlled by dot1agCfmDefaultMdDefLevel. **NOTE: this object is deprecated due to re-indexing of the table. ")
dot1agCfmDefaultMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 5), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setReference('12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setDescription('A value indicating if the Management entity can create MHFs (MIP Half Function) for this VID at this MD Level. If this object has the value defMHFdefer, MHF creation for this VLAN is controlled by dot1agCfmDefaultMdDefMhfCreation. The value of this variable is meaningless if the values of dot1agCfmDefaultMdStatus is false. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmDefaultMdIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 6), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setReference('12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setDescription('Enumerated value indicating what, if anything, is to be included in the Sender ID TLV (21.5.3) transmitted by MHFs created by the Default Maintenance Domain. If this object has the value sendIdDefer, Sender ID TLV transmission for this VLAN is controlled by dot1agCfmDefaultMdDefIdPermission. The value of this variable is meaningless if the values of dot1agCfmDefaultMdStatus is false. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmConfigErrorListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1), )
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setReference('12.14.4')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setDescription('The CFM Configuration Error List table provides a list of Interfaces and VIDs that are incorrectly configured. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmConfigErrorListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListVid"), (0, "IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListIfIndex"))
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setDescription('The Config Error List Table entry **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmConfigErrorListVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setReference('12.14.4.1.2:a')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setDescription('The VLAN ID of the VLAN with interfaces in error. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmConfigErrorListIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setReference('12.14.4.1.2:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setDescription('This object is the IfIndex of the interface. Upon a restart of the system, the system SHALL, if necessary, change the value of this variable so that it indexes the entry in the interface table with the same value of ifAlias that it indexed before the system restart. If no such entry exists, then the system SHALL delete any entries in dot1agCfmConfigErrorListTable indexed by that InterfaceIndex value. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmConfigErrorListErrorType = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 3), Dot1agCfmConfigErrors()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setReference('12.14.4.1.3:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setDescription('A vector of Boolean error conditions from 22.2.4, any of which may be true: 0) CFMleak; 1) ConflictingVids; 2) ExcessiveLevels; 3) OverlappedLevels. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMdTableNextIndex = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 1), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setDescription('This object contains an unused value for dot1agCfmMdIndex in the dot1agCfmMdTable, or a zero to indicate that none exist. ')
dot1agCfmMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2), )
if mibBuilder.loadTexts: dot1agCfmMdTable.setReference('3.117, 18.1')
if mibBuilder.loadTexts: dot1agCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTable.setDescription('The Maintenance Domain table. Each row in the table represents a different Maintenance Domain. A Maintenance Domain is described 3.117 as the network or the part of the network for which faults in connectivity are to be managed. The boundary of a Maintenance Domain is defined by a set of DSAPs, each of which can become a point of connectivity to a service instance. ')
dot1agCfmMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"))
if mibBuilder.loadTexts: dot1agCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost upon reboot. It is backed up by stable storage. ')
dot1agCfmMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMdIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdIndex.setDescription('The index to the Maintenance Domain table. dot1agCfmMdTableNextIndex needs to be inspected to find an available index for row-creation. Referential integrity is required, i.e., the index needs to be persistent upon a reboot or restart of a device. The index can never be reused for other Maintenance Domain. The index value SHOULD keep increasing up to the time that they wrap around. This is to facilitate access control based on OID. ')
dot1agCfmMdFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 2), Dot1agCfmMaintDomainNameType().clone('charString')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFormat.setReference('21.6.5.1')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
dot1agCfmMdName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 3), Dot1agCfmMaintDomainName().clone('DEFAULT')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdName.setReference('3.122, 12.14.5, 21.6.5.3')
if mibBuilder.loadTexts: dot1agCfmMdName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdName.setDescription('The Maintenance Domain name. The type/format of this object is determined by the value of the dot1agCfmMdNameType object. Each Maintenance Domain has unique name among all those used or available to a service provider or operator. It facilitates easy identification of administrative responsibility for each Maintenance Domain. 3.122 defines a Maintenance Domain name as the identifier, unique over the domain for which CFM is to protect against accidental concatenation of Service Instances, of a particular Maintenance Domain. ')
dot1agCfmMdMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 4), Dot1agCfmMDLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setReference('12.14.5.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setDescription('The Maintenance Domain Level.')
dot1agCfmMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 5), Dot1agCfmMhfCreation().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))).clone('defMHFnone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setReference('12.14.5.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setDescription('Enumerated value indicating whether the management entity can create MHFs (MIP Half Function) for this Maintenance Domain. Since, in this variable, there is no encompassing Maintenance Domain, the value defMHFdefer is not allowed. ')
dot1agCfmMdMhfIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 6), Dot1agCfmIdPermission().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4))).clone('sendIdNone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setReference('12.14.5.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setDescription('Enumerated value indicating what, if anything, is to be included in the Sender ID TLV (21.5.3) transmitted by MPs configured in this Maintenance Domain. Since, in this variable, there is no encompassing Maintenance Domain, the value sendIdDefer is not allowed. ')
dot1agCfmMdMaNextIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 7), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdMaNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMaNextIndex.setDescription('Value to be used as the index of the MA table entries, both the dot1agCfmMaNetTable and the dot1agCfmMaCompTable, for this Maintenance Domain when the management entity wants to create a new row in those tables. ')
dot1agCfmMdRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setDescription('The status of the row. The writable columns in a row can not be changed if the row is active. All columns MUST have a valid value before a row can be activated. ')
dot1agCfmMaNetTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1), )
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setReference('18.2')
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setDescription('The Maintenance Association table. Each row in the table represents an MA. An MA is a set of MEPs, each configured with a single service instance. This is the part of the complete MA table that is constant across all Bridges in a Maintenance Domain, and across all components of a single Bridge. That part of the MA table that can vary from Bridge component to Bridge component is contained in the dot1agCfmMaCompTable. Creation of a Service Instance establishes a connectionless association among the selected DSAPs. Configuring a Maintenance association Endpoint (MEP) at each of the DSAPs creates a Maintenance Association (MA) to monitor that connectionless connectivity. The MA is identified by a Short MA Name that is unique within the Maintenance Domain and chosen to facilitate easy identification of the Service Instance. Together, the Maintenance Domain Name and the Short MA Name form the Maintenance Association Identifier (MAID) that is carried in CFM Messages to identify incorrect connectivity among Service Instances. A small integer, the Maintenance association Endpoint Identifier (MEPID), identifies each MEP among those configured on a single MA (3.114, 18.2). This table uses two indices, first index is the index of the Maintenance Domain table. The second index is the same as the index of the dot1agCfmMaCompEntry for the same MA. The writable objects in this table need to be persistent upon reboot or restart of a device. ')
dot1agCfmMaNetEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaNetEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetEntry.setDescription('The MA table entry.')
dot1agCfmMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMaIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaIndex.setDescription('Index of the MA table dot1agCfmMdMaNextIndex needs to be inspected to find an available index for row-creation. ')
dot1agCfmMaNetFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 2), Dot1agCfmMaintAssocNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setReference('21.6.5.4')
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setDescription('The type (and thereby format) of the Maintenance Association Name. ')
dot1agCfmMaNetName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 3), Dot1agCfmMaintAssocName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetName.setReference('21.6.5.6, Table 21 20')
if mibBuilder.loadTexts: dot1agCfmMaNetName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetName.setDescription('The Short Maintenance Association name. The type/format of this object is determined by the value of the dot1agCfmMaNetNameType object. This name MUST be unique within a maintenance domain. ')
dot1agCfmMaNetCcmInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 4), Dot1agCfmCcmInterval().clone('interval1s')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setReference('12.14.6.1.3:e')
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setDescription('Interval between CCM transmissions to be used by all MEPs in the MA. ')
dot1agCfmMaNetRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetRowStatus.setDescription('The status of the row. The writable columns in a row can not be changed if the row is active. All columns MUST have a valid value before a row can be activated. ')
dot1agCfmMaCompTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2), )
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setReference('18.2')
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setDescription('The Maintenance Association table. Each row in the table represents an MA. An MA is a set of MEPs, each configured with a single service instance. This is the part of the complete MA table that is variable across the Bridges in a Maintenance Domain, or across the components of a single Bridge. That part of the MA table that is constant across the Bridges and their components in a Maintenance Domain is contained in the dot1agCfmMaNetTable. This table uses three indices, first index is the Dot1agCfmPbbComponentIdentifier that identifies the component within the Bridge for which the information in the dot1agCfmMaCompEntry applies. The second is the index of the Maintenance Domain table. The third index is the same as the index of the dot1agCfmMaNetEntry for the same MA. The writable objects in this table need to be persistent upon reboot or restart of a device. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMaComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaCompEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompEntry.setDescription('The MA table entry. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setDescription('The Bridge component within the system to which the information in this dot1agCfmMaCompEntry applies. If the system is not a Bridge, or if only one component is present in the Bridge, then this variable (index) MUST be equal to 1. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompPrimaryVlanId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 2), VlanIdOrNone()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setReference('12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setDescription('The Primary VLAN ID with which the Maintenance Association is associated, or 0 if the MA is not attached to any VID. If the MA is associated with more than one VID, the dot1agCfmVlanTable lists them. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 3), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setReference('12.14.6.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setDescription('Indicates if the Management entity can create MHFs (MIP Half Function) for this MA. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 4), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setReference('12.14.6.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setDescription('Enumerated value indicating what, if anything, is to be included in the Sender ID TLV (21.5.3) transmitted by MPs configured in this MA. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompNumberOfVids = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setReference('12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setDescription('The number of VIDs associated with the MA. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaCompRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompRowStatus.setDescription('The status of the row. The writable columns in a row can not be changed if the row is active. All columns MUST have a valid value before a row can be activated. **NOTE: this object is deprecated due to re-indexing of the table. ')
dot1agCfmMaMepListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3), )
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setReference('12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setDescription("List of MEPIDs that belong to this MA. 12.14.6.1.3 specifies that a list of MEPIDs in all Bridges in that MA, but since SNMP SMI does not allow to state in a MIB that an object in a table is an array, the information has to be stored in another table with two indices, being the first index, the index of the table that contains the list or array. For all Bridges in which the same MAID {dot1agCfmMdFormat, dot1agCfmMdName, dot1agCfmMaNetFormat, and dot1agCfmMaNetName} is configured, the same set of dot1agCfmMaMepListIdentifiers MUST be configured in the Bridges' dot1agCfmMaMepListTables. This allows each MEP to determine whether or not it is receiving CCMs from all of the other MEPs in the MA. For example, if one were creating a new MA whose MAID were {charString, 'Dom1', charString, 'MA1'}, that had 2 MEPs, whose MEPIDs were 1 and 3, one could, in Bridge A: 1. Get a new MD index d from dot1agCfmMdTableNextIndex. 2. Create the Maintenance Domain {charString, 'Dom1'}. 3. Get a new MA index a from dot1agCfmMdMaNextIndex [d]. 4. Create the Maintenance Association {charString, 'MA1'}. 5. Create a new dot1agCfmMaMepListEntry for each of the MEPs in the MA: [d, a, 1] and [d, a, 3]. 6. Create one of the new MEPs, say [d, a, 1]. Then, in Bridge B: 7. Do all of these steps 1-6, except for using the other MEPID for the new MEP in Step 6, in this example, MEPID 3. Note that, when creating the MA, MEP List Table, and MEP entries in the second Bridge, the indices 'd' and 'a' identifying the MAID {charString, 'Dom1', charString, 'MA1'} may have different values than those in the first Bridge. ")
dot1agCfmMaMepListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaMepListIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setDescription('The known MEPS table entry.')
dot1agCfmMaMepListIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setReference('12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setDescription('MEPID')
dot1agCfmMaMepListRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setDescription('The status of the row. Read SNMPv2-TC (RFC1903) for an explanation of the possible values this object can take. ')
dot1agCfmMepTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1), )
if mibBuilder.loadTexts: dot1agCfmMepTable.setReference('12.14.7, 19.2')
if mibBuilder.loadTexts: dot1agCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTable.setDescription('The Maintenance Association Endpoint (MEP) table. Each row in the table represents a different MEP. A MEP is an actively managed CFM entity, associated with a specific DSAP of a Service Instance, which can generate and receive CFM PDUs and track any responses. It is an endpoint of a single Maintenance Association, and is an endpoint of a separate Maintenance Entity for each of the other MEPs in the same Maintenance Association (3.114). This table uses three indices. The first two indices are the indices of the Maintenance Domain and MA tables, the reason being that a MEP is always related to an MA and Maintenance Domain. The MEP table also stores all the managed objects for sending LBM and LTM. *LBM Managed objects LBM Managed objects in the MEP table enables the management entity to initiate transmission of Loopback messages. It will signal the MEP that it SHOULD transmit some number of Loopback messages and detect the detection (or lack thereof) of the corresponding Loopback messages. Steps to use entries in this table: 1) Wait for dot1agCfmMepTransmitLbmStatus value to be false. To do this do this sequence: a. an SNMP GET for both SnmpSetSerialNo and dot1agCfmMepTransmitLbmStatus objects (in same SNMP PDU). b. Check if value for dot1agCfmMepTransmitLbmStatus is false. - if not, wait x seconds, go to step a above. - if yes, save the value of SnmpSetSerialNo and go to step 2) below 2) Change dot1agCfmMepTransmitLbmStatus value from false to true to ensure no other management entity will use the service. In order to not disturb a possible other NMS do this by sending an SNMP SET for both SnmpSetSerialNo and dot1agCfmMepTransmitLbmStatus objects (in same SNMP PDU, and make sure SNmpSetSerialNo is the first varBind). For the SnmpSetSerialNo varBind, use the value that you obtained in step 1)a.. This ensures that two cooperating NMSes will not step on each others toes. Setting this MIB object does not set the corresponding LBIactive state machine variable. 3) Setup the different data to be sent (number of messages, optional TLVs,...), except do not set dot1agCfmMepTransmitLbmMessages. 4) Record the current values of dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu. 6) Set dot1agCfmMepTransmitLbmMessages to a non-zero value to initiate transmission of Loopback messages. The dot1agCfmMepTransmitLbmMessages indicates the number of LBMs to be sent and is not decremented as loopbacks are actually sent. dot1agCfmMepTransmitLbmMessages is not equivalent to the LBMsToSend state machine variable. 7) Check the value of dot1agCfmMepTransmitLbmResultOK to find out if the operation was successfully initiated or not. 8) Monitor the value of dot1agCfmMepTransmitLbmStatus. When it is reset to false, the last LBM has been transmitted. Wait an additional 5 seconds to ensure that all LBRs have been returned. 9) Compare dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu to their old values from step 4, above, to get the results of the test. *LTM Managed objects The LTM Managed objects in the MEP table are used in a manner similar to that described for LBM transmission, above. A SET operation to the variable dot1agCfmMepTransmitLtmFlags triggers the transmission of an LTM. Then, the variables dot1agCfmMepTransmitLtmSeqNumber and dot1agCfmMepTransmitLtmEgressIdentifier return the information required to recover the results of the LTM from the dot1agCfmLtrTable. ')
dot1agCfmMepEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepEntry.setDescription('The MEP table entry')
dot1agCfmMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setReference('3.114, 19.2, 12.14.7')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setDescription('Integer that is unique among all the MEPs in the same MA. Other definition is: a small integer, unique over a given Maintenance Association, identifying a specific Maintenance association Endpoint (3.114). MEP Identifier is also known as the MEPID. ')
dot1agCfmMepIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setReference('12.14.7.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setDescription('This object is the interface index of the interface either a Bridge Port, or an aggregated IEEE 802.1 link within a Bridge port, to which the MEP is attached. Upon a restart of the system, the system SHALL, if necessary, change the value of this variable so that it indexes the entry in the interface table with the same value of ifAlias that it indexed before the system restart. If no such entry exists, then the system SHALL set this variable to 0. ')
dot1agCfmMepDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 3), Dot1agCfmMpDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepDirection.setReference('12.14.7.1.3:c, 19.2')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setDescription('The direction in which the MEP faces on the Bridge port.')
dot1agCfmMepPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setReference('12.14.7.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setDescription("An integer indicating the Primary VID of the MEP, always one of the VIDs assigned to the MEP's MA. The value 0 indicates that either the Primary VID is that of the MEP's MA, or that the MEP's MA is associated with no VID.")
dot1agCfmMepActive = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepActive.setReference('12.14.7.1.3:e, 20.9.1')
if mibBuilder.loadTexts: dot1agCfmMepActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepActive.setDescription('Administrative state of the MEP A Boolean indicating the administrative state of the MEP. True indicates that the MEP is to function normally, and false that it is to cease functioning.')
dot1agCfmMepFngState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 6), Dot1agCfmFngState().clone('fngReset')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepFngState.setReference('12.14.7.1.3:f, 20.35')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setDescription('Current state of the MEP Fault Notification Generator State Machine. ')
dot1agCfmMepCciEnabled = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setReference('12.14.7.1.3:g, 20.10.1')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setDescription('If set to true, the MEP will generate CCM messages.')
dot1agCfmMepCcmLtmPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setReference('12.14.7.1.3:h')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setDescription('The priority value for CCMs and LTMs transmitted by the MEP. Default Value is the highest priority value allowed to pass through the Bridge Port for any of this MEPs VIDs. The management entity can obtain the default value for this variable from the priority regeneration table by extracting the highest priority value in this table on this MEPs Bridge Port. (1 is lowest, then 2, then 0, then 3-7). ')
dot1agCfmMepMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setReference('12.14.7.1.3:i, 19.4')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setDescription('MAC address of the MEP.')
dot1agCfmMepLowPrDef = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 10), Dot1agCfmLowestAlarmPri().clone('macRemErrXcon')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setReference('12.14.7.1.3:k, 20.9.5, Table 20-1')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setDescription('An integer value specifying the lowest priority defect that is allowed to generate fault alarm. ')
dot1agCfmMepFngAlarmTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 11), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(250)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setReference('12.14.7.1.3:l, 20.3.3')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setDescription('The time that defects MUST be present before a Fault Alarm is issued (fngAlarmTime, 20.3.3) (default 2.5s). ')
dot1agCfmMepFngResetTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 12), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setReference('12.14.7.1.3:m, 20.35.4')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setDescription('The time that defects MUST be absent before resetting a Fault Alarm (fngResetTime, 20.35.4) (default 10s). ')
dot1agCfmMepHighestPrDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 13), Dot1agCfmHighestDefectPri()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setReference('12.14.7.1.3:n, 20.35.9, Table 21 1')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setDescription('The highest priority defect that has been present since the MEPs Fault Notification Generator State Machine was last in the FNG_RESET state. ')
dot1agCfmMepDefects = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 14), Dot1agCfmMepDefects()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDefects.setReference('12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q, 12.14.7.1.3:r, 12.14.7.1.3:s, 20.21.3, 20.23.3, 20.35.5, 20.35.6, 20.35.7.')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setDescription('A vector of Boolean error conditions from Table 20-1, any of which may be true: DefRDICCM(0) DefMACstatus(1) DefRemoteCCM(2) DefErrorCCM(3) DefXconCCM(4) ')
dot1agCfmMepErrorCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setReference('12.14.7.1.3:t, 20.21.2')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setDescription('The last-received CCM that triggered an DefErrorCCM fault.')
dot1agCfmMepXconCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setReference('12.14.7.1.3:u, 20.23.2')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setDescription('The last-received CCM that triggered a DefXconCCM fault.')
dot1agCfmMepCcmSequenceErrors = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setReference('12.14.7.1.3:v, 20.16.12')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setDescription('The total number of out-of-sequence CCMs received from all remote MEPs. ')
dot1agCfmMepCciSentCcms = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setReference('12.14.7.1.3:w, 20.10.2')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setDescription('Total number of Continuity Check messages transmitted.')
dot1agCfmMepNextLbmTransId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setReference('12.14.7.1.3:x, 20.28.2')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setDescription('Next sequence number/transaction identifier to be sent in a Loopback message. This sequence number can be zero because it wraps around. ')
dot1agCfmMepLbrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setReference('12.14.7.1.3:y, 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
dot1agCfmMepLbrInOutOfOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setReference('12.14.7.1.3:z, 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies received. ')
dot1agCfmMepLbrBadMsdu = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setReference('12.14.7.1.3:aa, 20.2.3')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setDescription('The total number of LBRs received whose mac_service_data_unit did not match (except for the OpCode) that of the corresponding LBM (20.2.3). ')
dot1agCfmMepLtmNextSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setReference('12.14.7.1.3:ab, 20.41.1')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setDescription('Next transaction identifier/sequence number to be sent in a Linktrace message. This sequence number can be zero because it wraps around. ')
dot1agCfmMepUnexpLtrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setReference('12.14.7.1.3:ac, 20.44.1')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setDescription('The total number of unexpected LTRs received (20.39.1). ')
dot1agCfmMepLbrOut = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setReference('12.14.7.1.3:ad, 20.28.2')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setDescription('Total number of Loopback Replies transmitted.')
dot1agCfmMepTransmitLbmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setDescription('A Boolean flag set to true by the MEP Loopback Initiator State Machine or an MIB manager to indicate that another LBM is being transmitted. Reset to false by the MEP Loopback Initiator State Machine.')
dot1agCfmMepTransmitLbmDestMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 27), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast destination MAC address. This address will be used if the value of the column dot1agCfmMepTransmitLbmDestIsMepId is 'false'. ")
dot1agCfmMepTransmitLbmDestMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 28), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setDescription("The Maintenance association Endpoint Identifier of another MEP in the same Maintenance Association to which the LBM is to be sent. This address will be used if the value of the column dot1agCfmMepTransmitLbmDestIsMepId is 'true'. ")
dot1agCfmMepTransmitLbmDestIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 29), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setDescription('True indicates that MEPID of the target MEP is used for Loopback transmission. False indicates that unicast destination MAC address of the target MEP is used for Loopback transmission. ')
dot1agCfmMepTransmitLbmMessages = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setReference('12.14.7.3.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setDescription('The number of Loopback messages to be transmitted.')
dot1agCfmMepTransmitLbmDataTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 31), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setReference('12.14.7.3.2:d')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setDescription('An arbitrary amount of data to be included in the Data TLV, if the Data TLV is selected to be sent. The intent is to be able to fill the frame carrying the CFM PDU to its maximum length. This may lead to fragmentation in some cases. ')
dot1agCfmMepTransmitLbmVlanPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setReference('12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setDescription('Priority. 3 bit value to be used in the VLAN tag, if present in the transmitted frame. The default value is CCM priority. ')
dot1agCfmMepTransmitLbmVlanDropEnable = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 33), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setReference('12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit value to be used in the VLAN tag, if present in the transmitted frame. For more information about VLAN Drop Enable, check IEEE 802.1ad. ')
dot1agCfmMepTransmitLbmResultOK = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 34), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setReference('12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setDescription('Indicates the result of the operation: - true The Loopback Message(s) will be (or has been) sent. - false The Loopback Message(s) will not be sent. ')
dot1agCfmMepTransmitLbmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setReference('12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setDescription('The Loopback Transaction Identifier (dot1agCfmMepNextLbmTransId) of the first LBM (to be) sent. The value returned is undefined if dot1agCfmMepTransmitLbmResultOK is false. ')
dot1agCfmMepTransmitLtmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 36), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setDescription('A Boolean flag set to true by the Bridge Port to indicate that another LTM may be transmitted. Reset to false by the MEP Linktrace Initiator State Machine.')
dot1agCfmMepTransmitLtmFlags = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 37), Bits().clone(namedValues=NamedValues(("useFDBonly", 0))).clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setReference('12.14.7.4.2:b, 20.42.1')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setDescription('The flags field for LTMs transmitted by the MEP.')
dot1agCfmMepTransmitLtmTargetMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 38), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast destination MAC address. This address will be used if the value of the column dot1agCfmMepTransmitLtmTargetIsMepId is 'false'. ")
dot1agCfmMepTransmitLtmTargetMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 39), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setDescription("An indication of the Target MAC Address Field to be transmitted: The Maintenance association Endpoint Identifier of another MEP in the same Maintenance Association This address will be used if the value of the column dot1agCfmMepTransmitLtmTargetIsMepId is 'true'. ")
dot1agCfmMepTransmitLtmTargetIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 40), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setDescription('True indicates that MEPID of the target MEP is used for Linktrace transmission. False indicates that unicast destination MAC address of the target MEP is used for Loopback transmission. ')
dot1agCfmMepTransmitLtmTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 41), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setReference('12.14.7.4.2:d, 21.8.4')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64. The TTL field indicates the number of hops remaining to the LTM. Decremented by 1 by each Linktrace Responder that handles the LTM. The value returned in the LTR is one less than that received in the LTM. If the LTM TTL is 0 or 1, the LTM is not forwarded to the next hop, and if 0, no LTR is generated. ')
dot1agCfmMepTransmitLtmResult = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 42), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setReference('12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setDescription('Indicates the result of the operation: - true The Linktrace Message will be (or has been) sent. - false The Linktrace Message will not be sent')
dot1agCfmMepTransmitLtmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 43), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setReference('12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setDescription('The LTM Transaction Identifier (dot1agCfmMepLtmNextSeqNumber) of the LTM sent. The value returned is undefined if dot1agCfmMepTransmitLtmResult is false. ')
dot1agCfmMepTransmitLtmEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setReference('12.14.7.4.3:b, 21.8.8')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setDescription('Identifies the MEP Linktrace Initiator that is originating, or the Linktrace Responder that is forwarding, this LTM. The low-order six octets contain a 48-bit IEEE MAC address unique to the system in which the MEP Linktrace Initiator or Linktrace Responder resides. The high-order two octets contain a value sufficient to uniquely identify the MEP Linktrace Initiator or Linktrace Responder within that system. For most Bridges, the address of any MAC attached to the Bridge will suffice for the low-order six octets, and 0 for the high-order octets. In some situations, e.g., if multiple virtual Bridges utilizing emulated LANs are implemented in a single physical system, the high-order two octets can be used to differentiate among the transmitting entities. The value returned is undefined if dot1agCfmMepTransmitLtmResult is false. ')
dot1agCfmMepRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 45), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setDescription('The status of the row. The writable columns in a row can not be changed if the row is active. All columns MUST have a valid value before a row can be activated. ')
dot1agCfmMepPbbTeCanReportPbbTePresence = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 46), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setReference('12.14.7.1.3:af, 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setDescription('A Boolean valued parameter that is set to true if the system has the capability to report the presence of traffic and that the capability is enabled. Traffic presence reporting is an optional PBB-TE feature.')
dot1agCfmMepPbbTeTrafficMismatchDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 47), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setReference('12.14.7.1.3:ah, 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setDescription('A Boolean valued parameter that is set to true if the system has detected a traffic field mismatch defect. Mismatch detection is an optional PBB-TE feature.')
dot1agCfmMepPbbTransmitLbmLtmReverseVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 48), IEEE8021VlanIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setReference('12.14.7.4.2')
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setDescription('This column specifies the value to use in the Reverse VID value field of PBB-TE MIP TLVs contained within TransmitLTM pdus.')
dot1agCfmMepPbbTeMismatchAlarm = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 49), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setReference('12.14.7.1.3:ag, 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setDescription('A Boolean valued parameter that is set to true if the system is to allow a mismatch defect to generate a fault alarm.')
dot1agCfmMepPbbTeLocalMismatchDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 50), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setReference('12.14.7.1.3:ai, 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setDescription('A Boolean valued parameter that is set to true if the system has detected a local mismatch defect. Mismatch detection is an optional PBB-TE feature.')
dot1agCfmMepPbbTeMismatchSinceReset = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 51), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setReference('12.14.7.1.3:aj')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setDescription('A Boolean valued parameter indicating if the mismatch defect has been present since the MEP Mismatch Fault Notification Generator was last in the MFNG_RESET state.')
dot1agCfmLtrTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2), )
if mibBuilder.loadTexts: dot1agCfmLtrTable.setReference('12.14.7.5')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setDescription('This table extends the MEP table and contains a list of Linktrace replies received by a specific MEP in response to a linktrace message. SNMP SMI does not allow to state in a MIB that an object in a table is an array. The solution is to take the index (or indices) of the first table and add one or more indices. ')
dot1agCfmLtrEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFM-MIB", "dot1agCfmLtrSeqNumber"), (0, "IEEE8021-CFM-MIB", "dot1agCfmLtrReceiveOrder"))
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setDescription('The Linktrace Reply table entry.')
dot1agCfmLtrSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setReference('12.14.7.5.2:b')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setDescription("Transaction identifier/Sequence number returned by a previous transmit linktrace message command, indicating which LTM's response is going to be returned. ")
dot1agCfmLtrReceiveOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setReference('12.14.7.5.2:c')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR Transaction Identifier field value. dot1agCfmLtrReceiveOrder are assigned sequentially from 1, in the order that the Linktrace Initiator received the LTRs. ')
dot1agCfmLtrTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setReference('12.14.7.5, 20.41.2.2')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setDescription('TTL field value for a returned LTR.')
dot1agCfmLtrForwarded = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setReference('12.14.7.5.3:c, 20.41.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setDescription("Indicates if a LTM was forwarded by the responding MP, as returned in the 'FwdYes' flag of the flags field. ")
dot1agCfmLtrTerminalMep = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setReference('12.14.7.5.3:d, 20.41.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setDescription('A Boolean value stating whether the forwarded LTM reached a MEP enclosing its MA, as returned in the Terminal MEP flag of the Flags field. ')
dot1agCfmLtrLastEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setReference('12.14.7.5.3:e, 20.41.2.3')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setDescription('An octet field holding the Last Egress Identifier returned in the LTR Egress Identifier TLV of the LTR. The Last Egress Identifier identifies the MEP Linktrace Initiator that originated, or the Linktrace Responder that forwarded, the LTM to which this LTR is the response. This is the same value as the Egress Identifier TLV of that LTM. ')
dot1agCfmLtrNextEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setReference('12.14.7.5.3:f, 20.41.2.4')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setDescription('An octet field holding the Next Egress Identifier returned in the LTR Egress Identifier TLV of the LTR. The Next Egress Identifier Identifies the Linktrace Responder that transmitted this LTR, and can forward the LTM to the next hop. This is the same value as the Egress Identifier TLV of the forwarded LTM, if any. If the FwdYes bit of the Flags field is false, the contents of this field are undefined, i.e., any value can be transmitted, and the field is ignored by the receiver. ')
dot1agCfmLtrRelay = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 8), Dot1agCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setReference('12.14.7.5.3:g, 20.41.2.5')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setDescription('Value returned in the Relay Action field.')
dot1agCfmLtrChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 9), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setReference('12.14.7.5.3:h, 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID returned in the Sender ID TLV of the LTR, if any. This value is meaningless if the dot1agCfmLtrChassisId has a length of 0.')
dot1agCfmLtrChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 10), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setReference('12.14.7.5.3:i, 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setDescription('The Chassis ID returned in the Sender ID TLV of the LTR, if any. The format of this object is determined by the value of the dot1agCfmLtrChassisIdSubtype object. ')
dot1agCfmLtrManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 11), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setReference('12.14.7.5.3:j, 21.5.3.5, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setDescription("The TDomain that identifies the type and format of the related dot1agCfmMepDbManAddress object, used to access the SNMP agent of the system transmitting the LTR. Received in the LTR Sender ID TLV from that system. Typical values will be one of (not all inclusive) list: snmpUDPDomain (from SNMPv2-TM, RFC3417) snmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789) The value 'zeroDotZero' (from RFC2578) indicates 'no management address was present in the LTR', in which case the related object dot1agCfmMepDbManAddress MUST have a zero-length OCTET STRING as a value. ")
dot1agCfmLtrManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 12), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setReference('12.14.7.5.3:j, 21.5.3.7, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setDescription("The TAddress that can be used to access the SNMP agent of the system transmitting the CCM, received in the CCM Sender ID TLV from that system. If the related object dot1agCfmLtrManAddressDomain contains the value 'zeroDotZero', this object dot1agCfmLtrManAddress MUST have a zero-length OCTET STRING as a value. ")
dot1agCfmLtrIngress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 13), Dot1agCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setReference('12.14.7.5.3:k, 20.41.2.6')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM. The value ingNoTlv(0) indicates that no Reply Ingress TLV was returned in the LTM.')
dot1agCfmLtrIngressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setReference('12.14.7.5.3:l, 20.41.2.7')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field. If the dot1agCfmLtrIngress object contains the value ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrIngressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 15), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setReference('12.14.7.5.3:m, 20.41.2.8')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID. If the dot1agCfmLtrIngress object contains the value ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrIngressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 16), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setReference('12.14.7.5.3:n, 20.41.2.9')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by the value of the dot1agCfmLtrIngressPortIdSubtype object. If the dot1agCfmLtrIngress object contains the value ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 17), Dot1agCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setReference('12.14.7.5.3:o, 20.41.2.10')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM. The value egrNoTlv(0) indicates that no Reply Egress TLV was returned in the LTM.')
dot1agCfmLtrEgressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setReference('12.14.7.5.3:p, 20.41.2.11')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setDescription('MAC address returned in the egress MAC address field. If the dot1agCfmLtrEgress object contains the value egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 19), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setReference('12.14.7.5.3:q, 20.41.2.12')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID. If the dot1agCfmLtrEgress object contains the value egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 20), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setReference('12.14.7.5.3:r, 20.41.2.13')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by the value of the dot1agCfmLtrEgressPortIdSubtype object. If the dot1agCfmLtrEgress object contains the value egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrOrganizationSpecificTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 21), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 1500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setReference('12.14.7.5.3:s, 21.5.2')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setDescription('All Organization specific TLVs returned in the LTR, if any. Includes all octets including and following the TLV Length field of each TLV, concatenated together.')
dot1agCfmMepDbTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3), )
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setReference('19.2.15')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setDescription('The MEP Database. A database, maintained by every MEP, that maintains received information about other MEPs in the Maintenance Domain. The SMI does not allow to state in a MIB that an object in a table is an array. The solution is to take the index (or indices) of the first table and add one or more indices. ')
dot1agCfmMepDbEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setDescription('The MEP Database table entry.')
dot1agCfmMepDbRMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setReference('12.14.7.6.2:b')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setDescription('Maintenance association Endpoint Identifier of a remote MEP whose information from the MEP Database is to be returned. ')
dot1agCfmMepDbRMepState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 2), Dot1agCfmRemoteMepState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setReference('12.14.7.6.3:b, 20.22')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setDescription('The operational state of the remote MEP IFF State machines.')
dot1agCfmMepDbRMepFailedOkTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setReference('12.14.7.6.3:c')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setDescription('The time (SysUpTime) at which the IFF Remote MEP state machine last entered either the RMEP_FAILED or RMEP_OK state. ')
dot1agCfmMepDbMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setReference('12.14.7.6.3:d, 20.19.7')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setDescription('The MAC address of the remote MEP.')
dot1agCfmMepDbRdi = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setReference('12.14.7.6.3:e, 20.19.2')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setDescription('State of the RDI bit in the last received CCM (true for RDI=1), or false if none has been received. ')
dot1agCfmMepDbPortStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 6), Dot1agCfmPortStatus().clone('psNoPortStateTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setReference('12.14.7.6.3:f, 20.19.3')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setDescription('An enumerated value of the Port status TLV received in the last CCM from the remote MEP or the default value psNoPortStateTLV indicating either no CCM has been received, or that nor port status TLV was received in the last CCM. ')
dot1agCfmMepDbInterfaceStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 7), Dot1agCfmInterfaceStatus().clone('isNoInterfaceStatusTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setReference('12.14.7.6.3:g, 20.19.4')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setDescription('An enumerated value of the Interface status TLV received in the last CCM from the remote MEP or the default value isNoInterfaceStatus TLV indicating either no CCM has been received, or that no interface status TLV was received in the last CCM. ')
dot1agCfmMepDbChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 8), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setReference('12.14.7.6.3:h, 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID received in the last CCM.')
dot1agCfmMepDbChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 9), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setReference('12.14.7.6.3:h, 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setDescription('The Chassis ID. The format of this object is determined by the value of the dot1agCfmLtrChassisIdSubtype object. ')
dot1agCfmMepDbManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 10), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setReference('12.14.7.6.3:h, 21.5.3.5, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setDescription("The TDomain that identifies the type and format of the related dot1agCfmMepDbManAddress object, used to access the SNMP agent of the system transmitting the CCM. Received in the CCM Sender ID TLV from that system. Typical values will be one of (not all inclusive) list: snmpUDPDomain (from SNMPv2-TM, RFC3417) snmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789) The value 'zeroDotZero' (from RFC2578) indicates 'no management address was present in the LTR', in which case the related object dot1agCfmMepDbManAddress MUST have a zero-length OCTET STRING as a value. ")
dot1agCfmMepDbManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 11), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setReference('12.14.7.6.3:h, 21.5.3.7, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setDescription("The TAddress that can be used to access the SNMP agent of the system transmitting the CCM, received in the CCM Sender ID TLV from that system. If the related object dot1agCfmMepDbManAddressDomain contains the value 'zeroDotZero', this object dot1agCfmMepDbManAddress MUST have a zero-length OCTET STRING as a value. ")
dot1agCfmMepDbRMepIsActive = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setReference('12.14.7.1.3:ae')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setDescription('A Boolean value stating if the remote MEP is active.')
dot1agCfmFaultAlarm = NotificationType((1, 3, 111, 2, 802, 1, 1, 8, 0, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepHighestPrDefect"))
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setDescription("A MEP has a persistent defect condition. A notification (fault alarm) is sent to the management entity with the OID of the MEP that has detected the fault. Whenever a MEP has a persistent defect, it may or may not generate a Fault Alarm to warn the system administrator of the problem, as controlled by the MEP Fault Notification Generator State Machine and associated Managed Objects. Only the highest-priority defect, as shown in Table 20-1, is reported in the Fault Alarm. If a defect with a higher priority is raised after a Fault Alarm has been issued, another Fault Alarm is issued. The management entity receiving the notification can identify the system from the network source address of the notification, and can identify the MEP reporting the defect by the indices in the OID of the dot1agCfmMepHighestPrDefect variable in the notification: dot1agCfmMdIndex - Also the index of the MEP's Maintenance Domain table entry (dot1agCfmMdTable). dot1agCfmMaIndex - Also an index (with the MD table index) of the MEP's Maintenance Association network table entry (dot1agCfmMaNetTable), and (with the MD table index and component ID) of the MEP's MA component table entry (dot1agCfmMaCompTable). dot1agCfmMepIdentifier - MEP Identifier and final index into the MEP table (dot1agCfmMepTable). ")
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setReference('12.14.7.7')
dot1agCfmCompliances = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 1))
dot1agCfmGroups = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 2))
dot1agCfmStackGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmStackMdIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMaIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmStackGroup = dot1agCfmStackGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackGroup.setDescription('Objects for the Stack group.')
dot1agCfmDefaultMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 2)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdIdPermission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmDefaultMdGroup = dot1agCfmDefaultMdGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdGroup.setDescription('Objects for the Default MD Level group.')
dot1agCfmVlanIdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 3)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmVlanPrimaryVid"), ("IEEE8021-CFM-MIB", "dot1agCfmVlanRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmVlanIdGroup = dot1agCfmVlanIdGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanIdGroup.setDescription('Objects for the VLAN ID group.')
dot1agCfmConfigErrorListGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 4)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListErrorType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmConfigErrorListGroup = dot1agCfmConfigErrorListGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListGroup.setDescription('Objects for the CFM Configuration Error List Group.')
dot1agCfmMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 5)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMdTableNextIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMdName"), ("IEEE8021-CFM-MIB", "dot1agCfmMdFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMdLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMhfIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMaNextIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMdRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMdGroup = dot1agCfmMdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdGroup.setDescription('Objects for the Maintenance Domain Group.')
dot1agCfmMaGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 6)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMaNetFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetName"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetCcmInterval"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompPrimaryVlanId"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompNumberOfVids"), ("IEEE8021-CFM-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMaGroup = dot1agCfmMaGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaGroup.setDescription('Objects for the MA group.')
dot1agCfmMepGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 7)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepIfIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDirection"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPrimaryVid"), ("IEEE8021-CFM-MIB", "dot1agCfmMepActive"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngState"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCciEnabled"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCcmLtmPriority"), ("IEEE8021-CFM-MIB", "dot1agCfmMepMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLowPrDef"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngAlarmTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngResetTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepHighestPrDefect"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDefects"), ("IEEE8021-CFM-MIB", "dot1agCfmMepErrorCcmLastFailure"), ("IEEE8021-CFM-MIB", "dot1agCfmMepXconCcmLastFailure"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCcmSequenceErrors"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCciSentCcms"), ("IEEE8021-CFM-MIB", "dot1agCfmMepNextLbmTransId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrIn"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrInOutOfOrder"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrBadMsdu"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLtmNextSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepUnexpLtrIn"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrOut"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestIsMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmMessages"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDataTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmVlanPriority"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmVlanDropEnable"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmResultOK"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmFlags"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetIsMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTtl"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmResult"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmMepRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrForwarded"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrRelay"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrChassisIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrChassisId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrManAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrManAddressDomain"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressMac"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressPortIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressPortId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressMac"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressPortIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressPortId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrTerminalMep"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrLastEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrNextEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrTtl"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrOrganizationSpecificTlv"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepGroup = dot1agCfmMepGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepGroup.setDescription('Objects for the MEP group.')
dot1agCfmMepDbGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 8)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepState"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepFailedOkTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbRdi"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbPortStatusTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbInterfaceStatusTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbChassisIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbChassisId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbManAddressDomain"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbManAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepDbGroup = dot1agCfmMepDbGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbGroup.setDescription('Objects for the MEP group.')
dot1agCfmNotificationsGroup = NotificationGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 9)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmFaultAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmNotificationsGroup = dot1agCfmNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmNotificationsGroup.setDescription('Objects for the Notifications group.')
ieee8021CfmMaNetGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 10)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMaNetFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetName"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetCcmInterval"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmMaNetGroup = ieee8021CfmMaNetGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmMaNetGroup.setDescription('Objects for the MA Net group.')
ieee8021CfmDefaultMdDefGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 11)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefIdPermission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmDefaultMdDefGroup = ieee8021CfmDefaultMdDefGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmDefaultMdDefGroup.setDescription('Objects for the Default MD default Level group.')
ieee8021CfmPbbTeExtensionGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 12)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepIsActive"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTransmitLbmLtmReverseVid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmPbbTeExtensionGroup = ieee8021CfmPbbTeExtensionGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmPbbTeExtensionGroup.setDescription('Objects needed for systems that support PBB-TE CFM functionality.')
ieee8021CfmPbbTeTrafficBitGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 13)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepDbManAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTeCanReportPbbTePresence"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTeMismatchAlarm"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTeTrafficMismatchDefect"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTeLocalMismatchDefect"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPbbTeMismatchSinceReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmPbbTeTrafficBitGroup = ieee8021CfmPbbTeTrafficBitGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmPbbTeTrafficBitGroup.setDescription('Objects needed for PBB-TE supporting systems that support the optional traffic bit.')
dot1agCfmCompliance = ModuleCompliance((1, 3, 111, 2, 802, 1, 1, 8, 2, 1, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmStackGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMdGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMaGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMepGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmNotificationsGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmVlanIdGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmCompliance = dot1agCfmCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmCompliance.setDescription('The compliance statement for support of the CFM MIB module.')
mibBuilder.exportSymbols("IEEE8021-CFM-MIB", dot1agCfmLtrManAddress=dot1agCfmLtrManAddress, dot1agCfmLtrEgressMac=dot1agCfmLtrEgressMac, dot1agCfmMd=dot1agCfmMd, Dot1afCfmIndexIntegerNextFree=Dot1afCfmIndexIntegerNextFree, dot1agCfmMaNetTable=dot1agCfmMaNetTable, dot1agCfmMepNextLbmTransId=dot1agCfmMepNextLbmTransId, dot1agCfmLtrReceiveOrder=dot1agCfmLtrReceiveOrder, dot1agCfmMepTransmitLbmMessages=dot1agCfmMepTransmitLbmMessages, dot1agCfmLtrIngressMac=dot1agCfmLtrIngressMac, Dot1agCfmIngressActionFieldValue=Dot1agCfmIngressActionFieldValue, dot1agCfmConfigErrorListVid=dot1agCfmConfigErrorListVid, dot1agCfmMdMhfCreation=dot1agCfmMdMhfCreation, dot1agCfmVlanPrimaryVid=dot1agCfmVlanPrimaryVid, dot1agCfmLtrIngressPortId=dot1agCfmLtrIngressPortId, dot1agCfmMepLbrIn=dot1agCfmMepLbrIn, dot1agCfmStackVlanIdOrNone=dot1agCfmStackVlanIdOrNone, dot1agCfmMepTransmitLbmDataTlv=dot1agCfmMepTransmitLbmDataTlv, dot1agCfmMepTransmitLbmDestIsMepId=dot1agCfmMepTransmitLbmDestIsMepId, Dot1agCfmMhfCreation=Dot1agCfmMhfCreation, dot1agCfmMepTransmitLtmFlags=dot1agCfmMepTransmitLtmFlags, dot1agCfmMepFngState=dot1agCfmMepFngState, dot1agCfmMepDbManAddressDomain=dot1agCfmMepDbManAddressDomain, dot1agCfmLtrManAddressDomain=dot1agCfmLtrManAddressDomain, dot1agCfmMaNetFormat=dot1agCfmMaNetFormat, dot1agCfmMepLbrBadMsdu=dot1agCfmMepLbrBadMsdu, dot1agCfmDefaultMdComponentId=dot1agCfmDefaultMdComponentId, dot1agCfmMepIdentifier=dot1agCfmMepIdentifier, dot1agCfmVlanEntry=dot1agCfmVlanEntry, dot1agCfmMaCompEntry=dot1agCfmMaCompEntry, dot1agCfmDefaultMd=dot1agCfmDefaultMd, dot1agCfmStackDirection=dot1agCfmStackDirection, dot1agCfmDefaultMdEntry=dot1agCfmDefaultMdEntry, dot1agCfmMepDbManAddress=dot1agCfmMepDbManAddress, dot1agCfmDefaultMdDefMhfCreation=dot1agCfmDefaultMdDefMhfCreation, dot1agCfmMaCompMhfCreation=dot1agCfmMaCompMhfCreation, dot1agCfmMdRowStatus=dot1agCfmMdRowStatus, dot1agCfmMepDirection=dot1agCfmMepDirection, dot1agCfmConfigErrorList=dot1agCfmConfigErrorList, dot1agCfmDefaultMdLevel=dot1agCfmDefaultMdLevel, dot1agCfmMdIndex=dot1agCfmMdIndex, dot1agCfmLtrEgress=dot1agCfmLtrEgress, dot1agCfmMepRowStatus=dot1agCfmMepRowStatus, dot1agCfmLtrOrganizationSpecificTlv=dot1agCfmLtrOrganizationSpecificTlv, dot1agCfmVlanIdGroup=dot1agCfmVlanIdGroup, dot1agCfmVlanRowStatus=dot1agCfmVlanRowStatus, dot1agCfmLtrTerminalMep=dot1agCfmLtrTerminalMep, Dot1agCfmLowestAlarmPri=Dot1agCfmLowestAlarmPri, dot1agCfmMaGroup=dot1agCfmMaGroup, dot1agNotifications=dot1agNotifications, dot1agCfmMepTransmitLbmResultOK=dot1agCfmMepTransmitLbmResultOK, dot1agCfmMepDbGroup=dot1agCfmMepDbGroup, dot1agCfmMepEntry=dot1agCfmMepEntry, Dot1agCfmMDLevel=Dot1agCfmMDLevel, dot1agCfmConformance=dot1agCfmConformance, dot1agCfmMepPbbTeTrafficMismatchDefect=dot1agCfmMepPbbTeTrafficMismatchDefect, Dot1agCfmHighestDefectPri=Dot1agCfmHighestDefectPri, dot1agCfmMdEntry=dot1agCfmMdEntry, dot1agCfmMepPbbTransmitLbmLtmReverseVid=dot1agCfmMepPbbTransmitLbmLtmReverseVid, dot1agCfmConfigErrorListTable=dot1agCfmConfigErrorListTable, dot1agCfmMepPbbTeLocalMismatchDefect=dot1agCfmMepPbbTeLocalMismatchDefect, dot1agCfmLtrNextEgressIdentifier=dot1agCfmLtrNextEgressIdentifier, dot1agCfmLtrTtl=dot1agCfmLtrTtl, dot1agCfmMaNetCcmInterval=dot1agCfmMaNetCcmInterval, dot1agCfmVlan=dot1agCfmVlan, dot1agCfmMepFngAlarmTime=dot1agCfmMepFngAlarmTime, dot1agCfmMepDbChassisId=dot1agCfmMepDbChassisId, dot1agCfmMepIfIndex=dot1agCfmMepIfIndex, Dot1agCfmMDLevelOrNone=Dot1agCfmMDLevelOrNone, dot1agCfmMaComponentId=dot1agCfmMaComponentId, ieee8021CfmMib=ieee8021CfmMib, dot1agCfmDefaultMdIdPermission=dot1agCfmDefaultMdIdPermission, dot1agCfmConfigErrorListGroup=dot1agCfmConfigErrorListGroup, Dot1agCfmPortStatus=Dot1agCfmPortStatus, dot1agCfmStackEntry=dot1agCfmStackEntry, dot1agMIBObjects=dot1agMIBObjects, dot1agCfmMepTransmitLbmDestMepId=dot1agCfmMepTransmitLbmDestMepId, dot1agCfmMepTable=dot1agCfmMepTable, dot1agCfmMepTransmitLtmTargetMacAddress=dot1agCfmMepTransmitLtmTargetMacAddress, dot1agCfmMepHighestPrDefect=dot1agCfmMepHighestPrDefect, Dot1agCfmMpDirection=Dot1agCfmMpDirection, dot1agCfmNotificationsGroup=dot1agCfmNotificationsGroup, dot1agCfmLtrForwarded=dot1agCfmLtrForwarded, dot1agCfmMepPbbTeMismatchAlarm=dot1agCfmMepPbbTeMismatchAlarm, Dot1agCfmCcmInterval=Dot1agCfmCcmInterval, dot1agCfmMaMepListEntry=dot1agCfmMaMepListEntry, dot1agCfmMepTransmitLbmVlanDropEnable=dot1agCfmMepTransmitLbmVlanDropEnable, dot1agCfmLtrIngressPortIdSubtype=dot1agCfmLtrIngressPortIdSubtype, dot1agCfmMdGroup=dot1agCfmMdGroup, Dot1agCfmConfigErrors=Dot1agCfmConfigErrors, dot1agCfmMepPbbTeCanReportPbbTePresence=dot1agCfmMepPbbTeCanReportPbbTePresence, dot1agCfmLtrChassisId=dot1agCfmLtrChassisId, dot1agCfmDefaultMdGroup=dot1agCfmDefaultMdGroup, Dot1agCfmFngState=Dot1agCfmFngState, dot1agCfmLtrTable=dot1agCfmLtrTable, dot1agCfmDefaultMdDefIdPermission=dot1agCfmDefaultMdDefIdPermission, dot1agCfmMepDbRMepIdentifier=dot1agCfmMepDbRMepIdentifier, ieee8021CfmMaNetGroup=ieee8021CfmMaNetGroup, Dot1agCfmRemoteMepState=Dot1agCfmRemoteMepState, dot1agCfmDefaultMdDefLevel=dot1agCfmDefaultMdDefLevel, dot1agCfmMepPrimaryVid=dot1agCfmMepPrimaryVid, dot1agCfmMepTransmitLtmSeqNumber=dot1agCfmMepTransmitLtmSeqNumber, dot1agCfmMaIndex=dot1agCfmMaIndex, dot1agCfmMepLtmNextSeqNumber=dot1agCfmMepLtmNextSeqNumber, dot1agCfmStack=dot1agCfmStack, Dot1agCfmEgressActionFieldValue=Dot1agCfmEgressActionFieldValue, Dot1agCfmMepDefects=Dot1agCfmMepDefects, dot1agCfmMepErrorCcmLastFailure=dot1agCfmMepErrorCcmLastFailure, dot1agCfmMepLbrInOutOfOrder=dot1agCfmMepLbrInOutOfOrder, dot1agCfmDefaultMdMhfCreation=dot1agCfmDefaultMdMhfCreation, dot1agCfmMdMhfIdPermission=dot1agCfmMdMhfIdPermission, dot1agCfmMepGroup=dot1agCfmMepGroup, dot1agCfmMepTransmitLtmTtl=dot1agCfmMepTransmitLtmTtl, dot1agCfmCompliance=dot1agCfmCompliance, dot1agCfmConfigErrorListEntry=dot1agCfmConfigErrorListEntry, ieee8021CfmDefaultMdDefGroup=ieee8021CfmDefaultMdDefGroup, Dot1agCfmRelayActionFieldValue=Dot1agCfmRelayActionFieldValue, dot1agCfmStackifIndex=dot1agCfmStackifIndex, dot1agCfmMaCompTable=dot1agCfmMaCompTable, dot1agCfmLtrIngress=dot1agCfmLtrIngress, dot1agCfmLtrEgressPortIdSubtype=dot1agCfmLtrEgressPortIdSubtype, dot1agCfmStackMacAddress=dot1agCfmStackMacAddress, dot1agCfmConfigErrorListErrorType=dot1agCfmConfigErrorListErrorType, dot1agCfmMepDbRMepState=dot1agCfmMepDbRMepState, Dot1agCfmMaintAssocName=Dot1agCfmMaintAssocName, dot1agCfmMdMdLevel=dot1agCfmMdMdLevel, dot1agCfmMaMepListTable=dot1agCfmMaMepListTable, dot1agCfmStackMepId=dot1agCfmStackMepId, dot1agCfmMdTableNextIndex=dot1agCfmMdTableNextIndex, dot1agCfmMepMacAddress=dot1agCfmMepMacAddress, dot1agCfmMepTransmitLbmStatus=dot1agCfmMepTransmitLbmStatus, dot1agCfmMepDbMacAddress=dot1agCfmMepDbMacAddress, dot1agCfmMepDbRMepFailedOkTime=dot1agCfmMepDbRMepFailedOkTime, dot1agCfmMepCcmSequenceErrors=dot1agCfmMepCcmSequenceErrors, dot1agCfmMepCciEnabled=dot1agCfmMepCciEnabled, Dot1agCfmMaintAssocNameType=Dot1agCfmMaintAssocNameType, Dot1agCfmMepIdOrZero=Dot1agCfmMepIdOrZero, dot1agCfmMepCcmLtmPriority=dot1agCfmMepCcmLtmPriority, dot1agCfmMaCompRowStatus=dot1agCfmMaCompRowStatus, dot1agCfmLtrEgressPortId=dot1agCfmLtrEgressPortId, dot1agCfmMaNetRowStatus=dot1agCfmMaNetRowStatus, dot1agCfmMaNetName=dot1agCfmMaNetName, dot1agCfmMepTransmitLtmEgressIdentifier=dot1agCfmMepTransmitLtmEgressIdentifier, Dot1agCfmMaintDomainNameType=Dot1agCfmMaintDomainNameType, dot1agCfmMepDbPortStatusTlv=dot1agCfmMepDbPortStatusTlv, dot1agCfmMep=dot1agCfmMep, dot1agCfmLtrLastEgressIdentifier=dot1agCfmLtrLastEgressIdentifier, dot1agCfmCompliances=dot1agCfmCompliances, dot1agCfmMaCompIdPermission=dot1agCfmMaCompIdPermission, dot1agCfmMdFormat=dot1agCfmMdFormat, Dot1agCfmIdPermission=Dot1agCfmIdPermission, dot1agCfmMepActive=dot1agCfmMepActive, dot1agCfmDefaultMdPrimaryVid=dot1agCfmDefaultMdPrimaryVid, Dot1agCfmMaintDomainName=Dot1agCfmMaintDomainName, dot1agCfmMepDbEntry=dot1agCfmMepDbEntry, ieee8021CfmPbbTeTrafficBitGroup=ieee8021CfmPbbTeTrafficBitGroup, dot1agCfmStackMaIndex=dot1agCfmStackMaIndex, dot1agCfmMepTransmitLbmDestMacAddress=dot1agCfmMepTransmitLbmDestMacAddress, dot1agCfmLtrChassisIdSubtype=dot1agCfmLtrChassisIdSubtype, dot1agCfmMepTransmitLbmSeqNumber=dot1agCfmMepTransmitLbmSeqNumber, PYSNMP_MODULE_ID=ieee8021CfmMib, Dot1agCfmPbbComponentIdentifier=Dot1agCfmPbbComponentIdentifier, dot1agCfmLtrSeqNumber=dot1agCfmLtrSeqNumber, dot1agCfmMepPbbTeMismatchSinceReset=dot1agCfmMepPbbTeMismatchSinceReset, dot1agCfmStackTable=dot1agCfmStackTable, dot1agCfmDefaultMdTable=dot1agCfmDefaultMdTable, dot1agCfmStackMdLevel=dot1agCfmStackMdLevel, dot1agCfmConfigErrorListIfIndex=dot1agCfmConfigErrorListIfIndex, dot1agCfmMepDefects=dot1agCfmMepDefects, dot1agCfmMepDbInterfaceStatusTlv=dot1agCfmMepDbInterfaceStatusTlv, dot1agCfmMepXconCcmLastFailure=dot1agCfmMepXconCcmLastFailure, dot1agCfmMepDbRMepIsActive=dot1agCfmMepDbRMepIsActive, Dot1agCfmInterfaceStatus=Dot1agCfmInterfaceStatus, dot1agCfmMaMepListIdentifier=dot1agCfmMaMepListIdentifier, dot1agCfmMepTransmitLtmTargetMepId=dot1agCfmMepTransmitLtmTargetMepId, dot1agCfmMepTransmitLtmResult=dot1agCfmMepTransmitLtmResult, dot1agCfmVlanVid=dot1agCfmVlanVid, dot1agCfmVlanTable=dot1agCfmVlanTable, dot1agCfmMaNetEntry=dot1agCfmMaNetEntry, dot1agCfmMepDbChassisIdSubtype=dot1agCfmMepDbChassisIdSubtype, dot1agCfmMdTable=dot1agCfmMdTable, dot1agCfmMaCompPrimaryVlanId=dot1agCfmMaCompPrimaryVlanId, dot1agCfmMaMepListRowStatus=dot1agCfmMaMepListRowStatus, dot1agCfmMa=dot1agCfmMa, dot1agCfmMepTransmitLbmVlanPriority=dot1agCfmMepTransmitLbmVlanPriority, dot1agCfmMepDbTable=dot1agCfmMepDbTable, dot1agCfmMaCompNumberOfVids=dot1agCfmMaCompNumberOfVids, Dot1agCfmMepId=Dot1agCfmMepId, dot1agCfmMepTransmitLtmTargetIsMepId=dot1agCfmMepTransmitLtmTargetIsMepId, ieee8021CfmPbbTeExtensionGroup=ieee8021CfmPbbTeExtensionGroup, dot1agCfmMdMaNextIndex=dot1agCfmMdMaNextIndex, dot1agCfmMepTransmitLtmStatus=dot1agCfmMepTransmitLtmStatus, dot1agCfmStackMdIndex=dot1agCfmStackMdIndex, dot1agCfmStackGroup=dot1agCfmStackGroup, dot1agCfmMepLowPrDef=dot1agCfmMepLowPrDef, dot1agCfmLtrEntry=dot1agCfmLtrEntry, dot1agCfmVlanComponentId=dot1agCfmVlanComponentId, dot1agCfmMepDbRdi=dot1agCfmMepDbRdi, dot1agCfmMepUnexpLtrIn=dot1agCfmMepUnexpLtrIn, dot1agCfmLtrRelay=dot1agCfmLtrRelay, dot1agCfmMdName=dot1agCfmMdName, dot1agCfmMepLbrOut=dot1agCfmMepLbrOut, dot1agCfmMepFngResetTime=dot1agCfmMepFngResetTime, dot1agCfmDefaultMdStatus=dot1agCfmDefaultMdStatus, dot1agCfmGroups=dot1agCfmGroups, dot1agCfmMepCciSentCcms=dot1agCfmMepCciSentCcms, dot1agCfmFaultAlarm=dot1agCfmFaultAlarm)

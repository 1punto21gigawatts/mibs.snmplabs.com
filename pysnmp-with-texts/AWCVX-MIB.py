#
# PySNMP MIB module AWCVX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AWCVX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:32:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
dot1dTpPort, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dTpPort")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
iso, Gauge32, TimeTicks, IpAddress, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Unsigned32, Bits, ObjectIdentity, enterprises, ModuleIdentity, Counter64, Integer32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "TimeTicks", "IpAddress", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Unsigned32", "Bits", "ObjectIdentity", "enterprises", "ModuleIdentity", "Counter64", "Integer32", "MibIdentifier")
TruthValue, RowStatus, MacAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "MacAddress", "DisplayString", "TextualConvention")
awcVx = ModuleIdentity((1, 3, 6, 1, 4, 1, 522, 3))
awcVx.setRevisions(('2003-04-21 00:00', '2002-12-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: awcVx.setRevisionsDescriptions(('Added awcDot11NonRootMobility to determine if a radio should look for a better parent AP in heavy traffic and awcFtEnableMcastMapping for multicast forwarding configuration.', 'This revision adds awcDot11QoSTable QoS support, awcIfOutDiscardsCoSx statistics to awcIfTable, awcPolGrpTable policy group, 802.11A 5GHz radio support, and action when Ethernet is lost. Corrected the ranges for awcDot11AuthenticationAlgorithmsIndex and awcPolGrpId.',))
if mibBuilder.loadTexts: awcVx.setLastUpdated('200304210000Z')
if mibBuilder.loadTexts: awcVx.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: awcVx.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-aironet@cisco.com')
if mibBuilder.loadTexts: awcVx.setDescription('The MIB module for Aironet entities. iso(1).org(3).dod(6).internet(1).private(4). enterprises(1).aironet(522).awcVx(3). This MIB provides network management support for Cisco IEEE 802.11 Wireless LAN type devices such as Access Point and Wireless Access Bridge.')
aironet = MibIdentifier((1, 3, 6, 1, 4, 1, 522))
awcSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 1))
bootconfigVx = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 2))
awcSerialDev = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 3))
awcFtp = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 4))
awc802dot11 = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6))
awcUserMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 7))
awcHttpd = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 8))
awcDnsRes = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 9))
awcSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 10))
awcSntp = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 11))
awcForwardTbl = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 12))
awcRipConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 13))
awcEventLog = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 14))
awcEtherMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 15))
awcPolicyGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 16))
awcDdpIAPP = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 17))
awcHotStandby = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 18))
awcAaa = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 19))
awcAcctConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 19, 3))
awcProtocolFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 20))
awcMobileIP = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 22))
class AwcVlanId(TextualConvention, Integer32):
    description = 'A 12-bit VLAN ID used in the VLAN Tag header. A value of 0 indicates NULL or no VLAN ID.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 4094)

class AwcPolId(TextualConvention, Integer32):
    description = 'A 10-bit Policy Group identifier. A value of 0 indicates that no Policy Group is specified.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 1023)

class WEPKeytype128(TextualConvention, OctetString):
    description = 'Wired Equivalent Privacy (WEP) shared secret encryption key, 128-bits.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(5, 13)

class AwcInvokeCommand(TextualConvention, Integer32):
    description = "Command directive to control asynchronous operations on the host system of the SNMP agent. Not all asynchronous operations support all directives. For example, not all operations support 'restart' or 'restartNotify' commands. inactive - No operation is either started or in progress. start - Start the operation. Perform the operation to completion. startNotify - Start the operation. Perform the operation to completion, then notify the requesting SNMP Manager via a Trap. restart - If the operation is not already started, start it. If it is already started, re-initialize the operation in a graceful manner and start it over again. Do not alter the Notify option of the corresponding Start command. restartNotify - If the operation is not already started, start it. If it is already started, re-initialize the operation in a graceful manner and start it over again. When the operation is complete, notify the requesting SNMP Manager via a Trap. cancel - If the operation, is not started, do nothing. If it is started, stop the operation gracefully. Notify the SNMP Manager via a Trap in accordance with whether {Re}Start or {Re}StartNotify was used. Multiple use of 'start' before an operation completes is ignored. Multiple use of 'startNotify' before an operation completes adds the Notify option of the operation."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("inactive", 1), ("start", 2), ("startNotify", 3), ("restart", 4), ("restartNotify", 5), ("cancel", 6))

class AwcDot11MicAlgorithm(TextualConvention, Integer32):
    description = 'Auxiliary Message Integrity Check (MIC) calculated on WEP-encoded packets to validate that they have not been modified. This is in addition to the standard 802.11 ICV.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("micNone", 1), ("micMMH", 2))

class AwcDot11WEPKeyPermuteAlgorithm(TextualConvention, Integer32):
    description = 'Function through which the WEP encryption key is permuted between key renewal periods.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("wepPermuteNone", 1), ("wepPermuteIV", 2))

class AwcEventDisposition(TextualConvention, Integer32):
    description = "Specifies the manner in which an event should be handled by the system. Events can be counted, displayed on the console, recorded in the system's event log memory, or an external device can be notified of the event. Each degree of handling implies all lower degrees."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("count", 1), ("displayConsole", 2), ("record", 3), ("notify", 4))

class AwcDot11EventDisposition(TextualConvention, Integer32):
    description = 'Specifies options to handled standard IEEE 802.11 traps on this system'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("noNotification", 1), ("eventLogOnly", 2), ("ieeeTrapOnly", 3), ("eventLogAndIeeeTrap", 4))

class AwcHotStandbyStatus(TextualConvention, Integer32):
    description = 'The status of the hot standby access point: normal(0) - AP hot standby is running. initializing(1) - AP hot standby is being initialized. takeover(2) - AP takeovers as new active access point. stopped(3) - AP hot standby stopped. associating(4) - Standby AP associates to active access point. rootMacFailed(5) - Cannot detect root AP MAC address. interfaceMerge(6) - Interface merge. associationFail(7) - Association failed. etherTestFail(8) - Hot standby test on Ethernet failed. radioTestFail(9) - Hot standby test on radio failed. error(10) - Hot standby system error.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("normal", 0), ("initializing", 1), ("takeover", 2), ("stopped", 3), ("associating", 4), ("rootMacFailed", 5), ("interfaceMerge", 6), ("associationFail", 7), ("etherTestFail", 8), ("radioTestFail", 9), ("error", 10))

vxWorksVersion = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vxWorksVersion.setStatus('current')
if mibBuilder.loadTexts: vxWorksVersion.setDescription('The version of the underlying VxWorks operating system.')
creationDate = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: creationDate.setStatus('current')
if mibBuilder.loadTexts: creationDate.setDescription('The date and time the Access Point system code was initially compiled.')
awcVxVersion = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcVxVersion.setStatus('current')
if mibBuilder.loadTexts: awcVxVersion.setDescription('The version of the Access Point system code.')
sysFlags = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 4), Unsigned32().clone(192)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysFlags.setStatus('current')
if mibBuilder.loadTexts: sysFlags.setDescription('The VxWorks sysFlags system-configuration flags in use by the Access Point system. Not used by system code with awcVxVersion from 10.00 to 11.06.')
languageCode = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('en-US')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: languageCode.setStatus('current')
if mibBuilder.loadTexts: languageCode.setDescription('The language currently in use by the system. Max. string length is 128 octets.')
awcDevID = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDevID.setStatus('current')
if mibBuilder.loadTexts: awcDevID.setDescription('The Aironet DDP protocol device ID of the system when using the full capabilities with which the system is licensed. Note that a system may be configured to use fewer capabilities that those for which it is licensed. For example, a Bridge may be configured for use as an Access Point.')
awcDevIDtxt = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDevIDtxt.setStatus('current')
if mibBuilder.loadTexts: awcDevIDtxt.setDescription('Textual representation of awcDevID. Max. string length is 128 octets.')
enableHTTP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableHTTP.setStatus('current')
if mibBuilder.loadTexts: enableHTTP.setDescription("If true, the Access Point's HTTP server can accept connections from other network devices. If false, the Access Point's HTTP server will only accept connections from the Access Point's console or indirectly over TELNET.")
enableTelnet = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableTelnet.setStatus('current')
if mibBuilder.loadTexts: enableTelnet.setDescription("If true, the Access Point's TELNET server can accept connections from other network devices. If false, all TELNET connections will be refused.")
enableSNMP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMP.setStatus('current')
if mibBuilder.loadTexts: enableSNMP.setDescription("If true, the Access Point's SNMP agent can accept connections from other network devices. If false, all SNMP connections will be refused. Note that this can only be set to false by an SNMP management station. If false, it can only be set to true by non-SNMP means.")
enableDnsResolver = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableDnsResolver.setStatus('current')
if mibBuilder.loadTexts: enableDnsResolver.setDescription('If true, the Access Point will attempt to resolve IP address references through all configured DNS servers and will attempt to perform reverse-lookup via all configured DNS servers when displaying IP addresses. If false, the Access Point will interpret and display only explicit numeric IP addresses.')
enableSNTP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNTP.setStatus('current')
if mibBuilder.loadTexts: enableSNTP.setDescription('If true, the Access Point will attempt to periodically update its wall-clock time via a configured SNTP server. If false, the Access Point wall-clock time must be manually adjusted.')
enableWDB = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableWDB.setStatus('current')
if mibBuilder.loadTexts: enableWDB.setDescription('If true, the Access Point will enable use of the VxWorks WDB debugger upon its next reboot. If false, no WDB debugging services will be available after the next reboot. The value of enableWDB is applicable only to special diagnostic versions of the Access Point system code.')
pingTxLen = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(12, 4096)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingTxLen.setStatus('current')
if mibBuilder.loadTexts: pingTxLen.setDescription('The size in octets of ping packets transmitted by the Access Point. Default 64.')
awcFirstBoot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 16), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFirstBoot.setStatus('current')
if mibBuilder.loadTexts: awcFirstBoot.setDescription('If true, no user-specified configuration has been saved by the Access Point since either the system left Cisco manufacturing or since the user performed a Reset All System Factory Defaults operation. If false, a change in configuration has been saved by the user. Note that configurations specified solely via boot protocols such as DHCP or BOOTP are not considered user-specified for purposes of changing awcFirstBoot.')
awcOemOUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 17), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcOemOUI.setStatus('current')
if mibBuilder.loadTexts: awcOemOUI.setDescription('The IEEE Organizationally Unique Identifier of the reseller for which this system is branded.')
awcOemName = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcOemName.setStatus('current')
if mibBuilder.loadTexts: awcOemName.setDescription('The full name of the reseller for which this system is branded.')
awcOemNameShort = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcOemNameShort.setStatus('current')
if mibBuilder.loadTexts: awcOemNameShort.setDescription('An abbreviated name of the reseller for which this system is branded.')
awcOemHomeURL = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcOemHomeURL.setStatus('current')
if mibBuilder.loadTexts: awcOemHomeURL.setDescription('The URL of the corporate HTML home page of the reseller for which this system is branded.')
enablePSPF = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 21), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enablePSPF.setStatus('current')
if mibBuilder.loadTexts: enablePSPF.setDescription('If true, Publicly-Secure Packet Forwarding mode is enabled (i.e. clients can not communicate with each other). If false, normal packet forwarding is used.')
sysExceptionReboot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 24), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExceptionReboot.setStatus('current')
if mibBuilder.loadTexts: sysExceptionReboot.setDescription('If true, all access violations or other general faults in any task will result in a reboot of the system. If false, such errors will not result in a reboot, and thus diagnostics can be performed on the system.')
bootblockVersion = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootblockVersion.setStatus('current')
if mibBuilder.loadTexts: bootblockVersion.setDescription('The version of the Access Point boot block (bootstrap loader) code.')
motherboardRevision = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: motherboardRevision.setStatus('current')
if mibBuilder.loadTexts: motherboardRevision.setDescription('Revision number of the Access Point system motherboard.')
enableSTP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 27), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSTP.setStatus('current')
if mibBuilder.loadTexts: enableSTP.setDescription('If true and the system is licensed with Bridge capabilities, the IEEE 802.1D Spanning Tree Protocol will be be used to control packet forwarding on all network interfaces. If false or the system is not licensed with Bridge capabilities, the system will use Access Point heuristics to control packet forwarding on all network interfaces.')
enableRebootKey = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 28), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableRebootKey.setStatus('current')
if mibBuilder.loadTexts: enableRebootKey.setDescription('If true, the VxWorks Monitor Trap keystroke is enabled from the console and from Telnet. By default, this is <control-X>. Entering this character initiates a warm-restart of the system. If false, the VxWorks Monitor Trap keystroke is disabled.')
awcLocateUnit = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 1, 29), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcLocateUnit.setStatus('current')
if mibBuilder.loadTexts: awcLocateUnit.setDescription('If true, the unit will immediately begin flashing all three of its Status LEDs with an alternating pattern of amber and off. If false, the Status LEDs operate in their normal fashion.')
bootconfigBootProtocol = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bootp", 2), ("dhcp", 3))).clone('dhcp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigBootProtocol.setStatus('current')
if mibBuilder.loadTexts: bootconfigBootProtocol.setDescription('The protocol to be used for automatic configuration at the time of system bootstrap/reboot. Options BOOTP, DHCP, or none.')
bootconfigReadINI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("always", 1), ("never", 2), ("ifSpecified", 3))).clone('ifSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigReadINI.setStatus('current')
if mibBuilder.loadTexts: bootconfigReadINI.setDescription("If always, the system will attempt to read a .ini-formatted configuration file upon every reboot. If never, the system will not attempt to read a .ini file upon reboot, even if a boot protocol is in use and the boot server specifies a file to be read. If ifSpecified, the system will attempt to read a .ini file upon reboot if and only if a boot protocol is in use and the boot server explicitly specifies a file to be read. The system attempts several filenames in the process of retrieving a .ini file without error. In order, these filenames are based on the system's BOOTP- or DHCP-assigned client name, then the MIB2 sysName, then the system's IP address, then, as a last resort, the BOOTP- or DHCP-assigned boot file name. For each filename, the system attempts to read first from the designated defaultFileServer, then, if not successful, from one of either the BOOTP/DHCP server itself or bootconfigFileServerAddr (if specified by the BOOTP/DHCP server).")
bootconfigServerConfigTimeout = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 3), Unsigned32().clone(120)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigServerConfigTimeout.setStatus('current')
if mibBuilder.loadTexts: bootconfigServerConfigTimeout.setDescription('The time in seconds which the system should wait for a configuration response from a BOOTP server before falling back to the stored configuration.')
bootconfigMultOfferTimeout = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 4), Unsigned32().clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigMultOfferTimeout.setStatus('current')
if mibBuilder.loadTexts: bootconfigMultOfferTimeout.setDescription('The time, in seconds, which the system should wait for a better offer configuration response from a DHCP or BOOTP server before choosing the best current offer.')
bootconfigReqLeaseDuration = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 5), Unsigned32().clone(1440)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigReqLeaseDuration.setStatus('current')
if mibBuilder.loadTexts: bootconfigReqLeaseDuration.setDescription('The requested DHCP lease duration, in minutes.')
bootconfigMinLeaseDuration = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 6), Unsigned32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigMinLeaseDuration.setStatus('current')
if mibBuilder.loadTexts: bootconfigMinLeaseDuration.setDescription('The minimum acceptable DHCP lease duration, in minutes.')
bootconfigDev = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigDev.setStatus('current')
if mibBuilder.loadTexts: bootconfigDev.setDescription('Text string identifying the network device used for bootstrapping the system via BOOTP or DHCP. This is only applicable in BOOTP mode or when the system is configured as a router, when not all the network interfaces share the same ifPhysAddress.')
bootconfigClientAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigClientAddr.setStatus('current')
if mibBuilder.loadTexts: bootconfigClientAddr.setDescription('IPv4 network address of this device, as determined by the BOOTP or DHCP protocol.')
bootconfigHostAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigHostAddr.setStatus('current')
if mibBuilder.loadTexts: bootconfigHostAddr.setDescription('IPv4 network address of the BOOTP or DHCP server from which the configuration of this device was leased.')
bootconfigBootFile = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigBootFile.setStatus('current')
if mibBuilder.loadTexts: bootconfigBootFile.setDescription('Name of the default boot configuration file, specified by the BOOTP or DHCP server, containing the system configuration to be utilized by this device. This is considered a default configuration file because many DHCP servers are not capable of distinguishing boot files between different clients.')
bootconfigSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigSubnetMask.setStatus('current')
if mibBuilder.loadTexts: bootconfigSubnetMask.setDescription('IPv4 network subnet mask to be used by this device, as determined by the BOOTP or DHCP protocol.')
bootconfigGateway = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigGateway.setStatus('current')
if mibBuilder.loadTexts: bootconfigGateway.setDescription('IPv4 network address of the default network gateway to be used by this device, as determined by the BOOTP or DHCP protocol.')
bootconfigHostName = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigHostName.setStatus('current')
if mibBuilder.loadTexts: bootconfigHostName.setDescription('Textual name of the BOOTP or DHCP server from which the configuration of this device was leased. This should be a DNS-recognizable host name.')
bootconfigClientName = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigClientName.setStatus('current')
if mibBuilder.loadTexts: bootconfigClientName.setDescription('Textual name of this device, as determined by the BOOTP or DHCP protocol. This should be a DNS-recognizable host name.')
bootconfigNameServerTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 2, 15), )
if mibBuilder.loadTexts: bootconfigNameServerTable.setStatus('current')
if mibBuilder.loadTexts: bootconfigNameServerTable.setDescription('Table of DNS Name Servers provided by the bootconfigHostAddr Boot Server.')
bootconfigNameServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 2, 15, 1), ).setIndexNames((0, "AWCVX-MIB", "bootconfigNameServerPriority"))
if mibBuilder.loadTexts: bootconfigNameServerEntry.setStatus('current')
if mibBuilder.loadTexts: bootconfigNameServerEntry.setDescription('An entry in bootconfigNameServerTable.')
bootconfigNameServerPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigNameServerPriority.setStatus('current')
if mibBuilder.loadTexts: bootconfigNameServerPriority.setDescription('The priority order in which a domain name server is queried. Lower values are queried first.')
bootconfigNameServer = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 2, 15, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigNameServer.setStatus('current')
if mibBuilder.loadTexts: bootconfigNameServer.setDescription('The IPv4 address of a domain name server.')
bootconfigDomainName = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigDomainName.setStatus('current')
if mibBuilder.loadTexts: bootconfigDomainName.setDescription('Name of the IP domain of which this device is a member, as determined by the BOOTP or DHCP protocol.')
bootconfigSntpServer = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigSntpServer.setStatus('current')
if mibBuilder.loadTexts: bootconfigSntpServer.setDescription('IPv4 network address of SNTP server for use by this device, as determined by the BOOTP or DHCP protocol.')
bootconfigSaveServerResponse = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 18), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigSaveServerResponse.setStatus('current')
if mibBuilder.loadTexts: bootconfigSaveServerResponse.setDescription('If true, the leased configuration from a boot server is saved as the new system defaults. If false, system defaults remain unchanged when a new configuration is leased.')
bootconfigCmdInvokeIniLoad = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 19), AwcInvokeCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigCmdInvokeIniLoad.setStatus('current')
if mibBuilder.loadTexts: bootconfigCmdInvokeIniLoad.setDescription("Initiate loading of an initialization script '.ini' file from the file server into the system FLASH. Commands recognized: start.")
bootconfigCmdStatusIniLoad = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigCmdStatusIniLoad.setStatus('current')
if mibBuilder.loadTexts: bootconfigCmdStatusIniLoad.setDescription("Status of the most recent command to load an initialization script '.ini' file. Possible values: 0 = Operation completed successfully (or has not taken place). 2 = The '.ini' file was not found on the file server. 12 = Insufficient memory to load the '.ini' file. 22 = Invalid '.ini' file format. 35 = File format of the '.ini' file is not supported. 68 = Operation is still in progress. Poll again later. 72 = Operation was started, but later was canceled.")
bootconfigDhcpClassID = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('AP4800E')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigDhcpClassID.setStatus('current')
if mibBuilder.loadTexts: bootconfigDhcpClassID.setDescription('Specification of the DHCP Class Identifier presented by the system when requesting DHCP leases.')
bootconfigFileServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigFileServerAddr.setStatus('current')
if mibBuilder.loadTexts: bootconfigFileServerAddr.setDescription('IPv4 network address of the file server from which to read configuration files, as determined by the BOOTP or DHCP protocol.')
bootconfigLogServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 26), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigLogServerAddr.setStatus('current')
if mibBuilder.loadTexts: bootconfigLogServerAddr.setDescription('IPv4 network address of the host to receive SYSLOG messages, as determined by the BOOTP or DHCP protocol.')
bootconfigBootCount = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootconfigBootCount.setStatus('current')
if mibBuilder.loadTexts: bootconfigBootCount.setDescription('The number of times the system code has been restarted since the system left Cisco manufacturing.')
bootconfigDhcpClientIdType = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 128))).clone(namedValues=NamedValues(("ethernet10Mb", 1), ("experimentalEthernet3Mb", 2), ("amateurRadioAxDot25", 3), ("proteonProNetTokenRing", 4), ("chaos", 5), ("ieee802Networks", 6), ("arcnet", 7), ("hyperchannel", 8), ("lanstar", 9), ("autonet", 10), ("localTalk", 11), ("localNet", 12), ("nonHardware", 128)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigDhcpClientIdType.setStatus('current')
if mibBuilder.loadTexts: bootconfigDhcpClientIdType.setDescription("The ARP hardware type, per RFC 1700, of bootconfigDhcpClientIdValue. If it is not a hardware address (e.g. is a fully-qualified domain name), a value of 0 will be used for the DHCP Client Identifier 'htype' field.")
bootconfigDhcpClientIdValue = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 2, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootconfigDhcpClientIdValue.setStatus('current')
if mibBuilder.loadTexts: bootconfigDhcpClientIdValue.setDescription('Specification of the DHCP unique client Identifier presented by the system when requesting DHCP leases.')
awcSerialConfigTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 3, 1), )
if mibBuilder.loadTexts: awcSerialConfigTable.setStatus('current')
if mibBuilder.loadTexts: awcSerialConfigTable.setDescription('SerialConfigTable attributes. In tabular form to allow for multiple instances on an agent.')
awcSerialConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1), ).setIndexNames((0, "AWCVX-MIB", "serialDevIndex"))
if mibBuilder.loadTexts: awcSerialConfigEntry.setStatus('current')
if mibBuilder.loadTexts: awcSerialConfigEntry.setDescription('An entry in the awcSerialConfigEntry table.')
serialDevIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialDevIndex.setStatus('current')
if mibBuilder.loadTexts: serialDevIndex.setDescription('The index used to access rows in the awcSerialConfig table.')
serialAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("error", 4))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialAdminStatus.setStatus('current')
if mibBuilder.loadTexts: serialAdminStatus.setDescription('The requested status of the serial port.')
serialOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("error", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialOperStatus.setStatus('current')
if mibBuilder.loadTexts: serialOperStatus.setDescription('The actual status of the serial port.')
serialBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 4), Unsigned32().clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialBaud.setStatus('current')
if mibBuilder.loadTexts: serialBaud.setDescription('The baud rate of the serial port.')
serialParity = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("even", 2), ("odd", 3), ("one", 4), ("zero", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialParity.setStatus('current')
if mibBuilder.loadTexts: serialParity.setDescription('The parity of the serial port.')
serialDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(7, 8)).clone(8)).setUnits('bits').setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialDataBits.setStatus('current')
if mibBuilder.loadTexts: serialDataBits.setDescription('The number of data bits per character recognized by the serial port.')
serialStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(1)).setUnits('bits').setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialStopBits.setStatus('current')
if mibBuilder.loadTexts: serialStopBits.setDescription('The number of stop bits of the serial port.')
serialFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("swXonXoff", 2), ("hwRtsCts", 3), ("swHwBoth", 4))).clone('swXonXoff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialFlowControl.setStatus('current')
if mibBuilder.loadTexts: serialFlowControl.setDescription('The flow control method used by the serial port.')
serialTerminalType = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("teletype", 1), ("ansi", 2))).clone('teletype')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTerminalType.setStatus('current')
if mibBuilder.loadTexts: serialTerminalType.setDescription('The terminal type of the serial port.')
serialTerminalLines = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 50)).clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTerminalLines.setStatus('current')
if mibBuilder.loadTexts: serialTerminalLines.setDescription('The number of horizontal lines available on each terminal page. Default 24.')
serialTerminalColumns = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 132)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTerminalColumns.setStatus('current')
if mibBuilder.loadTexts: serialTerminalColumns.setDescription('The number of vertical columns available on each terminal page. Default 80.')
serialDevFd = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialDevFd.setStatus('current')
if mibBuilder.loadTexts: serialDevFd.setDescription('The VxWorks I/O File Descriptor used to access the serial device.')
defaultFileServer = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultFileServer.setStatus('current')
if mibBuilder.loadTexts: defaultFileServer.setDescription('The name of the preferred file server to be used for all FTP and TFTP Put and Get operations. Max. name length is 128 octets.')
awcFileXferProtocol = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("ftp", 2))).clone('ftp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferProtocol.setStatus('current')
if mibBuilder.loadTexts: awcFileXferProtocol.setDescription('The protocol to be used by the system for file transfer (TFTP or FTP).')
awcFileXferUser = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('anonymous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferUser.setStatus('current')
if mibBuilder.loadTexts: awcFileXferUser.setDescription('The name of the user, as required by all FTP file transfers. Max. name length is 128 octets.')
awcFileXferPassword = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferPassword.setStatus('current')
if mibBuilder.loadTexts: awcFileXferPassword.setDescription('The password of the user, as required by all FTP file transfers. Max. password length is 128 octets.')
awcFileXferCmdInvokeFileLoad = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 5), AwcInvokeCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferCmdInvokeFileLoad.setStatus('current')
if mibBuilder.loadTexts: awcFileXferCmdInvokeFileLoad.setDescription('Initiate loading of all specified files from the file server into the system FLASH. Commands recognized: start.')
awcFileXferCmdStatusFileLoad = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFileXferCmdStatusFileLoad.setStatus('current')
if mibBuilder.loadTexts: awcFileXferCmdStatusFileLoad.setDescription('Status of the most recent command to load the specified fileXferFile* files. Possible values: 0 = Operation completed successfully (or has not taken place). 2 = At least one file was not found on the file server. 12 = Insufficient memory to load all files. 22 = No file specified, or invalid file format. 35 = File format of at least one of the files is not supported. 68 = Operation is still in progress. Poll again later. 72 = Operation was started, but later was canceled.')
awcFileXferCmdInvokeFileSave = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 7), AwcInvokeCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferCmdInvokeFileSave.setStatus('current')
if mibBuilder.loadTexts: awcFileXferCmdInvokeFileSave.setDescription('Initiate saving of all specified fileXferFile* files to the file server from the system FLASH. Commands recognized: start.')
awcFileXferCmdStatusFileSave = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFileXferCmdStatusFileSave.setStatus('current')
if mibBuilder.loadTexts: awcFileXferCmdStatusFileSave.setDescription('Status of the most recent command to save the specified fileXferFile* files. Possible values: 0 = Operation completed successfully (or has not taken place). 1 = Insufficient permission to save the files. 2 = A directory specified for saving at least one of the files was not found. 22 = No file specified, or invalid file format. 68 = Operation is still in progress. Poll again later. 72 = Operation was started, but later was canceled.')
awcFileXferFileFirmwareSystem = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFileFirmwareSystem.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFileFirmwareSystem.setDescription('The filename of the system firmware image. Max. string length is 128 octets.')
awcFileXferFileFirmwareRadio0 = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFileFirmwareRadio0.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFileFirmwareRadio0.setDescription('The filename of the radio firmware image. Max. string length is 128 octets.')
awcFileXferFileWebUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFileWebUI.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFileWebUI.setDescription('The filename of the system Web pages image. Max. string length is 128 octets.')
awcFileXferFileFpgaPcmcia = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFileFpgaPcmcia.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFileFpgaPcmcia.setDescription('The filename of the FPGA image for the PCMCIA controller. Max. string length is 128 octets.')
awcFileXferTftpPort = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(69)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferTftpPort.setStatus('current')
if mibBuilder.loadTexts: awcFileXferTftpPort.setDescription('IP port number over which to perform TFTP operations. Default 69.')
awcFileXferFtpDirectory = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFtpDirectory.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFtpDirectory.setDescription('Directory on defaultFileServer in which files are located.')
awcFileXferFilesFLASH = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('AP340_latest.img')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFilesFLASH.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFilesFLASH.setDescription('The filename of a complete FLASH firmware image for the system, including all non-configuration files within the system FLASH file system. Max. string length is 128 octets.')
awcFileXferFileFirmwareRadio1 = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 4, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFileXferFileFirmwareRadio1.setStatus('current')
if mibBuilder.loadTexts: awcFileXferFileFirmwareRadio1.setDescription('The filename of the radio firmware image. Max. string length is 128 octets.')
awcIfTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 5), )
if mibBuilder.loadTexts: awcIfTable.setStatus('current')
if mibBuilder.loadTexts: awcIfTable.setDescription('IfTable attributes. In tabular form to allow for multiple instances on an agent.')
awcIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcIfEntry.setStatus('current')
if mibBuilder.loadTexts: awcIfEntry.setDescription('An entry in the awcIfEntry table.')
awcIfDefaultPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfDefaultPhysAddress.setStatus('current')
if mibBuilder.loadTexts: awcIfDefaultPhysAddress.setDescription('The default, factory-assigned MAC address of the interface. Guaranteed to be unique across all IEEE 802 devices.')
awcIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIfPhysAddress.setStatus('current')
if mibBuilder.loadTexts: awcIfPhysAddress.setDescription('The MAC address to be used by the interface. If awcIfDefaultPhysAddress is to be used, this is 00:00:00:00:00:00.')
awcIfAdoptPrimaryIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIfAdoptPrimaryIdentity.setStatus('current')
if mibBuilder.loadTexts: awcIfAdoptPrimaryIdentity.setDescription('If true, this interface adopts the identity of bootconfigDev, the primary interface. This includes MAC address, IP address, etc. This is the conventional mode of operation when operating as a transparent bridge. If false, this interface always has a unique MAC address.')
awcIfDefaultIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 4), IpAddress().clone(hexValue="0A000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIfDefaultIpAddress.setStatus('current')
if mibBuilder.loadTexts: awcIfDefaultIpAddress.setDescription('The default IPv4 Address of the interface. If BOOTP or DHCP is enabled, this may be overridden by the BOOTP or DHCP server.')
awcIfDefaultIpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 5), IpAddress().clone(hexValue="FFFFFF00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIfDefaultIpNetMask.setStatus('current')
if mibBuilder.loadTexts: awcIfDefaultIpNetMask.setDescription('The default IPv4 netmask of the interface. If BOOTP or DHCP is enabled, this may be overridden by the BOOTP or DHCP server.')
awcIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfIpAddress.setStatus('current')
if mibBuilder.loadTexts: awcIfIpAddress.setDescription('The IPv4 Address currently in use by the interface.')
awcIfIpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfIpNetMask.setStatus('current')
if mibBuilder.loadTexts: awcIfIpNetMask.setDescription('The IPv4 netmask currently in use by the interface.')
awcIfMSDUMaxLength = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfMSDUMaxLength.setStatus('current')
if mibBuilder.loadTexts: awcIfMSDUMaxLength.setDescription('Maximum length of the data portion of a packet for this particular interface. This is the maximum MAC Service Data Unit length, which is greater than or equal to ifMtu, depending on the configured MAC-level encapsulation.')
awcIfOutDiscardsCoS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS0.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS0.setDescription('The number of outbound packets of CoS 0 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS1 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS1.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS1.setDescription('The number of outbound packets of CoS 1 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS2 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS2.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS2.setDescription('The number of outbound packets of CoS 2 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS3 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS3.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS3.setDescription('The number of outbound packets of CoS 3 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS4 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS4.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS4.setDescription('The number of outbound packets of CoS 4 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS5 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS5.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS5.setDescription('The number of outbound packets of CoS 5 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS6 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS6.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS6.setDescription('The number of outbound packets of CoS 6 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcIfOutDiscardsCoS7 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcIfOutDiscardsCoS7.setStatus('current')
if mibBuilder.loadTexts: awcIfOutDiscardsCoS7.setDescription('The number of outbound packets of CoS 7 which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space. Another reason would be exceeding their maximum time-to-live.')
awcDot11smt = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6, 1))
awcDot11StationConfigTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1), )
if mibBuilder.loadTexts: awcDot11StationConfigTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11StationConfigTable.setDescription('Station Config Table attributes. In tabular form to allow for multiple instances on an agent.')
awcDot11StationConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11StationConfigEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11StationConfigEntry.setDescription('An entry in the awcDot11StationConfigTable table.')
awcDot11StationRole = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("roleClient", 1), ("roleIBSS", 2), ("roleRepeater", 3), ("roleAP", 4))).clone('roleAP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11StationRole.setStatus('current')
if mibBuilder.loadTexts: awcDot11StationRole.setDescription('The role of this station itself within the 802.11 BSS (radio cell) of which it is a member.')
awcDot11PowerManagementSubMode = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11PowerManagementSubMode.setStatus('current')
if mibBuilder.loadTexts: awcDot11PowerManagementSubMode.setDescription('When configured as roleClient, the Power Management Submode of the device.')
awcDot11UseAWCExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11UseAWCExtensions.setStatus('current')
if mibBuilder.loadTexts: awcDot11UseAWCExtensions.setDescription('If true, Aironet extensions to the basic 802.11 protocol are enabled. This results in better BSS performance and faster roaming. If false, only the basic 802.11 protocols are used. This ensures maximum compatibility with non-Aironet equipment.')
awcDot11AllowAssocBroadcastSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AllowAssocBroadcastSSID.setStatus('current')
if mibBuilder.loadTexts: awcDot11AllowAssocBroadcastSSID.setDescription('If true and awcDot11StationRole is either roleAP or roleRepeater, the radio will respond to Broadcast SSID Probe Requests and will broadcast its own SSID within its Beacons. If false, the radio will not respond to the Broadcast SSID and will not broadcast its SSID within Beacons.')
awcDot11PrivacyOptionImplementedMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11PrivacyOptionImplementedMaxRate.setStatus('current')
if mibBuilder.loadTexts: awcDot11PrivacyOptionImplementedMaxRate.setDescription('The maximum Transmit bit rate supported by the radio when using WEP encryption. Expressed in standard 802.11 increments of 500Kb/sec.')
awcDot11DesiredBSSLength = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DesiredBSSLength.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredBSSLength.setDescription('The number of entries in awcDot11DesiredBSSTable.')
awcDot11EnetEncapsulationDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("encap802dot1H", 1), ("encapRfc1042", 2))).clone('encapRfc1042')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11EnetEncapsulationDefault.setStatus('current')
if mibBuilder.loadTexts: awcDot11EnetEncapsulationDefault.setDescription('The Ethernet Encapsulation Transform type used within the BSS. Either IEEE 802.1H or RFC 1042 can be utilized. IEEE 802.1H provides exceptions for the Novel IPX and AARP protocols.')
awcDot11ForceReqFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11ForceReqFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: awcDot11ForceReqFirmwareVersion.setDescription('If true, the radio driver will only allow operation with the specific radio firmware revision with which it was originally tested. If false, the radio driver will allow operation with the radio firmware revision with which it was tested, or any later radio firmware revision.')
awcDot11BridgeSpacing = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11BridgeSpacing.setStatus('current')
if mibBuilder.loadTexts: awcDot11BridgeSpacing.setDescription('If this device is the root side of a Bridge configuration, this value is the distance in kilometers reported between this device and its farthest non-root Bridge.')
awcDot11DesiredSSIDMaxAssociatedSTA = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDMaxAssociatedSTA.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDMaxAssociatedSTA.setDescription('The maximum number of 802.11 Stations which may Associate with this access point through either the Broadcast SSID or through dot11DesiredSSID. If 0, the maximum number is limited only by the 802.11 standard and by any hardware or radio firmware limitations of the access point.')
awcDot11DesiredSSIDNumAssociatedSTA = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DesiredSSIDNumAssociatedSTA.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDNumAssociatedSTA.setDescription('The current number of 802.11 Stations which are Associated with this access point through either the Broadcast SSID or through dot11DesiredSSID.')
awcDot11AuxiliarySSIDLength = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDLength.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDLength.setDescription('The maximum number of entries in awcDot11AuxiliarySSIDTable. If awcDot11MultipleSSIDPerBSSImplemented is FALSE, awcDot11AuxiliarySSIDLength must be 0.')
awcDot11MultipleSSIDPerBSSImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11MultipleSSIDPerBSSImplemented.setStatus('current')
if mibBuilder.loadTexts: awcDot11MultipleSSIDPerBSSImplemented.setDescription('This attribute, when TRUE, indicates that the station implementation is capable of responding to 802.11 Probe Requests for SSIDs other than dot11DesiredSSID. The default value of this attribute is FALSE.')
awcDot11SymbolExtensionsImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11SymbolExtensionsImplemented.setStatus('current')
if mibBuilder.loadTexts: awcDot11SymbolExtensionsImplemented.setDescription('This attribute, when TRUE, indicates that the station implementation is capable of generating Symbol, Inc. proprietary elements in its Beacons and Probe Responses. These elements enable support for Symbol Voice-over-IP (VoIP) phones. The default value of this attribute is FALSE.')
awcDot11SymbolExtensionsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11SymbolExtensionsEnabled.setStatus('current')
if mibBuilder.loadTexts: awcDot11SymbolExtensionsEnabled.setDescription('Should the Radio generate Symbol, Inc. proprietary elements in its Beacons and Probe Responses in support of Symbol VoIP phones?')
awcDot11DesiredSSIDMicAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 16), AwcDot11MicAlgorithm().clone('micNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDMicAlgorithm.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDMicAlgorithm.setDescription('Auxiliary Message Integrity Check (MIC) calculated on WEP-encoded packets of stations Associated to this access point through either the Broadcast SSID or dot11DesiredSSID.')
awcDot11DesiredSSIDWEPKeyPermuteAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 17), AwcDot11WEPKeyPermuteAlgorithm().clone('wepPermuteNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDWEPKeyPermuteAlgorithm.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDWEPKeyPermuteAlgorithm.setDescription('Function through which the WEP encryption key is permuted between key renewal periods for stations Associated to this access point through either the Broadcast SSID or dot11DesiredSSID.')
awcDot11DesiredSSIDInfrastructureWGB = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 18), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDInfrastructureWGB.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDInfrastructureWGB.setDescription('When true, Workgroup Bridge-class devices Associated to this access point through either the Broadcast SSID or dot11DesiredSSID are provided the class of service which is provided to network infrastructure stations by their parent access point. This includes use of the 802.11 reliable multicast protocol (4-address packets for multicast). When false, Workgroup Bridge-class devices are provided the class of service which is provided to ordinary client stations.')
awcDot11DesiredSSIDDefaultPolId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 19), AwcPolId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDDefaultPolId.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDDefaultPolId.setDescription('Default Policy Group Identifier for stations Associated to this access point through either the Broadcast SSID or dot11DesiredSSID. A value of 0 indicates that no special policies are to be applied by default.')
awcDot11DesiredSSIDDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 20), AwcVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDDefaultVlanId.setDescription('Default VLAN Identifier for stations Associated to this access point through either the Broadcast SSID or dot11DesiredSSID. A value of 0 indicates that either VLANs are disabled or that the default VLAN is awcNativeVlanId.')
awcDot11DesiredSSIDEnableProxyMobileIP = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 21), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredSSIDEnableProxyMobileIP.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredSSIDEnableProxyMobileIP.setDescription('If true, Proxy Mobile IP is enabled for use by all stations Associated to this access point through either the Broadcast SSID or dot11DesiredSSID.')
awcDot11InfrastructureSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11InfrastructureSSID.setStatus('current')
if mibBuilder.loadTexts: awcDot11InfrastructureSSID.setDescription('Index of the SSID which all 802.11 infrastructure stations shall use for Association. If 0, an access point and its repeaters and other subordinate infrastructure devices will Associate through dot11DesiredSSID. If non-0, an access point and its subordinate infrastructure devices will Associate through the auxiliary SSID with awcDot11AuxSSIDIndex equal to awcDot11InfrastructureSSID.')
awcDot11QBSSElementImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11QBSSElementImplemented.setStatus('current')
if mibBuilder.loadTexts: awcDot11QBSSElementImplemented.setDescription('This attribute, when TRUE, indicates that the station implementation is capable of generating 802.11e QBSS elements in its Beacons and Probe Responses. These elements enable support for basic 802.11 Quality of Service. The default value of this attribute is FALSE.')
awcDot11QBSSElementEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 24), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11QBSSElementEnabled.setStatus('current')
if mibBuilder.loadTexts: awcDot11QBSSElementEnabled.setDescription('Should the Radio generate 802.11e QBSS elements in its Beacons and Probe Responses in support of 802.11 Quality of Service?')
awcDot11InfrastructureSSIDExclusive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11InfrastructureSSIDExclusive.setStatus('current')
if mibBuilder.loadTexts: awcDot11InfrastructureSSIDExclusive.setDescription('Should this access point restrict all infrastructure stations to associate only through the SSID specified by awcDot11InfrastructureSSID?')
awcDot11SendIGMPGeneralQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11SendIGMPGeneralQuery.setStatus('current')
if mibBuilder.loadTexts: awcDot11SendIGMPGeneralQuery.setDescription('Should this access point issue an IGMP General Query to all associated stations when they complete all required high-level authentication? Such an IGMP query can help configure multicast groups efficiently.')
awcDot11NonRootMobility = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mobile", 1), ("stationary", 2))).clone('stationary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11NonRootMobility.setStatus('current')
if mibBuilder.loadTexts: awcDot11NonRootMobility.setDescription('This object is used to determine if the radio should look for a better parent AP in heavy traffic condition when the awcDot11StationRole is roleClient(1) or roleRepeater(3). It will look for better parent if it is mobile(1) and will not look for better parent if it is stationary(2).')
awcDot11AuthenticationAlgorithmsTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 2), )
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsTable.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.6 and IEEE802dot11-MIB.')
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsTable.setDescription('This table contains attributes to configure authentication algorithm parameters for associations through the SSID defined by IEEE802dot11-MIB dot11DesiredSSID object. It defines attributes additional to those defined in the IEEE802dot11-MIB dot11AuthenticationAlgorithmsTable. An interface may support multiple authentication algorithms. This table has an expansion dependent relationship on the ifTable. For each entry in this table, there exists at least an entry in the ifTable of ifType ieee80211(71). This table uses the dot11AuthenticationAlgorithmsIndex of the dot11AuthenticationAlgorithmsTable defined in the IEEE802dot11-MIB as the expansion index. Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcDot11AuthenticationAlgorithmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11AuthenticationAlgorithmsIndex"))
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsEntry.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 8.2 and IEEE802dot11-MIB.')
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsEntry.setDescription('Each entry specifies Cisco Aironet product specific authentication algorithm configuration attributes of the dot11DesiredSSID on a radio interface.')
awcDot11AuthenticationAlgorithmsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)))
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticationAlgorithmsIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the Aironet Authentication Algorithms Table. This variable corresponds directly to the 802.11 dot11AuthenticationAlgorithmsIndex.')
awcDot11AuthenticationRequireEAP = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 2, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuthenticationRequireEAP.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticationRequireEAP.setDescription('If true, stations authenticating with the corresponding dot11AuthenticationAlgorithm must complete network-level EAP authentication before they will be unblocked. If false, stations authenticating with the corresponding dot11AuthenticationAlgorithm will be unblocked as soon as they complete the requirements of 802.11 authentication.')
awcDot11AuthenticationDefaultUcastAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 2, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuthenticationDefaultUcastAllowedToGoTo.setReference('RFC 1493, BRIDGE-MIB, dot1dStaticTable.')
if mibBuilder.loadTexts: awcDot11AuthenticationDefaultUcastAllowedToGoTo.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticationDefaultUcastAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined for a MAC address which is not already listed in dot1dStaticTable and authenticates with the corresponding dot11AuthenticationAlgorithm, are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.) The default value of this object is a string of ones of appropriate length.")
awcDot11WEPDefaultKeysTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 3), )
if mibBuilder.loadTexts: awcDot11WEPDefaultKeysTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeysTable.setDescription('Extension of dot11WEPDefaultKeysTable to allow for key lengths other than 40 bits.')
awcDot11WEPDefaultKeysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11WEPDefaultKeyIndex"))
if mibBuilder.loadTexts: awcDot11WEPDefaultKeysEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeysEntry.setDescription('An entry in the awcDot11WEPDefaultKeysTable table.')
awcDot11WEPDefaultKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the WEP Default Keys Table. The value of this variable is equal to the WEPDefaultKeyID + 1')
awcDot11WEPDefaultKeyLen = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyLen.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyLen.setDescription('Length in octets of awcDot11WEPDefaultKeyValue. If 0, the corresponding awcDot11WEPDefaultKeyValue is not configured.')
awcDot11WEPDefaultKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 3, 1, 3), WEPKeytype128()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyValue.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyValue.setDescription('A WEP default secret key value. The value is write-only (attempt to read will result in return of a zero-length string).')
awcDot11PrivacyTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5), )
if mibBuilder.loadTexts: awcDot11PrivacyTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11PrivacyTable.setDescription('Additional information about the WEP capabilities of the device. In tabular form to allow for multiple instances on an agent.')
awcDot11PrivacyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11PrivacyEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11PrivacyEntry.setDescription('An entry in the awcDot11PrivacyTable table.')
awcDot11WEPDefaultKeyMaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyMaxIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPDefaultKeyMaxIndex.setDescription('The maximum WEP Default Key index which the radio supports. Range 1..4, or 0 if the radio does not support WEP.')
awcDot11AllowEncrypted = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AllowEncrypted.setStatus('current')
if mibBuilder.loadTexts: awcDot11AllowEncrypted.setDescription('When this attribute is true, the STA shall indicate at the MAC service interface received MSDUs regardless of the setting of the WEP subfield of the Frame Control field, so long as the dot11ExcludeUnencrypted attribute is false. The default value of this attribute shall be false.')
awcDot11WEPKeyMaxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11WEPKeyMaxLen.setStatus('current')
if mibBuilder.loadTexts: awcDot11WEPKeyMaxLen.setDescription('The maximum WEP Key Length which the radio supports. Range 0..16, or 0 if the radio does not support WEP. Note that, even if the radio supports more than 13 octets of key value, the current 802.11 standard only makes use of the first 13 octets.')
awcDot11LEAPUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11LEAPUserName.setStatus('current')
if mibBuilder.loadTexts: awcDot11LEAPUserName.setDescription('User Name assigned to the system for use when authenticating with AAA servers.')
awcDot11LEAPPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11LEAPPassword.setStatus('current')
if mibBuilder.loadTexts: awcDot11LEAPPassword.setDescription('User Password (shared secret) assigned to the system for use when authenticating with AAA servers.')
awcDot11DesiredBSSTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 6), )
if mibBuilder.loadTexts: awcDot11DesiredBSSTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredBSSTable.setDescription('When the radio is not in roleAP, a list of preferred Access Points with which the radio should Associate. In tabular form to allow for multiple instances on an agent.')
awcDot11DesiredBSSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11DesiredBSSIndex"))
if mibBuilder.loadTexts: awcDot11DesiredBSSEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredBSSEntry.setDescription('An entry in the awcDot11DesiredBSSTable table.')
awcDot11DesiredBSSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DesiredBSSIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredBSSIndex.setDescription('The priority order in which Preferred Access Points should be probed. Lower indices are probed first.')
awcDot11DesiredBSS = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 6, 1, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DesiredBSS.setStatus('current')
if mibBuilder.loadTexts: awcDot11DesiredBSS.setDescription('The BSS identifier (MAC address) of the Access Point with which the radio should try to Associate, or 00:00:00:00:00:00 if the BSS identifier for this priority is unspecified.')
awcDot11AuxiliarySSIDTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7), )
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDTable.setDescription('When the radio is not in roleClient, a list of Stations which, when Associated to this system, shall always have the same AID.')
awcDot11AuxiliarySSIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11AuxSSIDIndex"))
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxiliarySSIDEntry.setDescription('An entry in the awcDot11AuxiliarySSIDTable table.')
awcDot11AuxSSIDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AuxSSIDIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDIndex.setDescription('Identifier of auxiliary SSIDs supported by the access point in addition to dot11DesiredSSID. Domain from 1 to awcDot11AuxiliarySSIDLength.')
awcDot11AuxSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSID.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSID.setDescription('This attribute reflects a Service Set ID recognized by the access point. The access point shall respond to Probe Requests specifying this SSID, but does not advertise this SSID in its Beacons.')
awcDot11AuxSSIDMaxAssociatedSTA = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDMaxAssociatedSTA.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDMaxAssociatedSTA.setDescription('The maximum number of 802.11 Stations which may Associate with this access point through awcDot11AuxSSID. If 0, the maximum number is limited only by the 802.11 standard and by any hardware or radio firmware limitations of the access point.')
awcDot11AuxSSIDNumAssociatedSTA = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AuxSSIDNumAssociatedSTA.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDNumAssociatedSTA.setDescription('The current number of 802.11 Stations which are Associated with this access point through awcDot11AuxSSID.')
awcDot11AuxSSIDDefaultPolId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 6), AwcPolId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDDefaultPolId.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDDefaultPolId.setDescription('Default Policy Group Identifier for stations Associated to this access point over awcDot11AuxSSID. A value of 0 indicates that no special policies are to be applied by default.')
awcDot11AuxSSIDDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 7), AwcVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDDefaultVlanId.setDescription('Default VLAN Identifier for stations Associated to this access point over awcDot11AuxSSID. A value of 0 indicates that either VLANs are disabled or that the default VLAN is awcNativeVlanId.')
awcDot11AuxSSIDEnableProxyMobileIP = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 7, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDEnableProxyMobileIP.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDEnableProxyMobileIP.setDescription('If true, Proxy Mobile IP is enabled for use by all stations Associated to this access point over awcDot11AuxSSID.')
awcDot11AuxSSIDAuthAlgTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8), )
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgTable.setDescription('This (conceptual) table of attributes shall be a set of all the Aironet-specific parameters for each authentication algorithm supported by the station for each auxiliary SSID listed in awcDot11AuxiliarySSIDTable.')
awcDot11AuxSSIDAuthAlgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11AuxSSIDIndex"), (0, "AWCVX-MIB", "awcDot11AuxSSIDAuthAlgIndex"))
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgEntry.setDescription('An Entry (conceptual row) in the Aironet Auxiliary SSID Authentication Algorithms Table. ifIndex - Each 802.11 interface is represented by an ifEntry. Interface tables in this MIB module are indexed by ifIndex.')
awcDot11AuxSSIDAuthAlgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)))
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the Aironet Auxiliary SSID Authentication Algorithms Table. This variable corresponds directly to the 802.11 dot11AuthenticationAlgorithmsIndex.')
awcDot11AuxSSIDAuthAlgEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgEnable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgEnable.setDescription('If true, stations may authenticate to the SSID specified by awcDot11AuxSSIDIndex with the algorithm corresponding to dot11AuthenticationAlgorithmsIndex.')
awcDot11AuxSSIDAuthAlgRequireEAP = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgRequireEAP.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgRequireEAP.setDescription('If true, stations authenticating to the SSID specified by awcDot11AuxSSIDIndex with the corresponding dot11AuthenticationAlgorithm must complete network-level EAP authentication before they will be unblocked. If false, stations authenticating with the corresponding dot11AuthenticationAlgorithm will be unblocked as soon as they complete the requirements of 802.11 authentication.')
awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 8, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined for a MAC address which is not already listed in dot1dStaticTable and authenticates to the SSID specified by awcDot11AuxSSIDIndex with the corresponding dot11AuthenticationAlgorithm, are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.) The default value of this object is a string of ones of appropriate length.")
awcDot11AssignedAIDTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 9), )
if mibBuilder.loadTexts: awcDot11AssignedAIDTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AssignedAIDTable.setDescription("When the radio is not functioning as a client station (i.e., awcDot11StationRole is not 'roleClient'), this is the list of AIDs which this agent will assign to the clients associating with it. An AID is assigned if the corresponding MAC address matches that of the client. This table has an expansion dependent relationship on the ifTable. For each entry in this table, there exists at least an entry in the ifTable of ifType ieee80211(71).")
awcDot11AssignedAIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11AssignedAID"))
if mibBuilder.loadTexts: awcDot11AssignedAIDEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11AssignedAIDEntry.setDescription('An entry in the awcDot11AssignedAIDTable table.')
awcDot11AssignedAID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AssignedAID.setStatus('current')
if mibBuilder.loadTexts: awcDot11AssignedAID.setDescription('An AID which shall be reserved for the exclusive use of a single Station.')
awcDot11AssignedSTA = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 9, 1, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AssignedSTA.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.2.')
if mibBuilder.loadTexts: awcDot11AssignedSTA.setStatus('current')
if mibBuilder.loadTexts: awcDot11AssignedSTA.setDescription('The Station (MAC address) which, when Associated to this system, shall always be assigned awcDot11AssignedAID as its 802.11 AID.')
awcDot11AccessPointCountersTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10), )
if mibBuilder.loadTexts: awcDot11AccessPointCountersTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11AccessPointCountersTable.setDescription('This table includes radio statistics collected by the IEEE 802.11 radio interface. This table has a sparse dependent relationship on the ifTable. For each entry in this table, there exists an entry in the ifTable of ifType ieee80211(71).')
awcDot11AccessPointCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11AccessPointCountersEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11AccessPointCountersEntry.setDescription('Each entry contains counters of frame transmissions and client associations for a radio interface.')
awcDot11AssociatedStationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AssociatedStationCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.')
if mibBuilder.loadTexts: awcDot11AssociatedStationCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11AssociatedStationCount.setDescription('Total number of successful 802.11 Association Request operations to this radio of this access point since system startup.')
awcDot11AuthenticatedStationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11AuthenticatedStationCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.')
if mibBuilder.loadTexts: awcDot11AuthenticatedStationCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticatedStationCount.setDescription('Total number of successful 802.11 MAC-level Authentication operations to this radio of this access point since system startup. ')
awcDot11ReassociatedStationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11ReassociatedStationCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.')
if mibBuilder.loadTexts: awcDot11ReassociatedStationCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11ReassociatedStationCount.setDescription('Total number of successful 802.11 Reassociation Request operations to this radio of this access point since system startup.')
awcDot11RoamedStationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11RoamedStationCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11RoamedStationCount.setDescription('Total number of times that clients which had successfully (re)associated with this access point successfully reassociated with another access point since system startup.')
awcDot11DeauthenticateCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DeauthenticateCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.')
if mibBuilder.loadTexts: awcDot11DeauthenticateCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11DeauthenticateCount.setDescription('Total number of Deauthenticate frames sent over this radio of this access point since system startup.')
awcDot11DisassociateCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DisassociateCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 5.7.')
if mibBuilder.loadTexts: awcDot11DisassociateCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11DisassociateCount.setDescription('Total number of Disassociate frames sent over this radio of this access point since system startup.')
awcDot11EncapPktsMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11EncapPktsMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11EncapPktsMMH.setDescription('Total number of packets for which the a MIC has been requested to be calculated with the MMH algorithm before being submitted for transmission over this radio of this access point since system startup.')
awcDot11DecapPktsMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DecapPktsMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11DecapPktsMMH.setDescription('Total number of packets received over this radio of this access point since system startup and for which a MIC has been requested to be validated with the MMH algorithm.')
awcDot11EncapErrorsMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11EncapErrorsMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11EncapErrorsMMH.setDescription('Total number of packets which have failed MIC calculation with the MMH algorithm before being submitted for transmission over this radio of this access point since system startup.')
awcDot11DecapErrorsMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DecapErrorsMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11DecapErrorsMMH.setDescription('Total number of packets received over this radio of this access point since system startup which have failed MIC validation with the MMH algorithm.')
awcDot11DecapExistsMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DecapExistsMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11DecapExistsMMH.setDescription('Total number of packets received over this radio of this access point since system startup which have failed MIC validation with the MMH algorithm specifically due to sequence number and duplicate packet errors.')
awcDot11DecapAccessMMH = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 1, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11DecapAccessMMH.setStatus('current')
if mibBuilder.loadTexts: awcDot11DecapAccessMMH.setDescription('Total number of packets received over this radio of this access point since system startup which have failed MIC validation with the MMH algorithm specifically due to cryptographic key-mismatch errors.')
awcDot11mac = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6, 2))
awcDot11CountersTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 2), )
if mibBuilder.loadTexts: awcDot11CountersTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11CountersTable.setDescription('This table contains MAC statistics on each of IEEE 802.11 interface. This table has a sparse dependent relationship on the ifTable. For each entry in this table, there exists an entry in the ifTable of ifType ieee80211(71).')
awcDot11CountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11CountersEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11CountersEntry.setDescription('Each entry contains counters of frame transmissions for a radio interface.')
awcDot11TxDeferEnergyCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TxDeferEnergyCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11TxDeferEnergyCount.setDescription('Total number of frames deferred transmission due to energy detect since system startup.')
awcDot11RxMacCrcErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11RxMacCrcErrorCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11RxMacCrcErrorCount.setDescription('Total number of frames received with MAC CRC errors since system startup.')
awcDot11SsidMismatchCount = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11SsidMismatchCount.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, IEEE802dot11-MIB.')
if mibBuilder.loadTexts: awcDot11SsidMismatchCount.setStatus('current')
if mibBuilder.loadTexts: awcDot11SsidMismatchCount.setDescription('Total number of Beacon or Probe Response frames received for which the SSID does not match dot11DesiredSSID since system startup.')
awcDot11QoSTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 4), )
if mibBuilder.loadTexts: awcDot11QoSTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11QoSTable.setDescription('This (conceptual) table of attributes shall be a set of parameters for each traffic category (i.e. 802.1D priority) of packet passed over the radio.')
awcDot11QoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11QoSCoS"))
if mibBuilder.loadTexts: awcDot11QoSEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11QoSEntry.setDescription('An Entry (conceptual row) in the Aironet Quality of Service Table. ifIndex - Each 802.11 interface is represented by an ifEntry. Interface tables in this MIB module are indexed by ifIndex.')
awcDot11QoSCoS = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: awcDot11QoSCoS.setStatus('current')
if mibBuilder.loadTexts: awcDot11QoSCoS.setDescription('The auxiliary variable used to identify instances of the columnar objects in the Aironet Quality of Service Table. This variable corresponds directly to the 802.1D traffic category ID, plus 1.')
awcDot11QoSCWmin = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11QoSCWmin.setStatus('current')
if mibBuilder.loadTexts: awcDot11QoSCWmin.setDescription('802.11 CWmin of the traffic category. The value of this OID must be one of the set 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, or 1023, and must be less than or equal to awcDot11QoSCWmax.')
awcDot11QoSCWmax = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11QoSCWmax.setStatus('current')
if mibBuilder.loadTexts: awcDot11QoSCWmax.setDescription('802.11 CWmax of the traffic category. The value of this OID must be one of the set 1, 3, 7, 15, 31, 63, 127, 255, 511, or 1023, and must be greater than or equal to awcDot11QoSCWmin.')
awcDot11res = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6, 3))
awcDot11resAttribute = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6, 3, 1))
awcDot11ResourceInfoTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 3, 1, 2), )
if mibBuilder.loadTexts: awcDot11ResourceInfoTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11ResourceInfoTable.setDescription('Resource Info Table attributes. In tabular form to allow for multiple instances on an agent.')
awcDot11ResourceInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 3, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11ResourceInfoEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11ResourceInfoEntry.setDescription('An entry in the awcDot11ResourceInfoTable table.')
awcDot11FirmwareBootstrapVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 3, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11FirmwareBootstrapVersion.setStatus('current')
if mibBuilder.loadTexts: awcDot11FirmwareBootstrapVersion.setDescription('The firmware version of the radio boot block. Max. string length is 128 octets.')
awcDot11phy = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 6, 4))
awcDot11PhyOperationTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1), )
if mibBuilder.loadTexts: awcDot11PhyOperationTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyOperationTable.setDescription('awcDot11PhyOperationTable attributes. In tabular form to allow for multiple instances on an agent.')
awcDot11PhyOperationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11PhyOperationEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyOperationEntry.setDescription('An entry in the awcDot11PhyOperationTable table.')
awcDot11CurrentCarrierSet = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("usa", 0), ("europe", 1), ("japan", 2), ("spain", 3), ("france", 4), ("belgium", 5), ("israel", 6), ("canada", 7), ("australia", 8), ("japanWide", 9), ("usa5GHz", 11), ("europe5GHz", 12), ("japan5GHz", 13), ("singapore5GHz", 14), ("taiwan5GHz", 15), ("china", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11CurrentCarrierSet.setStatus('current')
if mibBuilder.loadTexts: awcDot11CurrentCarrierSet.setDescription('The carrier set of the device. The Carrier Set implies a Regulatory Domain, but geographic-specific restrictions within a Regulatory Domain may necessitate several Carrier Sets within the Regulatory Domain.')
awcDot11ModulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("mok", 2))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11ModulationType.setStatus('current')
if mibBuilder.loadTexts: awcDot11ModulationType.setDescription('The RF modulation of the radio.')
awcDot11PreambleType = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("long", 1), ("short", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11PreambleType.setStatus('current')
if mibBuilder.loadTexts: awcDot11PreambleType.setDescription('The current radio preamble type in use by the Station. Possible values: 1 = Use long preambles whenever possible. 2 = Use only short preambles.')
awcDot11PHYType = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11))).clone(namedValues=NamedValues(("fhss", 1), ("dsss", 2), ("irbaseband", 3), ("dsssDot11A", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11PHYType.setStatus('current')
if mibBuilder.loadTexts: awcDot11PHYType.setDescription('This is an 8-bit integer value that identifies the PHY type supported by the attached PLCP and PMD. Currently defined values and their corresponding PHY types are: FHSS 2.4 GHz = 01 , DSSS 2.4 GHz = 02, IR Baseband = 03, DSSS 5.0 GHz = 11')
awcDot11PhyFHSSTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 4), )
if mibBuilder.loadTexts: awcDot11PhyFHSSTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyFHSSTable.setDescription('awcDot11PhyFHSSTable attributes. In tabular form to allow for multiple instances on an agent.')
awcDot11PhyFHSSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11PhyFHSSEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyFHSSEntry.setDescription('An entry in the awcDot11PhyFHSSTable table.')
awcDot11Compatible3100 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 4, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11Compatible3100.setStatus('current')
if mibBuilder.loadTexts: awcDot11Compatible3100.setDescription('Boolean on whether or not the Station should use 1Mb/sec management frames to be compatible with Aironet 3100 series radios.')
awcDot11PhyDSSSTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5), )
if mibBuilder.loadTexts: awcDot11PhyDSSSTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyDSSSTable.setDescription('awcDot11PhyDSSSTable attributes. In tabular form to allow for multiple instances on an agent.')
awcDot11PhyDSSSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: awcDot11PhyDSSSEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11PhyDSSSEntry.setDescription('An entry in the awcDot11PhyDSSSTable table.')
awcDot11Compatible4500 = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11Compatible4500.setStatus('current')
if mibBuilder.loadTexts: awcDot11Compatible4500.setDescription('Boolean on whether or not the Station should use 2Mb/sec management frames to be compatible with Aironet 4500 series radios.')
awcDot11ChannelAutoImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11ChannelAutoImplemented.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChannelAutoImplemented.setDescription('If true, the radio can, when awcDot11StationRole is roleAP, scan for other BSS activity on all channels available in the current awcDot11CurrentCarrierSet before establishing its own BSS. If false, the radio can only establish its BSS on dot11CurrentChannel.')
awcDot11ChannelAutoEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11ChannelAutoEnabled.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChannelAutoEnabled.setDescription('If true and awcDot11StationRole is roleAP, the radio will scan for other BSS activity on all channels available in the current awcDot11CurrentCarrierSet before establishing its own BSS. After the scan, this station will establish its own BSS on the channel it considers to have the least probability of congestion. If false, this station always establishes its BSS on dot11CurrentChannel.')
awcDot11CurrentChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11CurrentChannel.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, IEEE802dot11-MIB.')
if mibBuilder.loadTexts: awcDot11CurrentChannel.setStatus('current')
if mibBuilder.loadTexts: awcDot11CurrentChannel.setDescription('The current operating frequency channel of the DSSS PHY, as selected either by selective scanning or via dot11CurrentChannel. Valid channel numbers are as defined in 15.4.6.2')
awcDot11SupportedDataRatesPrivacyTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 11), )
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyTable.setDescription('For each transmit and receive bit rate, whether or not the radio can support WEP encryption at that rate.')
awcDot11SupportedDataRatesPrivacyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11SupportedDataRatesPrivacyIndex"))
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyEntry.setDescription('An Entry (conceptual row) in the awcDot11SupportedDataRatesPrivacy Table. ifIndex - Each 802.11 interface is represented by an ifEntry. Interface tables in this MIB module are indexed by ifIndex.')
awcDot11SupportedDataRatesPrivacyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyIndex.setStatus('current')
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyIndex.setDescription('Index object which identifies which data rate to access. Range is 1..8.')
awcDot11SupportedDataRatesPrivacyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyValue.setStatus('current')
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyValue.setDescription('The receive or transmit bit rates supported by the PLCP and PMD, represented by a count from X02-X7f, corresponding to data rates in increments of 500Kb/s from 1 Mb/s to 63.5 Mb/s.')
awcDot11SupportedDataRatesPrivacyImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 11, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyImplemented.setStatus('current')
if mibBuilder.loadTexts: awcDot11SupportedDataRatesPrivacyImplemented.setDescription('Whether or not WEP encryption is supported by the radio for both Transmit and Receive operations at the corresponding bit rate specified by awcDot11SupportedDataRatesPrivacyValue.')
awcDot11ChanSelectTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 12), )
if mibBuilder.loadTexts: awcDot11ChanSelectTable.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 15.4.6.2.')
if mibBuilder.loadTexts: awcDot11ChanSelectTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChanSelectTable.setDescription('This table specifies for each 802.11 channel, whether the scanning process controlled by the awcDot11ChannelAutoEnabled can select a particular channel for use. This table has an expansion dependent relationship on the ifTable. For each entry in this table, there exists at least an entry in the ifTable of ifType ieee80211(71). Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcDot11ChanSelectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "AWCVX-MIB", "awcDot11ChanSelectChannel"))
if mibBuilder.loadTexts: awcDot11ChanSelectEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChanSelectEntry.setDescription('Each entry specifies if a particular radio channel is enabled on a radio interface.')
awcDot11ChanSelectChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11ChanSelectChannel.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, section 15.4.6.2.')
if mibBuilder.loadTexts: awcDot11ChanSelectChannel.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChanSelectChannel.setDescription('802.11 channel which is a candidate for low-occupancy scanning.')
awcDot11ChanSelectEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 6, 4, 12, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11ChanSelectEnable.setReference('IEEE Std 802.11-Jan 14 1999, Wireless LAN Medium Access Control and Physical Layer Specifications, LAN MAN Standards Committee of the IEEE Computer Society, IEEE802dot11-MIB.')
if mibBuilder.loadTexts: awcDot11ChanSelectEnable.setStatus('current')
if mibBuilder.loadTexts: awcDot11ChanSelectEnable.setDescription('If true, awcDot11ChanSelectChannel is available for the system to use as its awcDot11CurrentChannel after scanning for channel occupancy. If false, awcDot11ChanSelectChannel is not available.')
userMgrConfigTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 7, 1), )
if mibBuilder.loadTexts: userMgrConfigTable.setStatus('current')
if mibBuilder.loadTexts: userMgrConfigTable.setDescription('System User attributes.')
userMgrConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1), ).setIndexNames((0, "AWCVX-MIB", "userMgrUserIndex"))
if mibBuilder.loadTexts: userMgrConfigEntry.setStatus('current')
if mibBuilder.loadTexts: userMgrConfigEntry.setDescription('An entry in the user manager table.')
userMgrUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: userMgrUserIndex.setStatus('current')
if mibBuilder.loadTexts: userMgrUserIndex.setDescription('The index of the user.')
userMgrUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: userMgrUserName.setStatus('current')
if mibBuilder.loadTexts: userMgrUserName.setDescription('The name of the user. This should be unique across all users. Max. string length is 32 octets.')
userMgrPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: userMgrPassword.setStatus('current')
if mibBuilder.loadTexts: userMgrPassword.setDescription('The SHA-1 hashed password of the user in the user manager. When a plaintext password is written, it is automatically replaced by the SHA-1 Secure Hash of that plaintext, prefixed by a 4-octet magic cookie. Max. string length is 24 octets.')
userMgrCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: userMgrCapabilities.setStatus('current')
if mibBuilder.loadTexts: userMgrCapabilities.setDescription('Bitmask of the capabilities of the user. The value may be any combination (sum) of the following capability values: 0 = none 1 = Administrator 2 = Write 4 = Firmware Update 8 = Identity Update 16 = SNMP Community')
userMgrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 7, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: userMgrStatus.setStatus('current')
if mibBuilder.loadTexts: userMgrStatus.setDescription('Row status of the user. Allows deletion via SNMP.')
enableUserMgr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 7, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableUserMgr.setStatus('current')
if mibBuilder.loadTexts: enableUserMgr.setDescription('If true, the User Manager subsystem is active. Web page, console, and SNMP access is restricted in accordance with userMgrCapabilities. If false, all users have full access to the system. ')
allowBrowseWithoutLogin = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 7, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowBrowseWithoutLogin.setStatus('current')
if mibBuilder.loadTexts: allowBrowseWithoutLogin.setDescription('If true, the HTTP user interface to read-only web pages can be accessed without passing HTTP authentication. If false, any HTTP access requires the user to pass HTTP authentication.')
protectLegalPage = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 7, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protectLegalPage.setStatus('current')
if mibBuilder.loadTexts: protectLegalPage.setDescription('Should the legal credits page be protected or not.')
defaultWebRoot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('mfs0:/StdUI/')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultWebRoot.setStatus('current')
if mibBuilder.loadTexts: defaultWebRoot.setDescription("File directory which contains the system's web site root file index.shm. Max. string length is 128 octets.")
defaultHelpRoot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('http://www.cisco.com/warp/public/779/smbiz/prodconfig/help/eag/air/ap3xx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultHelpRoot.setStatus('current')
if mibBuilder.loadTexts: defaultHelpRoot.setDescription('URL identifying the directory in which help pages for the system are located. This URL is prefixed to all help page links. Max. string length is 128 octets.')
getWebUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: getWebUI.setStatus('current')
if mibBuilder.loadTexts: getWebUI.setDescription('The name of an auxilliary set of HTML user interface files to be loaded at system boot time from defaultFileServer. Archive formats accepted include .tar and .tar.gz. Max. string length is 128 octets.')
cmdInvokeGetWebUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 4), AwcInvokeCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdInvokeGetWebUI.setStatus('current')
if mibBuilder.loadTexts: cmdInvokeGetWebUI.setDescription('Initiate loading of the getWebUI file. Commands recognized: start.')
cmdStatusGetWebUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdStatusGetWebUI.setStatus('current')
if mibBuilder.loadTexts: cmdStatusGetWebUI.setDescription('Status of the most recent command to load the auxilliary web User Interface pages. Possible values: 0 = Operation completed successfully (or has not taken place). 2 = File not found on the file server. 12 = Insufficient memory to load all files. 20 = Identifier encountered while decoding is an ordinary file, not a directory. 22 = No file specified, or invalid file format. 35 = File format is not supported. 68 = Operation is still in progress. Poll again later. 72 = Operation was started, but later was canceled.')
awcHttpdPort = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcHttpdPort.setStatus('current')
if mibBuilder.loadTexts: awcHttpdPort.setDescription('IP port number over which to perform HTTP operations.')
awcConsoleAutoApply = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 8, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcConsoleAutoApply.setStatus('current')
if mibBuilder.loadTexts: awcConsoleAutoApply.setDescription("The current state of 'auto apply' mode on the console browser.")
resolverDomain = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 9, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resolverDomain.setStatus('current')
if mibBuilder.loadTexts: resolverDomain.setDescription('The name of the resolver domain currently in use by the system. Max. string length of 128 octets.')
resolverDomainSuffix = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 9, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resolverDomainSuffix.setStatus('current')
if mibBuilder.loadTexts: resolverDomainSuffix.setDescription('The suffix name of the resolver domain. Used to abbreviate displayed host names. Max. string length is 128 octets.')
resolverDomainServerTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 9, 3), )
if mibBuilder.loadTexts: resolverDomainServerTable.setStatus('current')
if mibBuilder.loadTexts: resolverDomainServerTable.setDescription('Table of DNS Name Servers currently in use by the system.')
resolverDomainServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 9, 3, 1), ).setIndexNames((0, "AWCVX-MIB", "resolverDomainServerPriority"))
if mibBuilder.loadTexts: resolverDomainServerEntry.setStatus('current')
if mibBuilder.loadTexts: resolverDomainServerEntry.setDescription('An entry in resolverDomainServerTable.')
resolverDomainServerPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resolverDomainServerPriority.setStatus('current')
if mibBuilder.loadTexts: resolverDomainServerPriority.setDescription('The priority order in which a domain name server is queried.')
resolverDomainServer = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 9, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resolverDomainServer.setStatus('current')
if mibBuilder.loadTexts: resolverDomainServer.setDescription('The IP Address of a domain name server currently in use by the system.')
defaultResolverDomain = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 9, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultResolverDomain.setStatus('current')
if mibBuilder.loadTexts: defaultResolverDomain.setDescription('The name of the resolver domain to be used by the system unless overridden by a BOOTP or DHCP server. Max. string length of 128 octets.')
defaultResolverDomainServerTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 9, 5), )
if mibBuilder.loadTexts: defaultResolverDomainServerTable.setStatus('current')
if mibBuilder.loadTexts: defaultResolverDomainServerTable.setDescription('Table of DNS Name Servers to be used by the system unless overridden by a BOOTP or DHCP server.')
defaultResolverDomainServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 9, 5, 1), ).setIndexNames((0, "AWCVX-MIB", "defaultResolverDomainServerPriority"))
if mibBuilder.loadTexts: defaultResolverDomainServerEntry.setStatus('current')
if mibBuilder.loadTexts: defaultResolverDomainServerEntry.setDescription('An entry in defaultResolverDomainServerTable.')
defaultResolverDomainServerPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 9, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: defaultResolverDomainServerPriority.setStatus('current')
if mibBuilder.loadTexts: defaultResolverDomainServerPriority.setDescription('The priority order in which a domain name server is queried.')
defaultResolverDomainServer = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 9, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultResolverDomainServer.setStatus('current')
if mibBuilder.loadTexts: defaultResolverDomainServer.setDescription('The IP Address of a domain name server to be used by the system unless overridden by a BOOTP or DHCP server.')
snmpTrapDest = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 10, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapDest.setStatus('current')
if mibBuilder.loadTexts: snmpTrapDest.setDescription('The destination of an SNMP trap. This may be any DNS-recognizable IP address. Max. string length is 128 octets.')
snmpTrapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 10, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCommunity.setStatus('current')
if mibBuilder.loadTexts: snmpTrapCommunity.setDescription('The community name of the trap. Max. string length is 128 octets.')
defaultSntpServer = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 11, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultSntpServer.setStatus('current')
if mibBuilder.loadTexts: defaultSntpServer.setDescription('The name of the SNTP server to be use by the system, unless overridden by a BOOTP or DHCP server. Max. string length is 128 octets.')
sntpServer = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 11, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sntpServer.setStatus('current')
if mibBuilder.loadTexts: sntpServer.setDescription('The name of the SNTP server currently in use by the system. Max. string length is 128 octets.')
awcFtStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 12, 1))
awcFtMcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtMcastAddr.setStatus('current')
if mibBuilder.loadTexts: awcFtMcastAddr.setDescription('Count of multicast addresses observed by the system.')
awcFtDsHost = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtDsHost.setStatus('current')
if mibBuilder.loadTexts: awcFtDsHost.setDescription('Count of DS (infrastructure) host addresses observed by the system over its own DS network interface (Ethernet).')
awcFtBridgeHost = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtBridgeHost.setStatus('current')
if mibBuilder.loadTexts: awcFtBridgeHost.setDescription('Count of DS (infrastructure) host addresses observed by the system on the remote side of a bridge.')
awcFtClientSTA = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtClientSTA.setStatus('current')
if mibBuilder.loadTexts: awcFtClientSTA.setDescription('Count of Client Station addresses observed by the system.')
awcFtClientSTASelf = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtClientSTASelf.setStatus('current')
if mibBuilder.loadTexts: awcFtClientSTASelf.setDescription('Count of Client Stations which are Associated to the system.')
awcFtBridge = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtBridge.setStatus('current')
if mibBuilder.loadTexts: awcFtBridge.setDescription('Count of non-root Bridge addresses observed by the system.')
awcFtBridgeSelf = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtBridgeSelf.setStatus('current')
if mibBuilder.loadTexts: awcFtBridgeSelf.setDescription('Count of non-root Bridges which are Associated to the system.')
awcFtRepeater = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtRepeater.setStatus('current')
if mibBuilder.loadTexts: awcFtRepeater.setDescription('Count of Repeater addresses observed by the system.')
awcFtRepeaterSelf = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtRepeaterSelf.setStatus('current')
if mibBuilder.loadTexts: awcFtRepeaterSelf.setDescription('Count of Repeater devices which are Associated to the system.')
awcFtAccessPoint = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtAccessPoint.setStatus('current')
if mibBuilder.loadTexts: awcFtAccessPoint.setDescription('Count of Access Point addresses observed by the system.')
awcFtBridgeRoot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcFtBridgeRoot.setStatus('current')
if mibBuilder.loadTexts: awcFtBridgeRoot.setDescription('Count of Root Bridge addresses observed by the system.')
awcFtConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 12, 2))
awcFtMaxNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 1), Integer32().clone(8192)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtMaxNumEntries.setStatus('current')
if mibBuilder.loadTexts: awcFtMaxNumEntries.setDescription('The maximum number of entries in the forwarding table. Must be a power of 2 from 1024 to 65536. The number of entries controls the size of the forwarding table and the hash algorithm used by the forwarding table. Changing the number of entries requires a system reboot.')
awcFtTimeoutSecUnknown = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 2), Unsigned32().clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecUnknown.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecUnknown.setDescription('The default number of seconds an Entry with awcTpFdbClassID=unknown will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecMcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 3), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecMcastAddr.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecMcastAddr.setDescription('The default number of seconds an Entry with awcTpFdbClassID=multicast will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecDsHost = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 4), Unsigned32().clone(1800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecDsHost.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecDsHost.setDescription('The default number of seconds an Entry with awcTpFdbClassID=dsHost will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecBridgeHost = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 5), Unsigned32().clone(1800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecBridgeHost.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecBridgeHost.setDescription('The default number of seconds an Entry with awcTpFdbClassID=bridgeHost will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecClientSTA = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 6), Unsigned32().clone(1800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecClientSTA.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecClientSTA.setDescription('The default number of seconds an Entry with awcTpFdbClassID=clientStation will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecBridge = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 7), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecBridge.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecBridge.setDescription('The default number of seconds an Entry with awcTpFdbClassID=bridge will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecRepeater = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 8), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecRepeater.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecRepeater.setDescription('The default number of seconds an Entry with awcTpFdbClassID=repeater will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecAccessPoint = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 9), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecAccessPoint.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecAccessPoint.setDescription('The default number of seconds an Entry with awcTpFdbClassID=accessPoint will remain in the Forwarding Table before being staled-out.')
awcFtTimeoutSecBridgeRoot = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 10), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtTimeoutSecBridgeRoot.setStatus('current')
if mibBuilder.loadTexts: awcFtTimeoutSecBridgeRoot.setDescription('The default number of seconds an Entry with awcTpFdbClassID=bridgeRoot will remain in the Forwarding Table before being staled-out.')
awcFtEnableAwcTpFdbTable = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtEnableAwcTpFdbTable.setStatus('current')
if mibBuilder.loadTexts: awcFtEnableAwcTpFdbTable.setDescription('If true, the system will populate the awcTpFdbEntry MIB for all forwarding table entries. This improves management statistics. If false, the system will not populate the awcTpFdbEntry MIB for any forwarding table entries. This improves speed and memory utilization.')
awcFtEnableMacAuthServer = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtEnableMacAuthServer.setStatus('current')
if mibBuilder.loadTexts: awcFtEnableMacAuthServer.setDescription('If true, the system will contact a AAA server for retrieving dot1dStaticTable information for new forwarding table entries if a dot1dStaticTable entry does not already exist for the host address.')
awcFtRogueApAlertTimeout = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtRogueApAlertTimeout.setStatus('current')
if mibBuilder.loadTexts: awcFtRogueApAlertTimeout.setDescription('The minimum number of minutes after a Possible Rogue status is reported about a device before another Possible Rogue status report is issued by this system about the same device.')
awcFtEnableMacOrEapAuth = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtEnableMacOrEapAuth.setStatus('current')
if mibBuilder.loadTexts: awcFtEnableMacOrEapAuth.setDescription('If true, the system grants full access to those clients which have successfully completed either MAC or EAP authentication.')
awcFtDot1dTpFdbTableEnable = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 15), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtDot1dTpFdbTableEnable.setStatus('current')
if mibBuilder.loadTexts: awcFtDot1dTpFdbTableEnable.setDescription('If true, the system will populate the dot1dTpFdbEntry MIB for all forwarding table entries. This improves management statistics. If false, the system will not populate the dot1dTpFdbEntry MIB for any forwarding table entries. This improves speed and memory utilization.')
awcFtEnableMcastMapping = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 12, 2, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcFtEnableMcastMapping.setStatus('current')
if mibBuilder.loadTexts: awcFtEnableMcastMapping.setDescription('If true, the system will map multicast forwarding table entries to the broadcast entry. This improves speed and memory utilization. If false, the system will create an entry for each unique multicast address. This improves management statistics and allows filtering of specific multicast addresses.')
class AwcTpFdbClassID(TextualConvention, Integer32):
    description = 'Description of the general 802.11 classification of a host.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("unknown", 1), ("multicast", 2), ("dsHost", 3), ("bridgeHost", 4), ("clientStation", 5), ("bridge", 6), ("repeater", 7), ("accessPoint", 8), ("bridgeRoot", 9))

awcTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 12, 3), )
if mibBuilder.loadTexts: awcTpFdbTable.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbTable.setDescription('A table that contains information about entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function for maintaining statistics about each entry.')
awcTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1), ).setIndexNames((0, "AWCVX-MIB", "awcTpFdbAddress"))
if mibBuilder.loadTexts: awcTpFdbEntry.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbEntry.setDescription('Information about a specific MAC address for which the bridge has some forwarding and/or filtering information.')
awcTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAddress.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAddress.setDescription('A MAC address for which the bridge has forwarding and/or filtering information.')
awcTpFdbClassID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 2), AwcTpFdbClassID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbClassID.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbClassID.setDescription('Observed general 802.11 classification of the entry.')
awcTpFdbSrcPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbSrcPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbSrcPktsImmed.setDescription('Number of observed packets for which this entry was the source.')
awcTpFdbSrcOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbSrcOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbSrcOctetsImmed.setDescription('Number of observed octets for which this entry was the source.')
awcTpFdbSrcErrorPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbSrcErrorPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbSrcErrorPktsImmed.setDescription('Number of observed error packets for which this entry was the source.')
awcTpFdbSrcErrorOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbSrcErrorOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbSrcErrorOctetsImmed.setDescription('Number of observed error octets for which this entry was the source.')
awcTpFdbDestPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDestPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDestPktsImmed.setDescription('Number of observed packets for which this entry was the destination.')
awcTpFdbDestOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDestOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDestOctetsImmed.setDescription('Number of observed octets for which this entry was the destination.')
awcTpFdbDestErrorPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDestErrorPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDestErrorPktsImmed.setDescription('Number of observed error packets for which this entry was the destination. This count includes awcTpFdbDestMaxRetryErrorsImmed.')
awcTpFdbDestErrorOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDestErrorOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDestErrorOctetsImmed.setDescription('Number of observed error octets for which this entry was the destination.')
awcTpFdbDestMaxRetryErrorsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDestMaxRetryErrorsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDestMaxRetryErrorsImmed.setDescription('Number of observed max-retry error packets for which this entry was the destination.')
awcTpFdbIPv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 3, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbIPv4Addr.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbIPv4Addr.setDescription('Observed IPv4 network address of the entry.')
class AwcDdpProdDevID(TextualConvention, Integer32):
    description = 'Aironet DDP Product Device ID of a host.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(74, 76, 77, 78, 84, 85, 86, 101, 102, 104, 109, 110, 111, 112, 113, 117, 120, 121, 122, 123, 124, 127, 128, 240, 241, 253, 255))
    namedValues = NamedValues(("tokenRingAP", 74), ("ethernetAP", 76), ("ethernetBridge", 77), ("tokenRingBridge", 78), ("pc3000Client", 84), ("serialUC", 85), ("ethernetUC", 86), ("pc3500Client", 101), ("pc4500Client", 102), ("generic80211Client", 104), ("pc4800Client", 109), ("pc3100Client", 110), ("mc", 111), ("ethernetClient", 112), ("pc2500Client", 113), ("pc4800bClient", 117), ("euc", 120), ("homeAP", 121), ("eucNoDiversity", 122), ("emcNoDiversity", 123), ("emc", 124), ("series350Client", 127), ("series370Client", 128), ("multicast", 240), ("unknown", 241), ("tokenRingHost", 253), ("ethernetHost", 255))

class AwcDdpRadioDevID(TextualConvention, Integer32):
    description = 'Aironet DDP Radio Device ID of a host.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 12, 13, 34, 35))
    namedValues = NamedValues(("unknown", 0), ("tma900", 1), ("tma2400", 2), ("pc3500", 3), ("pc3000", 4), ("tma2040", 5), ("pc4500", 6), ("pc4800", 12), ("pc3100", 13), ("series350", 34), ("series370", 35))

awcTpFdbDdpTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 12, 4), )
if mibBuilder.loadTexts: awcTpFdbDdpTable.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpTable.setDescription('A table that contains information about entries for which the bridge has forwarding and/or filtering information. This table maintains only Aironet-specific information about each entry.')
awcTpFdbDdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1), ).setIndexNames((0, "AWCVX-MIB", "awcTpFdbDdpAddress"))
if mibBuilder.loadTexts: awcTpFdbDdpEntry.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpEntry.setDescription('Information about a specific MAC address for which the bridge has some forwarding and/or filtering information.')
awcTpFdbDdpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpAddress.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpAddress.setDescription('A MAC address for which the bridge has forwarding and/or filtering information.')
awcTpFdbDdpSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpSysName.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpSysName.setDescription('The Aironet DDP System Name of the entry.')
awcTpFdbDdpProdDevID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 3), AwcDdpProdDevID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpProdDevID.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpProdDevID.setDescription('The Aironet DDP Product Device ID of the entry.')
awcTpFdbDdpRadioDevID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 4), AwcDdpRadioDevID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpRadioDevID.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpRadioDevID.setDescription('The Aironet DDP Radio Device ID of the entry.')
awcTpFdbDdpSwVerMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpSwVerMajor.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpSwVerMajor.setDescription('The Aironet DDP Major Software Version Number of the entry. If unknown, the value 0 is returned.')
awcTpFdbDdpSwVerMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpSwVerMinor.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpSwVerMinor.setDescription('The Aironet DDP Minor Software Version Number of the entry.')
awcTpFdbDdpSwVerBeta = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpSwVerBeta.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpSwVerBeta.setDescription('The Aironet DDP Beta Software Version Number of the entry. This number is always 0 for officially-released software.')
awcTpFdbDdpUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpUptime.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpUptime.setDescription('The time in seconds that the entry has been operational.')
awcTpFdbDdpNumAnnounceSent = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpNumAnnounceSent.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpNumAnnounceSent.setDescription('The number of times the entry itself believes that it has issued some form of Aironet DDP Presense Announcement. If this field decreases, the entry has probably been reset.')
awcTpFdbDdpNumAssociated = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpNumAssociated.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpNumAssociated.setDescription('The number of Stations currently Associated with the entry.')
awcTpFdbDdpLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpLoad.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpLoad.setDescription("An approximation of the percentage of offered vs. theoretically-available load on the host's radio interface.")
awcTpFdbDdpDistFromDS = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbDdpDistFromDS.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbDdpDistFromDS.setDescription('The Bridging Distance or Number of Hops between the entry and the backbone Distribution System (DS). If 0, the entry is directly connected to the DS.')
class AwcDot11ClientState(TextualConvention, Integer32):
    description = 'IEEE 802.11 Station Service State. state0 = Station not able to send any frames whatsoever. It is most likely not yet configured. state1 = Station can send Class 1 frames. It is Unauthenticated and Unassociated. state2 = Station can send Class 2 frames. It is Authenticated, but is as yet Unassociated. state3 = Station can send Class 3 frames. It is both Authenticated and Associated.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("state0", 1), ("state1", 2), ("state2", 3), ("state3", 4))

awcDot11TpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 12, 5), )
if mibBuilder.loadTexts: awcDot11TpFdbTable.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbTable.setDescription('A table that contains information about entries for which the bridge has forwarding and/or filtering information. This table maintains only 802.11-specific information about each entry.')
awcDot11TpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1), ).setIndexNames((0, "AWCVX-MIB", "awcDot11TpFdbAddress"))
if mibBuilder.loadTexts: awcDot11TpFdbEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbEntry.setDescription('Information about a specific MAC address for which the bridge has some forwarding and/or filtering information.')
awcDot11TpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbAddress.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbAddress.setDescription('A MAC address for which the bridge has forwarding and/or filtering information.')
awcDot11TpFdbAID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbAID.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbAID.setDescription('AID with which the Station is associated with this system, or 2008 if the Station is not currently known to be associated. If the entry is multicast, awcDot11TpFdbAID is 0. Note that the uplink from a Client or Repeater AP to its parent is always AID 1.')
awcDot11TpFdbClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 3), AwcDot11ClientState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbClientState.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbClientState.setDescription('802.11 Service State of the Station.')
awcDot11TpFdbTxShortRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbTxShortRetries.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbTxShortRetries.setDescription('The total number of 802.11 Short Retries incurred across all packet Transmission Attempts to this Station.')
awcDot11TpFdbTxLongRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbTxLongRetries.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbTxLongRetries.setDescription('The total number of 802.11 Long Retries incurred across all packet Transmission Attempts to this Station.')
awcDot11TpFdbLatestTxShortRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbLatestTxShortRetries.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbLatestTxShortRetries.setDescription('The number of 802.11 Short Retries incurred during the most recent packet Transmission Attempts to this Station.')
awcDot11TpFdbLatestTxLongRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbLatestTxLongRetries.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbLatestTxLongRetries.setDescription('The number of 802.11 Long Retries incurred during the most recent packet Transmission Attempts to this Station.')
awcDot11TpFdbRxWEPErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbRxWEPErrors.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbRxWEPErrors.setDescription('The total number of packets received from this Station which failed to be properly decrypted via the WEP security mechanism.')
awcDot11TpFdbLatestRxSignalStrength = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbLatestRxSignalStrength.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbLatestRxSignalStrength.setDescription('A device-dependent measure of the signal strength of the most recently received packet from this Station. Might be normalized or unnormalized.')
awcDot11TpFdbLatestRxSignalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbLatestRxSignalQuality.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbLatestRxSignalQuality.setDescription('A device-dependent measure of the signal quality of the most recently received packet from this Station.')
awcDot11TpFdbCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbCapabilities.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbCapabilities.setDescription("The possible 802.11 capabilities of the Station's radio.")
awcDot11TpFdbListenInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbListenInterval.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbListenInterval.setDescription('The number of beacon intervals across which a the Station will sleep in power-save mode, or 1 if the Station will never be in power-save mode.')
awcDot11TpFdbSupportedDataRates = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbSupportedDataRates.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbSupportedDataRates.setDescription('This attribute shall specify the set of data rates at which the station may transmit data. Each octet contains a value representing a rate. Each rate shall be within the range from 2 to 255, the lower seven bits 0..6 of which corresponding to data rates in increments of 500 kb/s from 1 Mb/s to 63.5 Mb/s, and shall be supported (as indicated in the supported rates table) for receiving data. This value is reported in transmitted Beacon, Probe Request, Probe Response, Association Request, Association Response, Reassociation Request, and Reassociation Response frames, and is used to determine whether a BSS with which the station desires to synchronize is suitable. If set, Bit 7 of the rate specification indicates that rate is a member of the Basic Rate Set of the access point.')
awcDot11TpFdbPreferredTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbPreferredTxRate.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbPreferredTxRate.setDescription('The transmission rate at which a packet should currently be transmitted from an AP to this Station. This rate does not carry information about whether or not the rate is in the Basic Rate Set (i.e. bit 0x80 is never set).')
awcDot11TpFdbCurrentBSS = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 15), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbCurrentBSS.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbCurrentBSS.setDescription("BSS to which the station is currently Associated, or 00:00:00:00:00:00 if the station's current AP is unknown.")
awcDot11TpFdbSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2007))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbSSID.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbSSID.setDescription('If the Station is Associated to this AP, the SSID via which the Station Associated. If 0, the Station Associated via dot11DesiredSSID. If greater than 0, the Station Associated through the auxiliary SSID with awcDot11AuxSSIDIndex equal to awcDot11TpFdbSSID. If -1, the Station is not currently Associated to this AP.')
awcDot11TpFdbVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 5, 1, 17), AwcVlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcDot11TpFdbVlanId.setStatus('current')
if mibBuilder.loadTexts: awcDot11TpFdbVlanId.setDescription('Numeric ID of the VLAN over which the Station is communicating. If 0, the Station is not known to be communicating over any specific VLAN.')
awcDot1dTpPortTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 12, 6), )
if mibBuilder.loadTexts: awcDot1dTpPortTable.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge. This table contains information about host and protocol filtering for the port. Each entry represents a transparent bridge port on the device. Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcDot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: awcDot1dTpPortEntry.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortEntry.setDescription('A list of filtering information for each port of a transparent bridge. This information includes packet forwarding permission for unicast and non-unicast frames and filters ID used for the filtering.')
awcDot1dTpPortDefaultUcastAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultUcastAllowedToGoTo.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultUcastAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined for a unicast MAC address which is not already listed in dot1dStaticTable are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.) The default value of this object is a string of ones of appropriate length.")
awcDot1dTpPortDefaultNUcastAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultNUcastAllowedToGoTo.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultNUcastAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined for a multicast MAC address which is not already listed in dot1dStaticTable are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.) The default value of this object is a string of ones of appropriate length.")
awcDot1dTpPortMaxNUcastPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortMaxNUcastPerSecond.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortMaxNUcastPerSecond.setDescription('The maximum number of multicast packets allowed to be forwarded over the port each second. If 0, the number of multicasts is unlimited.')
awcDot1dTpPortDefaultInEthertypeFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInEthertypeFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInEthertypeFilterId.setDescription('awcPfEtSetId of the Ethertype Filter Set to apply to packets received over this port. If 0, no filters are applied.')
awcDot1dTpPortDefaultOutEthertypeFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutEthertypeFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutEthertypeFilterId.setDescription('awcPfEtSetId of the Ethertype Filter Set to apply to packets transmitted over this port. If 0, no filters are applied.')
awcDot1dTpPortDefaultInIpProtoFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInIpProtoFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInIpProtoFilterId.setDescription('awcPfIppSetId of the IP Protocol Filter Set to apply to packets received over this port. If 0, no filters are applied.')
awcDot1dTpPortDefaultOutIpProtoFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutIpProtoFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutIpProtoFilterId.setDescription('awcPfIppSetId of the IP Protocol Filter Set to apply to packets transmitted over this port. If 0, no filters are applied.')
awcDot1dTpPortDefaultInIpPortFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInIpPortFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultInIpPortFilterId.setDescription('awcPfIptSetId of the IP Port Filter Set to apply to packets received over this port. If 0, no filters are applied.')
awcDot1dTpPortDefaultOutIpPortFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 6, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutIpPortFilterId.setStatus('current')
if mibBuilder.loadTexts: awcDot1dTpPortDefaultOutIpPortFilterId.setDescription('awcPfIptSetId of the IP Port Filter Set to apply to packets transmitted over this port. If 0, no filters are applied.')
awcTpFdbAlertTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 12, 7), )
if mibBuilder.loadTexts: awcTpFdbAlertTable.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertTable.setDescription('A table that contains information about entries for which the bridge has forwarding and/or filtering information. This table maintains only packet-trace alert statistics. Each entry is indexed by a MAC address in the packet forwarding. Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcTpFdbAlertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1), ).setIndexNames((0, "AWCVX-MIB", "awcTpFdbAlertAddress"))
if mibBuilder.loadTexts: awcTpFdbAlertEntry.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertEntry.setDescription('Information about a specific MAC address for which the bridge has some forwarding and/or filtering information.')
awcTpFdbAlertAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAlertAddress.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertAddress.setDescription('A MAC address for which the bridge has forwarding and/or filtering information.')
awcTpFdbFromAlertSrcPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbFromAlertSrcPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbFromAlertSrcPktsImmed.setDescription('The total number of packets directed to this entry, over any interface, from a source host designated Alert From in the forwarding table.')
awcTpFdbFromAlertSrcOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbFromAlertSrcOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbFromAlertSrcOctetsImmed.setDescription('The total number of octets directed to this entry, over any interface, from a source host designated Alert From in the forwarding table.')
awcTpFdbToAlertDestPktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbToAlertDestPktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbToAlertDestPktsImmed.setDescription('The total number of packets sent by this entry, over any interface, to a destination MAC address designated Alert To in the forwarding table.')
awcTpFdbToAlertDestOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbToAlertDestOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbToAlertDestOctetsImmed.setDescription('The total number of packets sent by this entry, over any interface, to a destination MAC address designated Alert To in the forwarding table.')
awcTpFdbAlertSentAlertTypePktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAlertSentAlertTypePktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertSentAlertTypePktsImmed.setDescription('The total number of packets sent by this entry, over any interface, with a packet type designated Alert in an applicable protocol filter.')
awcTpFdbAlertSentAlertTypeOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAlertSentAlertTypeOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertSentAlertTypeOctetsImmed.setDescription('The total number of octets sent by this entry, over any interface, with a packet type designated Alert in an applicable protocol filter.')
awcTpFdbAlertRcvdAlertTypePktsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAlertRcvdAlertTypePktsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertRcvdAlertTypePktsImmed.setDescription('The total number of packets directed to this entry, over any interface, with a packet type designated Alert in an applicable protocol filter.')
awcTpFdbAlertRcvdAlertTypeOctetsImmed = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 12, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcTpFdbAlertRcvdAlertTypeOctetsImmed.setStatus('current')
if mibBuilder.loadTexts: awcTpFdbAlertRcvdAlertTypeOctetsImmed.setDescription('The total number of octets directed to this entry, over any interface, with a packet type designated Alert in an applicable protocol filter.')
class AwcEventSeverity(TextualConvention, Integer32):
    description = 'Severity of an event handled within the system.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))
    namedValues = NamedValues(("systemFatal", 2), ("protocolFatal", 3), ("portFatal", 4), ("systemAlert", 5), ("protocolAlert", 6), ("portAlert", 7), ("externalAlert", 8), ("systemWarning", 9), ("protocolWarning", 10), ("portWarning", 11), ("externalWarning", 12), ("systemInfo", 13), ("protocolInfo", 14), ("portInfo", 15), ("externalInfo", 16))

awcEventOffsetGMT = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-720, 720)).clone(-300)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventOffsetGMT.setStatus('current')
if mibBuilder.loadTexts: awcEventOffsetGMT.setDescription('The current offset from GMT in minutes.')
awcEventUseDaylightSavingsTime = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventUseDaylightSavingsTime.setStatus('current')
if mibBuilder.loadTexts: awcEventUseDaylightSavingsTime.setDescription('If true, daylight savings time is used.')
awcEventTimestampGMT = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 3), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventTimestampGMT.setStatus('current')
if mibBuilder.loadTexts: awcEventTimestampGMT.setDescription('GMT Time, in seconds since January 1, 1970, when the system wall-clock time was last set.')
awcEventUptimeModifiedGMT = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 4), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventUptimeModifiedGMT.setStatus('current')
if mibBuilder.loadTexts: awcEventUptimeModifiedGMT.setDescription('System uptime, in seconds, when the system wall-clock time was last set.')
awcEventDisplayWallClockTime = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDisplayWallClockTime.setStatus('current')
if mibBuilder.loadTexts: awcEventDisplayWallClockTime.setDescription("If true, time display on the system's web pages and console is in wall-clock time. If false, time display is in system uptime.")
awcEventDisplayUptimeAscending = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDisplayUptimeAscending.setStatus('current')
if mibBuilder.loadTexts: awcEventDisplayUptimeAscending.setDescription('If true, time display in system uptime is measured from the time the system boots, forward. If false, time display in measured from the current time backwards.')
awcEventDetailDefault = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 7), Integer32().clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDetailDefault.setStatus('current')
if mibBuilder.loadTexts: awcEventDetailDefault.setDescription('Detail level at which, by default, events are displayed. General detail level classifications are: 8 - no display at all 16 - sparse detail 24 - normal detail 32 - verbose detail 40 - exhaustive detail ')
awcEventSeverityDispConsole = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 8), AwcEventSeverity().clone('externalInfo')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventSeverityDispConsole.setStatus('current')
if mibBuilder.loadTexts: awcEventSeverityDispConsole.setDescription('If an event has a severity level greater than or equal to awcEventSeverityDispConsole, it is displayed on the console shortly after it occurs.')
awcEventSeverityDispHtmlGUI = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 9), AwcEventSeverity().clone('externalInfo')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventSeverityDispHtmlGUI.setStatus('current')
if mibBuilder.loadTexts: awcEventSeverityDispHtmlGUI.setDescription('If an event has a severity level greater than or equal to awcEventSeverityDispHtmlGUI, it is displayed on the the Event Log GUI web pages.')
awcEventSeverityDispHtmlConsole = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 10), AwcEventSeverity().clone('externalInfo')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventSeverityDispHtmlConsole.setStatus('current')
if mibBuilder.loadTexts: awcEventSeverityDispHtmlConsole.setDescription('If an event has a severity level greater than or equal to awcEventSeverityDispHtmlConsole, it is displayed on the the Event Log console browser pages.')
awcEventAlertSNMP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventAlertSNMP.setStatus('current')
if mibBuilder.loadTexts: awcEventAlertSNMP.setDescription('If true, events of a severity with Disposition set to notify will generate an SNMP trap.')
awcEventAlertSyslog = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 12), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventAlertSyslog.setStatus('current')
if mibBuilder.loadTexts: awcEventAlertSyslog.setDescription('If true, events of a severity with Disposition set to notify will generate a sysLog message.')
awcEventStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 14, 14))
awcEventCntSeverityNULL = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityNULL.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityNULL.setDescription('NULL message counter.')
awcEventCntSeveritySilent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeveritySilent.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeveritySilent.setDescription('Silent message counter.')
awcEventCntSeveritySystemFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeveritySystemFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeveritySystemFatal.setDescription('Fatal system message counter.')
awcEventCntSeverityProtocolFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityProtocolFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityProtocolFatal.setDescription('Fatal Protocol message counter.')
awcEventCntSeverityPortFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityPortFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityPortFatal.setDescription('Fatal Port message counter.')
awcEventCntSeveritySystemAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeveritySystemAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeveritySystemAlert.setDescription('System Alert message counter.')
awcEventCntSeverityProtocolAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityProtocolAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityProtocolAlert.setDescription('Protocol Alert message counter.')
awcEventCntSeverityPortAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityPortAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityPortAlert.setDescription('Port Alert message counter.')
awcEventCntSeverityExternalAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityExternalAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityExternalAlert.setDescription('External Alert message counter.')
awcEventCntSeveritySystemWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeveritySystemWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeveritySystemWarning.setDescription('System Warning message counter.')
awcEventCntSeverityProtocolWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityProtocolWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityProtocolWarning.setDescription('Protocol Warning message counter.')
awcEventCntSeverityPortWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityPortWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityPortWarning.setDescription('Port Warning message counter.')
awcEventCntSeverityExternalWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityExternalWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityExternalWarning.setDescription('External Warning message counter.')
awcEventCntSeveritySystemInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeveritySystemInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeveritySystemInfo.setDescription('System Info message counter.')
awcEventCntSeverityProtocolInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityProtocolInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityProtocolInfo.setDescription('Protocol Info message counter.')
awcEventCntSeverityPortInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityPortInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityPortInfo.setDescription('Port Info message counter.')
awcEventCntSeverityExternalInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 14, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventCntSeverityExternalInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventCntSeverityExternalInfo.setDescription('External Info message counter.')
awcEventDisposition = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 14, 15))
awcEventDispSeverityNULL = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 1), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityNULL.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityNULL.setDescription('NULL message disposition.')
awcEventDispSeveritySilent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 2), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeveritySilent.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeveritySilent.setDescription('Silent message disposition.')
awcEventDispSeveritySystemFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 3), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeveritySystemFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeveritySystemFatal.setDescription('Fatal system message disposition.')
awcEventDispSeverityProtocolFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 4), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityProtocolFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityProtocolFatal.setDescription('Fatal Protocol message disposition.')
awcEventDispSeverityPortFatal = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 5), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityPortFatal.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityPortFatal.setDescription('Fatal Port message disposition.')
awcEventDispSeveritySystemAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 6), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeveritySystemAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeveritySystemAlert.setDescription('System Alert message disposition.')
awcEventDispSeverityProtocolAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 7), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityProtocolAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityProtocolAlert.setDescription('Protocol Alert message disposition.')
awcEventDispSeverityPortAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 8), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityPortAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityPortAlert.setDescription('Port Alert message disposition.')
awcEventDispSeverityExternalAlert = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 9), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityExternalAlert.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityExternalAlert.setDescription('External Alert message disposition.')
awcEventDispSeveritySystemWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 10), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeveritySystemWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeveritySystemWarning.setDescription('System Warning message disposition.')
awcEventDispSeverityProtocolWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 11), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityProtocolWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityProtocolWarning.setDescription('Protocol Warning message disposition.')
awcEventDispSeverityPortWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 12), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityPortWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityPortWarning.setDescription('Port Warning message disposition.')
awcEventDispSeverityExternalWarning = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 13), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityExternalWarning.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityExternalWarning.setDescription('External Warning message disposition.')
awcEventDispSeveritySystemInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 14), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeveritySystemInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeveritySystemInfo.setDescription('System Info message disposition.')
awcEventDispSeverityProtocolInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 15), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityProtocolInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityProtocolInfo.setDescription('Protocol Info message disposition.')
awcEventDispSeverityPortInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 16), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityPortInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityPortInfo.setDescription('Port Info message disposition.')
awcEventDispSeverityExternalInfo = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 15, 17), AwcEventDisposition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventDispSeverityExternalInfo.setStatus('current')
if mibBuilder.loadTexts: awcEventDispSeverityExternalInfo.setDescription('External Info message disposition.')
awcEventSyslogAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventSyslogAddr.setStatus('current')
if mibBuilder.loadTexts: awcEventSyslogAddr.setDescription('The destination of a sysLog message. This address must be numeric or DNS resolvable. Max. string length is 128 octets.')
awcEventSyslogFacility = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventSyslogFacility.setStatus('current')
if mibBuilder.loadTexts: awcEventSyslogFacility.setDescription('The facility number encoded within a sysLog message.')
awcEventTraceStationSeverity = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 20), AwcEventSeverity().clone('externalInfo')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventTraceStationSeverity.setStatus('current')
if mibBuilder.loadTexts: awcEventTraceStationSeverity.setDescription('Severity at which all Detailed Packet Trace events shall be handled.')
awcEventTraceLogSize = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388608))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventTraceLogSize.setStatus('current')
if mibBuilder.loadTexts: awcEventTraceLogSize.setDescription('Size in octets of the system Detailed Event Trace Buffer. Note that this buffer is statically allocated at system initialization time. Changing the size of the buffer requires a system reboot.')
awcEventTracePacketLen = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2312))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventTracePacketLen.setStatus('current')
if mibBuilder.loadTexts: awcEventTracePacketLen.setDescription('Maximum size in octets of each Packet Trace Event recorded in the Detailed Event Trace Buffer.')
awcEventTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 14, 23), )
if mibBuilder.loadTexts: awcEventTable.setStatus('current')
if mibBuilder.loadTexts: awcEventTable.setDescription('SNMP access to Event Log table.')
awcEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1), ).setIndexNames((0, "AWCVX-MIB", "awcEventID"))
if mibBuilder.loadTexts: awcEventEntry.setStatus('current')
if mibBuilder.loadTexts: awcEventEntry.setDescription('An entry in awcEventTable.')
awcEventID = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventID.setStatus('current')
if mibBuilder.loadTexts: awcEventID.setDescription('System-unique identifier of the event.')
awcEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventTime.setStatus('current')
if mibBuilder.loadTexts: awcEventTime.setDescription('System time at which the event occurred.')
awcEventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1, 3), AwcEventSeverity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventSeverity.setStatus('current')
if mibBuilder.loadTexts: awcEventSeverity.setDescription('Severity of the event.')
awcEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventDescription.setStatus('current')
if mibBuilder.loadTexts: awcEventDescription.setDescription('Detailed description of the event.')
awcEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 14, 23, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEventType.setStatus('current')
if mibBuilder.loadTexts: awcEventType.setDescription('Specific type of the event. The type is unique for each test condition which can result in event generation.')
awcEventUseCiscoFormat = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEventUseCiscoFormat.setStatus('current')
if mibBuilder.loadTexts: awcEventUseCiscoFormat.setDescription('If true, the system will generate syslog messages using Cisco standard EMBLEM- compliant format. If false, syslog will use legacy Aironet format.')
awcDot11AuthenticateFailDisposition = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 26), AwcDot11EventDisposition().clone('eventLogAndIeeeTrap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11AuthenticateFailDisposition.setStatus('current')
if mibBuilder.loadTexts: awcDot11AuthenticateFailDisposition.setDescription('Specifies how standard IEEE trap dot11AuthenticateFail is handled on the system.')
awcDot11DeauthenticateDisposition = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 27), AwcDot11EventDisposition().clone('eventLogAndIeeeTrap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DeauthenticateDisposition.setStatus('current')
if mibBuilder.loadTexts: awcDot11DeauthenticateDisposition.setDescription('Specifies how standard IEEE 802.11 trap dot11Deauthenticate is handled on the system.')
awcDot11DisassociateDisposition = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 14, 28), AwcDot11EventDisposition().clone('eventLogAndIeeeTrap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDot11DisassociateDisposition.setStatus('current')
if mibBuilder.loadTexts: awcDot11DisassociateDisposition.setDescription('Specifies how standard IEEE 802.11 trap dot11Disassociate is handled on the system.')
awcEtherIfSpeedSelect = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tenBaseT", 3), ("oneHundredBaseT", 5), ("tenBaseTfull", 6), ("oneHundredBaseTfull", 7), ("autoDetect", 8))).clone('autoDetect')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherIfSpeedSelect.setStatus('current')
if mibBuilder.loadTexts: awcEtherIfSpeedSelect.setDescription('Requested Ethernet interface speed and duplex.')
awcEtherDuplex = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEtherDuplex.setStatus('current')
if mibBuilder.loadTexts: awcEtherDuplex.setDescription('Actual Ethernet interface duplex, after any line negotiation has taken place.')
awcEtherCamSize = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcEtherCamSize.setStatus('current')
if mibBuilder.loadTexts: awcEtherCamSize.setDescription('Number of entries in the hardware Content Addressible Memory MAC address filter available to the Ethernet controller.')
awcEtherEnableSwCam = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherEnableSwCam.setStatus('current')
if mibBuilder.loadTexts: awcEtherEnableSwCam.setDescription('If true, the Ethernet driver makes use of a Software Content Addressible Memory when making packet-forwarding decisions. When true, forwarding decisions are much faster, but network statistics collection is much coarser. If false, all packet-forwarding decisions are made by the higher-level packet-bridging logic.')
awcEtherForcePortUnblock = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherForcePortUnblock.setStatus('current')
if mibBuilder.loadTexts: awcEtherForcePortUnblock.setDescription('If true, the Ethernet port has dot1dStpPortState forced to forwarding even when the Spanning Tree Protocol is not enabled. This provides rapid port re-establishment at the potential cost of not detecting network topology loops involving the Ethernet and other network interfaces such as the radio. If false, the Ethernet port is blocked whenever there exists the potential for a network topology loop and the Spanning Tree Protocol is not enabled to guard against such loops.')
awcEtherLostEthernetSeconds = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherLostEthernetSeconds.setStatus('current')
if mibBuilder.loadTexts: awcEtherLostEthernetSeconds.setDescription('Number of seconds the system must detect loss of backbone connectivity (i.e. loss of Ethernet link and no active trunks available on any of the radios) before taking the action specified by awcEtherLostEthernetAction.')
awcEtherLostEthernetAction = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("switchRepeater", 2), ("radioOff", 3), ("restrictSSID", 4))).clone('switchRepeater')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherLostEthernetAction.setStatus('current')
if mibBuilder.loadTexts: awcEtherLostEthernetAction.setDescription('Action taken by the system when a loss of backbone connectivity condition occurs for a period of time longer than awcEtherLostEthernetSeconds.')
awcEtherLostEthernetSSID = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 15, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcEtherLostEthernetSSID.setStatus('current')
if mibBuilder.loadTexts: awcEtherLostEthernetSSID.setDescription('The single SSID index required by the system if awcEtherLostEthernetAction is restrictSSID and backbone connectivity is lost for a period of time longer than awcEtherLostEthernetSeconds. If 0, only Association to dot11DesiredSSID is allowed. If non-0, only Association to the auxiliary SSID with the corresponding awcDot11AuxSSIDIndex is allowed.')
awcPolGrpTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 16, 1), )
if mibBuilder.loadTexts: awcPolGrpTable.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpTable.setDescription('Table of named groups of related protocol filters')
awcPolGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPolGrpId"))
if mibBuilder.loadTexts: awcPolGrpEntry.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpEntry.setDescription('An entry in awcPolGrpTable.')
awcPolGrpId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023)))
if mibBuilder.loadTexts: awcPolGrpId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpId.setDescription('Numeric identifier of the Policy Group.')
awcPolGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpName.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpName.setDescription('Descriptive name of the Policy Group. Max. string length is 64 octets.')
awcPolGrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpStatus.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpStatus.setDescription('Row status of the entire Policy Group.')
awcPolGrpInEthertypeFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpInEthertypeFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpInEthertypeFilterId.setDescription('awcPfEtSetId of the Ethertype Filter Set to apply to packets received subject to this policy. If 0, no filters are applied.')
awcPolGrpOutEthertypeFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpOutEthertypeFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpOutEthertypeFilterId.setDescription('awcPfEtSetId of the Ethertype Filter Set to apply to packets transmitted subject to this policy. If 0, no filters are applied.')
awcPolGrpInIpProtoFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpInIpProtoFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpInIpProtoFilterId.setDescription('awcPfIppSetId of the IP Protocol Filter Set to apply to packets received subject to this policy. If 0, no filters are applied.')
awcPolGrpOutIpProtoFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpOutIpProtoFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpOutIpProtoFilterId.setDescription('awcPfIppSetId of the IP Protocol Filter Set to apply to packets transmitted subject to this policy. If 0, no filters are applied.')
awcPolGrpInIpPortFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpInIpPortFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpInIpPortFilterId.setDescription('awcPfIptSetId of the IP Port Filter Set to apply to packets received subject to this policy. If 0, no filters are applied.')
awcPolGrpOutIpPortFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 1, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPolGrpOutIpPortFilterId.setStatus('current')
if mibBuilder.loadTexts: awcPolGrpOutIpPortFilterId.setDescription('awcPfIptSetId of the IP Port Filter Set to apply to packets transmitted subject to this policy. If 0, no filters are applied.')
awcDscpToCosMapEnable = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 16, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDscpToCosMapEnable.setStatus('current')
if mibBuilder.loadTexts: awcDscpToCosMapEnable.setDescription('If true, IP packets which are not already classified with a non-default Class of Service (CoS) can be classified by reference to their Differentiated Services Code-Point (DSCP) value. If false, unclassified IP packets are not subject to DSCP classification.')
awcDscpToCosMapTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 16, 3), )
if mibBuilder.loadTexts: awcDscpToCosMapTable.setStatus('current')
if mibBuilder.loadTexts: awcDscpToCosMapTable.setDescription('This (conceptual) table to statically map Differentiated Services Code-Point (DSCP) values to corresponding Class of Service (CoS) values.')
awcDscpToCosMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 16, 3, 1), ).setIndexNames((0, "AWCVX-MIB", "awcDscpToCosMapDscp"))
if mibBuilder.loadTexts: awcDscpToCosMapEntry.setStatus('current')
if mibBuilder.loadTexts: awcDscpToCosMapEntry.setDescription('An Entry (conceptual row) in the Aironet DSCP To CoS mapping table to statically map a Differentiated Services Code-Point (DSCP) value to corresponding Class of Service (CoS) value.')
awcDscpToCosMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: awcDscpToCosMapDscp.setStatus('current')
if mibBuilder.loadTexts: awcDscpToCosMapDscp.setDescription('The auxiliary variable used to identify instances of the columnar objects in the Aironet Differentiated Services Code-Point (DSCP) to Class of Service (CoS) Mapping Table. This variable directly corresponds to a Differentiated Services Code-Point, plus 1. The value may be used for marking a traffic stream.')
awcDscpToCosMapCos = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcDscpToCosMapCos.setStatus('current')
if mibBuilder.loadTexts: awcDscpToCosMapCos.setDescription('A value of Class of Service (CoS) mapped to the DSCP value awcDscpToCosMapDscp. This object corresponds directly to the 802.1D traffic category ID, plus 1. The matching values are therefore in the range 1 through 8. The value 0 indicates that no matching CoS is configured for the corresponding awcDscpToCosMapDscp.')
awcIappMcastIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 17, 1), IpAddress().clone(hexValue="E0000128")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIappMcastIpAddr.setStatus('current')
if mibBuilder.loadTexts: awcIappMcastIpAddr.setDescription('Multicast IP network address over which applicable packets of the DDP and IAPP protocols are exchanged between stations. Default 224.0.1.40.')
awcIappPort = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 17, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(2887)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcIappPort.setStatus('current')
if mibBuilder.loadTexts: awcIappPort.setDescription('IP port identifier through which applicable packets of the DDP and IAPP protocols are exchanged between stations. Default 2887.')
awcP802dot1XVersion = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 17, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 10))).clone(namedValues=NamedValues(("d7", 7), ("d8", 8), ("d10", 10))).clone('d10')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcP802dot1XVersion.setStatus('current')
if mibBuilder.loadTexts: awcP802dot1XVersion.setDescription("Version of the 802.1X Protocol specification which the AP will apply for incoming and outgoing EAPOL traffic. Versions with 'd' designators are draft specifications. The 802.1x-2001 standard is the same as draft 10.")
awcHotStandbyMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 1), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcHotStandbyMACAddr.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyMACAddr.setDescription('The MAC address of the target unit which is being monitored.')
awcHotStandbyPollingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcHotStandbyPollingFrequency.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyPollingFrequency.setDescription('The frequency (in seconds) that the monitored target unit is being polled for testing its health.')
awcHotStandbyPollingTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcHotStandbyPollingTimeOut.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyPollingTimeOut.setDescription('The total time (in seconds) that the monitoring unit can tolerate the failure at polling the monitored target unit. After this duration, one more failure of the polling will trigger the standby unit to take the role of monitored unit.')
awcHotStandbyInHotStandby = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcHotStandbyInHotStandby.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyInHotStandby.setDescription('If true, the current unit is in its monitoring mode, i.e., if the unit is or will be a hot standby device.')
class AwcHotStandbyState(TextualConvention, Integer32):
    description = 'Hot standby state.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("running", 0), ("initializing", 1), ("stopped", 2), ("notRunning", 3))

awcHotStandbyState = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 5), AwcHotStandbyState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcHotStandbyState.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyState.setDescription('The current state, e.g., running, stopped, ... of the hotstandby.')
awcHotStandbyStatus = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 18, 6), AwcHotStandbyStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcHotStandbyStatus.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyStatus.setDescription('The current stateus, e.g., error, OK, ... of the hotstandby.')
awcAaaServerTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 19, 1), )
if mibBuilder.loadTexts: awcAaaServerTable.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerTable.setDescription('This table provides information of AAA servers currently available to this access point and the parameters used to connect to the servers. Each entry corresponds to an AAA server and is indexed by the priority in which the server should be used. AAA server of lowest priority value should be used first. Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcAaaServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1), ).setIndexNames((0, "AWCVX-MIB", "awcAaaServerPriority"))
if mibBuilder.loadTexts: awcAaaServerEntry.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerEntry.setDescription('An entry provide the AAA server usage priority, protocol, name, IP port, request timeout, and authentication mechanisms supported.')
awcAaaServerPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAaaServerPriority.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerPriority.setDescription('The priority of the server for when multiple servers are configured for the same service. Lower priority servers are used, in sequence, as backups.')
awcAaaServerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("radius", 1), ("tacacsPlus", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerProtocol.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerProtocol.setDescription('The protocol used to communicate with the AAA server.')
awcAaaServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerName.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerName.setDescription('The DNS-resolvable name or numeric IP address of the AAA server.')
awcAaaServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerPort.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerPort.setDescription('The IP port number of the AAA server.')
awcAaaServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerTimeout.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerTimeout.setDescription('The amount of time (in seconds) that an Access Point should wait for a response from the AAA server before retransmitting the request. If the Access Point does not receive a response within the timeout period, it retransmits the request. If no response is received for a maximum of awcAaaServerMaxRetransmission retransmissions, the server is considered not reachable and a secondary server (if any) will be chosen. If the AP and the AAA server are connected through a low-speed network and the awcAaaServerTimeout value is set to too low, the network may become congested, as the AP retransmits unacknowledged requests that have not yet reached the server')
awcAaaClientName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaClientName.setStatus('current')
if mibBuilder.loadTexts: awcAaaClientName.setDescription('The name the Access Point uses to identify itself when acting as the supplicant.')
awcAaaServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerSharedSecret.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerSharedSecret.setDescription('The textual string shared between the AAA server and the access point, used to authenticate the messages delivered between them.')
awcAaaServer8021xCapabilityEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServer8021xCapabilityEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAaaServer8021xCapabilityEnabled.setDescription('Is this server to be used for 802.1X authentication?')
awcAaaServerMacAddrAuthEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerMacAddrAuthEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerMacAddrAuthEnabled.setDescription('Is this server to be used for MAC-address authentication?')
awcAaaServerAdminAuthEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerAdminAuthEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerAdminAuthEnabled.setDescription('Is this server to be used for AP Admin authentication?')
awcAaaServerMipAuthEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerMipAuthEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerMipAuthEnabled.setDescription('Is this server to be used for Proxy Mobile IP authentication?')
awcAaaServerMaxRetransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 1, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerMaxRetransmission.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerMaxRetransmission.setDescription('The maximum number of retransmission of a request. If an Access Point does not receive a response within awcAaaServerTimeout, it retransmits the request. If no response is received for a maximum number of retransmissions, the server is considered not reachable and a secondary server (if any) will be chosen temporarily.')
awcAcctServerTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 19, 2), )
if mibBuilder.loadTexts: awcAcctServerTable.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerTable.setDescription('This table provides information of AAA accounting servers currently available to this access point and the parameters used to connect to the servers. Each entry corresponds to an AAA server and is indexed by the priority in which the server should be used. AAA server of lowest priority value should be used first. Entries in this table cannot be created or deleted by the network management system. All entries are created or deleted by the agent.')
awcAcctServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1), ).setIndexNames((0, "AWCVX-MIB", "awcAcctServerPriority"))
if mibBuilder.loadTexts: awcAcctServerEntry.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerEntry.setDescription('An entry provide the AAA server usage priority, protocol, name, IP port, request timeout, and security mechanisms supported.')
awcAcctServerPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAcctServerPriority.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerPriority.setDescription('The priority of the server for when multiple servers are configured for the same service. Lower priority servers are used, in sequence, as backups.')
awcAcctServerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("radius", 1), ("tacacsPlus", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerProtocol.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerProtocol.setDescription('The protocol used to communicate with the AAA server.')
awcAcctServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerName.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerName.setDescription('The DNS-resolvable name or numeric IP address of the AAA server.')
awcAcctServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerPort.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerPort.setDescription('The IP port number of the AAA server.')
awcAcctServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerTimeout.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerTimeout.setDescription('The amount of time (in seconds) that an Access Point should wait for a response from the Accounting server before retransmitting the request. If the Access Point does not receive a response within the timeout period, it retransmits the request. If no response is received for a maximum of awcAcctServerMaxRetransmission retransmissions, the server is considered not reachable and a secondary server (if any) will be chosen. If the AP and the Accounting server are connected through a low-speed network and the awcAcctServerTimeout value is set to too low, the network may become congested, as the AP retransmits unacknowledged accounting requests that have not yet reached the server')
awcAcctServerUpdateEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerUpdateEnable.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerUpdateEnable.setDescription('Is the Acct update to this server enabled?.')
awcAcctServerUpdateDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 2592000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerUpdateDelay.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerUpdateDelay.setDescription('The amount of time (in seconds) that the Access Point should send to the AAA server an update of accounting information.')
awcAcctClientName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctClientName.setStatus('current')
if mibBuilder.loadTexts: awcAcctClientName.setDescription('The name the Access Point uses to identify itself when acting as the supplicant.')
awcAcctSecureEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctSecureEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAcctSecureEnabled.setDescription('Is this server to be used for accounting with security AUTH?')
awcAcctGeneralEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctGeneralEnabled.setStatus('current')
if mibBuilder.loadTexts: awcAcctGeneralEnabled.setDescription('Is this server to be used for accounting without security AUTH?')
awcAcctServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerSharedSecret.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerSharedSecret.setDescription('The textual string shared between the ACCT server and the access point, used to authenticate the messages delivered between them.')
awcAcctServerMaxRetransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 19, 2, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctServerMaxRetransmission.setStatus('current')
if mibBuilder.loadTexts: awcAcctServerMaxRetransmission.setDescription('The maximum number of retransmissions of an accounting request. If an Access Point does not receive a response within awcAcctServerTimeout, it retransmits the request. If no response is received for a maximum number of retransmissions, the server is considered not reachable and a secondary server (if any) will be chosen.')
awcAcctEnable = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 3, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctEnable.setStatus('current')
if mibBuilder.loadTexts: awcAcctEnable.setDescription('The boolean indicating if the accounting is enabled.')
awcAcctStopDelayEnable = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 3, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctStopDelayEnable.setStatus('current')
if mibBuilder.loadTexts: awcAcctStopDelayEnable.setDescription('The boolean indicating if the accounting stop request should be delayed before sent.')
awcAcctStopDelayTime = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 3, 3), Unsigned32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAcctStopDelayTime.setStatus('current')
if mibBuilder.loadTexts: awcAcctStopDelayTime.setDescription('The duration for the AP to delay sending the STOP message if any.')
awcAaaAuthConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 19, 4))
awcAaaServerPrimaryReattemptPeriod = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 4, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcAaaServerPrimaryReattemptPeriod.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerPrimaryReattemptPeriod.setDescription('While the primary authentication server serving a given authentication function is not reachable, the duration, in minutes, at which the AP should reattempt to return to its primary server serving that authentication function. A value of zero indicates that primary authentication server reattempt is disabled.')
awcAaaServerDot1xAuthCurrent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAaaServerDot1xAuthCurrent.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerDot1xAuthCurrent.setDescription('The index of the currently selected AAA server for 802.1X user authentication. A value of zero indicates that no authentication server is available to service 802.1X authentication function to this AP. The value of 1 to 4 indicates the corresponding server for 802.1X authentication.')
awcAaaServerMacAddrAuthCurrent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAaaServerMacAddrAuthCurrent.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerMacAddrAuthCurrent.setDescription('The index of the currently selected AAA server for MAC address authentication. A value of zero indicates that no authentication server is available to service MAC address authentication function to this AP. The value of 1 to 4 indicates the corresponding server in use for MAC address authentication function.')
awcAaaServerAdminAuthCurrent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAaaServerAdminAuthCurrent.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerAdminAuthCurrent.setDescription('The index of the currently selected AAA server for the Access Point administrator authentication function. A value of zero indicates that no authentication server is available to service admin login authentication function to this AP. The value of 1 to 4 indicates the corresponding server in use for the AP admin authentication function.')
awcAaaServerMipAuthCurrent = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 19, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcAaaServerMipAuthCurrent.setStatus('current')
if mibBuilder.loadTexts: awcAaaServerMipAuthCurrent.setDescription('The index of the currently selected AAA server used to retrieve authentication data requied for Proxy Mobile registration and authentication function. A value of zero indicates that no authentication server is available for this function. The value of 1 to 4 indicates the corresponding server in use for proxy mobile IP related authentication function.')
class AwcPfDisposition(TextualConvention, Integer32):
    description = 'Designate whether a protocol should be forwarded or blocked, or should behave in the default manner of the associated network interface.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("forward", 1), ("block", 2), ("default", 3))

class AwcPfPriority(TextualConvention, Integer32):
    description = 'Designate the 802.1P priority with which a protocol should be queued.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("default", 1), ("background", 2), ("spare", 3), ("excellentEffort", 4), ("controlledLoad", 5), ("interactiveVideo", 6), ("interactiveVoice", 7), ("networkControl", 8))

awcPrFltEthertypeSetTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 1), )
if mibBuilder.loadTexts: awcPrFltEthertypeSetTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltEthertypeSetTable.setDescription('Table of static Ethertype Filters')
awcPrFltEthertypeSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfEtSetId"))
if mibBuilder.loadTexts: awcPrFltEthertypeSetEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltEthertypeSetEntry.setDescription('An entry in awcPrFltEthertypeTable.')
awcPfEtSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfEtSetId.setStatus('current')
if mibBuilder.loadTexts: awcPfEtSetId.setDescription('Numeric identifier of the static Ethertype filters set.')
awcPfEtSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtSetName.setStatus('current')
if mibBuilder.loadTexts: awcPfEtSetName.setDescription('Descriptive name of the static Ethertype filters set. Max. string length is 64 octets.')
awcPfEtDefaultDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 3), AwcPfDisposition().clone('forward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtDefaultDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfEtDefaultDisposition.setDescription('Default packet disposition of the static Ethertype filters set.')
awcPfEtDefaultUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtDefaultUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfEtDefaultUcastTimeToLive.setDescription('Default time-to-live for unicast (directed) packets. A value of 0 means to use the system defaults.')
awcPfEtDefaultNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtDefaultNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfEtDefaultNUcastTimeToLive.setDescription('Default time-to-live for non-unicast (multicast) packets. A value of 0 means to use the system defaults.')
awcPfEtSetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtSetStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfEtSetStatus.setDescription('Row status of the entire static Ethertype filters set.')
awcPrFltEthertypeTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 2), )
if mibBuilder.loadTexts: awcPrFltEthertypeTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltEthertypeTable.setDescription('Table of individual static Ethertype filters.')
awcPrFltEthertypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfEtSetId"), (0, "AWCVX-MIB", "awcPfEtEthertype"))
if mibBuilder.loadTexts: awcPrFltEthertypeEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltEthertypeEntry.setDescription('An entry in the individual static Ethertype filter table.')
awcPfEtEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 255), ValueRangeConstraint(1501, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfEtEthertype.setStatus('current')
if mibBuilder.loadTexts: awcPfEtEthertype.setDescription('Ethertype (protocol) to which this individual static filter applies')
awcPfEtDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 2), AwcPfDisposition().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfEtDisposition.setDescription('Designation of how the protocol should be handled.')
awcPfEtUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 3), AwcPfPriority().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtUserPriority.setStatus('current')
if mibBuilder.loadTexts: awcPfEtUserPriority.setDescription('Designation of the priority assigned to packets of the Ethertype.')
awcPfEtUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfEtUcastTimeToLive.setDescription('Time-to-live for unicast (directed) packets. A value of 0 means to use the Filter Set defaults.')
awcPfEtNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfEtNUcastTimeToLive.setDescription('Time-to-live for non-unicast (multicast) packets. A value of 0 means to use the Filter Set defaults.')
awcPfEtAlert = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtAlert.setStatus('current')
if mibBuilder.loadTexts: awcPfEtAlert.setDescription('Should an alert be registered when a packet of this Ethertype is observed?')
awcPfEtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfEtStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfEtStatus.setDescription('Row status of the individual static Ethertype filters.')
awcPrFltIpProtocolSetTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 3), )
if mibBuilder.loadTexts: awcPrFltIpProtocolSetTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpProtocolSetTable.setDescription('Table of static IP Protocol Filters')
awcPrFltIpProtocolSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfIppSetId"))
if mibBuilder.loadTexts: awcPrFltIpProtocolSetEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpProtocolSetEntry.setDescription('An entry in awcPrFltIpProtocolTable.')
awcPfIppSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfIppSetId.setStatus('current')
if mibBuilder.loadTexts: awcPfIppSetId.setDescription('Numeric identifier of the static IP Protocol filters set.')
awcPfIppSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppSetName.setStatus('current')
if mibBuilder.loadTexts: awcPfIppSetName.setDescription('Descriptive name of the static IP Protocol filters set. Max. string length is 64 octets.')
awcPfIppDefaultDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 3), AwcPfDisposition().clone('forward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppDefaultDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfIppDefaultDisposition.setDescription('Default packet disposition of the static IP Protocol filters set.')
awcPfIppDefaultUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppDefaultUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIppDefaultUcastTimeToLive.setDescription('Default time-to-live for unicast (directed) packets. A value of 0 means to use the system defaults.')
awcPfIppDefaultNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppDefaultNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIppDefaultNUcastTimeToLive.setDescription('Default time-to-live for non-unicast (multicast) packets. A value of 0 means to use the system defaults.')
awcPfIppSetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppSetStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfIppSetStatus.setDescription('Row status of the entire static IP Protocol filters set.')
awcPrFltIpProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 4), )
if mibBuilder.loadTexts: awcPrFltIpProtocolTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpProtocolTable.setDescription('Table of individual static IP Protocol filters.')
awcPrFltIpProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfIppSetId"), (0, "AWCVX-MIB", "awcPfIppIpProtocol"))
if mibBuilder.loadTexts: awcPrFltIpProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpProtocolEntry.setDescription('An entry in the individual static IP Protocol filter table.')
awcPfIppIpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfIppIpProtocol.setStatus('current')
if mibBuilder.loadTexts: awcPfIppIpProtocol.setDescription('IP Protocol to which this individual static filter applies')
awcPfIppDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 2), AwcPfDisposition().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfIppDisposition.setDescription('Designation of how the protocol should be handled.')
awcPfIppUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 3), AwcPfPriority().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppUserPriority.setStatus('current')
if mibBuilder.loadTexts: awcPfIppUserPriority.setDescription('Designation of the priority assigned to packets of the IP Protocol.')
awcPfIppUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIppUcastTimeToLive.setDescription('Time-to-live for unicast (directed) packets. A value of 0 means to use the Filter Set defaults.')
awcPfIppNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIppNUcastTimeToLive.setDescription('Time-to-live for non-unicast (multicast) packets. A value of 0 means to use the Filter Set defaults.')
awcPfIppAlert = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppAlert.setStatus('current')
if mibBuilder.loadTexts: awcPfIppAlert.setDescription('Should an alert be registered when a packet of this IP Protocol is observed?')
awcPfIppStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIppStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfIppStatus.setDescription('Row status of the individual static IP Protocol filters.')
awcPrFltIpPortSetTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 5), )
if mibBuilder.loadTexts: awcPrFltIpPortSetTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpPortSetTable.setDescription('Table of static IP Port Filters')
awcPrFltIpPortSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfIptSetId"))
if mibBuilder.loadTexts: awcPrFltIpPortSetEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpPortSetEntry.setDescription('An entry in awcPrFltIpPortTable.')
awcPfIptSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfIptSetId.setStatus('current')
if mibBuilder.loadTexts: awcPfIptSetId.setDescription('Numeric identifier of the static IP Port filters set.')
awcPfIptSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptSetName.setStatus('current')
if mibBuilder.loadTexts: awcPfIptSetName.setDescription('Descriptive name of the static IP Port filters set. Max. string length is 64 octets.')
awcPfIptDefaultDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 3), AwcPfDisposition().clone('forward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptDefaultDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfIptDefaultDisposition.setDescription('Default packet disposition of the static IP Port filters set.')
awcPfIptDefaultUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptDefaultUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIptDefaultUcastTimeToLive.setDescription('Default time-to-live for unicast (directed) packets. A value of 0 means to use the system defaults.')
awcPfIptDefaultNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptDefaultNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIptDefaultNUcastTimeToLive.setDescription('Default time-to-live for non-unicast (multicast) packets. A value of 0 means to use the system defaults.')
awcPfIptSetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 5, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptSetStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfIptSetStatus.setDescription('Row status of the entire static IP Port filters set.')
awcPrFltIpPortTable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 20, 6), )
if mibBuilder.loadTexts: awcPrFltIpPortTable.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpPortTable.setDescription('Table of individual static IP Port filters.')
awcPrFltIpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1), ).setIndexNames((0, "AWCVX-MIB", "awcPfIptSetId"), (0, "AWCVX-MIB", "awcPfIptIpPort"))
if mibBuilder.loadTexts: awcPrFltIpPortEntry.setStatus('current')
if mibBuilder.loadTexts: awcPrFltIpPortEntry.setDescription('An entry in the individual static IP Port filter table.')
awcPfIptIpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: awcPfIptIpPort.setStatus('current')
if mibBuilder.loadTexts: awcPfIptIpPort.setDescription('IP Port to which this individual static filter applies')
awcPfIptDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 2), AwcPfDisposition().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptDisposition.setStatus('current')
if mibBuilder.loadTexts: awcPfIptDisposition.setDescription('Designation of how the Port should be handled.')
awcPfIptUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 3), AwcPfPriority().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptUserPriority.setStatus('current')
if mibBuilder.loadTexts: awcPfIptUserPriority.setDescription('Designation of the priority assigned to packets of the IP Port.')
awcPfIptUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIptUcastTimeToLive.setDescription('Time-to-live for unicast (directed) packets. A value of 0 means to use the Filter Set defaults.')
awcPfIptNUcastTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptNUcastTimeToLive.setStatus('current')
if mibBuilder.loadTexts: awcPfIptNUcastTimeToLive.setDescription('Time-to-live for non-unicast (multicast) packets. A value of 0 means to use the Filter Set defaults.')
awcPfIptAlert = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptAlert.setStatus('current')
if mibBuilder.loadTexts: awcPfIptAlert.setDescription('Should an alert be registered when a packet of this IP Port is observed?')
awcPfIptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 20, 6, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: awcPfIptStatus.setStatus('current')
if mibBuilder.loadTexts: awcPfIptStatus.setDescription('Row status of the individual static IP Port filters.')
enableMobileIP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 22, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableMobileIP.setStatus('current')
if mibBuilder.loadTexts: enableMobileIP.setDescription("If true, the Access Point's proxy mobile IP service is enabled. If false, proxy mobile IP service is disabled.")
awcprimAAP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 22, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcprimAAP.setStatus('current')
if mibBuilder.loadTexts: awcprimAAP.setDescription('The first AAP hostname or IP address from a list of 3 AAPs.')
awcsec1AAP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 22, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcsec1AAP.setStatus('current')
if mibBuilder.loadTexts: awcsec1AAP.setDescription('The second AAP hostname or IP address from a list of 3 AAPs.')
awcsec2AAP = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 22, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcsec2AAP.setStatus('current')
if mibBuilder.loadTexts: awcsec2AAP.setDescription('The third AAP hostname or IP address from a list of 3 AAPs.')
mipSATable = MibTable((1, 3, 6, 1, 4, 1, 522, 3, 22, 5), )
if mibBuilder.loadTexts: mipSATable.setStatus('current')
if mibBuilder.loadTexts: mipSATable.setDescription("This entity's Mobile IP Local SA Bindings table.")
mipSAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1), ).setIndexNames((0, "AWCVX-MIB", "mipSAIpStart"))
if mibBuilder.loadTexts: mipSAEntry.setStatus('current')
if mibBuilder.loadTexts: mipSAEntry.setDescription('An entry of SA bindings for a range of IP Addresses.')
mipSAIpStart = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1, 1), IpAddress())
if mibBuilder.loadTexts: mipSAIpStart.setStatus('current')
if mibBuilder.loadTexts: mipSAIpStart.setDescription('Starting IP Address of a range for the SA binding.')
mipSAIpEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mipSAIpEnd.setStatus('current')
if mibBuilder.loadTexts: mipSAIpEnd.setDescription('Ending IP Address of the range for the SA binding.')
mipSAGroupSPI = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mipSAGroupSPI.setStatus('current')
if mibBuilder.loadTexts: mipSAGroupSPI.setDescription('Group SPI for the range of IP Address in the Local SA binding')
mipSAGroupKey = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mipSAGroupKey.setStatus('current')
if mibBuilder.loadTexts: mipSAGroupKey.setDescription('Group Key for the range of IP Address in the Local SA binding')
mipSAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 522, 3, 22, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mipSAStatus.setStatus('current')
if mibBuilder.loadTexts: mipSAStatus.setDescription('Row status of the pMIP SA. Allows deletion via SNMP.')
awcmipDebug = MibScalar((1, 3, 6, 1, 4, 1, 522, 3, 22, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: awcmipDebug.setStatus('current')
if mibBuilder.loadTexts: awcmipDebug.setDescription("If true, the Access Point's proxy mobile IP debug information is printed on the console. If false, debug messages are not printed.")
awcTrapLog = NotificationType((1, 3, 6, 1, 4, 1, 522, 4)).setObjects(("AWCVX-MIB", "awcEventTime"), ("AWCVX-MIB", "awcEventSeverity"), ("AWCVX-MIB", "awcEventDescription"), ("AWCVX-MIB", "awcEventType"))
if mibBuilder.loadTexts: awcTrapLog.setStatus('current')
if mibBuilder.loadTexts: awcTrapLog.setDescription('SNMP trap corresponding to an event with a Severity Level requiring Notify Disposition while awcEventAlertSNMP is true.')
awcVxConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 100))
awcVxCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 100, 1))
awcVxGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 522, 3, 100, 2))
awcVxCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 522, 3, 100, 1, 1)).setObjects(("AWCVX-MIB", "awcSystemGroup"), ("AWCVX-MIB", "bootconfigVxGroup"), ("AWCVX-MIB", "awcSerialDevGroup"), ("AWCVX-MIB", "awcFtpGroup"), ("AWCVX-MIB", "awcIfTableGroup"), ("AWCVX-MIB", "awc802dot11Group"), ("AWCVX-MIB", "awcUserMgrGroup"), ("AWCVX-MIB", "awcHttpdGroup"), ("AWCVX-MIB", "awcDnsResGroup"), ("AWCVX-MIB", "awcSnmpGroup"), ("AWCVX-MIB", "awcSntpGroup"), ("AWCVX-MIB", "awcForwardTblGroup"), ("AWCVX-MIB", "awcEventLogGroup"), ("AWCVX-MIB", "awcEtherMIBGroup"), ("AWCVX-MIB", "awcDdpIAPPGroup"), ("AWCVX-MIB", "awcHotStandbyGroup"), ("AWCVX-MIB", "awcAaaGroup"), ("AWCVX-MIB", "awcProtocolFiltersGroup"), ("AWCVX-MIB", "awcMobileIpGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcVxCompliance = awcVxCompliance.setStatus('current')
if mibBuilder.loadTexts: awcVxCompliance.setDescription('The compliance statement for the awcVx group.')
awcSystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 1)).setObjects(("AWCVX-MIB", "vxWorksVersion"), ("AWCVX-MIB", "creationDate"), ("AWCVX-MIB", "awcVxVersion"), ("AWCVX-MIB", "sysFlags"), ("AWCVX-MIB", "languageCode"), ("AWCVX-MIB", "awcDevID"), ("AWCVX-MIB", "awcDevIDtxt"), ("AWCVX-MIB", "enableHTTP"), ("AWCVX-MIB", "enableTelnet"), ("AWCVX-MIB", "enableSNMP"), ("AWCVX-MIB", "enableDnsResolver"), ("AWCVX-MIB", "enableSNTP"), ("AWCVX-MIB", "enableWDB"), ("AWCVX-MIB", "pingTxLen"), ("AWCVX-MIB", "awcFirstBoot"), ("AWCVX-MIB", "awcOemOUI"), ("AWCVX-MIB", "awcOemName"), ("AWCVX-MIB", "awcOemNameShort"), ("AWCVX-MIB", "awcOemHomeURL"), ("AWCVX-MIB", "enablePSPF"), ("AWCVX-MIB", "sysExceptionReboot"), ("AWCVX-MIB", "bootblockVersion"), ("AWCVX-MIB", "motherboardRevision"), ("AWCVX-MIB", "enableSTP"), ("AWCVX-MIB", "enableRebootKey"), ("AWCVX-MIB", "awcLocateUnit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcSystemGroup = awcSystemGroup.setStatus('current')
if mibBuilder.loadTexts: awcSystemGroup.setDescription('Standard information to support operation of an Aironet Access Point such as versions, system flags, and what features are enabled.')
bootconfigVxGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 2)).setObjects(("AWCVX-MIB", "bootconfigBootProtocol"), ("AWCVX-MIB", "bootconfigReadINI"), ("AWCVX-MIB", "bootconfigServerConfigTimeout"), ("AWCVX-MIB", "bootconfigMultOfferTimeout"), ("AWCVX-MIB", "bootconfigReqLeaseDuration"), ("AWCVX-MIB", "bootconfigMinLeaseDuration"), ("AWCVX-MIB", "bootconfigDev"), ("AWCVX-MIB", "bootconfigClientAddr"), ("AWCVX-MIB", "bootconfigHostAddr"), ("AWCVX-MIB", "bootconfigBootFile"), ("AWCVX-MIB", "bootconfigSubnetMask"), ("AWCVX-MIB", "bootconfigGateway"), ("AWCVX-MIB", "bootconfigHostName"), ("AWCVX-MIB", "bootconfigClientName"), ("AWCVX-MIB", "bootconfigNameServerPriority"), ("AWCVX-MIB", "bootconfigNameServer"), ("AWCVX-MIB", "bootconfigDomainName"), ("AWCVX-MIB", "bootconfigSntpServer"), ("AWCVX-MIB", "bootconfigSaveServerResponse"), ("AWCVX-MIB", "bootconfigCmdInvokeIniLoad"), ("AWCVX-MIB", "bootconfigCmdStatusIniLoad"), ("AWCVX-MIB", "bootconfigDhcpClassID"), ("AWCVX-MIB", "bootconfigFileServerAddr"), ("AWCVX-MIB", "bootconfigLogServerAddr"), ("AWCVX-MIB", "bootconfigBootCount"), ("AWCVX-MIB", "bootconfigDhcpClientIdType"), ("AWCVX-MIB", "bootconfigDhcpClientIdValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bootconfigVxGroup = bootconfigVxGroup.setStatus('current')
if mibBuilder.loadTexts: bootconfigVxGroup.setDescription('Standard information to support operation of the boot server.')
awcSerialDevGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 3)).setObjects(("AWCVX-MIB", "serialDevIndex"), ("AWCVX-MIB", "serialAdminStatus"), ("AWCVX-MIB", "serialOperStatus"), ("AWCVX-MIB", "serialBaud"), ("AWCVX-MIB", "serialParity"), ("AWCVX-MIB", "serialDataBits"), ("AWCVX-MIB", "serialStopBits"), ("AWCVX-MIB", "serialFlowControl"), ("AWCVX-MIB", "serialTerminalType"), ("AWCVX-MIB", "serialTerminalLines"), ("AWCVX-MIB", "serialTerminalColumns"), ("AWCVX-MIB", "serialDevFd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcSerialDevGroup = awcSerialDevGroup.setStatus('current')
if mibBuilder.loadTexts: awcSerialDevGroup.setDescription('Standard information to support configuration of serial ports.')
awcFtpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 4)).setObjects(("AWCVX-MIB", "defaultFileServer"), ("AWCVX-MIB", "awcFileXferProtocol"), ("AWCVX-MIB", "awcFileXferUser"), ("AWCVX-MIB", "awcFileXferPassword"), ("AWCVX-MIB", "awcFileXferCmdInvokeFileLoad"), ("AWCVX-MIB", "awcFileXferCmdStatusFileLoad"), ("AWCVX-MIB", "awcFileXferCmdInvokeFileSave"), ("AWCVX-MIB", "awcFileXferCmdStatusFileSave"), ("AWCVX-MIB", "awcFileXferFileFirmwareSystem"), ("AWCVX-MIB", "awcFileXferFileFirmwareRadio0"), ("AWCVX-MIB", "awcFileXferFileWebUI"), ("AWCVX-MIB", "awcFileXferFileFpgaPcmcia"), ("AWCVX-MIB", "awcFileXferTftpPort"), ("AWCVX-MIB", "awcFileXferFtpDirectory"), ("AWCVX-MIB", "awcFileXferFilesFLASH"), ("AWCVX-MIB", "awcFileXferFileFirmwareRadio1"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcFtpGroup = awcFtpGroup.setStatus('current')
if mibBuilder.loadTexts: awcFtpGroup.setDescription('Standard information to support configuration of the FTP protocol.')
awcIfTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 5)).setObjects(("AWCVX-MIB", "awcIfDefaultPhysAddress"), ("AWCVX-MIB", "awcIfPhysAddress"), ("AWCVX-MIB", "awcIfAdoptPrimaryIdentity"), ("AWCVX-MIB", "awcIfDefaultIpAddress"), ("AWCVX-MIB", "awcIfDefaultIpNetMask"), ("AWCVX-MIB", "awcIfIpAddress"), ("AWCVX-MIB", "awcIfIpNetMask"), ("AWCVX-MIB", "awcIfMSDUMaxLength"), ("AWCVX-MIB", "awcIfOutDiscardsCoS0"), ("AWCVX-MIB", "awcIfOutDiscardsCoS1"), ("AWCVX-MIB", "awcIfOutDiscardsCoS2"), ("AWCVX-MIB", "awcIfOutDiscardsCoS3"), ("AWCVX-MIB", "awcIfOutDiscardsCoS4"), ("AWCVX-MIB", "awcIfOutDiscardsCoS5"), ("AWCVX-MIB", "awcIfOutDiscardsCoS6"), ("AWCVX-MIB", "awcIfOutDiscardsCoS7"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcIfTableGroup = awcIfTableGroup.setStatus('current')
if mibBuilder.loadTexts: awcIfTableGroup.setDescription('Standard information to support configuration of network interfaces.')
awc802dot11Group = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 6)).setObjects(("AWCVX-MIB", "awcDot11StationRole"), ("AWCVX-MIB", "awcDot11PowerManagementSubMode"), ("AWCVX-MIB", "awcDot11UseAWCExtensions"), ("AWCVX-MIB", "awcDot11AllowAssocBroadcastSSID"), ("AWCVX-MIB", "awcDot11PrivacyOptionImplementedMaxRate"), ("AWCVX-MIB", "awcDot11DesiredBSSLength"), ("AWCVX-MIB", "awcDot11EnetEncapsulationDefault"), ("AWCVX-MIB", "awcDot11ForceReqFirmwareVersion"), ("AWCVX-MIB", "awcDot11BridgeSpacing"), ("AWCVX-MIB", "awcDot11DesiredSSIDMaxAssociatedSTA"), ("AWCVX-MIB", "awcDot11DesiredSSIDNumAssociatedSTA"), ("AWCVX-MIB", "awcDot11AuxiliarySSIDLength"), ("AWCVX-MIB", "awcDot11MultipleSSIDPerBSSImplemented"), ("AWCVX-MIB", "awcDot11SymbolExtensionsImplemented"), ("AWCVX-MIB", "awcDot11SymbolExtensionsEnabled"), ("AWCVX-MIB", "awcDot11DesiredSSIDMicAlgorithm"), ("AWCVX-MIB", "awcDot11DesiredSSIDWEPKeyPermuteAlgorithm"), ("AWCVX-MIB", "awcDot11DesiredSSIDInfrastructureWGB"), ("AWCVX-MIB", "awcDot11DesiredSSIDDefaultPolId"), ("AWCVX-MIB", "awcDot11DesiredSSIDDefaultVlanId"), ("AWCVX-MIB", "awcDot11DesiredSSIDEnableProxyMobileIP"), ("AWCVX-MIB", "awcDot11InfrastructureSSID"), ("AWCVX-MIB", "awcDot11QBSSElementImplemented"), ("AWCVX-MIB", "awcDot11QBSSElementEnabled"), ("AWCVX-MIB", "awcDot11InfrastructureSSIDExclusive"), ("AWCVX-MIB", "awcDot11SendIGMPGeneralQuery"), ("AWCVX-MIB", "awcDot11AuthenticationRequireEAP"), ("AWCVX-MIB", "awcDot11AuthenticationDefaultUcastAllowedToGoTo"), ("AWCVX-MIB", "awcDot11WEPDefaultKeyIndex"), ("AWCVX-MIB", "awcDot11WEPDefaultKeyLen"), ("AWCVX-MIB", "awcDot11WEPDefaultKeyValue"), ("AWCVX-MIB", "awcDot11WEPDefaultKeyMaxIndex"), ("AWCVX-MIB", "awcDot11AllowEncrypted"), ("AWCVX-MIB", "awcDot11WEPKeyMaxLen"), ("AWCVX-MIB", "awcDot11LEAPUserName"), ("AWCVX-MIB", "awcDot11LEAPPassword"), ("AWCVX-MIB", "awcDot11DesiredBSSIndex"), ("AWCVX-MIB", "awcDot11DesiredBSS"), ("AWCVX-MIB", "awcDot11AuxSSIDIndex"), ("AWCVX-MIB", "awcDot11AuxSSID"), ("AWCVX-MIB", "awcDot11AuxSSIDMaxAssociatedSTA"), ("AWCVX-MIB", "awcDot11AuxSSIDNumAssociatedSTA"), ("AWCVX-MIB", "awcDot11AuxSSIDDefaultPolId"), ("AWCVX-MIB", "awcDot11AuxSSIDDefaultVlanId"), ("AWCVX-MIB", "awcDot11AuxSSIDEnableProxyMobileIP"), ("AWCVX-MIB", "awcDot11AuxSSIDAuthAlgEnable"), ("AWCVX-MIB", "awcDot11AuxSSIDAuthAlgRequireEAP"), ("AWCVX-MIB", "awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo"), ("AWCVX-MIB", "awcDot11AssignedAID"), ("AWCVX-MIB", "awcDot11AssignedSTA"), ("AWCVX-MIB", "awcDot11FirmwareBootstrapVersion"), ("AWCVX-MIB", "awcDot11CurrentCarrierSet"), ("AWCVX-MIB", "awcDot11ModulationType"), ("AWCVX-MIB", "awcDot11PreambleType"), ("AWCVX-MIB", "awcDot11PHYType"), ("AWCVX-MIB", "awcDot11Compatible3100"), ("AWCVX-MIB", "awcDot11Compatible4500"), ("AWCVX-MIB", "awcDot11ChannelAutoImplemented"), ("AWCVX-MIB", "awcDot11ChannelAutoEnabled"), ("AWCVX-MIB", "awcDot11CurrentChannel"), ("AWCVX-MIB", "awcDot11SupportedDataRatesPrivacyIndex"), ("AWCVX-MIB", "awcDot11SupportedDataRatesPrivacyValue"), ("AWCVX-MIB", "awcDot11SupportedDataRatesPrivacyImplemented"), ("AWCVX-MIB", "awcDot11ChanSelectChannel"), ("AWCVX-MIB", "awcDot11ChanSelectEnable"), ("AWCVX-MIB", "awcDot11AssociatedStationCount"), ("AWCVX-MIB", "awcDot11AuthenticatedStationCount"), ("AWCVX-MIB", "awcDot11ReassociatedStationCount"), ("AWCVX-MIB", "awcDot11RoamedStationCount"), ("AWCVX-MIB", "awcDot11DeauthenticateCount"), ("AWCVX-MIB", "awcDot11DisassociateCount"), ("AWCVX-MIB", "awcDot11EncapPktsMMH"), ("AWCVX-MIB", "awcDot11DecapPktsMMH"), ("AWCVX-MIB", "awcDot11EncapErrorsMMH"), ("AWCVX-MIB", "awcDot11DecapErrorsMMH"), ("AWCVX-MIB", "awcDot11DecapExistsMMH"), ("AWCVX-MIB", "awcDot11DecapAccessMMH"), ("AWCVX-MIB", "awcDot11TxDeferEnergyCount"), ("AWCVX-MIB", "awcDot11RxMacCrcErrorCount"), ("AWCVX-MIB", "awcDot11SsidMismatchCount"), ("AWCVX-MIB", "awcDot11QoSCWmin"), ("AWCVX-MIB", "awcDot11QoSCWmax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awc802dot11Group = awc802dot11Group.setStatus('current')
if mibBuilder.loadTexts: awc802dot11Group.setDescription('Standard information to support configuration of the 802.11 protocol.')
awcUserMgrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 7)).setObjects(("AWCVX-MIB", "userMgrUserIndex"), ("AWCVX-MIB", "userMgrUserName"), ("AWCVX-MIB", "userMgrPassword"), ("AWCVX-MIB", "userMgrCapabilities"), ("AWCVX-MIB", "userMgrStatus"), ("AWCVX-MIB", "enableUserMgr"), ("AWCVX-MIB", "allowBrowseWithoutLogin"), ("AWCVX-MIB", "protectLegalPage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcUserMgrGroup = awcUserMgrGroup.setStatus('current')
if mibBuilder.loadTexts: awcUserMgrGroup.setDescription('Standard information to support configuration of the User Manager.')
awcHttpdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 8)).setObjects(("AWCVX-MIB", "defaultWebRoot"), ("AWCVX-MIB", "defaultHelpRoot"), ("AWCVX-MIB", "getWebUI"), ("AWCVX-MIB", "cmdInvokeGetWebUI"), ("AWCVX-MIB", "cmdStatusGetWebUI"), ("AWCVX-MIB", "awcHttpdPort"), ("AWCVX-MIB", "awcConsoleAutoApply"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcHttpdGroup = awcHttpdGroup.setStatus('current')
if mibBuilder.loadTexts: awcHttpdGroup.setDescription('Standard information to support configuration of the Web Server.')
awcDnsResGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 9)).setObjects(("AWCVX-MIB", "resolverDomain"), ("AWCVX-MIB", "resolverDomainSuffix"), ("AWCVX-MIB", "resolverDomainServerPriority"), ("AWCVX-MIB", "resolverDomainServer"), ("AWCVX-MIB", "defaultResolverDomain"), ("AWCVX-MIB", "defaultResolverDomainServerPriority"), ("AWCVX-MIB", "defaultResolverDomainServer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcDnsResGroup = awcDnsResGroup.setStatus('current')
if mibBuilder.loadTexts: awcDnsResGroup.setDescription('Standard information to support configuration of the DNS Resolver.')
awcSnmpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 10)).setObjects(("AWCVX-MIB", "snmpTrapDest"), ("AWCVX-MIB", "snmpTrapCommunity"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcSnmpGroup = awcSnmpGroup.setStatus('current')
if mibBuilder.loadTexts: awcSnmpGroup.setDescription('Standard information to support configuration of the SNMP protocol.')
awcSntpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 11)).setObjects(("AWCVX-MIB", "defaultSntpServer"), ("AWCVX-MIB", "sntpServer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcSntpGroup = awcSntpGroup.setStatus('current')
if mibBuilder.loadTexts: awcSntpGroup.setDescription('Standard information to support configuration of the SNTP protocol.')
awcForwardTblGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 12)).setObjects(("AWCVX-MIB", "awcFtMcastAddr"), ("AWCVX-MIB", "awcFtDsHost"), ("AWCVX-MIB", "awcFtBridgeHost"), ("AWCVX-MIB", "awcFtClientSTA"), ("AWCVX-MIB", "awcFtClientSTASelf"), ("AWCVX-MIB", "awcFtBridge"), ("AWCVX-MIB", "awcFtBridgeSelf"), ("AWCVX-MIB", "awcFtRepeater"), ("AWCVX-MIB", "awcFtRepeaterSelf"), ("AWCVX-MIB", "awcFtAccessPoint"), ("AWCVX-MIB", "awcFtBridgeRoot"), ("AWCVX-MIB", "awcFtMaxNumEntries"), ("AWCVX-MIB", "awcFtTimeoutSecUnknown"), ("AWCVX-MIB", "awcFtTimeoutSecMcastAddr"), ("AWCVX-MIB", "awcFtTimeoutSecDsHost"), ("AWCVX-MIB", "awcFtTimeoutSecBridgeHost"), ("AWCVX-MIB", "awcFtTimeoutSecClientSTA"), ("AWCVX-MIB", "awcFtTimeoutSecBridge"), ("AWCVX-MIB", "awcFtTimeoutSecRepeater"), ("AWCVX-MIB", "awcFtTimeoutSecAccessPoint"), ("AWCVX-MIB", "awcFtTimeoutSecBridgeRoot"), ("AWCVX-MIB", "awcFtEnableAwcTpFdbTable"), ("AWCVX-MIB", "awcFtEnableMacAuthServer"), ("AWCVX-MIB", "awcFtRogueApAlertTimeout"), ("AWCVX-MIB", "awcFtEnableMacOrEapAuth"), ("AWCVX-MIB", "awcFtDot1dTpFdbTableEnable"), ("AWCVX-MIB", "awcTpFdbAddress"), ("AWCVX-MIB", "awcTpFdbClassID"), ("AWCVX-MIB", "awcTpFdbSrcPktsImmed"), ("AWCVX-MIB", "awcTpFdbSrcOctetsImmed"), ("AWCVX-MIB", "awcTpFdbSrcErrorPktsImmed"), ("AWCVX-MIB", "awcTpFdbSrcErrorOctetsImmed"), ("AWCVX-MIB", "awcTpFdbDestPktsImmed"), ("AWCVX-MIB", "awcTpFdbDestOctetsImmed"), ("AWCVX-MIB", "awcTpFdbDestErrorPktsImmed"), ("AWCVX-MIB", "awcTpFdbDestErrorOctetsImmed"), ("AWCVX-MIB", "awcTpFdbDestMaxRetryErrorsImmed"), ("AWCVX-MIB", "awcTpFdbIPv4Addr"), ("AWCVX-MIB", "awcTpFdbDdpAddress"), ("AWCVX-MIB", "awcTpFdbDdpSysName"), ("AWCVX-MIB", "awcTpFdbDdpProdDevID"), ("AWCVX-MIB", "awcTpFdbDdpRadioDevID"), ("AWCVX-MIB", "awcTpFdbDdpSwVerMajor"), ("AWCVX-MIB", "awcTpFdbDdpSwVerMinor"), ("AWCVX-MIB", "awcTpFdbDdpSwVerBeta"), ("AWCVX-MIB", "awcTpFdbDdpUptime"), ("AWCVX-MIB", "awcTpFdbDdpNumAnnounceSent"), ("AWCVX-MIB", "awcTpFdbDdpNumAssociated"), ("AWCVX-MIB", "awcTpFdbDdpLoad"), ("AWCVX-MIB", "awcTpFdbDdpDistFromDS"), ("AWCVX-MIB", "awcDot11TpFdbAddress"), ("AWCVX-MIB", "awcDot11TpFdbAID"), ("AWCVX-MIB", "awcDot11TpFdbClientState"), ("AWCVX-MIB", "awcDot11TpFdbTxShortRetries"), ("AWCVX-MIB", "awcDot11TpFdbTxLongRetries"), ("AWCVX-MIB", "awcDot11TpFdbLatestTxShortRetries"), ("AWCVX-MIB", "awcDot11TpFdbLatestTxLongRetries"), ("AWCVX-MIB", "awcDot11TpFdbRxWEPErrors"), ("AWCVX-MIB", "awcDot11TpFdbLatestRxSignalStrength"), ("AWCVX-MIB", "awcDot11TpFdbLatestRxSignalQuality"), ("AWCVX-MIB", "awcDot11TpFdbCapabilities"), ("AWCVX-MIB", "awcDot11TpFdbListenInterval"), ("AWCVX-MIB", "awcDot11TpFdbSupportedDataRates"), ("AWCVX-MIB", "awcDot11TpFdbPreferredTxRate"), ("AWCVX-MIB", "awcDot11TpFdbCurrentBSS"), ("AWCVX-MIB", "awcDot11TpFdbSSID"), ("AWCVX-MIB", "awcDot11TpFdbVlanId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultUcastAllowedToGoTo"), ("AWCVX-MIB", "awcDot1dTpPortDefaultNUcastAllowedToGoTo"), ("AWCVX-MIB", "awcDot1dTpPortMaxNUcastPerSecond"), ("AWCVX-MIB", "awcDot1dTpPortDefaultInEthertypeFilterId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultOutEthertypeFilterId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultInIpProtoFilterId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultOutIpProtoFilterId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultInIpPortFilterId"), ("AWCVX-MIB", "awcDot1dTpPortDefaultOutIpPortFilterId"), ("AWCVX-MIB", "awcTpFdbAlertAddress"), ("AWCVX-MIB", "awcTpFdbFromAlertSrcPktsImmed"), ("AWCVX-MIB", "awcTpFdbFromAlertSrcOctetsImmed"), ("AWCVX-MIB", "awcTpFdbToAlertDestPktsImmed"), ("AWCVX-MIB", "awcTpFdbToAlertDestOctetsImmed"), ("AWCVX-MIB", "awcTpFdbAlertSentAlertTypePktsImmed"), ("AWCVX-MIB", "awcTpFdbAlertSentAlertTypeOctetsImmed"), ("AWCVX-MIB", "awcTpFdbAlertRcvdAlertTypePktsImmed"), ("AWCVX-MIB", "awcTpFdbAlertRcvdAlertTypeOctetsImmed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcForwardTblGroup = awcForwardTblGroup.setStatus('current')
if mibBuilder.loadTexts: awcForwardTblGroup.setDescription('Standard information to support configuration of the Forwarding Table.')
awcEventLogGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 14)).setObjects(("AWCVX-MIB", "awcEventOffsetGMT"), ("AWCVX-MIB", "awcEventUseDaylightSavingsTime"), ("AWCVX-MIB", "awcEventTimestampGMT"), ("AWCVX-MIB", "awcEventUptimeModifiedGMT"), ("AWCVX-MIB", "awcEventDisplayWallClockTime"), ("AWCVX-MIB", "awcEventDisplayUptimeAscending"), ("AWCVX-MIB", "awcEventDetailDefault"), ("AWCVX-MIB", "awcEventSeverityDispConsole"), ("AWCVX-MIB", "awcEventSeverityDispHtmlGUI"), ("AWCVX-MIB", "awcEventSeverityDispHtmlConsole"), ("AWCVX-MIB", "awcEventAlertSNMP"), ("AWCVX-MIB", "awcEventAlertSyslog"), ("AWCVX-MIB", "awcEventCntSeverityNULL"), ("AWCVX-MIB", "awcEventCntSeveritySilent"), ("AWCVX-MIB", "awcEventCntSeveritySystemFatal"), ("AWCVX-MIB", "awcEventCntSeverityProtocolFatal"), ("AWCVX-MIB", "awcEventCntSeverityPortFatal"), ("AWCVX-MIB", "awcEventCntSeveritySystemAlert"), ("AWCVX-MIB", "awcEventCntSeverityProtocolAlert"), ("AWCVX-MIB", "awcEventCntSeverityPortAlert"), ("AWCVX-MIB", "awcEventCntSeverityExternalAlert"), ("AWCVX-MIB", "awcEventCntSeveritySystemWarning"), ("AWCVX-MIB", "awcEventCntSeverityProtocolWarning"), ("AWCVX-MIB", "awcEventCntSeverityPortWarning"), ("AWCVX-MIB", "awcEventCntSeverityExternalWarning"), ("AWCVX-MIB", "awcEventCntSeveritySystemInfo"), ("AWCVX-MIB", "awcEventCntSeverityProtocolInfo"), ("AWCVX-MIB", "awcEventCntSeverityPortInfo"), ("AWCVX-MIB", "awcEventCntSeverityExternalInfo"), ("AWCVX-MIB", "awcEventDispSeverityNULL"), ("AWCVX-MIB", "awcEventDispSeveritySilent"), ("AWCVX-MIB", "awcEventDispSeveritySystemFatal"), ("AWCVX-MIB", "awcEventDispSeverityProtocolFatal"), ("AWCVX-MIB", "awcEventDispSeverityPortFatal"), ("AWCVX-MIB", "awcEventDispSeveritySystemAlert"), ("AWCVX-MIB", "awcEventDispSeverityProtocolAlert"), ("AWCVX-MIB", "awcEventDispSeverityPortAlert"), ("AWCVX-MIB", "awcEventDispSeverityExternalAlert"), ("AWCVX-MIB", "awcEventDispSeveritySystemWarning"), ("AWCVX-MIB", "awcEventDispSeverityProtocolWarning"), ("AWCVX-MIB", "awcEventDispSeverityPortWarning"), ("AWCVX-MIB", "awcEventDispSeverityExternalWarning"), ("AWCVX-MIB", "awcEventDispSeveritySystemInfo"), ("AWCVX-MIB", "awcEventDispSeverityProtocolInfo"), ("AWCVX-MIB", "awcEventDispSeverityPortInfo"), ("AWCVX-MIB", "awcEventDispSeverityExternalInfo"), ("AWCVX-MIB", "awcEventSyslogAddr"), ("AWCVX-MIB", "awcEventSyslogFacility"), ("AWCVX-MIB", "awcEventTraceStationSeverity"), ("AWCVX-MIB", "awcEventTraceLogSize"), ("AWCVX-MIB", "awcEventTracePacketLen"), ("AWCVX-MIB", "awcEventID"), ("AWCVX-MIB", "awcEventTime"), ("AWCVX-MIB", "awcEventSeverity"), ("AWCVX-MIB", "awcEventDescription"), ("AWCVX-MIB", "awcEventType"), ("AWCVX-MIB", "awcEventUseCiscoFormat"), ("AWCVX-MIB", "awcDot11AuthenticateFailDisposition"), ("AWCVX-MIB", "awcDot11DeauthenticateDisposition"), ("AWCVX-MIB", "awcDot11DisassociateDisposition"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcEventLogGroup = awcEventLogGroup.setStatus('current')
if mibBuilder.loadTexts: awcEventLogGroup.setDescription('Standard information to support operation of the Event Log.')
awcEtherMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 15)).setObjects(("AWCVX-MIB", "awcEtherIfSpeedSelect"), ("AWCVX-MIB", "awcEtherDuplex"), ("AWCVX-MIB", "awcEtherCamSize"), ("AWCVX-MIB", "awcEtherEnableSwCam"), ("AWCVX-MIB", "awcEtherForcePortUnblock"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcEtherMIBGroup = awcEtherMIBGroup.setStatus('current')
if mibBuilder.loadTexts: awcEtherMIBGroup.setDescription('Standard information to support operation of the Ethernet Controller.')
awcPolicyGroupsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 16)).setObjects(("AWCVX-MIB", "awcPolGrpName"), ("AWCVX-MIB", "awcPolGrpStatus"), ("AWCVX-MIB", "awcPolGrpInEthertypeFilterId"), ("AWCVX-MIB", "awcPolGrpOutEthertypeFilterId"), ("AWCVX-MIB", "awcPolGrpInIpProtoFilterId"), ("AWCVX-MIB", "awcPolGrpOutIpProtoFilterId"), ("AWCVX-MIB", "awcPolGrpInIpPortFilterId"), ("AWCVX-MIB", "awcPolGrpOutIpPortFilterId"), ("AWCVX-MIB", "awcDscpToCosMapEnable"), ("AWCVX-MIB", "awcDscpToCosMapCos"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcPolicyGroupsGroup = awcPolicyGroupsGroup.setStatus('current')
if mibBuilder.loadTexts: awcPolicyGroupsGroup.setDescription('Standard information to support operation of Policy Groups.')
awcDdpIAPPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 17)).setObjects(("AWCVX-MIB", "awcIappMcastIpAddr"), ("AWCVX-MIB", "awcIappPort"), ("AWCVX-MIB", "awcP802dot1XVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcDdpIAPPGroup = awcDdpIAPPGroup.setStatus('current')
if mibBuilder.loadTexts: awcDdpIAPPGroup.setDescription('Standard information to support operation of the DDP and IAPP protocols.')
awcHotStandbyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 18)).setObjects(("AWCVX-MIB", "awcHotStandbyMACAddr"), ("AWCVX-MIB", "awcHotStandbyPollingFrequency"), ("AWCVX-MIB", "awcHotStandbyPollingTimeOut"), ("AWCVX-MIB", "awcHotStandbyInHotStandby"), ("AWCVX-MIB", "awcHotStandbyState"), ("AWCVX-MIB", "awcHotStandbyStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcHotStandbyGroup = awcHotStandbyGroup.setStatus('current')
if mibBuilder.loadTexts: awcHotStandbyGroup.setDescription('Standard information to support operation of an AP in the Hot Standby mode.')
awcAaaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 19)).setObjects(("AWCVX-MIB", "awcAaaServerPriority"), ("AWCVX-MIB", "awcAaaServerProtocol"), ("AWCVX-MIB", "awcAaaServerName"), ("AWCVX-MIB", "awcAaaServerPort"), ("AWCVX-MIB", "awcAaaServerTimeout"), ("AWCVX-MIB", "awcAaaClientName"), ("AWCVX-MIB", "awcAaaServerSharedSecret"), ("AWCVX-MIB", "awcAaaServer8021xCapabilityEnabled"), ("AWCVX-MIB", "awcAaaServerMacAddrAuthEnabled"), ("AWCVX-MIB", "awcAaaServerAdminAuthEnabled"), ("AWCVX-MIB", "awcAaaServerMipAuthEnabled"), ("AWCVX-MIB", "awcAaaServerMaxRetransmission"), ("AWCVX-MIB", "awcAcctServerPriority"), ("AWCVX-MIB", "awcAcctServerProtocol"), ("AWCVX-MIB", "awcAcctServerName"), ("AWCVX-MIB", "awcAcctServerPort"), ("AWCVX-MIB", "awcAcctServerTimeout"), ("AWCVX-MIB", "awcAcctServerUpdateEnable"), ("AWCVX-MIB", "awcAcctServerUpdateDelay"), ("AWCVX-MIB", "awcAcctClientName"), ("AWCVX-MIB", "awcAcctSecureEnabled"), ("AWCVX-MIB", "awcAcctGeneralEnabled"), ("AWCVX-MIB", "awcAcctServerSharedSecret"), ("AWCVX-MIB", "awcAcctServerMaxRetransmission"), ("AWCVX-MIB", "awcAcctEnable"), ("AWCVX-MIB", "awcAcctStopDelayEnable"), ("AWCVX-MIB", "awcAcctStopDelayTime"), ("AWCVX-MIB", "awcAaaServerPrimaryReattemptPeriod"), ("AWCVX-MIB", "awcAaaServerDot1xAuthCurrent"), ("AWCVX-MIB", "awcAaaServerMacAddrAuthCurrent"), ("AWCVX-MIB", "awcAaaServerAdminAuthCurrent"), ("AWCVX-MIB", "awcAaaServerMipAuthCurrent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcAaaGroup = awcAaaGroup.setStatus('current')
if mibBuilder.loadTexts: awcAaaGroup.setDescription('Standard information to support configuration of RADIUS and TACACS+ client operation.')
awcProtocolFiltersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 20)).setObjects(("AWCVX-MIB", "awcPfEtSetId"), ("AWCVX-MIB", "awcPfEtSetName"), ("AWCVX-MIB", "awcPfEtDefaultDisposition"), ("AWCVX-MIB", "awcPfEtDefaultUcastTimeToLive"), ("AWCVX-MIB", "awcPfEtDefaultNUcastTimeToLive"), ("AWCVX-MIB", "awcPfEtSetStatus"), ("AWCVX-MIB", "awcPfEtEthertype"), ("AWCVX-MIB", "awcPfEtDisposition"), ("AWCVX-MIB", "awcPfEtUserPriority"), ("AWCVX-MIB", "awcPfEtUcastTimeToLive"), ("AWCVX-MIB", "awcPfEtNUcastTimeToLive"), ("AWCVX-MIB", "awcPfEtAlert"), ("AWCVX-MIB", "awcPfEtStatus"), ("AWCVX-MIB", "awcPfIppSetId"), ("AWCVX-MIB", "awcPfIppSetName"), ("AWCVX-MIB", "awcPfIppDefaultDisposition"), ("AWCVX-MIB", "awcPfIppDefaultUcastTimeToLive"), ("AWCVX-MIB", "awcPfIppDefaultNUcastTimeToLive"), ("AWCVX-MIB", "awcPfIppSetStatus"), ("AWCVX-MIB", "awcPfIppIpProtocol"), ("AWCVX-MIB", "awcPfIppDisposition"), ("AWCVX-MIB", "awcPfIppUserPriority"), ("AWCVX-MIB", "awcPfIppUcastTimeToLive"), ("AWCVX-MIB", "awcPfIppNUcastTimeToLive"), ("AWCVX-MIB", "awcPfIppAlert"), ("AWCVX-MIB", "awcPfIppStatus"), ("AWCVX-MIB", "awcPfIptSetId"), ("AWCVX-MIB", "awcPfIptSetName"), ("AWCVX-MIB", "awcPfIptDefaultDisposition"), ("AWCVX-MIB", "awcPfIptDefaultUcastTimeToLive"), ("AWCVX-MIB", "awcPfIptDefaultNUcastTimeToLive"), ("AWCVX-MIB", "awcPfIptSetStatus"), ("AWCVX-MIB", "awcPfIptIpPort"), ("AWCVX-MIB", "awcPfIptDisposition"), ("AWCVX-MIB", "awcPfIptUserPriority"), ("AWCVX-MIB", "awcPfIptUcastTimeToLive"), ("AWCVX-MIB", "awcPfIptNUcastTimeToLive"), ("AWCVX-MIB", "awcPfIptAlert"), ("AWCVX-MIB", "awcPfIptStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcProtocolFiltersGroup = awcProtocolFiltersGroup.setStatus('current')
if mibBuilder.loadTexts: awcProtocolFiltersGroup.setDescription('Standard information to support configuration of static protocol filters on the AP.')
awcMobileIpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 21)).setObjects(("AWCVX-MIB", "enableMobileIP"), ("AWCVX-MIB", "mipSAIpEnd"), ("AWCVX-MIB", "mipSAGroupSPI"), ("AWCVX-MIB", "mipSAGroupKey"), ("AWCVX-MIB", "mipSAStatus"), ("AWCVX-MIB", "awcmipDebug"), ("AWCVX-MIB", "awcprimAAP"), ("AWCVX-MIB", "awcsec1AAP"), ("AWCVX-MIB", "awcsec2AAP"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcMobileIpGroup = awcMobileIpGroup.setStatus('current')
if mibBuilder.loadTexts: awcMobileIpGroup.setDescription('Information to support configuration of proxy mobile IP on the AP.')
awcEthernetLostGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 22)).setObjects(("AWCVX-MIB", "awcEtherLostEthernetSeconds"), ("AWCVX-MIB", "awcEtherLostEthernetAction"), ("AWCVX-MIB", "awcEtherLostEthernetSSID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcEthernetLostGroup = awcEthernetLostGroup.setStatus('current')
if mibBuilder.loadTexts: awcEthernetLostGroup.setDescription('Information to support AP in case Ethernet connection is lost.')
awc802dot11GroupExt1 = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 23)).setObjects(("AWCVX-MIB", "awcDot11NonRootMobility"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awc802dot11GroupExt1 = awc802dot11GroupExt1.setStatus('current')
if mibBuilder.loadTexts: awc802dot11GroupExt1.setDescription('Configuration information for IEEE 802.11 radio driver and firmware.')
awcForwardTblGroupExt1 = ObjectGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 24)).setObjects(("AWCVX-MIB", "awcFtEnableMcastMapping"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcForwardTblGroupExt1 = awcForwardTblGroupExt1.setStatus('current')
if mibBuilder.loadTexts: awcForwardTblGroupExt1.setDescription('Information to support configuration of the Forwarding Table.')
awcTrapLogGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 522, 3, 100, 2, 100)).setObjects(("AWCVX-MIB", "awcTrapLog"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    awcTrapLogGroup = awcTrapLogGroup.setStatus('current')
if mibBuilder.loadTexts: awcTrapLogGroup.setDescription('SNMP trap corresponding to an event with a Severity Level requiring Notify Disposition while awcEventAlertSNMP is true.')
mibBuilder.exportSymbols("AWCVX-MIB", defaultWebRoot=defaultWebRoot, awcPrFltIpProtocolEntry=awcPrFltIpProtocolEntry, awcDot11AssociatedStationCount=awcDot11AssociatedStationCount, AwcDot11EventDisposition=AwcDot11EventDisposition, awcDot11mac=awcDot11mac, awcEventSyslogAddr=awcEventSyslogAddr, awcEtherEnableSwCam=awcEtherEnableSwCam, awcEventDispSeveritySystemWarning=awcEventDispSeveritySystemWarning, awcAcctSecureEnabled=awcAcctSecureEnabled, awcIfOutDiscardsCoS6=awcIfOutDiscardsCoS6, awcDot11DesiredSSIDEnableProxyMobileIP=awcDot11DesiredSSIDEnableProxyMobileIP, awcDot11DesiredBSSIndex=awcDot11DesiredBSSIndex, awcAcctServerUpdateEnable=awcAcctServerUpdateEnable, vxWorksVersion=vxWorksVersion, awcDot11DesiredBSSLength=awcDot11DesiredBSSLength, awcDot11LEAPUserName=awcDot11LEAPUserName, awcDot11TpFdbClientState=awcDot11TpFdbClientState, awcFtClientSTASelf=awcFtClientSTASelf, bootconfigLogServerAddr=bootconfigLogServerAddr, awcEtherLostEthernetSeconds=awcEtherLostEthernetSeconds, awcPolGrpTable=awcPolGrpTable, awcPolGrpName=awcPolGrpName, awcPolGrpOutIpProtoFilterId=awcPolGrpOutIpProtoFilterId, awcPrFltIpPortEntry=awcPrFltIpPortEntry, awcFileXferTftpPort=awcFileXferTftpPort, awcP802dot1XVersion=awcP802dot1XVersion, awcHttpd=awcHttpd, bootconfigSaveServerResponse=bootconfigSaveServerResponse, awcFtBridge=awcFtBridge, awcEventCntSeveritySystemInfo=awcEventCntSeveritySystemInfo, protectLegalPage=protectLegalPage, awcPfIppStatus=awcPfIppStatus, awcFtRepeaterSelf=awcFtRepeaterSelf, awcDot11ChanSelectTable=awcDot11ChanSelectTable, awcDot11TpFdbLatestTxLongRetries=awcDot11TpFdbLatestTxLongRetries, awcDot1dTpPortDefaultUcastAllowedToGoTo=awcDot1dTpPortDefaultUcastAllowedToGoTo, awcEventCntSeverityExternalWarning=awcEventCntSeverityExternalWarning, awcForwardTblGroupExt1=awcForwardTblGroupExt1, bootconfigDhcpClassID=bootconfigDhcpClassID, awcDot11Compatible4500=awcDot11Compatible4500, resolverDomainSuffix=resolverDomainSuffix, awcEventCntSeverityPortWarning=awcEventCntSeverityPortWarning, awcAaaServerMipAuthEnabled=awcAaaServerMipAuthEnabled, awcAaaServerMacAddrAuthCurrent=awcAaaServerMacAddrAuthCurrent, AwcInvokeCommand=AwcInvokeCommand, awcDot11res=awcDot11res, awcTpFdbToAlertDestPktsImmed=awcTpFdbToAlertDestPktsImmed, awcPfIptSetId=awcPfIptSetId, awcPfIptDefaultDisposition=awcPfIptDefaultDisposition, awcDnsResGroup=awcDnsResGroup, awcEventEntry=awcEventEntry, defaultResolverDomainServerPriority=defaultResolverDomainServerPriority, awcPfIptUcastTimeToLive=awcPfIptUcastTimeToLive, awcEventDisposition=awcEventDisposition, awcDot11SendIGMPGeneralQuery=awcDot11SendIGMPGeneralQuery, awcPolGrpInIpProtoFilterId=awcPolGrpInIpProtoFilterId, awcPfIppAlert=awcPfIppAlert, awcDot11DesiredBSSEntry=awcDot11DesiredBSSEntry, awcUserMgrGroup=awcUserMgrGroup, awcDot11PhyFHSSTable=awcDot11PhyFHSSTable, awcIfOutDiscardsCoS5=awcIfOutDiscardsCoS5, awcFtTimeoutSecClientSTA=awcFtTimeoutSecClientSTA, defaultResolverDomainServer=defaultResolverDomainServer, awcEventTable=awcEventTable, awcSystemGroup=awcSystemGroup, awcDot11CurrentChannel=awcDot11CurrentChannel, awcDot11StationRole=awcDot11StationRole, awcVx=awcVx, serialBaud=serialBaud, awcIfMSDUMaxLength=awcIfMSDUMaxLength, awcDot11DeauthenticateDisposition=awcDot11DeauthenticateDisposition, awcAcctServerEntry=awcAcctServerEntry, awcEventCntSeverityProtocolWarning=awcEventCntSeverityProtocolWarning, awcDot11PrivacyEntry=awcDot11PrivacyEntry, awcDot11TpFdbVlanId=awcDot11TpFdbVlanId, awcAcctServerMaxRetransmission=awcAcctServerMaxRetransmission, awcPrFltIpPortTable=awcPrFltIpPortTable, awcDot11AuthenticationRequireEAP=awcDot11AuthenticationRequireEAP, bootconfigDev=bootconfigDev, awcAaaServerMaxRetransmission=awcAaaServerMaxRetransmission, bootconfigHostName=bootconfigHostName, defaultResolverDomain=defaultResolverDomain, awcEtherCamSize=awcEtherCamSize, awcTpFdbClassID=awcTpFdbClassID, awcDot11TxDeferEnergyCount=awcDot11TxDeferEnergyCount, awcPfIppSetId=awcPfIppSetId, bootconfigBootProtocol=bootconfigBootProtocol, awcTpFdbDdpLoad=awcTpFdbDdpLoad, awcProtocolFiltersGroup=awcProtocolFiltersGroup, awcTpFdbSrcErrorPktsImmed=awcTpFdbSrcErrorPktsImmed, awcDot11AssignedAIDEntry=awcDot11AssignedAIDEntry, awcFtEnableMacOrEapAuth=awcFtEnableMacOrEapAuth, bootconfigVx=bootconfigVx, awcPolGrpOutEthertypeFilterId=awcPolGrpOutEthertypeFilterId, awcAaaServerTimeout=awcAaaServerTimeout, awcEventDispSeverityProtocolFatal=awcEventDispSeverityProtocolFatal, defaultResolverDomainServerTable=defaultResolverDomainServerTable, awcFtp=awcFtp, awcEventType=awcEventType, awcDot11AuthenticatedStationCount=awcDot11AuthenticatedStationCount, awcDot11AuxSSIDAuthAlgEnable=awcDot11AuxSSIDAuthAlgEnable, userMgrCapabilities=userMgrCapabilities, enableSTP=enableSTP, awcFtBridgeSelf=awcFtBridgeSelf, bootconfigNameServer=bootconfigNameServer, awcDot11PrivacyOptionImplementedMaxRate=awcDot11PrivacyOptionImplementedMaxRate, awcFtTimeoutSecBridgeHost=awcFtTimeoutSecBridgeHost, awcAcctStopDelayEnable=awcAcctStopDelayEnable, awcFileXferCmdStatusFileSave=awcFileXferCmdStatusFileSave, awcDot11TpFdbAID=awcDot11TpFdbAID, awcEventDispSeverityExternalWarning=awcEventDispSeverityExternalWarning, bootconfigNameServerPriority=bootconfigNameServerPriority, awcDot11RoamedStationCount=awcDot11RoamedStationCount, AwcEventDisposition=AwcEventDisposition, AwcHotStandbyState=AwcHotStandbyState, awcDot11PHYType=awcDot11PHYType, awcTpFdbAlertEntry=awcTpFdbAlertEntry, awcHotStandby=awcHotStandby, awcFileXferCmdInvokeFileSave=awcFileXferCmdInvokeFileSave, awcAcctServerPriority=awcAcctServerPriority, awcDot11DisassociateCount=awcDot11DisassociateCount, awcAaaServerAdminAuthCurrent=awcAaaServerAdminAuthCurrent, awcEventDetailDefault=awcEventDetailDefault, awcEventDispSeverityProtocolAlert=awcEventDispSeverityProtocolAlert, awcUserMgr=awcUserMgr, awcDscpToCosMapTable=awcDscpToCosMapTable, awcAcctServerProtocol=awcAcctServerProtocol, awcPfIptSetName=awcPfIptSetName, awcRipConfig=awcRipConfig, awcFtTimeoutSecBridgeRoot=awcFtTimeoutSecBridgeRoot, awcAcctClientName=awcAcctClientName, awcTpFdbSrcPktsImmed=awcTpFdbSrcPktsImmed, awcPfIptAlert=awcPfIptAlert, serialStopBits=serialStopBits, awcTpFdbDdpProdDevID=awcTpFdbDdpProdDevID, awcDot11UseAWCExtensions=awcDot11UseAWCExtensions, awcDot11resAttribute=awcDot11resAttribute, awcDot11DecapPktsMMH=awcDot11DecapPktsMMH, awcEventCntSeverityPortFatal=awcEventCntSeverityPortFatal, mipSAIpStart=mipSAIpStart, awcFileXferPassword=awcFileXferPassword, awcEventCntSeveritySystemWarning=awcEventCntSeveritySystemWarning, awcDot11CountersEntry=awcDot11CountersEntry, awcEventSeverityDispHtmlConsole=awcEventSeverityDispHtmlConsole, awcPfIppNUcastTimeToLive=awcPfIppNUcastTimeToLive, awcDot11AuxSSIDDefaultPolId=awcDot11AuxSSIDDefaultPolId, awcVxConformance=awcVxConformance, awcTpFdbDdpNumAnnounceSent=awcTpFdbDdpNumAnnounceSent, awcPolGrpEntry=awcPolGrpEntry, awcDot11WEPDefaultKeyValue=awcDot11WEPDefaultKeyValue, awcPfIptDisposition=awcPfIptDisposition, awcHotStandbyStatus=awcHotStandbyStatus, awcDot11PhyFHSSEntry=awcDot11PhyFHSSEntry, awcDot11AuxSSIDAuthAlgTable=awcDot11AuxSSIDAuthAlgTable, mipSAStatus=mipSAStatus, awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo=awcDot11AuxSSIDAuthAlgDefaultUcastAllowedToGoTo, awcPolGrpInEthertypeFilterId=awcPolGrpInEthertypeFilterId, awcDot11TpFdbCapabilities=awcDot11TpFdbCapabilities, awcTpFdbDestErrorPktsImmed=awcTpFdbDestErrorPktsImmed, awcMobileIP=awcMobileIP, awcPrFltIpProtocolTable=awcPrFltIpProtocolTable, AwcPolId=AwcPolId, awcAaaServer8021xCapabilityEnabled=awcAaaServer8021xCapabilityEnabled, bootconfigSntpServer=bootconfigSntpServer, userMgrConfigEntry=userMgrConfigEntry, awcDscpToCosMapCos=awcDscpToCosMapCos, awcsec1AAP=awcsec1AAP, awcIfEntry=awcIfEntry, bootconfigBootCount=bootconfigBootCount, awcIfDefaultPhysAddress=awcIfDefaultPhysAddress, awcDot11DesiredBSSTable=awcDot11DesiredBSSTable, awcDot11TpFdbLatestRxSignalStrength=awcDot11TpFdbLatestRxSignalStrength, awcTpFdbTable=awcTpFdbTable, awcDot11ModulationType=awcDot11ModulationType, awcDot11DesiredSSIDNumAssociatedSTA=awcDot11DesiredSSIDNumAssociatedSTA, awcDot11ForceReqFirmwareVersion=awcDot11ForceReqFirmwareVersion, awcDot1dTpPortDefaultInIpPortFilterId=awcDot1dTpPortDefaultInIpPortFilterId, awcDot11WEPKeyMaxLen=awcDot11WEPKeyMaxLen, awcsec2AAP=awcsec2AAP, enableTelnet=enableTelnet, bootconfigHostAddr=bootconfigHostAddr, userMgrConfigTable=userMgrConfigTable, awcPfEtUserPriority=awcPfEtUserPriority, awcFtEnableMacAuthServer=awcFtEnableMacAuthServer, awcDot11CurrentCarrierSet=awcDot11CurrentCarrierSet, awcPfEtUcastTimeToLive=awcPfEtUcastTimeToLive, awcEventDispSeverityNULL=awcEventDispSeverityNULL, awcDot11LEAPPassword=awcDot11LEAPPassword, awcHotStandbyPollingFrequency=awcHotStandbyPollingFrequency, awcPrFltEthertypeSetEntry=awcPrFltEthertypeSetEntry, enableWDB=enableWDB, awcPfEtNUcastTimeToLive=awcPfEtNUcastTimeToLive, awcEventSyslogFacility=awcEventSyslogFacility, awcAaaServerName=awcAaaServerName, awcAaaServerPriority=awcAaaServerPriority, awcEtherForcePortUnblock=awcEtherForcePortUnblock, awcDot11TpFdbCurrentBSS=awcDot11TpFdbCurrentBSS, awcDot11QoSCoS=awcDot11QoSCoS, awcEventUseCiscoFormat=awcEventUseCiscoFormat, awcEtherLostEthernetSSID=awcEtherLostEthernetSSID, awcEventTraceLogSize=awcEventTraceLogSize, awcDot11AuthenticationAlgorithmsTable=awcDot11AuthenticationAlgorithmsTable, AwcPfDisposition=AwcPfDisposition, awcDot11QBSSElementEnabled=awcDot11QBSSElementEnabled, awcAaaClientName=awcAaaClientName, AwcDot11ClientState=AwcDot11ClientState, awcAcctServerName=awcAcctServerName, awcFtEnableMcastMapping=awcFtEnableMcastMapping, awcDot11PowerManagementSubMode=awcDot11PowerManagementSubMode, awcFtMcastAddr=awcFtMcastAddr, awcEventDispSeverityExternalAlert=awcEventDispSeverityExternalAlert, awcDot11SymbolExtensionsImplemented=awcDot11SymbolExtensionsImplemented, awcEventCntSeveritySystemAlert=awcEventCntSeveritySystemAlert, awcDot11TpFdbEntry=awcDot11TpFdbEntry, mipSAIpEnd=mipSAIpEnd, awcAaaAuthConfig=awcAaaAuthConfig, awcDot11AuxSSIDDefaultVlanId=awcDot11AuxSSIDDefaultVlanId, awcFtRogueApAlertTimeout=awcFtRogueApAlertTimeout, awcTpFdbDdpNumAssociated=awcTpFdbDdpNumAssociated, awcTpFdbToAlertDestOctetsImmed=awcTpFdbToAlertDestOctetsImmed, awcFileXferFilesFLASH=awcFileXferFilesFLASH, awcDot11TpFdbRxWEPErrors=awcDot11TpFdbRxWEPErrors, awcDevIDtxt=awcDevIDtxt, awcPolGrpStatus=awcPolGrpStatus, enableRebootKey=enableRebootKey, awcSntp=awcSntp, awcIfAdoptPrimaryIdentity=awcIfAdoptPrimaryIdentity, awcDot11EncapPktsMMH=awcDot11EncapPktsMMH, awcDot11AuxiliarySSIDLength=awcDot11AuxiliarySSIDLength, awcEventSeverityDispHtmlGUI=awcEventSeverityDispHtmlGUI, awcEventCntSeverityProtocolAlert=awcEventCntSeverityProtocolAlert, awcTpFdbAlertSentAlertTypePktsImmed=awcTpFdbAlertSentAlertTypePktsImmed, awcFtTimeoutSecUnknown=awcFtTimeoutSecUnknown, awcPfIppDefaultDisposition=awcPfIppDefaultDisposition, awcPfIptIpPort=awcPfIptIpPort, awcEventDispSeveritySilent=awcEventDispSeveritySilent, awcDot11DesiredBSS=awcDot11DesiredBSS, awcTpFdbDestOctetsImmed=awcTpFdbDestOctetsImmed, awcFtStatistics=awcFtStatistics, awcFtAccessPoint=awcFtAccessPoint, awcFtBridgeRoot=awcFtBridgeRoot, awcPfEtSetStatus=awcPfEtSetStatus, awcDot11DecapErrorsMMH=awcDot11DecapErrorsMMH, awcDot11DesiredSSIDDefaultVlanId=awcDot11DesiredSSIDDefaultVlanId, awcDot11Compatible3100=awcDot11Compatible3100, awcIfOutDiscardsCoS4=awcIfOutDiscardsCoS4, awcDot11SupportedDataRatesPrivacyImplemented=awcDot11SupportedDataRatesPrivacyImplemented, awcFtConfig=awcFtConfig, awcDot11TpFdbPreferredTxRate=awcDot11TpFdbPreferredTxRate, awcPrFltEthertypeTable=awcPrFltEthertypeTable, awcDot11DeauthenticateCount=awcDot11DeauthenticateCount, awcIfIpAddress=awcIfIpAddress, awcEventCntSeverityProtocolFatal=awcEventCntSeverityProtocolFatal, awcFtEnableAwcTpFdbTable=awcFtEnableAwcTpFdbTable)
mibBuilder.exportSymbols("AWCVX-MIB", awcEtherIfSpeedSelect=awcEtherIfSpeedSelect, bootconfigCmdInvokeIniLoad=bootconfigCmdInvokeIniLoad, awcDot1dTpPortDefaultOutIpPortFilterId=awcDot1dTpPortDefaultOutIpPortFilterId, awcEventTracePacketLen=awcEventTracePacketLen, awcDot1dTpPortEntry=awcDot1dTpPortEntry, awcDot11SsidMismatchCount=awcDot11SsidMismatchCount, awcDot11QoSCWmin=awcDot11QoSCWmin, getWebUI=getWebUI, awcTpFdbDdpAddress=awcTpFdbDdpAddress, awcPolGrpOutIpPortFilterId=awcPolGrpOutIpPortFilterId, AwcVlanId=AwcVlanId, AwcDdpProdDevID=AwcDdpProdDevID, bootblockVersion=bootblockVersion, awcDot1dTpPortMaxNUcastPerSecond=awcDot1dTpPortMaxNUcastPerSecond, awcAcctServerTable=awcAcctServerTable, awcAcctServerPort=awcAcctServerPort, awcDot11TpFdbListenInterval=awcDot11TpFdbListenInterval, awcPfEtDisposition=awcPfEtDisposition, awcTpFdbSrcErrorOctetsImmed=awcTpFdbSrcErrorOctetsImmed, awcDot11AuxSSIDIndex=awcDot11AuxSSIDIndex, awcFtMaxNumEntries=awcFtMaxNumEntries, awcEventSeverity=awcEventSeverity, awcDot11smt=awcDot11smt, awcHttpdGroup=awcHttpdGroup, awcTpFdbDestPktsImmed=awcTpFdbDestPktsImmed, WEPKeytype128=WEPKeytype128, awcEventDispSeverityExternalInfo=awcEventDispSeverityExternalInfo, userMgrStatus=userMgrStatus, serialAdminStatus=serialAdminStatus, awcPfEtDefaultNUcastTimeToLive=awcPfEtDefaultNUcastTimeToLive, awcDot11PhyOperationTable=awcDot11PhyOperationTable, AwcHotStandbyStatus=AwcHotStandbyStatus, awcPfIptDefaultUcastTimeToLive=awcPfIptDefaultUcastTimeToLive, awcDot11NonRootMobility=awcDot11NonRootMobility, awcDot11EnetEncapsulationDefault=awcDot11EnetEncapsulationDefault, creationDate=creationDate, serialDataBits=serialDataBits, bootconfigSubnetMask=bootconfigSubnetMask, awcDot11AuxSSIDNumAssociatedSTA=awcDot11AuxSSIDNumAssociatedSTA, awcEventDispSeveritySystemFatal=awcEventDispSeveritySystemFatal, awcAaaServerProtocol=awcAaaServerProtocol, awcDot11WEPDefaultKeysTable=awcDot11WEPDefaultKeysTable, awcDot11WEPDefaultKeyMaxIndex=awcDot11WEPDefaultKeyMaxIndex, awcDot11ResourceInfoEntry=awcDot11ResourceInfoEntry, awcDot11RxMacCrcErrorCount=awcDot11RxMacCrcErrorCount, awcFtDsHost=awcFtDsHost, awcAaaServerTable=awcAaaServerTable, sysFlags=sysFlags, awcPfIppSetStatus=awcPfIppSetStatus, awcTpFdbFromAlertSrcOctetsImmed=awcTpFdbFromAlertSrcOctetsImmed, awcFileXferCmdInvokeFileLoad=awcFileXferCmdInvokeFileLoad, awcPfIppUcastTimeToLive=awcPfIppUcastTimeToLive, awc802dot11GroupExt1=awc802dot11GroupExt1, awcDot11ChannelAutoImplemented=awcDot11ChannelAutoImplemented, bootconfigMultOfferTimeout=bootconfigMultOfferTimeout, awcAaaServerMipAuthCurrent=awcAaaServerMipAuthCurrent, awcAcctEnable=awcAcctEnable, awcTpFdbDdpRadioDevID=awcTpFdbDdpRadioDevID, awcEventCntSeverityExternalAlert=awcEventCntSeverityExternalAlert, awcConsoleAutoApply=awcConsoleAutoApply, awcEventDisplayWallClockTime=awcEventDisplayWallClockTime, awcEventLogGroup=awcEventLogGroup, awcTpFdbDdpSwVerMajor=awcTpFdbDdpSwVerMajor, AwcEventSeverity=AwcEventSeverity, awcDot11TpFdbSSID=awcDot11TpFdbSSID, awcDot11AssignedAIDTable=awcDot11AssignedAIDTable, awcFileXferCmdStatusFileLoad=awcFileXferCmdStatusFileLoad, awcAaa=awcAaa, awcMobileIpGroup=awcMobileIpGroup, mipSAEntry=mipSAEntry, awcDot11AuxiliarySSIDTable=awcDot11AuxiliarySSIDTable, awcPfEtDefaultUcastTimeToLive=awcPfEtDefaultUcastTimeToLive, awcDot11AuxSSID=awcDot11AuxSSID, awcFileXferFileFirmwareSystem=awcFileXferFileFirmwareSystem, awcTpFdbDdpDistFromDS=awcTpFdbDdpDistFromDS, awcDot11AccessPointCountersEntry=awcDot11AccessPointCountersEntry, awcPfIptNUcastTimeToLive=awcPfIptNUcastTimeToLive, serialDevFd=serialDevFd, awc802dot11Group=awc802dot11Group, awcOemOUI=awcOemOUI, awcDot11PreambleType=awcDot11PreambleType, awcPfEtAlert=awcPfEtAlert, awcTpFdbAlertRcvdAlertTypeOctetsImmed=awcTpFdbAlertRcvdAlertTypeOctetsImmed, awcDot11ResourceInfoTable=awcDot11ResourceInfoTable, awcDot1dTpPortDefaultInIpProtoFilterId=awcDot1dTpPortDefaultInIpProtoFilterId, awcPfEtDefaultDisposition=awcPfEtDefaultDisposition, awcEventDisplayUptimeAscending=awcEventDisplayUptimeAscending, awcPfEtSetName=awcPfEtSetName, awcDot11FirmwareBootstrapVersion=awcDot11FirmwareBootstrapVersion, awcTpFdbAlertTable=awcTpFdbAlertTable, awcDot11CountersTable=awcDot11CountersTable, bootconfigReadINI=bootconfigReadINI, awcTpFdbIPv4Addr=awcTpFdbIPv4Addr, awcOemHomeURL=awcOemHomeURL, awcDnsRes=awcDnsRes, awcDot11phy=awcDot11phy, awcFtTimeoutSecAccessPoint=awcFtTimeoutSecAccessPoint, awcDot11AssignedAID=awcDot11AssignedAID, awcDot11SupportedDataRatesPrivacyTable=awcDot11SupportedDataRatesPrivacyTable, awcPolGrpInIpPortFilterId=awcPolGrpInIpPortFilterId, userMgrPassword=userMgrPassword, userMgrUserIndex=userMgrUserIndex, awcSerialConfigTable=awcSerialConfigTable, awcEventTimestampGMT=awcEventTimestampGMT, awcTpFdbAlertAddress=awcTpFdbAlertAddress, awcDot11EncapErrorsMMH=awcDot11EncapErrorsMMH, awcTpFdbDdpSwVerBeta=awcTpFdbDdpSwVerBeta, awcHotStandbyGroup=awcHotStandbyGroup, awcEventDispSeverityPortFatal=awcEventDispSeverityPortFatal, awcPrFltIpPortSetTable=awcPrFltIpPortSetTable, awcDot11StationConfigTable=awcDot11StationConfigTable, bootconfigReqLeaseDuration=bootconfigReqLeaseDuration, awcDot11DesiredSSIDMicAlgorithm=awcDot11DesiredSSIDMicAlgorithm, awcEventDescription=awcEventDescription, awcDot11AuxSSIDEnableProxyMobileIP=awcDot11AuxSSIDEnableProxyMobileIP, awcIfOutDiscardsCoS1=awcIfOutDiscardsCoS1, awcProtocolFilters=awcProtocolFilters, bootconfigDhcpClientIdValue=bootconfigDhcpClientIdValue, awcTpFdbDestErrorOctetsImmed=awcTpFdbDestErrorOctetsImmed, awcHotStandbyPollingTimeOut=awcHotStandbyPollingTimeOut, awcPfEtEthertype=awcPfEtEthertype, defaultHelpRoot=defaultHelpRoot, serialParity=serialParity, AwcDot11WEPKeyPermuteAlgorithm=AwcDot11WEPKeyPermuteAlgorithm, bootconfigBootFile=bootconfigBootFile, awcTpFdbDdpTable=awcTpFdbDdpTable, bootconfigGateway=bootconfigGateway, awcDscpToCosMapEnable=awcDscpToCosMapEnable, awcDot11DecapExistsMMH=awcDot11DecapExistsMMH, aironet=aironet, awcDot11QoSCWmax=awcDot11QoSCWmax, resolverDomain=resolverDomain, awcTpFdbDdpSwVerMinor=awcTpFdbDdpSwVerMinor, awcDot11AssignedSTA=awcDot11AssignedSTA, awcAaaServerDot1xAuthCurrent=awcAaaServerDot1xAuthCurrent, awcmipDebug=awcmipDebug, enableMobileIP=enableMobileIP, awcFileXferProtocol=awcFileXferProtocol, awcVxVersion=awcVxVersion, awcTpFdbAlertRcvdAlertTypePktsImmed=awcTpFdbAlertRcvdAlertTypePktsImmed, awcPrFltEthertypeEntry=awcPrFltEthertypeEntry, awc802dot11=awc802dot11, awcHttpdPort=awcHttpdPort, awcIfOutDiscardsCoS7=awcIfOutDiscardsCoS7, awcAcctConfig=awcAcctConfig, awcDot1dTpPortDefaultOutIpProtoFilterId=awcDot1dTpPortDefaultOutIpProtoFilterId, bootconfigDhcpClientIdType=bootconfigDhcpClientIdType, awcAaaServerEntry=awcAaaServerEntry, serialTerminalLines=serialTerminalLines, awcSerialConfigEntry=awcSerialConfigEntry, awcSystem=awcSystem, awcEventDispSeverityProtocolInfo=awcEventDispSeverityProtocolInfo, awcEtherDuplex=awcEtherDuplex, awcDot1dTpPortDefaultNUcastAllowedToGoTo=awcDot1dTpPortDefaultNUcastAllowedToGoTo, awcPrFltIpProtocolSetEntry=awcPrFltIpProtocolSetEntry, awcDot11TpFdbTxLongRetries=awcDot11TpFdbTxLongRetries, awcAcctServerSharedSecret=awcAcctServerSharedSecret, awcFtRepeater=awcFtRepeater, awcDot11TpFdbAddress=awcDot11TpFdbAddress, awcDot11PhyDSSSTable=awcDot11PhyDSSSTable, sntpServer=sntpServer, awcSnmpGroup=awcSnmpGroup, awcDot11DisassociateDisposition=awcDot11DisassociateDisposition, AwcDot11MicAlgorithm=AwcDot11MicAlgorithm, bootconfigNameServerTable=bootconfigNameServerTable, awcOemNameShort=awcOemNameShort, awcAaaServerSharedSecret=awcAaaServerSharedSecret, awcIfIpNetMask=awcIfIpNetMask, awcPfIptStatus=awcPfIptStatus, mipSAGroupKey=mipSAGroupKey, awcDot11TpFdbTxShortRetries=awcDot11TpFdbTxShortRetries, awcPolicyGroupsGroup=awcPolicyGroupsGroup, awcFileXferUser=awcFileXferUser, awcDot11WEPDefaultKeysEntry=awcDot11WEPDefaultKeysEntry, userMgrUserName=userMgrUserName, awcDot11QoSEntry=awcDot11QoSEntry, awcFtDot1dTpFdbTableEnable=awcFtDot1dTpFdbTableEnable, awcFileXferFtpDirectory=awcFileXferFtpDirectory, awcTpFdbDdpEntry=awcTpFdbDdpEntry, awcDot11QBSSElementImplemented=awcDot11QBSSElementImplemented, awcDot11InfrastructureSSID=awcDot11InfrastructureSSID, awcHotStandbyInHotStandby=awcHotStandbyInHotStandby, awcAcctStopDelayTime=awcAcctStopDelayTime, awcDscpToCosMapDscp=awcDscpToCosMapDscp, awcPrFltIpProtocolSetTable=awcPrFltIpProtocolSetTable, awcDdpIAPP=awcDdpIAPP, awcPfIppDefaultUcastTimeToLive=awcPfIppDefaultUcastTimeToLive, awcPfEtStatus=awcPfEtStatus, enableSNTP=enableSNTP, awcEventCntSeverityExternalInfo=awcEventCntSeverityExternalInfo, awcAaaServerAdminAuthEnabled=awcAaaServerAdminAuthEnabled, awcAaaServerPort=awcAaaServerPort, cmdStatusGetWebUI=cmdStatusGetWebUI, resolverDomainServerEntry=resolverDomainServerEntry, awcDot11InfrastructureSSIDExclusive=awcDot11InfrastructureSSIDExclusive, awcDot11ChanSelectEnable=awcDot11ChanSelectEnable, awcFtClientSTA=awcFtClientSTA, awcLocateUnit=awcLocateUnit, awcDot11BridgeSpacing=awcDot11BridgeSpacing, awcHotStandbyState=awcHotStandbyState, awcSerialDev=awcSerialDev, awcDot11AccessPointCountersTable=awcDot11AccessPointCountersTable, snmpTrapDest=snmpTrapDest, awcVxCompliances=awcVxCompliances, awcIfOutDiscardsCoS2=awcIfOutDiscardsCoS2, awcFtTimeoutSecMcastAddr=awcFtTimeoutSecMcastAddr, awcForwardTbl=awcForwardTbl, awcDot1dTpPortDefaultOutEthertypeFilterId=awcDot1dTpPortDefaultOutEthertypeFilterId, awcIfPhysAddress=awcIfPhysAddress, awcPrFltIpPortSetEntry=awcPrFltIpPortSetEntry, awcOemName=awcOemName, awcDot11AuxSSIDAuthAlgRequireEAP=awcDot11AuxSSIDAuthAlgRequireEAP, awcDot11ChanSelectEntry=awcDot11ChanSelectEntry, awcDot11ChannelAutoEnabled=awcDot11ChannelAutoEnabled, awcTpFdbEntry=awcTpFdbEntry, awcEventDispSeverityProtocolWarning=awcEventDispSeverityProtocolWarning, awcFileXferFileFpgaPcmcia=awcFileXferFileFpgaPcmcia, awcPfIppUserPriority=awcPfIppUserPriority, awcAaaServerMacAddrAuthEnabled=awcAaaServerMacAddrAuthEnabled, awcIfTable=awcIfTable, resolverDomainServer=resolverDomainServer, awcEventAlertSNMP=awcEventAlertSNMP, enablePSPF=enablePSPF, awcEventTime=awcEventTime, awcprimAAP=awcprimAAP, awcDot11PrivacyTable=awcDot11PrivacyTable, awcFtBridgeHost=awcFtBridgeHost, enableDnsResolver=enableDnsResolver, awcEtherMIB=awcEtherMIB, awcEventDispSeveritySystemAlert=awcEventDispSeveritySystemAlert, awcEventAlertSyslog=awcEventAlertSyslog, awcDot11DesiredSSIDMaxAssociatedSTA=awcDot11DesiredSSIDMaxAssociatedSTA, awcDot11ChanSelectChannel=awcDot11ChanSelectChannel, snmpTrapCommunity=snmpTrapCommunity, awcTpFdbDdpSysName=awcTpFdbDdpSysName, serialDevIndex=serialDevIndex, awcDot11TpFdbTable=awcDot11TpFdbTable, awcForwardTblGroup=awcForwardTblGroup, awcDot11TpFdbSupportedDataRates=awcDot11TpFdbSupportedDataRates, awcDot11SupportedDataRatesPrivacyEntry=awcDot11SupportedDataRatesPrivacyEntry, awcEventCntSeverityPortAlert=awcEventCntSeverityPortAlert, awcFirstBoot=awcFirstBoot, awcDot11SupportedDataRatesPrivacyValue=awcDot11SupportedDataRatesPrivacyValue, awcDot1dTpPortDefaultInEthertypeFilterId=awcDot1dTpPortDefaultInEthertypeFilterId, awcDot11StationConfigEntry=awcDot11StationConfigEntry, awcDot11TpFdbLatestRxSignalQuality=awcDot11TpFdbLatestRxSignalQuality, awcDot11PhyDSSSEntry=awcDot11PhyDSSSEntry, awcIappMcastIpAddr=awcIappMcastIpAddr, AwcTpFdbClassID=AwcTpFdbClassID, awcEventUptimeModifiedGMT=awcEventUptimeModifiedGMT, bootconfigDomainName=bootconfigDomainName, awcPfIppIpProtocol=awcPfIppIpProtocol, awcPfIptSetStatus=awcPfIptSetStatus, serialOperStatus=serialOperStatus)
mibBuilder.exportSymbols("AWCVX-MIB", awcDot11TpFdbLatestTxShortRetries=awcDot11TpFdbLatestTxShortRetries, awcAcctServerTimeout=awcAcctServerTimeout, AwcDdpRadioDevID=AwcDdpRadioDevID, sysExceptionReboot=sysExceptionReboot, awcEtherLostEthernetAction=awcEtherLostEthernetAction, awcDevID=awcDevID, awcDot11AllowEncrypted=awcDot11AllowEncrypted, awcTpFdbDdpUptime=awcTpFdbDdpUptime, awcPfIptUserPriority=awcPfIptUserPriority, defaultSntpServer=defaultSntpServer, awcDot11DesiredSSIDDefaultPolId=awcDot11DesiredSSIDDefaultPolId, awcPolicyGroups=awcPolicyGroups, awcDot11AuthenticationDefaultUcastAllowedToGoTo=awcDot11AuthenticationDefaultUcastAllowedToGoTo, awcDot11AuthenticateFailDisposition=awcDot11AuthenticateFailDisposition, bootconfigServerConfigTimeout=bootconfigServerConfigTimeout, awcFtpGroup=awcFtpGroup, awcSntpGroup=awcSntpGroup, enableUserMgr=enableUserMgr, awcIfDefaultIpNetMask=awcIfDefaultIpNetMask, defaultFileServer=defaultFileServer, awcDot11DesiredSSIDInfrastructureWGB=awcDot11DesiredSSIDInfrastructureWGB, awcDot11WEPDefaultKeyIndex=awcDot11WEPDefaultKeyIndex, awcDot11DecapAccessMMH=awcDot11DecapAccessMMH, awcFtTimeoutSecRepeater=awcFtTimeoutSecRepeater, awcDscpToCosMapEntry=awcDscpToCosMapEntry, awcTpFdbSrcOctetsImmed=awcTpFdbSrcOctetsImmed, awcDot11WEPDefaultKeyLen=awcDot11WEPDefaultKeyLen, AwcPfPriority=AwcPfPriority, awcPfEtSetId=awcPfEtSetId, awcAaaServerPrimaryReattemptPeriod=awcAaaServerPrimaryReattemptPeriod, awcIfDefaultIpAddress=awcIfDefaultIpAddress, awcEthernetLostGroup=awcEthernetLostGroup, awcDot11SymbolExtensionsEnabled=awcDot11SymbolExtensionsEnabled, serialFlowControl=serialFlowControl, awcSerialDevGroup=awcSerialDevGroup, awcEventCntSeveritySystemFatal=awcEventCntSeveritySystemFatal, bootconfigNameServerEntry=bootconfigNameServerEntry, awcTrapLog=awcTrapLog, awcDot11AuthenticationAlgorithmsIndex=awcDot11AuthenticationAlgorithmsIndex, awcEtherMIBGroup=awcEtherMIBGroup, awcDot11PhyOperationEntry=awcDot11PhyOperationEntry, awcEventDispSeveritySystemInfo=awcEventDispSeveritySystemInfo, awcEventDispSeverityPortInfo=awcEventDispSeverityPortInfo, bootconfigVxGroup=bootconfigVxGroup, awcVxGroups=awcVxGroups, resolverDomainServerPriority=resolverDomainServerPriority, awcEventSeverityDispConsole=awcEventSeverityDispConsole, awcHotStandbyMACAddr=awcHotStandbyMACAddr, motherboardRevision=motherboardRevision, awcTpFdbAlertSentAlertTypeOctetsImmed=awcTpFdbAlertSentAlertTypeOctetsImmed, awcFileXferFileWebUI=awcFileXferFileWebUI, awcDdpIAPPGroup=awcDdpIAPPGroup, awcDot11MultipleSSIDPerBSSImplemented=awcDot11MultipleSSIDPerBSSImplemented, awcPfIppDisposition=awcPfIppDisposition, serialTerminalType=serialTerminalType, awcDot11AuxSSIDAuthAlgEntry=awcDot11AuxSSIDAuthAlgEntry, awcEventCntSeverityNULL=awcEventCntSeverityNULL, bootconfigClientName=bootconfigClientName, awcDot11QoSTable=awcDot11QoSTable, awcIfOutDiscardsCoS0=awcIfOutDiscardsCoS0, awcEventCntSeveritySilent=awcEventCntSeveritySilent, awcSnmp=awcSnmp, awcIfOutDiscardsCoS3=awcIfOutDiscardsCoS3, mipSAGroupSPI=mipSAGroupSPI, resolverDomainServerTable=resolverDomainServerTable, awcAaaGroup=awcAaaGroup, bootconfigCmdStatusIniLoad=bootconfigCmdStatusIniLoad, awcDot11AuxSSIDMaxAssociatedSTA=awcDot11AuxSSIDMaxAssociatedSTA, cmdInvokeGetWebUI=cmdInvokeGetWebUI, awcIappPort=awcIappPort, awcEventTraceStationSeverity=awcEventTraceStationSeverity, mipSATable=mipSATable, awcTpFdbAddress=awcTpFdbAddress, defaultResolverDomainServerEntry=defaultResolverDomainServerEntry, awcDot11DesiredSSIDWEPKeyPermuteAlgorithm=awcDot11DesiredSSIDWEPKeyPermuteAlgorithm, awcPfIppDefaultNUcastTimeToLive=awcPfIppDefaultNUcastTimeToLive, awcFtTimeoutSecDsHost=awcFtTimeoutSecDsHost, enableSNMP=enableSNMP, awcDot11ReassociatedStationCount=awcDot11ReassociatedStationCount, enableHTTP=enableHTTP, awcDot11AllowAssocBroadcastSSID=awcDot11AllowAssocBroadcastSSID, awcIfTableGroup=awcIfTableGroup, awcEventDispSeverityPortAlert=awcEventDispSeverityPortAlert, awcDot11AuxiliarySSIDEntry=awcDot11AuxiliarySSIDEntry, awcFileXferFileFirmwareRadio1=awcFileXferFileFirmwareRadio1, pingTxLen=pingTxLen, awcFileXferFileFirmwareRadio0=awcFileXferFileFirmwareRadio0, bootconfigMinLeaseDuration=bootconfigMinLeaseDuration, awcEventLog=awcEventLog, languageCode=languageCode, allowBrowseWithoutLogin=allowBrowseWithoutLogin, awcEventUseDaylightSavingsTime=awcEventUseDaylightSavingsTime, awcTrapLogGroup=awcTrapLogGroup, awcVxCompliance=awcVxCompliance, awcDot11SupportedDataRatesPrivacyIndex=awcDot11SupportedDataRatesPrivacyIndex, awcPolGrpId=awcPolGrpId, awcEventStatistics=awcEventStatistics, awcAcctGeneralEnabled=awcAcctGeneralEnabled, awcDot1dTpPortTable=awcDot1dTpPortTable, serialTerminalColumns=serialTerminalColumns, awcPrFltEthertypeSetTable=awcPrFltEthertypeSetTable, awcFtTimeoutSecBridge=awcFtTimeoutSecBridge, bootconfigClientAddr=bootconfigClientAddr, awcTpFdbDestMaxRetryErrorsImmed=awcTpFdbDestMaxRetryErrorsImmed, awcAcctServerUpdateDelay=awcAcctServerUpdateDelay, awcEventCntSeverityProtocolInfo=awcEventCntSeverityProtocolInfo, awcEventCntSeverityPortInfo=awcEventCntSeverityPortInfo, awcPfIppSetName=awcPfIppSetName, awcEventID=awcEventID, awcPfIptDefaultNUcastTimeToLive=awcPfIptDefaultNUcastTimeToLive, awcDot11AuthenticationAlgorithmsEntry=awcDot11AuthenticationAlgorithmsEntry, awcDot11AuxSSIDAuthAlgIndex=awcDot11AuxSSIDAuthAlgIndex, awcTpFdbFromAlertSrcPktsImmed=awcTpFdbFromAlertSrcPktsImmed, bootconfigFileServerAddr=bootconfigFileServerAddr, awcEventDispSeverityPortWarning=awcEventDispSeverityPortWarning, awcEventOffsetGMT=awcEventOffsetGMT, PYSNMP_MODULE_ID=awcVx)

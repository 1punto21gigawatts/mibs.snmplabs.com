#
# PySNMP MIB module DLINK-3100-DNSCL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DLINK-3100-DNSCL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:48:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
rlDnsCl, = mibBuilder.importSymbols("DLINK-3100-MIB", "rlDnsCl")
dnsResConfigSbeltEntry, = mibBuilder.importSymbols("DNS-RESOLVER-MIB", "dnsResConfigSbeltEntry")
DnsName, DnsRespCode, DnsType, DnsNameAsIndex, DnsClass, DnsTime, dns, DnsOpCode, DnsQType, DnsQClass = mibBuilder.importSymbols("DNS-SERVER-MIB", "DnsName", "DnsRespCode", "DnsType", "DnsNameAsIndex", "DnsClass", "DnsTime", "dns", "DnsOpCode", "DnsQType", "DnsQClass")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, Gauge32, ObjectIdentity, MibIdentifier, iso, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, Unsigned32, Counter64, NotificationType, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "ObjectIdentity", "MibIdentifier", "iso", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "Unsigned32", "Counter64", "NotificationType", "TimeTicks", "Integer32")
DisplayString, TextualConvention, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue", "RowStatus")
rlDnsClMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMibVersion.setDescription("MIB's version, the current version is 1.")
rlDnsClEnable = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClEnable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClEnable.setDescription('Enable or Disable the use of the DNS client feature.')
rlDnsClDomainNameTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 3), )
if mibBuilder.loadTexts: rlDnsClDomainNameTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameTable.setDescription('The domain names table.')
rlDnsClDomainNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 3, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsClDomainNameName"))
if mibBuilder.loadTexts: rlDnsClDomainNameEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameEntry.setDescription(' The row definition for this table.')
rlDnsClDomainNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 3, 1, 1), DnsName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClDomainNameName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameName.setDescription('The domain name for this ifIndex.')
rlDnsClDomainNameOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClDomainNameOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameOwner.setDescription('The Domain Name owner. Static if Domain Name defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClDomainNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClDomainNameRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsClMaxNumOfRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClMaxNumOfRetransmissions.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMaxNumOfRetransmissions.setDescription('The maximum number of retransmissions for each query.')
rlDnsClMinRetransmissionInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClMinRetransmissionInterval.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMinRetransmissionInterval.setDescription('The minimum number of seconds that must elapsed before retransmission for each query.')
rlDnsClNamesTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6), )
if mibBuilder.loadTexts: rlDnsClNamesTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesTable.setDescription('The Names table.')
rlDnsClNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesName"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesOwner"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesIndex"))
if mibBuilder.loadTexts: rlDnsClNamesEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesEntry.setDescription(' The row definition for this table.')
rlDnsClNamesName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1, 1), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClNamesName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesName.setDescription('The host name.')
rlDnsClNamesOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesOwner.setDescription('The Host Name Entry owner. Static if Host Name Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClNamesIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsClNamesName) do not provide a unique index.')
rlDnsClNamesAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesAddr.setDescription('The host IP address')
rlDnsClNamesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 6, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsResConfigSbeltExtTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 7), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtTable.setDescription('Augmenting rlDnsResConfigSbeltTable (dns resolver safety belt table) for added info')
rlDnsResConfigSbeltExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 7, 1), )
dnsResConfigSbeltEntry.registerAugmentions(("DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltExtEntry"))
rlDnsResConfigSbeltExtEntry.setIndexNames(*dnsResConfigSbeltEntry.getIndexNames())
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtEntry.setDescription('A row of the table rlDnsResConfigSbeltTable Extended by this definition.')
rlDnsResConfigSbeltOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResConfigSbeltOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltOwner.setDescription('The DNS server Entry owner. Static if DNS server Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8), )
if mibBuilder.loadTexts: rlDnsClNamesInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetTable.setDescription('The Names table.')
rlDnsClNamesInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesInetName"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesInetOwner"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesInetIndex"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsClNamesInetRRType"))
if mibBuilder.loadTexts: rlDnsClNamesInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetEntry.setDescription(' The row definition for this table.')
rlDnsClNamesInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 1), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClNamesInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetName.setDescription('The host name.')
rlDnsClNamesInetOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetOwner.setDescription('The Host Name Entry owner. Static if Host Name Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClNamesInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsClNamesName) do not provide a unique index.')
rlDnsClNamesInetRRType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 4), DnsType())
if mibBuilder.loadTexts: rlDnsClNamesInetRRType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetRRType.setDescription("DNS type of the Resource Record in the cache which is identified in this row of the table. The user can configure 'a' or 'aaaa' types only.")
rlDnsClNamesInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 5), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetAddrType.setDescription('The address type of rlDnsResNCacheErrInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsClNamesInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetAddr.setDescription('The host IP address')
rlDnsClNamesInetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 8, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsResConfigSbeltInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetTable.setDescription("Table of safety belt information used by the resolver when it hasn't got any better idea of where to send a query, such as when the resolver is booting or is a stub resolver.")
rlDnsResConfigSbeltInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltInetAddrType"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltInetAddr"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltInetSubTree"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltInetClass"))
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetEntry.setDescription("An entry in the resolver's Sbelt table. Rows may be created or deleted at any time by the DNS resolver and by SNMP SET requests. Whether the values changed via SNMP are saved in stable storage across `reset' operations is implementation-specific.")
rlDnsResConfigSbeltInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddrType.setDescription('The address type of rlDnsResConfigSbeltInetAddr. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResConfigSbeltInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddr.setDescription('The IP address of the Sbelt name server identified by this row of the table.')
rlDnsResConfigSbeltInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 3), DnsName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetName.setDescription('The DNS name of a Sbelt nameserver identified by this row of the table. A zero-length string indicates that the name is not known by the resolver.')
rlDnsResConfigSbeltInetRecursion = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("iterative", 1), ("recursive", 2), ("recursiveAndIterative", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetRecursion.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetRecursion.setDescription('Kind of queries resolver will be sending to the name server identified in this row of the table: iterative(1) indicates that resolver will be directing iterative queries to this name server (RD bit turned off). recursive(2) indicates that resolver will be directing recursive queries to this name server (RD bit turned on). recursiveAndIterative(3) indicates that the resolver will be directing both recursive and iterative queries to the server identified in this row of the table.')
rlDnsResConfigSbeltInetPref = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetPref.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetPref.setDescription('This value identifies the preference for the name server identified in this row of the table. The lower the value, the more desirable the resolver considers this server.')
rlDnsResConfigSbeltInetSubTree = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 6), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetSubTree.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetSubTree.setDescription('Queries sent to the name server identified by this row of the table are limited to those for names in the name subtree identified by this variable. If no such limitation applies, the value of this variable is the name of the root domain (a DNS name consisting of a single zero octet).')
rlDnsResConfigSbeltInetClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 7), DnsClass())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetClass.setDescription('The class of DNS queries that will be sent to the server identified by this row of the table.')
rlDnsResConfigSbeltInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 9, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetStatus.setDescription('Row status column for this row of the Sbelt table.')
rlDnsResCacheRRInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10), )
if mibBuilder.loadTexts: rlDnsResCacheRRInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetTable.setDescription("This table contains information about all the resource records currently in the resolver's cache.")
rlDnsResCacheRRInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsResCacheRRInetName"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResCacheRRInetClass"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResCacheRRInetType"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResCacheRRInetIndex"))
if mibBuilder.loadTexts: rlDnsResCacheRRInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetEntry.setDescription("An entry in the resolvers's cache. Rows may be created only by the resolver. SNMP SET requests may be used to delete rows.")
rlDnsResCacheRRInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setReference('RFC-1034 section 3.6.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setDescription('Owner name of the Resource Record in the cache which is identified in this row of the table. As described in RFC-1034, the owner of the record is the domain name were the RR is found.')
rlDnsResCacheRRInetClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 2), DnsClass())
if mibBuilder.loadTexts: rlDnsResCacheRRInetClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetClass.setDescription('DNS class of the Resource Record in the cache which is identified in this row of the table.')
rlDnsResCacheRRInetType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 3), DnsType())
if mibBuilder.loadTexts: rlDnsResCacheRRInetType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetType.setDescription('DNS type of the Resource Record in the cache which is identified in this row of the table.')
rlDnsResCacheRRInetTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetTTL.setDescription('Time-To-Live of RR in DNS cache. This is the initial TTL value which was received with the RR when it was originally received.')
rlDnsResCacheRRInetElapsedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetElapsedTTL.setDescription('Elapsed seconds since RR was received.')
rlDnsResCacheRRInetSourceAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetSourceAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetSourceAddrType.setDescription('The address type of rlDnsResCacheRRInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResCacheRRInetSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetSource.setDescription('Host from which RR was received, 0.0.0.0 if unknown.')
rlDnsResCacheRRInetData = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setReference('RFC-1035 section 3.2.1.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setDescription('RDATA portion of a cached RR. The value is in the format defined for the particular DNS class and type of the resource record.')
rlDnsResCacheRRInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResCacheRRInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetStatus.setDescription('Status column for the resolver cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
rlDnsResCacheRRInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 10), Integer32())
if mibBuilder.loadTexts: rlDnsResCacheRRInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsResCacheRRName, rlDnsResCacheRRClass, and rlDnsResCacheRRType) do not provide a unique index.')
rlDnsResCacheRRInetPrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 10, 1, 11), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setDescription('Name of the RR at this row in the table. This is identical to the rlDnsResCacheRRName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsResNCacheErrInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11), )
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTable.setDescription("The resolver's negative response cache. This table contains information about authoritative errors that have been cached by the resolver.")
rlDnsResNCacheErrInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1), ).setIndexNames((0, "DLINK-3100-DNSCL-MIB", "rlDnsResNCacheErrInetQName"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResNCacheErrInetQClass"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResNCacheErrInetQType"), (0, "DLINK-3100-DNSCL-MIB", "rlDnsResNCacheErrInetIndex"))
if mibBuilder.loadTexts: rlDnsResNCacheErrInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetEntry.setDescription("An entry in the resolver's negative response cache table. Only the resolver can create rows. SNMP SET requests may be used to delete rows.")
rlDnsResNCacheErrInetQName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setReference('RFC-1034 section 3.7.1.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setDescription('QNAME associated with a cached authoritative error.')
rlDnsResNCacheErrInetQClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 2), DnsQClass())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQClass.setDescription('DNS QCLASS associated with a cached authoritative error.')
rlDnsResNCacheErrInetQType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 3), DnsQType())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQType.setDescription('DNS QTYPE associated with a cached authoritative error.')
rlDnsResNCacheErrInetTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setReference('RFC-1034 section 4.3.4.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setDescription('Time-To-Live of a cached authoritative error at the time of the error, it should not be decremented by the number of seconds since it was received. This should be the TTL as copied from the MINIMUM field of the SOA that accompanied the authoritative error, or a smaller value if the resolver implements a ceiling on negative response cache TTLs.')
rlDnsResNCacheErrInetElapsedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetElapsedTTL.setDescription('Elapsed seconds since authoritative error was received.')
rlDnsResNCacheErrInetSourceAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSourceAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSourceAddrType.setDescription('The address type of rlDnsResNCacheErrInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResNCacheErrInetSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSource.setDescription('Host which sent the authoritative error, 0.0.0.0 if unknown.')
rlDnsResNCacheErrInetCode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonexistantName", 1), ("noData", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetCode.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetCode.setDescription('The authoritative error that has been cached: nonexistantName(1) indicates an authoritative name error (RCODE = 3). noData(2) indicates an authoritative response with no error (RCODE = 0) and no relevant data. other(3) indicates some other cached authoritative error. At present, no such errors are known to exist.')
rlDnsResNCacheErrInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetStatus.setDescription('Status column for the resolver negative response cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
rlDnsResNCacheErrInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsResNCacheErrQName, rlDnsResNCacheErrQClass, and rlDnsResNCacheErrQType) do not provide a unique index.')
rlDnsResNCacheErrInetPrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 11, 1, 11), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setDescription('QNAME associated with this row in the table. This is identical to the rlDnsResNCacheErrQName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsResConfigSbeltExtInetTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 12), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetTable.setDescription('Augmenting rlDnsResConfigSbeltInetTable (dns resolver safety belt table) for added info')
rlDnsResConfigSbeltExtInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 12, 1), )
rlDnsResConfigSbeltInetEntry.registerAugmentions(("DLINK-3100-DNSCL-MIB", "rlDnsResConfigSbeltExtInetEntry"))
rlDnsResConfigSbeltExtInetEntry.setIndexNames(*rlDnsResConfigSbeltInetEntry.getIndexNames())
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetEntry.setDescription('A row of the table rlDnsResConfigSbeltInetTable Extended by this definition.')
rlDnsResConfigSbeltInetOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 93, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetOwner.setDescription('The DNS server Entry owner. Static if DNS server Entry defined by user, dhcp if received by boot protocol like DHCP.')
mibBuilder.exportSymbols("DLINK-3100-DNSCL-MIB", rlDnsResCacheRRInetData=rlDnsResCacheRRInetData, rlDnsClMaxNumOfRetransmissions=rlDnsClMaxNumOfRetransmissions, rlDnsClDomainNameRowStatus=rlDnsClDomainNameRowStatus, rlDnsClNamesEntry=rlDnsClNamesEntry, rlDnsResConfigSbeltOwner=rlDnsResConfigSbeltOwner, rlDnsClNamesName=rlDnsClNamesName, rlDnsClNamesInetOwner=rlDnsClNamesInetOwner, rlDnsResNCacheErrInetSource=rlDnsResNCacheErrInetSource, rlDnsResNCacheErrInetSourceAddrType=rlDnsResNCacheErrInetSourceAddrType, rlDnsResConfigSbeltInetStatus=rlDnsResConfigSbeltInetStatus, rlDnsResNCacheErrInetQClass=rlDnsResNCacheErrInetQClass, rlDnsResConfigSbeltInetEntry=rlDnsResConfigSbeltInetEntry, rlDnsClNamesAddr=rlDnsClNamesAddr, rlDnsClNamesIndex=rlDnsClNamesIndex, rlDnsResConfigSbeltInetSubTree=rlDnsResConfigSbeltInetSubTree, rlDnsClNamesInetAddrType=rlDnsClNamesInetAddrType, rlDnsResCacheRRInetName=rlDnsResCacheRRInetName, rlDnsResConfigSbeltInetName=rlDnsResConfigSbeltInetName, rlDnsResNCacheErrInetElapsedTTL=rlDnsResNCacheErrInetElapsedTTL, rlDnsResConfigSbeltInetOwner=rlDnsResConfigSbeltInetOwner, rlDnsClNamesInetTable=rlDnsClNamesInetTable, rlDnsResCacheRRInetSourceAddrType=rlDnsResCacheRRInetSourceAddrType, rlDnsResConfigSbeltExtTable=rlDnsResConfigSbeltExtTable, rlDnsResConfigSbeltInetAddr=rlDnsResConfigSbeltInetAddr, rlDnsClNamesInetRRType=rlDnsClNamesInetRRType, rlDnsResNCacheErrInetQType=rlDnsResNCacheErrInetQType, rlDnsClNamesTable=rlDnsClNamesTable, rlDnsClNamesInetAddr=rlDnsClNamesInetAddr, rlDnsResConfigSbeltExtInetEntry=rlDnsResConfigSbeltExtInetEntry, rlDnsResCacheRRInetTable=rlDnsResCacheRRInetTable, rlDnsResNCacheErrInetEntry=rlDnsResNCacheErrInetEntry, rlDnsResConfigSbeltInetPref=rlDnsResConfigSbeltInetPref, rlDnsResConfigSbeltInetTable=rlDnsResConfigSbeltInetTable, rlDnsResNCacheErrInetTTL=rlDnsResNCacheErrInetTTL, rlDnsClMibVersion=rlDnsClMibVersion, rlDnsResNCacheErrInetIndex=rlDnsResNCacheErrInetIndex, rlDnsClDomainNameName=rlDnsClDomainNameName, rlDnsResConfigSbeltExtEntry=rlDnsResConfigSbeltExtEntry, rlDnsResConfigSbeltInetAddrType=rlDnsResConfigSbeltInetAddrType, rlDnsResConfigSbeltInetClass=rlDnsResConfigSbeltInetClass, rlDnsResCacheRRInetEntry=rlDnsResCacheRRInetEntry, rlDnsClDomainNameEntry=rlDnsClDomainNameEntry, rlDnsClDomainNameOwner=rlDnsClDomainNameOwner, rlDnsResCacheRRInetPrettyName=rlDnsResCacheRRInetPrettyName, rlDnsResNCacheErrInetTable=rlDnsResNCacheErrInetTable, rlDnsClMinRetransmissionInterval=rlDnsClMinRetransmissionInterval, rlDnsClNamesInetEntry=rlDnsClNamesInetEntry, rlDnsResConfigSbeltInetRecursion=rlDnsResConfigSbeltInetRecursion, rlDnsResCacheRRInetType=rlDnsResCacheRRInetType, rlDnsResCacheRRInetSource=rlDnsResCacheRRInetSource, rlDnsResCacheRRInetIndex=rlDnsResCacheRRInetIndex, rlDnsResConfigSbeltExtInetTable=rlDnsResConfigSbeltExtInetTable, rlDnsClNamesRowStatus=rlDnsClNamesRowStatus, rlDnsClEnable=rlDnsClEnable, rlDnsClNamesInetIndex=rlDnsClNamesInetIndex, rlDnsResNCacheErrInetStatus=rlDnsResNCacheErrInetStatus, rlDnsResCacheRRInetStatus=rlDnsResCacheRRInetStatus, rlDnsResCacheRRInetElapsedTTL=rlDnsResCacheRRInetElapsedTTL, rlDnsResCacheRRInetTTL=rlDnsResCacheRRInetTTL, rlDnsResNCacheErrInetPrettyName=rlDnsResNCacheErrInetPrettyName, rlDnsClNamesInetName=rlDnsClNamesInetName, rlDnsResCacheRRInetClass=rlDnsResCacheRRInetClass, rlDnsClNamesInetRowStatus=rlDnsClNamesInetRowStatus, rlDnsClDomainNameTable=rlDnsClDomainNameTable, rlDnsClNamesOwner=rlDnsClNamesOwner, rlDnsResNCacheErrInetQName=rlDnsResNCacheErrInetQName, rlDnsResNCacheErrInetCode=rlDnsResNCacheErrInetCode)

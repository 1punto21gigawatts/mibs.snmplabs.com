#
# PySNMP MIB module Olicom-crossfireAtmSwitch-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Olicom-crossfireAtmSwitch-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:35:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
controlTime, ocmibsCrossfireAtmMIB = mibBuilder.importSymbols("Olicom-MIB", "controlTime", "ocmibsCrossfireAtmMIB")
MacAddress, = mibBuilder.importSymbols("RFC1231-MIB", "MacAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Bits, Counter64, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, enterprises, Integer32, Unsigned32, NotificationType, MibIdentifier, NotificationType, iso, IpAddress, ModuleIdentity, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Bits", "Counter64", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "enterprises", "Integer32", "Unsigned32", "NotificationType", "MibIdentifier", "NotificationType", "iso", "IpAddress", "ModuleIdentity", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

olicom = MibIdentifier((1, 3, 6, 1, 4, 1, 285))
ocmibs = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2))
ocmibsCrossfireAtmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6))
crossfireAtmInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1))
crossfireAtmConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2))
crossfireAtmStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3))
crossfireAtmStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 4))
crossfireAtmTrapControl = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 5))
crossfireAtmTest = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 6))
crossfirexlx = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7))
infoProcessorModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1))
infoFeatureModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2))
infoXModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3))
infoIfIndex = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4))
termRestartInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5))
infoProcessorModuleHwProductId = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwProductId.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwProductId.setDescription('The processor module product ID from the EEPROM.')
infoProcessorModuleHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwVersion.setDescription('The processor module version from the EEPROM.')
infoProcessorModuleHwEcoLevel = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwEcoLevel.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwEcoLevel.setDescription('The processor module ECO level - not used.')
infoProcessorModuleHwSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwSerialNumber.setDescription('The processor module serial number from the EEPROM.')
infoProcessorModuleHwOptionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 5), )
if mibBuilder.loadTexts: infoProcessorModuleHwOptionTable.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwOptionTable.setDescription('The table of processor module options as found in the EEPROM.')
infoProcessorModuleHwOptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 5, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "infoProcessorModuleHwOptionNo"))
if mibBuilder.loadTexts: infoProcessorModuleHwOptionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwOptionEntry.setDescription('Each row in this table describes one processor module option.')
infoProcessorModuleHwOptionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwOptionNo.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwOptionNo.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
infoProcessorModuleHwOption = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 1, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProcessorModuleHwOption.setStatus('mandatory')
if mibBuilder.loadTexts: infoProcessorModuleHwOption.setDescription('A processor module option string from the EEPROM.')
infoFeatureModuleHwProductId = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwProductId.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwProductId.setDescription('The feature module product ID from the EEPROM.')
infoFeatureModuleHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwVersion.setDescription('The feature module version from the EEPROM.')
infoFeatureModuleHwEcoLevel = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwEcoLevel.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwEcoLevel.setDescription('The feature module ECO level - not used.')
infoFeatureModuleHwSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwSerialNumber.setDescription('The feature module serial number from the EEPROM.')
infoFeatureModuleHwOptionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 5), )
if mibBuilder.loadTexts: infoFeatureModuleHwOptionTable.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwOptionTable.setDescription('The table of feature module options as found in the EEPROM.')
infoFeatureModuleHwOptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 5, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "infoFeatureModuleHwOptionNo"))
if mibBuilder.loadTexts: infoFeatureModuleHwOptionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwOptionEntry.setDescription('Each row in this table describes one feature module option.')
infoFeatureModuleHwOptionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwOptionNo.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwOptionNo.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
infoFeatureModuleHwOption = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 2, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFeatureModuleHwOption.setStatus('mandatory')
if mibBuilder.loadTexts: infoFeatureModuleHwOption.setDescription('A feature module option string from the EEPROM.')
infoXModuleTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1), )
if mibBuilder.loadTexts: infoXModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleTable.setDescription('This table contains information for each of the expansion modules installed in the switch.')
infoXModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "infoXModuleSlotIndex"))
if mibBuilder.loadTexts: infoXModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleEntry.setDescription('Each row in this table contains information for one expansion module.')
infoXModuleSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleSlotIndex.setDescription('The slot number for the expansion module. It is used to index the expansion module in the table.')
infoXModuleHwProductId = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwProductId.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwProductId.setDescription('The expansion module product ID from the EEPROM.')
infoXModuleHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwVersion.setDescription('The expansion module version from the EEPROM.')
infoXModuleHwEcoLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwEcoLevel.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwEcoLevel.setDescription('The expansion module ECO level - not used.')
infoXModuleHwSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwSerialNumber.setDescription('The expansion module serial number from the EEPROM.')
infoXModuleHwOptionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 2), )
if mibBuilder.loadTexts: infoXModuleHwOptionTable.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwOptionTable.setDescription('The table of expansion module options as found in the EEPROM. There is one row in the table for each expansion module and each option.')
infoXModuleHwOptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "infoXModuleHwOptionSlotIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "infoXModuleHwOptionNo"))
if mibBuilder.loadTexts: infoXModuleHwOptionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwOptionEntry.setDescription('Each row in this table describes one expansion module option.')
infoXModuleHwOptionSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwOptionSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwOptionSlotIndex.setDescription('The slot number for the expansion module. It is used to index the expansion module in the table.')
infoXModuleHwOptionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwOptionNo.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwOptionNo.setDescription('An arbitrary integer used to differentiate multiple rows for the same expansion module.')
infoXModuleHwOption = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 3, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoXModuleHwOption.setStatus('mandatory')
if mibBuilder.loadTexts: infoXModuleHwOption.setDescription('An expansion module option string from the EEPROM.')
infoIfIndexLan = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexLan.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexLan.setDescription('This ifIndex value designates the Ethernet LAN interface on the switch.')
infoIfIndexSlip = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexSlip.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexSlip.setDescription('This ifIndex value designates the SLIP interface on the switch.')
infoIfIndexElan = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexElan.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexElan.setDescription('This ifIndex value designates the emulated LAN user side virtual interface on the switch.')
infoIfIndexClassicalIp = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexClassicalIp.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexClassicalIp.setDescription('This ifIndex value designates the Classical IP virtual interface on the switch.')
infoIfIndexRfc1483Bridged = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexRfc1483Bridged.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexRfc1483Bridged.setDescription('This ifIndex value designates the Classical IP (RFC 1483 bridged encapsulation) virtual interface on the switch.')
infoIfIndexRfc1483Routed = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexRfc1483Routed.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexRfc1483Routed.setDescription('This ifIndex value designates the Classical IP (RFC 1483 routed encapsulation) virtual interface on the switch.')
infoIfIndexAtmNode = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoIfIndexAtmNode.setStatus('mandatory')
if mibBuilder.loadTexts: infoIfIndexAtmNode.setDescription('This ifIndex value designates the network node side virtual interface on the switch which is used when the switch communicates with itself.')
termRestartInfoRestartTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoRestartTime.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoRestartTime.setDescription('Time when the system was restarted (measured in seconds since 00:00:00 UTC on 1 January 1970).')
termRestartInfoSwSection1StatusWord = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoSwSection1StatusWord.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoSwSection1StatusWord.setDescription('The value of the status word in the first section of the software image flash memory.')
termRestartInfoSwSection2StatusWord = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoSwSection2StatusWord.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoSwSection2StatusWord.setDescription('The value of the status word in the second section of the software image flash memory.')
termRestartInfoSwImageLoaded = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("image1", 1), ("image2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoSwImageLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoSwImageLoaded.setDescription('The number of the software image currently running.')
termRestartInfoFutureTestMode = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoFutureTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoFutureTestMode.setDescription("Indicates if the software is running in 'Future Test' mode, i.e. if this is a one-shot test of a software image.")
termRestartInfoBootpExecuted = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoBootpExecuted.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoBootpExecuted.setDescription('Indicates if BOOTP was executed to load the software image.')
termRestartInfoReloadTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoReloadTime.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoReloadTime.setDescription('Time when the software was stored in the switch (measured in seconds since 00:00:00 UTC on 1 January 1970).')
termRestartInfoBootpReason = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noSw", 1), ("chksumError", 2), ("invalidSwStatus", 3), ("pushButtons", 4), ("undefined", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoBootpReason.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoBootpReason.setDescription("The reason that BOOTP was executed to load the software. The possible values are: noSw There was no executable software image in the switch. chksumError The software image in the switch had a check sum error. invalidSwStatus The status word associated with the software image in the switch was invalid. pushButtons The 'default' and 'reset' buttons on the switch font panel were pressed. undefined Other reasons.")
termRestartInfoServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoServerIpAddress.setDescription('The IP address of the server that provided the software image during the BOOTP operation.')
termRestartInfoServerMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoServerMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoServerMacAddress.setDescription('The MAC address of the of the server that provided the software image during the BOOTP operation.')
termRestartInfoFileName = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoFileName.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoFileName.setDescription('The name of the software image file on the BOOTP server.')
termRestartInfoBbsramTerminationTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoBbsramTerminationTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoBbsramTerminationTimestamp.setDescription('Time when the system last closed down (measured in seconds since 00:00:00 UTC on 1 January 1970).')
termRestartInfoTerminationReason = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("controlled", 2), ("controlledHalt", 3), ("fatal", 4), ("watchdog", 5), ("temperatureAlarm", 6), ("psuFailure", 7), ("featureModuleRemoved", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoTerminationReason.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoTerminationReason.setDescription('The reason the system last closed down. Possible values are: unknown Unknown reason. controlled Management requested termination. controlledHalt The switch was halted, possibly because of an inconsistent configuration. fatal A fatal error was encountered in the software. watchdog The software watchdog timed out. temperatureAlarm The temperature within the switch reached a value above temperatureCriticalTrapThreshold. psuFailure Power supply failure. featureModuleRemoved The feature module was removed while the switch was operating.')
termRestartInfoRestartReason = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("reset", 1), ("default", 2), ("resetDefault", 3), ("watchdog", 4), ("fatal", 5), ("controlled", 6), ("coldStart", 7), ("unknown", 8), ("featureModuleRemoved", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoRestartReason.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoRestartReason.setDescription("The reason the system started. Possible values are: reset The 'reset' button on the switch font panel was pressed. default The 'default' button on the switch front panel was pressed. resetDefault The 'reset' and 'default' buttons on the switch front panel were pressed. watchdog The software watchdog timed out. fatal A fatal error was encountered in the software. controlled Management requested restart. coldStart Power up. unknown Unknown reason. featureModuleRemoved The feature module was removed while the switch was operating.")
termRestartInfoHwReconfigState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("totalReconfig", 1), ("partialReconfig", 2), ("noReconfig", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoHwReconfigState.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoHwReconfigState.setDescription('The reconfiguration state of the switch. Possible values are: totalReconfig The stored configuration is invalidated because of hardware changes. partialReconfig The stored expansion module configuration does not match the physically installed expansion modules. Some configuration is invalidated. noReconfig The stored configuration is used unchanged.')
termRestartInfoBbsram = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 1, 5, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(50, 50)).setFixedLength(50)).setMaxAccess("readonly")
if mibBuilder.loadTexts: termRestartInfoBbsram.setStatus('mandatory')
if mibBuilder.loadTexts: termRestartInfoBbsram.setDescription('Data stored in battery backed-up RAM when the switch terminated.')
configAddressing = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 1))
configClocking = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 2))
configLane = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 3))
configMonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 4))
configTm = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6))
configTrafficDescr = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7))
configServiceReg = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8))
configSar = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 9))
configXModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 10))
configFeatureModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 11))
configCommonEPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12))
configEPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13))
configCpuQ = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 14))
configCommonIPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15))
configIPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16))
configPvpPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17))
configSvpSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18))
configCommonSignalling = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19))
configIisp = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20))
configIpArp = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21))
configQosClass = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22))
configSerial = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 23))
configOam = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24))
configTest = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 25))
configPriorityBuffer = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 26))
configSwitchAddrPrefixType = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(57, 69, 71))).clone(namedValues=NamedValues(("dcc", 57), ("iso", 69), ("icd", 71)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSwitchAddrPrefixType.setStatus('mandatory')
if mibBuilder.loadTexts: configSwitchAddrPrefixType.setDescription('The ATM address prefix type.')
configSwitchAddrPrefixSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSwitchAddrPrefixSize.setStatus('mandatory')
if mibBuilder.loadTexts: configSwitchAddrPrefixSize.setDescription('The number of octets in configSwitchAddrAtmPrefix.')
configSwitchAddrAtmPrefix = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSwitchAddrAtmPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: configSwitchAddrAtmPrefix.setDescription('The next octets of the ATM address.')
configSwitchAddrAtmAddress = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 1, 4), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configSwitchAddrAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configSwitchAddrAtmAddress.setDescription('The complete ATM address (with a 0 in the final octet, i.e. the selector).')
configNetworkClockSource = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNetworkClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: configNetworkClockSource.setDescription('Controls whether the internal clock is the master clock or an incoming network clock is redistributed to all other ports.')
configNetworkClockEPortIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNetworkClockEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configNetworkClockEPortIndex.setDescription("The ePort that is the clock source if configNetworkClockSource has the value 'external'.")
configLaneControlAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configLaneControlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configLaneControlAdminStatus.setDescription('Enable or disable LAN emulation services.')
configLaneControlLecsAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configLaneControlLecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configLaneControlLecsAdminStatus.setDescription('Enable or disable the LAN Emulation Configuration Server (LECS).')
configLaneControlLesBusAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configLaneControlLesBusAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configLaneControlLesBusAdminStatus.setDescription('Enable or disable the LAN Emulation Server (LES) and Broadcast and Unknown Server (BUS).')
configMonitorEPortAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorEPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorEPortAdminStatus.setDescription('Enable or disable copying of cells to the last iPort.')
configMonitorEPortIPortSlotIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorEPortIPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorEPortIPortSlotIndex.setDescription('The number of the expansion module containing the iPort whose inbound or outbound cells are to be copied.')
configMonitorEPortIPortRIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorEPortIPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorEPortIPortRIndex.setDescription('The number of the iPort whose inbound or outbound cells are to be copied.')
configMonitorEPortDirection = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorEPortDirection.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorEPortDirection.setDescription('Controls if the inbound (rx) or outbound (tx) cells are to be copied.')
configTmControlMode = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("efci", 1), ("er", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlMode.setDescription('Controls whether ABR traffic should be controlled through EFCI (Explicit Forward Congestion Indication), ER (Explicit Rate) or no mechanism at all.')
configTmControlEarlyPacketDiscardAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlEarlyPacketDiscardAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlEarlyPacketDiscardAdminStatus.setDescription('Enables or disables early packed discard.')
configTmControlVbrTrafficAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strictAllocation", 1), ("overSubscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlVbrTrafficAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlVbrTrafficAllocation.setDescription('Indicates if bandwidth allocation of VBR connections should be based on the peak cell rate (strictAllocation) or a calculation of equivalent bandwidth (overSubscribe).')
configTmControlErTuningAlpha = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningAlpha.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningAlpha.setDescription('100 times the value of the alpha parameter in the explicit rate algorithm.')
configTmControlErTuningBeta = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningBeta.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningBeta.setDescription('The value of the beta parameter in the explicit rate algorithm.')
configTmControlErTuningGamma = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningGamma.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningGamma.setDescription('The value of the gamma parameter in the explicit rate algorithm.')
configTmControlErTuningDelta = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningDelta.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningDelta.setDescription('100 times the value of the delta parameter in the explicit rate algorithm.')
configTmControlErTuningLambda = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningLambda.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningLambda.setDescription('The value of the lambda parameter in the explicit rate algorithm.')
configTmControlErTuningTau = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningTau.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningTau.setDescription('The value (in microseconds) of the tau parameter in the explicit rate algorithm.')
configTmControlErTuningPhi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningPhi.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningPhi.setDescription('100 times the value of the phi parameter in the explicit rate algorithm.')
configTmControlErTuningPsi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmControlErTuningPsi.setStatus('mandatory')
if mibBuilder.loadTexts: configTmControlErTuningPsi.setDescription('The value of the psi parameter in the explicit rate algorithm.')
configTmServiceClassMapTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 12), )
if mibBuilder.loadTexts: configTmServiceClassMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: configTmServiceClassMapTable.setDescription('This table maps each traffic category to one of the four scheduling queues that are associated with each iPort in the switch.')
configTmServiceClassMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 12, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configTmServiceClassMapServiceClass"))
if mibBuilder.loadTexts: configTmServiceClassMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configTmServiceClassMapEntry.setDescription('Each row in this table describes one service category.')
configTmServiceClassMapServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configTmServiceClassMapServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: configTmServiceClassMapServiceClass.setDescription('The service category described by this row.')
configTmServiceClassMapSchedulingQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTmServiceClassMapSchedulingQueue.setStatus('mandatory')
if mibBuilder.loadTexts: configTmServiceClassMapSchedulingQueue.setDescription('The cell scheduling queue used by this service category.')
trafficDescriptorTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficDescriptorTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorTableNextIndex.setDescription('The next unused row in trafficDescriptorTable.')
trafficDescriptorTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2), )
if mibBuilder.loadTexts: trafficDescriptorTable.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorTable.setDescription('This table contains all the traffic descriptors in the switch. Each traffic descriptor may be associated with zero or more connections passing through the switch.')
trafficDescriptorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "trafficDescriptorIndex"))
if mibBuilder.loadTexts: trafficDescriptorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorEntry.setDescription('Each row in this table describes one traffic descriptor.')
trafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
trafficDescriptorCreationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switchedConnection", 1), ("management", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficDescriptorCreationMode.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorCreationMode.setDescription('The reason this traffic descriptor was created. Possible values are: switchedConnection The traffic descriptor was created because signalling established a connection through the switch. management The traffic descriptor was created through management. default The traffic descriptor is one of the default descriptors present in the switch.')
trafficDescriptorServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorServiceClass.setDescription('The service category for this traffic descriptor.')
trafficDescriptorPcr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorPcr01.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorPcr01.setDescription('The Peak Cell Rate (in cells/second) for the CLP0+1 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorPcr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorPcr0.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorPcr0.setDescription('The Peak Cell Rate (in cells/second) for the CLP0 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorScr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorScr01.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorScr01.setDescription('The Sustainable Cell Rate (in cells/second) for the CLP0+1 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorScr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorScr0.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorScr0.setDescription('The Sustainable Cell Rate (in cells/second) for the CLP0 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorMbs01 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorMbs01.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorMbs01.setDescription('The Maximum Burst Size for the CLP0+1 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorMbs0 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorMbs0.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorMbs0.setDescription('The Maximum Burst Size for the CLP0 flow. The value -1 is used to indicate that this value is not used.')
trafficDescriptorTaggingFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noTagging", 1), ("tagging", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorTaggingFlag.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorTaggingFlag.setDescription('Indicates if tagging is disabled or enabled.')
trafficDescriptorFrameDiscardFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noDiscard", 1), ("discard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorFrameDiscardFlag.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorFrameDiscardFlag.setDescription('Indicates if frame discard is enabled or disabled. This only has any effect if configTmControlEarlyPacketDiscardAdminStatus is up.')
trafficDescriptorBestEffortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noBestEffort", 1), ("bestEffort", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorBestEffortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorBestEffortFlag.setDescription('Indicates that best-effort delivery should be used (i.e. UBR service).')
trafficDescriptorMcr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorMcr.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorMcr.setDescription('The Minimum Cell Rate (in cells/second). The value -1 is used to indicate that this value is not used.')
trafficDescriptorAbrIcr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrIcr.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrIcr.setDescription('The Initial Cell Rate (in cells/second). The value -1 is used to indicate that this value is not used.')
trafficDescriptorAbrTbe = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrTbe.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrTbe.setDescription('The Transient Buffer Exposure. The value -1 is used to indicate that this value is not used.')
trafficDescriptorAbrFrtt = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrFrtt.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrFrtt.setDescription('The Fixed Round Trip time (in microseconds). The value -1 is used to indicate that this value is not used.')
trafficDescriptorAbrRif = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rifOneOver32768", 1), ("rifOneOver16384", 2), ("rifOneOver8192", 3), ("rifOneOver4096", 4), ("rifOneOver2048", 5), ("rifOneOver1024", 6), ("rifOneOver512", 7), ("rifOneOver256", 8), ("rifOneOver128", 9), ("rifOneOver64", 10), ("rifOneOver32", 11), ("rifOneOver16", 12), ("rifOneOver8", 13), ("rifOneOver4", 14), ("rifOneOver2", 15), ("rifOne", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrRif.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrRif.setDescription('The Rate Increase Factor. A value such as, for example, rifOneOver128 indicates a RIF value of 1/128.')
trafficDescriptorAbrRdf = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rdfOneOver32768", 1), ("rdfOneOver16384", 2), ("rdfOneOver8192", 3), ("rdfOneOver4096", 4), ("rdfOneOver2048", 5), ("rdfOneOver1024", 6), ("rdfOneOver512", 7), ("rdfOneOver256", 8), ("rdfOneOver128", 9), ("rdfOneOver64", 10), ("rdfOneOver32", 11), ("rdfOneOver16", 12), ("rdfOneOver8", 13), ("rdfOneOver4", 14), ("rdfOneOver2", 15), ("rdfOne", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrRdf.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrRdf.setDescription('The Rate Decrease Factor. A value such as, for example, rdfOneOver128 indicates a RIF value of 1/128.')
trafficDescriptorAbrNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("nrm2", 1), ("nrm4", 2), ("nrm8", 3), ("nrm16", 4), ("nrm32", 5), ("nrm64", 6), ("nrm128", 7), ("nrm256", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrNrm.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrNrm.setDescription('The number of cells between each Resource Management (RM) cell. A value such as, for example, nrm32 indicates an Nrm value of 32.')
trafficDescriptorAbrTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("trm0Point78125", 1), ("trm1Point5625", 2), ("trm3Point125", 3), ("trm6Point25", 4), ("trm12Point5", 5), ("trm25", 6), ("trm50", 7), ("trm100", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrTrm.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrTrm.setDescription('The maximum time between each Resource Management (RM) cell. A value such as, for example, trm3Point125 indicates a Trm value of 3.125 milliseconds.')
trafficDescriptorAbrCdf = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cdf0", 1), ("cdfOneOver64", 2), ("cdfOneOver32", 3), ("cdfOneOver16", 4), ("cdfOneOver8", 5), ("cdfOneOver4", 6), ("cdfOneOver2", 7), ("cdfOne", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrCdf.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrCdf.setDescription('The Cutoff Decrease Factor. A value such as, for example, cdfOneOver16 indicates a CDF value of 1/16.')
trafficDescriptorAbrAdtf = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorAbrAdtf.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorAbrAdtf.setDescription('The value (in centiseconds) of the ACR Decrease Time Factor.')
trafficDescriptorTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficDescriptorTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorTrafficType.setDescription('The traffic descriptor type. This value is identical to the last component of the object ID of the MIB objects in the atmfTrafficDescrTypes subtree of the ILMI MIB.')
trafficDescriptorRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
trafficDescriptorCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorCtd.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorCtd.setDescription('The Cell Transfer Delay (in microseconds). The value -1 is used to indicate that this value is not used.')
trafficDescriptorCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorCdv.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorCdv.setDescription('The Cell Delay Variation (in microseconds). The value -1 is used to indicate that this value is not used.')
trafficDescriptorLogClr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 7, 2, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficDescriptorLogClr.setStatus('mandatory')
if mibBuilder.loadTexts: trafficDescriptorLogClr.setDescription('Minus the base 10 logarithm of the Cell Loss Ratio. The value 0 is used to indicate that this value is not used.')
configIlmiServiceRegistryTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1), )
if mibBuilder.loadTexts: configIlmiServiceRegistryTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryTable.setDescription('This table is used to configure the contents of the ILMI service registry on all ATM ports.')
configIlmiServiceRegistryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configIlmiServiceRegistryServiceId"), (0, "Olicom-crossfireAtmSwitch-MIB", "configIlmiServiceRegistryAddressIndex"))
if mibBuilder.loadTexts: configIlmiServiceRegistryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryEntry.setDescription('Each row in this table describes one service provided by one service provider.')
configIlmiServiceRegistryAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIlmiServiceRegistryAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryAddressIndex.setDescription('An arbitrary integer used to differentiate multiple rows containing different ATM addresses for the same service.')
configIlmiServiceRegistryServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIlmiServiceRegistryServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryServiceId.setDescription('The service identifier which uniquely identifies the type of service at the address provided in the table. Legal values are given in the Service Registry MIB in the ILMI specification.')
configIlmiServiceRegistryAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIlmiServiceRegistryAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryAtmAddress.setDescription('The full ATM address of the service. The user-side IME may use this address to establish a connection with the service.')
configIlmiServiceRegistryParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIlmiServiceRegistryParm1.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryParm1.setDescription('An octet string whose size and meaning is determined by the value of configIlmiServiceRegistryServiceId.')
configIlmiServiceRegistryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIlmiServiceRegistryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIlmiServiceRegistryRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
configSarMuxFillThreshold = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSarMuxFillThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configSarMuxFillThreshold.setDescription('The number of cells in the SAR multiplexer FIFO that will cause the PHY to take priority over the SAR.')
configSarMuxSarVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSarMuxSarVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configSarMuxSarVpi.setDescription('The VPI used to distinguish cells on iPort 0 that are intended for the SAR.')
configSarEmptyCellHandling = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("unassigned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSarEmptyCellHandling.setStatus('mandatory')
if mibBuilder.loadTexts: configSarEmptyCellHandling.setDescription('')
configXModuleTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 10, 1), )
if mibBuilder.loadTexts: configXModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: configXModuleTable.setDescription('This table contains configuration information for the expansion modules.')
configXModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 10, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configXModuleSlotIndex"))
if mibBuilder.loadTexts: configXModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configXModuleEntry.setDescription('Each row in this table contains information about one expansion module.')
configXModuleSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configXModuleSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configXModuleSlotIndex.setDescription('The slot number for the expansion module. It is used to index the expansion module in the table.')
configXModuleAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("reset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configXModuleAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configXModuleAdminStatus.setDescription('Enables, disables, or resets the expansion module.')
configFeatureModuleAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configFeatureModuleAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configFeatureModuleAdminStatus.setDescription('Enables or disables the feature module.')
configCommonEPortIlmiAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("full", 1), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortIlmiAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortIlmiAdminStatus.setDescription('Enables or disables ILMI on an ATM port.')
configCommonEPortAddrRegistrationAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortAddrRegistrationAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortAddrRegistrationAdminStatus.setDescription('Enables or disables the address registration protocol on an ATM port.')
configCommonEPortMaxVpcs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxVpcs.setDescription('The maximum number of VPCs on an ATM port.')
configCommonEPortMaxVccs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxVccs.setDescription('The maximum number of VCCs on an ATM port.')
configCommonEPortMaxVpiBits = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxVpiBits.setDescription('The number of bits used in a VPI on an ATM port.')
configCommonEPortMaxVciBits = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxVciBits.setDescription('The number of bits used in a VCI on an ATM port.')
configCommonEPortUniType = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortUniType.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortUniType.setDescription('The UNI type on an ATM port.')
configCommonEPortUniVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("version3point0", 2), ("version3point1", 3), ("version4point0", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortUniVersion.setDescription('The highest UNI version used on an ATM port.')
configCommonEPortDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortDeviceType.setDescription('The ATM port device type.')
configCommonEPortIlmiVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortIlmiVersion.setDescription('The highest ILMI version used on an ATM port.')
configCommonEPortNniSigVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortNniSigVersion.setDescription('The NNI signalling protocol used on an ATM port.')
configCommonEPortSignallingVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortSignallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortSignallingVpi.setDescription('The VPI used for signalling.')
configCommonEPortSignallingVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortSignallingVci.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortSignallingVci.setDescription('The VCI used for signalling.')
configCommonEPortIlmiVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortIlmiVpi.setDescription('The VPI used for ILMI.')
configCommonEPortIlmiVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortIlmiVci.setDescription('The VCI used for ILMI.')
configCommonEPortLecsVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortLecsVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortLecsVpi.setDescription('The VPI used for LECS.')
configCommonEPortLecsVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortLecsVci.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortLecsVci.setDescription('The VCI used for LECS.')
configCommonEPortPnniVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortPnniVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortPnniVpi.setDescription('The VPI used for PNNI.')
configCommonEPortPnniVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortPnniVci.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortPnniVci.setDescription('The VCI used for PNNI.')
configCommonEPortAbrBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortAbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortAbrBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for ABR traffic.')
configCommonEPortVbrRtBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortVbrRtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortVbrRtBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for rt-VBR traffic.')
configCommonEPortVbrNrtBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortVbrNrtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortVbrNrtBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for nrt-VBR traffic.')
configCommonEPortCbrBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortCbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortCbrBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for CBR traffic.')
configStaticEPortIlmiPollFrequency = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configStaticEPortIlmiPollFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: configStaticEPortIlmiPollFrequency.setDescription('Polling frequency in seconds for maintaining ILMI connectivity.')
configStaticEPortIlmiPollRetries = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configStaticEPortIlmiPollRetries.setStatus('mandatory')
if mibBuilder.loadTexts: configStaticEPortIlmiPollRetries.setDescription('The number of retries before declaring a loss of ILMI connectivity.')
configStaticEPortMaxTransientPhyFailureTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configStaticEPortMaxTransientPhyFailureTime.setStatus('mandatory')
if mibBuilder.loadTexts: configStaticEPortMaxTransientPhyFailureTime.setDescription('The maximum time in seconds where loss of signal or lack of rx sync is not considered a loss of PHY connectivity. A value of 0 indicates that failures will never be considered transient.')
configStaticEPortMaxPhyFailuresPerMinute = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configStaticEPortMaxPhyFailuresPerMinute.setStatus('deprecated')
if mibBuilder.loadTexts: configStaticEPortMaxPhyFailuresPerMinute.setDescription('The maximum number of transient or non-transient PHY failures per minute before an ATM port is automatically disabled and an ePortAutoDisabled trap is generated.')
configCommonEPortLinkDelay = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortLinkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortLinkDelay.setDescription('The expected transmission delay on the ATM link (in microseconds).')
configCommonEPortTransientPhyOffTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortTransientPhyOffTime.setStatus('deprecated')
if mibBuilder.loadTexts: configCommonEPortTransientPhyOffTime.setDescription('The time (in seconds) that the PHY may be disconnected during configCommonEPortTransientPhyWindowTime before an ePortAutoDisabled trap is sent.')
configCommonEPortTransientPhyWindowTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortTransientPhyWindowTime.setStatus('deprecated')
if mibBuilder.loadTexts: configCommonEPortTransientPhyWindowTime.setDescription('The duration (in seconds) of the window used for measuring PHY down time.')
configCommonEPortTransientPhyDisconnectCount = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortTransientPhyDisconnectCount.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortTransientPhyDisconnectCount.setDescription('Number of PHY disconnects that may occur during configCommonEPortTransientPhyDisconnectTimer before an ePortAutoDisabled trap is sent.')
configCommonEPortTransientPhyDisconnectTimer = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortTransientPhyDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortTransientPhyDisconnectTimer.setDescription('The duration (in seconds) of the time used for counting PHY disconnects.')
configCommonEPortDefaultSigVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uni", 1), ("pnni", 2), ("iispNetworkSide", 3), ("iispUserSide", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortDefaultSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortDefaultSigVersion.setDescription('The signalling version used if ILMI autoconfiguration is not possible.')
configCommonEPortMaxSvpcVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the port is configured to support for allocation to SVPCs.')
configCommonEPortMaxSvccVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the port is configured to support for allocation to SVCCs.')
configCommonEPortMinSvccVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 12, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonEPortMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonEPortMinSvccVci.setDescription('The minimum VCI that the signalling stack on the port is configured to support for allocation to SVCCs. The same value applies to all SVCC VPI values for which the signalling stack is configured.')
configEPortScratchPadScratchPadStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notReady", 1), ("copy", 2), ("copied", 3), ("updateAndGo", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadScratchPadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadScratchPadStatus.setDescription('Controls the copying of data between configEPortTable and the ePort scratch pad.')
configEPortScratchPadEPortIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadEPortIndex.setDescription('Set to the row index in configEPortTable before the contents of the row are copied to the ePort scratch pad.')
configEPortScratchPadIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortScratchPadIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIpAddress.setDescription('The IP address of the manager that uses the ePort scratch pad. Used as a lock.')
configEPortScratchPadActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("failed", 2), ("notPossible", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortScratchPadActionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadActionStatus.setDescription('The result of an attempt to copy between configEPortTable and the scratch pad.')
configEPortScratchPadHwConfigTxClocking = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadHwConfigTxClocking.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadHwConfigTxClocking.setDescription('A copy of configEPortHwConfigTxClocking.')
configEPortScratchPadHwConfigSonetSdh = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadHwConfigSonetSdh.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadHwConfigSonetSdh.setDescription('A copy of configEPortHwConfigSonetSdh.')
configEPortScratchPadUseCommonEPortConfig = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadUseCommonEPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadUseCommonEPortConfig.setDescription('A copy of configEPortUseCommonEPortConfig.')
configEPortScratchPadLoopback = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("line", 2), ("payload", 3), ("diag", 4), ("externalLine", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadLoopback.setDescription('A copy of configEPortLoopback.')
configEPortScratchPadIlmiConfigIlmiAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("full", 1), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiAdminStatus.setDescription('A copy of configEPortIlmiConfigIlmiAdminStatus.')
configEPortScratchPadIlmiConfigAddrRegistrationAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigAddrRegistrationAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigAddrRegistrationAdminStatus.setDescription('A copy of configEPortIlmiConfigAddrRegistrationAdminStatus.')
configEPortScratchPadIlmiConfigMaxVpcs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVpcs.setDescription('A copy of configEPortIlmiConfigMaxVpcs.')
configEPortScratchPadIlmiConfigMaxVccs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVccs.setDescription('A copy of configEPortIlmiConfigMaxVccs.')
configEPortScratchPadIlmiConfigMaxVpiBits = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVpiBits.setDescription('A copy of configEPortIlmiConfigMaxVpiBits.')
configEPortScratchPadIlmiConfigMaxVciBits = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxVciBits.setDescription('A copy of configEPortIlmiConfigMaxVciBits.')
configEPortScratchPadIlmiConfigUniType = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigUniType.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigUniType.setDescription('A copy of configEPortIlmiConfigUniType.')
configEPortScratchPadIlmiConfigUniVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("version3point0", 2), ("version3point1", 3), ("version4point0", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigUniVersion.setDescription('A copy of configEPortIlmiConfigUniVersion.')
configEPortScratchPadIlmiConfigDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigDeviceType.setDescription('A copy of configEPortIlmiConfigDeviceType.')
configEPortScratchPadIlmiConfigIlmiVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVersion.setDescription('A copy of configEPortIlmiConfigIlmiVersion.')
configEPortScratchPadIlmiConfigNniSigVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigNniSigVersion.setDescription('A copy of configEPortIlmiConfigNniSigVersion.')
configEPortScratchPadIlmiConfigSignallingVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigSignallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigSignallingVpi.setDescription('A copy of configEPortIlmiConfigSignallingVpi.')
configEPortScratchPadIlmiConfigSignallingVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigSignallingVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigSignallingVci.setDescription('A copy of configEPortIlmiConfigSignallingVci.')
configEPortScratchPadIlmiConfigIlmiVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVpi.setDescription('A copy of configEPortIlmiConfigIlmiVpi.')
configEPortScratchPadIlmiConfigIlmiVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigIlmiVci.setDescription('A copy of configEPortIlmiConfigIlmiVci.')
configEPortScratchPadIlmiConfigLecsVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigLecsVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigLecsVpi.setDescription('A copy of configEPortIlmiConfigLecsVpi.')
configEPortScratchPadIlmiConfigLecsVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigLecsVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigLecsVci.setDescription('A copy of configEPortIlmiConfigLecsVci.')
configEPortScratchPadIlmiConfigPnniVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigPnniVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigPnniVpi.setDescription('A copy of configEPortIlmiConfigPnniVpi.')
configEPortScratchPadIlmiConfigPnniVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigPnniVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigPnniVci.setDescription('A copy of configEPortIlmiConfigPnniVci.')
configEPortScratchPadAbrBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadAbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadAbrBandwidthAllocation.setDescription('A copy of configEPortAbrBandwidthAllocation.')
configEPortScratchPadVbrRtBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadVbrRtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadVbrRtBandwidthAllocation.setDescription('A copy of configEPortVbrRtBandwidthAllocation.')
configEPortScratchPadVbrNrtBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadVbrNrtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadVbrNrtBandwidthAllocation.setDescription('A copy of configEPortVbrNrtBandwidthAllocation.')
configEPortScratchPadCbrBandwidthAllocation = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadCbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadCbrBandwidthAllocation.setDescription('A copy of configEPortCbrBandwidthAllocation.')
configEPortScratchPadLinkDelay = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadLinkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadLinkDelay.setDescription('A copy of configEPortLinkDelay.')
configEPortScratchPadTransientPhyOffTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyOffTime.setStatus('deprecated')
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyOffTime.setDescription('A copy of configEPortTransientPhyOffTime.')
configEPortScratchPadTransientPhyWindowTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyWindowTime.setStatus('deprecated')
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyWindowTime.setDescription('A copy of configEPortTransientPhyWindowTime.')
configEPortScratchPadTransientPhyDisconnectCount = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyDisconnectCount.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyDisconnectCount.setDescription('A copy of configEPortTransientPhyDisconnectCount.')
configEPortScratchPadTransientPhyDisconnectTimer = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadTransientPhyDisconnectTimer.setDescription('A copy of configEPortTransientPhyDisconnectTimer.')
configEPortScratchPadBandwidthLimit = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadBandwidthLimit.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadBandwidthLimit.setDescription('A copy of configEPortBandwidthLimit.')
configEPortScratchPadDefaultSigVersion = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uni", 1), ("pnni", 2), ("iispNetworkSide", 3), ("iispUserSide", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadDefaultSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadDefaultSigVersion.setDescription('A copy of configEPortDefaultSigVersion.')
configEPortScratchPadIlmiConfigMaxSvpcVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxSvpcVpi.setDescription('A copy of configEPortIlmiConfigMaxSvpcVpi.')
configEPortScratchPadIlmiConfigMaxSvccVpi = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMaxSvccVpi.setDescription('A copy of configEPortIlmiConfigMaxSvccVpi.')
configEPortScratchPadIlmiConfigMinSvccVci = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortScratchPadIlmiConfigMinSvccVci.setDescription('A copy of configEPortIlmiConfigMinSvccVci.')
configEPortTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38), )
if mibBuilder.loadTexts: configEPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortTable.setDescription('This table contains configuration for each ATM port (ePort) in the switch. The table may be modified through the ePort scratch pad.')
configEPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configEPortIfIndex"))
if mibBuilder.loadTexts: configEPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortEntry.setDescription('Each row in this table describes one ATM port (ePort).')
configEPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIfIndex.setDescription('The ifIndex of the ATM port described by this row.')
configEPortHwConfigTxClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("local", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortHwConfigTxClocking.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortHwConfigTxClocking.setDescription('The clocking source for this ATM port. This setting is disregarded if this port is configured to receive the master clock from the network.')
configEPortHwConfigSonetSdh = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortHwConfigSonetSdh.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortHwConfigSonetSdh.setDescription('The cell framing used on this ATM port.')
configEPortUseCommonEPortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortUseCommonEPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortUseCommonEPortConfig.setDescription('Indicates if this ATM port should use the common ePort configuration (found in the configCommonEPort MIB subtree) or its own configuration.')
configEPortLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("line", 2), ("payload", 3), ("diag", 4), ("externalLine", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortLoopback.setDescription('The hardware loopback type on this ATM port.')
configEPortIlmiConfigIlmiAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("full", 1), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiAdminStatus.setDescription('Enables or disables ILMI on this ATM port.')
configEPortIlmiConfigAddrRegistrationAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigAddrRegistrationAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigAddrRegistrationAdminStatus.setDescription('Enables or disables the address registration protocol on this ATM port.')
configEPortIlmiConfigMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVpcs.setDescription('The maximum number of VPCs on this ATM port.')
configEPortIlmiConfigMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVccs.setDescription('The maximum number of VCCs on this ATM port.')
configEPortIlmiConfigMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVpiBits.setDescription('The number of bits used in a VPI on this ATM port.')
configEPortIlmiConfigMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxVciBits.setDescription('The number of bits used in a VCI on this ATM port.')
configEPortIlmiConfigUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigUniType.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigUniType.setDescription('The UNI type on this ATM port.')
configEPortIlmiConfigUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("version3point0", 2), ("version3point1", 3), ("version4point0", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigUniVersion.setDescription('The highest UNI version used on this ATM port.')
configEPortIlmiConfigDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigDeviceType.setDescription('The ATM port device type.')
configEPortIlmiConfigIlmiVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVersion.setDescription('The highest ILMI version used on this ATM port.')
configEPortIlmiConfigNniSigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigNniSigVersion.setDescription('The NNI signalling protocol used on this ATM port.')
configEPortIlmiConfigSignallingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigSignallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigSignallingVpi.setDescription('The VPI used for signalling.')
configEPortIlmiConfigSignallingVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigSignallingVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigSignallingVci.setDescription('The VCI used for signalling.')
configEPortIlmiConfigIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVpi.setDescription('The VPI used for ILMI.')
configEPortIlmiConfigIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigIlmiVci.setDescription('The VCI used for ILMI.')
configEPortIlmiConfigLecsVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigLecsVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigLecsVpi.setDescription('The VPI used for LECS.')
configEPortIlmiConfigLecsVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigLecsVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigLecsVci.setDescription('The VCI used for LECS.')
configEPortIlmiConfigPnniVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigPnniVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigPnniVpi.setDescription('The VPI used for PNNI.')
configEPortIlmiConfigPnniVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigPnniVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigPnniVci.setDescription('The VCI used for PNNI.')
configEPortAbrBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortAbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortAbrBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for ABR traffic.')
configEPortVbrRtBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortVbrRtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortVbrRtBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for rt-VBR traffic.')
configEPortVbrNrtBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortVbrNrtBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortVbrNrtBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for nrt-VBR traffic.')
configEPortCbrBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortCbrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortCbrBandwidthAllocation.setDescription('The maximum percentage of the ATM link bandwidth that may be used for CBR traffic.')
configEPortLinkDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortLinkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortLinkDelay.setDescription('The expected transmission delay on the ATM link (in microseconds).')
configEPortTransientPhyOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortTransientPhyOffTime.setStatus('deprecated')
if mibBuilder.loadTexts: configEPortTransientPhyOffTime.setDescription('The time (in seconds) that the PHY may be disconnected during configEPortTransientPhyWindowTime before an ePortAutoDisabled trap is sent.')
configEPortTransientPhyWindowTime = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortTransientPhyWindowTime.setStatus('deprecated')
if mibBuilder.loadTexts: configEPortTransientPhyWindowTime.setDescription('The duration (in seconds) of the window used for measuring PHY down time.')
configEPortTransientPhyDisconnectCount = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortTransientPhyDisconnectCount.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortTransientPhyDisconnectCount.setDescription('Number of PHY disconnects that may occur during configEPortTransientPhyDisconnectTimer before an ePortAutoDisabled trap is sent.')
configEPortTransientPhyDisconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortTransientPhyDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortTransientPhyDisconnectTimer.setDescription('The duration (in seconds) of the time used for counting PHY disconnects.')
configEPortBandwidthLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortBandwidthLimit.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortBandwidthLimit.setDescription('The maximum total bandwidth that may be used on this ATM port (in cells/seconds). A value of -1 indicates that the full link rate may be used.')
configEPortDefaultSigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uni", 1), ("pnni", 2), ("iispNetworkSide", 3), ("iispUserSide", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortDefaultSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortDefaultSigVersion.setDescription('The signalling version used if ILMI autoconfiguration is not possible.')
configEPortIlmiConfigMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the port is configured to support for allocation to SVPCs.')
configEPortIlmiConfigMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the port is configured to support for allocation to SVCCs.')
configEPortIlmiConfigMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 13, 38, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPortIlmiConfigMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: configEPortIlmiConfigMinSvccVci.setDescription('The minimum VCI that the signalling stack on the port is configured to support for allocation to SVCCs. The same value applies to all SVCC VPI values for which the signalling stack is configured.')
configCpuPortCpuQueueSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 14, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCpuPortCpuQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCpuPortCpuQueueSize.setDescription('The maximum size of the switch processor queue. This must be an number of the form 255+256*N, where N is an integer.')
configCpuPortResetQueueSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 14, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCpuPortResetQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCpuPortResetQueueSize.setDescription('The maximum size of the reset queue. This must be an number of the form 255+256*N, where N is an integer.')
configCommonIPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1), )
if mibBuilder.loadTexts: configCommonIPortQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortQueueTable.setDescription('This table contains configuration data for the four queues associated with each iPort.')
configCommonIPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configCommonIPortQueueIndex"))
if mibBuilder.loadTexts: configCommonIPortQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortQueueEntry.setDescription('Each row in this table contains data for one queue, but common to all iPorts.')
configCommonIPortQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configCommonIPortQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortQueueIndex.setDescription('The queue number.')
configCommonIPortEfciTaggingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortEfciTaggingAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortEfciTaggingAdminStatus.setDescription('Enables or disables Explicit Forward Congestion Indication (EFCI) on a queue.')
configCommonIPortClpDiscardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortClpDiscardAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortClpDiscardAdminStatus.setDescription('Enables or disables discarding of CLP=1 cells on a queue.')
configCommonIPortEfciTaggingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortEfciTaggingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortEfciTaggingThreshold.setDescription('The queue length threshold beyond which cells in the queue are tagged with EFCI. The threshold is given as a fraction of the maximum queue length.')
configCommonIPortClpDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortClpDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortClpDiscardThreshold.setDescription('The queue length threshold beyond which CLP=1 cells are dropped rather than added to the queue. The threshold is given as a fraction of the maximum queue length.')
configCommonIPortQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortQueueSize.setDescription('The maximum queue size. This must be an number of the form 255+256*N, where N is an integer.')
configCommonIPortLogClr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortLogClr.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortLogClr.setDescription('The worst expected Cell Loss Ratio for this queue. The number is expressed as minus the base 10 logarithm of the Cell Loss Ratio.')
configCommonIPortCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 15, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonIPortCdv.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonIPortCdv.setDescription('The worst expected Cell Delay Variation (in microseconds) for this queue.')
configPriorityBufferTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 26, 1), )
if mibBuilder.loadTexts: configPriorityBufferTable.setStatus('mandatory')
if mibBuilder.loadTexts: configPriorityBufferTable.setDescription('This table contains the maximum total number of cells buffers that may be allocated to a particular queue priority.')
configPriorityBufferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 26, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configPriorityBufferIndex"))
if mibBuilder.loadTexts: configPriorityBufferEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configPriorityBufferEntry.setDescription('Each row in this table describes one queue priority.')
configPriorityBufferIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPriorityBufferIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configPriorityBufferIndex.setDescription('The queue priority.')
configPriorityBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 26, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPriorityBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: configPriorityBufferSize.setDescription('The maximum total cell buffer allocation for this queue priority.')
configIPortScratchPadScratchPadStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notReady", 1), ("copy", 2), ("copied", 3), ("updateAndGo", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadScratchPadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadScratchPadStatus.setDescription('Controls the copying of data between configIPort(Queue)Table and the iPort scratch pad.')
configIPortScratchPadSlotIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadSlotIndex.setDescription('Set to the expansion module number in configIPort(Queue)Table before the contents of the row are copied to the iPort scratch pad.')
configIPortScratchPadIPortRIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadIPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadIPortRIndex.setDescription('Set to the iPort number in configIPort(Queue)Table before the contents of the row are copied to the iPort scratch pad.')
configIPortScratchPadIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortScratchPadIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadIpAddress.setDescription('The IP address of the manager that uses the iPort scratch pad. Used as a lock.')
configIPortScratchPadActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("failed", 2), ("notPossible", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortScratchPadActionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadActionStatus.setDescription('The result of an attempt to copy between configEPortTable and the scratch pad.')
configIPortScratchPadUseCommonIPortConfig = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadUseCommonIPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadUseCommonIPortConfig.setDescription('A copy of configIPortUseCommonIPortConfig.')
configIPortScratchPadQueueTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7), )
if mibBuilder.loadTexts: configIPortScratchPadQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueTable.setDescription('A copy of configIPortQueueTable for one iPort.')
configIPortScratchPadQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configIPortScratchPadQueueQueueIndex"))
if mibBuilder.loadTexts: configIPortScratchPadQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueEntry.setDescription('Each row in this table describes one queue for one iPort.')
configIPortScratchPadQueueQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortScratchPadQueueQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueQueueIndex.setDescription('A copy of configIPortQueueSlotIndex.')
configIPortScratchPadQueueEfciTaggingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueEfciTaggingAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueEfciTaggingAdminStatus.setDescription('A copy of configIPortQueueEfciTaggingAdminStatus.')
configIPortScratchPadQueueClpDiscardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueClpDiscardAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueClpDiscardAdminStatus.setDescription('A copy of configIPortQueueClpDiscardAdminStatus.')
configIPortScratchPadQueueEfciTaggingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueEfciTaggingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueEfciTaggingThreshold.setDescription('A copy of configIPortQueueEfciTaggingThreshold.')
configIPortScratchPadQueueClpDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueClpDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueClpDiscardThreshold.setDescription('A copy of configIPortQueueClpDiscardThreshold.')
configIPortScratchPadQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueSize.setDescription('A copy of configIPortQueueSize.')
configIPortScratchPadQueueLogClr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueLogClr.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueLogClr.setDescription('A copy of configIPortQueueLogClr.')
configIPortScratchPadQueueCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortScratchPadQueueCdv.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortScratchPadQueueCdv.setDescription('A copy of configIPortQueueCdv.')
configIPortTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 8), )
if mibBuilder.loadTexts: configIPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortTable.setDescription('This table contains configuration for each Core Access Point (iPort) in the switch. The table may be modified through the iPort scratch pad.')
configIPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 8, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configIPortSlotIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "configIPortRIndex"))
if mibBuilder.loadTexts: configIPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortEntry.setDescription('Each row in this table describes one Core Access Point (iPort).')
configIPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortSlotIndex.setDescription('The number of the expansion module to which the iPort is connected.')
configIPortRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortRIndex.setDescription('The number of the iPort within the expansion module.')
configIPortUseCommonIPortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortUseCommonIPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortUseCommonIPortConfig.setDescription('Indicates if this iPort should use the common iPort configuration (found in the configCommonIPort MIB subtree) or its own configuration.')
configIPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9), )
if mibBuilder.loadTexts: configIPortQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueTable.setDescription('This table contains configuration for each queue. The table may be modified through the iPort scratch pad.')
configIPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configIPortQueueSlotIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "configIPortQueueRIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "configIPortQueueQueueIndex"))
if mibBuilder.loadTexts: configIPortQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueEntry.setDescription('Each row in this table describes one queue.')
configIPortQueueSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueSlotIndex.setDescription('The number of the expansion module to which the iPort for this queue is connected.')
configIPortQueueRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueRIndex.setDescription('The number of the iPort within the expansion module.')
configIPortQueueQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueQueueIndex.setDescription('The queue priority.')
configIPortQueueEfciTaggingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueEfciTaggingAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueEfciTaggingAdminStatus.setDescription('Enables or disables Explicit Forward Congestion Indication (EFCI) on this queue.')
configIPortQueueClpDiscardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueClpDiscardAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueClpDiscardAdminStatus.setDescription('Enables or disables discarding of CLP=1 cells on this queue.')
configIPortQueueEfciTaggingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueEfciTaggingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueEfciTaggingThreshold.setDescription('The queue length threshold beyond which cells in the queue are tagged with EFCI. The threshold is given as a fraction of the maximum queue length.')
configIPortQueueClpDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneEighth", 1), ("oneFourth", 2), ("oneHalf", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueClpDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueClpDiscardThreshold.setDescription('The queue length threshold beyond which CLP=1 cells are dropped rather than added to the queue. The threshold is given as a fraction of the maximum queue length.')
configIPortQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIPortQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueSize.setDescription('The maximum queue size. This must be an number of the form 255+256*N, where N is an integer.')
configIPortQueueLogClr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortQueueLogClr.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueLogClr.setDescription('The worst expected Cell Loss Ratio for this queue. The number is expressed as minus the base 10 logarithm of the Cell Loss Ratio.')
configIPortQueueCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 16, 9, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIPortQueueCdv.setStatus('mandatory')
if mibBuilder.loadTexts: configIPortQueueCdv.setDescription('The worst expected Cell Delay Variation (in microseconds) for this queue.')
pvpSetupTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvpSetupTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupTableNextIndex.setDescription('The next unused row in pvpSetupTable.')
pvpSetupTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2), )
if mibBuilder.loadTexts: pvpSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupTable.setDescription('This table contains all Permanent Virtual Paths (PVPs) in the switch.')
pvpSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "pvpSetupIndex"))
if mibBuilder.loadTexts: pvpSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupEntry.setDescription("Each row in this table describes one PVP. PVPs typically connect two ATM ports. The numerically lowest of these is called the 'low' port, and the numerically highest is called the 'high' port.")
pvpSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvpSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
pvpSetupApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transitVp", 1), ("softPvpOriginatorVpl", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupApplication.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupApplication.setDescription("The PVP type. The value 'transitVp' indicates a PVP that passes through the switch and has high and low end configuration. The value 'softPvpOriginatorVpl' indicates a PVP that terminates in the switch itself and only low end configuration is present.")
pvpSetupLowEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupLowEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupLowEPortIndex.setDescription('The ifIndex of the low port connected to this PVP.')
pvpSetupLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupLowVpi.setDescription('The VPI used at the low end of the PVP.')
pvpSetupHighEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupHighEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupHighEPortIndex.setDescription('The ifIndex of the high port connected to this PVP.')
pvpSetupHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupHighVpi.setDescription('The VPI used at the high end of the PVP.')
pvpSetupVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvpSetupVpCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupVpCrossConnectIndex.setDescription('After the PVP has been created, this is the index into the atmVpCrossConnectTable in the ATM MIB.')
pvpSetupL2HTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupL2HTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupL2HTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction low-to-high.')
pvpSetupH2LTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupH2LTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupH2LTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction high-to-low.')
pvpSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvpSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pvpSetupRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
pvcSetupTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSetupTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupTableNextIndex.setDescription('The next unused row in pvcSetupTable.')
pvcSetupTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4), )
if mibBuilder.loadTexts: pvcSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupTable.setDescription('This table contains all Permanent Virtual Channels (PVCs) in the switch.')
pvcSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "pvcSetupIndex"))
if mibBuilder.loadTexts: pvcSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupEntry.setDescription("Each row in this table describes one PVC. PVCs typically connect two ATM ports. The numerically lowest of these is called the 'low' port, and the numerically highest is called the 'high' port.")
pvcSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
pvcSetupApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("transitVc", 1), ("softPvcOriginatorVcl", 2), ("classicalIpArpSrvVcl", 3), ("lesCntrlDirectVcl", 4), ("busMcastSendVcl", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupApplication.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupApplication.setDescription("The PVC type. The value 'transitVc' indicates a PVC that passes through the switch and has high and low end configuration. The other values indicate a PVP that terminates in the switch itself and only low end configuration is present. Legal values are: transitVc A PVC that passes through the switch. softPvcOriginatorVcl One end of a soft PVC. classicalIpArpSrvVcl The PVC connects the classical IP ARP server to the specified ATM port. lesCntrlDirectVcl The PVC connects the LAN Emulation Server (LES) to the specified ATM port. busMcastSendVcl The PVC connects the Broadcast and Unknown Server (BUS) to the specified ATM port.")
pvcSetupLowEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupLowEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupLowEPortIndex.setDescription('The ifIndex of the low port connected to this PVC.')
pvcSetupLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupLowVpi.setDescription('The VPI used at the low end of the PVC.')
pvcSetupLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupLowVci.setDescription('The VCI used at the low end of the PVC.')
pvcSetupHighEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupHighEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupHighEPortIndex.setDescription('The ifIndex of the high port connected to this PVC.')
pvcSetupHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupHighVpi.setDescription('The VPI used at the high end of the PVC.')
pvcSetupHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupHighVci.setDescription('The VCI used at the high end of the PVC.')
pvcSetupVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSetupVcCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupVcCrossConnectIndex.setDescription('After the PVC has been created, this is the index into the atmVcCrossConnectTable in the ATM MIB.')
pvcSetupL2HTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupL2HTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupL2HTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction low-to-high.')
pvcSetupH2LTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupH2LTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupH2LTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction high-to-low.')
pvcSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 17, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSetupRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
svpSetupTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svpSetupTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupTableNextIndex.setDescription('The next unused row in svpSetupTable.')
svpSetupTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2), )
if mibBuilder.loadTexts: svpSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupTable.setDescription('This table contains all Soft Virtual Paths (SVPs) in the switch.')
svpSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "svpSetupIndex"))
if mibBuilder.loadTexts: svpSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupEntry.setDescription('Each row in this table describes one SVP.')
svpSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svpSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
svpSetupApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("tunnel", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: svpSetupApplication.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupApplication.setDescription('The SVP type. Only one type (tunnel) is currently available.')
svpSetupEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupEPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupEPortIndex.setDescription('The ifIndex of the ATM port connected to this SVP.')
svpSetupPreferredVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupPreferredVpi.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupPreferredVpi.setDescription('The preferred VPI number to use on the ATM port given in svpSetupEPortIndex.')
svpSetupTermAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 5), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupTermAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupTermAtmAddr.setDescription('The ATM address to which the SVP should be connected.')
svpSetupVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svpSetupVpCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupVpCrossConnectIndex.setDescription('After the SVP has been created, this is the index into the atmVpCrossConnectTable in the ATM MIB.')
svpSetupTxTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupTxTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupTxTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction svpSetupEPortIndex-to-svpSetupTermAtmAddr.')
svpSetupRxTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupRxTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupRxTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction svpSetupTermAtmAddr-to-svpSetupEPortIndex.')
svpSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svpSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: svpSetupRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
svcSetupTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSetupTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupTableNextIndex.setDescription('The next unused row in svcSetupTable.')
svcSetupTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4), )
if mibBuilder.loadTexts: svcSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupTable.setDescription('This table contains all Soft Virtual Channels (SVCs) in the switch.')
svcSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "svcSetupIndex"))
if mibBuilder.loadTexts: svcSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupEntry.setDescription('Each row in this table describes one SVC.')
svcSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
svcSetupApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("classicalIpArpSrv", 1), ("lecsConfigDirectSvc", 2), ("lesCntrlDirectSvc", 3), ("busMcastSendSvc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSetupApplication.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupApplication.setDescription('The SVC type. The following values exist: classicalIpArpSrv The SVC connects the classical IP ARP server with the specified ATM address. lecsConfigDirectSvc The SVC connects the LAN Emulation Configuration Server (LECS) with the specified ATM address. lesCntrlDirectSvc The SVC connects the LAN Emulation Server (LES) with the specified ATM address. busMcastSendSvc The SVC connects the Broadcast and Unknown Server (BUS) with the specified ATM address.')
svcSetupTermAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcSetupTermAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupTermAtmAddr.setDescription('The ATM address to which the SVC should be connected.')
svcSetupVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSetupVcCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupVcCrossConnectIndex.setDescription('After the SVC has been created, this is the index into the atmVpCrossConnectTable in the ATM MIB.')
svcSetupTxTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcSetupTxTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupTxTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction switch-to-svcSetupTermAtmAddr.')
svcSetupRxTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcSetupRxTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupRxTrafficDescriptorIndex.setDescription('The index into the trafficDescriptorTable for the traffic descriptor used in the direction svcSetupTermAtmAddr-to-switch.')
svcSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 18, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: svcSetupRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
configCommonSignallingMaxTunnels = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxTunnels.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingMaxTunnels.setDescription('The maximum number of additional signalling and SSCOP incarnations needed to service tunnels.')
configCommonSignallingMaxSaps = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 511))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxSaps.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingMaxSaps.setDescription('The maximum number of SAPs (logical users) supported by the signalling subsystem. This value must be at least the number of ATM ports present plus the number of virtual ports (for LEC, LES and CLIP) plus the number of signalling tunnels.')
configCommonSignallingMaxPvcs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxPvcs.setStatus('obsolete')
if mibBuilder.loadTexts: configCommonSignallingMaxPvcs.setDescription('The maximum number of simultaneously active PVCs (connections) in the entire switch.')
configCommonSignallingMaxSvcs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingMaxSvcs.setDescription('The maximum number of simultaneously active SVCs (calls/connections) signalling instances in the entire switch. Note that each call/connection through the switch uses two of these (in and out), so the maximum number of SVC calls/connections through the switch is half this value. This values encompasses both point-to-point SVCs and SVPs, as well as point-to-multipoint SVCs (basic call part of pt-to-mpt connection).')
configCommonSignallingMaxConManStevs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxConManStevs.setStatus('obsolete')
if mibBuilder.loadTexts: configCommonSignallingMaxConManStevs.setDescription('The maximum number of Connection Manager state-event machines, i.e. the maximum number of SVC+PVC calls/connections being processed simultaneously.')
configCommonSignallingMaxSigProtStevs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingMaxSigProtStevs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingMaxSigProtStevs.setDescription("The maximum number SVC calls/connections setup or clear operations that can be processed concurrently in the entire switch. Actually twice this number of call processors will be allocated - half for incoming and half for outgoing operations. Since the switch uses two call processors for a 'through-switch' call (one incoming and one outgoing), this means that this value directly describes the number of simultaneous 'through-switch' call/connection setup or clear operations supported by the switch.")
configCommonSignallingT301 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT301.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT301.setDescription('The maximum time (in seconds) to wait for CONNECT after receiving ALERTING. Should be at least 3 minutes (180 seconds).')
configCommonSignallingT302 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT302.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT302.setDescription('For N-ISDN interworking. Currently not used.')
configCommonSignallingT303 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT303.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT303.setDescription('The maximum time (in seconds) to wait for response to SETUP (i.e. CALL-PROCEEDING, ALERTING or CONNECT).')
configCommonSignallingT304 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT304.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT304.setDescription('For N-ISDN interworking. Currently not used.')
configCommonSignallingT306 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT306.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT306.setDescription('For N-ISDN interworking. Currently not used.')
configCommonSignallingT308 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT308.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT308.setDescription('The maximum time to wait for response to RELEASE.')
configCommonSignallingT309 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT309.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT309.setDescription('The maximum time (in seconds) allowing SAAL (SSCOP) connection loss. If SSCOP experiences connection loss for longer than this time for a signalling connection, the signalling instance will clear all its calls: active calls, as well as calls under establishment. The switch will propagate these call clearings through towards the remote endpoint.')
configCommonSignallingT310 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT310.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT310.setDescription('The maximum time (in seconds) to wait for response to SETUP (i.e. ALERTING or CONNECT) after receiving CALL PROCEEDING.')
configCommonSignallingT313 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT313.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT313.setDescription('The maximum time (in seconds) to wait for response to CONNECT.')
configCommonSignallingT316 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT316.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT316.setDescription('The maximum time (in seconds) to wait for response to RESTART.')
configCommonSignallingT317 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT317.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT317.setDescription('The maximum time (in seconds) to act on RESTART. Should be less than configCommonSignallingT316.')
configCommonSignallingT322 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT322.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT322.setDescription('The maximum time (in seconds) to wait for response to STATUS ENQUIRY.')
configCommonSignallingT331 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT331.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT331.setDescription('For Leaf Initiated Join support: The maximum time (in seconds) to wait for response to LEAF SETUP REQUEST.')
configCommonSignallingT333 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT333.setStatus('obsolete')
if mibBuilder.loadTexts: configCommonSignallingT333.setDescription('This timer value is no longer used. Was removed from final UNI4.0 signalling specification.')
configCommonSignallingT397 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT397.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT397.setDescription('The maximum time (in seconds) to wait for ADD PARTY ACK after receiving ALERTING or ADD PARTY ALERTED. Should be minimum 3 minutes (180 seconds). Note: Should usually be the same as configCommonSignallingT301.')
configCommonSignallingT398 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT398.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT398.setDescription('For point-to-multipoint support: The maximum time (in seconds) to wait for response to DROP PARTY.')
configCommonSignallingT399 = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingT399.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingT399.setDescription('For point-to-multipoint support: The maximum time (in seconds) to wait for response to ADD PARTY.')
configCommonSignallingPtmpMaxLeafs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafs.setDescription('The maximum number of simultaneously active point-to-multipoint SVC leaf connection signalling instances (in the entire switch). Note that each leaf connection through the switch uses two of these (in and out), so the maximum number of SVC leaf connections through the switch is half this value.')
configCommonSignallingPtmpMaxLeafOperations = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafOperations.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafOperations.setDescription("The maximum number of signalling pt-to-mpt SVC leaf add or drop operations that can be processed concurrently in the entire switch. Actually twice this number of leaf processors will be allocated - half for incoming and half for outgoing operations. So since the switch uses two leaf processors (one incoming and one outgoing) to process a 'through-switch' operation, this means that this value directly describes the number of simultaneous 'through-switch' leaf add or drop operations supported by the switch.")
configCommonSignallingPtmpMaxLeafsDropByClear = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafsDropByClear.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxLeafsDropByClear.setDescription('The maximum number of concurrent leaf drop operations (for a single pt-to-mpt connection) when initiated by call clearing.')
configCommonSignallingPtmpMaxP2mpSvcs = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxP2mpSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSignallingPtmpMaxP2mpSvcs.setDescription('The maximum number of the Signalling SVCs in the switch that can provide point-to-multipoint support. Note that each pt-to-mpt connection through the switch uses two of these (incoming and outgoing), so the maximum number of SVCs that can provide pt-to-mpt support through the switch is half this value.')
configCommonSscopMaxSaps = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxSaps.setStatus('obsolete')
if mibBuilder.loadTexts: configCommonSscopMaxSaps.setDescription('The maximum number of SSCOP SAPs. This value is not used.')
configCommonSscopMaxLinks = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxLinks.setStatus('obsolete')
if mibBuilder.loadTexts: configCommonSscopMaxLinks.setDescription('The maximum number of SSCOP Links. This value is not used.')
configCommonSscopMaxRcvWinSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxRcvWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxRcvWinSize.setDescription('The maximum SSCOP protocol receive window size. Q.2110, app.IV, defines calculation of window size.')
configCommonSscopMaxCc = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxCc.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxCc.setDescription('The maximum SSCOP Connection Control state variable value (the maximum transmissions of a BGN, END, ER or RS PDU).')
configCommonSscopMaxPd = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxPd.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxPd.setDescription('The maximum SSCOP Poll Data state variable value (the maximum transmissions of between polls).')
configCommonSscopMaxStat = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxStat.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxStat.setDescription('The maximum number of list elements placed in a SSCOP STAT PDU.')
configCommonSscopTimerPoll = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopTimerPoll.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopTimerPoll.setDescription('SSCOP Timer-POLL (in milliseconds). This defines the maximum interval between SSCOP sending POLLs, while it has unacknowledged SD PDU transmits. Ensures that peer receiver is polled often enough to return its status. Optimized to maintain optimum flow. Timer-NO-RESPONSE must be greater than timer-POLL.')
configCommonSscopTimerNoResponse = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopTimerNoResponse.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopTimerNoResponse.setDescription('SSCOP Timer-NO-RESPONSE (in seconds). The time interval during which at least one STAT PDU must be received, when there are unacknowledged SD PDU transmits. Must be at least Timer-KEEP-ALIVE + round-trip delay. Timer-NO-RESPONSE must be greater than timer-POLL.')
configCommonSscopTimerKeepAlive = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopTimerKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopTimerKeepAlive.setDescription('SSCOP Timer-KEEP-ALIVE (in seconds). Used when there are no unacknowledged SD PDU transmits. Defines the time period after sending a POLL, during which a STAT response must have been received. Generally, this value is greater than both Timer-POLL and round-trip delay.')
configCommonSscopTimerIdle = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopTimerIdle.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopTimerIdle.setDescription('SSCOP Timer-IDLE (in seconds). Defines the idle-period during which no POLL PDUs are sent, when there are no unacknowledged SD PDU transmits. May be much greater than Timer-KEEP-ALIVE.')
configCommonSscopTimerCc = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopTimerCc.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopTimerCc.setDescription('SSCOP Timer-CC (in units of 100 milliseconds). Defines the maximum time to wait for response, during outgoing link establish, release, resynch and recovery. Should be somewhat greater than a round-trip delay.')
configCommonSscopMaxSduSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxSduSize.setDescription('The maximum SSCOP SDU size (SAAL Service Data Unit size) in bytes.')
configCommonSscopMaxUuSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 19, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configCommonSscopMaxUuSize.setStatus('mandatory')
if mibBuilder.loadTexts: configCommonSscopMaxUuSize.setDescription('The maximum SSCOP UU size (User-to-User data size) in bytes. Note: This value is currently not needed according to Q.2130, and hence not used.')
configNextHopRoutingTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configNextHopRoutingTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingTableNextIndex.setDescription('The next unused row in configNextHopRoutingTable.')
configNextHopRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2), )
if mibBuilder.loadTexts: configNextHopRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingTable.setDescription('This table contains the IISP routing information.')
configNextHopRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configNextHopRoutingIndex"))
if mibBuilder.loadTexts: configNextHopRoutingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingEntry.setDescription('Each row in this table describes the route to one ATM address prefix.')
configNextHopRoutingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configNextHopRoutingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
configNextHopRoutingAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 2), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNextHopRoutingAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingAtmAddress.setDescription('The ATM address or ATM summary address to which this row describes a route.')
configNextHopRoutingAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNextHopRoutingAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingAddressLength.setDescription('The number of valid bits in configNextHopRoutingAtmAddress.')
configNextHopRoutingEPort = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNextHopRoutingEPort.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingEPort.setDescription('The ifIndex of the ATM port that leads to the specified ATM address.')
configNextHopRoutingSignallingType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("userSide", 1), ("networkSide", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNextHopRoutingSignallingType.setStatus('obsolete')
if mibBuilder.loadTexts: configNextHopRoutingSignallingType.setDescription('Not used.')
configNextHopRoutingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 20, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNextHopRoutingRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configNextHopRoutingRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
atmIpArpTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1), )
if mibBuilder.loadTexts: atmIpArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpTable.setDescription('This table contains the IP-address-to-ATM-address translation table used by the IP ARP server.')
atmIpArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "atmIpArpServerIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "atmIpArpIpAddress"))
if mibBuilder.loadTexts: atmIpArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpEntry.setDescription('Each row in this table describes one IP address.')
atmIpArpServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIpArpServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpServerIndex.setDescription('The index of the IP ARP server that handles this row.')
atmIpArpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIpArpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpIpAddress.setDescription('The IP address that this row translates.')
atmIpArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIpArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpAtmAddress.setDescription('The ATM address that corresponds to atmIpArpIpAddress.')
atmIpArpType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIpArpType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIpArpType.setDescription("The entry type. 'Dynamic' means created automatically, 'static' means created by management.")
configIpArpServerTableNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIpArpServerTableNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerTableNextIndex.setDescription('The next unused row in configIpArpServerTable.')
configIpArpServerTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3), )
if mibBuilder.loadTexts: configIpArpServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerTable.setDescription('This table is used to create and configure the IP ARP servers.')
configIpArpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "configIpArpServerIndex"))
if mibBuilder.loadTexts: configIpArpServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerEntry.setDescription('Each row in this table describes one IP ARP server, servicing one IP subnet.')
configIpArpServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIpArpServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerIndex.setDescription('An arbitrary integer used to differentiate multiple rows containing different IP ARP servers.')
configIpArpServerAtmAddressSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 2), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerAtmAddressSpec.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerAtmAddressSpec.setDescription('An ATM Address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the IP ARP Server will use to derive the actual ATM address from the network or ILMI. The derived ATM address is specified in the object configIpArpServerAtmAddressActual, which is used to receive ATM IP ARP requests.')
configIpArpServerAtmAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerAtmAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerAtmAddressMask.setDescription("The ATM address mask associated with the object configIpArpServerAtmAddressSpec. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
configIpArpServerAtmAddressActual = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 4), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIpArpServerAtmAddressActual.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerAtmAddressActual.setDescription('The resultant ATM address in use by the IP ARP Server. This object is a product of the specified ATM address, mask, and interaction with the network. This object is created by the agent.')
configIpArpServerIpSubnetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerIpSubnetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerIpSubnetAddress.setDescription('The address of the IP subnet serviced by this IP ARP server.')
configIpArpServerIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerIpSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerIpSubnetMask.setDescription('The subnet mask of the IP subnet serviced by this IP ARP server.')
configIpArpServerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerAdminStatus.setDescription('Enables or disable the IP ARP server.')
configIpArpServerOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIpArpServerOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerOperStatus.setDescription('Operational state of this IP ARP Server entry.')
configIpArpServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpArpServerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIpArpServerRowStatus.setDescription('Used to control creation and deletion of new rows in the table.')
configClipArpServer = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 21, 4), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configClipArpServer.setStatus('mandatory')
if mibBuilder.loadTexts: configClipArpServer.setDescription('The ATM address of the IP ARP server used by the CLIP client in the switch.')
qosClassTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1), )
if mibBuilder.loadTexts: qosClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassTable.setDescription('This table provides the translation between the Quality of Service (QoS) classes used in UNI 3.1 signalling and the corresponding values of the QoS parameters. Only classes 1 through 4 can be configured.')
qosClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "qosClassClass"))
if mibBuilder.loadTexts: qosClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassEntry.setDescription('Each row in this table describes one QoS class.')
qosClassClass = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosClassClass.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassClass.setDescription('The QoS class number.')
qosClassCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosClassCtd.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassCtd.setDescription('The Cell Transfer Delay (in microseconds) for this QoS class.')
qosClassCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosClassCdv.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassCdv.setDescription('The Cell Delay Variation (in microseconds) for this QoS class.')
qosClassLogClr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 22, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosClassLogClr.setStatus('mandatory')
if mibBuilder.loadTexts: qosClassLogClr.setDescription('Minus the base 10 logarithm of the Cell Loss Ratio for this QoS class.')
configSerialObmSlip = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 23, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("obm", 2), ("slip", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSerialObmSlip.setStatus('mandatory')
if mibBuilder.loadTexts: configSerialObmSlip.setDescription('Controls if the serial line is used for OBM or SLIP.')
ifMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1))
atmTESTMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2))
ifTestTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3), )
if mibBuilder.loadTexts: ifTestTable.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestTable.setDescription('This table contains one entry per interface. It is a copy of the ifTestTable in the ifMIB as defined in RFC 1573.')
ifTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ifTestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestEntry.setDescription('An entry containing objects for invoking tests on an interface.')
ifTestId = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTestId.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestId.setDescription("This object identifies the current invocation of the interface's test. The type of this object is identical to the textual convention TestAndIncr, defined in RFC 1903.")
ifTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInUse", 1), ("inUse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestStatus.setDescription("This object indicates whether or not some manager currently has the necessary 'ownership' required to invoke a test on this interface. A write to this object is only successful when it changes its value from 'notInUse(1)' to 'inUse(2)'. After completion of a test, the agent resets the value back to 'notInUse(1)'.")
ifTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTestType.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestType.setDescription('A control variable used to start and stop operator- initiated interface tests. Most OBJECT IDENTIFIER values assigned to tests are defined elsewhere, in association with specific types of interface. However, this document assigns a value for a full- duplex loopback test, and defines the special meanings of the subject identifier: noTest OBJECT IDENTIFIER ::= { 0 0 } When the value noTest is written to this object, no action is taken unless a test is in progress, in which case the test is aborted. Writing any other value to this object is only valid when no test is currently in progress, in which case the indicated test is initiated. When read, this object always returns the most recent value that ifTestType was set to. If it has not been set since the last initialization of the network management subsystem on the agent, a value of noTest is returned.')
ifTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("inProgress", 3), ("notSupported", 4), ("unAbleToRun", 5), ("aborted", 6), ("failed", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestResult.setDescription('This object contains the result of the most recently requested test, or the value none(1) if no tests have been requested since the last reset. Note that this facility provides no provision for saving the results of one test when starting another, as could be required if used by multiple managers concurrently.')
ifTestCode = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifTestCode.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestCode.setDescription('This object contains a code which contains more specific information on the test result, for example an error-code after a failed test. Error codes and other values this object may take are specific to the type of interface and/or test. The value may have the semantics of either the AutonomousType or InstancePointer textual conventions as defined in RFC 1443. The identifier: testCodeUnknown OBJECT IDENTIFIER ::= { 0 0 } is defined for use if no additional result code is available.')
ifTestOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 1, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTestOwner.setStatus('mandatory')
if mibBuilder.loadTexts: ifTestOwner.setDescription("The entity which currently has the 'ownership' required to invoke a test on this interface.")
atmLoopbackTestGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1))
atmLoopbackTestTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1, 4))
atmLoopbackVpE2e = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1, 4, 1))
atmLoopbackVcE2e = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1, 4, 2))
atmLoopbackVpSegment = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1, 4, 3))
atmLoopbackVcSegment = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 24, 2, 1, 4, 4))
controlDeleteCode = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 25, 1), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: controlDeleteCode.setStatus('optional')
if mibBuilder.loadTexts: controlDeleteCode.setDescription("Writing a value of 0x54455354 (i.e. 'TEST') to this object causes both installed code blocks to be erased")
controlDeleteConfig = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 2, 25, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: controlDeleteConfig.setStatus('optional')
if mibBuilder.loadTexts: controlDeleteConfig.setDescription("Writing a value of 0x54455354 (i.e. 'TEST') to this object causes the configuration flash to be erased")
statusBasicHw = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1))
statusProcessorModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 2))
statusFeatureModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 3))
statusXModule = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4))
statusEPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6))
statusVpcVcc = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7))
statusFatalLog = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8))
statusHwChassisCurrentXModules = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHwChassisCurrentXModules.setStatus('mandatory')
if mibBuilder.loadTexts: statusHwChassisCurrentXModules.setDescription('The number of installed expansion modules.')
statusHwChassisCurrentEPorts = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHwChassisCurrentEPorts.setStatus('mandatory')
if mibBuilder.loadTexts: statusHwChassisCurrentEPorts.setDescription('The number of installed ATM ports.')
statusHwChassisUpsOperState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("inUse", 2), ("failed", 3), ("notPresent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHwChassisUpsOperState.setStatus('mandatory')
if mibBuilder.loadTexts: statusHwChassisUpsOperState.setDescription('The operational state of the Uninterrupted Power Supply (UPS).')
statusHwChassisSwitchingSystemSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHwChassisSwitchingSystemSize.setStatus('mandatory')
if mibBuilder.loadTexts: statusHwChassisSwitchingSystemSize.setDescription('The number of Core Access Points in the switch.')
statusHwChassisCellBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHwChassisCellBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: statusHwChassisCellBufferSize.setDescription('The size (in K cells) of the switch core cell buffer.')
statusCurrentTemperatureConditionState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusCurrentTemperatureConditionState.setStatus('mandatory')
if mibBuilder.loadTexts: statusCurrentTemperatureConditionState.setDescription('The current state of the temperature within the switch. Possible values are: normal The temperature is below fhTrapDashboardControlThresholdLow. highDecreasing The temperature is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The temperature is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The temperature is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the temperatureWarning entry in fhTrapDashboardControlTable.')
statusCurrentTemperatureGauge = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusCurrentTemperatureGauge.setStatus('mandatory')
if mibBuilder.loadTexts: statusCurrentTemperatureGauge.setDescription('The current temperature in degrees Celsius.')
statusCurrentTemperatureLatch = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statusCurrentTemperatureLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statusCurrentTemperatureLatch.setDescription('Indicates if the temperature has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statusCurrentTemperatureLatchTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusCurrentTemperatureLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statusCurrentTemperatureLatchTime.setDescription('The value of sysUpTime when the system turned statusCurrentTemperatureLatch on.')
statusFanOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFanOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statusFanOperStatus.setDescription('Indicates if the fan is running.')
statusPsuStatusTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 11), )
if mibBuilder.loadTexts: statusPsuStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: statusPsuStatusTable.setDescription('This table contains status information about the two power supplies in the switch.')
statusPsuStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 11, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statusPsuIndex"))
if mibBuilder.loadTexts: statusPsuStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statusPsuStatusEntry.setDescription('Each row in this table describes one power supply.')
statusPsuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusPsuIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusPsuIndex.setDescription('The power supply number.')
statusPsuOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusPsuOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statusPsuOperStatus.setDescription('Indicates the operational state of the power supply.')
statusProcessorModuleStatusLed = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusProcessorModuleStatusLed.setStatus('mandatory')
if mibBuilder.loadTexts: statusProcessorModuleStatusLed.setDescription('Indicates the state of the status LED on the processor module.')
statusProcessorModuleFaultLed = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusProcessorModuleFaultLed.setStatus('mandatory')
if mibBuilder.loadTexts: statusProcessorModuleFaultLed.setDescription('Indicates the state of the fault LED on the processor module.')
statusFeatureModuleOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2), ("testing", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFeatureModuleOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statusFeatureModuleOperStatus.setDescription('Indicates the operational state of the feature module.')
statusFeatureModuleStatusLed = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFeatureModuleStatusLed.setStatus('mandatory')
if mibBuilder.loadTexts: statusFeatureModuleStatusLed.setDescription('Indicates the state of the LED on the feature module.')
statusXModuleTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1), )
if mibBuilder.loadTexts: statusXModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleTable.setDescription('This table contains status information about the expansion modules in the switch.')
statusXModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statusXModuleSlotIndex"))
if mibBuilder.loadTexts: statusXModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleEntry.setDescription('Each row in this table describes one expansion module.')
statusXModuleSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleSlotIndex.setDescription('The expansion module slot in the switch.')
statusXModuleOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("inService", 2), ("slave", 3), ("failed", 4), ("lost", 5), ("disabledChanged", 6), ("disabledReplaced", 7), ("disabledByManagement", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleOperStatus.setDescription('The operational state of the expansion module.')
statusXModuleNoOfSlotsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleNoOfSlotsUsed.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleNoOfSlotsUsed.setDescription('Indicates the number of slots occupied by this expansion module.')
statusXModuleIPort1SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort1SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort1SlotIndex.setDescription('The slot number for the first iPort connected to this expansion module. This slot number can be used to index, for example, configIPortTable. A value of 0 indicates that the iPort is non-existent.')
statusXModuleIPort1RIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort1RIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort1RIndex.setDescription('The index of the first iPort connected to this expansion module. This value can be used to index, for example, configIPortTable.')
statusXModuleIPort2SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort2SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort2SlotIndex.setDescription('The slot number for the second iPort connected to this expansion module. This slot number can be used to index, for example, configIPortTable. A value of 0 indicates that the iPort is non-existent.')
statusXModuleIPort2RIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort2RIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort2RIndex.setDescription('The index of the second iPort connected to this expansion module. This value can be used to index, for example, configIPortTable.')
statusXModuleIPort3SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort3SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort3SlotIndex.setDescription('The slot number for the third iPort connected to this expansion module. This slot number can be used to index, for example, configIPortTable. A value of 0 indicates that the iPort is non-existent.')
statusXModuleIPort3RIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort3RIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort3RIndex.setDescription('The index of the third iPort connected to this expansion module. This value can be used to index, for example, configIPortTable.')
statusXModuleIPort4SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort4SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort4SlotIndex.setDescription('The slot number for the fourth iPort connected to this expansion module. This slot number can be used to index, for example, configIPortTable. A value of 0 indicates that the iPort is non-existent.')
statusXModuleIPort4RIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusXModuleIPort4RIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusXModuleIPort4RIndex.setDescription('The index of the fourth iPort connected to this expansion module. This value can be used to index, for example, configIPortTable.')
statusEPortTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1), )
if mibBuilder.loadTexts: statusEPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortTable.setDescription('This table provides status information about the ATM ports on the switch.')
statusEPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statusEPortIfIndex"))
if mibBuilder.loadTexts: statusEPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortEntry.setDescription('Each row in this table describes one ATM port.')
statusEPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortIfIndex.setDescription('The ifIndex of the ATM port.')
statusEPortXModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortXModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortXModuleIndex.setDescription('The expansion module on which this ATM port is located.')
statusEPortRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortRIndex.setDescription('The position within the expansion module of this ATM port.')
statusEPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortOperStatus.setDescription('The operational state of the ATM port.')
statusEPortPhyState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("offlineDisabled", 1), ("offlineRestart", 2), ("onlineOk", 3), ("onlineTransPhyFault", 4), ("onlineSignalLoss", 5), ("onlineNoRxSync", 6), ("onlineAutoDisable", 7), ("onlineTesting", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortPhyState.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortPhyState.setDescription('The state of the ATM port PHY.')
statusEPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("utp25", 2), ("mmf155", 3), ("utp155", 4), ("mmf622", 5), ("smf155", 6), ("smf622", 7), ("ds3", 8), ("vpTunnel", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortType.setDescription('The ATM port type.')
statusEPortRxSyncLedState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortRxSyncLedState.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortRxSyncLedState.setDescription('The state of the RXSYNC LED at the ATM port.')
statusEPortSignalLossLedState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortSignalLossLedState.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortSignalLossLedState.setDescription('The state of the SIGLOSS LED at the ATM port.')
statusEPortPhyPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortPhyPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortPhyPortIndex.setDescription('Index into a physical layer table.')
statusEPortLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("error", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortLoopbackState.setDescription('The loopback state of the ATM port.')
statusEPortLoopbackErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortLoopbackErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortLoopbackErrorCode.setDescription('Loopback test error information.')
statusEPortIlmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("stopped", 1), ("linkFailing", 2), ("establishing", 3), ("configuring", 4), ("retrieving", 5), ("registering", 6), ("verifying", 7), ("cleanUp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortIlmiState.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortIlmiState.setDescription('State of the ILMI protocol on the ATM port.')
statusEPortAdjInfoTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoTransmissionType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoTransmissionType.setDescription('UNI 2.0 only: Transmission type of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMediaType.setDescription('UNI 3.1 only: The media type of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoIfName.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoIfName.setDescription('The ifName from MIB-II of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoSystemIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoSystemIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoSystemIdentifier.setDescription('The IEEE MAC address of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVpcs.setDescription('The maximum number of VPCs on the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVccs.setDescription('The maximum number of VCC on the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVpiBits.setDescription('The number of bits used in a VPI on the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxVciBits.setDescription('The number of bits used in a VCI on the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoUniType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoUniType.setDescription('The UNI type of the remote ATM port to which the ATM port is connected.')
statusEPortAdjInfoUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("version2point0", 1), ("version3point0", 2), ("version3point1", 3), ("version4point0", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoUniVersion.setDescription('The UNI version of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoDeviceType.setDescription('The device type of the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoIlmiVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoIlmiVersion.setDescription('The ILMI version used by the remote ATM port to which this ATM port is connected.')
statusEPortAdjInfoNniSigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoNniSigVersion.setDescription('The NNI signalling protocol used by the remote ATM port to which this ATM port is connected.')
statusEPortAutoconfigMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVpcs.setDescription('The maximum number of VPCs that the connection between this ATM port and its peer will use.')
statusEPortAutoconfigMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVccs.setDescription('The maximum number of VCCs that the connection between this ATM port and its peer will use.')
statusEPortAutoconfigMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVpiBits.setDescription('The number of bits used in a VPI on the connection between this ATM port and its peer.')
statusEPortAutoconfigMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxVciBits.setDescription('The number of bits used in a VCI on the connection between this ATM port and its peer.')
statusEPortAutoconfigUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("version3point0", 2), ("version3point1", 3), ("version4point0", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigUniVersion.setDescription('The UNI version used between this ATM port and its peer.')
statusEPortAutoconfigDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigDeviceType.setDescription('The device type of this ATM port used in its communication with its peer.')
statusEPortAutoconfigDerivedInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("publicUni", 2), ("privateUni", 3), ("privateNni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigDerivedInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigDerivedInterfaceType.setDescription('The UNI/NNI interface type of this ATM port used in its communication with its peer.')
statusEPortAutoconfigMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxSvpcVpi.setDescription('The highest VPI number used for signalled VPCs between this ATM port and its peer.')
statusEPortAutoconfigMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMaxSvccVpi.setDescription('The highest VPI number used for signalled VCCs between this ATM port and its peer.')
statusEPortAutoconfigMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAutoconfigMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAutoconfigMinSvccVci.setDescription('The lowest VCI number used for signalled VCCs between this ATM port and its peer.')
statusEPortAdjInfoMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxSvpcVpi.setDescription('The MaxSvpcVpi value of the remote port.')
statusEPortAdjInfoMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMaxSvccVpi.setDescription('The MaxSvccVpi value of the remote port.')
statusEPortAdjInfoMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 6, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusEPortAdjInfoMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: statusEPortAdjInfoMinSvccVci.setDescription('The MinSvccVci value of the remote port.')
vpcExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1), )
if mibBuilder.loadTexts: vpcExtensionTable.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionTable.setDescription('This table provides information about VPCs in addition to what is found in the ATM MIB.')
vpcExtensionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "vpcExtensionIndex"))
if mibBuilder.loadTexts: vpcExtensionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionEntry.setDescription('Each row in this table describes one VPC.')
vpcExtensionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpcExtensionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionIndex.setDescription('An arbitrary integer used to differentiate multiple rows in this table.')
vpcExtensionVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpcExtensionVpCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionVpCrossConnectIndex.setDescription('The index of this VPC in the atmVpCrossConnectTable in the ATM MIB.')
vpcExtensionOrigAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1, 3), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpcExtensionOrigAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionOrigAtmAddr.setDescription('The ATM address that originated this VPC.')
vpcExtensionTermAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1, 4), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpcExtensionTermAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionTermAtmAddr.setDescription('The ATM address at which this VPC terminates.')
vpcExtensionCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpcExtensionCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: vpcExtensionCapabilities.setDescription('Reserved for special capabilities.')
vccExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2), )
if mibBuilder.loadTexts: vccExtensionTable.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionTable.setDescription('This table provides information about VCCs in addition to what is found in the ATM MIB.')
vccExtensionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "vccExtensionIndex"))
if mibBuilder.loadTexts: vccExtensionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionEntry.setDescription('Each row in this table describes one VCC.')
vccExtensionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionIndex.setDescription('An arbitrary integer used to differentiate multiple rows in this table.')
vccExtensionVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionVcCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionVcCrossConnectIndex.setDescription('The index of this VCC in the atmVcCrossConnectTable in the ATM MIB.')
vccExtensionOrigAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 3), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionOrigAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionOrigAtmAddr.setDescription('The ATM address that originated this VCC.')
vccExtensionTermAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 4), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionTermAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionTermAtmAddr.setDescription('The ATM address at which this VPC terminates.')
vccExtensionCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionCapabilities.setDescription('Reserved for special capabilities.')
vccExtensionEarlyPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vccExtensionEarlyPacketDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: vccExtensionEarlyPacketDiscard.setDescription('Indicates if early packet discard is allowed on this VCC.')
statusFatalStatUsed = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalStatUsed.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalStatUsed.setDescription('The number of currently used entries in the FATAL log.')
statusFatalStatFree = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalStatFree.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalStatFree.setDescription('The number of free entries in the FATAL log.')
statusFatalStatOverflow = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalStatOverflow.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalStatOverflow.setDescription('Indicates if there has been an overflow in the FATAL log.')
statusFatalStatMaxDumpLength = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalStatMaxDumpLength.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalStatMaxDumpLength.setDescription('The maximum number of bytes that can be dumped.')
statusFatalTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5), )
if mibBuilder.loadTexts: statusFatalTable.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalTable.setDescription('This table contains the contents of the FATAL log.')
statusFatalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statusFatalIndex"))
if mibBuilder.loadTexts: statusFatalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalEntry.setDescription('Each row in this table describes one entry in the FATAL log.')
statusFatalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalIndex.setDescription('An arbitrary integer used to differentiate multiple rows in the table.')
statusFatalSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalSerial.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalSerial.setDescription('The serial number of this entry.')
statusFatalTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalTimestamp.setDescription('Time when the FATAL error occurred (measured in seconds since 00:00:00 UTC on 1 January 1970).')
statusFatalTimeString = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalTimeString.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalTimeString.setDescription('Time when the FATAL error occurred (as a string giving the UTC time and date).')
statusFatalSource = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalSource.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalSource.setDescription('Source file name of version of the software that generated the FATAL error.')
statusFatalLine = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalLine.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalLine.setDescription('The line number of the source code instruction that generated the FATAL error.')
statusFatalOriginalDumpSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalOriginalDumpSize.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalOriginalDumpSize.setDescription('The original size of the dumped objects.')
statusFatalDumpSize = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalDumpSize.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalDumpSize.setDescription('The actual size of the dumped objects.')
statusFatalDump = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 3, 8, 5, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFatalDump.setStatus('mandatory')
if mibBuilder.loadTexts: statusFatalDump.setDescription('The dumped objects.')
statisticsGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1))
statisticsCpuPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2))
statisticsEPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3))
statisticsIPort = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4))
statsGlobalCongestionState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsGlobalCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: statsGlobalCongestionState.setDescription('The current congestion state within the switch, based on the number of globally discarded cells. Possible values are: normal The cell discard rate is below fhTrapDashboardControlThresholdLow. highDecreasing The cell discard rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The cell discard rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The cell discard rate is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the globalCongestion entry in fhTrapDashboardControlTable.')
statsGlobalCongestionDiscardCellRate = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellRate.setDescription('The rate of globally discarded cells (measured in cells/second), averaged over 10 seconds.')
statsGlobalCongestionDiscardCellCounter = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellCounter.setStatus('mandatory')
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellCounter.setDescription('The number of globally discarded cells.')
statsGlobalCongestionDiscardCellLatch = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellLatch.setDescription('Indicates if the cell discard rate has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statsGlobalCongestionDiscardCellLatchTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsGlobalCongestionDiscardCellLatchTime.setDescription('The value of sysUpTime when the system turned statsGlobalCongestionDiscardCellLatch on.')
statsInvalidCellRateState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsInvalidCellRateState.setStatus('mandatory')
if mibBuilder.loadTexts: statsInvalidCellRateState.setDescription('The current invalid cell state within the switch, based on the number of invalid cells received. Possible values are: normal The invalid cell rate is below fhTrapDashboardControlThresholdLow. highDecreasing The invalid cell rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The invalid cell rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The invalid cell rate is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the globalInvalidCellRate entry in fhTrapDashboardControlTable.')
statsInvalidCellRate = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsInvalidCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsInvalidCellRate.setDescription('The rate of invalid cells (measured in cells/second), averaged over 10 seconds.')
statsInvalidCellCounter = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsInvalidCellCounter.setStatus('mandatory')
if mibBuilder.loadTexts: statsInvalidCellCounter.setDescription('The number of invalid cells received.')
statsInvalidCellLatch = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statsInvalidCellLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statsInvalidCellLatch.setDescription('Indicates if the invalid cell rate has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statsInvalidCellLatchTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsInvalidCellLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsInvalidCellLatchTime.setDescription('The value of sysUpTime when the system turned statsInvalidCellLatch on.')
statsCpuPortCongestionState = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsCpuPortCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: statsCpuPortCongestionState.setDescription('The current congestion state of the switch processor queue, based on the number of cells in the switch processor queue. Possible values are: normal The queue length is below fhTrapDashboardControlThresholdLow. highDecreasing The queue length is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The queue length is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The queue length is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the cpuPortCongestion entry in fhTrapDashboardControlTable.')
statsCpuPortDiscardCellRate = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsCpuPortDiscardCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsCpuPortDiscardCellRate.setDescription('The rate of discarded cells per second destined for the switch processor queue (measured in cells/second), averaged over 10 seconds.')
statsCpuPortDiscardCellCounter = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsCpuPortDiscardCellCounter.setStatus('mandatory')
if mibBuilder.loadTexts: statsCpuPortDiscardCellCounter.setDescription('The number of cells, destined for the switch processor queue, that have been discarded.')
statsCpuPortDiscardCellLatch = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statsCpuPortDiscardCellLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statsCpuPortDiscardCellLatch.setDescription('Indicates if the switch processor queue cell discard rate has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statsCpuPortDiscardCellLatchTime = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 2, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsCpuPortDiscardCellLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsCpuPortDiscardCellLatchTime.setDescription('The value of sysUpTime when the system turned statsCpuPortDiscardCellLatch on.')
statsEportTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1), )
if mibBuilder.loadTexts: statsEportTable.setStatus('mandatory')
if mibBuilder.loadTexts: statsEportTable.setDescription('This table contains ATM port HEC error statistics.')
statsEportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statsEPortIfIndex"))
if mibBuilder.loadTexts: statsEportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statsEportEntry.setDescription('Each row in this table describes one ATM port.')
statsEPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsEPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortIfIndex.setDescription('The ifIndex of the ATM port.')
statsEPortHecErrorRateConditionState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsEPortHecErrorRateConditionState.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortHecErrorRateConditionState.setDescription('The current HEC error state within the switch, based on the rate of cells with HEC errors. Possible values are: normal The HEC error cell rate is below fhTrapDashboardControlThresholdLow. highDecreasing The HEC error cell rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The HEC error cell rate is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The HEC cell rate is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the ePortHecErrorRate entry in fhTrapDashboardControlTable.')
statsEPortRxHecErrorCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsEPortRxHecErrorCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortRxHecErrorCellRate.setDescription('The rate of cells with HEC errors received on this ATM port (measured in cells/second), averaged over 10 seconds.')
statsEPortRxHecErrorCellCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsEPortRxHecErrorCellCounter.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortRxHecErrorCellCounter.setDescription('The number of cells with HEC errors received on this ATM port.')
statsEPortRxHecErrorCellLatch = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statsEPortRxHecErrorCellLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortRxHecErrorCellLatch.setDescription('Indicates if the HEC error cell rate has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statsEPortRxHecErrorCellLatchTime = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 3, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsEPortRxHecErrorCellLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsEPortRxHecErrorCellLatchTime.setDescription('The value of sysUpTime when the system turned statsEPortRxHecErrorCellLatch on.')
statsIPortTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1), )
if mibBuilder.loadTexts: statsIPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortTable.setDescription('This table contains statistics for the Core Access Points (iPorts) in the switch).')
statsIPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statsIPortSlotIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "statsIPortRIndex"))
if mibBuilder.loadTexts: statsIPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortEntry.setDescription('Each row in this table describes one iPort.')
statsIPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsIPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortSlotIndex.setDescription('The number of the expansion module to which the iPort is connected.')
statsIPortRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsIPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortRIndex.setDescription('The number of the iPort within the expansion module.')
statsIPortRxCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsIPortRxCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortRxCellRate.setDescription('The rate of cells received on this iPort (measured in cells/second), averaged over 5 samples, sampled every 2 seconds, computed as 0.8*previous+0.2*current.')
statsIPortTxCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsIPortTxCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortTxCellRate.setDescription('The rate of cells transmitted on this iPort (measured in cells/second), averaged over 5 samples, sampled every 2 seconds, computed as 0.8*previous+0.2*current.')
statsIPortTxParityErrorCellCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsIPortTxParityErrorCellCounter.setStatus('mandatory')
if mibBuilder.loadTexts: statsIPortTxParityErrorCellCounter.setDescription('The number of cells with memory parity error that were read from the switch core cell buffer.')
statsQueueCongestionTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2), )
if mibBuilder.loadTexts: statsQueueCongestionTable.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionTable.setDescription('This table contains congestion information for each queue attached to each Core Access Point (iPort).')
statsQueueCongestionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionSlotIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionIPortRIndex"), (0, "Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionQueueIndex"))
if mibBuilder.loadTexts: statsQueueCongestionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionEntry.setDescription('Each row in this table describes one queue on one iPort.')
statsQueueCongestionSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionSlotIndex.setDescription('The number of the expansion module to which the iPort is connected.')
statsQueueCongestionIPortRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionIPortRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionIPortRIndex.setDescription('The number of the iPort within the expansion module.')
statsQueueCongestionQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionQueueIndex.setDescription('The queue priority.')
statsQueueCongestionConditionState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("highDecreasing", 2), ("normalIncreasing", 3), ("high", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionConditionState.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionConditionState.setDescription('The current congestion state on the iPort queue, based on the length of the queue. Possible values are: normal The queue length is below fhTrapDashboardControlThresholdLow. highDecreasing The queue length is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is decreasing. normalIncreasing The queue length is between fhTrapDashboardControlThresholdLow and fhTrapDashboardControlThresholdHigh, and it is increasing. high The queue length is above fhTrapDashboardControlThresholdHigh. The references to fhTrapDashboardControlThresholdLow/High refer to the iPortCongestion entry in fhTrapDashboardControlTable.')
statsQueueCongestionCellsInQueueGauge = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueGauge.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueGauge.setDescription('The current length of the iPort queue.')
statsQueueCongestionCellsInQueueLatch = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueLatch.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueLatch.setDescription('Indicates if the iPort queue length has been above fhTrapDashboardControlThresholdHigh. This object is writable so that it can be reset by management.')
statsQueueCongestionCellsInQueueLatchTime = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 4, 4, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueLatchTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsQueueCongestionCellsInQueueLatchTime.setDescription('The value of sysUpTime when the system turned statsQueueCongestionCellsInQueueLatch on.')
fhTrapFrequencyCntrlFrequency = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapFrequencyCntrlFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapFrequencyCntrlFrequency.setDescription('Controls how frequently a threshold-exceeded trap may be generated. This object is the maximum number of times each trap may be sent per minute.')
fhTrapFrequencyCntrlMaxTraps = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapFrequencyCntrlMaxTraps.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapFrequencyCntrlMaxTraps.setDescription('The maximum number of times each threshold-exceeded trap may be generated during one threshold-exceeded incident if fhTrapDashboardControlFrequencyMode is upToMax.')
fhTrapDashboardControlTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3), )
if mibBuilder.loadTexts: fhTrapDashboardControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlTable.setDescription('This table contains the thresholds that trigger various traps.')
fhTrapDashboardControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "fhTrapDashboardControlTrapTypeIndex"))
if mibBuilder.loadTexts: fhTrapDashboardControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlEntry.setDescription('Each row in this table describes one trap type.')
fhTrapDashboardControlTrapTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("globalCongestion", 1), ("globalInvalidCellRate", 2), ("cpuPortCongestion", 3), ("iPortCongestion", 4), ("ePortHecErrorRate", 5), ("temperatureWarning", 6), ("psuMonitor", 7), ("fanMonitor", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fhTrapDashboardControlTrapTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlTrapTypeIndex.setDescription('The trap type.')
fhTrapDashboardControlFrequencyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneShot", 1), ("forever", 2), ("upToMax", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapDashboardControlFrequencyMode.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlFrequencyMode.setDescription('Controls the number of times this trap may be generated. The legal values are: oneShot Generate a trap once for each threshold-exceeded incident. forever Generate traps at the rate specified in fhTrapFrequencyCntrlFrequency. upToMax Generate traps at the rate specified in fhTrapFrequencyCntrlFrequency, but do not generate more than fhTrapFrequencyCntrlMaxTraps traps for each threshold-exceeded incident.')
fhTrapDashboardControlThresholdLow = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapDashboardControlThresholdLow.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlThresholdLow.setDescription('The low threshold hysteresis value. When the measured value drops below this number, trap generation stops. This value must be smaller than or equal to fhTrapDashboardControlThresholdHigh.')
fhTrapDashboardControlThresholdHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapDashboardControlThresholdHigh.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlThresholdHigh.setDescription('The high threshold hysteresis value. When the measured value rises above this number, trap generation starts. This value must be greater than or equal to fhTrapDashboardControlThresholdLow.')
fhTrapDashboardControlSamplingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapDashboardControlSamplingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlSamplingInterval.setDescription('Sampling interval (in seconds) for the value that is to be compared with the thresholds.')
fhTrapDashboardControlNoSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fhTrapDashboardControlNoSamples.setStatus('mandatory')
if mibBuilder.loadTexts: fhTrapDashboardControlNoSamples.setDescription('The number of samples in a running average. A value of 1 indicates no running average.')
temperatureCriticalTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: temperatureCriticalTrapThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: temperatureCriticalTrapThreshold.setDescription('If the temperature in the switch rises above this value (in degrees Celsius, the temperatureCriticalTrap trap is generated, and the switch is shut down.')
restart = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,1)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "termRestartInfoRestartTime"), ("Olicom-crossfireAtmSwitch-MIB", "termRestartInfoRestartReason"), ("Olicom-crossfireAtmSwitch-MIB", "termRestartInfoTerminationReason"), ("Olicom-crossfireAtmSwitch-MIB", "termRestartInfoBbsram"))
if mibBuilder.loadTexts: restart.setDescription('The switch has restarted.')
globalCongestionTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,3)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsGlobalCongestionState"), ("Olicom-crossfireAtmSwitch-MIB", "statsGlobalCongestionDiscardCellRate"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: globalCongestionTrap.setDescription('The rate of globally discarded cells/second rises or falls above/below defined threshold.')
globalInvalidCellRateTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,4)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsInvalidCellRateState"), ("Olicom-crossfireAtmSwitch-MIB", "statsInvalidCellRate"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: globalInvalidCellRateTrap.setDescription('The rate of invalid cells/second is above the defined threshold.')
cpuPortCongestionTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,5)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsCpuPortCongestionState"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: cpuPortCongestionTrap.setDescription('The number of cells in the switch processor queue is above the defined threshold.')
queueCongestionTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,6)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionSlotIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionIPortRIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionQueueIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsQueueCongestionConditionState"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: queueCongestionTrap.setDescription('The number of cells in an iPort queue is above the defined threshold.')
ePortHecErrorRateTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,7)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsEPortIfIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statusEPortXModuleIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statusEPortRIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsEPortHecErrorRateConditionState"), ("Olicom-crossfireAtmSwitch-MIB", "statsEPortRxHecErrorCellRate"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: ePortHecErrorRateTrap.setDescription('The rate of HEC error cells/second is above the defined threshold.')
iPortTxParityErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,8)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statsIPortSlotIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsIPortRIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statsIPortTxParityErrorCellCounter"))
if mibBuilder.loadTexts: iPortTxParityErrorTrap.setDescription('The rate of cell buffer memory parity errors is above the defined threshold.')
ePortAutoDisabled = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,9)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusEPortIfIndex"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: ePortAutoDisabled.setDescription('An ATM port has been automatically disabled due to a hardware failure.')
featureModuleStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,10)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusFeatureModuleOperStatus"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: featureModuleStatusChange.setDescription('Informs the management station that an expected feature module is not present, the system will operate without a feature module.')
xModuleStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,11)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusXModuleSlotIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statusXModuleOperStatus"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: xModuleStatusChange.setDescription('Informs the management station about a change in the state of an expansion module, e.g. when its state changes to failed, lost, disabledChanged, or disabledReplaced.')
temperatureWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,12)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusCurrentTemperatureConditionState"), ("Olicom-crossfireAtmSwitch-MIB", "statusCurrentTemperatureGauge"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: temperatureWarningTrap.setDescription('The temerature in the switch is above the defined threshold.')
fanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,13)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusFanOperStatus"), ("Olicom-crossfireAtmSwitch-MIB", "statusCurrentTemperatureGauge"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: fanFailureTrap.setDescription('The fan has stopped working.')
psuFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,14)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusPsuIndex"), ("Olicom-crossfireAtmSwitch-MIB", "statusPsuOperStatus"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: psuFailureTrap.setDescription('A power supply has stopped working.')
temperatureCriticalTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,15)).setObjects(("Olicom-crossfireAtmSwitch-MIB", "statusCurrentTemperatureConditionState"), ("Olicom-crossfireAtmSwitch-MIB", "statusCurrentTemperatureGauge"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: temperatureCriticalTrap.setDescription('The temperature has reached an unacceptable level. The switch will be shut down.')
oamFlowNoResponseTrap = NotificationType((1, 3, 6, 1, 4, 1, 285, 2, 6) + (0,16)).setObjects(("IF-MIB", "ifIndex"), ("Olicom-MIB", "controlTime"))
if mibBuilder.loadTexts: oamFlowNoResponseTrap.setDescription('An F4 or F5 OAM cell was not returned within 5 seconds.')
ocCNNI = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3))
ocDsx3 = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4))
ocCNNIMonSimple = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1), )
if mibBuilder.loadTexts: ocCNNIMonSimple.setStatus('optional')
ocCNNIMonSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIApplID"))
if mibBuilder.loadTexts: ocCNNIMonSEntry.setStatus('optional')
ocCNNIRoutingTableChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIRoutingTableChanged.setStatus('optional')
ocCNNINeighborTableChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNINeighborTableChanged.setStatus('optional')
ocCNNILineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNILineStatus.setStatus('optional')
ocCNNIMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIMACAddress.setStatus('optional')
ocCNNIMode = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIMode.setStatus('optional')
ocCNNIProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIProtocolVersion.setStatus('optional')
ocCNNIApplID = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIApplID.setStatus('optional')
ocCNNIMonTables = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2))
ocCNNIRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 1), )
if mibBuilder.loadTexts: ocCNNIRoutingTable.setStatus('optional')
ocCNNIRoutingTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIApplID"), (0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIAddress"))
if mibBuilder.loadTexts: ocCNNIRoutingTableEntry.setStatus('optional')
ocCNNIAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddress.setStatus('optional')
ocCNNIRoutingTableData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIRoutingTableData.setStatus('optional')
ocCNNIAddressAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddressAlias.setStatus('optional')
ocCNNINeighborTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 2), )
if mibBuilder.loadTexts: ocCNNINeighborTable.setStatus('optional')
ocCNNINeighborTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIApplID"), (0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIPort"))
if mibBuilder.loadTexts: ocCNNINeighborTableEntry.setStatus('optional')
ocCNNIPort = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIPort.setStatus('optional')
ocCNNINeighborTableData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNINeighborTableData.setStatus('optional')
ocCNNITrapClientTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 3), )
if mibBuilder.loadTexts: ocCNNITrapClientTable.setStatus('optional')
ocCNNITrapClientTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 3, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIApplID"), (0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNITrapClientAddress"))
if mibBuilder.loadTexts: ocCNNITrapClientTableEntry.setStatus('optional')
ocCNNITrapClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNITrapClientIndex.setStatus('optional')
ocCNNITrapClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNITrapClientAddress.setStatus('optional')
ocCNNITrapClientCommName = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 2, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNITrapClientCommName.setStatus('optional')
ocCNNIConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 3))
ocCNNIConfigMethod = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("first", 0), ("best", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIConfigMethod.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIConfigMethod.setDescription('An alorithm used by CNNI. First (0) means that the SETUP frame which arrives first is accepted, all consecutive are discarded. Best (1) means that we delay the decision of accepting a SETUP frame for some time and accept the one that carries the smallest cost.')
ocCNNIConfigAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIConfigAlgorithm.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIConfigAlgorithm.setDescription('An algorithm that is used to determine the cost of a SETUP frame if ocCNNIConfigMethod equals Best (1).')
ocCNNIPortConfig = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4), )
if mibBuilder.loadTexts: ocCNNIPortConfig.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortConfig.setDescription('A table of parameter information for CNNI ports.')
ocCNNIPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIPort"))
if mibBuilder.loadTexts: ocCNNIPortEntry.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortEntry.setDescription('An entry in the table, containing information about parameters for CNNI ports.')
ocCNNIPortProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cnni", 0), ("pnni", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIPortProtocol.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortProtocol.setDescription('Routing protocol used on an ATM port.')
ocCNNIPortBorder = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIPortBorder.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortBorder.setDescription('Definition of a role this port has in CNNI cloud. no (0) means that it is connected to another device running CNNI. yes (1) means it is connected to a non-CNNI device. no (0) requires that atmfAtmLayerUniVersion equals NNI(6).')
ocCNNIPortAutoreroute = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIPortAutoreroute.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortAutoreroute.setDescription('An indication if all calls coming from this port should be automatically rerouted by CNNI if a path they are traversing becomes invalid. Refers to UNI ports.')
ocCNNIPortReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIPortReroute.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortReroute.setDescription('An indication if a port should be considered an alternate path for automatic rerouting. Refers to ports that have ocCNNIPortProtocol set to cnni (0).')
ocCNNIPortAssign = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIPortAssign.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIPortAssign.setDescription('Defines if CNNI should assign VPI/VCI identifiers for this port. For CNNI link (ocCNNIPortProtocol set to cnni (0)) only one end should have it set to yes(1).')
ocCNNIGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5))
ocCNNIGlobalStatsTotal = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsTotal.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsTotal.setDescription('Total number of active switched connection established by CNNI.')
ocCNNIGlobalStatsCreated = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsCreated.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsCreated.setDescription('Number of connections set up by CNNI that are in CREATED phase.')
ocCNNIGlobalStatsOneWay = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsOneWay.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsOneWay.setDescription('Number of connections set up by CNNI that are in ONE WAY phase.')
ocCNNIGlobalStatsConnected = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsConnected.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsConnected.setDescription('Number of connections set up by CNNI that are in CONNECTED phase.')
ocCNNIGlobalStatsBrokenLeaf = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsBrokenLeaf.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsBrokenLeaf.setDescription('Number of connections set up by CNNI that are in BROKEN LEAF phase.')
ocCNNIGlobalStatsBrokenRoot = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsBrokenRoot.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsBrokenRoot.setDescription('Number of connections set up by CNNI that are in BROKEN ROOT phase.')
ocCNNIGlobalStatsRerouteWaiting = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIGlobalStatsRerouteWaiting.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIGlobalStatsRerouteWaiting.setDescription('Number of connections set up by CNNI that are in REROUTE WAITING phase.')
ocCNNIAddrStats = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6), )
if mibBuilder.loadTexts: ocCNNIAddrStats.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStats.setDescription('A table of CNNI statistics information for an ATM address.')
ocCNNIAddrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIAddress"))
if mibBuilder.loadTexts: ocCNNIAddrStatsEntry.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsEntry.setDescription('An entry in a table of CNNI statistics information for an ATM address.')
ocCNNIAddrStatsToTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToTotal.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToTotal.setDescription('Total number of active switched connection established by CNNI to this address.')
ocCNNIAddrStatsToCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToCreated.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToCreated.setDescription('Number of active switched connection set up by CNNI to this address that are in CREATED phase.')
ocCNNIAddrStatsToOneWay = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToOneWay.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToOneWay.setDescription('Number of active switched connection set up by CNNI to this address that are in ONE WAY phase.')
ocCNNIAddrStatsToConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToConnected.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToConnected.setDescription('Number of active switched connection set up by CNNI to this address that are in CONNECTED phase.')
ocCNNIAddrStatsToBrokenLeaf = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToBrokenLeaf.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToBrokenLeaf.setDescription('Number of active switched connection set up by CNNI to this address that are in BROKEN LEAF phase.')
ocCNNIAddrStatsToBrokenRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToBrokenRoot.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToBrokenRoot.setDescription('Number of active switched connection set up by CNNI to this address that are in BROKEN ROOT phase.')
ocCNNIAddrStatsToRerouteWaiting = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsToRerouteWaiting.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsToRerouteWaiting.setDescription('Number of active switched connection set up by CNNI to this address that are in REROUTE WAITING phase.')
ocCNNIAddrStatsFromTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromTotal.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromTotal.setDescription('Total number of active switched connection set up by CNNI from this address.')
ocCNNIAddrStatsFromCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromCreated.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromCreated.setDescription('Number of active switched connection set up by CNNI from this address that are in CREATED phase.')
ocCNNIAddrStatsFromOneWay = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromOneWay.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromOneWay.setDescription('Number of active switched connection set up by CNNI from this address that are in ONE WAY phase.')
ocCNNIAddrStatsFromConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromConnected.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromConnected.setDescription('Number of active switched connection set up by CNNI from this address that are in CONNECTED phase.')
ocCNNIAddrStatsFromBrokenLeaf = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromBrokenLeaf.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromBrokenLeaf.setDescription('Number of active switched connection set up by CNNI from this address that are in BROKEN LEAF phase.')
ocCNNIAddrStatsFromBrokenRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromBrokenRoot.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromBrokenRoot.setDescription('Number of active switched connection set up by CNNI from this address that are in BROKEN ROOT phase.')
ocCNNIAddrStatsFromRerouteWaiting = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIAddrStatsFromRerouteWaiting.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAddrStatsFromRerouteWaiting.setDescription('Number of active switched connection set up by CNNI from this address that are in REROUTE WAITING phase.')
ocCNNIAliasTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 7), )
if mibBuilder.loadTexts: ocCNNIAliasTable.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAliasTable.setDescription('A table of symbolic names assigned to ATM addresses.')
ocCNNIAliasTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 7, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIAddress"))
if mibBuilder.loadTexts: ocCNNIAliasTableEntry.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAliasTableEntry.setDescription('An entry in a table of symbolic names assigned to ATM addresses.')
ocCNNIAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 7, 1, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIAlias.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIAlias.setDescription('A symbolic name assigned to an ATM address. It can be 15 characters long max.')
ocCNNIConnDB = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8))
ocCNNIFilterAssignID = MibScalar((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIFilterAssignID.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterAssignID.setDescription('First empty slot in CNNI filter table. The NMS station should obtain it first, before setting filter parameters.')
ocCNNIFilterTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2), )
if mibBuilder.loadTexts: ocCNNIFilterTable.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterTable.setDescription('Table of filters defined for tracing signalling messages.')
ocCNNIFilterTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIFilterID"))
if mibBuilder.loadTexts: ocCNNIFilterTableEntry.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterTableEntry.setDescription('Entry in a table of filters for tracing signalling messages.')
ocCNNIFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNIFilterID.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterID.setDescription('Unique identificator of a filter.')
ocCNNIFilterTypePres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterTypePres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterTypePres.setDescription('Indicates if a connection type field is present in the filter definition.')
ocCNNIFilterTypeData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointtopoint", 0), ("pointtomulitpoint", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterTypeData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterTypeData.setDescription('Connection type field in the filter definition. This field has any meaning only if ocCNNIFilterTypePres is set to present (1).')
ocCNNIFilterInPortPres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterInPortPres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterInPortPres.setDescription('Indicates if a incoming port field is present in the filter definition.')
ocCNNIFilterInPortData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterInPortData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterInPortData.setDescription('Incoming port field in the filter definition. This field has any meaning only if ocCNNIFilterInPortPres is set to present (1).')
ocCNNIFilterOutPortPres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterOutPortPres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterOutPortPres.setDescription('Indicates if a outgoing port field is present in the filter definition.')
ocCNNIFilterOutPortData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterOutPortData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterOutPortData.setDescription('Outgoing port field in the filter definition. This field has any meaning only if ocCNNIFilterOutPortPres is set to present (1).')
ocCNNIFilterCgPtyPres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterCgPtyPres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterCgPtyPres.setDescription('Indicates if a calling party field is present in the filter definition.')
ocCNNIFilterCgPtyData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterCgPtyData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterCgPtyData.setDescription('Calling party field in the filter definition. This field has any meaning only if ocCNNIFilterCgPtyPres is set to present (1).')
ocCNNIFilterCdPtyPres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterCdPtyPres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterCdPtyPres.setDescription('Indicates if a called party field is present in the filter definition.')
ocCNNIFilterCdPtyData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterCdPtyData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterCdPtyData.setDescription('Called party field in the filter definition. This field has any meaning only if ocCNNIFilterCdPtyPres is set to present (1).')
ocCNNIFilterStatePres = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notpresent", 0), ("present", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterStatePres.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterStatePres.setDescription('Indicates if a connection phase field is present in the filter definition.')
ocCNNIFilterStateData = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("created", 0), ("oneway", 1), ("connected", 2), ("brokenroot", 3), ("brokenleaf", 4), ("reroutewaiting", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocCNNIFilterStateData.setStatus('optional')
if mibBuilder.loadTexts: ocCNNIFilterStateData.setDescription('Connection state field in the filter definition. This field has any meaning only if ocCNNIFilterStatePres is set to present (1).')
ocCNNISessTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3), )
if mibBuilder.loadTexts: ocCNNISessTable.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessTable.setDescription('Table containing info about session data. In order to read from this table one must first define a filter using ocCNNIFilterTable.')
ocCNNISessTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNIFilterID"), (0, "Olicom-crossfireAtmSwitch-MIB", "ocCNNISessID"))
if mibBuilder.loadTexts: ocCNNISessTableEntry.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessTableEntry.setDescription('An entry in a table containing info about session data.')
ocCNNISessID = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessID.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessID.setDescription('A unique session identifier.')
ocCNNISessDataType = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointtopoint", 0), ("pointtomulitpoint", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataType.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataType.setDescription('Connection type: pointtopoint (0) or pointtomultipoint (1).')
ocCNNISessDataInPort = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataInPort.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataInPort.setDescription('Incoming port (a port from which we received a SETUP frame that was accepted).')
ocCNNISessDataOutPort = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataOutPort.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataOutPort.setDescription('Outgoing port (a port to which we sent a SETUP frame that was accepted).')
ocCNNISessDataCgPty = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataCgPty.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataCgPty.setDescription('ATM address of a calling party.')
ocCNNISessDataCdPty = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataCdPty.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataCdPty.setDescription('ATM address of a called party.')
ocCNNISessDataState = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 3, 8, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("created", 0), ("oneway", 1), ("connected", 2), ("brokenroot", 3), ("brokenleaf", 4), ("reroutewaiting", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocCNNISessDataState.setStatus('optional')
if mibBuilder.loadTexts: ocCNNISessDataState.setDescription('State of the connection.')
ocDsx3MIBObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1))
ocDsx3ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1), )
if mibBuilder.loadTexts: ocDsx3ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3ConfigTable.setDescription('The Olicom extensions to the DS3/E3 Configuration table.')
ocDsx3ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "dsx3LineIndex"))
if mibBuilder.loadTexts: ocDsx3ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3ConfigEntry.setDescription('An entry in the DS3/E3 Configuration table.')
ocDsx3Xor55 = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3Xor55.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3Xor55.setDescription('This tests the FIFO data path between the the ATM layer, Atomizer and PHY/TC layer. Normally this option is disabled. ')
ocDsx3Scrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3Scrambling.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3Scrambling.setDescription('Scrambles the cell payload using a self synchronizing scrambler with an XX^43+1. Required by ITU-T in I.432 Not used on ATMF UNI DS3 interface, but may be required in future.')
ocDsx3Delineation = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hec", 1), ("plcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3Delineation.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3Delineation.setDescription('Provides ATM cell delineation based on the cell HEC byte or by the PLCP direct based mapping of ATM cells into the DS3 payload envelopes. Normally PLCP delineation is used.')
ocDsx3HcsPassThru = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3HcsPassThru.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3HcsPassThru.setDescription('Allows cells with detected HCS errors to pass to the receive FIFO. This is ussually disabled. ')
ocDsx3Ext8kRefClk = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled-master", 1), ("disabled", 2), ("slave", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3Ext8kRefClk.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3Ext8kRefClk.setDescription("The option selects an internal frame reference clock. When the interface is used to source line timing, this reference clock should be active. On an XLX one of the four ports of an adapter may be used as the master supplier or source of the clock, and the other 3 can reference the master's clock as slaves.")
ocDsx3ShortCable = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3ShortCable.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3ShortCable.setDescription('If the coaxial cables attached to the DS3 interface are 225 feet or less, select the short. If length is greater than 225 feet do not select short. This selection changes the DS3 Line build-out characteristics. Do not use cables longer than 450 feet. Cable type should be good quality RG-59/U. This is 75 ohm coax. Do not us 50 ohm coax, such as that used for Ethernet applications.')
ocDsx3CntHcsCorrectedErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ocDsx3CntHcsCorrectedErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3CntHcsCorrectedErrs.setDescription('If this parameter is enabled(1) the CPPM HCS counter will count the number of correctable header checksum errors. If disabled(1) the CPPM HCS counter will count the number of uncorrectable HCS errors.')
ocDsx3SuniPdhTable = MibTable((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2), )
if mibBuilder.loadTexts: ocDsx3SuniPdhTable.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPdhTable.setDescription('The Olicom extensions to the DS3/E3 Configuration table.')
ocDsx3SuniPdhEntry = MibTableRow((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1), ).setIndexNames((0, "Olicom-crossfireAtmSwitch-MIB", "dsx3LineIndex"))
if mibBuilder.loadTexts: ocDsx3SuniPdhEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPdhEntry.setDescription('An entry in the DS3/E3 Configuration table.')
ocDsx3SuniPmonLcv = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonLcv.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonLcv.setDescription('Represents the number of Line Code Violations since last polled.')
ocDsx3SuniPmonFerr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonFerr.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonFerr.setDescription('Represents the number of DS3 F and M bit errors since last polled.')
ocDsx3SuniPmonExzs = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonExzs.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonExzs.setDescription('Represents the number of summed excessivce zeros that occured during the previous accumulation period. One or more excessive zeros occurrence withan an 85 bit DS3 information block is counterd as one summed excessive zero.')
ocDsx3SuniPmonPeec = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonPeec.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonPeec.setDescription('Represents the number of DS3 P bits errors that have been detected since last polled.')
ocDsx3SuniPmonPpec = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonPpec.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonPpec.setDescription('Represents the number of DS3 path parity errprs that have been detected since last polled.')
ocDsx3SuniPmonFebeErr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniPmonFebeErr.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniPmonFebeErr.setDescription('Represents the number of DS3 far end block errors that have been detected since last polled.')
ocDsx3SuniB1Bip8Err = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniB1Bip8Err.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniB1Bip8Err.setDescription('Represents the number of B1 Bit-Interleaved Parity (BIP8) errors since last polled.')
ocDsx3SuniCppmFrameErr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmFrameErr.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmFrameErr.setDescription('Represents the number of PLCP frame errors that have occurred since last polled.')
ocDsx3SuniCppmFebeErr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmFebeErr.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmFebeErr.setDescription('Represent the number of PLCP Far End Block Errors since last polled.')
ocDsx3SuniCppmHcsErr = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmHcsErr.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmHcsErr.setDescription('If the ocDsx3CntHcsCorrectedErrs is enabled this counter represents the number of correctable Header Checksum errors that have occurred since last polled. If the ocDsx3CntHcsCorrectedErrs is disabled this counter represents the number of uncorrectable Header Checksum errors that have occurred since last polled. ')
ocDsx3SuniCppmRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmRcvCells.setDescription('Represents the number of cells received by the PHY device since power on.')
ocDsx3SuniCppmXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmXmtCells.setDescription('Represents the number of cells transmitted by the PHY device since power on.')
ocDsx3SuniCppmIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmIdleCells.setDescription('Represents the number of received idle cells by the PHY device since power on.')
ocDsx3SuniCppmMegaRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaRcvCells.setDescription('Represents the millions of cells received by the PHY device since power on.')
ocDsx3SuniCppmMegaXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaXmtCells.setDescription('Represents the millions of cells transmitted by the PHY device since power on.')
ocDsx3SuniCppmMegaIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 285, 2, 6, 7, 4, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: ocDsx3SuniCppmMegaIdleCells.setDescription('Represents the millions of received idle cells by the PHY device since power on.')
mibBuilder.exportSymbols("Olicom-crossfireAtmSwitch-MIB", pvpSetupTable=pvpSetupTable, pvcSetupIndex=pvcSetupIndex, configIPortScratchPadQueueClpDiscardThreshold=configIPortScratchPadQueueClpDiscardThreshold, statusEPort=statusEPort, statsQueueCongestionEntry=statsQueueCongestionEntry, configCommonEPortPnniVci=configCommonEPortPnniVci, ocDsx3HcsPassThru=ocDsx3HcsPassThru, statsInvalidCellRateState=statsInvalidCellRateState, svpSetupTable=svpSetupTable, statusProcessorModuleStatusLed=statusProcessorModuleStatusLed, pvcSetupApplication=pvcSetupApplication, ocDsx3SuniCppmHcsErr=ocDsx3SuniCppmHcsErr, configIPortScratchPadQueueLogClr=configIPortScratchPadQueueLogClr, configCommonEPortLecsVpi=configCommonEPortLecsVpi, configEPortIfIndex=configEPortIfIndex, statusXModuleTable=statusXModuleTable, atmLoopbackTestTypes=atmLoopbackTestTypes, crossfireAtmTrapControl=crossfireAtmTrapControl, configSarMuxFillThreshold=configSarMuxFillThreshold, statsQueueCongestionCellsInQueueLatchTime=statsQueueCongestionCellsInQueueLatchTime, ocCNNIFilterCgPtyData=ocCNNIFilterCgPtyData, statusEPortPhyPortIndex=statusEPortPhyPortIndex, ePortAutoDisabled=ePortAutoDisabled, configMonitorEPortDirection=configMonitorEPortDirection, ocCNNITrapClientIndex=ocCNNITrapClientIndex, configClocking=configClocking, ocCNNINeighborTableEntry=ocCNNINeighborTableEntry, ocDsx3Delineation=ocDsx3Delineation, configEPortIlmiConfigIlmiVersion=configEPortIlmiConfigIlmiVersion, ocCNNIFilterOutPortPres=ocCNNIFilterOutPortPres, ocCNNIAddrStatsFromBrokenLeaf=ocCNNIAddrStatsFromBrokenLeaf, atmIpArpEntry=atmIpArpEntry, configTmServiceClassMapEntry=configTmServiceClassMapEntry, svcSetupApplication=svcSetupApplication, statusXModuleIPort4RIndex=statusXModuleIPort4RIndex, configEPortTransientPhyWindowTime=configEPortTransientPhyWindowTime, termRestartInfoServerMacAddress=termRestartInfoServerMacAddress, configIlmiServiceRegistryAtmAddress=configIlmiServiceRegistryAtmAddress, statsEPortRxHecErrorCellLatchTime=statsEPortRxHecErrorCellLatchTime, configEPortScratchPadIlmiConfigMaxSvccVpi=configEPortScratchPadIlmiConfigMaxSvccVpi, termRestartInfoBbsram=termRestartInfoBbsram, crossfireAtmTest=crossfireAtmTest, configSerial=configSerial, statusFatalTimeString=statusFatalTimeString, fhTrapFrequencyCntrlMaxTraps=fhTrapFrequencyCntrlMaxTraps, configEPort=configEPort, statsQueueCongestionSlotIndex=statsQueueCongestionSlotIndex, qosClassEntry=qosClassEntry, configCommonEPortIlmiVersion=configCommonEPortIlmiVersion, configCpuQ=configCpuQ, statsCpuPortDiscardCellLatchTime=statsCpuPortDiscardCellLatchTime, configCommonEPortUniVersion=configCommonEPortUniVersion, fhTrapDashboardControlEntry=fhTrapDashboardControlEntry, configXModuleTable=configXModuleTable, fhTrapDashboardControlFrequencyMode=fhTrapDashboardControlFrequencyMode, ocCNNIConnDB=ocCNNIConnDB, infoIfIndexClassicalIp=infoIfIndexClassicalIp, configCommonEPortDeviceType=configCommonEPortDeviceType, ocCNNIPortBorder=ocCNNIPortBorder, configEPortScratchPadActionStatus=configEPortScratchPadActionStatus, statusHwChassisUpsOperState=statusHwChassisUpsOperState, trafficDescriptorCtd=trafficDescriptorCtd, configIpArpServerIpSubnetAddress=configIpArpServerIpSubnetAddress, pvcSetupLowVpi=pvcSetupLowVpi, configLaneControlLesBusAdminStatus=configLaneControlLesBusAdminStatus, configEPortScratchPadIlmiConfigPnniVci=configEPortScratchPadIlmiConfigPnniVci, atmLoopbackVpSegment=atmLoopbackVpSegment, ocCNNIAddrStatsFromRerouteWaiting=ocCNNIAddrStatsFromRerouteWaiting, svpSetupApplication=svpSetupApplication, ocCNNIFilterStateData=ocCNNIFilterStateData, statusHwChassisCellBufferSize=statusHwChassisCellBufferSize, statusFanOperStatus=statusFanOperStatus, svpSetupTermAtmAddr=svpSetupTermAtmAddr, trafficDescriptorScr0=trafficDescriptorScr0, pvpSetupLowVpi=pvpSetupLowVpi, vccExtensionVcCrossConnectIndex=vccExtensionVcCrossConnectIndex, statsQueueCongestionCellsInQueueLatch=statsQueueCongestionCellsInQueueLatch, ocCNNI=ocCNNI, pvpSetupL2HTrafficDescriptorIndex=pvpSetupL2HTrafficDescriptorIndex, infoIfIndex=infoIfIndex, configIlmiServiceRegistryAddressIndex=configIlmiServiceRegistryAddressIndex, configCommonSignallingMaxSvcs=configCommonSignallingMaxSvcs, configEPortScratchPadIlmiConfigIlmiVersion=configEPortScratchPadIlmiConfigIlmiVersion, configNextHopRoutingIndex=configNextHopRoutingIndex, statusEPortAutoconfigDeviceType=statusEPortAutoconfigDeviceType, ocCNNIAddrStatsToTotal=ocCNNIAddrStatsToTotal, ocCNNIAddrStatsToRerouteWaiting=ocCNNIAddrStatsToRerouteWaiting, statusEPortAdjInfoMaxSvccVpi=statusEPortAdjInfoMaxSvccVpi, infoXModuleHwOptionTable=infoXModuleHwOptionTable, xModuleStatusChange=xModuleStatusChange, configClipArpServer=configClipArpServer, configNetworkClockEPortIndex=configNetworkClockEPortIndex, configSarEmptyCellHandling=configSarEmptyCellHandling, configEPortScratchPadVbrRtBandwidthAllocation=configEPortScratchPadVbrRtBandwidthAllocation, configCommonEPortTransientPhyDisconnectCount=configCommonEPortTransientPhyDisconnectCount, ocCNNISessDataState=ocCNNISessDataState, atmIpArpServerIndex=atmIpArpServerIndex, ifTestResult=ifTestResult, infoIfIndexLan=infoIfIndexLan, pvpSetupHighVpi=pvpSetupHighVpi, configEPortIlmiConfigAddrRegistrationAdminStatus=configEPortIlmiConfigAddrRegistrationAdminStatus, configCommonSignallingT333=configCommonSignallingT333, fhTrapDashboardControlThresholdLow=fhTrapDashboardControlThresholdLow, configCommonSscopTimerIdle=configCommonSscopTimerIdle, ocCNNIAddrStats=ocCNNIAddrStats, statisticsEPort=statisticsEPort, ocDsx3SuniPmonExzs=ocDsx3SuniPmonExzs, configEPortIlmiConfigMaxSvccVpi=configEPortIlmiConfigMaxSvccVpi, queueCongestionTrap=queueCongestionTrap, fhTrapDashboardControlSamplingInterval=fhTrapDashboardControlSamplingInterval, statusXModuleIPort4SlotIndex=statusXModuleIPort4SlotIndex, configEPortCbrBandwidthAllocation=configEPortCbrBandwidthAllocation, ocDsx3SuniCppmRcvCells=ocDsx3SuniCppmRcvCells, configIPortQueueLogClr=configIPortQueueLogClr, statusEPortAutoconfigUniVersion=statusEPortAutoconfigUniVersion, configIPortQueueEntry=configIPortQueueEntry, configNextHopRoutingTable=configNextHopRoutingTable, configEPortScratchPadTransientPhyDisconnectCount=configEPortScratchPadTransientPhyDisconnectCount, statusEPortLoopbackErrorCode=statusEPortLoopbackErrorCode, statsQueueCongestionConditionState=statsQueueCongestionConditionState, ocCNNIPortReroute=ocCNNIPortReroute, configCommonSscopMaxStat=configCommonSscopMaxStat, configCommonEPortIlmiVci=configCommonEPortIlmiVci, ocCNNITrapClientTableEntry=ocCNNITrapClientTableEntry, configIPortScratchPadQueueQueueIndex=configIPortScratchPadQueueQueueIndex, ocDsx3SuniPmonPeec=ocDsx3SuniPmonPeec, statsGlobalCongestionDiscardCellLatch=statsGlobalCongestionDiscardCellLatch, trafficDescriptorBestEffortFlag=trafficDescriptorBestEffortFlag, svpSetupEntry=svpSetupEntry, qosClassLogClr=qosClassLogClr, statsInvalidCellLatchTime=statsInvalidCellLatchTime, configEPortScratchPadIlmiConfigMaxVccs=configEPortScratchPadIlmiConfigMaxVccs, statsQueueCongestionIPortRIndex=statsQueueCongestionIPortRIndex, statusXModule=statusXModule, ocDsx3SuniPmonFebeErr=ocDsx3SuniPmonFebeErr, ocDsx3ConfigEntry=ocDsx3ConfigEntry, statusFatalEntry=statusFatalEntry, configEPortIlmiConfigLecsVci=configEPortIlmiConfigLecsVci, statusEPortAutoconfigMaxVciBits=statusEPortAutoconfigMaxVciBits, ocCNNIFilterTypePres=ocCNNIFilterTypePres, ocmibs=ocmibs, configTrafficDescr=configTrafficDescr, configTmControlErTuningLambda=configTmControlErTuningLambda, configCommonEPortIlmiVpi=configCommonEPortIlmiVpi, trafficDescriptorAbrAdtf=trafficDescriptorAbrAdtf, configCommonEPortNniSigVersion=configCommonEPortNniSigVersion, statsCpuPortDiscardCellRate=statsCpuPortDiscardCellRate, atmIpArpIpAddress=atmIpArpIpAddress, ocCNNIRoutingTable=ocCNNIRoutingTable, termRestartInfoFutureTestMode=termRestartInfoFutureTestMode, configEPortIlmiConfigMaxVciBits=configEPortIlmiConfigMaxVciBits, vccExtensionIndex=vccExtensionIndex, configIpArpServerOperStatus=configIpArpServerOperStatus, configCommonEPort=configCommonEPort, termRestartInfoHwReconfigState=termRestartInfoHwReconfigState, trafficDescriptorPcr01=trafficDescriptorPcr01, configIPortScratchPadQueueEfciTaggingThreshold=configIPortScratchPadQueueEfciTaggingThreshold, svcSetupTable=svcSetupTable, ocCNNIAddrStatsToConnected=ocCNNIAddrStatsToConnected, ocCNNIFilterOutPortData=ocCNNIFilterOutPortData, ocCNNIProtocolVersion=ocCNNIProtocolVersion, fhTrapDashboardControlThresholdHigh=fhTrapDashboardControlThresholdHigh, infoProcessorModule=infoProcessorModule, configIPortQueueRIndex=configIPortQueueRIndex, AtmAddress=AtmAddress, configCommonIPortClpDiscardThreshold=configCommonIPortClpDiscardThreshold, statusHwChassisCurrentXModules=statusHwChassisCurrentXModules, configIPortScratchPadQueueSize=configIPortScratchPadQueueSize, ocCNNIMACAddress=ocCNNIMACAddress, temperatureCriticalTrap=temperatureCriticalTrap, svpSetupTxTrafficDescriptorIndex=svpSetupTxTrafficDescriptorIndex, infoXModuleSlotIndex=infoXModuleSlotIndex, configCommonEPortSignallingVpi=configCommonEPortSignallingVpi, configCommonEPortDefaultSigVersion=configCommonEPortDefaultSigVersion, statusEPortAdjInfoMaxVciBits=statusEPortAdjInfoMaxVciBits, configTmControlErTuningGamma=configTmControlErTuningGamma, statusFatalDumpSize=statusFatalDumpSize, statusFatalSerial=statusFatalSerial, configCommonSignallingT301=configCommonSignallingT301, statusFatalStatUsed=statusFatalStatUsed, statusXModuleEntry=statusXModuleEntry, configXModuleEntry=configXModuleEntry, vpcExtensionEntry=vpcExtensionEntry, configLaneControlLecsAdminStatus=configLaneControlLecsAdminStatus, pvcSetupEntry=pvcSetupEntry, configNextHopRoutingTableNextIndex=configNextHopRoutingTableNextIndex, statusXModuleIPort3SlotIndex=statusXModuleIPort3SlotIndex, configIPortScratchPadQueueTable=configIPortScratchPadQueueTable, configIPortSlotIndex=configIPortSlotIndex, statusEPortAutoconfigMaxSvpcVpi=statusEPortAutoconfigMaxSvpcVpi, statusFatalTimestamp=statusFatalTimestamp, ocCNNIGlobalStatsConnected=ocCNNIGlobalStatsConnected, configTest=configTest, ocCNNIFilterCgPtyPres=ocCNNIFilterCgPtyPres, infoProcessorModuleHwOptionTable=infoProcessorModuleHwOptionTable, configIPortQueueSize=configIPortQueueSize, statusEPortAdjInfoTransmissionType=statusEPortAdjInfoTransmissionType, trafficDescriptorLogClr=trafficDescriptorLogClr, statusProcessorModuleFaultLed=statusProcessorModuleFaultLed, trafficDescriptorAbrRif=trafficDescriptorAbrRif, configCommonEPortPnniVpi=configCommonEPortPnniVpi, fhTrapDashboardControlTable=fhTrapDashboardControlTable, vccExtensionTermAtmAddr=vccExtensionTermAtmAddr, crossfireAtmInfo=crossfireAtmInfo, atmIpArpTable=atmIpArpTable, ocCNNIAddrStatsFromBrokenRoot=ocCNNIAddrStatsFromBrokenRoot, configCommonIPortClpDiscardAdminStatus=configCommonIPortClpDiscardAdminStatus, statusEPortAdjInfoMediaType=statusEPortAdjInfoMediaType, ocDsx3SuniCppmFebeErr=ocDsx3SuniCppmFebeErr, configEPortEntry=configEPortEntry, configEPortIlmiConfigLecsVpi=configEPortIlmiConfigLecsVpi, qosClassCdv=qosClassCdv, configCommonIPortQueueIndex=configCommonIPortQueueIndex, svcSetupEntry=svcSetupEntry, ocCNNIGlobalStatsRerouteWaiting=ocCNNIGlobalStatsRerouteWaiting, svpSetupIndex=svpSetupIndex, configMonitorEPortAdminStatus=configMonitorEPortAdminStatus, restart=restart, svcSetupIndex=svcSetupIndex, termRestartInfoBbsramTerminationTimestamp=termRestartInfoBbsramTerminationTimestamp, statusPsuOperStatus=statusPsuOperStatus, statusHwChassisSwitchingSystemSize=statusHwChassisSwitchingSystemSize, configCommonSignallingT302=configCommonSignallingT302, statusPsuStatusTable=statusPsuStatusTable, configEPortScratchPadIlmiConfigMinSvccVci=configEPortScratchPadIlmiConfigMinSvccVci, trafficDescriptorMbs0=trafficDescriptorMbs0, statusFatalTable=statusFatalTable, statsEPortIfIndex=statsEPortIfIndex, statusEPortOperStatus=statusEPortOperStatus, configCommonIPort=configCommonIPort, fhTrapFrequencyCntrlFrequency=fhTrapFrequencyCntrlFrequency, ifTestEntry=ifTestEntry, trafficDescriptorAbrFrtt=trafficDescriptorAbrFrtt, ocCNNIPort=ocCNNIPort, ifTestStatus=ifTestStatus, statusEPortEntry=statusEPortEntry, configEPortScratchPadIlmiConfigPnniVpi=configEPortScratchPadIlmiConfigPnniVpi, infoIfIndexRfc1483Routed=infoIfIndexRfc1483Routed, trafficDescriptorTrafficType=trafficDescriptorTrafficType, configEPortScratchPadIlmiConfigSignallingVpi=configEPortScratchPadIlmiConfigSignallingVpi, statusXModuleIPort1RIndex=statusXModuleIPort1RIndex, configCommonEPortVbrNrtBandwidthAllocation=configCommonEPortVbrNrtBandwidthAllocation, configCommonSignallingT322=configCommonSignallingT322, statsInvalidCellCounter=statsInvalidCellCounter, ocCNNIMonSimple=ocCNNIMonSimple, termRestartInfoBootpReason=termRestartInfoBootpReason, configEPortAbrBandwidthAllocation=configEPortAbrBandwidthAllocation, configCommonEPortMaxVciBits=configCommonEPortMaxVciBits, statusEPortAutoconfigMaxVpcs=statusEPortAutoconfigMaxVpcs, svpSetupEPortIndex=svpSetupEPortIndex, svcSetupTermAtmAddr=svcSetupTermAtmAddr, configPriorityBufferIndex=configPriorityBufferIndex, termRestartInfoSwSection2StatusWord=termRestartInfoSwSection2StatusWord, ocDsx3Xor55=ocDsx3Xor55)
mibBuilder.exportSymbols("Olicom-crossfireAtmSwitch-MIB", cpuPortCongestionTrap=cpuPortCongestionTrap, configCommonSignallingT310=configCommonSignallingT310, statusEPortAutoconfigDerivedInterfaceType=statusEPortAutoconfigDerivedInterfaceType, configEPortDefaultSigVersion=configEPortDefaultSigVersion, configNextHopRoutingEPort=configNextHopRoutingEPort, configTmControlEarlyPacketDiscardAdminStatus=configTmControlEarlyPacketDiscardAdminStatus, statsCpuPortCongestionState=statsCpuPortCongestionState, ocCNNIMonSEntry=ocCNNIMonSEntry, infoFeatureModuleHwSerialNumber=infoFeatureModuleHwSerialNumber, statusFeatureModule=statusFeatureModule, infoIfIndexElan=infoIfIndexElan, statsQueueCongestionQueueIndex=statsQueueCongestionQueueIndex, configEPortLoopback=configEPortLoopback, termRestartInfo=termRestartInfo, ocCNNINeighborTable=ocCNNINeighborTable, ocCNNIAlias=ocCNNIAlias, ocDsx3SuniB1Bip8Err=ocDsx3SuniB1Bip8Err, svcSetupTableNextIndex=svcSetupTableNextIndex, pvpSetupHighEPortIndex=pvpSetupHighEPortIndex, configEPortIlmiConfigMaxVpiBits=configEPortIlmiConfigMaxVpiBits, ocCNNISessDataOutPort=ocCNNISessDataOutPort, pvcSetupVcCrossConnectIndex=pvcSetupVcCrossConnectIndex, configIPortScratchPadQueueEfciTaggingAdminStatus=configIPortScratchPadQueueEfciTaggingAdminStatus, ocCNNISessTableEntry=ocCNNISessTableEntry, statusEPortAdjInfoIfName=statusEPortAdjInfoIfName, statsCpuPortDiscardCellLatch=statsCpuPortDiscardCellLatch, trafficDescriptorTaggingFlag=trafficDescriptorTaggingFlag, controlDeleteCode=controlDeleteCode, configSvpSvc=configSvpSvc, fhTrapDashboardControlTrapTypeIndex=fhTrapDashboardControlTrapTypeIndex, ocCNNIMonTables=ocCNNIMonTables, infoXModuleHwOptionSlotIndex=infoXModuleHwOptionSlotIndex, pvcSetupHighVpi=pvcSetupHighVpi, ocCNNIGlobalStatsBrokenRoot=ocCNNIGlobalStatsBrokenRoot, temperatureCriticalTrapThreshold=temperatureCriticalTrapThreshold, ocCNNIAddrStatsEntry=ocCNNIAddrStatsEntry, configEPortBandwidthLimit=configEPortBandwidthLimit, configEPortScratchPadBandwidthLimit=configEPortScratchPadBandwidthLimit, statsEportTable=statsEportTable, ocCNNITrapClientAddress=ocCNNITrapClientAddress, configCommonSignallingT398=configCommonSignallingT398, configCommonSignallingT331=configCommonSignallingT331, configEPortScratchPadIlmiConfigUniVersion=configEPortScratchPadIlmiConfigUniVersion, configEPortIlmiConfigPnniVpi=configEPortIlmiConfigPnniVpi, vpcExtensionOrigAtmAddr=vpcExtensionOrigAtmAddr, configCommonSscopMaxSduSize=configCommonSscopMaxSduSize, svpSetupTableNextIndex=svpSetupTableNextIndex, configTmControlVbrTrafficAllocation=configTmControlVbrTrafficAllocation, configCommonEPortMaxSvpcVpi=configCommonEPortMaxSvpcVpi, statusPsuIndex=statusPsuIndex, psuFailureTrap=psuFailureTrap, crossfireAtmStatus=crossfireAtmStatus, configIpArpServerAtmAddressActual=configIpArpServerAtmAddressActual, ocCNNIAliasTable=ocCNNIAliasTable, infoProcessorModuleHwOptionNo=infoProcessorModuleHwOptionNo, configIPortQueueTable=configIPortQueueTable, svpSetupRxTrafficDescriptorIndex=svpSetupRxTrafficDescriptorIndex, statsCpuPortDiscardCellCounter=statsCpuPortDiscardCellCounter, ocCNNIAddrStatsFromTotal=ocCNNIAddrStatsFromTotal, configNetworkClockSource=configNetworkClockSource, configIPortRIndex=configIPortRIndex, statusXModuleSlotIndex=statusXModuleSlotIndex, ocCNNINeighborTableData=ocCNNINeighborTableData, statusFatalDump=statusFatalDump, ocCNNIPortProtocol=ocCNNIPortProtocol, configEPortIlmiConfigUniType=configEPortIlmiConfigUniType, configCommonSscopMaxSaps=configCommonSscopMaxSaps, atmLoopbackVcE2e=atmLoopbackVcE2e, ocCNNIGlobalStatsTotal=ocCNNIGlobalStatsTotal, statsEPortRxHecErrorCellRate=statsEPortRxHecErrorCellRate, configEPortScratchPadHwConfigSonetSdh=configEPortScratchPadHwConfigSonetSdh, statusEPortAdjInfoMinSvccVci=statusEPortAdjInfoMinSvccVci, configIPortQueueEfciTaggingAdminStatus=configIPortQueueEfciTaggingAdminStatus, ocCNNISessDataInPort=ocCNNISessDataInPort, statsGlobalCongestionState=statsGlobalCongestionState, ocCNNIFilterInPortPres=ocCNNIFilterInPortPres, ifTestId=ifTestId, configEPortScratchPadScratchPadStatus=configEPortScratchPadScratchPadStatus, configEPortScratchPadTransientPhyOffTime=configEPortScratchPadTransientPhyOffTime, configCommonEPortTransientPhyWindowTime=configCommonEPortTransientPhyWindowTime, pvcSetupTable=pvcSetupTable, configEPortIlmiConfigMinSvccVci=configEPortIlmiConfigMinSvccVci, configCommonEPortTransientPhyOffTime=configCommonEPortTransientPhyOffTime, configCommonSignallingT304=configCommonSignallingT304, ocCNNIAddrStatsFromOneWay=ocCNNIAddrStatsFromOneWay, ocCNNIFilterAssignID=ocCNNIFilterAssignID, configEPortScratchPadIlmiConfigMaxVpiBits=configEPortScratchPadIlmiConfigMaxVpiBits, infoFeatureModuleHwOptionEntry=infoFeatureModuleHwOptionEntry, statusHwChassisCurrentEPorts=statusHwChassisCurrentEPorts, configCommonSignallingMaxTunnels=configCommonSignallingMaxTunnels, trafficDescriptorPcr0=trafficDescriptorPcr0, configTmServiceClassMapServiceClass=configTmServiceClassMapServiceClass, configEPortScratchPadIlmiConfigLecsVci=configEPortScratchPadIlmiConfigLecsVci, configCommonSignallingT313=configCommonSignallingT313, iPortTxParityErrorTrap=iPortTxParityErrorTrap, infoFeatureModuleHwOptionTable=infoFeatureModuleHwOptionTable, configCpuPortCpuQueueSize=configCpuPortCpuQueueSize, vpcExtensionCapabilities=vpcExtensionCapabilities, statusCurrentTemperatureGauge=statusCurrentTemperatureGauge, vpcExtensionTermAtmAddr=vpcExtensionTermAtmAddr, configSwitchAddrPrefixType=configSwitchAddrPrefixType, configEPortScratchPadIlmiConfigLecsVpi=configEPortScratchPadIlmiConfigLecsVpi, svcSetupRowStatus=svcSetupRowStatus, ocCNNIGlobalStatsOneWay=ocCNNIGlobalStatsOneWay, infoIfIndexSlip=infoIfIndexSlip, statusEPortRxSyncLedState=statusEPortRxSyncLedState, configEPortVbrNrtBandwidthAllocation=configEPortVbrNrtBandwidthAllocation, configIpArpServerAdminStatus=configIpArpServerAdminStatus, statusPsuStatusEntry=statusPsuStatusEntry, statsEPortRxHecErrorCellLatch=statsEPortRxHecErrorCellLatch, configIpArp=configIpArp, configCommonSignallingMaxSaps=configCommonSignallingMaxSaps, statusFatalStatMaxDumpLength=statusFatalStatMaxDumpLength, configIPortQueueClpDiscardThreshold=configIPortQueueClpDiscardThreshold, olicom=olicom, statusXModuleIPort1SlotIndex=statusXModuleIPort1SlotIndex, configTmControlErTuningPhi=configTmControlErTuningPhi, configCommonSignallingPtmpMaxLeafsDropByClear=configCommonSignallingPtmpMaxLeafsDropByClear, trafficDescriptorRowStatus=trafficDescriptorRowStatus, statusFatalIndex=statusFatalIndex, vccExtensionEarlyPacketDiscard=vccExtensionEarlyPacketDiscard, ocDsx3SuniCppmFrameErr=ocDsx3SuniCppmFrameErr, atmTESTMIBObjects=atmTESTMIBObjects, configEPortScratchPadLinkDelay=configEPortScratchPadLinkDelay, configXModule=configXModule, configNextHopRoutingSignallingType=configNextHopRoutingSignallingType, ocCNNIConfigAlgorithm=ocCNNIConfigAlgorithm, configCommonSscopTimerCc=configCommonSscopTimerCc, configCommonEPortTransientPhyDisconnectTimer=configCommonEPortTransientPhyDisconnectTimer, statusFatalSource=statusFatalSource, configCommonSignallingPtmpMaxP2mpSvcs=configCommonSignallingPtmpMaxP2mpSvcs, configCommonEPortAbrBandwidthAllocation=configCommonEPortAbrBandwidthAllocation, configIPortScratchPadUseCommonIPortConfig=configIPortScratchPadUseCommonIPortConfig, statusEPortIfIndex=statusEPortIfIndex, controlDeleteConfig=controlDeleteConfig, termRestartInfoReloadTime=termRestartInfoReloadTime, infoFeatureModuleHwOptionNo=infoFeatureModuleHwOptionNo, configEPortScratchPadIlmiConfigUniType=configEPortScratchPadIlmiConfigUniType, infoIfIndexAtmNode=infoIfIndexAtmNode, trafficDescriptorEntry=trafficDescriptorEntry, termRestartInfoSwImageLoaded=termRestartInfoSwImageLoaded, statusEPortAutoconfigMaxVpiBits=statusEPortAutoconfigMaxVpiBits, configEPortUseCommonEPortConfig=configEPortUseCommonEPortConfig, crossfireAtmStatistics=crossfireAtmStatistics, configCommonIPortQueueSize=configCommonIPortQueueSize, statusEPortAdjInfoMaxVpiBits=statusEPortAdjInfoMaxVpiBits, configNextHopRoutingRowStatus=configNextHopRoutingRowStatus, atmLoopbackVpE2e=atmLoopbackVpE2e, ocCNNIPortEntry=ocCNNIPortEntry, ocCNNIPortConfig=ocCNNIPortConfig, ocCNNISessTable=ocCNNISessTable, termRestartInfoRestartTime=termRestartInfoRestartTime, ocDsx3MIBObjs=ocDsx3MIBObjs, statusXModuleIPort2RIndex=statusXModuleIPort2RIndex, configTmServiceClassMapTable=configTmServiceClassMapTable, configStaticEPortIlmiPollFrequency=configStaticEPortIlmiPollFrequency, ocCNNISessID=ocCNNISessID, configEPortScratchPadIpAddress=configEPortScratchPadIpAddress, configFeatureModuleAdminStatus=configFeatureModuleAdminStatus, configNextHopRoutingEntry=configNextHopRoutingEntry, configSwitchAddrAtmPrefix=configSwitchAddrAtmPrefix, trafficDescriptorIndex=trafficDescriptorIndex, statsQueueCongestionCellsInQueueGauge=statsQueueCongestionCellsInQueueGauge, ocDsx3ConfigTable=ocDsx3ConfigTable, pvcSetupHighVci=pvcSetupHighVci, pvpSetupLowEPortIndex=pvpSetupLowEPortIndex, statsEportEntry=statsEportEntry, ocCNNIAddrStatsToOneWay=ocCNNIAddrStatsToOneWay, statusFatalStatOverflow=statusFatalStatOverflow, configIPortQueueEfciTaggingThreshold=configIPortQueueEfciTaggingThreshold, ocDsx3SuniCppmXmtCells=ocDsx3SuniCppmXmtCells, configEPortHwConfigSonetSdh=configEPortHwConfigSonetSdh, pvpSetupH2LTrafficDescriptorIndex=pvpSetupH2LTrafficDescriptorIndex, configIPortQueueQueueIndex=configIPortQueueQueueIndex, statsGlobalCongestionDiscardCellRate=statsGlobalCongestionDiscardCellRate, configIPortQueueCdv=configIPortQueueCdv, featureModuleStatusChange=featureModuleStatusChange, configEPortScratchPadDefaultSigVersion=configEPortScratchPadDefaultSigVersion, trafficDescriptorAbrRdf=trafficDescriptorAbrRdf, trafficDescriptorAbrTbe=trafficDescriptorAbrTbe, statusEPortAdjInfoMaxSvpcVpi=statusEPortAdjInfoMaxSvpcVpi, ocCNNIFilterInPortData=ocCNNIFilterInPortData, configEPortIlmiConfigUniVersion=configEPortIlmiConfigUniVersion, configIPortScratchPadIPortRIndex=configIPortScratchPadIPortRIndex, configCommonEPortCbrBandwidthAllocation=configCommonEPortCbrBandwidthAllocation, statsInvalidCellRate=statsInvalidCellRate, configEPortLinkDelay=configEPortLinkDelay, pvpSetupEntry=pvpSetupEntry, configIpArpServerIndex=configIpArpServerIndex, configIlmiServiceRegistryParm1=configIlmiServiceRegistryParm1, configEPortScratchPadIlmiConfigMaxVciBits=configEPortScratchPadIlmiConfigMaxVciBits, configStaticEPortMaxPhyFailuresPerMinute=configStaticEPortMaxPhyFailuresPerMinute, configEPortIlmiConfigMaxSvpcVpi=configEPortIlmiConfigMaxSvpcVpi, configCommonSignallingPtmpMaxLeafs=configCommonSignallingPtmpMaxLeafs, termRestartInfoFileName=termRestartInfoFileName, configNextHopRoutingAtmAddress=configNextHopRoutingAtmAddress, configIpArpServerAtmAddressSpec=configIpArpServerAtmAddressSpec, ocCNNIApplID=ocCNNIApplID, statusCurrentTemperatureLatch=statusCurrentTemperatureLatch, ocCNNIGlobalStatsCreated=ocCNNIGlobalStatsCreated, ocCNNISessDataType=ocCNNISessDataType, trafficDescriptorScr01=trafficDescriptorScr01, configCommonSignallingT309=configCommonSignallingT309, statsIPortRIndex=statsIPortRIndex, configLaneControlAdminStatus=configLaneControlAdminStatus, statusVpcVcc=statusVpcVcc, configTmControlErTuningDelta=configTmControlErTuningDelta, infoProcessorModuleHwSerialNumber=infoProcessorModuleHwSerialNumber, statsEPortRxHecErrorCellCounter=statsEPortRxHecErrorCellCounter, configTmControlErTuningPsi=configTmControlErTuningPsi, configSerialObmSlip=configSerialObmSlip, configEPortIlmiConfigMaxVpcs=configEPortIlmiConfigMaxVpcs, configIPortEntry=configIPortEntry, ocCNNIAliasTableEntry=ocCNNIAliasTableEntry, infoFeatureModuleHwOption=infoFeatureModuleHwOption, svcSetupVcCrossConnectIndex=svcSetupVcCrossConnectIndex, pvcSetupHighEPortIndex=pvcSetupHighEPortIndex, configTm=configTm, configEPortScratchPadIlmiConfigNniSigVersion=configEPortScratchPadIlmiConfigNniSigVersion, statusEPortAdjInfoMaxVpcs=statusEPortAdjInfoMaxVpcs, infoXModuleTable=infoXModuleTable, crossfireAtmConfiguration=crossfireAtmConfiguration, configFeatureModule=configFeatureModule, configIlmiServiceRegistryServiceId=configIlmiServiceRegistryServiceId, configMonitorEPortIPortRIndex=configMonitorEPortIPortRIndex, configTmControlMode=configTmControlMode, configEPortScratchPadAbrBandwidthAllocation=configEPortScratchPadAbrBandwidthAllocation, ocCNNILineStatus=ocCNNILineStatus, temperatureWarningTrap=temperatureWarningTrap, configEPortScratchPadIlmiConfigDeviceType=configEPortScratchPadIlmiConfigDeviceType, ocDsx3Scrambling=ocDsx3Scrambling, ocCNNIAddrStatsFromCreated=ocCNNIAddrStatsFromCreated, ocDsx3SuniCppmMegaXmtCells=ocDsx3SuniCppmMegaXmtCells, ocDsx3Ext8kRefClk=ocDsx3Ext8kRefClk, ocCNNIRoutingTableData=ocCNNIRoutingTableData, globalCongestionTrap=globalCongestionTrap, configEPortTransientPhyDisconnectTimer=configEPortTransientPhyDisconnectTimer, pvcSetupL2HTrafficDescriptorIndex=pvcSetupL2HTrafficDescriptorIndex, termRestartInfoRestartReason=termRestartInfoRestartReason, statsIPortEntry=statsIPortEntry, configIPortTable=configIPortTable, svcSetupRxTrafficDescriptorIndex=svcSetupRxTrafficDescriptorIndex, ocCNNIAddrStatsToBrokenLeaf=ocCNNIAddrStatsToBrokenLeaf, trafficDescriptorMcr=trafficDescriptorMcr, ocCNNITrapClientCommName=ocCNNITrapClientCommName, configSar=configSar, pvcSetupLowEPortIndex=pvcSetupLowEPortIndex, configIPortScratchPadSlotIndex=configIPortScratchPadSlotIndex, configEPortScratchPadIlmiConfigMaxSvpcVpi=configEPortScratchPadIlmiConfigMaxSvpcVpi, atmIpArpType=atmIpArpType, statusXModuleIPort2SlotIndex=statusXModuleIPort2SlotIndex, infoXModuleHwEcoLevel=infoXModuleHwEcoLevel, configSarMuxSarVpi=configSarMuxSarVpi, crossfirexlx=crossfirexlx)
mibBuilder.exportSymbols("Olicom-crossfireAtmSwitch-MIB", configSwitchAddrPrefixSize=configSwitchAddrPrefixSize, statusBasicHw=statusBasicHw, infoXModuleHwSerialNumber=infoXModuleHwSerialNumber, trafficDescriptorAbrNrm=trafficDescriptorAbrNrm, configCpuPortResetQueueSize=configCpuPortResetQueueSize, statusEPortLoopbackState=statusEPortLoopbackState, statusEPortAdjInfoIlmiVersion=statusEPortAdjInfoIlmiVersion, configIPortScratchPadQueueCdv=configIPortScratchPadQueueCdv, statusFatalOriginalDumpSize=statusFatalOriginalDumpSize, statsGlobalCongestionDiscardCellCounter=statsGlobalCongestionDiscardCellCounter, statusEPortAdjInfoDeviceType=statusEPortAdjInfoDeviceType, configXModuleSlotIndex=configXModuleSlotIndex, configCommonSignallingT303=configCommonSignallingT303, ocDsx3SuniCppmIdleCells=ocDsx3SuniCppmIdleCells, pvpSetupTableNextIndex=pvpSetupTableNextIndex, configPriorityBufferTable=configPriorityBufferTable, configCommonEPortMaxSvccVpi=configCommonEPortMaxSvccVpi, configStaticEPortIlmiPollRetries=configStaticEPortIlmiPollRetries, configCommonIPortQueueEntry=configCommonIPortQueueEntry, infoFeatureModule=infoFeatureModule, configIpArpServerRowStatus=configIpArpServerRowStatus, configEPortScratchPadIlmiConfigIlmiVpi=configEPortScratchPadIlmiConfigIlmiVpi, ocCNNIRoutingTableEntry=ocCNNIRoutingTableEntry, trafficDescriptorCreationMode=trafficDescriptorCreationMode, ocCNNITrapClientTable=ocCNNITrapClientTable, ocCNNINeighborTableChanged=ocCNNINeighborTableChanged, pvcSetupTableNextIndex=pvcSetupTableNextIndex, statusEPortAdjInfoSystemIdentifier=statusEPortAdjInfoSystemIdentifier, infoXModuleHwProductId=infoXModuleHwProductId, configCommonEPortLecsVci=configCommonEPortLecsVci, configCommonSignallingT306=configCommonSignallingT306, configCommonSscopMaxRcvWinSize=configCommonSscopMaxRcvWinSize, configCommonEPortUniType=configCommonEPortUniType, statsIPortRxCellRate=statsIPortRxCellRate, vccExtensionTable=vccExtensionTable, ocCNNIFilterTable=ocCNNIFilterTable, configIlmiServiceRegistryRowStatus=configIlmiServiceRegistryRowStatus, ocmibsCrossfireAtmMIB=ocmibsCrossfireAtmMIB, statusXModuleNoOfSlotsUsed=statusXModuleNoOfSlotsUsed, statisticsIPort=statisticsIPort, ocCNNISessDataCgPty=ocCNNISessDataCgPty, ocCNNIAddrStatsFromConnected=ocCNNIAddrStatsFromConnected, atmIpArpAtmAddress=atmIpArpAtmAddress, configAddressing=configAddressing, statusFatalLog=statusFatalLog, configIpArpServerAtmAddressMask=configIpArpServerAtmAddressMask, statsGlobalCongestionDiscardCellLatchTime=statsGlobalCongestionDiscardCellLatchTime, configIPortScratchPadQueueClpDiscardAdminStatus=configIPortScratchPadQueueClpDiscardAdminStatus, pvpSetupApplication=pvpSetupApplication, vccExtensionOrigAtmAddr=vccExtensionOrigAtmAddr, configCommonSignallingMaxConManStevs=configCommonSignallingMaxConManStevs, termRestartInfoTerminationReason=termRestartInfoTerminationReason, statusEPortPhyState=statusEPortPhyState, configEPortScratchPadIlmiConfigSignallingVci=configEPortScratchPadIlmiConfigSignallingVci, configCommonEPortAddrRegistrationAdminStatus=configCommonEPortAddrRegistrationAdminStatus, ocCNNIFilterTableEntry=ocCNNIFilterTableEntry, configStaticEPortMaxTransientPhyFailureTime=configStaticEPortMaxTransientPhyFailureTime, configCommonSignallingMaxSigProtStevs=configCommonSignallingMaxSigProtStevs, configCommonSignallingMaxPvcs=configCommonSignallingMaxPvcs, infoXModule=infoXModule, configEPortIlmiConfigIlmiVpi=configEPortIlmiConfigIlmiVpi, ocCNNIAddressAlias=ocCNNIAddressAlias, ePortHecErrorRateTrap=ePortHecErrorRateTrap, statusEPortAutoconfigMaxVccs=statusEPortAutoconfigMaxVccs, configSwitchAddrAtmAddress=configSwitchAddrAtmAddress, configCommonSscopTimerNoResponse=configCommonSscopTimerNoResponse, statusFeatureModuleStatusLed=statusFeatureModuleStatusLed, configCommonEPortVbrRtBandwidthAllocation=configCommonEPortVbrRtBandwidthAllocation, statsQueueCongestionTable=statsQueueCongestionTable, oamFlowNoResponseTrap=oamFlowNoResponseTrap, ocDsx3SuniCppmMegaRcvCells=ocDsx3SuniCppmMegaRcvCells, configEPortIlmiConfigDeviceType=configEPortIlmiConfigDeviceType, configEPortScratchPadUseCommonEPortConfig=configEPortScratchPadUseCommonEPortConfig, svpSetupRowStatus=svpSetupRowStatus, statusEPortIlmiState=statusEPortIlmiState, ocCNNIPortAutoreroute=ocCNNIPortAutoreroute, configEPortIlmiConfigSignallingVci=configEPortIlmiConfigSignallingVci, configEPortVbrRtBandwidthAllocation=configEPortVbrRtBandwidthAllocation, configCommonEPortSignallingVci=configCommonEPortSignallingVci, configCommonIPortQueueTable=configCommonIPortQueueTable, statusProcessorModule=statusProcessorModule, configEPortTransientPhyOffTime=configEPortTransientPhyOffTime, infoXModuleHwOption=infoXModuleHwOption, ocDsx3SuniPmonFerr=ocDsx3SuniPmonFerr, trafficDescriptorCdv=trafficDescriptorCdv, trafficDescriptorTable=trafficDescriptorTable, configCommonSignallingT308=configCommonSignallingT308, configEPortIlmiConfigMaxVccs=configEPortIlmiConfigMaxVccs, configCommonSignallingT316=configCommonSignallingT316, ocCNNIMode=ocCNNIMode, configEPortIlmiConfigIlmiVci=configEPortIlmiConfigIlmiVci, ocCNNIFilterTypeData=ocCNNIFilterTypeData, configCommonIPortEfciTaggingThreshold=configCommonIPortEfciTaggingThreshold, configIpArpServerTable=configIpArpServerTable, configCommonSignalling=configCommonSignalling, infoProcessorModuleHwOptionEntry=infoProcessorModuleHwOptionEntry, configIPortQueueClpDiscardAdminStatus=configIPortQueueClpDiscardAdminStatus, termRestartInfoSwSection1StatusWord=termRestartInfoSwSection1StatusWord, configCommonEPortIlmiAdminStatus=configCommonEPortIlmiAdminStatus, configCommonSscopTimerKeepAlive=configCommonSscopTimerKeepAlive, configCommonSignallingT317=configCommonSignallingT317, configEPortScratchPadIlmiConfigIlmiVci=configEPortScratchPadIlmiConfigIlmiVci, configOam=configOam, statisticsGlobal=statisticsGlobal, statsEPortHecErrorRateConditionState=statsEPortHecErrorRateConditionState, configEPortScratchPadEPortIndex=configEPortScratchPadEPortIndex, configIPortScratchPadScratchPadStatus=configIPortScratchPadScratchPadStatus, ocCNNIRoutingTableChanged=ocCNNIRoutingTableChanged, configPriorityBuffer=configPriorityBuffer, ocCNNIGlobalStats=ocCNNIGlobalStats, ocCNNIFilterCdPtyPres=ocCNNIFilterCdPtyPres, configNextHopRoutingAddressLength=configNextHopRoutingAddressLength, vccExtensionCapabilities=vccExtensionCapabilities, configEPortScratchPadTransientPhyWindowTime=configEPortScratchPadTransientPhyWindowTime, statusEPortXModuleIndex=statusEPortXModuleIndex, configIPortUseCommonIPortConfig=configIPortUseCommonIPortConfig, trafficDescriptorMbs01=trafficDescriptorMbs01, statsIPortTable=statsIPortTable, configPriorityBufferSize=configPriorityBufferSize, configCommonEPortMaxVpiBits=configCommonEPortMaxVpiBits, statusEPortAdjInfoNniSigVersion=statusEPortAdjInfoNniSigVersion, termRestartInfoServerIpAddress=termRestartInfoServerIpAddress, configEPortHwConfigTxClocking=configEPortHwConfigTxClocking, ifTestTable=ifTestTable, ocCNNIAddrStatsToBrokenRoot=ocCNNIAddrStatsToBrokenRoot, ocDsx3SuniPmonLcv=ocDsx3SuniPmonLcv, statusXModuleIPort3RIndex=statusXModuleIPort3RIndex, ocCNNISessDataCdPty=ocCNNISessDataCdPty, qosClassClass=qosClassClass, ocCNNIAddress=ocCNNIAddress, configEPortScratchPadHwConfigTxClocking=configEPortScratchPadHwConfigTxClocking, configEPortScratchPadVbrNrtBandwidthAllocation=configEPortScratchPadVbrNrtBandwidthAllocation, configIlmiServiceRegistryEntry=configIlmiServiceRegistryEntry, ocDsx3CntHcsCorrectedErrs=ocDsx3CntHcsCorrectedErrs, configCommonIPortEfciTaggingAdminStatus=configCommonIPortEfciTaggingAdminStatus, pvpSetupRowStatus=pvpSetupRowStatus, configIPort=configIPort, svpSetupPreferredVpi=svpSetupPreferredVpi, fhTrapDashboardControlNoSamples=fhTrapDashboardControlNoSamples, infoProcessorModuleHwOption=infoProcessorModuleHwOption, configCommonSscopMaxPd=configCommonSscopMaxPd, termRestartInfoBootpExecuted=termRestartInfoBootpExecuted, statusFatalLine=statusFatalLine, configIpArpServerTableNextIndex=configIpArpServerTableNextIndex, configMonitoring=configMonitoring, atmLoopbackTestGroup=atmLoopbackTestGroup, configLane=configLane, statusEPortRIndex=statusEPortRIndex, configIlmiServiceRegistryTable=configIlmiServiceRegistryTable, statusCurrentTemperatureConditionState=statusCurrentTemperatureConditionState, configCommonSscopTimerPoll=configCommonSscopTimerPoll, statusEPortSignalLossLedState=statusEPortSignalLossLedState, svpSetupVpCrossConnectIndex=svpSetupVpCrossConnectIndex, ocCNNIConfigMethod=ocCNNIConfigMethod, trafficDescriptorAbrCdf=trafficDescriptorAbrCdf, ocCNNIFilterCdPtyData=ocCNNIFilterCdPtyData, statsIPortSlotIndex=statsIPortSlotIndex, globalInvalidCellRateTrap=globalInvalidCellRateTrap, statusEPortAutoconfigMinSvccVci=statusEPortAutoconfigMinSvccVci, pvcSetupLowVci=pvcSetupLowVci, statusEPortAdjInfoUniType=statusEPortAdjInfoUniType, configCommonSignallingPtmpMaxLeafOperations=configCommonSignallingPtmpMaxLeafOperations, ocDsx3SuniCppmMegaIdleCells=ocDsx3SuniCppmMegaIdleCells, statsInvalidCellLatch=statsInvalidCellLatch, ocCNNIConfig=ocCNNIConfig, configEPortIlmiConfigPnniVci=configEPortIlmiConfigPnniVci, ocCNNIFilterStatePres=ocCNNIFilterStatePres, ocCNNIAddrStatsToCreated=ocCNNIAddrStatsToCreated, configCommonSscopMaxCc=configCommonSscopMaxCc, configCommonSscopMaxUuSize=configCommonSscopMaxUuSize, ocCNNIGlobalStatsBrokenLeaf=ocCNNIGlobalStatsBrokenLeaf, fanFailureTrap=fanFailureTrap, pvcSetupH2LTrafficDescriptorIndex=pvcSetupH2LTrafficDescriptorIndex, configIPortScratchPadIpAddress=configIPortScratchPadIpAddress, configQosClass=configQosClass, infoFeatureModuleHwProductId=infoFeatureModuleHwProductId, statusEPortAdjInfoMaxVccs=statusEPortAdjInfoMaxVccs, configIpArpServerEntry=configIpArpServerEntry, ocDsx3ShortCable=ocDsx3ShortCable, ifTestType=ifTestType, infoProcessorModuleHwVersion=infoProcessorModuleHwVersion, trafficDescriptorFrameDiscardFlag=trafficDescriptorFrameDiscardFlag, trafficDescriptorServiceClass=trafficDescriptorServiceClass, vccExtensionEntry=vccExtensionEntry, configCommonEPortMaxVpcs=configCommonEPortMaxVpcs, configEPortScratchPadIlmiConfigMaxVpcs=configEPortScratchPadIlmiConfigMaxVpcs, statisticsCpuPort=statisticsCpuPort, configXModuleAdminStatus=configXModuleAdminStatus, configIPortScratchPadQueueEntry=configIPortScratchPadQueueEntry, atmLoopbackVcSegment=atmLoopbackVcSegment, infoXModuleEntry=infoXModuleEntry, configTmControlErTuningAlpha=configTmControlErTuningAlpha, configMonitorEPortIPortSlotIndex=configMonitorEPortIPortSlotIndex, infoProcessorModuleHwProductId=infoProcessorModuleHwProductId, configEPortIlmiConfigNniSigVersion=configEPortIlmiConfigNniSigVersion, configPriorityBufferEntry=configPriorityBufferEntry, qosClassTable=qosClassTable, configCommonSignallingT397=configCommonSignallingT397, configEPortScratchPadIlmiConfigIlmiAdminStatus=configEPortScratchPadIlmiConfigIlmiAdminStatus, infoProcessorModuleHwEcoLevel=infoProcessorModuleHwEcoLevel, ocDsx3SuniPdhEntry=ocDsx3SuniPdhEntry, configCommonEPortLinkDelay=configCommonEPortLinkDelay, ocCNNIFilterID=ocCNNIFilterID, configTmControlErTuningBeta=configTmControlErTuningBeta, configCommonEPortMaxVccs=configCommonEPortMaxVccs, trafficDescriptorTableNextIndex=trafficDescriptorTableNextIndex, configCommonEPortMinSvccVci=configCommonEPortMinSvccVci, configCommonIPortLogClr=configCommonIPortLogClr, configTmServiceClassMapSchedulingQueue=configTmServiceClassMapSchedulingQueue, qosClassCtd=qosClassCtd, statusCurrentTemperatureLatchTime=statusCurrentTemperatureLatchTime, configEPortScratchPadTransientPhyDisconnectTimer=configEPortScratchPadTransientPhyDisconnectTimer, trafficDescriptorAbrTrm=trafficDescriptorAbrTrm, pvpSetupIndex=pvpSetupIndex, configEPortIlmiConfigSignallingVpi=configEPortIlmiConfigSignallingVpi, trafficDescriptorAbrIcr=trafficDescriptorAbrIcr, statusXModuleOperStatus=statusXModuleOperStatus, vpcExtensionIndex=vpcExtensionIndex, configIPortQueueSlotIndex=configIPortQueueSlotIndex, pvpSetupVpCrossConnectIndex=pvpSetupVpCrossConnectIndex, infoFeatureModuleHwVersion=infoFeatureModuleHwVersion, svcSetupTxTrafficDescriptorIndex=svcSetupTxTrafficDescriptorIndex, ifTestCode=ifTestCode, statsIPortTxCellRate=statsIPortTxCellRate, infoXModuleHwOptionNo=infoXModuleHwOptionNo, statusEPortAutoconfigMaxSvccVpi=statusEPortAutoconfigMaxSvccVpi, ocDsx3SuniPdhTable=ocDsx3SuniPdhTable, pvcSetupRowStatus=pvcSetupRowStatus, configEPortTransientPhyDisconnectCount=configEPortTransientPhyDisconnectCount, ifMIBObjects=ifMIBObjects, configCommonSscopMaxLinks=configCommonSscopMaxLinks, infoXModuleHwOptionEntry=infoXModuleHwOptionEntry, vpcExtensionVpCrossConnectIndex=vpcExtensionVpCrossConnectIndex, infoXModuleHwVersion=infoXModuleHwVersion, configServiceReg=configServiceReg, vpcExtensionTable=vpcExtensionTable, configCommonIPortCdv=configCommonIPortCdv, configIisp=configIisp, statusFatalStatFree=statusFatalStatFree, configEPortScratchPadIlmiConfigAddrRegistrationAdminStatus=configEPortScratchPadIlmiConfigAddrRegistrationAdminStatus, configEPortTable=configEPortTable, statsIPortTxParityErrorCellCounter=statsIPortTxParityErrorCellCounter, statusEPortTable=statusEPortTable, configIPortScratchPadActionStatus=configIPortScratchPadActionStatus, ocCNNIPortAssign=ocCNNIPortAssign, infoFeatureModuleHwEcoLevel=infoFeatureModuleHwEcoLevel, statusEPortAdjInfoUniVersion=statusEPortAdjInfoUniVersion, infoIfIndexRfc1483Bridged=infoIfIndexRfc1483Bridged, configEPortIlmiConfigIlmiAdminStatus=configEPortIlmiConfigIlmiAdminStatus, configTmControlErTuningTau=configTmControlErTuningTau, ocDsx3=ocDsx3, configEPortScratchPadCbrBandwidthAllocation=configEPortScratchPadCbrBandwidthAllocation, statusFeatureModuleOperStatus=statusFeatureModuleOperStatus, ifTestOwner=ifTestOwner)
mibBuilder.exportSymbols("Olicom-crossfireAtmSwitch-MIB", configCommonSignallingT399=configCommonSignallingT399, configIpArpServerIpSubnetMask=configIpArpServerIpSubnetMask, configEPortScratchPadLoopback=configEPortScratchPadLoopback, statusEPortType=statusEPortType, configPvpPvc=configPvpPvc, ocDsx3SuniPmonPpec=ocDsx3SuniPmonPpec)

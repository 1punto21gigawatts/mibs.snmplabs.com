#
# PySNMP MIB module APM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:23:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
rmon, OwnerString = mibBuilder.importSymbols("RMON-MIB", "rmon", "OwnerString")
protocolDirLocalIndex, = mibBuilder.importSymbols("RMON2-MIB", "protocolDirLocalIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, Bits, ModuleIdentity, TimeTicks, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType, iso, Counter32, ObjectIdentity, IpAddress, Counter64, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Bits", "ModuleIdentity", "TimeTicks", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType", "iso", "Counter32", "ObjectIdentity", "IpAddress", "Counter64", "Integer32")
TextualConvention, RowStatus, TruthValue, DisplayString, StorageType, TimeInterval, TimeStamp, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString", "StorageType", "TimeInterval", "TimeStamp", "DateAndTime")
apm = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 23))
apm.setRevisions(('2004-02-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: apm.setRevisionsDescriptions(('The original version of this MIB Module, published as RFC3729.',))
if mibBuilder.loadTexts: apm.setLastUpdated('200402190000Z')
if mibBuilder.loadTexts: apm.setOrganization('IETF RMON MIB Working Group')
if mibBuilder.loadTexts: apm.setContactInfo('Author: Steve Waldbusser Phone: +1-650-948-6500 Fax : +1-650-745-0671 Email: waldbusser@nextbeacon.com Working Group Chair: Andy Bierman Cisco Systems, Inc. Postal: 170 West Tasman Drive San Jose, CA USA 95134 Tel: +1 408 527-3711 E-mail: abierman@cisco.com Working Group Mailing List: <rmonmib@ietf.org> To subscribe send email to: <rmonmib-request@ietf.org> ')
if mibBuilder.loadTexts: apm.setDescription('The MIB module for measuring application performance as experienced by end-users. Copyright (C) The Internet Society (2004). This version of this MIB module is part of RFC 3729; see the RFC itself for full legal notices.')
apmMibObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 23, 1))
apmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 23, 2))
apmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 23, 2, 1))
apmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 23, 2, 2))
class AppLocalIndex(TextualConvention, Unsigned32):
    description = "A locally arbitrary unique identifier associated with an application or application verb. All objects of type AppLocalIndex are assigned by the agent out of a common number space. In other words, AppLocalIndex values assigned to entries in one table must not overlap with AppLocalIndex values assigned to entries in another table. Further, every protocolDirLocalIndex value registered by the agent automatically assigns the same value out of the AppLocalIndex number space. For example, if the protocolDirLocalIndex values { 1, 3, 5, 7 } have been assigned, and the apmHttpFilterAppLocalIndex values { 6, 8, 9 } have been assigned: - Assignment of new AppLocalIndex values must not use the values { 1, 3, 5, 6, 7, 8, 9 }. - AppLocalIndex values { 1, 3, 5, 7 } are automatically assigned and are associated with the identical value of protocolDirLocalIndex. In particular, an entry in the apmAppDirTable indexed by a value provides further information about a protocol indexed by the same value in the protocolDirTable of RMON2. The value for each supported application must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization, except that if an application is deleted and re-created, it must be re-created with a new value that has not been used since the last re-initialization. The specific value is meaningful only within a given SNMP entity. An AppLocalIndex value must not be re-used until the next agent restart."
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class ProtocolDirNetworkAddress(TextualConvention, OctetString):
    description = 'A network level address whose semantics and encoding are specified by an associated protocolDirLocalIndex value. Objects of this type must specify which protocolDirLocalIndex value is used. This value is encoded according to the encoding rules for the identified protocolDirectory entry. For example, if the associated protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order. Objects of this type may allow this value to be the zero length string. If so, they must identify they meaning of this value.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class DataSourceOrZero(TextualConvention, ObjectIdentifier):
    reference = 'The DataSource textual convention is defined in RFC 2021 [5].'
    description = "Identifies the source of the data that the associated function is configured to analyze. This source can be any interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in [4], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. If the source of the data isn't an interface or cannot be localized to an interface, this object would be set to 0.0"
    status = 'current'

class RmonClientID(TextualConvention, Unsigned32):
    description = "A long-lived unique ID assigned to an end-system. This ID is assigned by the agent using an implementation-specific algorithm. Because a client machine may be assigned multiple addresses over any time period it can be difficult to attribute behavior to a particular client based solely on its address. A ClientID may be assigned to provide a more stable handle for referencing that client. The entity that assigns the ClientID may use various implementation techniques to keep track of a client but if the assigning entity is unable to track client address mappings, it may map client identifiers to client addresses rather than to distinct client machines. This is named ClientID because it helps to solve a problem seen in network clients (servers usually have well-known, long-lived addresses). However, ClientID's may be assigned to any end-system regardless of its role on the network."
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class TransactionAggregationType(TextualConvention, Integer32):
    description = 'Specifies one of 4 different techniques for aggregating transactions. The metrics for a single transaction are the responsiveness of the transaction and whether the transaction succeeded (a boolean). When such metrics are aggregated in this MIB Module, these metrics are replaced by averages and distributions of responsiveness and availability. The metrics describing aggregates are constant no matter which type of aggregation is being performed. These metrics may be found in the apmReportTable. The flows(1) aggregation is the simplest. All transactions that share common application/server/client 3-tuples are aggregated together, resulting in a set of metrics for all such unique 3-tuples. The clients(2) aggregation results in somewhat more aggregation (i.e., fewer resulting records). All transactions that share common application/client tuples are aggregated together, resulting in a set of metrics for all such unique tuples. The servers(3) aggregation usually results in still more aggregation (i.e., fewer resulting records). All transactions that share common application/server tuples are aggregated together, resulting in a set of metrics for all such unique tuples. The applications(4) aggregation results in the most aggregation (i.e., the fewest resulting records). All transactions that share a common application are aggregated together, resulting in a set of metrics for all such unique applications. Note that it is not meaningful to aggregate applications, as different applications have widely varying characteristics. As a result, this set of aggregations is complete.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("flows", 1), ("clients", 2), ("servers", 3), ("applications", 4))

apmAppDirTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 1), )
if mibBuilder.loadTexts: apmAppDirTable.setStatus('current')
if mibBuilder.loadTexts: apmAppDirTable.setDescription("The APM MIB directory of applications and application verbs. The agent will populate this table with all applications/verbs of any responsivenessType it has the capability to monitor. Since the agent populates this table with every entry it has the capability to monitor, the entries in this table are read-write, allowing the management station to modify parameters in this table but not to add new entries or delete entries (however, entries may be disabled). If new entries are added to the apmHttpFilterTable or the apmUserDefinedAppTable, the agent will add the corresponding entries to this table. It is an implementation-dependent matter as to how the agent sets these default parameters. For example, it may leave certain entries in this table 'off(0)' if the agent developer believes that combination will be infrequently used, allowing a manager that needs that capability to set it to 'on(1)'. Some applications are registered in the RMON2 protocol directory and some are registered in other tables in this MIB Module. Regardless of where an application is originally registered, it is assigned an AppLocalIndex value that is the primary index for this table. The contents of this table affect all reports and exceptions generated by this agent. Accordingly, modification of this table should be performed by a manager acting in the role of administrator. In particular, management software should not require or enforce particular configuration of this table - it should reflect the preferences of the site administrator, not the software author. As a practical matter, this requires management software to allow the administrator to configure the values it will use so that it can be adapted to the site policy.")
apmAppDirEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1), ).setIndexNames((0, "APM-MIB", "apmAppDirAppLocalIndex"), (0, "APM-MIB", "apmAppDirResponsivenessType"))
if mibBuilder.loadTexts: apmAppDirEntry.setStatus('current')
if mibBuilder.loadTexts: apmAppDirEntry.setDescription('The APM MIB directory of applications and application verbs. An entry will exist in this table for all applications for which application performance measurement is supported.')
apmAppDirAppLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 1), AppLocalIndex())
if mibBuilder.loadTexts: apmAppDirAppLocalIndex.setStatus('current')
if mibBuilder.loadTexts: apmAppDirAppLocalIndex.setDescription('The AppLocalIndex assigned for this application Directory entry.')
apmAppDirResponsivenessType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transactionOriented", 1), ("throughputOriented", 2), ("streamingOriented", 3))))
if mibBuilder.loadTexts: apmAppDirResponsivenessType.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessType.setDescription("This object describes and configures the agent's support for application performance measurement for this application. There are 3 types of measurements for different types of applications: Transaction-Oriented applications have a fairly constant workload to perform for all transactions. The responsiveness metric for transaction-oriented applications is application response time (from first request to final delivery of service) and is measured in milliseconds. This is commonly referred to as end-user response time. Throughput-Oriented applications have widely varying workloads based on the nature of the client request. In particular, throughput-oriented applications vary widely in the amount of data that must be transported to satisfy the request. The responsiveness metric for throughput-oriented applications is kilobits per second. Streaming-Oriented applications deliver data at a constant metered rate of speed regardless of the responsiveness of the networking and computing infrastructure. This constant rate of speed is generally specified to be below (sometimes well below) the nominal capability of the infrastructure. However, when the infrastructures cannot deliver data at this speed, interruption of service or degradation of service can result. The responsiveness metric for streaming-oriented applications is the ratio of time that the service is degraded or interrupted to the total service time. This metric is measured in parts per million. Note that for some applications, measuring more than one responsiveness type may be interesting. For agents that wish to support more than one measurement for a application, they will populate this table with multiple entries for that application, one for each type.")
apmAppDirConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirConfig.setStatus('current')
if mibBuilder.loadTexts: apmAppDirConfig.setDescription('This object describes and configures support for application performance measurement for this application. If the value of this object is on(2), the agent supports measurement of application performance metrics for this application and is configured to measure such metrics for all APM MIB functions and all interfaces. If the value of this object is off(1), the agent supports measurement of application performance for this application but is configured to not measure these metrics for any APM MIB functions or interfaces. Whenever this value changes from on(2) to off(1), the agent shall delete all related entries in all tables in this MIB Module. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary1 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary1.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary1.setDescription('The boundary value between bucket1 and bucket 2. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary2 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary2.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary2.setDescription('The boundary value between bucket2 and bucket 3. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary3 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary3.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary3.setDescription('The boundary value between bucket3 and bucket 4. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary4 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary4.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary4.setDescription('The boundary value between bucket4 and bucket 5. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary5 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary5.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary5.setDescription('The boundary value between bucket5 and bucket 6. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmAppDirResponsivenessBoundary6 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 1, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary6.setStatus('current')
if mibBuilder.loadTexts: apmAppDirResponsivenessBoundary6.setDescription('The boundary value between bucket6 and bucket 7. If this value is modified, all entries in the apmReportTable must be deleted by the agent. The value of this object must persist across reboots.')
apmBucketBoundaryLastChange = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmBucketBoundaryLastChange.setStatus('current')
if mibBuilder.loadTexts: apmBucketBoundaryLastChange.setDescription('The value of sysUpTime the last time that any bucket boundary in any appDirEntry was changed. This object can help to determine if two managers are both trying to enforce different configurations of this table.')
apmAppDirID = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmAppDirID.setStatus('current')
if mibBuilder.loadTexts: apmAppDirID.setDescription("This object allows managers to avoid downloading application directory information when the directory is set to a known (usually fixed) configuration. If the value of this object isn't 0.0, it signifies that the entire contents of the apmAppDirTable, apmHttpFilterTable, apmUserDefinedAppTable and protocolDirTable are equal to a known state identified by the value of this object. If a manager recognizes this value as identifying a directory configuration it has a local copy of, it may use this local copy rather than downloading these tables. Note that it may have downloaded this local copy (and the ID) from another agent and used this copy for all other agents that advertised the same ID. If an agent recognizes that the entire contents of the apmAppDirTable, apmHttpFilterTable, apmUserDefinedAppTable and protocolDirTable are equal to a known state to which an ID has been assigned, it should set this object to that ID. In many cases when this feature is used, the application directory information will be in read-only memory and thus the tables may not be modified via SNMP requests. In the event that the tables are writable and a modification is made, the agent is responsible for setting this object to 0.0 if it cannot determine that the state is equal to a known state. An agent is not obligated to recognize and advertise all such registered states as it may not have knowledge of all states. Thus, a manager may encounter agents whose DirectoryID value is 0.0 even though the contents of the directory were equal to a registered state. Note that the contents of those tables includes the protocolDirLocalIndex and appLocalIndex values. In other words, these values can't be assigned randomly on each agent, but must be equal to values that are part of the known state. While it is possible for a manager to download application directory details using SNMP and to set the appropriate directoryID, the manager would need to have some scheme to ensure consistent values of LocalIndex variables from agent to agent. Such schemes are outside the scope of this specification. Application directory registrations are unique within an administrative domain. Typically these registrations will be made by an agent software developer who will set the application directory tables to a read-only state and assign a DirectoryID to that state. Thus, all agents running this software would share the same DirectoryID. As the application directory might change from one software release to the next, the developer may register different DirectoryID's for each software release. A customer could also create a site-wide application directory configuration and assign a DirectoryID to that configuration as long as consistent values of LocalIndex variables can be ensured. The value of this object must persist across reboots.")
apmHttpFilterTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 4), )
if mibBuilder.loadTexts: apmHttpFilterTable.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterTable.setDescription('A table that creates virtual applications which measure the performance of certain web pages or sets of web pages. When an entry is added to this table, the agent will automatically create one or more entries in the apmAppDirTable (one for each responsivenessType it is capable of measuring). Note that when entries exist in this table some HTTP transactions will be summarized twice: in applications represented here as well as the HTTP application. If entries in this table overlap, these transactions may be summarized additional times. The contents of this table affect all reports and exceptions generated by this agent. Accordingly, modification of this table should be performed by a manager acting in the role of administrator. In particular, management software should not require or enforce particular configuration of this table - it should reflect the preferences of the site administrator, not the software author.')
apmHttpFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1), ).setIndexNames((0, "APM-MIB", "apmHttpFilterIndex"))
if mibBuilder.loadTexts: apmHttpFilterEntry.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterEntry.setDescription('A virtual application which measure the performance of certain web pages or sets of web pages.')
apmHttpFilterIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: apmHttpFilterIndex.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterIndex.setDescription('An index that uniquely identifies an entry in the apmHttpFilterTable.')
apmHttpFilterAppLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 2), AppLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmHttpFilterAppLocalIndex.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterAppLocalIndex.setDescription('The AppLocalIndex that represents HTTP transactions that match this entry. This object is read-only. A value is created by the agent from an unused AppLocalIndex value when this apmHttpFilterEntry is created.')
apmHttpFilterServerProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterServerProtocol.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterServerProtocol.setDescription('The protocolDirLocalIndex value of the network level protocol of the apmHttpFilterServerAddress.')
apmHttpFilterServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 4), ProtocolDirNetworkAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterServerAddress.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterServerAddress.setDescription("This entry will only represent transactions coming from the network address specified in this object. This is represented as an octet string with specific semantics and length as identified by the associated apmHttpFilterServerProtocol object. If this object is the zero-length string, then this entry will match one of the addresses represented by the 'host' component of the associated apmHttpFilterURLPath object, where the format if a URL [9] is http://<host>:<port>/<path>?<searchpart>.")
apmHttpFilterURLPath = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterURLPath.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterURLPath.setDescription('This entry will only represent HTTP transactions where the URL path component in the request matches this value. This value represents the requested path regardless of any substitution that the server might perform. Prior to the matching, the URL is stripped of any server address or DNS name and consists solely of the path name on that server. If the length of this object is zero, then this entry will match if the associated apmHttpFilterServerAddress match. If the length of that object is also zero, then this entry will match nothing. The value of the associated apmHttpFilterMatchType dictates the type of matching that will be attempted.')
apmHttpFilterMatchType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exact", 1), ("stripTrailingSlash", 2), ("prefix", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterMatchType.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterMatchType.setDescription("The matching algorithm used to compare the URL pathname. If the value is exact(1), then the pathname component will be compared with the associated apmHttpFilterURLPath and will only be associated with this entry if it matches exactly. If the value is stripTrailingSlash(2), then the pathname component will be compared with the associated apmHttpFilterURLPath and will only be associated with this entry if it matches exactly or if the pathname ends with a '/' symbol and matches apmHttpFilterURLPath if the '/' symbol is removed from the pathname. This option exists for those paths where an optional trailing slash is possible but for which a prefix match would be too broad. If the value is prefix(3), then the pathname component will be compared with the associated apmHttpFilterURLPath and will only be associated with this entry if the beginning of the pathname matches every octet of this value. Octets that extend beyond the length of this value are ignored.")
apmHttpFilterOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterOwner.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
apmHttpFilterStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 8), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterStorageType.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterStorageType.setDescription("The storage type of this apmHttpFilterEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
apmHttpFilterRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 4, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmHttpFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: apmHttpFilterRowStatus.setDescription("The status of this apmHttpFilterEntry. No objects in this row may be modified while the row's status is 'active'.")
apmHttpIgnoreUnregisteredURLs = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmHttpIgnoreUnregisteredURLs.setStatus('current')
if mibBuilder.loadTexts: apmHttpIgnoreUnregisteredURLs.setDescription('When true, APM measurements of HTTP transactions will only measure transactions relating to URLs that match a filter in the apmHttpFilterTable. Thus, measurements for the HTTP application will present aggregated statistics for URL-matching HTTP transactions and measurements for the HTTP GET application verb will present aggregated statistics for URL-matching HTTP GET transactions. This will be used in environments that wish to monitor only targeted URLs and to ignore large volumes of internet web browsing traffic. This object affects all APM reports and exceptions generated by this agent. Accordingly, modification of this object should be performed by a manager acting in the role of administrator. In particular, management software should not require or enforce particular configuration of this object - it should reflect the preferences of the site administrator, not the software author. The value of this object must persist across reboots.')
apmHttp4xxIsFailure = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmHttp4xxIsFailure.setStatus('current')
if mibBuilder.loadTexts: apmHttp4xxIsFailure.setDescription("When true, this agent will recognize HTTP errors in the range of 400 through 499 and will treat them as unavailable transactions. When false or when this object isn't supported, they will be treated as successful transactions. This object allows such error pages to be tracked at the possible expense of having user typos treated as poor service on the part of the web server. This object affects all reports and exceptions generated by this agent. Accordingly, modification of this object should be performed by a manager acting in the role of administrator. In particular, management software should not require or enforce particular configuration of this object - it should reflect the preferences of the site administrator, not the software author. The value of this object must persist across reboots.")
apmUserDefinedAppTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 7), )
if mibBuilder.loadTexts: apmUserDefinedAppTable.setStatus('current')
if mibBuilder.loadTexts: apmUserDefinedAppTable.setDescription('A table that advertises user-defined applications that the agent is measuring. The agent will automatically create one or more entries in the apmAppDirTable (one for each responsivenessType it is capable of measuring) for each entry in this table. Note that when entries exist in this table some transactions can be summarized more than once if there is overlap between applications defined here and applications defined in the protocol directory or in the httpFilter table.')
apmUserDefinedAppEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 7, 1), ).setIndexNames((0, "APM-MIB", "apmAppDirAppLocalIndex"))
if mibBuilder.loadTexts: apmUserDefinedAppEntry.setStatus('current')
if mibBuilder.loadTexts: apmUserDefinedAppEntry.setDescription('A user-defined application that the agent is measuring, along with its AppLocalIndex assignment. The apmAppDirAppLocalIndex value in the index identifies the agent-assigned AppLocalIndex value for this user-defined application.')
apmUserDefinedAppParentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmUserDefinedAppParentIndex.setStatus('current')
if mibBuilder.loadTexts: apmUserDefinedAppParentIndex.setDescription('The protocolDirLocalIndex value of the highest-layer protocol defined in the protocolDirTable that this application is a child of.')
apmUserDefinedAppApplication = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 7, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmUserDefinedAppApplication.setStatus('current')
if mibBuilder.loadTexts: apmUserDefinedAppApplication.setDescription('A human readable descriptive tag for this application.')
apmNameTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 8), )
if mibBuilder.loadTexts: apmNameTable.setStatus('current')
if mibBuilder.loadTexts: apmNameTable.setDescription("A client machine may have multiple addresses during a period of monitoring. The apmNameTable assigns a long-lived identifier to a client and records what addresses were assigned to that client for periods of time. Various implementation techniques exist for tracking this mapping but if an agent is unable to track client address mappings, it may map client identifiers to client addresses rather than to distinct client machines. A particular apmNameClientID should be a constant attribute of a particular client. When available, the agent may also record the machine name and/or user name which may be valuable for displaying to humans. The apmNameMachineName and apmNameUserName are relatively constant, changing only if these attributes actually change on the client. The agent will store a historical log of these entries, aging out old entries as the log becomes too large. Since this table contains information vital to the interpretation of other tables (e.g., the apmReportTable), the agent should ensure that the log doesn't age out entries that would be referenced by data in those tables. Note that an entry for a clientID is active from its StartTime until the StartTime of another entry (for the same clientID) that supersedes it, or 'now' if none supersede it. Therefore, if a clientID only has a single entry, it is by definition very new and should never be aged out. No entry for a clientID should be aged out unless it has been updated by a new entry for the client (i.e., with an updated address) and only if the new entry is 'old' enough. To determine how old is old enough, compute the maximum value of Interval * (NumReports + 1) of all entries in the apmReportControlTable (the '+ 1' is to allow a reasonable period of time for the report to be downloaded). Then take the larger of this value and the age in seconds of the oldest entry in the current transaction table. If an entry for a clientID is superseded by another entry whose StartTime is more than this many seconds ago, then the older entry may be deleted.")
apmNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1), ).setIndexNames((0, "APM-MIB", "apmNameClientID"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "APM-MIB", "apmNameClientAddress"), (0, "APM-MIB", "apmNameMappingStartTime"))
if mibBuilder.loadTexts: apmNameEntry.setStatus('current')
if mibBuilder.loadTexts: apmNameEntry.setDescription('An entry in the APM name table. An entry exists for each period of time that a client has been associated with a particular address. The protocolDirLocalIndex value in the index identifies the network layer protocol for the ClientAddress for this entry. Note that some combinations of index values may result in an index that exceeds 128 sub-identifiers in length which exceeds the maximum for the SNMP protocol. Implementations should take care to avoid such combinations.')
apmNameClientID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1, 1), RmonClientID())
if mibBuilder.loadTexts: apmNameClientID.setStatus('current')
if mibBuilder.loadTexts: apmNameClientID.setDescription('A unique ID assigned to the machine represented by this mapping. This ID is assigned by the agent using an implementation-specific algorithm.')
apmNameClientAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1, 2), ProtocolDirNetworkAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 255)))
if mibBuilder.loadTexts: apmNameClientAddress.setStatus('current')
if mibBuilder.loadTexts: apmNameClientAddress.setDescription("The network client address for this client when this mapping was active. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. This object may not be the zero length string. Since this object is an index variable, it is encoded in the index according to the index encoding rules. For example, if the protocolDirLocalIndex component of the index indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order. Care should be taken to avoid values of this object that, in conjunction with the other index variables, would result in an index longer than SNMP's maximum of 128 subidentifiers.")
apmNameMappingStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1, 3), DateAndTime())
if mibBuilder.loadTexts: apmNameMappingStartTime.setStatus('current')
if mibBuilder.loadTexts: apmNameMappingStartTime.setDescription('The time that the agent first discovered this mapping as active.')
apmNameMachineName = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmNameMachineName.setStatus('current')
if mibBuilder.loadTexts: apmNameMachineName.setDescription('The human readable name of the client machine. If the client has no machine name or the agent is unable to learn the machine name, this object will be a zero-length string.')
apmNameUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 8, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmNameUserName.setStatus('current')
if mibBuilder.loadTexts: apmNameUserName.setDescription("The human readable name of a human user using the client machine. If more than one user name are available simultaneously, it is an implementation-dependent matter as to which is used here. However, if the user name changes, this object should change to reflect that change. Non-human user names like 'root' or 'administrator' aren't intended as values for this object. If the client has no recorded user name or the agent is unable to learn a user name, this object will be a zero-length string.")
apmReportControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 9), )
if mibBuilder.loadTexts: apmReportControlTable.setStatus('current')
if mibBuilder.loadTexts: apmReportControlTable.setDescription('Parameters that control the creation of a set of reports that aggregate application performance.')
apmReportControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1), ).setIndexNames((0, "APM-MIB", "apmReportControlIndex"))
if mibBuilder.loadTexts: apmReportControlEntry.setStatus('current')
if mibBuilder.loadTexts: apmReportControlEntry.setDescription('A conceptual row in the apmReportControlTable. An example of the indexing of this table is apmReportControlInterval.3')
apmReportControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: apmReportControlIndex.setStatus('current')
if mibBuilder.loadTexts: apmReportControlIndex.setDescription('An index that uniquely identifies an entry in the apmReportControlTable. Each such entry defines a unique report whose results are placed in the apmReportTable on behalf of this apmReportControlEntry.')
apmReportControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 2), DataSourceOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlDataSource.setStatus('current')
if mibBuilder.loadTexts: apmReportControlDataSource.setDescription("The source of the data for APM Reports generated on behalf of this apmReportControlEntry. If the measurement is being performed by a probe, this should be set to interface or port where data was received for analysis. If the measurement isn't being performed by a probe, this should be set to the primary interface over which the measurement is being performed. If the measurement isn't being performed by a probe and there is no primary interface or this information isn't known, this object should be set to 0.0. This object may not be modified if the associated apmReportControlStatus object is equal to active(1).")
apmReportControlAggregationType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 3), TransactionAggregationType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlAggregationType.setStatus('current')
if mibBuilder.loadTexts: apmReportControlAggregationType.setDescription('The type of aggregation being performed for this set of reports. The metrics for a single transaction are the responsiveness of the transaction and whether the transaction succeeded (a boolean). When such metrics are aggregated in this MIB Module, these metrics are replaced by averages and distributions of responsiveness and availability. The metrics describing aggregates are constant no matter which type of aggregation is being performed. These metrics may be found in the apmReportTable. The flows(1) aggregation is the simplest. All transactions that share common application/server/client 3-tuples are aggregated together, resulting in a set of metrics for all such unique 3-tuples. The clients(2) aggregation results in somewhat more aggregation (i.e., fewer resulting records). All transactions that share common application/client tuples are aggregated together, resulting in a set of metrics for all such unique tuples. The servers(3) aggregation usually results in still more aggregation (i.e., fewer resulting records). All transactions that share common application/server tuples are aggregated together, resulting in a set of metrics for all such unique tuples. The applications(4) aggregation results in the most aggregation (i.e., the fewest resulting records). All transactions that share a common application are aggregated together, resulting in a set of metrics for all such unique applications. Note that it is not meaningful to aggregate applications, as different applications have widely varying characteristics. As a result, this set of aggregations is complete. This object may not be modified if the associated apmReportControlStatus object is equal to active(1).')
apmReportControlInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 4), Unsigned32().clone(3600)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlInterval.setStatus('current')
if mibBuilder.loadTexts: apmReportControlInterval.setDescription("The interval in seconds over which data is accumulated before being aggregated into a report in the apmReportTable. All reports with the same apmReportControlIndex will be based on the same interval. This object must be greater than zero. Many users desire that these reports be synchronized to within seconds of the beginning of the hour because the results may be correlated more meaningfully to business behavior and so that data from multiple agents is aggregated over the same time periods. Thus management software may take extra effort to synchronize reports to the beginning of the hour and to one another. However, the agent must not allow reports to 'drift' over time as they will quickly become unsynchronized. In particular, if there is any fixed processing delay between reports, the reports should deduct this time from the interval so that reports don't drift. This object may not be modified if the associated apmReportControlStatus object is equal to active(1).")
apmReportControlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlRequestedSize.setStatus('current')
if mibBuilder.loadTexts: apmReportControlRequestedSize.setDescription('The number of entries requested to be allocated for each report generated on behalf of this entry.')
apmReportControlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlGrantedSize.setStatus('current')
if mibBuilder.loadTexts: apmReportControlGrantedSize.setDescription("The number of entries per report the agent has allocated based on the requested amount in apmReportControlRequestedSize. Since multiple reports are saved, the total number of entries allocated will be this number multiplied by the value of apmReportControlGrantedReports, or 1 if that object doesn't exist. When the associated apmReportControlRequestedSize object is created or modified, the agent should set this object as closely to the requested value as is possible for the particular implementation and available resources. When considering resources available, the agent must consider its ability to allocate this many entries for all reports. Note that while the actual number of entries stored in the reports may fluctuate due to changing conditions, the agent must continue to have storage available to satisfy the full report size for all reports when necessary. Further, the agent must not lower this value except as a result of a set to the associated apmReportControlRequestedSize object.")
apmReportControlRequestedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlRequestedReports.setStatus('current')
if mibBuilder.loadTexts: apmReportControlRequestedReports.setDescription('The number of saved reports requested to be allocated on behalf of this entry.')
apmReportControlGrantedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlGrantedReports.setStatus('current')
if mibBuilder.loadTexts: apmReportControlGrantedReports.setDescription("The number of saved reports the agent has allocated based on the requested amount in apmReportControlRequestedReports. Since each report can have many entries, the total number of entries allocated will be this number multiplied by the value of apmReportControlGrantedSize, or 1 if that object doesn't exist. When the associated apmReportControlRequestedReports object is created or modified, the agent should set this object as closely to the requested value as is possible for the particular implementation and available resources. When considering resources available, the agent must consider its ability to allocate this many reports each with the number of entries represented by apmReportControlGrantedSize, or 1 if that object doesn't exist. Note that while the storage required for each report may fluctuate due to changing conditions, the agent must continue to have storage available to satisfy the full report size for all reports when necessary. Further, the agent must not lower this value except as a result of a set to the associated apmReportControlRequestedSize object.")
apmReportControlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlStartTime.setStatus('current')
if mibBuilder.loadTexts: apmReportControlStartTime.setDescription('The value of sysUpTime when the system began processing the report in progress. Note that the report in progress is not available. This object may be used by the management station to figure out the start time for all previous reports saved for this apmReportControlEntry, as reports are started at fixed intervals.')
apmReportControlReportNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlReportNumber.setStatus('current')
if mibBuilder.loadTexts: apmReportControlReportNumber.setDescription('The number of the report in progress. When an apmReportControlEntry is activated, the first report will be numbered one.')
apmReportControlDeniedInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlDeniedInserts.setStatus('current')
if mibBuilder.loadTexts: apmReportControlDeniedInserts.setDescription("The number of failed attempts to add an entry to reports for this apmReportControlEntry because the number of entries would have exceeded apmReportControlGrantedSize. This number is valuable in determining if enough entries have been allocated for reports in light of fluctuating network usage. Note that since an entry that is denied will often be attempted again, this number will not predict the exact number of additional entries needed, but can be used to understand the relative magnitude of the problem. Also note that there is no ordering specified for the entries in the report, thus there are no rules for which entries will be omitted when not enough entries are available. As a consequence, the agent is not required to delete 'least valuable' entries first.")
apmReportControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportControlDroppedFrames.setStatus('current')
if mibBuilder.loadTexts: apmReportControlDroppedFrames.setDescription('The total number of frames which were received by the agent and therefore not accounted for in the *StatsDropEvents, but for which the agent chose not to count for this entry for whatever reason. Most often, this event occurs when the agent is out of some resources and decides to shed load from this collection. This count does not include packets that were not counted because they had MAC-layer errors. This counter is only relevant if this apm report is based on a data source whose collection methodology is based on analyzing network traffic. Note that if the apmReportTables are inactive because no applications are enabled in the application directory, this value should be 0. Note that, unlike the dropEvents counter, this number is the exact number of frames dropped.')
apmReportControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 13), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlOwner.setStatus('current')
if mibBuilder.loadTexts: apmReportControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
apmReportControlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 14), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlStorageType.setStatus('current')
if mibBuilder.loadTexts: apmReportControlStorageType.setDescription("The storage type of this apmReportControlEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
apmReportControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 9, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmReportControlStatus.setStatus('current')
if mibBuilder.loadTexts: apmReportControlStatus.setDescription('The status of this apmReportControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. The only objects in the entry that may be modified while the entry is in the active state are apmReportControlRequestedSize and apmReportControlRequestedReports. If this object is not equal to active(1), all associated entries in the apmReportTable shall be deleted by the agent.')
apmReportTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 10), )
if mibBuilder.loadTexts: apmReportTable.setStatus('current')
if mibBuilder.loadTexts: apmReportTable.setDescription('The data resulting from aggregated APM reports. Consult the definition of apmReportControlAggregationType for the definition of the various types of aggregations.')
apmReportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1), ).setIndexNames((0, "APM-MIB", "apmReportControlIndex"), (0, "APM-MIB", "apmReportIndex"), (0, "APM-MIB", "apmAppDirAppLocalIndex"), (0, "APM-MIB", "apmAppDirResponsivenessType"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "APM-MIB", "apmReportServerAddress"), (0, "APM-MIB", "apmNameClientID"))
if mibBuilder.loadTexts: apmReportEntry.setStatus('current')
if mibBuilder.loadTexts: apmReportEntry.setDescription("A conceptual row in the apmReportTable. The apmReportControlIndex value in the index identifies the apmReportControlEntry on whose behalf this entry was created. The apmReportIndex value in the index identifies which report (in the series of reports) this entry is a part of. The apmAppDirAppLocalIndex value in the index identifies the common application of the transactions aggregated in this entry. The apmAppDirResponsivenessType value in the index identifies the type of responsiveness metric reported by this entry and uniquely identifies this entry when more than one responsiveness metric is measured for a flow. Entries will only exist in this table for those combinations of AppLocalIndex and ResponsivenessType that are configured 'on(1)'. The protocolDirLocalIndex value in the index identifies the network layer protocol of the apmReportServerAddress. When the associated apmReportControlAggregationType value is equal to applications(4) or clients(2), this protocolDirLocalIndex value will equal 0. The apmReportServerAddress value in the index identifies the network layer address of the server in transactions aggregated in this entry. The apmNameClientID value in the index identifies the client in transactions aggregated in this entry. If the associated apmReportControlAggregationType is equal to applications(4) or servers(3), then this protocolDirLocalIndex value will equal 0. An example of the indexing of this entry is apmReportTransactionCount.3.15.3.1.8.4.192.168.1.2.3232235788 Note that some combinations of index values may result in an index that exceeds 128 sub-identifiers in length which exceeds the maximum for the SNMP protocol. Implementations should take care to avoid such combinations.")
apmReportIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: apmReportIndex.setStatus('current')
if mibBuilder.loadTexts: apmReportIndex.setDescription('The value of apmReportControlReportNumber for the report to which this entry belongs.')
apmReportServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 2), ProtocolDirNetworkAddress())
if mibBuilder.loadTexts: apmReportServerAddress.setStatus('current')
if mibBuilder.loadTexts: apmReportServerAddress.setDescription("The network server address for this apmReportEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. Since this object is an index variable, it is encoded in the index according to the index encoding rules. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order. Care should be taken to avoid values of this object that, in conjunction with the other index variables, would result in an index longer than SNMP's maximum of 128 subidentifiers. If the associated apmReportControlAggregationType is equal to applications(4) or clients(2), then this object will be a null string and will be encoded simply as a length octet of 0.")
apmReportTransactionCount = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportTransactionCount.setStatus('current')
if mibBuilder.loadTexts: apmReportTransactionCount.setDescription('The total number of transactions aggregated into this record.')
apmReportSuccessfulTransactions = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportSuccessfulTransactions.setStatus('current')
if mibBuilder.loadTexts: apmReportSuccessfulTransactions.setDescription('The total number of successful transactions aggregated into this record.')
apmReportResponsivenessMean = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessMean.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessMean.setDescription('The arithmetic mean of the responsiveness metrics for all successful transactions aggregated into this record.')
apmReportResponsivenessMin = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessMin.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessMin.setDescription('The minimum of the responsiveness metrics for all successful transactions aggregated into this record.')
apmReportResponsivenessMax = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessMax.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessMax.setDescription('The maximum of the responsiveness metrics for all successful transactions aggregated into this record.')
apmReportResponsivenessB1 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB1.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB1.setDescription('The number of successful transactions aggregated into this record whose responsiveness was less than boundary1 value for this application.')
apmReportResponsivenessB2 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB2.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB2.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Bucket 1 and was greater than or equal to the boundary1 value for this application and less than the boundary2 value for this application.')
apmReportResponsivenessB3 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB3.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB3.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Bucket 1 or 2 and as greater than or equal to the boundary2 value for this application and less than the boundary3 value for this application.')
apmReportResponsivenessB4 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB4.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB4.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Buckets 1 through 3 and was greater than or equal to the boundary3 value for this application and less than the boundary4 value for this application.')
apmReportResponsivenessB5 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB5.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB5.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Buckets 1 through 4 and was greater than or equal to the boundary4 value for this application and less than the boundary5 value for this application.')
apmReportResponsivenessB6 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB6.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB6.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Buckets 1 through 5 and was greater than or equal to the boundary5 value for this application and less than the boundary6 value for this application.')
apmReportResponsivenessB7 = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 10, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmReportResponsivenessB7.setStatus('current')
if mibBuilder.loadTexts: apmReportResponsivenessB7.setDescription('The number of successful transactions aggregated into this record whose responsiveness did not fall into Buckets 1 through 6 and was greater than or equal to the boundary6 value for this application.')
apmTransactionTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 11), )
if mibBuilder.loadTexts: apmTransactionTable.setStatus('current')
if mibBuilder.loadTexts: apmTransactionTable.setDescription('This table contains transactions that are currently running or have recently finished.')
apmTransactionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1), ).setIndexNames((0, "APM-MIB", "apmAppDirAppLocalIndex"), (0, "APM-MIB", "apmAppDirResponsivenessType"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "APM-MIB", "apmTransactionServerAddress"), (0, "APM-MIB", "apmNameClientID"), (0, "APM-MIB", "apmTransactionID"))
if mibBuilder.loadTexts: apmTransactionEntry.setStatus('current')
if mibBuilder.loadTexts: apmTransactionEntry.setDescription("A conceptual row in the apmTransactionTable. The apmAppDirAppLocalIndex value in the index identifies the application of the transaction represented by this entry. The apmAppDirResponsivenessType value in the index identifies the type of responsiveness metric reported by this entry and uniquely identifies this entry when more than one responsiveness metric is measured for a flow. Entries will only exist in this table for those combinations of AppLocalIndex and ResponsivenessType that are configured 'on(1)'. The protocolDirLocalIndex value in the index identifies the network layer protocol of the apmTransactionServerAddress. The apmTransactionServerAddress value in the index identifies the network layer address of the server in the transaction represented by this entry. The apmNameClientID value in the index identifies the client in the transaction represented by this entry. An example of the indexing of this entry is apmTransactionCount.3.1.8.4.192.168.1.2.3232235788.2987 Note that some combinations of index values may result in an index that exceeds 128 sub-identifiers in length which exceeds the maximum for the SNMP protocol. Implementations should take care to avoid such combinations.")
apmTransactionServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1, 1), ProtocolDirNetworkAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 255)))
if mibBuilder.loadTexts: apmTransactionServerAddress.setStatus('current')
if mibBuilder.loadTexts: apmTransactionServerAddress.setDescription("The network server address for this apmTransactionEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. This object may not be the zero length string. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order. Care should be taken to avoid values of this object that, in conjunction with the other index variables, would result in an index longer than SNMP's maximum of 128 subidentifiers.")
apmTransactionID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: apmTransactionID.setStatus('current')
if mibBuilder.loadTexts: apmTransactionID.setDescription("A unique value for this transaction amongst other transactions sharing the same application layer protocol and server and client addresses. Implementations may choose to use the value of the client's source port, when possible.")
apmTransactionResponsiveness = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmTransactionResponsiveness.setStatus('current')
if mibBuilder.loadTexts: apmTransactionResponsiveness.setDescription('The current value of the responsiveness metric for this transaction. If this transaction has completed, the final value of the metric will be available. Note that this value may change over the lifetime of the transaction and it is the final value of this metric that is recorded as the responsiveness of the transaction for use in other APM MIB functions.')
apmTransactionAge = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmTransactionAge.setStatus('current')
if mibBuilder.loadTexts: apmTransactionAge.setDescription('If this transaction is still executing, this value shall be the length of time since it was started. If it has completed, this value shall be the length of time it was executing.')
apmTransactionSuccess = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 11, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmTransactionSuccess.setStatus('current')
if mibBuilder.loadTexts: apmTransactionSuccess.setDescription('The success of this transaction up to this time. Once a transaction has been marked as failed, it cannot move back into the successful state.')
apmTransactionsRequestedHistorySize = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmTransactionsRequestedHistorySize.setStatus('current')
if mibBuilder.loadTexts: apmTransactionsRequestedHistorySize.setDescription("The maximum number of completed transactions desired to be retained in the apmTransactionTable. If the agent doesn't have enough resources to retain this many, it will retain as many as possible. Regardless of this value, the agent must attempt to keep records for all current transactions it is monitoring. The value of this object must persist across reboots.")
apmExceptionTable = MibTable((1, 3, 6, 1, 2, 1, 16, 23, 1, 13), )
if mibBuilder.loadTexts: apmExceptionTable.setStatus('current')
if mibBuilder.loadTexts: apmExceptionTable.setDescription('This table creates filters so that a management station can get immediate notification of a transaction that has had poor availability or responsiveness. Each apmExceptionEntry is associated with a particular type of transaction and is applied to all transactions of that type. Multiple apmExceptionEntries may be associated with a particular type of transaction. A transaction type is identified by the value of the apmAppDirAppLocalIndex component of the index. Because the quality of a transaction is not known until it is completed, these thresholds are only applied after the transaction has completed.')
apmExceptionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1), ).setIndexNames((0, "APM-MIB", "apmAppDirAppLocalIndex"), (0, "APM-MIB", "apmAppDirResponsivenessType"), (0, "APM-MIB", "apmExceptionIndex"))
if mibBuilder.loadTexts: apmExceptionEntry.setStatus('current')
if mibBuilder.loadTexts: apmExceptionEntry.setDescription('A conceptual row in the apmExceptionTable. The apmAppDirAppLocalIndex value in the index identifies the application this entry will monitor. The apmAppDirResponsivenessType value in the index identifies the type of responsiveness metric this entry will monitor.')
apmExceptionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: apmExceptionIndex.setStatus('current')
if mibBuilder.loadTexts: apmExceptionIndex.setDescription('An index that uniquely identifies an entry in the apmExceptionTable amongst other entries with equivalent index values for apmAppDirAppLocalIndex and apmAppDirResponsivenessType. Each such entry sets up thresholds for a particular measurement of a particular application.')
apmExceptionResponsivenessComparison = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("greater", 2), ("less", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionResponsivenessComparison.setStatus('current')
if mibBuilder.loadTexts: apmExceptionResponsivenessComparison.setDescription('If this value is greater(2) or less(3), the associated apmExceptionResponsivenessThreshold will be compared to this value and an exception will be created if the responsiveness is greater than the threshold (greater(2)) or less than the threshold (less(3)).')
apmExceptionResponsivenessThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionResponsivenessThreshold.setStatus('current')
if mibBuilder.loadTexts: apmExceptionResponsivenessThreshold.setDescription('The threshold that responsiveness metrics are compared to.')
apmExceptionUnsuccessfulException = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionUnsuccessfulException.setStatus('current')
if mibBuilder.loadTexts: apmExceptionUnsuccessfulException.setDescription('If this value is on(2), an exception will be created if a transaction of the associated type is unsuccessful.')
apmExceptionResponsivenessEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmExceptionResponsivenessEvents.setStatus('current')
if mibBuilder.loadTexts: apmExceptionResponsivenessEvents.setDescription('The total number of responsiveness exceptions generated. This counter will be incremented even if no notification was sent due to notifications not being configured or due to exceeding the apmNotificationMaxRate value.')
apmExceptionUnsuccessfulEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apmExceptionUnsuccessfulEvents.setStatus('current')
if mibBuilder.loadTexts: apmExceptionUnsuccessfulEvents.setDescription('The total number of unsuccessful exceptions generated. This counter will be incremented even if no notification was sent due to notifications not being configured or due to exceeding the apmNotificationMaxRate value.')
apmExceptionOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionOwner.setStatus('current')
if mibBuilder.loadTexts: apmExceptionOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
apmExceptionStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 8), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionStorageType.setStatus('current')
if mibBuilder.loadTexts: apmExceptionStorageType.setDescription("The storage type of this apmReportControlEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
apmExceptionStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 23, 1, 13, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apmExceptionStatus.setStatus('current')
if mibBuilder.loadTexts: apmExceptionStatus.setDescription('The status of this apmExceptionEntry. The only objects in the entry that may be modified while the entry is in the active state are apmExceptionResponsivenessComparison, apmExceptionResponsivenessThreshold and apmExceptionUnsuccessfulException.')
apmThroughputExceptionMinTime = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 14), Unsigned32().clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmThroughputExceptionMinTime.setStatus('current')
if mibBuilder.loadTexts: apmThroughputExceptionMinTime.setDescription("Because the responsiveness for throughput-oriented transactions is divided by the elapsed time, it can be very sensitive to short-term performance variations for transactions that take a short period of time. For example, when downloading a very short file, a single dropped packet could double or triple the total response time. Further, throughput is usually examined for applications that transfer a lot of data, and when doing so it is helpful to conceptualize transaction costs that are proportional to the amount of data separately from those costs that are relatively fixed (i.e., independent of the amount of data). For very short transactions, these fixed transaction costs (handshake, setup time, authentication, round-trip time) may dominate the total response time for the transaction, resulting in throughput measurements that aren't really proportional to the network's, server's and client's combined data throughput capability. This object controls the minimum number of seconds that an throughput-based transaction must exceed before an exception can be generated for it. If this object is set to zero, then all throughput-based transactions are candidates for exceptions. The value of this object must persist across reboots.")
apmNotificationMaxRate = MibScalar((1, 3, 6, 1, 2, 1, 16, 23, 1, 15), Unsigned32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apmNotificationMaxRate.setStatus('current')
if mibBuilder.loadTexts: apmNotificationMaxRate.setDescription('The maximum number of notifications that can be generated from this agent by the apmExceptionTable in any 60 second period. The value of this object must persist across reboots.')
apmNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 23, 0))
apmTransactionResponsivenessAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16, 23, 0, 1)).setObjects(("APM-MIB", "apmExceptionResponsivenessThreshold"), ("APM-MIB", "apmTransactionResponsiveness"))
if mibBuilder.loadTexts: apmTransactionResponsivenessAlarm.setStatus('current')
if mibBuilder.loadTexts: apmTransactionResponsivenessAlarm.setDescription('Notification sent when a transaction exceeds a threshold defined in the apmException table. The index of the included apmExceptionResponsivenessThreshold object identifies the apmExceptionEntry that specified the threshold. The apmTransactionResponsiveness variable identifies the actual transaction and its responsiveness. Agent implementors are urged to include additional data objects in the alarm that may explain the reason for the alarm. It is helpful to include such data in the alarm because it describes the situation at the time the alarm was generated, where polls after the fact may not provide meaningful information. Examples of such information are CPU load, memory utilization, network utilization, and transaction statistics.')
apmTransactionUnsuccessfulAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16, 23, 0, 2)).setObjects(("APM-MIB", "apmExceptionResponsivenessThreshold"))
if mibBuilder.loadTexts: apmTransactionUnsuccessfulAlarm.setStatus('current')
if mibBuilder.loadTexts: apmTransactionUnsuccessfulAlarm.setDescription('Notification sent when a transaction is unsuccessful. The index of the included apmExceptionResponsivenessThreshold object identifies both the type of the transaction that caused this notification as well as the apmExceptionEntry that specified the threshold. Agent implementors are urged to include additional data objects in the alarm that may explain the reason for the alarm. It is helpful to include such data in the alarm because it describes the situation at the time the alarm was generated, where polls after the fact may not provide meaningful information. Examples of such information are CPU load, memory utilization, network utilization, and transaction statistics.')
apmCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 23, 2, 1, 1)).setObjects(("APM-MIB", "apmAppDirGroup"), ("APM-MIB", "apmReportGroup"), ("APM-MIB", "apmUserDefinedApplicationsGroup"), ("APM-MIB", "apmTransactionGroup"), ("APM-MIB", "apmExceptionGroup"), ("APM-MIB", "apmNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmCompliance = apmCompliance.setStatus('current')
if mibBuilder.loadTexts: apmCompliance.setDescription('Describes the requirements for conformance to the APM MIB')
apmAppDirGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 1)).setObjects(("APM-MIB", "apmAppDirConfig"), ("APM-MIB", "apmAppDirResponsivenessBoundary1"), ("APM-MIB", "apmAppDirResponsivenessBoundary2"), ("APM-MIB", "apmAppDirResponsivenessBoundary3"), ("APM-MIB", "apmAppDirResponsivenessBoundary4"), ("APM-MIB", "apmAppDirResponsivenessBoundary5"), ("APM-MIB", "apmAppDirResponsivenessBoundary6"), ("APM-MIB", "apmBucketBoundaryLastChange"), ("APM-MIB", "apmAppDirID"), ("APM-MIB", "apmNameMachineName"), ("APM-MIB", "apmNameUserName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmAppDirGroup = apmAppDirGroup.setStatus('current')
if mibBuilder.loadTexts: apmAppDirGroup.setDescription('The APM MIB directory of applications and application verbs.')
apmUserDefinedApplicationsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 2)).setObjects(("APM-MIB", "apmHttpFilterAppLocalIndex"), ("APM-MIB", "apmHttpFilterServerProtocol"), ("APM-MIB", "apmHttpFilterServerAddress"), ("APM-MIB", "apmHttpFilterURLPath"), ("APM-MIB", "apmHttpFilterMatchType"), ("APM-MIB", "apmHttpFilterOwner"), ("APM-MIB", "apmHttpFilterStorageType"), ("APM-MIB", "apmHttpFilterRowStatus"), ("APM-MIB", "apmHttpIgnoreUnregisteredURLs"), ("APM-MIB", "apmHttp4xxIsFailure"), ("APM-MIB", "apmUserDefinedAppParentIndex"), ("APM-MIB", "apmUserDefinedAppApplication"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmUserDefinedApplicationsGroup = apmUserDefinedApplicationsGroup.setStatus('current')
if mibBuilder.loadTexts: apmUserDefinedApplicationsGroup.setDescription('Objects used for creating and managing user-defined applications.')
apmReportGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 3)).setObjects(("APM-MIB", "apmReportControlDataSource"), ("APM-MIB", "apmReportControlAggregationType"), ("APM-MIB", "apmReportControlInterval"), ("APM-MIB", "apmReportControlRequestedSize"), ("APM-MIB", "apmReportControlGrantedSize"), ("APM-MIB", "apmReportControlRequestedReports"), ("APM-MIB", "apmReportControlGrantedReports"), ("APM-MIB", "apmReportControlStartTime"), ("APM-MIB", "apmReportControlReportNumber"), ("APM-MIB", "apmReportControlDeniedInserts"), ("APM-MIB", "apmReportControlDroppedFrames"), ("APM-MIB", "apmReportControlOwner"), ("APM-MIB", "apmReportControlStorageType"), ("APM-MIB", "apmReportControlStatus"), ("APM-MIB", "apmReportTransactionCount"), ("APM-MIB", "apmReportSuccessfulTransactions"), ("APM-MIB", "apmReportResponsivenessMean"), ("APM-MIB", "apmReportResponsivenessMin"), ("APM-MIB", "apmReportResponsivenessMax"), ("APM-MIB", "apmReportResponsivenessB1"), ("APM-MIB", "apmReportResponsivenessB2"), ("APM-MIB", "apmReportResponsivenessB3"), ("APM-MIB", "apmReportResponsivenessB4"), ("APM-MIB", "apmReportResponsivenessB5"), ("APM-MIB", "apmReportResponsivenessB6"), ("APM-MIB", "apmReportResponsivenessB7"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmReportGroup = apmReportGroup.setStatus('current')
if mibBuilder.loadTexts: apmReportGroup.setDescription('The apm report group controls the creation and retrieval of reports that aggregate application performance.')
apmTransactionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 4)).setObjects(("APM-MIB", "apmTransactionResponsiveness"), ("APM-MIB", "apmTransactionAge"), ("APM-MIB", "apmTransactionSuccess"), ("APM-MIB", "apmTransactionsRequestedHistorySize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmTransactionGroup = apmTransactionGroup.setStatus('current')
if mibBuilder.loadTexts: apmTransactionGroup.setDescription('The apm transaction group contains statistics for individual transactions.')
apmExceptionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 5)).setObjects(("APM-MIB", "apmExceptionResponsivenessComparison"), ("APM-MIB", "apmExceptionResponsivenessThreshold"), ("APM-MIB", "apmExceptionUnsuccessfulException"), ("APM-MIB", "apmExceptionResponsivenessEvents"), ("APM-MIB", "apmExceptionUnsuccessfulEvents"), ("APM-MIB", "apmExceptionOwner"), ("APM-MIB", "apmExceptionStorageType"), ("APM-MIB", "apmExceptionStatus"), ("APM-MIB", "apmThroughputExceptionMinTime"), ("APM-MIB", "apmNotificationMaxRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmExceptionGroup = apmExceptionGroup.setStatus('current')
if mibBuilder.loadTexts: apmExceptionGroup.setDescription('The apm exception group causes notifications to be sent whenever transactions are detected that had poor availability or responsiveness.')
apmNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 16, 23, 2, 2, 6)).setObjects(("APM-MIB", "apmTransactionResponsivenessAlarm"), ("APM-MIB", "apmTransactionUnsuccessfulAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apmNotificationGroup = apmNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: apmNotificationGroup.setDescription('Notifications sent by an APM MIB agent.')
mibBuilder.exportSymbols("APM-MIB", apmExceptionIndex=apmExceptionIndex, apmAppDirConfig=apmAppDirConfig, apmHttpFilterOwner=apmHttpFilterOwner, apmReportResponsivenessB7=apmReportResponsivenessB7, apmGroups=apmGroups, apmUserDefinedAppParentIndex=apmUserDefinedAppParentIndex, apmNameClientID=apmNameClientID, apmUserDefinedAppTable=apmUserDefinedAppTable, apmReportControlRequestedReports=apmReportControlRequestedReports, apmConformance=apmConformance, apmNameUserName=apmNameUserName, apmReportControlOwner=apmReportControlOwner, apmExceptionResponsivenessThreshold=apmExceptionResponsivenessThreshold, apmExceptionResponsivenessComparison=apmExceptionResponsivenessComparison, PYSNMP_MODULE_ID=apm, apmTransactionEntry=apmTransactionEntry, apmNameMappingStartTime=apmNameMappingStartTime, apmHttpFilterServerProtocol=apmHttpFilterServerProtocol, apmHttpFilterIndex=apmHttpFilterIndex, apmExceptionTable=apmExceptionTable, apmAppDirGroup=apmAppDirGroup, apmAppDirEntry=apmAppDirEntry, apmNotificationMaxRate=apmNotificationMaxRate, apmTransactionAge=apmTransactionAge, apmTransactionGroup=apmTransactionGroup, apmAppDirResponsivenessBoundary5=apmAppDirResponsivenessBoundary5, apmReportResponsivenessB5=apmReportResponsivenessB5, apmTransactionResponsiveness=apmTransactionResponsiveness, apmExceptionOwner=apmExceptionOwner, apmAppDirID=apmAppDirID, apmReportControlTable=apmReportControlTable, apmBucketBoundaryLastChange=apmBucketBoundaryLastChange, apmHttpFilterMatchType=apmHttpFilterMatchType, apmTransactionResponsivenessAlarm=apmTransactionResponsivenessAlarm, apmAppDirResponsivenessBoundary1=apmAppDirResponsivenessBoundary1, apmReportResponsivenessB3=apmReportResponsivenessB3, apmHttpFilterURLPath=apmHttpFilterURLPath, apmUserDefinedApplicationsGroup=apmUserDefinedApplicationsGroup, apmExceptionGroup=apmExceptionGroup, apmUserDefinedAppEntry=apmUserDefinedAppEntry, apmReportGroup=apmReportGroup, apmTransactionsRequestedHistorySize=apmTransactionsRequestedHistorySize, apmReportResponsivenessMax=apmReportResponsivenessMax, apmReportResponsivenessMean=apmReportResponsivenessMean, apmAppDirAppLocalIndex=apmAppDirAppLocalIndex, ProtocolDirNetworkAddress=ProtocolDirNetworkAddress, apmReportResponsivenessB2=apmReportResponsivenessB2, apmHttpFilterRowStatus=apmHttpFilterRowStatus, apmTransactionUnsuccessfulAlarm=apmTransactionUnsuccessfulAlarm, apmHttpIgnoreUnregisteredURLs=apmHttpIgnoreUnregisteredURLs, apmReportControlRequestedSize=apmReportControlRequestedSize, apmReportControlStorageType=apmReportControlStorageType, apmHttpFilterStorageType=apmHttpFilterStorageType, apmReportTable=apmReportTable, apmReportResponsivenessB6=apmReportResponsivenessB6, apmMibObjects=apmMibObjects, apmNameTable=apmNameTable, apmReportControlStartTime=apmReportControlStartTime, apm=apm, TransactionAggregationType=TransactionAggregationType, apmExceptionUnsuccessfulException=apmExceptionUnsuccessfulException, apmCompliances=apmCompliances, apmReportResponsivenessB1=apmReportResponsivenessB1, apmNameMachineName=apmNameMachineName, apmReportControlAggregationType=apmReportControlAggregationType, apmAppDirResponsivenessBoundary2=apmAppDirResponsivenessBoundary2, apmReportControlDeniedInserts=apmReportControlDeniedInserts, apmExceptionEntry=apmExceptionEntry, apmReportControlInterval=apmReportControlInterval, DataSourceOrZero=DataSourceOrZero, AppLocalIndex=AppLocalIndex, apmReportControlEntry=apmReportControlEntry, apmExceptionStorageType=apmExceptionStorageType, apmTransactionID=apmTransactionID, apmUserDefinedAppApplication=apmUserDefinedAppApplication, apmReportIndex=apmReportIndex, apmReportControlGrantedReports=apmReportControlGrantedReports, apmNotifications=apmNotifications, apmExceptionResponsivenessEvents=apmExceptionResponsivenessEvents, apmCompliance=apmCompliance, apmAppDirResponsivenessType=apmAppDirResponsivenessType, apmExceptionUnsuccessfulEvents=apmExceptionUnsuccessfulEvents, apmHttpFilterEntry=apmHttpFilterEntry, apmReportResponsivenessB4=apmReportResponsivenessB4, apmReportTransactionCount=apmReportTransactionCount, apmAppDirResponsivenessBoundary3=apmAppDirResponsivenessBoundary3, apmAppDirResponsivenessBoundary6=apmAppDirResponsivenessBoundary6, apmHttpFilterServerAddress=apmHttpFilterServerAddress, apmReportControlStatus=apmReportControlStatus, apmHttpFilterAppLocalIndex=apmHttpFilterAppLocalIndex, apmAppDirTable=apmAppDirTable, apmReportControlDataSource=apmReportControlDataSource, apmReportResponsivenessMin=apmReportResponsivenessMin, apmReportSuccessfulTransactions=apmReportSuccessfulTransactions, apmExceptionStatus=apmExceptionStatus, apmReportControlReportNumber=apmReportControlReportNumber, RmonClientID=RmonClientID, apmReportServerAddress=apmReportServerAddress, apmTransactionTable=apmTransactionTable, apmTransactionServerAddress=apmTransactionServerAddress, apmTransactionSuccess=apmTransactionSuccess, apmThroughputExceptionMinTime=apmThroughputExceptionMinTime, apmReportControlIndex=apmReportControlIndex, apmNotificationGroup=apmNotificationGroup, apmAppDirResponsivenessBoundary4=apmAppDirResponsivenessBoundary4, apmHttp4xxIsFailure=apmHttp4xxIsFailure, apmReportControlGrantedSize=apmReportControlGrantedSize, apmHttpFilterTable=apmHttpFilterTable, apmReportControlDroppedFrames=apmReportControlDroppedFrames, apmReportEntry=apmReportEntry, apmNameEntry=apmNameEntry, apmNameClientAddress=apmNameClientAddress)

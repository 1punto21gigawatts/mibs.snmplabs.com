#
# PySNMP MIB module NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
NtnDisplayString, ntntechInterfaceModule = mibBuilder.importSymbols("NTNTECH-ROOT-MIB", "NtnDisplayString", "ntntechInterfaceModule")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, NotificationType, Unsigned32, MibIdentifier, ModuleIdentity, ObjectIdentity, Gauge32, Integer32, Bits, iso, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "NotificationType", "Unsigned32", "MibIdentifier", "ModuleIdentity", "ObjectIdentity", "Gauge32", "Integer32", "Bits", "iso", "IpAddress", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ntntechInterfaceModuleConfigurationMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1))
ntntechInterfaceModuleConfigurationMIB.setRevisions(('1902-08-06 11:50', '1902-08-28 10:23', '1902-10-11 09:40', '1902-10-22 02:00', '1903-09-30 10:59', '1904-10-11 09:32', '1904-11-17 10:59',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ntntechInterfaceModuleConfigurationMIB.setRevisionsDescriptions(('Added to the ifCfgPortTable the OID ifCfgPortBkBoneEtherType. VLAN ID max limit changed from 4095 to 4085.', 'New Release - v1.01.00', 'Added fixedadaptive(4) mode to the ifCfgPortAdslPortMode OID.', 'New Release - v1.01.01', 'Added to the comment section of ifCfgPortT1RxTxRate and ifCfgPortE1RxTxRate the newly supported T1/E1 module types - tim1500p12(31), tim1500p24(32), eim2000p12(33), eim2000p24(34)', 'Adjusted copyright and Paradyne references.', 'New release version 1.02.01',))
if mibBuilder.loadTexts: ntntechInterfaceModuleConfigurationMIB.setLastUpdated('0411171059Z')
if mibBuilder.loadTexts: ntntechInterfaceModuleConfigurationMIB.setOrganization('Paradyne Corporation')
if mibBuilder.loadTexts: ntntechInterfaceModuleConfigurationMIB.setContactInfo('Paradyne Corporation 8545 126th Avenue North Largo, FL 33773 phone: +1 (727) 530-2000 email: support@paradyne.com www: http://www.nettonet.com/support/')
if mibBuilder.loadTexts: ntntechInterfaceModuleConfigurationMIB.setDescription("This mib module defines an SNMP API to manage Paradyne Corporation's IPD12000, IPD4000, and Mini/Micro DSLAM interface parameters. The interface types are described below, AMD8000-12 12-Port ADSL Mini DSLAMs With Full Rate and G.lite Operational Modes AAM8000-12 12-Port ADSL Access Multiplexer with Full Rate and G.lite Operational Modes AAM8000-24 24-Port ADSL Access Multiplexer with Full Rate and G.lite Operational Modes EAM2000-12 12-Port E1 Access Multiplexer TAM1500-12 12-Port T1 Access Multiplexer IAM144-12 12-Port IDSL Access Multiplexer SAM1000-12 12-Port SDSL Access Multiplexer SAM2000-12, SAM2000Q-12, and SAM2000G-12 12-Port SDSL Access Multiplexers with CAP, 2B1Q or TC/PAM (G.SHDSL) encoding SAM2000D-12 12-Port SDSL Access Multiplexer W/O voice daughter card, running CAP encoding SAM2000DQ-12 12-Port SDSL Access Multiplexer W/O voice daughter card, running 2B1Q encoding SAM2000V-12, SAM2000QV-12, SAM2000GV-12 12-Port SDSL Access Multiplexers with Voice Capability running CAP, 2B1Q or TC/PAM (G.SHDSL) encoding SIM2000-12 12-Port SDSL Access Multiplexer with CAP, 2B1Q and TC/PAM (G.SHDSL) encoding SIM2000-24 24-Port SDSL Access Multiplexer with CAP, 2B1Q and TC/PAM (G.SHDSL) encoding SMD2000-12, SMD2000Q-12, SMD2000G-12 12-Port SDSL Mini DSLAMs: AC and DC Versions with Cap, 2B1Q and G.SHDSL Line encoding SuD2011_12T, SuD2011_12E, SuD2003_12T, SuD2003_12E 12-Port SDSL Micro DSLAMs: Cap, 2B1Q and G.SHDSL Line encoding SuD2011_6T, SuD2011_6E, SuD2002_6T, SuD2002_6E 6-Port SDSL Micro DSLAMs: Cap, 2B1Q and G.SHDSL Line encoding ")
ifModCfgMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1))
ifModCfgParameterConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1))
prmCfgInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 1))
prmCfgInterfacePort = MibIdentifier((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2))
ifCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1), )
if mibBuilder.loadTexts: ifCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortTable.setDescription('A list of IPD12000, IPD4000 Access/Inverse module and Mini/Micro DSLAM entries.')
ifCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgSlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgPortIndex"))
if mibBuilder.loadTexts: ifCfgPortEntry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortEntry.setDescription('An entry containing management information applicable to the IPD12000, IPD4000 Access/Inverse module as well as the Mini/Micro DSLAM.')
ifCfgSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgSlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro DSLAM will have a slot index value of 1.')
ifCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortIndex.setDescription('The physical port number of the interface.')
ifCfgPortCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortCircuitID.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortCircuitID.setDescription('The circuit identification number assigned to a port on an interface.')
ifCfgPortFltrIp1Start = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortFltrIp1Start.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortFltrIp1Start.setDescription('The value assigned to a port which designates the start of the first Ip filter range.')
ifCfgPortFltrIp1End = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortFltrIp1End.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortFltrIp1End.setDescription('The value assigned to a port which designates the end of the first Ip filter range.')
ifCfgPortFltrIp2Start = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortFltrIp2Start.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortFltrIp2Start.setDescription('The value assigned to a port which designates the start of the second Ip filter range.')
ifCfgPortFltrIp2End = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortFltrIp2End.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortFltrIp2End.setDescription('The value assigned to a port which designates the end of the second Ip filter range.')
ifCfgPortBackboneVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4085))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortBackboneVlan.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortBackboneVlan.setDescription('The Backbone VLAN tag will become the primary identifier that can be used by routers with backbone capabilities to direct traffic to the appropriate network cloud.')
ifCfgPortVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortVlanPriority.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortVlanPriority.setDescription('The value assigned to a port which designates the VLAN priority.')
ifCfgPortFloodMde = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uplFlood", 1), ("vlnFlood", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortFloodMde.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortFloodMde.setDescription('The value assigned to a port which designates the flood mode.')
ifCfgPortIpFltProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("protocolALL", 1), ("protocolIP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortIpFltProtocol.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortIpFltProtocol.setDescription('The value assigned to a port which designates the IP filter protocol.')
ifCfgPortReset = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("noReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortReset.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortReset.setDescription('This value is always read as integer value 2. Reset all associated port statistics to zero upon initiation of the reset(1). ')
ifCfgPortBkBoneEthType = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethtype8100", 1), ("ethtype9100", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortBkBoneEthType.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortBkBoneEthType.setDescription('The value assigned to a port which designates the ethernet packet type. ')
ifCfgPortVLANTable = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2), )
if mibBuilder.loadTexts: ifCfgPortVLANTable.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortVLANTable.setDescription('A list of IPD12000, IPD4000 Access/Inverse module and Mini/Micro DSLAM port 802.1Q VLAN entries.')
ifCfgPortVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgIfSlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgIfPortIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgVLANIndex"))
if mibBuilder.loadTexts: ifCfgPortVLANEntry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortVLANEntry.setDescription('An entry containing management information applicable to an IPD12000, IPD4000 Access/Inverse module and Mini/Micro DSLAM port.')
ifCfgIfSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgIfSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgIfSlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgIfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgIfPortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgIfPortIndex.setDescription('The physical port number of the interface.')
ifCfgVLANIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgVLANIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgVLANIndex.setDescription('A pointer to one of ten possible VLAN tags that can be assigned to a port.')
ifCfgVLANIdStart = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4085))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgVLANIdStart.setStatus('current')
if mibBuilder.loadTexts: ifCfgVLANIdStart.setDescription('The value assigned to a port which designates the start of a VLAN ID range.')
ifCfgVLANIdEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4085))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgVLANIdEnd.setStatus('current')
if mibBuilder.loadTexts: ifCfgVLANIdEnd.setDescription('The value assigned to a port which designates the end of a VLAN ID range.')
ifCfgPortAdslTable = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3), )
if mibBuilder.loadTexts: ifCfgPortAdslTable.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslTable.setDescription('A list of ADSL interface entries.')
ifCfgPortAdslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgAdslSlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgAdslPortIndex"))
if mibBuilder.loadTexts: ifCfgPortAdslEntry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslEntry.setDescription('An entry containing management information applicable to ADSL module.')
ifCfgAdslSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgAdslSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgAdslSlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgAdslPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgAdslPortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgAdslPortIndex.setDescription('The physical port number of the ADSL interface.')
ifCfgPortAdslPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("adaptive", 3), ("fixedadaptive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslPortMode.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslPortMode.setDescription("The port mode of operation, ON, OFF, or Adaptive. When a port is set to Adaptive mode, the best possible value for the Rx/Tx data rates will be achieved. A successful data rate connection will be indicated with a port 'linkup' status.")
ifCfgPortAdslVpiVciDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslVpiVciDetect.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslVpiVciDetect.setDescription('ADSL Virtual Path Identifier (VPI) and Virtual Channel Identifier (VCI) detect mode. If this mode is set to ON, auto-detect the line VPI and VCI values.')
ifCfgPortAdslRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslRxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslRxRate.setDescription("ADSL upstream (Rx) data rate. The available upstream data rates range from 32Kbps to 1024Kbps. The upstream data rate can be set by the user via the set value x where x = 1 to 32. The actual data rate that is represented by these set values can be calculated using the following formula, (x * 32Kbps) = upstream data rate, i.e. (3 * 32Kbps) = 96Kbps Note: if an Rx rate value of zero(0) is returned via a GET operation, this would indicate that the port is in 'Adaptive' mode and that the link condition is 'linkdown'.")
ifCfgPortAdslTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 252))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslTxRate.setDescription("ADSL downstream (Tx) data rates. The available downstream data rates range from 32Kbps to 8064Kbps. The downstream data rate can be set by the user via the set value x where x = 1 to 252. The actual data rate that is represented by these set values can be calculated using the following formula, (x * 32Kbps) = downstream data rate, i.e. (252 * 32Kbps) = 8064Kbps Note: if a Tx rate value of zero(0) is returned via a GET operation, this would indicate that the port is in 'Adaptive' mode and that the link condition is 'linkdown'.")
ifCfgPortAdslFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameType1483LLC", 1), ("frameType1483VCM", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslFrameType.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslFrameType.setDescription('ADSL frame type.')
ifCfgPortAdslVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslVpi.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslVpi.setDescription('ADSL Virtual Path Identifier (VPI) value.')
ifCfgPortAdslVci = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslVci.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslVci.setDescription('ADSL Virtual Channel Identifier (VCI).')
ifCfgPortAdslStandardMde = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("t1413", 1), ("gLite", 2), ("gDMT", 3), ("multiMode", 4), ("aLCATEL", 5), ("gDMT-BIS", 6), ("gDMT-BISplus", 7), ("gDMT-BIS-Annex-L", 8), ("gDMT-BIS-Annex-M", 9), ("stdMdeNoLink", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslStandardMde.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslStandardMde.setDescription("ADSL standard modes of operation. Note: if receive a standard mode of integer value 255 (0xFF), this would indicate that the standard mode is unknown due to a port 'linkdown' condition.")
ifCfgPortAdslCorrectionUp = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("corr125us", 1), ("corr250us", 2), ("corr500us", 3), ("corr1ms", 4), ("corr2ms", 5), ("corr4ms", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslCorrectionUp.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslCorrectionUp.setDescription('ADSL Impulse protection duration in the Upstream duration.')
ifCfgPortAdslCorrectionDn = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("corr125us", 1), ("corr250us", 2), ("corr500us", 3), ("corr1ms", 4), ("corr2ms", 5), ("corr4ms", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslCorrectionDn.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslCorrectionDn.setDescription('ADSL Impulse protection duration in the Upstream duration.')
ifCfgPortAdslDelayUp = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("delay1ms", 1), ("delay2ms", 2), ("delay4ms", 3), ("delay8ms", 4), ("delay16ms", 5), ("delay32ms", 6), ("delay64ms", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslDelayUp.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslDelayUp.setDescription('ADSL Impulse protection duration in the Upstream direction.')
ifCfgPortAdslDelayDn = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("delay1ms", 1), ("delay2ms", 2), ("delay4ms", 3), ("delay8ms", 4), ("delay16ms", 5), ("delay32ms", 6), ("delay64ms", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslDelayDn.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslDelayDn.setDescription('ADSL Impulse protection duration in the Upstream direction.')
ifCfgPortAdslEcFdm = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ec", 1), ("fdm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslEcFdm.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslEcFdm.setDescription('ADSL Echo Cancellation uses Upstream Tones for Upstream and Dnstream data.')
ifCfgPortAdslFastBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslFastBuffer.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslFastBuffer.setDescription('Selects fast buffer/low latency. Same is interleave delay of 1ms')
ifCfgPortAdslSnrUp = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslSnrUp.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslSnrUp.setDescription('Selects Target Upstream SNR')
ifCfgPortAdslSnrDn = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortAdslSnrDn.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslSnrDn.setDescription('Selects Target Dnstream SNR')
ifCfgPortAdslActualRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortAdslActualRxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslActualRxRate.setDescription("ADSL upstream (Rx) data rate. The available upstream data rates range from 32Kbps to 1024Kbps. The upstream data rate can be set by the user via the set value x where x = 1 to 64. The actual data rate that is represented by these set values can be calculated using the following formula, (x * 32Kbps) = upstream data rate, i.e. (3 * 32Kbps) = 96Kbps Note: if an Rx rate value of zero(0) is returned via a GET operation, this would indicate that the port is in 'Adaptive' mode and that the link condition is 'linkdown'.")
ifCfgPortAdslActualTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortAdslActualTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslActualTxRate.setDescription("ADSL downstream (Tx) data rates. The available downstream data rates range from 32Kbps to 8064Kbps. The downstream data rate can be set by the user via the set value x where x = 1 to 1024. The actual data rate that is represented by these set values can be calculated using the following formula, (x * 32Kbps) = downstream data rate, i.e. (252 * 32Kbps) = 8064Kbps Note: if a Tx rate value of zero(0) is returned via a GET operation, this would indicate that the port is in 'Adaptive' mode and that the link condition is 'linkdown'.")
ifCfgPortAdslActualStandardMde = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("t1413", 1), ("gLite", 2), ("gDMT", 3), ("multiMode", 4), ("aLCATEL", 5), ("gDMT-BIS", 6), ("gDMT-BISplus", 7), ("gDMT-BIS-Annex-L", 8), ("gDMT-BIS-Annex-M", 9), ("stdMdeNoLink", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortAdslActualStandardMde.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslActualStandardMde.setDescription('ADSL current operating mode, should match ifCfgPortAdslStandardMde UNLESS operating in MULTIMODE')
ifCfgPortAdslActualDepthUp = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortAdslActualDepthUp.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslActualDepthUp.setDescription('ADSL upstream interleving depth.')
ifCfgPortAdslActualDepthDn = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgPortAdslActualDepthDn.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortAdslActualDepthDn.setDescription('ADSL dnstream interleaving depth.')
ifCfgPortIdslTable = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 4), )
if mibBuilder.loadTexts: ifCfgPortIdslTable.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortIdslTable.setDescription('A list of IDSL interface entries.')
ifCfgPortIdslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 4, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgIdslSlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgIdslPortIndex"))
if mibBuilder.loadTexts: ifCfgPortIdslEntry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortIdslEntry.setDescription('An entry containing management information applicable to the IDSL interface.')
ifCfgIdslSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgIdslSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgIdslSlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgIdslPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgIdslPortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgIdslPortIndex.setDescription('The physical port number of the IDSL interface.')
ifCfgPortIdslRxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 255))).clone(namedValues=NamedValues(("idslRxTxRateDefect", 0), ("idslRxTxRate128", 1), ("idslRxTxRate144", 2), ("idslRxTxRateOff", 255)))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortIdslRxTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortIdslRxTxRate.setDescription('IDSL symetrical (Rx/Tx) data rates. IDSL module types and the associated Rx/Tx data rates- IAM144-12: Data Rates (Kbps): 128,144 Note: if a rate value of zero(0) is returned via a GET operation, it will indicate that the port is defective.')
ifCfgPortSdslTable = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5), )
if mibBuilder.loadTexts: ifCfgPortSdslTable.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortSdslTable.setDescription('A list of SDSL interface entries.')
ifCfgPortSdslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgSdslSlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgSdslPortIndex"))
if mibBuilder.loadTexts: ifCfgPortSdslEntry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortSdslEntry.setDescription('An entry containing management information applicable to the SDSL interface.')
ifCfgSdslSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgSdslSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgSdslSlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgSdslPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgSdslPortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgSdslPortIndex.setDescription('The physical port number of the SDSL interface.')
ifCfgPortSdslRxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 255))).clone(namedValues=NamedValues(("sdslRxTxRateDefect", 0), ("sdslRxTxRate144", 1), ("sdslRxTxRate272", 2), ("sdslRxTxRate400", 3), ("sdslRxTxRate528", 4), ("sdslRxTxRate784", 5), ("sdslRxTxRate1040", 6), ("sdslRxTxRate1168", 7), ("sdslRxTxRate1552", 8), ("sdslRxTxRate2064", 9), ("sdslRxTxRate2320", 10), ("sdslRxTxRateOff", 255)))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortSdslRxTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortSdslRxTxRate.setDescription('SDSL symetrical (Rx/Tx) data rates. SDSL module types and the associated Rx/Tx data rates- SAM1000-12: Data Rates (Kbps): 272,528,784,1168 SAM2000-12,SAM2000Q-12,SAM2000G-12,SAM2000D-12,SAM2000DQ-12, SIM2000-24,SuD2011_12T,SuD2011_12E,SuD2003_12T,SuD2003_12E, SuD2011_6T,SuD2011_6E,SuD2002_6T,SuD2002_6E: Data Rates (Kbps): 144,272,400,528,784,1040,1552,2064,2320 SAM2000V-12,SAM2000QV-12,SAM2000GV-12,SIM2000V-12,SIM2000V-24: Data Rates (Kbps): 272,400,528,784,1040,1552,2064,2320 Note: if a rate value of zero(0) is returned via a GET operation, it will indicate that the port is defective.')
ifCfgPortSdslLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lineCodeCap", 1), ("lineCode2B1Q", 2), ("lineCodeGSHDSL", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortSdslLineCode.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortSdslLineCode.setDescription('Line code for the SDSL modules. Note, the line code may be set on the following modules, SIM2000-12,SIM2000-24,SIM2000V-24,SIM2000V-12, or the SDSL micro DSLAM. The line code options are described as follows- CAP: Carrierless Amplitude and Phase modulation 2B1Q: Two Binary, One Quaternary G.SHDSL: Multirate Symmetric Single-pair DSL')
ifCfgPortT1Table = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6), )
if mibBuilder.loadTexts: ifCfgPortT1Table.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1Table.setDescription('A list of T1 interface entries.')
ifCfgPortT1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgT1SlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgT1PortIndex"))
if mibBuilder.loadTexts: ifCfgPortT1Entry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1Entry.setDescription('An entry containing management information applicable to the T1 interface.')
ifCfgT1SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgT1SlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgT1SlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgT1PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgT1PortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgT1PortIndex.setDescription('The physical port number of the T1 interface.')
ifCfgPortT1RxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("t1RxTxRateDefect", 0), ("t1RxTxRate192", 1), ("t1RxTxRate384", 2), ("t1RxTxRate576", 3), ("t1RxTxRate768", 4), ("t1RxTxRate960", 5), ("t1RxTxRate1152", 6), ("t1RxTxRate1344", 7), ("t1RxTxRate1536", 8), ("t1RxTxRateOff", 255)))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortT1RxTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1RxTxRate.setDescription('T1 symetrical (Rx/Tx) data rates. T1 module types and the associated Rx/Tx data rates- TAM1500-12,TIM1500-12,TIM1500-24: Data Rates (Kbps): 192,384,576,768,960,1152,1344,1536 Note: if a rate value of zero(0) is returned via a GET operation, it will indicate that the port is defective.')
ifCfgPortT1FrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1frameTypeESF", 1), ("t1frameTypeSFD4", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortT1FrameType.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1FrameType.setDescription('T1 frame type.')
ifCfgPortT1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1lineCodeB8ZS", 1), ("t1lineCodeAMI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortT1LineCode.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1LineCode.setDescription('T1 line code.')
ifCfgPortT1TxBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t1TxBuildOut0db", 1), ("t1TxBuildOutN7p5db", 2), ("t1TxBuildOutN15db", 3), ("t1TxBuildOutN22db", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortT1TxBuildOut.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1TxBuildOut.setDescription('T1 tx buildout.')
ifCfgPortT1ClockSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1ClockSrcLocal", 1), ("t1ClockSrcLoop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortT1ClockSrc.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortT1ClockSrc.setDescription('T1 clock source.')
ifCfgPortE1Table = MibTable((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7), )
if mibBuilder.loadTexts: ifCfgPortE1Table.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1Table.setDescription('A list of E1 interface entries.')
ifCfgPortE1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1), ).setIndexNames((0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgE1SlotIndex"), (0, "NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", "ifCfgE1PortIndex"))
if mibBuilder.loadTexts: ifCfgPortE1Entry.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1Entry.setDescription('An entry containing management information applicable to the E1 interface.')
ifCfgE1SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgE1SlotIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgE1SlotIndex.setDescription('The physical slot number of the IPD chassis to which the interface module resides. The Mini/Micro slot index will be 1.')
ifCfgE1PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCfgE1PortIndex.setStatus('current')
if mibBuilder.loadTexts: ifCfgE1PortIndex.setDescription('The physical port number of the E1 interface.')
ifCfgPortE1RxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("e1RxTxRateDefect", 0), ("e1RxTxRate256", 1), ("e1RxTxRate512", 2), ("e1RxTxRate768", 3), ("e1RxTxRate1024", 4), ("e1RxTxRate1280", 5), ("e1RxTxRate1536", 6), ("e1RxTxRate1792", 7), ("e1RxTxRate1984", 8), ("e1RxTxRateOff", 255)))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortE1RxTxRate.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1RxTxRate.setDescription('E1 symetrical (Rx/Tx) data rates. E1 module types and the associated Rx/Tx data rates- EAM2000-12,EIM2000-12,EIM2000-24: Data Rates (Kbps): 256,512,768,1024,1280,1536,1792,1984 Note: if a rate value of zero(0) is returned via a GET operation, it will indicate that the port is defective.')
ifCfgPortE1FrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("e1frameTypeCRC", 1), ("e1frameTypeNoCRC", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortE1FrameType.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1FrameType.setDescription('E1 frame type.')
ifCfgPortE1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("e1lineCodeHDB3", 1), ("e1lineCodeAMI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortE1LineCode.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1LineCode.setDescription('E1 line code.')
ifCfgPortE1ClockSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 8059, 1, 2, 1, 1, 1, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("e1ClockSrcLocal", 1), ("e1ClockSrcLoop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifCfgPortE1ClockSrc.setStatus('current')
if mibBuilder.loadTexts: ifCfgPortE1ClockSrc.setDescription('E1 clock source.')
mibBuilder.exportSymbols("NTNTECH-INTERFACE-MODULE-CONFIGURATION-MIB", ifCfgPortSdslLineCode=ifCfgPortSdslLineCode, ifCfgPortAdslVci=ifCfgPortAdslVci, ifCfgPortSdslEntry=ifCfgPortSdslEntry, ifCfgPortE1Table=ifCfgPortE1Table, ifCfgPortAdslRxRate=ifCfgPortAdslRxRate, ifCfgPortIdslRxTxRate=ifCfgPortIdslRxTxRate, ifCfgPortAdslVpiVciDetect=ifCfgPortAdslVpiVciDetect, ifCfgAdslPortIndex=ifCfgAdslPortIndex, ifCfgPortVlanPriority=ifCfgPortVlanPriority, ifCfgPortT1RxTxRate=ifCfgPortT1RxTxRate, ifCfgPortTable=ifCfgPortTable, ifCfgPortAdslFrameType=ifCfgPortAdslFrameType, ifCfgPortT1FrameType=ifCfgPortT1FrameType, ifCfgIfPortIndex=ifCfgIfPortIndex, ifCfgPortAdslActualDepthUp=ifCfgPortAdslActualDepthUp, ifCfgSlotIndex=ifCfgSlotIndex, ifCfgPortIdslEntry=ifCfgPortIdslEntry, ifCfgPortEntry=ifCfgPortEntry, ifCfgVLANIdEnd=ifCfgVLANIdEnd, ifCfgPortE1ClockSrc=ifCfgPortE1ClockSrc, ifCfgPortAdslTable=ifCfgPortAdslTable, ifCfgPortAdslActualRxRate=ifCfgPortAdslActualRxRate, ifCfgT1PortIndex=ifCfgT1PortIndex, ifCfgSdslPortIndex=ifCfgSdslPortIndex, ifCfgIfSlotIndex=ifCfgIfSlotIndex, ifCfgPortIndex=ifCfgPortIndex, prmCfgInterfacePort=prmCfgInterfacePort, ifCfgE1PortIndex=ifCfgE1PortIndex, ifCfgVLANIndex=ifCfgVLANIndex, ifCfgPortAdslPortMode=ifCfgPortAdslPortMode, ifCfgPortT1ClockSrc=ifCfgPortT1ClockSrc, prmCfgInterface=prmCfgInterface, ifCfgPortT1TxBuildOut=ifCfgPortT1TxBuildOut, ifCfgPortAdslStandardMde=ifCfgPortAdslStandardMde, ifCfgPortFltrIp1End=ifCfgPortFltrIp1End, ifCfgIdslSlotIndex=ifCfgIdslSlotIndex, ifCfgPortFltrIp2End=ifCfgPortFltrIp2End, ifCfgSdslSlotIndex=ifCfgSdslSlotIndex, ifCfgPortCircuitID=ifCfgPortCircuitID, ifCfgPortT1Table=ifCfgPortT1Table, ifCfgPortFltrIp2Start=ifCfgPortFltrIp2Start, ifCfgPortVLANEntry=ifCfgPortVLANEntry, ifModCfgMIBObjects=ifModCfgMIBObjects, ifCfgPortAdslDelayDn=ifCfgPortAdslDelayDn, ifCfgPortFltrIp1Start=ifCfgPortFltrIp1Start, ifCfgT1SlotIndex=ifCfgT1SlotIndex, ifModCfgParameterConfiguration=ifModCfgParameterConfiguration, ifCfgPortT1Entry=ifCfgPortT1Entry, ifCfgPortAdslSnrDn=ifCfgPortAdslSnrDn, ifCfgVLANIdStart=ifCfgVLANIdStart, ifCfgPortE1LineCode=ifCfgPortE1LineCode, ifCfgPortBkBoneEthType=ifCfgPortBkBoneEthType, ifCfgPortT1LineCode=ifCfgPortT1LineCode, ifCfgPortBackboneVlan=ifCfgPortBackboneVlan, ifCfgPortAdslTxRate=ifCfgPortAdslTxRate, ifCfgPortAdslCorrectionUp=ifCfgPortAdslCorrectionUp, ifCfgE1SlotIndex=ifCfgE1SlotIndex, ifCfgPortSdslRxTxRate=ifCfgPortSdslRxTxRate, ifCfgPortIpFltProtocol=ifCfgPortIpFltProtocol, ifCfgPortReset=ifCfgPortReset, PYSNMP_MODULE_ID=ntntechInterfaceModuleConfigurationMIB, ntntechInterfaceModuleConfigurationMIB=ntntechInterfaceModuleConfigurationMIB, ifCfgPortAdslCorrectionDn=ifCfgPortAdslCorrectionDn, ifCfgPortAdslActualTxRate=ifCfgPortAdslActualTxRate, ifCfgAdslSlotIndex=ifCfgAdslSlotIndex, ifCfgIdslPortIndex=ifCfgIdslPortIndex, ifCfgPortE1FrameType=ifCfgPortE1FrameType, ifCfgPortAdslSnrUp=ifCfgPortAdslSnrUp, ifCfgPortAdslEntry=ifCfgPortAdslEntry, ifCfgPortIdslTable=ifCfgPortIdslTable, ifCfgPortAdslEcFdm=ifCfgPortAdslEcFdm, ifCfgPortVLANTable=ifCfgPortVLANTable, ifCfgPortAdslFastBuffer=ifCfgPortAdslFastBuffer, ifCfgPortE1Entry=ifCfgPortE1Entry, ifCfgPortFloodMde=ifCfgPortFloodMde, ifCfgPortAdslVpi=ifCfgPortAdslVpi, ifCfgPortE1RxTxRate=ifCfgPortE1RxTxRate, ifCfgPortAdslDelayUp=ifCfgPortAdslDelayUp, ifCfgPortSdslTable=ifCfgPortSdslTable, ifCfgPortAdslActualDepthDn=ifCfgPortAdslActualDepthDn, ifCfgPortAdslActualStandardMde=ifCfgPortAdslActualStandardMde)

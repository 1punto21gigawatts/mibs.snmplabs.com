#
# PySNMP MIB module CPQSCSI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQSCSI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
compaq, cpqHoTrapFlags = mibBuilder.importSymbols("CPQHOST-MIB", "compaq", "cpqHoTrapFlags")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
iso, Counter64, Unsigned32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, IpAddress, Bits, TimeTicks, Counter32, enterprises, Gauge32, MibIdentifier, NotificationType, ObjectIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "Unsigned32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "IpAddress", "Bits", "TimeTicks", "Counter32", "enterprises", "Gauge32", "MibIdentifier", "NotificationType", "ObjectIdentity", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cpqScsi = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5))
cpqScsiMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 1))
cpqScsiComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2))
cpqScsiTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 3))
cpqTapeComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 4))
cpqScsiInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 1))
cpqScsiCntlr = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 2))
cpqScsiLogDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 3))
cpqScsiPhyDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 4))
cpqScsiTarget = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 5))
cpqScsiCd = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 6))
cpqScsiOsNetWare = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1))
cpqScsiOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4))
cpqTapePhyDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 4, 1))
cpqTapeCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 4, 2))
cpqTapeLibrary = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 5, 4, 3))
cpqSbScsiBus = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 7))
cpqSbScsiMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 7, 1))
cpqSbDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 7, 2))
cpqScsiMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiMibRevMajor.setDescription('The Major Revision level. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqScsiMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiMibRevMinor.setDescription('The Minor Revision level. A change in the minor revision level may represent some minor additional support; no changes to any pre-existing information has occurred.')
cpqScsiMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiMibCondition.setDescription('The overall condition. This object represents the overall status of the SCSI system represented by this MIB.')
cpqScsiNw3xDriverName = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xDriverName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xDriverName.setDescription('SCSI Drive Device Driver Name. This is the name of the NetWare v3.1x SCSI device driver. It can be used for identification purposes.')
cpqScsiNw3xDriverVers = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xDriverVers.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xDriverVers.setDescription('SCSI Drive Device Driver Version. This is the version of the NetWare v3.1x SCSI device driver. It can be used for identification purposes.')
cpqScsiNw3xDriverPollType = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("polled", 2), ("demand", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xDriverPollType.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xDriverPollType.setDescription('SCSI Drive Device Driver Poll Type. The SNMP instrument agent collects information from the device driver in two ways: other(1) The management agent does not recognize this poll type. You may need to upgrade your software. polled(2) Indicates that the information is periodically requested and stored by the server based agent and is available when requested. demand(3) Indicates that the information is collected at the time of the request.')
cpqScsiNw3xDriverPollTime = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xDriverPollTime.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xDriverPollTime.setDescription('SCSI Drive Device Driver Poll Time. If the nw3xDriverPollType is polled(2) this value shows how frequently, in seconds, the instrument agent requests information from the device driver. To change the poll time, you need to unload and then reload the instrument agent using the following commands: UNLOAD CPQDSKSA LOAD CPQDSKSA /U<time> The parameter /U specifies the frequency of updates in seconds. The variable <time> represents the number of seconds that the NLM should wait before collecting new data. The minimum is one second and the maximum value is 300 seconds (five minutes).')
cpqScsiNw3xCntlrInfoTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5), )
if mibBuilder.loadTexts: cpqScsiNw3xCntlrInfoTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xCntlrInfoTable.setDescription('SCSI Controller Information Table.')
cpqScsiNw3xCntlrInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiNw3xCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiNw3xBusIndex"))
if mibBuilder.loadTexts: cpqScsiNw3xCntlrInfoEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xCntlrInfoEntry.setDescription('SCSI Controller Information Table Entry.')
cpqScsiNw3xCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xCntlrIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xCntlrIndex.setDescription('SCSI Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqScsiNw3xBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xBusIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xBusIndex.setDescription('SCSI Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on an adapter.')
cpqScsiNw3xXptDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xXptDesc.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xXptDesc.setDescription('SCSI XPT Description. This is a description of the Transport Layer (XPT) module, CPQSXPT.DSK. The Transport Layer manages requests from the device driver and routes them to the appropriate SCSI Interface Module (SIM). This architecture is based on the ANSI SCSI-2 Common Access Method (CAM) specification.')
cpqScsiNw3xXptVers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xXptVers.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xXptVers.setDescription('SCSI XPT Version. This is the version of the Transport Layer (XPT) module, CPQSXPT.DSK. The Transport Layer manages requests from the device driver and routes them to the appropriate SCSI Interface Module (SIM). This architecture is based on the ANSI SCSI-2 Common Access Method (CAM) specification.')
cpqScsiNw3xSimDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xSimDesc.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xSimDesc.setDescription('SCSI SIM Description. This is a description of the SCSI Interface Module (SIM). Each type of controller model has a specific SIM designed for it. The SIM accepts requests from the Transport Layer and delivers them to the physical device. This architecture is based on the ANSI SCSI-2 Common Access Method (CAM) specification.')
cpqScsiNw3xSimVers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xSimVers.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xSimVers.setDescription('SCSI SIM Version. This is the version of the SCSI Interface Module (SIM). Each type of controller model has a specific SIM designed for it. The SIM accepts requests from the Transport Layer and delivers them to the physical device. This architecture is based on the ANSI SCSI-2 Common Access Method (CAM) specification.')
cpqScsiNw3xHbaDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xHbaDesc.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xHbaDesc.setDescription('SCSI HBA Description. This is a description of the SCSI Host Bus Adapter (HBA). An HBA represents one instance of a SCSI bus in the SCSI Interface Module (SIM). This architecture is based on the ANSI SCSI-2 Common Access Method (CAM) specification.')
cpqScsiLogDrvStatTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6), )
if mibBuilder.loadTexts: cpqScsiLogDrvStatTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiLogDrvStatTable.setDescription('SCSI Logical Drive Statistics Table.')
cpqScsiLogDrvStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiNw3xStatCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiNw3xStatBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiNw3xStatLogDrvIndex"))
if mibBuilder.loadTexts: cpqScsiLogDrvStatEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiLogDrvStatEntry.setDescription('SCSI Device Driver Statistics Table Entry.')
cpqScsiNw3xStatCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xStatCntlrIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xStatCntlrIndex.setDescription('SCSI Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqScsiNw3xStatBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xStatBusIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xStatBusIndex.setDescription('SCSI Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiNw3xStatLogDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xStatLogDrvIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xStatLogDrvIndex.setDescription('SCSI Logical Drive Index. The logical drive index indicates to which logical drive instance on a SCSI bus this table entry belongs. The logical drive index starts at one and increments for each logical drive on the SCSI bus.')
cpqScsiNw3xTotalReads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xTotalReads.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xTotalReads.setDescription('SCSI Logical Drive Total Reads. This shows the total number of reads performed by the device driver to this logical drive. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiNw3xTotalWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xTotalWrites.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xTotalWrites.setDescription('SCSI Logical Drive Total Writes. This shows the total number of writes performed by the device driver to this logical drive. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiNw3xCorrReads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xCorrReads.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xCorrReads.setDescription('SCSI Logical Drive Corrected Reads. This is the total number of read commands sent to the specified logical drive which had to be corrected by fault tolerance. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiNw3xCorrWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xCorrWrites.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xCorrWrites.setDescription('SCSI Logical Drive Corrected Writes. This is the total number of write commands sent to the specified logical drive which had to be corrected by fault tolerance. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiNw3xFatalReads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xFatalReads.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xFatalReads.setDescription('SCSI Logical Drive Fatal Reads. This is the total number of read commands sent to the specified logical drive which failed. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiNw3xFatalWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xFatalWrites.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xFatalWrites.setDescription('SCSI Logical Drive Fatal Writes. This is the total number of write commands sent to the specified logical drive which failed. This number is reset each time the device driver is loaded for this logical drive.')
cpqScsiVolMapTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7), )
if mibBuilder.loadTexts: cpqScsiVolMapTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiVolMapTable.setDescription('SCSI Drive Volume Map Table.')
cpqScsiVolMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiNw3xVolCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiNw3xVolBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiNw3xVolLogDrvIndex"))
if mibBuilder.loadTexts: cpqScsiVolMapEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiVolMapEntry.setDescription('SCSI Drive Volume Map Table Entry.')
cpqScsiNw3xVolCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xVolCntlrIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xVolCntlrIndex.setDescription('SCSI Cntlr Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqScsiNw3xVolBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xVolBusIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xVolBusIndex.setDescription('SCSI Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiNw3xVolLogDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xVolLogDrvIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xVolLogDrvIndex.setDescription('SCSI Logical Drive Index. The logical drive index indicates to which logical drive instance on a SCSI bus this table entry belongs. The logical drive index starts at one and increments for each logical drive on the SCSI bus.')
cpqScsiNw3xVolMap = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 1, 7, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiNw3xVolMap.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiNw3xVolMap.setDescription('SCSI Drive Volume Map. This is a data structure containing the volume mappings for this logical drive. There are 8 entries in a NetWare volume mapping. An entry can be null indicating no mapping exists. Each entry has the following format. BYTE Name[16] BYTE Segment')
cpqScsiOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqScsiOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. If the poll frequency is zero (0) all attempts to write to this object will fail. If the poll frequency is non-zero, setting this value will change the polling frequency of the Insight Agent. Setting the poll frequency to zero will always fail, an agent may also choose to fail any request to change the poll frequency to a value that would severely impact system performance.")
cpqScsiOsCommonModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2), )
if mibBuilder.loadTexts: cpqScsiOsCommonModuleTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleTable.setDescription('A table of software modules that provide an interface to the device this MIB describes.')
cpqScsiOsCommonModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiOsCommonModuleIndex"))
if mibBuilder.loadTexts: cpqScsiOsCommonModuleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleEntry.setDescription('A description of a software modules that provide an interface to the device this MIB describes.')
cpqScsiOsCommonModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiOsCommonModuleIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleIndex.setDescription('A unique index for this module description.')
cpqScsiOsCommonModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiOsCommonModuleName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleName.setDescription('The module name.')
cpqScsiOsCommonModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiOsCommonModuleVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleVersion.setDescription('The module version in XX.YY format. Where XX is the major version number and YY is the minor version number. This field will be a null (size 0) string if the agent cannot provide the module version.')
cpqScsiOsCommonModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiOsCommonModuleDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModuleDate.setDescription('The module date. field octets contents range ===== ====== ======= ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the agent cannot provide the module date. The hour, minute, and second field will be set to zero (0) if they are not relevant. The year field is set with the most significant octect first.')
cpqScsiOsCommonModulePurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiOsCommonModulePurpose.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiOsCommonModulePurpose.setDescription('The purpose of the module described in this entry.')
cpqScsiCntlrTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1), )
if mibBuilder.loadTexts: cpqScsiCntlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrTable.setDescription('SCSI Controller Table.')
cpqScsiCntlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiCntlrBusIndex"))
if mibBuilder.loadTexts: cpqScsiCntlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrEntry.setDescription('SCSI Controller Table Entry.')
cpqScsiCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrIndex.setDescription('SCSI Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqScsiCntlrBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrBusIndex.setDescription('SCSI Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiCntlrModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("cpqs710", 2), ("cpqs94", 3), ("cpqs810p", 4), ("cpqs825e", 5), ("cpqs825p", 6), ("cpqs974p", 7), ("cpqs875p", 8), ("extended", 9), ("cpqs895p", 10), ("cpqs896p", 11), ("cpqa789x", 12), ("cpqs876t", 13), ("hpu320", 14), ("hpu320r", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrModel.setDescription("SCSI Controller Model. The is the controller's model and can be used for identification purposes. The following values are defined: other(1) The management agent does not recognize this model. You may need to upgrade your software. cpqs710(2) Compaq 32-Bit Fast SCSI-2 Controller. cpqs94(3) Compaq Systempro/XL Integrated SCSI-2 Options Port. cpqs810p(4) Integrated Fast-SCSI-2 Controller/P. cpqs825e(5) Compaq 32-Bit Fast-Wide SCSI-2 /E Controller. cpqs825p(6) Compaq 32-Bit Fast-Wide SCSI-2 /P Controller. cpqs974p(7) Deskpro XL Integrated PCI SCSI-2 Controller. cpqs875p(8) Compaq Wide-Ultra SCSI Controller. extended(9) SCSI Controllers described by cpqScsiCntlrModelExtended. cpqs895p(10) Compaq Wide Ultra2 SCSI Controller. cpqs896p(11) Compaq 64-Bit Dual Channel Wide Ultra2 SCSI Controller. cpqa789x(12) Compaq Wide Ultra3 SCSI Adapter. cpqs876t(13) Compaq StorageWorks Library Adapter. hpu320(14) HP 64-Bit/133MHz PCI-X 2CH Ultra320 HBA. hpu320r(15) HP PCI-X Dual Channel Ultra320 SCSI Adapter.")
cpqScsiCntlrFWVers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrFWVers.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrFWVers.setDescription("SCSI Controller Firmware Version. This is the version of the firmware on the SCSI controller. If the SCSI controller does not use firmware then this string will be of length zero (0). Some SCSI bus controllers are script driven and use the computer system's microprocessor thus not needing firmware.")
cpqScsiCntlrSWVers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrSWVers.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiCntlrSWVers.setDescription("SCSI Controller Software Version. This is the version of any software upgrade which is being used in place of the firmware with the controller. If the SCSI controller has not been upgraded via software or does not have firmware then this string will be of length zero (0). Some SCSI bus controllers are script driven and use the computer system's microprocessor thus not needing firmware.")
cpqScsiCntlrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrSlot.setDescription('SCSI Controller Slot. This is the physical slot in which this controller is installed. This information can be used for identification purposes.')
cpqScsiCntlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrStatus.setDescription('SCSI Controller Status. This is the current status of the controller. The following values are currently defined: other(1) The controller is not operational due to reasons other than hardware failure. The controller may be intentionally disabled. The controller configuration may be in conflict with the configuration of other hardware or software in the system. The controller may have failed initialization. Corrective action is Operating System dependent. Check for diagnostic messages which may have occurred at system boot time. ok(2) The controller is operating normally. failed(3) The controller has failed and is no longer operating. Please run diagnostics on the computer system to help identify the problem.')
cpqScsiCntlrHardResets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrHardResets.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrHardResets.setDescription('SCSI Controller Hard Resets. This is the number of times the SCSI Hardware Interface driver detected that the SCSI bus has been reset since the driver was loaded. Hard resets may occasionally occur due to device errors. If this value should rise dramatically, you may have a problem. Check the SCSI bus statistics for unusually high error counts. If there is a device with a large number of bus errors, it may be failing and should be replaced.')
cpqScsiCntlrSoftResets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrSoftResets.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrSoftResets.setDescription('SCSI Controller Soft Resets. This is the number of times the SCSI Hardware Interface driver has issued a reset command to all devices on a SCSI bus since the driver was loaded. Soft resets occur when the device driver is initializing the SCSI bus for operation and when device errors have left the bus in an ambiguous state. If this value should rise dramatically, you may have a problem. Check the SCSI bus statistics for unusually high error counts. If there is a device with a large number of bus errors, it may be failing and should be and should be replaced.')
cpqScsiCntlrTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrTimeouts.setDescription('SCSI Controller Time-outs. This is the number of times, since the driver was loaded, that the SCSI Hardware Interface driver issued a SCSI command but did not receive a reply within a specified amount of time. Timeouts may occasionally occur when a device fails to process a request because the SCSI bus was busy. If this value should rise dramatically, you may have a problem. Check if you have any non-disk SCSI devices, like tape drives, on the SCSI bus with the drives. Sometimes a non-disk device can hold the SCSI bus for long periods of time causing time-outs.')
cpqScsiCntlrBaseIOAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrBaseIOAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrBaseIOAddr.setDescription('SCSI Controller Base I/O Address. This is the I/O address that the SCSI Hardware Interface driver uses to communicate with the SCSI bus controller. This value can be used for identification purposes.')
cpqScsiCntlrCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrCondition.setDescription("SCSI Controller Condition. This is the overall condition of the controller and all of the logical drives and physical drives controlled by it. The following values are defined: other(1) The management agent does not recognize the status as one of those listed below. ok(2) The controller and all of its logical drives and physical drives are operating normally. No user action is required. degraded(3) One or more of the controller's logical drives or physical drives is degraded. You need to check the status of all logical drives and physical drives. failed(4) The controller status is failed. The drives on this controller are inaccessible. Please refer to the controller status field for further information.")
cpqScsiCntlrSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrSerialNum.setDescription('SCSI Controller Serial Number. This is the serial number assigned to the controller. This can be used for identification purposes. This field will be a null (size 0) string if the management agent cannot provide the serial number.')
cpqScsiCntlrBusWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("narrow", 2), ("wide16", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrBusWidth.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrBusWidth.setDescription("SCSI Controller Data Bus Width. This is the physical width of the controller's SCSI data bus. other(1) The management agent does not recognize this width. You may need to upgrade your software. narrow(2) The SCSI controller supports an 8-bit narrow SCSI data bus. wide16(3) The SCSI controller supports a 16-bit wide SCSI data bus.")
cpqScsiCntlrModelExtended = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrModelExtended.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCntlrModelExtended.setDescription('SCSI Controller Model Name. This is the model name for SCSI controllers not defined by cpqScsiCntlrModel enumerations. This field will be a null (size 0) string if the management agent cannot provide the SCSI Controller description.')
cpqScsiCntlrHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 2, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCntlrHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqScsiCntlrHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the SCSI controller. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqScsiLogDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1), )
if mibBuilder.loadTexts: cpqScsiLogDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvTable.setDescription('SCSI Logical Drive Table.')
cpqScsiLogDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiLogDrvCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiLogDrvBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiLogDrvIndex"))
if mibBuilder.loadTexts: cpqScsiLogDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvEntry.setDescription('SCSI Logical Drive Entry.')
cpqScsiLogDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvCntlrIndex.setDescription('SCSI Logical Drive Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs.')
cpqScsiLogDrvBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvBusIndex.setDescription('SCSI Logical Drive Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs.')
cpqScsiLogDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvIndex.setDescription('SCSI Logical Drive Index. The logical drive index indicates to which logical drive instance on a SCSI bus this table entry belongs.')
cpqScsiLogDrvFaultTol = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("mirroring", 3), ("dataGuard", 4), ("distribDataGuard", 5), ("enhancedMirroring", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvFaultTol.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvFaultTol.setDescription("SCSI Logical Drive Fault Tolerance. This shows the fault tolerance mode of the logical drive. The following values are valid for the Logical Drive Fault Tolerance: other(1) The management agent does not recognize the status. You may need to upgrade your software. none(2) Fault tolerance is not enabled. If a physical drive reports an error, the data cannot be recovered. This is known as RAID 0. mirroring(3) For each physical drive, there is a second physical drive containing identical data. If a drive fails, the data can be retrieved from the mirror drive. dataGuard(4) One of the physical drives is used as a data guard drive and contains the exclusive OR of the data on the remaining drives. If a failure is detected, the data is rebuilt using the data guard information plus information from the other drives. distribDataGuard(5) Distributed Data Guarding, sometimes referred to as RAID 5, is similar to Data Guarding, but instead of storing the parity information on one drive, the information is distributed across all of the drives. If a failure is detected, the data is rebuilt using the data guard information from all the drives. enhancedMirroring(6) This is used when there are more than 2 physical disks. Each 'mirrored stripe' is written to a disk and is mirrored to an 'adjacent' disk. This is commonly referred to as RAID 1E. If a failure is detected, the data is rebuilt using the data from the mirrored stripes on the other drives.")
cpqScsiLogDrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3), ("unconfigured", 4), ("recovering", 5), ("readyForRebuild", 6), ("rebuilding", 7), ("wrongDrive", 8), ("badConnect", 9), ("degraded", 10), ("disabled", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvStatus.setDescription("SCSI Logical Drive Status. The logical drive can be in one of the following states: other(1) The management agent does not recognize the status. You may need to upgrade your software. ok(2) Indicates that the logical drive is in normal operation mode. No user action is required. failed(3) Indicates that more physical drives have failed than the fault tolerance mode of the logical drive can handle without data loss. unconfigured(4) Indicates that the logical drive is not configured. Insure all of the drive switches are properly set and run the configuration utility. recovering(5) Indicates that the logical drive is using Interim Recovery Mode. In Interim Recovery Mode, at least one physical drive has failed, but the logical drive's fault tolerance mode lets the logical drive continue to operate with no data loss. You should replace the failed drive as soon as possible. readyRebuild(6) Indicates that the logical drive is ready for Automatic Data Recovery. The physical drive that failed has been replaced, but the logical drive is still operating in Interim Recovery Mode. rebuilding(7) Indicates that the logical drive is currently resynchronizing the data accross the physical drives in the logical drive. wrongDrive(8) Indicates that the wrong physical drive was replaced after a physical drive failure. You need to return the drive incorrectly replaced and replace the failed drive. badConnect(9) Indicates that a physical drive is not responding. Check the cables connected to it. degraded(10) Indicates that the logical drive is in a degraded state. disabled(11) Indicates that the logical drive is disabled. The logical drive configuration utility can enable or disable the logical drive. You should enable the logical drive using the configuration utility.")
cpqScsiLogDrvSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvSize.setDescription('SCSI Logical Drive Size. This is the size of the logical drive in megabytes. This value is calculated using the value 1,048,576 (2^20) as a megabyte. Drive manufacturers sometimes use the number 1,000,000 as a megabyte when giving drive capacities so this value may differ from the advertised size of a drive.')
cpqScsiLogDrvPhyDrvIDs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvPhyDrvIDs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvPhyDrvIDs.setDescription("SCSI Logical Drive Physical Drive IDs. This lists the physical drive SCSI ID's which are associated with this logical drive. These are the same IDs which can be used as indices into the physical drive table. Each byte of the string is an index.")
cpqScsiLogDrvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvCondition.setDescription('SCSI Logical Drive Condition. This is the overall condition of the logical drive and all of the physical drives which comprise it. The following values are defined: other(1) The management agent does not recognize the status. You may need to upgrade your software. ok(2) The logical drive and all of its physical drives are operating normally. No user action is required. degraded(3) Either the logical drive is degraded or one or more of its physical drives is degraded. You need to check the status of the logical drive and of all its physical drives. failed(4) Either the logical drive has failed or one or more of its physical drives has failed. You need to check the status of the logical drive and of all its physical drives.')
cpqScsiLogDrvStripeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvStripeSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvStripeSize.setDescription('Logical Drive Stripe Size. This is the size of a logical drive stripe in kilobytes.')
cpqScsiLogDrvAvailSpares = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvAvailSpares.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvAvailSpares.setDescription("SCSI Logical Drive Available Spares. This indicates if this logical drive has one or more spares designated for it that are not currently in use by another drive. Each octet present will be a physical drive ID that is an available spare for this logical drive. These are the same ID's which can be used as indexes into the physical drive table. An octet string of length zero indicates that there are no available spares for this logical drive.")
cpqScsiLogDrvPercentRebuild = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvPercentRebuild.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvPercentRebuild.setDescription('Logical Drive Percent Rebuild. After a failed physical drive has been replaced, the physical drive must have its data rebuilt. This value is the percent complete of the rebuild. When the value reaches 100, the rebuilding process is complete. The drive array continues to operate in interim recovery mode while a drive is rebuilding. This value is only valid if the Logical Drive Status is rebuilding(7). If the value cannot be determined or a rebuild is not active, the value is set to 0.')
cpqScsiLogDrvOsName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 3, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiLogDrvOsName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiLogDrvOsName.setDescription('Logical Drive OS Name. The OS name for this array logical drive. This field will be a null (size 0) string if the agent does not support OS name.')
cpqScsiPhyDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1), )
if mibBuilder.loadTexts: cpqScsiPhyDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvTable.setDescription('SCSI Physical Drive Table.')
cpqScsiPhyDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiPhyDrvCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiPhyDrvBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiPhyDrvIndex"))
if mibBuilder.loadTexts: cpqScsiPhyDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvEntry.setDescription('SCSI Physical Drive Entry.')
cpqScsiPhyDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvCntlrIndex.setDescription('SCSI Physical Drive Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer where the adapter is located.')
cpqScsiPhyDrvBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvBusIndex.setDescription('SCSI Physical Drive Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiPhyDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvIndex.setDescription('SCSI Physical Drive Index. The physical drive index indicates to which physical drive instance on a SCSI bus this table entry belongs. The physical drive index is the SCSI ID being used by that drive.')
cpqScsiPhyDrvModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvModel.setDescription("SCSI Physical Drive Model. This is a description of the physical drive's model as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiPhyDrvFWRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvFWRev.setDescription('SCSI Physical Drive Firmware Revision. This is the revision level of the physical drive as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqScsiPhyDrvVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvVendor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvVendor.setDescription("SCSI Physical Drive Vendor. This is the physical drive vendor's name as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiPhyDrvSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvSize.setDescription('SCSI Physical Drive Size in MB. This is the size of the physical drive in megabytes. This value is calculated using the value 1,048,576 (2^20) as a megabyte. Drive manufacturers sometimes use the number 1,000,000 as a megabyte when giving drive capacities so this value may differ from the advertised size of a drive.')
cpqScsiPhyDrvScsiID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvScsiID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvScsiID.setDescription("SCSI Physical Drive SCSI ID. This is the SCSI ID used by the physical drive. SCSI ID's identify a physical drive on a bus so the controller can communicate with it.")
cpqScsiPhyDrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3), ("notConfigured", 4), ("badCable", 5), ("missingWasOk", 6), ("missingWasFailed", 7), ("predictiveFailure", 8), ("missingWasPredictiveFailure", 9), ("offline", 10), ("missingWasOffline", 11), ("hardError", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvStatus.setDescription("SCSI Physical Drive Status. The physical drive can be in one of the following states: other(1) The drive is in a state other than one of those listed below. ok(2) Indicates that the physical drive is in normal operation mode. No user action is necessary. failed(3) Indicates that the physical drive has failed and can no longer return data. When convenient, you should bring down the server and run diagnostics to help identify the problem. The drive may need to be replaced. notConfigured(4) Indicates that the physical drive is not configured. You need to insure all of the drive's switches are properly set and that the configuration utility has been run. badCable(5) Indicates that a physical drive is not responding. You should check the cables connected to it. You can bring down the server and run diagnostics to help identify the problem. missingWasOk(6) Indicates that a physical drive had a status of OK and is no longer present. The drive has been removed. missingWasFailed(7) Indicates that a physical drive had a status of FAILED and is no longer present. The drive has been removed. predictiveFailure(8) Indicates that the physical drive has exceeded a threshold value for one of it's predictive indicators. When convenient, you should bring down the server and run diagnostics to help identify the problem. The drive may need to be replaced. missingWasPredictiveFailure(9) Indicates that a physical drive had a status of PREDICTIVE FAILURE and is no longer present. The drive has been removed. offline(10) Indicates that the physical drive is offline and can no longer return data. No further status is available. missingWasOffline(11) Indicates that a physical drive had a status of OFFLINE and is no longer present. The drive has been removed. hardError(12) Indicates that a hard error occurred for this physical drive.")
cpqScsiPhyDrvServiceHours = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvServiceHours.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvServiceHours.setDescription('SCSI Physical Drive Service Time in hours. This shows the total number of hours that a physical drive has been operating under the device driver. You can use the service time to calculate rates for other physical drive objects.')
cpqScsiPhyDrvHighReadSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvHighReadSectors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvHighReadSectors.setDescription('SCSI Physical Drive Sectors Read (high). The phyDrvHighReadSectors and the phyDrvlowReadSectors together show the total number of sectors read from the physical disk drive during the service time (phyDrvServiceHours). The actual number of sectors read equals the phyDrvHighReadSectors times 2^32 plus the phyDrvLowReadSectors. This information may be useful for determining rates. For example, if you want to calculate the average number of reads per hour of operation, divide this number by the service time.')
cpqScsiPhyDrvLowReadSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvLowReadSectors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvLowReadSectors.setDescription('SCSI Physical Drive Sectors Read (low). The phyDrvHighReadSectors and the phyDrvlowReadSectors together show the total number of sectors read from the physical disk drive during the service time (phyDrvServiceHours). The actual number of sectors read equals the phyDrvHighReadSectors times 2^32 plus the phyDrvLowReadSectors. This information may be useful for determining rates. For example, if you want to calculate the average number of reads per hour of operation, divide this number by the service time.')
cpqScsiPhyDrvHighWriteSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvHighWriteSectors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvHighWriteSectors.setDescription('SCSI Physical Drive Sectors Written (high). The phyDrvHighWriteSectors and the phyDrvlowWriteSectors together show the total number of sectors written to the physical disk drive during the service time (phyDrvServiceHours). The actual number of sectors read equals the phyDrvHighWriteSectors times 2^32 plus the phyDrvLowWriteSectors. This information may be useful for determining rates. For example, if you want to calculate the average number of writes per hour of operation, divide this number by the service time.')
cpqScsiPhyDrvLowWriteSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvLowWriteSectors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvLowWriteSectors.setDescription('SCSI Physical Drive Sectors Written (low). The phyDrvHighWriteSectors and the phyDrvlowWriteSectors together show the total number of sectors written to the physical disk drive during the service time (phyDrvServiceHours). The actual number of sectors read equals the phyDrvHighWriteSectors times 2^32 plus the phyDrvLowWriteSectors. This information may be useful for determining rates. For example, if you want to calculate the average number of writes per hour of operation, divide this number by the service time.')
cpqScsiPhyDrvHardReadErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvHardReadErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvHardReadErrs.setDescription("SCSI Physical Drive Hard Read Errors. This is the number of read errors that have occurred on a drive that could not be recovered by a physical drive's Error Correction Code (ECC) algorithm, retries or any other recovery mechanisms during the service time (phyDrvServiceHours). If you see any hard read errors there may be a problem. This is often caused by bad media sections on the drive. If the error count continues to rise you may need to replace the drive.")
cpqScsiPhyDrvHardWriteErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvHardWriteErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvHardWriteErrs.setDescription('SCSI Physical Drive Hard Write Errors. This is the number of write errors that have occurred on a drive that could not be recovered by retries or any other recovery mechanisms during the service time (phyDrvServiceHours). If you see any hard write errors there may be a problem. This is often caused by bad media sections on the drive. If the error count continues to rise you may need to replace the drive.')
cpqScsiPhyDrvEccCorrReads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvEccCorrReads.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvEccCorrReads.setDescription('SCSI Physical Drive ECC Corrected Read Errors (high). This is the number of read requests that the drive had to use an Error Correction Code (ECC) algorithm on to recover data during the service time (phyDrvServiceHours). ECC corrected reads will occasionally occur over time. Having a large number of ECC corrected errors does not necessarily indicate that the drive is failing. However, you may wish to replace a drive with an abnormally high amount in comparison to other similar drives as a precaution.')
cpqScsiPhyDrvRecvReadErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvRecvReadErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvRecvReadErrs.setDescription('SCSI Physical Drive Recovered Read Errors. This is the number of read requests that the drive had to use retries or other recovery mechanisms on to recover data during the service time (phyDrvServiceHours). Retry corrected reads will occasionally occur over time. Having a large number of retry corrected errors does not necessarily indicate that the drive is failing. However, you may wish to replace a drive with an abnormally high amount in comparison to other similiar drives as a precaution.')
cpqScsiPhyDrvRecvWriteErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvRecvWriteErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvRecvWriteErrs.setDescription('SCSI Physical Drive Recovered Write Errors. This is the number of write requests that the drive had to use retries or other recovery mechanisms on to recover data during the service time (phyDrvServiceHours). Retry corrected writes will occasionally occur over time. Having a large number of retry corrected errors does not necessarily indicate that the drive is failing. However, you may wish to replace a drive with an abnormally high amount in comparison to other similiar drives as a precaution.')
cpqScsiPhyDrvSeekErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvSeekErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvSeekErrs.setDescription('SCSI Physical Drive Seek Errors. This is the number of times a drive head seek failed during the service time (phyDrvServiceHours). Seek errors will occasionally occur over time. Having a large number of seek errors does not necessarily indicate that the drive is failing. However, you may wish to replace a drive with an abnormally high amount in comparison to other similiar drives as a precaution.')
cpqScsiPhyDrvSpinupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvSpinupTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvSpinupTime.setDescription('SCSI Physical Drive Spin up Time (tenths of seconds). This is the time it takes for a physical drive to spin up to full speed. Disks require time to gain momentum and reach operating speed. As cars are tested to go from 0 mph to 60 mph in x number of seconds, drive manufacturers have preset expectations for the time it takes the drive to spin to full speed. Drives that do not meet these expectations may have problems. If the drive is having problems spinning up, this value will increase over time. Eventually, the drive may fail to spin up altogether. If you see a large increase in this value over time, you may want to replace the drive as a precaution.')
cpqScsiPhyDrvUsedReallocs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvUsedReallocs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvUsedReallocs.setDescription('SCSI Physical Drive Used Reallocation Sectors. This shows the number of sectors of the reallocation area that have been used by the physical drive over the life of the drive. Because of the nature of magnetic disks, certain sectors on a drive may have media defects. The reallocation area is part of the disk drive that the drive manufacturer sets aside to compensate for these defects. The drive writes information addressed from these unusable sectors to available sectors in the reallocation area. If all of the reserved sectors have been used, then there is no way for the drive to remap bad sectors and the drive will start failing. Unfortunately, the number of reallocation sectors originally reserved for this purpose is drive specific and you must contact the drive vendor for these values. If the current value starts to approach the maximum reserved you may wish to replace the drive before it fails.')
cpqScsiPhyDrvTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvTimeouts.setDescription('SCSI Physical Drive Time-out Errors. This is the number of times the drive failed to complete a request within a specified amount of time during the service time (phyDrvServiceHours). Time-outs may occasionally occur when a device fails to process a request because the SCSI bus was busy. If this value should rise dramatically, you may have a problem. Check if you have any non-disk SCSI devices, like tape drives, on the SCSI bus with the drives. Sometimes a non-disk device can hold onto the SCSI bus for long periods of time causing time-outs.')
cpqScsiPhyDrvPostErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvPostErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvPostErrs.setDescription('SCSI Physical Drive Power On Self Test (POST) Errors. This is the number of times that a drive failed its self test during the service time (phyDrvServiceHours). The drive does a self test each time power is applied to the system. If you see any self test errors there may be a problem. You can run diagnostics to help identify the problem.')
cpqScsiPhyDrvPostErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvPostErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvPostErrCode.setDescription('SCSI Physical Drive Last POST Error Code. This is the result of the last SCSI command which caused a self test to fail. The value is split into three fields. The first byte is the SCSI Sense Qualifier. The second byte is the SCSI Sense Code. The third byte is the SCSI Sense Key. You will need to refer to a SCSI-2 specification for the valid values of these fields.')
cpqScsiPhyDrvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvCondition.setDescription('SCSI Physical Drive Condition. This is the overall condition of the physical drive. The following values are defined: other(1) The Insight agent does not recognize the status. You may need to upgrade your software. ok(2) The physical drive is operating normally. No user action is required. degraded(3) The physical drive is degraded. You need to check the status of all logical drives and physical drives. failed(4) The physical drives has failed. When convenient, you should bring down the server and run diagnostics to help identify the problem.')
cpqScsiPhyDrvFuncTest1 = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvFuncTest1.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvFuncTest1.setDescription('SCSI Physical Drive Functional Test 1. This is a percentage value that represents the operating efficiency of a drive. The functional test issues a series of SCSI commands and times the results. When the drive has the test run for the very first time (service time is zero), the results are saved as the baseline value. Then, whenever the test is executed the current result is compared to the baseline result and expressed as a percent. If the percentage result should drop rapidly there may be a problem with the drive. You may wish to replace the drive as a precaution.')
cpqScsiPhyDrvFuncTest2 = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvFuncTest2.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvFuncTest2.setDescription('SCSI Physical Drive Functional Test 2. This is a percentage value that represents the operating efficiency of a drive. The functional test issues a series of SCSI commands and times the results. When the drive has the test run for the very first time (service time is zero), the results are saved as the baseline value. Then, whenever the test is executed the current result is compared to the baseline result and expressed as a percent. If the percentage result should drop rapidly there may be a problem with the drive. You may wish to replace the drive as a precaution.')
cpqScsiPhyDrvStatsPreserved = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("inNVRAM", 2), ("onDisk", 3), ("noCPUSupport", 4), ("noFreeNVRAM", 5), ("noDrvSupport", 6), ("noSoftwareSupport", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvStatsPreserved.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvStatsPreserved.setDescription('SCSI Physical Drive Statistics Preservation Method. This value indicates how all of the objects in this table are saved over a power cycle. If the objects are not saved then all of their values will be reset whenever the device driver is unloaded. The following values are defined: other(1) The Insight agent does not recognize the status. You may need to upgrade your software. inNVRAM(2) The objects are saved in non-volatile memory in the computer system. onDisk(3) The objects are saved on the physical drives in reserved sectors. noCPUSupport(4) The objects are not saved across power cycles because the hardware does not support this operation. noFreeNVRAM(5) The objects are not saved across power cycles because all of the available non-volatile memory is in use. noDrvSupport(6) The objects are not saved across power cycles because the physical drive does not contain a unique identifier to save it under. noSoftwareSupport(7) The objects are not saved across power cycles because either the device driver or computer system firmware do not provide support.')
cpqScsiPhyDrvSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvSerialNum.setDescription('SCSI Physical Drive Serial Number. This is the serial number assigned to the physical drive. This value is based upon the serial number as returned by the SCSI inquiry command but may have been modified due to space limitations. This can be used for identification purposes.')
cpqScsiPhyDrvLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("proliant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvLocation.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiPhyDrvLocation.setDescription('SCSI Physical Drive Location. This is the physical location of where the drive is located. The following values are defined: other(1) The drives are not located in any special product that identifies the location. proliant(2) The drives are located in the ProLiant Storage System.')
cpqScsiPhyDrvParent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvParent.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvParent.setDescription('SCSI Physical Drive Parent. This is the logical drive index to which this physical drive belongs.')
cpqScsiPhyDrvSectorSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvSectorSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvSectorSize.setDescription('SCSI Physical Drive Sector Size in Bytes. This allows one to convert counters that are reported in sectors to bytes.')
cpqScsiPhyDrvHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("hotPlug", 2), ("nonHotPlug", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvHotPlug.setDescription('SCSI Physical Drive Hot Plug Support Status. The following values are defined: other(1) The Insight agent is unable to determine if this drive supports hot plug replacement. hotPlug(2) The drive supports hot plug replacement. nonhotPlug(3) The drive does not support hot plug replacement.')
cpqScsiPhyDrvPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvPlacement.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvPlacement.setDescription('SCSI Physical Drive Placement. The following values are defined: other(1) The agent is unable to determine if the drive is internal or external to the system chassis. internal(2) The drive is located in an internal Proliant system chassis. external(3) The drive is located in an external Proliant storage system.')
cpqScsiPhyDrvPreFailMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notAvailable", 2), ("available", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvPreFailMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvPreFailMonitoring.setDescription('SCSI Physical Drive Predictive Failure Monitoring. The following values are defined: other(1) The agent is unable to determine if the drive supports predictive failure monitoring. notAvailable(2) This drive does not support predictive failure monitoring. available(3) This drive supports predictive failure monitoring.')
cpqScsiPhyDrvOsName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvOsName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvOsName.setDescription('Physical Drive OS Name. The OS name for this SCSI physical drive. This field will be a null (size 0) string if the agent does not support OS name.')
cpqScsiPhyDrvRotationalSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("rpm7200", 2), ("rpm10K", 3), ("rpm15K", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvRotationalSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvRotationalSpeed.setDescription('SCSI Physical Drive Rotational Speed. The following values are defined: other(1) The agent is unable to determine the rotational speed for this drive. rpm7200(2) The rotational speed for this drive is 7200 rpm. rpm10K(3) The rotational speed for this drive is 10000 rpm. rpm15K(4) The rotational speed for this drive is 15000 rpm.')
cpqScsiPhyDrvMemberLogDrv = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 4, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("member", 2), ("spare", 3), ("nonMember", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiPhyDrvMemberLogDrv.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiPhyDrvMemberLogDrv.setDescription('The Physical Drive is a Member of a Logical Drive. This is an indication of whether the physical drive is a member of a SCSI logical drive. This variable can be in one of the following states: other(1) The agent is unable to determine if the physical drive is a member of a logical drive. member(2) The physical drive is a member of a logical drive. spare(2) The physical drive is a spare drive for a logical drive. nonMember(4) The physical drive is not a logical drive member or spare.')
cpqScsiTargetTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1), )
if mibBuilder.loadTexts: cpqScsiTargetTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetTable.setDescription('SCSI Target Table.')
cpqScsiTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiTargetCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiTargetBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiTargetScsiIdIndex"))
if mibBuilder.loadTexts: cpqScsiTargetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetEntry.setDescription('SCSI Target Entry.')
cpqScsiTargetCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetCntlrIndex.setDescription('SCSI Target Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqScsiTargetBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetBusIndex.setDescription('SCSI Target Bus Index. The bus index indicates to which SCSI bus instance on an adapter card this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiTargetScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetScsiIdIndex.setDescription('SCSI Target Device Index. The device index indicates to which device instance on a SCSI bus this table entry belongs. The device index is the SCSI ID being used by that device.')
cpqScsiTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("disk", 2), ("tape", 3), ("printer", 4), ("processor", 5), ("wormDrive", 6), ("cd-rom", 7), ("scanner", 8), ("optical", 9), ("jukeBox", 10), ("commDev", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetType.setDescription('SCSI Device Type. This is the type of SCSI device. The following types are defined: other(1) The Insight agent does not recognize this type. You may need to upgrade your software. disk(2) This is a direct-access device like a disk drive. tape(3) This is a sequential-access device like a tape drive. printer(4) This is a printer device. processor(5) This is a processor device like the ProLiant Storage System. worm(6) This is a write-once, read-many times device. cd-rom(7) This is a CD or DVD device. scanner(8) This is a scanner device. optical(9) This is an optical memory device. jukeBox(10) This is a media changer device like a jukebox. commDev(11) This is a communications device like a LAN bridge.')
cpqScsiTargetModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetModel.setDescription("SCSI Device Model. This is a description of the device's model as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiTargetFWRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetFWRev.setDescription('SCSI Device Firmware Revision. This is the revision level of the device as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqScsiTargetVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetVendor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetVendor.setDescription("SCSI Device Vendor. This is the device vendor's name as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiTargetParityErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetParityErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetParityErrs.setDescription('SCSI Device Bus Parity Errors. This is the number of parity errors seen on the SCSI bus while processing commands for this SCSI ID. This value is maintained since the SCSI Hardware Interface driver was loaded. Parity errors may occasionally occur. If this value should rise dramatically, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqScsiTargetPhaseErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetPhaseErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetPhaseErrs.setDescription('SCSI Device Bus Phase Errors. This is the number of times the SCSI bus entered an invalid operating state while processing commands for the SCSI ID. This value is maintained since the SCSI Hardware Interface driver was loaded. If you see any phase errors you may have a problem. Phase errors can be caused by a device which is not operating correctly. If the phase errors continue to increase the device should be replaced.')
cpqScsiTargetSelectTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetSelectTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetSelectTimeouts.setDescription('SCSI Device Bus Select Time-outs. This is the number of times the controller attempted to start communications with a device by selecting it but the device did not respond. If you see any select time-outs you may have a problem. The device may have hung during operations. The SCSI controller will attempt to reset the device but if this value continues to increment you may need to power cycle the device.')
cpqScsiTargetMsgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetMsgRejects.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetMsgRejects.setDescription('SCSI Device Bus Message Rejects. This is the number of times the device rejected a command because it did not support the specified operation since the SCSI Hardware Interface driver was loaded. A large number for this object does not indicate a problem. It only shows that the device does not support certain advanced SCSI commands that the device driver issued.')
cpqScsiTargetNegPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetNegPeriod.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTargetNegPeriod.setDescription('SCSI Device Negotiated Period. This is the amount of time that was negotiated between the controller and the device as a synchronous transfer window. A synchronous transfer window is how long the device can transfer data without requiring an acknowledgment from the controller. In general the larger the negotiated period is, the lower the device throughput. This value is reported in quarters of nanoseconds.')
cpqScsiTargetLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("proliant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetLocation.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetLocation.setDescription('SCSI Device Location. This is the physical location of where the device is located. The following values are defined: other(1) The device is not located in any special product that identifies the location. proliant(2) The device is located in the ProLiant Storage System.')
cpqScsiTargetNegSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetNegSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetNegSpeed.setDescription('SCSI Device Negotiated Speed. This is the data transfer speed that was negotiated between the controller and the device. This value is reported in bits per second.')
cpqScsiTargetPhysWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("narrow", 2), ("wide16", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetPhysWidth.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetPhysWidth.setDescription("SCSI Device Data Bus Physical Width. This is the physical width of the device's SCSI data bus. other(1) The management agent does not recognize this width. You may need to upgrade your software. narrow(2) The SCSI device supports an 8-bit narrow SCSI data bus. wide16(3) The SCSI device supports a 16-bit wide SCSI data bus.")
cpqScsiTargetNegWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetNegWidth.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetNegWidth.setDescription("SCSI Device Data Bus Negotiated Width. This is the width of the device's SCSI data bus that was negotiated between the controller and the device. This value is reported in bits.")
cpqScsiTargetTypeExtended = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("pdcd", 2), ("removableDisk", 3), ("dltAutoloader", 4), ("cdJukebox", 5), ("cr3500", 6), ("autoloader", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetTypeExtended.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetTypeExtended.setDescription('SCSI Extended Device Type. This is additional information about the type of SCSI device. The following types are defined: other(1) This target does not have any extended type information. pdcd(2) This is a power-drive CD-ROM. removableDisk(3) This is a removable media disk device like a floppy drive. dltAutoloader(4) This is a tape library device. cdJukebox(5) This is a CD storage system device. cr3500(6) This is a CR3500 RAID SCSI controller. autoloader(7) This is an autoloader medium changer device.')
cpqScsiTargetCurrentSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("asynchronous", 2), ("fast", 3), ("ultra", 4), ("ultra2", 5), ("ultra3", 6), ("scsi1", 7), ("ultra4", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTargetCurrentSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiTargetCurrentSpeed.setDescription('SCSI Device Current Data Transfer Speed. The following values are defined: other(1) The agent is unable to determine the current negotiated data transfer speed for this drive. asynchronous(2) The negotiated data transfer speed for this drive is asynchronous. fast(3) The negotiated data transfer speed for this drive is 10 million transfers per second. ultra(4) The negotiated data transfer speed for this drive is 20 million transfers per second. ultra2(5) The negotiated data transfer speed for this drive is 40 million transfers per second. ultra3(6) The negotiated data transfer speed for this drive is 80 million transfers per second. scsi1(7) The negotiated data transfer speed for this drive is 5 million transfers per second. ultra4(8) The negotiated data transfer speed for this drive is 160 million transfers per second. Ultra4 is now referred to as Ultra320.')
cpqScsiCdDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1), )
if mibBuilder.loadTexts: cpqScsiCdDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvTable.setDescription('Scsi CD-ROM Drive Table.')
cpqScsiCdDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiCdDrvCntlrIndex"), (0, "CPQSCSI-MIB", "cpqScsiCdDrvBusIndex"), (0, "CPQSCSI-MIB", "cpqScsiCdDrvScsiIdIndex"), (0, "CPQSCSI-MIB", "cpqScsiCdDrvLunIndex"))
if mibBuilder.loadTexts: cpqScsiCdDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvEntry.setDescription('Scsi CD-ROM Drive Entry.')
cpqScsiCdDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvCntlrIndex.setDescription('SCSI CD-ROM Drive Controller Index. The controller index indicates to which SCSI adapter instance this CD table entry belongs. The controller index is the physical slot in the computer where the adapter is located.')
cpqScsiCdDrvBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvBusIndex.setDescription('SCSI CD-ROM Drive Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqScsiCdDrvScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvScsiIdIndex.setDescription('SCSI CD-ROM Drive Index. The CD-ROM drive index indicates to which CD-ROM drive instance on a SCSI bus this table entry belongs. The physical drive index is the SCSI ID being used by that CD drive.')
cpqScsiCdDrvLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvLunIndex.setDescription('SCSI CD-ROM Drive Logical Unit Index. The CD-ROM drive logical unit index indicates to which physical drive logical unit on a SCSI ID instance on a SCSI bus this table entry belongs. The CD-ROM drive Lun index is the logical unit number being used by that CD drive.')
cpqScsiCdDrvModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvModel.setDescription("SCSI CD Device Model. This is a description of the device's model as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiCdDrvVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvVendor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvVendor.setDescription("SCSI CD Drive Vendor. This is the CD drive vendor's name as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqScsiCdDrvFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiCdDrvFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqScsiCdDrvFwRev.setDescription('SCSI CD-ROM Firmware Revision. This is used to differentiate the firmware versions which have the same CD-ROM drive vendor and model (as specified by cpqScsiCdVendor and cpqScsiCdModel). This can be retrieved by the SCSI inquiry command. ')
cpqCdLibraryTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2), )
if mibBuilder.loadTexts: cpqCdLibraryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryTable.setDescription('CD Library Table.')
cpqCdLibraryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqCdLibraryCntlrIndex"), (0, "CPQSCSI-MIB", "cpqCdLibraryBusIndex"), (0, "CPQSCSI-MIB", "cpqCdLibraryScsiIdIndex"), (0, "CPQSCSI-MIB", "cpqCdLibraryLunIndex"))
if mibBuilder.loadTexts: cpqCdLibraryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryEntry.setDescription('CD Library Entry.')
cpqCdLibraryCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryCntlrIndex.setDescription('SCSI CD Library Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqCdLibraryBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryBusIndex.setDescription('SCSI CD Library Bus Index. The bus index indicates to which SCSI bus instance on an adapter card this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqCdLibraryScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryScsiIdIndex.setDescription('SCSI CD Library Device Index. The device index indicates to which device instance on a SCSI bus this table entry belongs. The device index is the SCSI ID being used by that device.')
cpqCdLibraryLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryLunIndex.setDescription('SCSI CD Library Logical Unit Index. The logical unit index indicates to which Lun device instance on a SCSI bus this table entry belongs. The logical unit index is the Lun being used by that device.')
cpqCdLibraryCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryCondition.setDescription('CD Library Condition. This value represents the overall condition of this CD Library. The library can be in one of the following states: other(1) The library is in a state other than one of those listed below. ok(2) Indicates that the library is in normal operation mode. No user action is necessary. degraded(3) Indicates that the library has degraded in some manner. failed(4) Indicates that the library has failed and can no longer return data. When convenient, you should bring down the server and run diagnostics to help identify the problem.')
cpqCdLibraryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3), ("offline", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryStatus.setDescription("CD Library Status. This value represents the status of this CD Library. The library can be in one of the following states: other(1) The library is in a state other than one of those listed below. ok(2) Indicates that the CD library fault light is in an 'ok' state. failed(3) Indicates that the CD library fault light is in a 'failed' state. The fault light is activated for hardware errors (Sense Code 04h) with additional Sense codes: 40h-4fh except the parity error. The LED will remain on until is powered cycled. offline(4) Indicates that the Insight Agents can no longer communicate with the CD library. This could be caused by a cabling problem or the CD library may be powered off.")
cpqCdLibraryModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryModel.setDescription("SCSI CD Library Device Model. This is a description of the device's model as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqCdLibraryVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryVendor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryVendor.setDescription("SCSI CD Library Vendor. This is the CD Library drive vendor's name as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqCdLibrarySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibrarySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibrarySerialNumber.setDescription('CD Library Serial Number. This is the unit serial number for the library. It can be used for identification purposes.')
cpqCdLibraryDriveList = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryDriveList.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryDriveList.setDescription('CD Library Drive List This is a data structure containing the list of CD drive ids that are present in this library. The format is: BYTE Controller Number BYTE Bus Number BYTE SCSI ID BYTE Logical Unit Number There will be 1 structure for each drive present in the library.')
cpqCdLibraryFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryFwRev.setDescription('SCSI CD Library Firmware Revision. This is used to differentiate the firmware versions which have the same CD library vendor and model (as specified in cpqCdLibraryVendor and cpqCdLibraryModel). This can be retrieved by the SCSI inquiry command. ')
cpqCdLibraryFwSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 2, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCdLibraryFwSubtype.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCdLibraryFwSubtype.setDescription('SCSI CD library Firmware Subtype. This is used to differentiate the firmware versions which have the same vendor and model. CD library will contain a value of 1 for this variable when they first ship, and this value will be incremented if future versions are shipped which are not firmware compatible with the predecessor. If the CD library does not support this capability, a value of 0 will be returned.')
cpqScsiTrapPkts = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTrapPkts.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapPkts.setDescription('The total number of trap packets issued by the SCSI enterprise since the instrument agent was loaded.')
cpqScsiTrapLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 5, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTrapLogMaxSize.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapLogMaxSize.setDescription('The maximum number of entries that will currently be kept in the trap log. If the maximum size has been reached and a new trap occurs the oldest trap will be removed.')
cpqScsiTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 3, 3), )
if mibBuilder.loadTexts: cpqScsiTrapLogTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapLogTable.setDescription('An ordered list of trap log entries (conceptually a queue). The trap log entries will be kept in the order in which they were generated with the most recent trap at index 1 and the oldest trap entry at index trapLogMaxSize. If the maximum number size has been reached and a new trap occurs the oldest trap will be removed when the new trap is added so the trapMaxLogSize is not exceeded.')
cpqScsiTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 3, 3, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqScsiTrapLogIndex"))
if mibBuilder.loadTexts: cpqScsiTrapLogEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapLogEntry.setDescription('A description of a trap event.')
cpqScsiTrapLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTrapLogIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapLogIndex.setDescription("The value of this object uniquely identifies this trapLogEntry at this time. The most recent trap will have an index of 1 and the oldest trap will have an index of trapLogMaxSize. Because of the queue-like nature of the trapLog this particular trap event's index will change as new traps are issued.")
cpqScsiTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5001, 5002, 5003))).clone(namedValues=NamedValues(("cpqScsiCntlrStatusChange", 1), ("cpqScsiLogDrvStatusChange", 2), ("cpqScsiPhyDrvStatusChange", 3), ("cpqScsi2CntlrStatusChange", 5001), ("cpqScsi2LogDrvStatusChange", 5002), ("cpqScsi2PhyDrvStatusChange", 5003)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTrapType.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapType.setDescription('The type of the trap event that this entry describes. This number refers to an entry in a list of traps enumerating the possible traps the SCSI agent may issue.')
cpqScsiTrapTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 3, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqScsiTrapTime.setStatus('deprecated')
if mibBuilder.loadTexts: cpqScsiTrapTime.setDescription('The time of the trap event that this entry describes. The time is given in year (first octet), month, day of month, hour, minute, second (last octet) order. Each octet gives the value in Binary Coded Decimal (BCD).')
cpqSbMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbMibRevMajor.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbMibRevMajor.setDescription('The Major Revision level. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqSbMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbMibRevMinor.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbMibRevMinor.setDescription('The Minor Revision level. A change in the minor revision level may represent some minor additional support; no changes to any pre-existing information has occurred.')
cpqSbDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 232, 7, 2, 2), )
if mibBuilder.loadTexts: cpqSbDeviceTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDeviceTable.setDescription('SCSI Drive Bus Table')
cpqSbDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqSbDevCntlrIndex"), (0, "CPQSCSI-MIB", "cpqSbDevBusIndex"), (0, "CPQSCSI-MIB", "cpqSbDevScsiIdIndex"))
if mibBuilder.loadTexts: cpqSbDeviceEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDeviceEntry.setDescription('SCSI Drive Bus Entry')
cpqSbDevCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevCntlrIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevCntlrIndex.setDescription('SCSI Device Bus Controller Index The controller index indicates which SCSI adapter card instance this table entry belongs to. The controller index is the physical slot in the computer system where the adapter card is located.')
cpqSbDevBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevBusIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevBusIndex.setDescription('SCSI Device Bus Index The bus index indicates which SCSI bus instance on an adapter card this table entry belongs to. The instances start at one and increment for each SCSI bus on a card.')
cpqSbDevScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevScsiIdIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevScsiIdIndex.setDescription('SCSI Device Bus Physical Drive Index The physical drive index indicates which physical drive instance on a SCSI bus this table entry belongs to. The physical drive index is the SCSI ID being used by that device.')
cpqSbDevType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("disk", 2), ("tape", 3), ("printer", 4), ("processor", 5), ("wormDrive", 6), ("cd-rom", 7), ("scanner", 8), ("optical", 9), ("jukeBox", 10), ("commDev", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevType.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevType.setDescription('SCSI Device Type This is the type of SCSI device. The following types are defined: other(1) The management agent does not recognize this type. You may need to upgrade you software. disk(2) This is a direct-access device like a disk drive. tape(3) This is a sequential-access device like a tape drive. printer(4) This is a printer device. processor(5) This is a processor device like the ProLiant Storage System. worm(6) This is a write-once, read-many times device. cd-rom(7) This is a CD-ROM, read-only device. scanner(8) This is a scanner device. optical(9) This is an optical memory device. jukeBox(10) This is a medium changer device like a jukebox. commDev(11) This is a communications device like a LAN bridge.')
cpqSbDevModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevModel.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevModel.setDescription("SCSI Device Model This is a description of the physical drive's model as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqSbDevFWRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevFWRev.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevFWRev.setDescription('SCSI Device Firmware Revision This is the revision level of the physical drive as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqSbDevVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevVendor.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevVendor.setDescription("SCSI Device Vendor. This is the physical drive vendor's name as returned by the SCSI inquiry command. This can be used for identification purposes.")
cpqSbDevParityErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevParityErrs.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevParityErrs.setDescription('SCSI Device Bus Parity Errors This is the number of parity errors seen on the SCSI bus while processing commands for this SCSI ID since the SCSI Interface Module was loaded. Parity errors may occasionally occur. If this value should rise dramatically, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqSbDevPhaseErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevPhaseErrs.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevPhaseErrs.setDescription('SCSI Device Bus Phase Errors This is the number of times the SCSI bus entered an invalid operating state while processing commands for the SCSI ID since the SCSI Hardware Interface driver was loaded. If you see any phase errors you may have a problem. Phase errors can be caused by a device which is not operating correctly. If the phase errors continue to increase the device should be replaced.')
cpqSbDevSelectTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevSelectTimeouts.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevSelectTimeouts.setDescription('SCSI Device Bus Select Time-outs This is the number of times the controller attempted to start communications with a device by selecting it but the device did not respond. If you see any select time-outs you may have a problem. The device may have hung during operations. The SCSI controller will attempt to reset the device but if this value continues to increment you may need to power cycle the device.')
cpqSbDevMsgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevMsgRejects.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevMsgRejects.setDescription('SCSI Device Bus Message Rejects This is the number of times the device rejected a command because it did not support the specified operation since the SCSI Hardware Interface driver was loaded. A large number for this object does not indicate a problem. It only shows that the device does not support certain advanced SCSI commands that the device driver issued.')
cpqSbDevNegPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevNegPeriod.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevNegPeriod.setDescription('SCSI Device Negotiated Period This is the amount of time that was negotiated between the controller and the device as a synchronous transfer window. A synchronous transfer window is how long the device can transfer data without requiring an acknowledgment from the controller. In general the larger the negotiated period is, the higher the device throughput.')
cpqSbDevLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 7, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("proliant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSbDevLocation.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSbDevLocation.setDescription('SCSI Device Location This is the physical location of where the device is located. The following values are defined: other(1) The drives are not located in any special product that identifies the location. proliant(2) The drives are located in the ProLiant Storage System.')
cpqTapePhyDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1), )
if mibBuilder.loadTexts: cpqTapePhyDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvTable.setDescription('Tape Physical Drive Table.')
cpqTapePhyDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqTapePhyDrvCntlrIndex"), (0, "CPQSCSI-MIB", "cpqTapePhyDrvBusIndex"), (0, "CPQSCSI-MIB", "cpqTapePhyDrvScsiIdIndex"), (0, "CPQSCSI-MIB", "cpqTapePhyDrvLunIndex"))
if mibBuilder.loadTexts: cpqTapePhyDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvEntry.setDescription('Tape Physical Drive Entry.')
cpqTapePhyDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvCntlrIndex.setDescription('Tape Physical Drive Controller Index. The controller index indicates to which SCSI adapter instance this tape table entry belongs. The controller index is the physical slot in the computer where the adapter is located.')
cpqTapePhyDrvBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvBusIndex.setDescription('Tape Physical Drive Bus Index. The bus index indicates to which SCSI bus instance on an adapter this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqTapePhyDrvScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvScsiIdIndex.setDescription('Tape Physical Drive Index. The physical drive index indicates to which physical drive instance on a SCSI bus this table entry belongs. The physical drive index is the SCSI ID being used by that tape drive.')
cpqTapePhyDrvLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvLunIndex.setDescription('Tape Physical Drive Logical Unit Index. The physical drive logical unit index indicates to which physical drive logical unit on a SCSI ID instance on a SCSI bus this table entry belongs. The physical drive Lun index is the logical unit number being used by that tape drive.')
cpqTapePhyDrvType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("other", 1), ("cpqDat4-16", 2), ("cpqDatAuto", 3), ("cpqDat2-8", 4), ("cpqDlt10-20", 5), ("cpqDlt20-40", 6), ("cpqDlt15-30", 7), ("cpqDlt35-70", 8), ("cpqDat4-8", 9), ("cpqSlr4-8", 10), ("cpqDat12-24", 11), ("cpqDatAuto12-24", 12), ("cpqMlr16-32", 13), ("cpqAit35", 14), ("cpqAit50", 15), ("cpqDat20-40", 16), ("cpqDlt40-80", 17), ("cpqDatAuto20-40", 18), ("cpqSuperDlt1", 19), ("cpqAit35Lvd", 20), ("cpqCompaq", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvType.setDescription('Tape Device Type. This is the drives model, and can be used for identification purposes. The following values are defined: other(1) The management agent does not recognize this model. You may need to upgrade your software. cpqDat4-16(2) Compaq 4/8-Gigabyte TurboDAT Drive. cpqDatAuto(3) Compaq TurboDAT Autoloader. cpqDat2-8(4) Compaq 2/8-Gigabyte TurboDAT Drive. cpqDlt10-20(5) Compaq 10/20-GB DLT Drive. cpqDlt20-40(6) Compaq 20/40-GB DLT Drive. cpqDlt15-30(7) Compaq 15/30-GB DLT Drive. cpqDlt35-70(8) Compaq 35/70-GB DLT Drive. cpqDat4-8(9) Compaq 4/8-GB DAT Drive. cpqSlr4-8(10) Compaq 4/8-GB SLR Drive. cpqDat12-24(11) Compaq 12/24-GB DAT Drive. cpqDatAuto12-24(12) Compaq 12/24-GB DAT Autoloader. cpqMlr16-32(13) Compaq 16/32-GB MLR Drive. cpqAit35(14) Compaq AIT 35GB Drive. cpqAit50(15) Compaq AIT 50GB Drive. cpqDat20-40(16) Compaq 20/40GB DAT Drive. cpqDlt40-80(17) Compaq 40/80GB DLT Drive. cpqDatAuto20-40(18) Compaq 20/40GB DAT Autoloader. cpqSuperDlt1(19) Compaq 100GB Super DLT Drive. cpqAit35Lvd(20) Compaq AIT 35 LVD Drive. cpqCompaq(21) Supported Tape Drive.')
cpqTapePhyDrvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvCondition.setDescription('Tape Physical Drive Status. The physical drive can be in one of the following states: other(1) The drive is in a state other than one of those listed below. ok(2) Indicates that the physical drive is in normal operation mode. No user action is necessary. degraded(3) Indicates that the physical drive has degraded in some manner. failed(4) Indicates that the physical drive has failed and can no longer return data. When convenient, you should bring down the server and run diagnostics to help identify the problem. The drive may need to be replaced.')
cpqTapePhyDrvMagSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvMagSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvMagSize.setDescription('Tape Physical Drive Magazine Size. The number of tape slots available in the magazine cartridge that is currently loaded into the tape drive. For non-autoloader devices, this value will be 1.')
cpqTapePhyDrvSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvSerialNumber.setDescription('Tape Physical Drive Serial Number. This is the unit serial number for the tape drive. It can be used for identification purposes.')
cpqTapePhyDrvCleanReq = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvCleanReq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvCleanReq.setDescription('Tape Physical Drive Cleaning Required Status. This is an indication of whether the tape drive heads require a cleaning session to occur. If this variable indicates a need to clean the tape heads, then a cleaning tape will need to be inserted and run through a cleaning cycle. This variable can be in one of the following states: other(1) The tape drive does not support monitoring of the cleaning required status. true(2) The tape drive requires a cleaning tape session in order to clean the heads. false(3) The tape drive does not require any cleaning tape session.')
cpqTapePhyDrvCleanTapeRepl = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvCleanTapeRepl.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvCleanTapeRepl.setDescription('Tape Physical Drive Cleaning Tape Replacement Status. This variable is only applicable to autoloader tape drives. This variable indicates whether the cleaning tape which is inserted in an autoloader needs to be replaced because its cleaning capability is exhausted (it is at end of tape). This variable can be in one of the following states: other(1) The tape drive does not support monitoring of the cleaning tape replacement status. true(2) The autoloader tape drive requires a new cleaning tape to be inserted. false(3) The tape drive does not require a new cleaning tape.')
cpqTapePhyDrvFwSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvFwSubtype.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvFwSubtype.setDescription('Tape Physical Drive Firmware Subtype. This is used to differentiate the firmware versions which have the same tape drive type (as specified by cpqTapePhyDrvType). Tape drives will contain a value of 1 for this variable when they first ship, and this value will be incremented if future versions are shipped which are not firmware compatible with the predecessor. If the tape drive does not support this capability, a value of 0 will be returned.')
cpqTapePhyDrvName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvName.setDescription('Tape Physical Drive Name. This is a combination of the vendor ID and the product ID as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqTapePhyDrvCleanTapeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvCleanTapeCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvCleanTapeCount.setDescription('Tape Physical Drive Cleaning Tape Count. This variable is only applicable to autoloader tape drives. This variable is a count from a tape drive of the number of cleanings done by the tape cleaner last in the drive.')
cpqTapePhyDrvFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvFwRev.setDescription('Tape Physical Drive Firmware Revision. This is the revision level of the physical drive as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqTapePhyDrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 4), ("offline", 5), ("missingWasOk", 6), ("missingWasFailed", 7), ("missingWasOffline", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvStatus.setDescription('Tape Physical Drive Status. The tape physical drive can be in one of the following states: other(1) The tape drive is in a state other than one of those listed below. ok(2) Indicates that the tape physical drive is in normal operation mode. No user action is necessary. failed(4) Indicates that the tape physical drive has failed and can no longer return data. The drive may need to be replaced. offline(5) Indicates that the tape physical drive is offline and can no longer return data. No further status is available. missingWasOk(6) Indicates that a tape physical drive had a status of OK and is no longer present. The drive has been removed. missingWasFailed(7) Indicates that a tape physical drive had a status of FAILED and is no longer present. The drive has been removed. missingWasOffline(8) Indicates that a tape physical drive had a status of OFFLINE and is no longer present. The drive has been removed.')
cpqTapePhyDrvHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("hotPlug", 2), ("nonHotPlug", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvHotPlug.setDescription('Tape Physical Drive Hot Plug Support Status. The following values are defined: other(1) The agent is unable to determine if this drive supports hot plug replacement. hotPlug(2) The drive supports hot plug replacement. nonhotPlug(3) The drive does not support hot plug replacement.')
cpqTapePhyDrvPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvPlacement.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvPlacement.setDescription('Tape Physical Drive Placement. The following values are defined: other(1) The agent is unable to determine if the tape drive is internal or external to the system chassis. internal(2) The tape drive is located in an internal Proliant system chassis. external(3) The tape drive is located in an external Proliant storage system.')
cpqTapePhyDrvLibraryDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvLibraryDrive.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvLibraryDrive.setDescription('Tape Physical Drive Library Drive. This variable indicates whether or not the tape drive is part of a tape library. It can be in one of the following states: other(1) Indicates that the storage agents cannot determine if the tape drive is part of a tape library. true(2) The tape drive is part of a tape library. false(3) The tape drive is not part of a tape library.')
cpqTapePhyDrvLoaderName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderName.setDescription('Tape Autoloader Name. This is a combination of the vendor ID and the product ID as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqTapePhyDrvLoaderFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderFwRev.setDescription('Tape Autoloader Firmware Revision. This is the firmware revision level of the autoloader as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqTapePhyDrvLoaderSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 1, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapePhyDrvLoaderSerialNum.setDescription('Tape Autoloader Serial Number. This is the autoloader serial number. It can be used for identification purposes.')
cpqTapeCountersTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1), )
if mibBuilder.loadTexts: cpqTapeCountersTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersTable.setDescription('Tape Counters Table.')
cpqTapeCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqTapeCountersCntlrIndex"), (0, "CPQSCSI-MIB", "cpqTapeCountersBusIndex"), (0, "CPQSCSI-MIB", "cpqTapeCountersScsiIdIndex"), (0, "CPQSCSI-MIB", "cpqTapeCountersLunIndex"))
if mibBuilder.loadTexts: cpqTapeCountersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersEntry.setDescription('Tape Counters Entry.')
cpqTapeCountersCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersCntlrIndex.setDescription('SCSI Counters Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqTapeCountersBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersBusIndex.setDescription('SCSI Counters Bus Index. The bus index indicates to which SCSI bus instance on an adapter card this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqTapeCountersScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersScsiIdIndex.setDescription('SCSI Counters Device Index. The device index indicates to which device instance on a SCSI bus this table entry belongs. The device index is the SCSI ID being used by that device.')
cpqTapeCountersLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersLunIndex.setDescription('SCSI Counters Logical Unit Index. The logical unit index indicates to which Lun device instance on a SCSI bus this table entry belongs. The logical unit index is the Lun being used by that device.')
cpqTapeCountersReWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersReWrites.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersReWrites.setDescription('Tape Device Re-write count. This is the number of times blocks had to be re-written to the device. This value is maintained since the Tape Hardware Interface driver was loaded. Re-write errors may occasionally occur. If this value should rise dramatically, you may need to clean the device. If you continue to have re-writes, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqTapeCountersReReads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersReReads.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersReReads.setDescription('Tape Device Re-read count. This is the number of times blocks had to be re-read from the device. This value is maintained since the Tape Hardware Interface driver was loaded. Re-read errors may occasionally occur. If this value should rise dramatically, you may need to clean the device. If you continue to have re-reads, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqTapeCountersTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersTotalErrors.setDescription('Tape Device Total Errors. This is the total number of read/write errors encountered. This value is maintained since the Tape Hardware Interface driver was loaded. Errors may occasionally occur. If this value should rise dramatically, you may need to clean the device. If you continue to have errors, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqTapeCountersTotalUncorrectable = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersTotalUncorrectable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersTotalUncorrectable.setDescription('Tape Device Total Uncorrectable Errors. This is the total number of read and write errors which could not be corrected. This value is maintained since the Tape Hardware Interface driver was loaded. Errors may occasionally occur. If this value should rise dramatically, you may need to clean the device. If you continue to have errors, you may have a problem. Some common causes include radio frequency interference (RFI) on the bus cables, bad or missing terminating resisters on the drives or having more than one device with the same SCSI ID. Insure the bus cable is free of obstructions and that the devices on the bus are properly configured.')
cpqTapeCountersTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeCountersTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeCountersTotalBytes.setDescription('Tape Device Total Bytes. This is the number total number of bytes read/written to the tape currently installed in the device. This value is reset whenever a new tape is inserted into the device.')
cpqTapeLibraryTable = MibTable((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1), )
if mibBuilder.loadTexts: cpqTapeLibraryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryTable.setDescription('Tape Library Table.')
cpqTapeLibraryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1), ).setIndexNames((0, "CPQSCSI-MIB", "cpqTapeLibraryCntlrIndex"), (0, "CPQSCSI-MIB", "cpqTapeLibraryBusIndex"), (0, "CPQSCSI-MIB", "cpqTapeLibraryScsiIdIndex"), (0, "CPQSCSI-MIB", "cpqTapeLibraryLunIndex"))
if mibBuilder.loadTexts: cpqTapeLibraryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryEntry.setDescription('Tape Library Entry.')
cpqTapeLibraryCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryCntlrIndex.setDescription('SCSI Library Controller Index. The controller index indicates to which SCSI adapter instance this table entry belongs. The controller index is the physical slot in the computer system where the adapter is located.')
cpqTapeLibraryBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryBusIndex.setDescription('SCSI Library Bus Index. The bus index indicates to which SCSI bus instance on an adapter card this table entry belongs. The instances start at one and increment for each SCSI bus on a card.')
cpqTapeLibraryScsiIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryScsiIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryScsiIdIndex.setDescription('SCSI Library Device Index. The device index indicates to which device instance on a SCSI bus this table entry belongs. The device index is the SCSI ID being used by that device.')
cpqTapeLibraryLunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryLunIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryLunIndex.setDescription('SCSI Library Logical Unit Index. The logical unit index indicates to which Lun device instance on a SCSI bus this table entry belongs. The logical unit index is the Lun being used by that device.')
cpqTapeLibraryCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryCondition.setDescription('Tape Library Status. The library can be in one of the following states: other(1) The library is in a state other than one of those listed below. ok(2) Indicates that the library is in normal operation mode. No user action is necessary. degraded(3) Indicates that the library has degraded in some manner. failed(4) Indicates that the library has failed and can no longer return data. When convenient, you should bring down the server and run diagnostics to help identify the problem. The library may need to be replaced.')
cpqTapeLibraryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryStatus.setDescription('Error code returned by the last library error.')
cpqTapeLibraryDoorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("closed", 2), ("open", 3), ("notSupported", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryDoorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryDoorStatus.setDescription('Status of the library door. The door can be in one of the following states: other(1) The door is in a state other than one of those listed below. closed(2) The door is closed. open(3) The door is open. notSupported(4) The door status is not supported by the device.')
cpqTapeLibraryStatHours = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryStatHours.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryStatHours.setDescription('The number of hours of operation for the library.')
cpqTapeLibraryStatMoves = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryStatMoves.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryStatMoves.setDescription('The number of tape moves for the library loader arm.')
cpqTapeLibraryName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryName.setDescription('Tape Library Name.')
cpqTapeLibrarySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibrarySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibrarySerialNumber.setDescription('Tape Library Serial Number. This is the unit serial number for the library. It can be used for identification purposes.')
cpqTapeLibraryDriveList = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 320))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryDriveList.setStatus('deprecated')
if mibBuilder.loadTexts: cpqTapeLibraryDriveList.setDescription('Tape Library Drive List This is a data structure containing the list of tape drive ids that are present in this library. The format is: BYTE Controller Number BYTE Bus Number BYTE SCSI ID BYTE Logical Unit Number There will be 1 structure for each drive present in the library.')
cpqTapeLibraryState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4), ("offline", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryState.setDescription('Tape Library Status. The library can be in one of the following states: other(1) The library is in a state other than one of those listed below. ok(2) Indicates that the library is in normal operation mode. No user action is necessary. degraded(3) Indicates that the library has degraded in some manner. failed(4) Indicates that the library has failed and can no longer return data. When convenient, you should bring down the server and run diagnostics to help identify the problem. The library may need to be replaced. offline(5) Indicates that the Insight Agents can no longer communicate with the library. This could be caused by a cabling problem or the library may be powered off.')
cpqTapeLibraryTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("ok", 3), ("safeTempExceeded", 4), ("maxTempExceeded", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryTemperature.setDescription('Tape Library Temperature Status. The library temperature can be in one of the following states: other(1) The library temperature status is unknown. notSupported(2) Indicates that the library cannot detect or report temperature. ok(3) Indicates that the temperature of the library is within normal operating limits. safeTempExceeded(4) Indicates that the temperature of the library has exceeded the safe operational temperature. The library will continue to operate under this warning. maxTempExceeded(5) Indicates that the temperature of the library has exceeded normal operating limits to the extent that the library may no longer function.')
cpqTapeLibraryRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("capable", 3), ("notCapable", 4), ("active", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryRedundancy.setDescription('Tape Library Redundancy Status. Redundancy status denotes the presence of internal redundant components such as fans, power supplies, etc. The library redundancy can be in one of the following states: other(1) The library redundancy status is unknown. notSupported(2) Indicates that the library cannot detect or report redundancy status. capable(3) Indicates that the library is capable of detecting and reporting redundant components but there are not enough redundant units installed to make redundancy active. notCapable(4) Indicates that the library is capable of detecting and reporting redundant components but there are no components that support redundancy. active(5) Indicates that the library is capable of detecting and reporting redundant components, there are enough redundant units installed, and redundancy is active.')
cpqTapeLibraryHotSwap = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("capable", 3), ("notCapable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryHotSwap.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryHotSwap.setDescription('Tape Library Hot Swap Status. Hot swap status denotes the presence of hot swappable internal components such as drives, fans, power supplies, etc. The library hot swap status can be in one of the following states: other(1) The library hot swap status is unknown. notSupported(2) Indicates that the library cannot detect or report hot swap status. capable(3) Indicates that the library is capable of detecting and reporting hot swappable internal components and has at least one hot swappable component. notCapable(4) Indicates that the library is capable of detecting and reporting hot swappable internal components but there are no hot swappable components installed.')
cpqTapeLibraryFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryFwRev.setDescription('Tape Library Firmware Revision. This is the revision level of the tape library firmware as returned by the SCSI inquiry command. This can be used for identification purposes.')
cpqTapeLibraryTapeList = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 5, 4, 3, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 560))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqTapeLibraryTapeList.setStatus('mandatory')
if mibBuilder.loadTexts: cpqTapeLibraryTapeList.setDescription('Tape Library Drive List This is a data structure containing the list of tape drive ids that are present in this library. The format is: ULONG Controller Number BYTE Bus Number BYTE SCSI ID BYTE Logical Unit Number There will be 1 structure for each drive present in the library.')
cpqScsiCntlrStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232, 5) + (0,1)).setObjects(("CPQSCSI-MIB", "cpqScsiCntlrStatus"))
if mibBuilder.loadTexts: cpqScsiCntlrStatusChange.setDescription('SCSI Controller Status Change. The Insight Agent has detected a change in the controller status of a SCSI Controller. The variable cpqScsiCntlrStatus indicates the current controller status.')
cpqScsiLogDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232, 5) + (0,2)).setObjects(("CPQSCSI-MIB", "cpqScsiLogDrvStatus"))
if mibBuilder.loadTexts: cpqScsiLogDrvStatusChange.setDescription('Logical Drive Status Change. The Insight Agent has detected a change in the Logical Drive Status of a SCSI logical drive. The current logical drive status is indicated by the cpqScsiLogDrvStatus variable.')
cpqScsiPhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232, 5) + (0,3)).setObjects(("CPQSCSI-MIB", "cpqScsiPhyDrvStatus"))
if mibBuilder.loadTexts: cpqScsiPhyDrvStatusChange.setDescription('Physical Drive Status Change. The Insight Agent has detected a change in the status of a SCSI physical drive. The current physical drive status is indicated in the cpqScsiPhyDrvStatus variable.')
cpqScsi2CntlrStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5001)).setObjects(("CPQSCSI-MIB", "cpqScsiCntlrStatus"))
if mibBuilder.loadTexts: cpqScsi2CntlrStatusChange.setDescription('SCSI Controller Status Change. The Insight Agent has detected a change in the controller status of a SCSI Controller. The variable cpqScsiCntlrStatus indicates the current controller status.')
cpqScsi2LogDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5002)).setObjects(("CPQSCSI-MIB", "cpqScsiLogDrvStatus"))
if mibBuilder.loadTexts: cpqScsi2LogDrvStatusChange.setDescription('Logical Drive Status Change. The Insight Agent has detected a change in the Logical Drive Status of a SCSI logical drive. The current logical drive status is indicated by the cpqScsiLogDrvStatus variable.')
cpqScsi2PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5003)).setObjects(("CPQSCSI-MIB", "cpqScsiPhyDrvStatus"))
if mibBuilder.loadTexts: cpqScsi2PhyDrvStatusChange.setDescription('Physical Drive Status Change. The Insight Agent has detected a change in the status of a SCSI physical drive. The current physical drive status is indicated in the cpqScsiPhyDrvStatus variable.')
cpqTapePhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5004)).setObjects(("CPQSCSI-MIB", "cpqTapePhyDrvCondition"))
if mibBuilder.loadTexts: cpqTapePhyDrvStatusChange.setDescription('Tape Drive Status Change. The Insight Agent has detected a change in the status of a Tape drive. The current physical drive status is indicated in the cpqTapePhyDrvCondition variable.')
cpqScsi3CntlrStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5005)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqScsiCntlrStatus"))
if mibBuilder.loadTexts: cpqScsi3CntlrStatusChange.setDescription('SCSI Controller Status Change. The Insight Agent has detected a change in the controller status of a SCSI Controller. The variable cpqScsiCntlrStatus indicates the current controller status.')
cpqScsi3PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5006)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqScsiPhyDrvStatus"))
if mibBuilder.loadTexts: cpqScsi3PhyDrvStatusChange.setDescription('Physical Drive Status Change. The Insight Agent has detected a change in the status of a SCSI physical drive. The current physical drive status is indicated in the cpqScsiPhyDrvStatus variable.')
cpqTape3PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5007)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapePhyDrvCondition"))
if mibBuilder.loadTexts: cpqTape3PhyDrvStatusChange.setDescription('Tape Drive Status Change. The Insight Agent has detected a change in the status of a Tape drive. The current physical drive status is indicated in the cpqTapePhyDrvCondition variable.')
cpqTape3PhyDrvCleaningRequired = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5008)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapePhyDrvCondition"))
if mibBuilder.loadTexts: cpqTape3PhyDrvCleaningRequired.setDescription('Tape Drive Cleaning Required trap. The Insight Agent has detected a tape drive that needs to have a cleaning tape inserted and run. This will cause the tape drive heads to be cleaned.')
cpqTape3PhyDrvCleanTapeReplace = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5009)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapePhyDrvCondition"))
if mibBuilder.loadTexts: cpqTape3PhyDrvCleanTapeReplace.setDescription('Tape Drive Cleaning Tape Needs Replacing. The Insight Agent has detected that an autoloader tape unit has a cleaning tape that has been fully used and therefore needs to be replaced with a new cleaning tape.')
cpqTape3LibraryFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5010)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"))
if mibBuilder.loadTexts: cpqTape3LibraryFailed.setDescription('Tape Library Error The Insight Agent has detected that an autoloader unit has an encountered an error.')
cpqTape3LibraryOkay = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5011)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"))
if mibBuilder.loadTexts: cpqTape3LibraryOkay.setDescription('Tape Library Okay The Insight Agent has detected that an autoloader unit has recovered from errors.')
cpqTape3LibraryDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5012)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"))
if mibBuilder.loadTexts: cpqTape3LibraryDegraded.setDescription('Tape Library Degraded The Insight Agent has detected that an autoloader unit is in a degraded condition.')
cpqTape3LibraryDoorOpen = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5013)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"))
if mibBuilder.loadTexts: cpqTape3LibraryDoorOpen.setDescription('Tape Library Door Open The Insight Agent has detected that the door on an autoloader is open so the unit is not operational.')
cpqTape3LibraryDoorClosed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5014)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"))
if mibBuilder.loadTexts: cpqTape3LibraryDoorClosed.setDescription('Tape Library Door Closed The Insight Agent has detected that the door on a an autoloader has closed.')
cpqScsiCdLibraryStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5015)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqCdLibraryCntlrIndex"), ("CPQSCSI-MIB", "cpqCdLibraryBusIndex"), ("CPQSCSI-MIB", "cpqCdLibraryScsiIdIndex"), ("CPQSCSI-MIB", "cpqCdLibraryStatus"))
if mibBuilder.loadTexts: cpqScsiCdLibraryStatusChange.setDescription('CD Library Status Change. The Insight Agent has detected a change in the status of a CD Library device. The current CD Library status is indicated in the cpqScsiCdLibraryCondition variable.')
cpqTape4PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5016)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapePhyDrvCntlrIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvBusIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvScsiIdIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvStatus"))
if mibBuilder.loadTexts: cpqTape4PhyDrvStatusChange.setDescription('Tape Drive Status Change. The Storage Agent has detected a change in the status of a Tape drive. The current physical drive status is indicated in the cpqTapePhyDrvStatus variable.')
cpqScsi4PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5017)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqScsiPhyDrvStatus"), ("CPQSCSI-MIB", "cpqScsiPhyDrvCntlrIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvBusIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvVendor"), ("CPQSCSI-MIB", "cpqScsiPhyDrvModel"), ("CPQSCSI-MIB", "cpqScsiPhyDrvFWRev"), ("CPQSCSI-MIB", "cpqScsiPhyDrvSerialNum"))
if mibBuilder.loadTexts: cpqScsi4PhyDrvStatusChange.setDescription('Physical Drive Status Change. The Storage Agent has detected a change in the status of a SCSI physical drive. The current physical drive status is indicated in the cpqScsiPhyDrvStatus variable.')
cpqTapeLibraryStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5018)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapeLibraryCntlrIndex"), ("CPQSCSI-MIB", "cpqTapeLibraryBusIndex"), ("CPQSCSI-MIB", "cpqTapeLibraryScsiIdIndex"), ("CPQSCSI-MIB", "cpqTapeLibraryLunIndex"), ("CPQSCSI-MIB", "cpqTapeLibraryName"), ("CPQSCSI-MIB", "cpqTapeLibraryFwRev"), ("CPQSCSI-MIB", "cpqTapeLibrarySerialNumber"), ("CPQSCSI-MIB", "cpqTapeLibraryState"))
if mibBuilder.loadTexts: cpqTapeLibraryStatusChange.setDescription('Tape Library Status Change The Storage Agent has detected a change in the status of a tape library. The current tape library status is indicated in the cpqTapeLibraryState variable.')
cpqTape5PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5019)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqTapePhyDrvCntlrIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvBusIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvScsiIdIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvLunIndex"), ("CPQSCSI-MIB", "cpqTapePhyDrvName"), ("CPQSCSI-MIB", "cpqTapePhyDrvFwRev"), ("CPQSCSI-MIB", "cpqTapePhyDrvSerialNumber"), ("CPQSCSI-MIB", "cpqTapePhyDrvStatus"))
if mibBuilder.loadTexts: cpqTape5PhyDrvStatusChange.setDescription('Tape Drive Status Change. The Storage Agent has detected a change in the status of a tape drive. The current physical drive status is indicated in the cpqTapePhyDrvStatus variable.')
cpqScsi5PhyDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5020)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqScsiPhyDrvStatus"), ("CPQSCSI-MIB", "cpqScsiPhyDrvCntlrIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvBusIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvIndex"), ("CPQSCSI-MIB", "cpqScsiPhyDrvVendor"), ("CPQSCSI-MIB", "cpqScsiPhyDrvModel"), ("CPQSCSI-MIB", "cpqScsiPhyDrvFWRev"), ("CPQSCSI-MIB", "cpqScsiPhyDrvSerialNum"), ("CPQSCSI-MIB", "cpqScsiPhyDrvOsName"))
if mibBuilder.loadTexts: cpqScsi5PhyDrvStatusChange.setDescription('Physical Drive Status Change. The Storage Agent has detected a change in the status of a SCSI physical drive. The current physical drive status is indicated in the cpqScsiPhyDrvStatus variable.')
cpqScsi3LogDrvStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,5021)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSCSI-MIB", "cpqScsiLogDrvStatus"), ("CPQSCSI-MIB", "cpqScsiLogDrvCntlrIndex"), ("CPQSCSI-MIB", "cpqScsiLogDrvBusIndex"), ("CPQSCSI-MIB", "cpqScsiLogDrvIndex"), ("CPQSCSI-MIB", "cpqScsiLogDrvOsName"))
if mibBuilder.loadTexts: cpqScsi3LogDrvStatusChange.setDescription('Logical Drive Status Change. The Storage Agent has detected a change in the status of a SCSI logical drive. The current logical drive status is indicated in the cpqScsiLogDrvStatus variable.')
mibBuilder.exportSymbols("CPQSCSI-MIB", cpqTapePhyDrvLoaderFwRev=cpqTapePhyDrvLoaderFwRev, cpqTapePhyDrvName=cpqTapePhyDrvName, cpqScsiLogDrvStatEntry=cpqScsiLogDrvStatEntry, cpqScsiPhyDrvFuncTest2=cpqScsiPhyDrvFuncTest2, cpqCdLibraryFwSubtype=cpqCdLibraryFwSubtype, cpqScsiCdDrvBusIndex=cpqScsiCdDrvBusIndex, cpqTapeLibraryTable=cpqTapeLibraryTable, cpqScsiLogDrvCondition=cpqScsiLogDrvCondition, cpqScsiPhyDrvLocation=cpqScsiPhyDrvLocation, cpqScsiPhyDrvMemberLogDrv=cpqScsiPhyDrvMemberLogDrv, cpqScsiNw3xCntlrIndex=cpqScsiNw3xCntlrIndex, cpqScsiTargetBusIndex=cpqScsiTargetBusIndex, cpqScsiCntlrSlot=cpqScsiCntlrSlot, cpqTapeLibraryLunIndex=cpqTapeLibraryLunIndex, cpqScsiPhyDrvBusIndex=cpqScsiPhyDrvBusIndex, cpqScsiPhyDrvSpinupTime=cpqScsiPhyDrvSpinupTime, cpqTapeLibraryScsiIdIndex=cpqTapeLibraryScsiIdIndex, cpqSbDevNegPeriod=cpqSbDevNegPeriod, cpqScsiLogDrvStatusChange=cpqScsiLogDrvStatusChange, cpqSbDevType=cpqSbDevType, cpqScsiPhyDrvStatus=cpqScsiPhyDrvStatus, cpqScsiCntlrBusIndex=cpqScsiCntlrBusIndex, cpqSbMibRevMajor=cpqSbMibRevMajor, cpqScsiCntlrEntry=cpqScsiCntlrEntry, cpqScsiNw3xStatLogDrvIndex=cpqScsiNw3xStatLogDrvIndex, cpqScsiCntlrHardResets=cpqScsiCntlrHardResets, cpqScsiOsCommonModulePurpose=cpqScsiOsCommonModulePurpose, cpqScsiTargetTypeExtended=cpqScsiTargetTypeExtended, cpqScsiCdDrvVendor=cpqScsiCdDrvVendor, cpqScsiLogDrvPhyDrvIDs=cpqScsiLogDrvPhyDrvIDs, cpqScsiCntlrFWVers=cpqScsiCntlrFWVers, cpqScsiCntlrStatus=cpqScsiCntlrStatus, cpqCdLibraryModel=cpqCdLibraryModel, cpqSbDevBusIndex=cpqSbDevBusIndex, cpqTapeLibraryStatMoves=cpqTapeLibraryStatMoves, cpqScsiCdDrvScsiIdIndex=cpqScsiCdDrvScsiIdIndex, cpqTapeLibraryHotSwap=cpqTapeLibraryHotSwap, cpqScsiTargetMsgRejects=cpqScsiTargetMsgRejects, cpqScsiNw3xFatalWrites=cpqScsiNw3xFatalWrites, cpqScsiVolMapEntry=cpqScsiVolMapEntry, cpqCdLibraryTable=cpqCdLibraryTable, cpqScsiPhyDrvParent=cpqScsiPhyDrvParent, cpqScsiLogDrvBusIndex=cpqScsiLogDrvBusIndex, cpqScsiInterface=cpqScsiInterface, cpqScsiPhyDrvEccCorrReads=cpqScsiPhyDrvEccCorrReads, cpqSbDeviceEntry=cpqSbDeviceEntry, cpqScsiCdDrvModel=cpqScsiCdDrvModel, cpqScsiPhyDrvSectorSize=cpqScsiPhyDrvSectorSize, cpqScsiCntlrTable=cpqScsiCntlrTable, cpqScsiCdLibraryStatusChange=cpqScsiCdLibraryStatusChange, cpqScsiLogDrvStatus=cpqScsiLogDrvStatus, cpqScsiNw3xStatBusIndex=cpqScsiNw3xStatBusIndex, cpqScsiMibRevMajor=cpqScsiMibRevMajor, cpqTape3LibraryDegraded=cpqTape3LibraryDegraded, cpqTapeLibraryCondition=cpqTapeLibraryCondition, cpqSbDevPhaseErrs=cpqSbDevPhaseErrs, cpqTapeLibraryFwRev=cpqTapeLibraryFwRev, cpqSbDeviceTable=cpqSbDeviceTable, cpqScsiPhyDrvHardWriteErrs=cpqScsiPhyDrvHardWriteErrs, cpqTapeCountersReWrites=cpqTapeCountersReWrites, cpqCdLibraryEntry=cpqCdLibraryEntry, cpqScsiPhyDrvModel=cpqScsiPhyDrvModel, cpqTapeLibraryTapeList=cpqTapeLibraryTapeList, cpqScsiPhyDrvOsName=cpqScsiPhyDrvOsName, cpqTapeLibraryDoorStatus=cpqTapeLibraryDoorStatus, cpqScsiNw3xCntlrInfoEntry=cpqScsiNw3xCntlrInfoEntry, cpqTapeLibraryBusIndex=cpqTapeLibraryBusIndex, cpqScsiCntlrStatusChange=cpqScsiCntlrStatusChange, cpqScsi4PhyDrvStatusChange=cpqScsi4PhyDrvStatusChange, cpqTapeLibraryCntlrIndex=cpqTapeLibraryCntlrIndex, cpqScsiTrapLogIndex=cpqScsiTrapLogIndex, cpqSbMibRevMinor=cpqSbMibRevMinor, cpqTapeCountersTable=cpqTapeCountersTable, cpqTapeLibraryStatus=cpqTapeLibraryStatus, cpqTapePhyDrvCondition=cpqTapePhyDrvCondition, cpqScsiPhyDrvIndex=cpqScsiPhyDrvIndex, cpqScsiCntlrModelExtended=cpqScsiCntlrModelExtended, cpqScsiPhyDrvEntry=cpqScsiPhyDrvEntry, cpqTapeCountersBusIndex=cpqTapeCountersBusIndex, cpqScsiLogDrvSize=cpqScsiLogDrvSize, cpqTape3PhyDrvCleaningRequired=cpqTape3PhyDrvCleaningRequired, cpqSbDevice=cpqSbDevice, cpqScsiNw3xDriverName=cpqScsiNw3xDriverName, cpqScsi=cpqScsi, cpqSbDevMsgRejects=cpqSbDevMsgRejects, cpqSbDevParityErrs=cpqSbDevParityErrs, cpqScsiPhyDrvVendor=cpqScsiPhyDrvVendor, cpqScsiPhyDrvLowReadSectors=cpqScsiPhyDrvLowReadSectors, cpqTapePhyDrvBusIndex=cpqTapePhyDrvBusIndex, cpqTape3LibraryDoorClosed=cpqTape3LibraryDoorClosed, cpqScsiTargetCntlrIndex=cpqScsiTargetCntlrIndex, cpqTapeLibraryTemperature=cpqTapeLibraryTemperature, cpqTapeLibraryRedundancy=cpqTapeLibraryRedundancy, cpqScsiLogDrvCntlrIndex=cpqScsiLogDrvCntlrIndex, cpqScsiTarget=cpqScsiTarget, cpqTapeLibraryStatusChange=cpqTapeLibraryStatusChange, cpqSbDevLocation=cpqSbDevLocation, cpqTape3PhyDrvStatusChange=cpqTape3PhyDrvStatusChange, cpqScsi3LogDrvStatusChange=cpqScsi3LogDrvStatusChange, cpqScsiCntlrBusWidth=cpqScsiCntlrBusWidth, cpqScsiVolMapTable=cpqScsiVolMapTable, cpqScsi2CntlrStatusChange=cpqScsi2CntlrStatusChange, cpqTapePhyDrvMagSize=cpqTapePhyDrvMagSize, cpqSbDevFWRev=cpqSbDevFWRev, cpqTapeCountersCntlrIndex=cpqTapeCountersCntlrIndex, cpqScsiOsCommonModuleEntry=cpqScsiOsCommonModuleEntry, cpqScsiNw3xXptVers=cpqScsiNw3xXptVers, cpqSbDevScsiIdIndex=cpqSbDevScsiIdIndex, cpqScsiPhyDrvHardReadErrs=cpqScsiPhyDrvHardReadErrs, cpqScsiTargetTable=cpqScsiTargetTable, cpqScsiMibRev=cpqScsiMibRev, cpqScsiNw3xSimVers=cpqScsiNw3xSimVers, cpqScsiNw3xVolMap=cpqScsiNw3xVolMap, cpqScsiTrapLogMaxSize=cpqScsiTrapLogMaxSize, cpqScsiComponent=cpqScsiComponent, cpqCdLibraryScsiIdIndex=cpqCdLibraryScsiIdIndex, cpqTapePhyDrvFwRev=cpqTapePhyDrvFwRev, cpqScsiPhyDrvServiceHours=cpqScsiPhyDrvServiceHours, cpqTape3PhyDrvCleanTapeReplace=cpqTape3PhyDrvCleanTapeReplace, cpqScsiNw3xDriverPollType=cpqScsiNw3xDriverPollType, cpqScsiLogDrvEntry=cpqScsiLogDrvEntry, cpqSbScsiMibRev=cpqSbScsiMibRev, cpqScsiPhyDrvSerialNum=cpqScsiPhyDrvSerialNum, cpqTapeLibraryStatHours=cpqTapeLibraryStatHours, cpqScsi2PhyDrvStatusChange=cpqScsi2PhyDrvStatusChange, cpqScsiOsCommonModuleTable=cpqScsiOsCommonModuleTable, cpqScsiLogDrvStatTable=cpqScsiLogDrvStatTable, cpqScsiNw3xVolLogDrvIndex=cpqScsiNw3xVolLogDrvIndex, cpqScsiPhyDrvHighReadSectors=cpqScsiPhyDrvHighReadSectors, cpqScsiMibCondition=cpqScsiMibCondition, cpqTapeCountersEntry=cpqTapeCountersEntry, cpqScsiCntlrTimeouts=cpqScsiCntlrTimeouts, cpqScsiPhyDrvFWRev=cpqScsiPhyDrvFWRev, cpqScsiPhyDrvRotationalSpeed=cpqScsiPhyDrvRotationalSpeed, cpqScsiCdDrvLunIndex=cpqScsiCdDrvLunIndex, cpqScsiTrapLogTable=cpqScsiTrapLogTable, cpqScsiTargetCurrentSpeed=cpqScsiTargetCurrentSpeed, cpqTapeCountersReReads=cpqTapeCountersReReads, cpqTapePhyDrvCleanReq=cpqTapePhyDrvCleanReq, cpqScsiNw3xVolCntlrIndex=cpqScsiNw3xVolCntlrIndex, cpqScsiTargetScsiIdIndex=cpqScsiTargetScsiIdIndex, cpqScsiPhyDrvCondition=cpqScsiPhyDrvCondition, cpqScsiPhyDrvSeekErrs=cpqScsiPhyDrvSeekErrs, cpqTapePhyDrvTable=cpqTapePhyDrvTable, cpqScsiCntlrCondition=cpqScsiCntlrCondition, cpqScsiOsCommonModuleVersion=cpqScsiOsCommonModuleVersion, cpqScsiCntlrBaseIOAddr=cpqScsiCntlrBaseIOAddr, cpqScsi3PhyDrvStatusChange=cpqScsi3PhyDrvStatusChange, cpqScsiTargetSelectTimeouts=cpqScsiTargetSelectTimeouts, cpqTape5PhyDrvStatusChange=cpqTape5PhyDrvStatusChange, cpqTapeCountersTotalUncorrectable=cpqTapeCountersTotalUncorrectable, cpqScsiOsCommonModuleDate=cpqScsiOsCommonModuleDate, cpqTapeLibraryEntry=cpqTapeLibraryEntry, cpqSbDevSelectTimeouts=cpqSbDevSelectTimeouts, cpqScsiNw3xXptDesc=cpqScsiNw3xXptDesc, cpqSbDevModel=cpqSbDevModel, cpqScsi2LogDrvStatusChange=cpqScsi2LogDrvStatusChange, cpqTape3LibraryFailed=cpqTape3LibraryFailed, cpqScsiOsNetWare=cpqScsiOsNetWare, cpqScsiPhyDrvPlacement=cpqScsiPhyDrvPlacement, cpqScsiNw3xDriverPollTime=cpqScsiNw3xDriverPollTime, cpqScsiCntlrSoftResets=cpqScsiCntlrSoftResets, cpqTapePhyDrvStatusChange=cpqTapePhyDrvStatusChange, cpqScsiCntlrSerialNum=cpqScsiCntlrSerialNum, cpqScsiCntlrModel=cpqScsiCntlrModel, cpqScsiPhyDrvCntlrIndex=cpqScsiPhyDrvCntlrIndex, cpqScsiNw3xCntlrInfoTable=cpqScsiNw3xCntlrInfoTable, cpqCdLibraryFwRev=cpqCdLibraryFwRev, cpqScsiTrapPkts=cpqScsiTrapPkts, cpqScsiPhyDrvScsiID=cpqScsiPhyDrvScsiID, cpqScsiTargetVendor=cpqScsiTargetVendor, cpqCdLibraryStatus=cpqCdLibraryStatus, cpqScsiPhyDrvTimeouts=cpqScsiPhyDrvTimeouts, cpqTapePhyDrvCleanTapeRepl=cpqTapePhyDrvCleanTapeRepl, cpqTapePhyDrvLibraryDrive=cpqTapePhyDrvLibraryDrive, cpqScsiPhyDrvStatusChange=cpqScsiPhyDrvStatusChange, cpqScsiCntlrIndex=cpqScsiCntlrIndex, cpqScsiCntlrSWVers=cpqScsiCntlrSWVers, cpqScsiPhyDrvPostErrCode=cpqScsiPhyDrvPostErrCode, cpqScsiNw3xTotalWrites=cpqScsiNw3xTotalWrites, cpqScsiNw3xFatalReads=cpqScsiNw3xFatalReads, cpqScsiPhyDrvStatsPreserved=cpqScsiPhyDrvStatsPreserved, cpqTapePhyDrvCleanTapeCount=cpqTapePhyDrvCleanTapeCount, cpqScsiOsCommon=cpqScsiOsCommon, cpqTapeLibraryState=cpqTapeLibraryState, cpqTapeLibrarySerialNumber=cpqTapeLibrarySerialNumber, cpqTape3LibraryDoorOpen=cpqTape3LibraryDoorOpen, cpqScsiPhyDrvTable=cpqScsiPhyDrvTable, cpqCdLibraryLunIndex=cpqCdLibraryLunIndex, cpqCdLibrarySerialNumber=cpqCdLibrarySerialNumber, cpqScsi5PhyDrvStatusChange=cpqScsi5PhyDrvStatusChange, cpqSbDevVendor=cpqSbDevVendor, cpqScsiPhyDrvUsedReallocs=cpqScsiPhyDrvUsedReallocs, cpqScsiTargetModel=cpqScsiTargetModel, cpqScsiTargetNegWidth=cpqScsiTargetNegWidth, cpqScsiOsCommonModuleName=cpqScsiOsCommonModuleName, cpqScsiCntlrHwLocation=cpqScsiCntlrHwLocation, cpqCdLibraryBusIndex=cpqCdLibraryBusIndex, cpqScsiMibRevMinor=cpqScsiMibRevMinor, cpqScsiNw3xSimDesc=cpqScsiNw3xSimDesc, cpqScsiTrap=cpqScsiTrap, cpqScsiNw3xVolBusIndex=cpqScsiNw3xVolBusIndex, cpqScsiLogDrvAvailSpares=cpqScsiLogDrvAvailSpares, cpqScsiTargetType=cpqScsiTargetType, cpqTapeCounters=cpqTapeCounters, cpqTapePhyDrvPlacement=cpqTapePhyDrvPlacement, cpqTapePhyDrvFwSubtype=cpqTapePhyDrvFwSubtype, cpqScsiLogDrvStripeSize=cpqScsiLogDrvStripeSize, cpqTapeCountersTotalErrors=cpqTapeCountersTotalErrors, cpqScsiTargetParityErrs=cpqScsiTargetParityErrs, cpqScsiNw3xCorrReads=cpqScsiNw3xCorrReads, cpqScsiPhyDrvFuncTest1=cpqScsiPhyDrvFuncTest1, cpqTapeCountersScsiIdIndex=cpqTapeCountersScsiIdIndex, cpqScsiCdDrvEntry=cpqScsiCdDrvEntry, cpqTapePhyDrvLunIndex=cpqTapePhyDrvLunIndex, cpqScsiTargetFWRev=cpqScsiTargetFWRev, cpqTapeLibraryName=cpqTapeLibraryName, cpqScsi3CntlrStatusChange=cpqScsi3CntlrStatusChange, cpqScsiTargetNegPeriod=cpqScsiTargetNegPeriod, cpqScsiNw3xDriverVers=cpqScsiNw3xDriverVers, cpqTapePhyDrvSerialNumber=cpqTapePhyDrvSerialNumber, cpqScsiPhyDrvSize=cpqScsiPhyDrvSize, cpqTapePhyDrvCntlrIndex=cpqTapePhyDrvCntlrIndex, cpqTape3LibraryOkay=cpqTape3LibraryOkay, cpqScsiCdDrvFwRev=cpqScsiCdDrvFwRev, cpqScsiLogDrv=cpqScsiLogDrv, cpqScsiCdDrvTable=cpqScsiCdDrvTable, cpqScsiTrapTime=cpqScsiTrapTime, cpqCdLibraryCntlrIndex=cpqCdLibraryCntlrIndex, cpqTape4PhyDrvStatusChange=cpqTape4PhyDrvStatusChange, cpqCdLibraryDriveList=cpqCdLibraryDriveList, cpqScsiTrapType=cpqScsiTrapType, cpqScsiLogDrvPercentRebuild=cpqScsiLogDrvPercentRebuild, cpqTapePhyDrvType=cpqTapePhyDrvType, cpqScsiLogDrvFaultTol=cpqScsiLogDrvFaultTol, cpqScsiTargetPhysWidth=cpqScsiTargetPhysWidth, cpqScsiLogDrvIndex=cpqScsiLogDrvIndex, cpqTapePhyDrv=cpqTapePhyDrv, cpqTapeLibrary=cpqTapeLibrary, cpqScsiTargetLocation=cpqScsiTargetLocation, cpqTapePhyDrvHotPlug=cpqTapePhyDrvHotPlug, cpqScsiPhyDrvRecvReadErrs=cpqScsiPhyDrvRecvReadErrs, cpqTapeLibraryDriveList=cpqTapeLibraryDriveList, cpqScsiTargetPhaseErrs=cpqScsiTargetPhaseErrs, cpqTapePhyDrvStatus=cpqTapePhyDrvStatus, cpqScsiCdDrvCntlrIndex=cpqScsiCdDrvCntlrIndex, cpqScsiNw3xCorrWrites=cpqScsiNw3xCorrWrites, cpqTapePhyDrvLoaderSerialNum=cpqTapePhyDrvLoaderSerialNum, cpqScsiTargetNegSpeed=cpqScsiTargetNegSpeed, cpqTapePhyDrvEntry=cpqTapePhyDrvEntry, cpqScsiPhyDrvPreFailMonitoring=cpqScsiPhyDrvPreFailMonitoring, cpqScsiPhyDrvHotPlug=cpqScsiPhyDrvHotPlug, cpqTapePhyDrvScsiIdIndex=cpqTapePhyDrvScsiIdIndex, cpqScsiOsCommonPollFreq=cpqScsiOsCommonPollFreq)
mibBuilder.exportSymbols("CPQSCSI-MIB", cpqScsiPhyDrvPostErrs=cpqScsiPhyDrvPostErrs, cpqTapeComponent=cpqTapeComponent, cpqTapePhyDrvLoaderName=cpqTapePhyDrvLoaderName, cpqSbScsiBus=cpqSbScsiBus, cpqScsiNw3xStatCntlrIndex=cpqScsiNw3xStatCntlrIndex, cpqScsiTargetEntry=cpqScsiTargetEntry, cpqScsiPhyDrvHighWriteSectors=cpqScsiPhyDrvHighWriteSectors, cpqCdLibraryVendor=cpqCdLibraryVendor, cpqScsiCntlr=cpqScsiCntlr, cpqTapeCountersTotalBytes=cpqTapeCountersTotalBytes, cpqScsiPhyDrvRecvWriteErrs=cpqScsiPhyDrvRecvWriteErrs, cpqScsiPhyDrvLowWriteSectors=cpqScsiPhyDrvLowWriteSectors, cpqScsiLogDrvTable=cpqScsiLogDrvTable, cpqSbDevCntlrIndex=cpqSbDevCntlrIndex, cpqScsiNw3xBusIndex=cpqScsiNw3xBusIndex, cpqScsiNw3xHbaDesc=cpqScsiNw3xHbaDesc, cpqScsiNw3xTotalReads=cpqScsiNw3xTotalReads, cpqScsiLogDrvOsName=cpqScsiLogDrvOsName, cpqTapeCountersLunIndex=cpqTapeCountersLunIndex, cpqScsiCd=cpqScsiCd, cpqScsiPhyDrv=cpqScsiPhyDrv, cpqScsiOsCommonModuleIndex=cpqScsiOsCommonModuleIndex, cpqCdLibraryCondition=cpqCdLibraryCondition, cpqScsiTrapLogEntry=cpqScsiTrapLogEntry)

#
# PySNMP MIB module Wellfleet-MPLS-MLM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-MPLS-MLM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:40:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Unsigned32, IpAddress, Counter64, Gauge32, TimeTicks, NotificationType, MibIdentifier, Bits, Integer32, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Unsigned32", "IpAddress", "Counter64", "Gauge32", "TimeTicks", "NotificationType", "MibIdentifier", "Bits", "Integer32", "iso", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wfMplsAtmGroup, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfMplsAtmGroup")
wfMplsAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1))
wfMplsAtmIfConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1), )
if mibBuilder.loadTexts: wfMplsAtmIfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfConfTable.setDescription('MPLS ATM interface configuration table - This tabulates the ATM interfaces within an mpls protocol group. All interfaces are indexed according to their line number. There is one ATM interface per MPLS LDP session, but there might be more LDP sessions per ATM interface.')
wfMplsAtmIfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1, 1), ).setIndexNames((0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmIfConfLineNumber"))
if mibBuilder.loadTexts: wfMplsAtmIfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfConfEntry.setDescription('MPLS ATM interface configuration entries.')
wfMplsAtmIfCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmIfCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfCreate.setDescription('Create/Delete parameter. Default is created. Users modify this object in order to create/delete MPLS ATM interfaces')
wfMplsAtmIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfAdminStatus.setDescription('Enable/Disable parameter. Default is enabled.')
wfMplsAtmIfConfLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfConfLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfConfLineNumber.setDescription('The line number of the driver line to which the interface belongs.')
wfMplsAtmIfDebugLogMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16, 128, 255))).clone(namedValues=NamedValues(("none", 1), ("fsm", 16), ("other", 128), ("all", 255))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmIfDebugLogMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfDebugLogMask.setDescription("Log bits for debug messages. This values above can be used separately, or OR'd together for a combination of debug levels.")
wfMplsAtmIfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2), )
if mibBuilder.loadTexts: wfMplsAtmIfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfStatusTable.setDescription('MPLS ATM interface status table - This tabulates the ATM interfaces within an mpls protocol group. All interfaces are indexed according to their line number. There is one ATM interface per MPLS LDP session, but there might be multiple LDP sessions per ATM interface.')
wfMplsAtmIfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1), ).setIndexNames((0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmIfStatusLineNumber"))
if mibBuilder.loadTexts: wfMplsAtmIfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfStatusEntry.setDescription('MPLS ATM interface status entries.')
wfMplsAtmIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("init", 2), ("up", 3), ("cleanup", 4), ("notpresent", 5))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfOperStatus.setDescription('The current state of the MPLS ATM interface')
wfMplsAtmIfStatusLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfStatusLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfStatusLineNumber.setDescription('The line number of the driver line to which the interface belongs.')
wfMplsAtmIfCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfCircuit.setDescription('The circuit number of the circuit to which the interface belongs.')
wfMplsAtmIfTotalSess = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfTotalSess.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfTotalSess.setDescription('The total number of LDPs up running.')
wfMplsAtmIfTotalVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfTotalVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfTotalVcs.setDescription('The total number of VCs either in use, or available on this interface.')
wfMplsAtmIfAllocVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmIfAllocVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmIfAllocVcs.setDescription('The number of VCs which are currently allocated for different LDP sessions on this interface. wfMplsAtmTotalVcs minus the value of this object results in knowning how many VCs are still available to allocate to new LDP sessions on this interface.')
wfMplsAtmSessConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3), )
if mibBuilder.loadTexts: wfMplsAtmSessConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfTable.setDescription('This is the ATM related configuration table for every LDP session.')
wfMplsAtmSessConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1), ).setIndexNames((0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmSessConfLineNumber"), (0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmSessConfIndex"))
if mibBuilder.loadTexts: wfMplsAtmSessConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfEntry.setDescription('Entry definition.')
wfMplsAtmSessDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDelete.setDescription('Create/delete MIB instance parameter.')
wfMplsAtmSessAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessAdminStatus.setDescription('Specifies the desired administrative state of the VCL. The up and down states indicate that the traffic flow is enabled and disabled respectively for the VCL.')
wfMplsAtmSessConfLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessConfLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfLineNumber.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information. We use line number here.')
wfMplsAtmSessConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfIndex.setDescription('LDP session index number.')
wfMplsAtmSessConfDefVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessConfDefVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfDefVclVpi.setDescription('The VPI value of the default VC.')
wfMplsAtmSessConfDefVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessConfDefVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfDefVclVci.setDescription('The VCI value of the default VC. It should not in the configured VC range for any LDP session.')
wfMplsAtmSessConfVcRangeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeVpi.setDescription('The VPI value of the VCs in this LDP session.')
wfMplsAtmSessConfVcRangeMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(33)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeMinVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeMinVci.setDescription('The minimum VCI value of the configured LDP session.')
wfMplsAtmSessConfVcRangeMaxVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeMaxVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessConfVcRangeMaxVci.setDescription('The maximum VCI value of the configured LDP session.')
wfMplsAtmSessDefVclXmtPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtPeakCellRate.setDescription('Transmit (Forward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection. 0 means best effort peak cell rate.')
wfMplsAtmSessDefVclXmtSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtSustainableCellRate.setDescription("Transmit (Forward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'. 0 means best effort sustainable cell rate.")
wfMplsAtmSessDefVclXmtBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtBurstSize.setDescription('Transmit (Forward) Burst Size in cells.')
wfMplsAtmSessDefVclXmtQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4))).clone('class3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtQosClass.setDescription('Transmit (Forward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfMplsAtmSessDefVclRcvPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvPeakCellRate.setDescription('Receive (Backward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection. 0 means best effort peak cell rate.')
wfMplsAtmSessDefVclRcvSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvSustainableCellRate.setDescription("Receive (Backward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'. 0 means best effort sustainable cell rate.")
wfMplsAtmSessDefVclRcvBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvBurstSize.setDescription('Receive (Backward) Burst Size in cells.')
wfMplsAtmSessDefVclRcvQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4))).clone('class3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvQosClass.setDescription('Receive (Backward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfMplsAtmSessDefVclAalType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type1", 1), ("type34", 2), ("type5", 3), ("other", 4), ("unknown", 5))).clone('type5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalType.setDescription('The type of AAL used on the VCL.')
wfMplsAtmSessDefVclAalCpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalCpcsTransmitSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalCpcsTransmitSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the transmit direction of this VCC.')
wfMplsAtmSessDefVclAalCpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalCpcsReceiveSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalCpcsReceiveSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the receive direction of this VCC.')
wfMplsAtmSessDefVclAalEncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("llcencaps", 2), ("null", 3), ("other", 4))).clone('llcencaps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalEncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclAalEncapsType.setDescription('The type of data encapsulation used over both AAL3/4 and AAL5 SSCS layer. Currently, the only values supported are : ATM_VCLENCAPS_LLCENCAPS - RFC1483 ATM_VCLENCAPS_ROUTEDPROTO - NONE')
wfMplsAtmSessDefVclCongestionIndication = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclCongestionIndication.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclCongestionIndication.setDescription('The desired state of the Congestion Indication (CI) bit in the payload field of each ATM cell for this VCL.')
wfMplsAtmSessDefVclCellLossPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclCellLossPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclCellLossPriority.setDescription('The desired state of the Cell Loss Priority (CLP) bit in the ATM header of each cell for this VCL.')
wfMplsAtmSessDefVclXmtTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclXmtTagging.setDescription('Tagging forward VC messages if peak/sustainable rates exceeded')
wfMplsAtmSessDefVclRcvTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessDefVclRcvTagging.setDescription('Tagging backward VC messages if peak/sustainable rates exceeded')
wfMplsAtmSessStatusTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4), )
if mibBuilder.loadTexts: wfMplsAtmSessStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessStatusTable.setDescription('This is the ATM related status table for every LDP session.')
wfMplsAtmSessStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1), ).setIndexNames((0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmSessStatusLineNumber"), (0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmSessStatusIndex"))
if mibBuilder.loadTexts: wfMplsAtmSessStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessStatusEntry.setDescription('Entry definition.')
wfMplsAtmSessOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("init", 2), ("up", 3), ("cleanup", 4), ("notpresent", 5))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessOperStatus.setDescription('The ATM related LDP session state.')
wfMplsAtmSessStatusLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessStatusLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessStatusLineNumber.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information. We use line number here.')
wfMplsAtmSessStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessStatusIndex.setDescription('LDP session index number.')
wfMplsAtmSessActualVcRangeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeVpi.setDescription('The VPI value of the actually allowable VC range for this session. The maximum VPI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVpiBits.')
wfMplsAtmSessActualVcRangeMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeMinVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeMinVci.setDescription('The minimum VCI value of the actually allowable VC range for LDP session. The maximum VCI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVciBits.')
wfMplsAtmSessActualVcRangeMaxVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeMaxVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessActualVcRangeMaxVci.setDescription('The maximum VCI value of the actually allowable VC range for LDP session. The maximum VCI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVciBits.')
wfMplsAtmSessNegotiatedVcRangeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeVpi.setDescription('The VPI value of the VCs negotiated with LDP peer for this LDP session. The maximum VPI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVpiBits. -1 means it is not possible.')
wfMplsAtmSessNegotiatedVcRangeMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeMinVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeMinVci.setDescription('The minimum VCI value of VCs negotiated with LDP peer for this LDP session. The maximum VCI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVciBits.')
wfMplsAtmSessNegotiatedVcRangeMaxVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeMaxVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessNegotiatedVcRangeMaxVci.setDescription('The maximum VCI value of VCs negotiated with LDP peer for this LDP session. The maximum VCI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVciBits.')
wfMplsAtmSessInboundInuseVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessInboundInuseVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessInboundInuseVcs.setDescription('number of VCs opened for inbound LSP.')
wfMplsAtmSessOutboundInuseVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmSessOutboundInuseVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmSessOutboundInuseVcs.setDescription('number of VCs opened for outbound LSP.')
wfMplsAtmVclTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5), )
if mibBuilder.loadTexts: wfMplsAtmVclTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclTable.setDescription('Read-only per VC infomation.')
wfMplsAtmVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1), ).setIndexNames((0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmVclLineNumber"), (0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmVclVpi"), (0, "Wellfleet-MPLS-MLM-MIB", "wfMplsAtmVclVci"))
if mibBuilder.loadTexts: wfMplsAtmVclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclEntry.setDescription('Entry definition.')
wfMplsAtmVclLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclLineNumber.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information. We use line number here.')
wfMplsAtmVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclVpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the wfMplsAtmInterfaceMaxActiveVpiBits.')
wfMplsAtmVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclVci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the wfMplsAtmInterfaceMaxActiveVciBits.')
wfMplsAtmVclLdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclLdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclLdpIndex.setDescription('Uniquely identifies the LDP session number in this interface.')
wfMplsAtmVclDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2), ("duplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclDirection.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclDirection.setDescription('The direction of LSP')
wfMplsAtmVclState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("init", 2), ("up", 3), ("cleanup", 4), ("notpresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclState.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclState.setDescription('The VC state.')
wfMplsAtmVclType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("lsp", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclType.setDescription('default VC or normal LSP VC.')
wfMplsAtmVclLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclLastChange.setDescription("The value of MIBII's sysUpTime at the time this VCL entered its current operational state.")
wfMplsAtmVclXmtPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4716))).clone(namedValues=NamedValues(("default", 4716)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclXmtPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclXmtPeakCellRate.setDescription('Transmit (Forward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection.')
wfMplsAtmVclXmtSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4716))).clone(namedValues=NamedValues(("default", 4716)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclXmtSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclXmtSustainableCellRate.setDescription("Transmit (Forward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'.")
wfMplsAtmVclXmtBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclXmtBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclXmtBurstSize.setDescription('Transmit (Forward) Burst Size in cells.')
wfMplsAtmVclXmtQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclXmtQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclXmtQosClass.setDescription('Transmit (Forward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfMplsAtmVclRcvPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4716))).clone(namedValues=NamedValues(("default", 4716)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclRcvPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclRcvPeakCellRate.setDescription('Receive (Backward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection.')
wfMplsAtmVclRcvSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4716))).clone(namedValues=NamedValues(("default", 4716)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclRcvSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclRcvSustainableCellRate.setDescription("Receive (Backward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'.")
wfMplsAtmVclRcvBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclRcvBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclRcvBurstSize.setDescription('Receive (Backward) Burst Size in cells.')
wfMplsAtmVclRcvQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclRcvQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclRcvQosClass.setDescription('Receive (Backward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfMplsAtmVclAalType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type1", 1), ("type34", 2), ("type5", 3), ("other", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclAalType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclAalType.setDescription('The type of AAL used on the VCL.')
wfMplsAtmVclAalCpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclAalCpcsTransmitSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclAalCpcsTransmitSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the transmit direction of this VCC.')
wfMplsAtmVclAalCpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclAalCpcsReceiveSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclAalCpcsReceiveSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the receive direction of this VCC.')
wfMplsAtmVclAalEncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("llcencaps", 2), ("null", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclAalEncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclAalEncapsType.setDescription('The type of data encapsulation used over both AAL3/4 and AAL5 SSCS layer. Currently, the only values supported are : ATM_VCLENCAPS_LLCENCAPS - RFC1483 ATM_VCLENCAPS_ROUTEDPROTO - NONE')
wfMplsAtmVclCongestionIndication = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclCongestionIndication.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclCongestionIndication.setDescription('The desired state of the Congestion Indication (CI) bit in the payload field of each ATM cell for this VCL.')
wfMplsAtmVclCellLossPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclCellLossPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclCellLossPriority.setDescription('The desired state of the Cell Loss Priority (CLP) bit in the ATM header of each cell for this VCL.')
wfMplsAtmVclXmtTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclXmtTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclXmtTagging.setDescription('Tagging forward VC messages if peak/sustainable rates exceeded')
wfMplsAtmVclRcvTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 16, 1, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMplsAtmVclRcvTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfMplsAtmVclRcvTagging.setDescription('Tagging backward VC messages if peak/sustainable rates exceeded')
mibBuilder.exportSymbols("Wellfleet-MPLS-MLM-MIB", wfMplsAtmVclCellLossPriority=wfMplsAtmVclCellLossPriority, wfMplsAtmSessConfVcRangeMaxVci=wfMplsAtmSessConfVcRangeMaxVci, wfMplsAtmSessDelete=wfMplsAtmSessDelete, wfMplsAtmIfConfLineNumber=wfMplsAtmIfConfLineNumber, wfMplsAtmSessConfIndex=wfMplsAtmSessConfIndex, wfMplsAtmSessDefVclXmtPeakCellRate=wfMplsAtmSessDefVclXmtPeakCellRate, wfMplsAtmVclLastChange=wfMplsAtmVclLastChange, wfMplsAtmSessDefVclAalCpcsTransmitSduSize=wfMplsAtmSessDefVclAalCpcsTransmitSduSize, wfMplsAtmVclXmtTagging=wfMplsAtmVclXmtTagging, wfMplsAtmSessConfTable=wfMplsAtmSessConfTable, wfMplsAtmSessDefVclRcvSustainableCellRate=wfMplsAtmSessDefVclRcvSustainableCellRate, wfMplsAtmVclAalEncapsType=wfMplsAtmVclAalEncapsType, wfMplsAtmIfOperStatus=wfMplsAtmIfOperStatus, wfMplsAtmVclType=wfMplsAtmVclType, wfMplsAtmSessOperStatus=wfMplsAtmSessOperStatus, wfMplsAtmSessStatusIndex=wfMplsAtmSessStatusIndex, wfMplsAtmSessActualVcRangeVpi=wfMplsAtmSessActualVcRangeVpi, wfMplsAtmVclTable=wfMplsAtmVclTable, wfMplsAtmSessDefVclCongestionIndication=wfMplsAtmSessDefVclCongestionIndication, wfMplsAtmSessAdminStatus=wfMplsAtmSessAdminStatus, wfMplsAtmSessNegotiatedVcRangeMinVci=wfMplsAtmSessNegotiatedVcRangeMinVci, wfMplsAtmSessDefVclAalCpcsReceiveSduSize=wfMplsAtmSessDefVclAalCpcsReceiveSduSize, wfMplsAtmIfStatusLineNumber=wfMplsAtmIfStatusLineNumber, wfMplsAtmIfConfTable=wfMplsAtmIfConfTable, wfMplsAtmVclXmtSustainableCellRate=wfMplsAtmVclXmtSustainableCellRate, wfMplsAtmSessDefVclXmtBurstSize=wfMplsAtmSessDefVclXmtBurstSize, wfMplsAtmVclAalCpcsTransmitSduSize=wfMplsAtmVclAalCpcsTransmitSduSize, wfMplsAtmSessDefVclXmtTagging=wfMplsAtmSessDefVclXmtTagging, wfMplsAtmVclRcvTagging=wfMplsAtmVclRcvTagging, wfMplsAtmSessDefVclRcvQosClass=wfMplsAtmSessDefVclRcvQosClass, wfMplsAtmIfStatusEntry=wfMplsAtmIfStatusEntry, wfMplsAtmSessDefVclAalType=wfMplsAtmSessDefVclAalType, wfMplsAtmIfDebugLogMask=wfMplsAtmIfDebugLogMask, wfMplsAtmIfAllocVcs=wfMplsAtmIfAllocVcs, wfMplsAtmSessConfDefVclVci=wfMplsAtmSessConfDefVclVci, wfMplsAtmSessConfLineNumber=wfMplsAtmSessConfLineNumber, wfMplsAtmSessNegotiatedVcRangeMaxVci=wfMplsAtmSessNegotiatedVcRangeMaxVci, wfMplsAtmSessActualVcRangeMaxVci=wfMplsAtmSessActualVcRangeMaxVci, wfMplsAtmVclLdpIndex=wfMplsAtmVclLdpIndex, wfMplsAtmIfConfEntry=wfMplsAtmIfConfEntry, wfMplsAtmVclRcvPeakCellRate=wfMplsAtmVclRcvPeakCellRate, wfMplsAtm=wfMplsAtm, wfMplsAtmSessDefVclAalEncapsType=wfMplsAtmSessDefVclAalEncapsType, wfMplsAtmVclLineNumber=wfMplsAtmVclLineNumber, wfMplsAtmVclAalType=wfMplsAtmVclAalType, wfMplsAtmIfAdminStatus=wfMplsAtmIfAdminStatus, wfMplsAtmVclXmtPeakCellRate=wfMplsAtmVclXmtPeakCellRate, wfMplsAtmSessConfVcRangeMinVci=wfMplsAtmSessConfVcRangeMinVci, wfMplsAtmVclXmtBurstSize=wfMplsAtmVclXmtBurstSize, wfMplsAtmSessActualVcRangeMinVci=wfMplsAtmSessActualVcRangeMinVci, wfMplsAtmVclDirection=wfMplsAtmVclDirection, wfMplsAtmSessDefVclRcvPeakCellRate=wfMplsAtmSessDefVclRcvPeakCellRate, wfMplsAtmVclState=wfMplsAtmVclState, wfMplsAtmSessNegotiatedVcRangeVpi=wfMplsAtmSessNegotiatedVcRangeVpi, wfMplsAtmSessStatusEntry=wfMplsAtmSessStatusEntry, wfMplsAtmIfTotalSess=wfMplsAtmIfTotalSess, wfMplsAtmSessConfEntry=wfMplsAtmSessConfEntry, wfMplsAtmSessConfVcRangeVpi=wfMplsAtmSessConfVcRangeVpi, wfMplsAtmVclAalCpcsReceiveSduSize=wfMplsAtmVclAalCpcsReceiveSduSize, wfMplsAtmSessOutboundInuseVcs=wfMplsAtmSessOutboundInuseVcs, wfMplsAtmIfTotalVcs=wfMplsAtmIfTotalVcs, wfMplsAtmIfCircuit=wfMplsAtmIfCircuit, wfMplsAtmVclVpi=wfMplsAtmVclVpi, wfMplsAtmSessConfDefVclVpi=wfMplsAtmSessConfDefVclVpi, wfMplsAtmSessStatusLineNumber=wfMplsAtmSessStatusLineNumber, wfMplsAtmSessStatusTable=wfMplsAtmSessStatusTable, wfMplsAtmVclEntry=wfMplsAtmVclEntry, wfMplsAtmIfStatusTable=wfMplsAtmIfStatusTable, wfMplsAtmVclCongestionIndication=wfMplsAtmVclCongestionIndication, wfMplsAtmSessDefVclRcvBurstSize=wfMplsAtmSessDefVclRcvBurstSize, wfMplsAtmVclRcvSustainableCellRate=wfMplsAtmVclRcvSustainableCellRate, wfMplsAtmSessDefVclXmtQosClass=wfMplsAtmSessDefVclXmtQosClass, wfMplsAtmSessDefVclRcvTagging=wfMplsAtmSessDefVclRcvTagging, wfMplsAtmVclRcvQosClass=wfMplsAtmVclRcvQosClass, wfMplsAtmIfCreate=wfMplsAtmIfCreate, wfMplsAtmVclVci=wfMplsAtmVclVci, wfMplsAtmSessInboundInuseVcs=wfMplsAtmSessInboundInuseVcs, wfMplsAtmVclRcvBurstSize=wfMplsAtmVclRcvBurstSize, wfMplsAtmSessDefVclCellLossPriority=wfMplsAtmSessDefVclCellLossPriority, wfMplsAtmSessDefVclXmtSustainableCellRate=wfMplsAtmSessDefVclXmtSustainableCellRate, wfMplsAtmVclXmtQosClass=wfMplsAtmVclXmtQosClass)

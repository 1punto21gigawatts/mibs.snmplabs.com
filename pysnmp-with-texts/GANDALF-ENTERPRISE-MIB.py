#
# PySNMP MIB module GANDALF-ENTERPRISE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GANDALF-ENTERPRISE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, TimeTicks, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Unsigned32, enterprises, Counter32, IpAddress, NotificationType, iso, Integer32, MibIdentifier, Counter64, Gauge32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "TimeTicks", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Unsigned32", "enterprises", "Counter32", "IpAddress", "NotificationType", "iso", "Integer32", "MibIdentifier", "Counter64", "Gauge32", "ObjectIdentity")
TextualConvention, PhysAddress, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "PhysAddress", "DisplayString")
gandalf = MibIdentifier((1, 3, 6, 1, 4, 1, 64))
gandalf_hub = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 1)).setLabel("gandalf-hub")
gandalf_bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2)).setLabel("gandalf-bridge")
gandalf_generic = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 3)).setLabel("gandalf-generic")
gandalf_2590 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 4)).setLabel("gandalf-2590")
gandalf_wanNode = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 5)).setLabel("gandalf-wanNode")
gandalf_products = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6)).setLabel("gandalf-products")
gandalf_nms = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 7)).setLabel("gandalf-nms")
gandalf_wanProxy = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 8)).setLabel("gandalf-wanProxy")
gandalf_rlanisdn = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 9)).setLabel("gandalf-rlanisdn")
gandalf_termserver = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 10)).setLabel("gandalf-termserver")
gandalf_router = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 11)).setLabel("gandalf-router")
gandalf_experimental = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 12)).setLabel("gandalf-experimental")
hmBasicCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 1, 1))
hmSelfTestCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 1, 2))
hmPerfMonCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 1, 3))
hmAddrTrackCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 1, 4))
bridgeConfigObject = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 1))
bridgeTpObject = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 2))
bridgeStpObject = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 3))
bridgeStaticObject = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 4))
wanPhysicalObject = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 5))
ieee8023Object = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 2, 6))
gandalfLog = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 3, 1))
snmpAdminCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 3, 2))
gProd_wan = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 1)).setLabel("gProd-wan")
gProxy = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 1, 1))
g2300 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 1, 2))
g2050 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 1, 3))
gProd_hub = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 2)).setLabel("gProd-hub")
ecm1000 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 2, 1))
rsc9000 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 2, 3))
gProd_bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3)).setLabel("gProd-bridge")
lanline5220L = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 2))
xbr6202 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 3))
lanline5220e = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 4))
lanline5225i = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 5))
lanline5240i = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 6))
xbr6204 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 7))
lanline5221 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 8))
lanline5242 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 3, 9))
gProd_gateway = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 4)).setLabel("gProd-gateway")
wgm2590_hub = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 4, 1)).setLabel("wgm2590-hub")
wgm2590_standalone = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 4, 2)).setLabel("wgm2590-standalone")
gProd_termserver = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 5)).setLabel("gProd-termserver")
gts1000 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 5, 1))
gtsplus = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 5, 2))
gProd_router = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6)).setLabel("gProd-router")
lanline5250i = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 5))
lanline5250L = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 7))
lanline5242er = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 8))
lanline5250fr = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 9))
xpressway5250isdn_typ1 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 10)).setLabel("xpressway5250isdn-typ1")
xpressway5250isdn_typ2 = MibIdentifier((1, 3, 6, 1, 4, 1, 64, 6, 6, 11)).setLabel("xpressway5250isdn-typ2")
hubBasicID = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubBasicID.setStatus('mandatory')
if mibBuilder.loadTexts: hubBasicID.setDescription('A 48-bit unique identifier, the hub ethernet address is used.')
hubCardCapacity = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubCardCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: hubCardCapacity.setDescription('The number of groups (cards) that can be contained within the hub.')
hubCardMap = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubCardMap.setStatus('mandatory')
if mibBuilder.loadTexts: hubCardMap.setDescription("A string of bits which reflects the current configuration of units which are viewed by the Group managed objects. The length of the bitstring is hubGroupCapacity bits. The LSBit relates to the unit viewed by group 1. A '1' in the bitstring indicates presence of the unit, '0' represent absence of the unit.")
hubNumOfRelays = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubNumOfRelays.setStatus('mandatory')
if mibBuilder.loadTexts: hubNumOfRelays.setDescription('Shows the number of relays present without regard as to whether or not each is enabled or disabled.')
hubRelayActive = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubRelayActive.setStatus('mandatory')
if mibBuilder.loadTexts: hubRelayActive.setDescription('An integer that indicates which relay is active. Zero indicates that no relays are active.')
hubResourceType = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubResourceType.setStatus('mandatory')
if mibBuilder.loadTexts: hubResourceType.setDescription('An integer value representing the IEEE802 Standard that applies to this resource.')
hubStandardRevision = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubStandardRevision.setStatus('mandatory')
if mibBuilder.loadTexts: hubStandardRevision.setDescription('An integer value representing the revision of the IEEE802 Standard to which the station conforms with respect to that resource.')
hubIEEE8023LmeOptions = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIEEE8023LmeOptions.setStatus('mandatory')
if mibBuilder.loadTexts: hubIEEE8023LmeOptions.setDescription('A set of option indicators, each of which, if present, indicates that a particular option within NM_LME is supported. Its interpretation is specified in the appropriate standard.')
hubManID = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubManID.setStatus('mandatory')
if mibBuilder.loadTexts: hubManID.setDescription('A 24 bit value that identifies the manufacturer.')
hubManProductID = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubManProductID.setStatus('mandatory')
if mibBuilder.loadTexts: hubManProductID.setDescription('A manufacturer-defined product identifier.')
hubManProductVersion = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubManProductVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hubManProductVersion.setDescription('A manufacturer-defined product revision designation.')
hubManTelephoneNum = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(33, 33)).setFixedLength(33)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubManTelephoneNum.setStatus('mandatory')
if mibBuilder.loadTexts: hubManTelephoneNum.setDescription("An ascii representation of the manufacturer's telephone number.")
hubName = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubName.setStatus('mandatory')
if mibBuilder.loadTexts: hubName.setDescription('This attribute is a text string up to 32 characters, of locally determined significance.')
hubIPaddress = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIPaddress.setStatus('mandatory')
if mibBuilder.loadTexts: hubIPaddress.setDescription('This attribute contains the IP address of the hub.')
hubEEpromRev = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubEEpromRev.setStatus('mandatory')
if mibBuilder.loadTexts: hubEEpromRev.setDescription('This attribute provides the eeprom revision number and is read from the hardware.')
hubSecureMode = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecureMode.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecureMode.setDescription('An integer value to set the hub in secure mode. In secure mode all ports are disabled by default, otherwise ports are enabled by default upon creation.')
hmBasicCardTable = MibTable((1, 3, 6, 1, 4, 1, 64, 1, 1, 17), )
if mibBuilder.loadTexts: hmBasicCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: hmBasicCardTable.setDescription('This table provide a management view of the HUB configuration specific to individual cards.')
hmBasicCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "gCardID"))
if mibBuilder.loadTexts: hmBasicCardEntry.setStatus('mandatory')
gCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardID.setStatus('mandatory')
if mibBuilder.loadTexts: gCardID.setDescription('An 8 bit value unique within the hub.')
gCardNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: gCardNumberOfPorts.setDescription('This attribute contains the number of ports in the card object instance (MAC Entities).')
gCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardName.setStatus('mandatory')
if mibBuilder.loadTexts: gCardName.setDescription('This attribute is a text string up to 32 characters, of locally determined significance.')
gCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardType.setStatus('mandatory')
if mibBuilder.loadTexts: gCardType.setDescription('This attribute contains the type of card.')
gCardRingNumberA = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ring1", 1), ("ring2", 2), ("ring3", 3), ("ring4", 4), ("standalone", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardRingNumberA.setStatus('mandatory')
if mibBuilder.loadTexts: gCardRingNumberA.setDescription("This attribute contains the Ring number associated with a UTP2112 type of card, or with RI/RO set of ports 'A' for a STP4104 type of card.")
gCardRingNumberB = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ring1", 1), ("ring2", 2), ("ring3", 3), ("ring4", 4), ("standalone", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardRingNumberB.setStatus('mandatory')
if mibBuilder.loadTexts: gCardRingNumberB.setDescription("This attribute contains the Ring number associated with RI/RO set of ports 'B' for a STP4104 type of card.")
gCardIbmModeA = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonIbmMode", 1), ("ibmMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardIbmModeA.setStatus('mandatory')
if mibBuilder.loadTexts: gCardIbmModeA.setDescription("This attribute specifies wether RI/RO set of ports 'A' for a STP4104 type of card is in IBM mode or normal mode.")
gCardIbmModeB = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ibmMode", 1), ("nonIbmMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardIbmModeB.setStatus('mandatory')
if mibBuilder.loadTexts: gCardIbmModeB.setDescription("This attribute specifies wether RI/RO set of ports 'B' for a STP4104 type of card is in IBM mode or normal mode.")
gCardRingSpeedA = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 16, 255))).clone(namedValues=NamedValues(("fourMbps", 4), ("sixteenMbps", 16), ("unknown", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardRingSpeedA.setStatus('mandatory')
if mibBuilder.loadTexts: gCardRingSpeedA.setDescription("This attribute specifies wether RI/RO set of ports 'A' for a STP4104 runs at 4 or 16 Mbps. It is also used to display the speed of a UTP2112 type of cards.")
gCardRingSpeedB = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 17, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 16, 255))).clone(namedValues=NamedValues(("fourMbps", 4), ("sixteenMbps", 16), ("unknown", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gCardRingSpeedB.setStatus('mandatory')
if mibBuilder.loadTexts: gCardRingSpeedB.setDescription("This attribute specifies wether RI/RO set of ports 'B' for a STP4104 runs at 4 or 16 Mbps.")
hmBasicPortTable = MibTable((1, 3, 6, 1, 4, 1, 64, 1, 1, 18), )
if mibBuilder.loadTexts: hmBasicPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hmBasicPortTable.setDescription('This table provide a management view of the HUB configuration specific to individual ports.')
hmBasicPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "gCardBasicID"), (0, "GANDALF-ENTERPRISE-MIB", "gPortID"))
if mibBuilder.loadTexts: hmBasicPortEntry.setStatus('mandatory')
gCardBasicID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardBasicID.setStatus('mandatory')
if mibBuilder.loadTexts: gCardBasicID.setDescription('An 8 bit value unique within the hub.')
gPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortID.setStatus('mandatory')
if mibBuilder.loadTexts: gPortID.setDescription('An 8 bit value unique in the group.')
gPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("aui", 1), ("bnc", 2), ("rj45", 3), ("rj71", 4), ("thin", 5), ("st", 6), ("fsma", 7), ("other", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortType.setStatus('mandatory')
if mibBuilder.loadTexts: gPortType.setDescription('Port connector type.')
gPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gPortAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAdminState.setDescription('Indicates whether the port is enabled or disabled. A disabled port neither transmit nor receives.')
gPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonAutoPartitioned", 2), ("autoPartitioned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAutoPartitionState.setDescription("Indicates whether the port is currently partitioned by the hub's auto-partition protection.")
gPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gPortName.setStatus('mandatory')
if mibBuilder.loadTexts: gPortName.setDescription('This attribute is a text string up to 32 characters, of locally determined significance.')
gPortEffectiveState = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("masterReady", 3), ("masterActive", 4), ("masterFaulty", 5), ("masterDisabled", 6), ("standbyReady", 7), ("standbyActive", 8), ("standbyFaulty", 9), ("standbyDisabled", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortEffectiveState.setStatus('mandatory')
if mibBuilder.loadTexts: gPortEffectiveState.setDescription("Indicates redundant port's effective state.")
gPortConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonRedundant", 1), ("master", 2), ("standby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: gPortConfiguration.setDescription("Indicates port's redundant configuration status.")
gPortRedundantPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gPortRedundantPort.setStatus('mandatory')
if mibBuilder.loadTexts: gPortRedundantPort.setDescription("Indicates redundant port's port number.")
gPortRedundantCard = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gPortRedundantCard.setStatus('mandatory')
if mibBuilder.loadTexts: gPortRedundantCard.setDescription("Indicates redundant port's card number.")
gPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 1, 18, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gPortLinkStatus.setDescription("Indicates port's link integrity status.")
hubSelfTestID = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSelfTestID.setStatus('mandatory')
if mibBuilder.loadTexts: hubSelfTestID.setDescription('A 48-bit unique identifier, the hub ethernet address is used.')
hubTimeSinceReset = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubTimeSinceReset.setStatus('mandatory')
if mibBuilder.loadTexts: hubTimeSinceReset.setDescription('The time in tens of milliseconds since the last time that the system was reset. This counter has a value of 0 when initialized.')
hubResetTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubResetTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: hubResetTimeStamp.setDescription('Not a counter, this attribute provides the value of hubTimeSinceReset when the hub was last reset.')
hubHealthState = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHealthState.setStatus('mandatory')
if mibBuilder.loadTexts: hubHealthState.setDescription('This attribute will store the results of the startup diagnostics. The first octet indicates the overall results of the startup tests, while the remaining 8 octets will contain the results of the individual test. Each octet will contain a 1 if the test was passed, 2 if the test failed. The following list defines the meanings of each octet in the string: Octet 1 - overall test result Octet 2 - system NMI test Octet 3 - system timers test Octet 4 - system DMA test Octet 5 - 82586 test Octet 6 - backplane ethernet address test Octet 7 - NVRAM test Octet 8 - dual port RAM test Octet 9 - real time clock test')
hubHealthText = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: hubHealthText.setDescription('This attribute provides a textual description of which test, if any, failed during diagnostics.')
hubHealthData = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubHealthData.setStatus('mandatory')
if mibBuilder.loadTexts: hubHealthData.setDescription('This attribute provides a textual description of which test, if any, failed during diagnostics.')
hubSystemResetting = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notResetting", 1), ("resetting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSystemResetting.setStatus('mandatory')
if mibBuilder.loadTexts: hubSystemResetting.setDescription('Indicates whether the hub is in the process of resetting completely (coldstart).')
hubResetting = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notResetting", 1), ("resetting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubResetting.setStatus('mandatory')
if mibBuilder.loadTexts: hubResetting.setDescription('Indicates whether the hub is in the process of resetting or not (warmstart).')
hubExecutingSelfTest = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSelfTesting", 1), ("selfTesting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubExecutingSelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: hubExecutingSelfTest.setDescription('Indicates whether the hub is in the process of executing self diagnostics.')
hubResetAction = MibScalar((1, 3, 6, 1, 4, 1, 64, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noreset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubResetAction.setStatus('mandatory')
if mibBuilder.loadTexts: hubResetAction.setDescription('Restart the hub if selecting reset.')
hmPerfMonRelayTable = MibTable((1, 3, 6, 1, 4, 1, 64, 1, 3, 1), )
if mibBuilder.loadTexts: hmPerfMonRelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: hmPerfMonRelayTable.setDescription('This table provide a management view individual relay performance capability.')
hmPerfMonRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 1, 3, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "relayPerfID"))
if mibBuilder.loadTexts: hmPerfMonRelayEntry.setStatus('mandatory')
relayPerfID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: relayPerfID.setStatus('mandatory')
if mibBuilder.loadTexts: relayPerfID.setDescription('This attribute is the value used in addressing the relay.')
relayTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: relayTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: relayTotalCollisions.setDescription('The counter is incremented every time the hub enters a condition caused by simultaneous transmission and detection of external activity on one or more of its ports.')
hmPerfMonPortTable = MibTable((1, 3, 6, 1, 4, 1, 64, 1, 3, 2), )
if mibBuilder.loadTexts: hmPerfMonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hmPerfMonPortTable.setDescription('This table provide a management view of individual ports performance capability.')
hmPerfMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "gCardPerfID"), (0, "GANDALF-ENTERPRISE-MIB", "gPortPerfID"))
if mibBuilder.loadTexts: hmPerfMonPortEntry.setStatus('mandatory')
gCardPerfID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardPerfID.setStatus('mandatory')
if mibBuilder.loadTexts: gCardPerfID.setDescription('This attribute represent the card number and is used to address the performance monitoring table.')
gPortPerfID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortPerfID.setStatus('mandatory')
if mibBuilder.loadTexts: gPortPerfID.setDescription('This attribute represent the port number and is used to address the performance monitoring table.')
gPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gPortReadableFrames.setDescription('A representation of the total frames of legal length that have not been corrupted in transmission counted by the port object.')
gPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: gPortReadableOctets.setDescription('It is sum of data and padding octets contained in ReadableFrames counted by the port object.')
gPortPygmys = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortPygmys.setStatus('mandatory')
if mibBuilder.loadTexts: gPortPygmys.setDescription('The sum of pygmy frame fragments counted by the port object. They occur when a frame fragment was received which was not in collision and was not recognized as a valid ethernet packet. They normally make up less than 5% of Rx frames on hub-to-hub or hub-to-backbone connections and < 1% of total Rx frames for hub-DTE connections. Significantly higher levels may indicate external noise hits on the cabling, i.e. UTP in a noisy environment.')
gPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: gPortRunts.setDescription('The sum of frames which were received then collided with another fram(e)s received by the hub. The port(s) which receive the collider frame(s) will increment their gPortCollisions and the port which was collided with will increment this counter. It is possible to count more runts than collisions for a specific port. As a rough guideline, less than 5% of the Rx frames should be runts.')
gPortFrameCheckSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortFrameCheckSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: gPortFrameCheckSeqErrs.setDescription('The sum of frames received on this port that are an integral number of octets in length and do not pass the FCS check. Normally less than 1% of Rx frames. Could be caused by line noise, loose connections, a faulty DTE, or a faulty hub.')
gPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAlignmentErrors.setDescription('The sum of frames received on this port that are not an integral number of octets in length. Should be less than 1% of the total number of Rx frames and greater than or equal to gPortFramesTooLong and gPortFrameCheckSeqErrors. Could be caused by line noise, loose connections, a faulty DTE, or a faulty hub. ')
gPortFramesTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortFramesTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: gPortFramesTooLong.setDescription('The sum of frames received on this port that are more than 1518 octets long. Should be < 1% of the total number of Rx frames. Could be caused by a faulty DTE or a faulty hub.')
gPortAutoPartitionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortAutoPartitionCount.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAutoPartitionCount.setDescription('It is the number of times that this port has been automatically partitioned.')
gPortLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: gPortLateCollisions.setDescription('This attribute is the total number of late collisions experienced by the port object. Usually indicates a DTE trying to Tx w/o checking the Ethernet for traffic first. May be due to a hardware fault on the sending DTE, or a segment which is too long for collision detection to work properly. Should normally be < 1% of total Rx frames.')
gPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: gPortCollisions.setDescription('This attribute provides the total number of collisions encountered by the port object. The port that was collided with will count a runt. Normally less than 5% of the Rx frames should be collisions. Numbers significantly higher than this may indicate hardware problems or congestion.')
gPortAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAlarms.setDescription('The number of times a threshold was exceeded on that port.')
gPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gPortMulticastFrames.setDescription('This attribute contains a count of frames successfully received by the port and are directed to an active non-broadcast group of addresses.')
gPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gPortBroadcastFrames.setDescription('This attribute contains the total number of broadcast frames received by the port object since system restart.')
hmAddrTrackPortTable = MibTable((1, 3, 6, 1, 4, 1, 64, 1, 4, 1), )
if mibBuilder.loadTexts: hmAddrTrackPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hmAddrTrackPortTable.setDescription('This table provide a management view of individual port address tracking capability.')
hmAddrTrackPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 1, 4, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "gCardAddrID"), (0, "GANDALF-ENTERPRISE-MIB", "gPortAddrID"))
if mibBuilder.loadTexts: hmAddrTrackPortEntry.setStatus('mandatory')
gCardAddrID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gCardAddrID.setStatus('mandatory')
if mibBuilder.loadTexts: gCardAddrID.setDescription('An 8 bit value unique within the hub.')
gPortAddrID = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortAddrID.setStatus('mandatory')
if mibBuilder.loadTexts: gPortAddrID.setDescription('An 8 bit value unique within the group.')
gPortLastSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortLastSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gPortLastSourceAddress.setDescription('The source (ethernet) address of the last ReadableFrame received by this port.')
gPortSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gPortSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: gPortSourceAddrChanges.setDescription('This attribute counts the number of times the last source address has changed.')
bridgeBaseAddress = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeBaseAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeBaseAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique.')
bridgeNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeNumPorts.setDescription('The number of (logical) ports controlled by this bridging entity.')
bridgeType = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparent-only", 2), ("sourceroute-only", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeType.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeType.setDescription('Indicates what type of bridging this bridge can perform. If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.')
bridgeNumOfInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeNumOfInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeNumOfInterfaces.setDescription('The number of interfaces controlled by this bridging entity, the interface stats are managed by MIB II interface group.')
bridgePowerUpStatus = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgePowerUpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bridgePowerUpStatus.setDescription('This attribute contains the result of any non fatal hardware diagnostics performed during the power on procedure.')
bridgeIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeIpAddr.setDescription('This attribute contains the IP address of the bridge.')
bridgeManID = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeManID.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeManID.setDescription('This is a 24 bit value that identifies the manufacturer.')
bridgeManProductVersion = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeManProductVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeManProductVersion.setDescription('This attribute provides the software revision number.')
bridgeEEpromRev = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeEEpromRev.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEEpromRev.setDescription('This attribute provides the eeprom revision number and is read from the hardware.')
bridgeSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeSerialNum.setDescription('This attribute provides the EBM Serial Number and is read from the hardware.')
bridgeHubChassis = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeHubChassis.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeHubChassis.setDescription('This attribute provides information on the type of Hub Chassis this bridge is currently using.')
filterDatabaseSize = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterDatabaseSize.setStatus('mandatory')
if mibBuilder.loadTexts: filterDatabaseSize.setDescription('This attribute represents the number of entries into the filtering database.')
numberOfDynamicEntries = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfDynamicEntries.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfDynamicEntries.setDescription('This attribute contains a number of dynamic entries currently in the Filtering Database.')
numberOfStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfStaticEntries.setDescription('This attribute contains a number of static entries currently in the Filtering Database.')
agingState = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agingState.setStatus('mandatory')
if mibBuilder.loadTexts: agingState.setDescription('When this attribute is ON, the Bridge will age dynamic station entries from the filter table automatically.')
agingTime = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agingTime.setStatus('mandatory')
if mibBuilder.loadTexts: agingTime.setDescription('The timeout period in seconds for aging out dynamically learned forwarding information.')
learningState = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: learningState.setStatus('mandatory')
if mibBuilder.loadTexts: learningState.setDescription('When this attribute is ON, the Bridge will learn LAN station addresses automatically.')
protocolFilterState = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: protocolFilterState.setDescription('This attribute specifies whether protocol filtering is enabled or disabled.')
broadcastForwardingState = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadcastForwardingState.setStatus('mandatory')
if mibBuilder.loadTexts: broadcastForwardingState.setDescription('This attribute specifies whether broadcast frames are being forwarded.')
multicastForwardingState = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: multicastForwardingState.setStatus('mandatory')
if mibBuilder.loadTexts: multicastForwardingState.setDescription('This attribute specifies whether multicast frames are being forwarded.')
bridgeTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 2, 10), )
if mibBuilder.loadTexts: bridgeTpFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTpFdbTable.setDescription('A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame.')
bridgeTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 2, 10, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "bridgeDot1dTpFdbAddress"))
if mibBuilder.loadTexts: bridgeTpFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the bridge has some forwarding and/or filtering information.')
bridgeDot1dTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 10, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpFdbAddress.setReference('P802.1d/D9, July 14, 1989: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: bridgeDot1dTpFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeDot1dTpFdbAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
bridgeDot1dTpFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeDot1dTpFdbPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance of dot1dTpFdbAddress has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address (e.g. in the dot1dStaticTable). Implementors are encouraged to assign the port value to this object whenever it is learned even for addresses for which the corresponding value of dot1dTpFdbStatus is not learned(3).")
bridgeDot1dTpFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeDot1dTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) : none of the following. This would include the case where some other MIB object (not the corresponding instance of dot1dTpFdbPort, nor an entry in the dot1dStaticTable) is being used to determine if and how frames addressed to the value of the corresponding instance of dot1dTpFdbAddress are being forwarded. invalid(2) : this entry is not longer valid (e.g., it was learned but has since aged-out), but has not yet been flushed from the table. learned(3) : the value of the corresponding instance of dot1dTpFdbPort was learned, and is being used. self(4) : the value of the corresponding instance of dot1dTpFdbAddress represents one of the bridge's addresses. The corresponding instance of dot1dTpFdbPort indicates which of the bridge's ports has this address. mgmt(5) : the value of the corresponding instance of dot1dTpFdbAddress is also the value of an existing instance of dot1dStaticAddress.")
bridgeLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 2, 11), )
if mibBuilder.loadTexts: bridgeLogicalPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeLogicalPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
bridgeLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "bridgeDot1dTpPort"))
if mibBuilder.loadTexts: bridgeLogicalPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeLogicalPortEntry.setDescription('A list of information for each port of a transparent bridge.')
bridgeDot1dTpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpPort.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dTpPort.setDescription('The port number of the port for which this entry contains Transparent bridging management information.')
bridgeDot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpPortMaxInfo.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
bridgeDot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpPortInFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: bridgeDot1dTpPortInFrames.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
bridgeDot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpPortOutFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: bridgeDot1dTpPortOutFrames.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
bridgeDot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dTpPortInDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: bridgeDot1dTpPortInDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dTpPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
bridgeDot1dStpProtocolSpecification = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpProtocolSpecification.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpProtocolSpecification.setDescription("An indication of what version of the Spanning Tree Protocol is being run. The value 'decLb100(2)' indicates the DEC LANbridge 100 Spanning Tree protocol. IEEE 802.1d implementations will return 'ieee8021d(3)'. If future versions of the IEEE Spanning Tree Protocol are released that are incompatible with the current version a new value will be defined.")
bridgeDot1dStpPriority = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.7')
if mibBuilder.loadTexts: bridgeDot1dStpPriority.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID. The other (last) 6 octets of the Bridge ID are given by the value of dot1dBaseBridgeAddress.')
bridgeDot1dStpTimeSinceTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpTimeSinceTopologyChange.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: bridgeDot1dStpTimeSinceTopologyChange.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
bridgeDot1dStpTopChanges = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpTopChanges.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: bridgeDot1dStpTopChanges.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
bridgeDot1dStpDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.1')
if mibBuilder.loadTexts: bridgeDot1dStpDesignatedRoot.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
bridgeDot1dStpRootCost = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpRootCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.2')
if mibBuilder.loadTexts: bridgeDot1dStpRootCost.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
bridgeDot1dStpRootPort = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpRootPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.3')
if mibBuilder.loadTexts: bridgeDot1dStpRootPort.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
bridgeDot1dStpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.4')
if mibBuilder.loadTexts: bridgeDot1dStpMaxAge.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
bridgeDot1dStpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.5')
if mibBuilder.loadTexts: bridgeDot1dStpHelloTime.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
bridgeDot1dStpHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpHoldTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.14')
if mibBuilder.loadTexts: bridgeDot1dStpHoldTime.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
bridgeDot1dStpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.6')
if mibBuilder.loadTexts: bridgeDot1dStpForwardDelay.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in a particular state before moving to the next state. For example, how long a port stays in the Listening state when moving from Blocking to Learning. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. [Note that this value is the one that this bridge is currently using, in contrast to dot1dStpBridgeForwardDelay which is the value that this bridge and all others would start using if/when this bridge were to become the root.]')
bridgeDot1dStpBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpBridgeMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.8')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeMaxAge.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeMaxAge.setDescription('The value that all bridges use for MaxAge when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of dot1dStpBridgeHelloTime. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
bridgeDot1dStpBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpBridgeHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.9')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeHelloTime.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeHelloTime.setDescription('The value that all bridges use for HelloTime when this bridge is acting as the root. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
bridgeDot1dStpBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 64, 2, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpBridgeForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.10')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeForwardDelay.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpBridgeForwardDelay.setDescription('The value that all bridges use for ForwardDelay when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of dot1dStpBridgeMaxAge. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
bridgeStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 3, 15), )
if mibBuilder.loadTexts: bridgeStpPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeStpPortTable.setDescription('A table that contains port-specific information for the Spanning Tree Protocol.')
bridgeStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "bridgeDot1dStpPort"))
if mibBuilder.loadTexts: bridgeStpPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeStpPortEntry.setDescription('A list of information maintained by every port about the Spanning Tree Protocol state for that port.')
bridgeDot1dStpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPort.setReference('P802.1d/D9, July 14, 1989: Section 6.8.2.1.2')
if mibBuilder.loadTexts: bridgeDot1dStpPort.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPort.setDescription('The port number of the port for which this entry contains Spanning Tree Protocol management information.')
bridgeDot1dStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.1')
if mibBuilder.loadTexts: bridgeDot1dStpPortPriority.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID. The other octet of the Port ID is given by the value of dot1dStpPort.')
bridgeDot1dStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortState.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: bridgeDot1dStpPortState.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see dot1dStpPortEnable), this object will have a value of disabled(1).")
bridgeDot1dStpPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortEnable.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: bridgeDot1dStpPortEnable.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortEnable.setDescription('The enabled/disabled status of the port.')
bridgeDot1dStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortPathCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.3')
if mibBuilder.loadTexts: bridgeDot1dStpPortPathCost.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port.')
bridgeDot1dStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.4')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedRoot.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
bridgeDot1dStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.5')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedCost.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
bridgeDot1dStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedBridge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.6')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedBridge.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
bridgeDot1dStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.7')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedPort.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
bridgeDot1dStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 3, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStpPortForwardTransitions.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStpPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
bridgeStaticTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 4, 1), )
if mibBuilder.loadTexts: bridgeStaticTable.setReference('P802.1d/D9, July 14, 1989: Section 6.7.2')
if mibBuilder.loadTexts: bridgeStaticTable.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeStaticTable.setDescription('A table containing filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific destination addresses are allowed to be forwarded. The value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for unicast and for group/broadcast addresses.')
bridgeStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 4, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "bridgeDot1dStaticAddress"))
if mibBuilder.loadTexts: bridgeStaticEntry.setReference('P802.1d/D9, July 14,1989: Section 6.7.2')
if mibBuilder.loadTexts: bridgeStaticEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeStaticEntry.setDescription('Filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from a specific port and containing a specific destination address are allowed to be forwarded.')
bridgeDot1dStaticAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 1, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStaticAddress.setReference('P802.1d/D9, July 14, 1989: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: bridgeDot1dStaticAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStaticAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object can take the value of a unicast address, a group address or the broadcast address.")
bridgeDot1dStaticReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStaticReceivePort.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStaticReceivePort.setDescription("Either the value '0', or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.")
bridgeDot1dStaticAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStaticAllowedToGoTo.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStaticAllowedToGoTo.setDescription('This attribute contains a representation of the Outbound Ports associated with this static entry.')
bridgeDot1dStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeDot1dStaticStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bridgeDot1dStaticStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
bridgeProtFiltTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 4, 2), )
if mibBuilder.loadTexts: bridgeProtFiltTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtFiltTable.setDescription('A table containing protocol filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames containing protocol ID are allowed to be forwarded.')
bridgeProtFiltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 4, 2, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "brProtFiltIndex"))
if mibBuilder.loadTexts: bridgeProtFiltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtFiltEntry.setDescription('Protocol filtering information configured into the bridge by (local or network) management.')
brProtFiltIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtFiltIndex.setStatus('mandatory')
if mibBuilder.loadTexts: brProtFiltIndex.setDescription('This attribute is used as a unique identifier into the Bridge Protocol Filtering Table.')
brProtFiltName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtFiltName.setStatus('mandatory')
if mibBuilder.loadTexts: brProtFiltName.setDescription('A text string of up to 32 characters, of locally determined significance used to identify this Protocol filter.')
brProtFiltId = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtFiltId.setStatus('mandatory')
if mibBuilder.loadTexts: brProtFiltId.setDescription('This attribute identifies the protocol type to be filtered.')
brProtFiltPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtFiltPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: brProtFiltPortMap.setDescription('This attribute contains a representation of the Outbound Ports associated with this static entry.')
bridgeProtPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 4, 3), )
if mibBuilder.loadTexts: bridgeProtPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtPriorityTable.setDescription('A table containing protocol priority information configured into the bridge by (local or network) management specifying the priority in which frames will be transmitted on the wide area network links.')
bridgeProtPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 4, 3, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "brProtPriorityIndex"))
if mibBuilder.loadTexts: bridgeProtPriorityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeProtPriorityEntry.setDescription('Protocol priority information configured into the bridge by (local or network) management.')
brProtPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: brProtPriorityIndex.setDescription('This attribute is used as a unique identifier into the Bridge Protocol Priority Table.')
brProtPriorityName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtPriorityName.setStatus('mandatory')
if mibBuilder.loadTexts: brProtPriorityName.setDescription('A text string of up to 32 characters, of locally determined significance used to identify this Protocol Priority entry.')
brProtPriorityId = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtPriorityId.setStatus('mandatory')
if mibBuilder.loadTexts: brProtPriorityId.setDescription('This attribute identifies the protocol type to be prioritized.')
brProtPriorityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brProtPriorityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: brProtPriorityLevel.setDescription('The priority assigned to the associated Portocol ID')
wanPhysTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 5, 1), )
if mibBuilder.loadTexts: wanPhysTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysTable.setDescription('This table represent a view of Management Facilities for WAN physical ports.')
wanPhysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "wanPhysPortId"))
if mibBuilder.loadTexts: wanPhysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysEntry.setDescription('This list contains counters and parameters related to the management of WAN ports.')
wanPhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortId.setDescription('This attribute is used as a unique identifier for the Bridge WAN interface.')
wanPhysPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortName.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortName.setDescription('A text string of up to 32 characters, of locally determined significance used to identify this WAN interface.')
wanPhysLogicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysLogicalPort.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysLogicalPort.setDescription('This attribute shows the logical port for this Wan interface. Redundant links will have the same logical port.')
wanPhysDcdLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysDcdLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysDcdLevel.setDescription('This attribute shows the level of the DCD EIA signal on this particular WAN link.')
wanPhysLinkLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysLinkLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysLinkLevel.setDescription("This attribute shows whether the WAN link is 'up' or 'down'.")
wanTxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanTxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: wanTxLinkUtilization.setDescription('This attribute shows the link utilization in the TX direction. The utilization is a percentage of the bandwidth (0 to 100).')
wanRxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanRxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: wanRxLinkUtilization.setDescription('This attribute shows the link utilization in the RX direction. The utilization is a percentage of the bandwidth (0 to 100).')
wanPhysFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysFrameErrors.setDescription('This attribute shows the number of frame errors on this WAN interface.')
wanCompressionState = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanCompressionState.setStatus('mandatory')
if mibBuilder.loadTexts: wanCompressionState.setDescription('This attribute shows whether data compression is enabled or disabled.')
wanCompressionRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanCompressionRatio.setStatus('mandatory')
if mibBuilder.loadTexts: wanCompressionRatio.setDescription('An indication of how well the Bridge is compressing data that is to be transmitted to another bridge. A value of 100 shows no compression, a value of 300 shows a 3 : 1 compression.')
ieeeIfTable = MibTable((1, 3, 6, 1, 4, 1, 64, 2, 6, 1), )
if mibBuilder.loadTexts: ieeeIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIfTable.setDescription('This table represent a view of Management Facilities for the IEEE802.3 CSMA/CD MAC layer. The object was defined by IEEE in a 802.3 standard.')
ieeeIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "ieeeIfIndex"))
if mibBuilder.loadTexts: ieeeIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIfEntry.setDescription('This list contains counters and parameters related to the management of the IEEE802.3 MAC layer.')
ieeeIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIfIndex.setDescription('This attribute is used as a unique identifier for the Bridge LAN interface.')
ieeeFrmsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeFrmsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeFrmsTxOk.setDescription('This attribute contains a count of frames that are successfully transmitted.')
ieeeSingleCollFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeSingleCollFrms.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeSingleCollFrms.setDescription('This attribute contains a count of frames that are involved in a single collision and are subsequently transmitted successfuly.')
ieeeMultipleCollFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMultipleCollFrms.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMultipleCollFrms.setDescription('This attribute contains a count of frames that are involved in more than one collision and are subsequently transmitted successfully.')
ieeeOctetsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeOctetsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeOctetsTxOk.setDescription('This attribute contains a count of data and padding octets in frames that are successfully transmitted.')
ieeeDefTx = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeDefTx.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeDefTx.setDescription('This attribute contains a count of frames whose transmission was delayed on its first attempt becasue the medium was busy.')
ieeeMcastFrmsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMcastFrmsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMcastFrmsTxOk.setDescription('This attribute contains a count of frames that are successfully transmitted as indicated by the status value transmitOK, to a group destination address other than broadcast.')
ieeeBcastFrmsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeBcastFrmsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeBcastFrmsTxOk.setDescription('This attribute contains a number of broadcast frames transmitted to the LAN connection.')
ieeeLateColls = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeLateColls.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeLateColls.setDescription('This attribute contains a count of the times that a collision has been detected later than 512 bit times into the transmitted packet.')
ieeeExcessColls = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeExcessColls.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeExcessColls.setDescription('This attribute contains a count of frames that due to excessive collisions are not transmitted successfully.')
ieeeIntlMacTxError = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeIntlMacTxError.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIntlMacTxError.setDescription('This attribute contains a count of frames which would otherwise be transmitted by the station,but could not be sent due to an internal MAC sublayer transmit error.')
ieeeCsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeCsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeCsErrors.setDescription('This attribute contains number of frames that were lost because the ethernet carrier signal was lost.')
ieeeExcessDef = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeExcessDef.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeExcessDef.setDescription('This attribute contains a count of frames which deferred for an excessive period of time.')
ieeeFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeFrmsRxOk.setDescription('This attribute contains a count of frames that are successfully received.')
ieeeOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeOctetsRxOk.setDescription('This attribute contains a count of data and padding octets in frames that are successfully received.')
ieeeMcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMcastFrmsRxOk.setDescription('This attribute contains a count of frames that are successfully received and are directed to an active non-broadcast group of addresses.')
ieeeBcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeBcastFrmsRxOk.setDescription('This attribute contains a number of broadcast frames received from the LAN connection.')
ieeeTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeTooLongErrors.setDescription('This attribute contains a count of frames that are received and exceeded the maximum permitted frame size. This counter is incremented when the status of a frame reception is frame TooLong.')
ieeeAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeAlignErrors.setDescription('This attribute contains a count of frames that are not an integral of octets in length and do not pass the Frame Check Sequence(FCS) check.This counter is incremented when the ReceiveStatus is reported as alignmentError.')
ieeeFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeFcsErrors.setDescription('This attribute contains a count of frames that are an integral of octets in length and do not pass the Frame Check Sequence(FCS) check. This counter is incremented when the ReceiveStatus is reported as frameCheckError.')
ieeeIrLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeIrLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIrLengthErrors.setDescription('This attribute contains a count of frames with a length field value, between the minimum unpadded LLC data size and the maximum allowed LLC data size inclusive, that does not match the number of LLC data octets received. The counter also contains frames with a length field value less than the minimum unpadded LLC data size.')
ieeeOorLengthFields = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeOorLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeOorLengthFields.setDescription('This attribute contains a count of frames with a length field value greater than the maximum allowed LLC data size.')
ieeeIntlMacRcvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeIntlMacRcvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeIntlMacRcvErrors.setDescription('This attribute contains a count of frames which would otherwise be received by the station,but could not be accepted due to an internal MAC sublayer receive error.')
ieeeInitMac = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initialize", 1), ("uninitialize", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeInitMac.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeInitMac.setDescription('This attributes indicates wether the underlying IEEE 802.3 MAC was initialized.')
ieeePromRxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeePromRxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieeePromRxStatus.setDescription('This attribute contains the current state of the Prom.')
ieeeMacSubLayerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMacSubLayerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMacSubLayerStatus.setDescription('This attribute contains the current state of the Receive side of the underlying IEEE 802.3 resource.')
ieeeTxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeTxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeTxStatus.setDescription('This attribute contains the current state of the Transmit side of the underlying IEEE 802.3 resource.')
ieeeMcastRxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMcastRxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMcastRxStatus.setDescription('This attribute specifies if Multicast frames will be received by the underlying IEEE 802.3 resource.')
ieeeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeMacAddress.setDescription('This attribute contains the specific MAC Address of the individual MAC Entity associated with the Port.')
ieeeSqeTestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 2, 6, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieeeSqeTestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeSqeTestErrors.setDescription('This attribute contains a count of errors detected when performing an SQE test. This counter is not currently supported.')
ganEventLogTable = MibTable((1, 3, 6, 1, 4, 1, 64, 3, 1, 1), )
if mibBuilder.loadTexts: ganEventLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogTable.setDescription('A table containing alarm information.')
ganEventLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "ganEventLogIndex"))
if mibBuilder.loadTexts: ganEventLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogEntry.setDescription('Log information of alarms generated by the product, including time of event, severity and description.')
ganEventLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogIndex.setDescription('An index to the alarm table, not relevant other than to display the table.')
ganEventLogDate = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogDate.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogDate.setDescription('This date on which the event causing the alarm to be generated occurred.')
ganEventLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogTime.setDescription('This time at which the event causing the alarm to be generated occurred.')
ganEventLogEventNum = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogEventNum.setStatus('deprecated')
if mibBuilder.loadTexts: ganEventLogEventNum.setDescription('An index to the alarm table, not relevant other than to display the table. This attribute has been deprecated because it duplicates the ganEventLogIndex.')
ganEventLogSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("critical", 1), ("major", 2), ("minor", 3), ("warning", 4), ("cleared", 5), ("informational", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogSeverity.setDescription('An index to the event log table, not relevant other than to display the table.')
ganEventLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ganEventLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ganEventLogDescription.setDescription('Textual description of the event log.')
snmpCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 64, 3, 2, 1), )
if mibBuilder.loadTexts: snmpCommunityTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityTable.setDescription('This table provide a management view of which device can poll this resource via SNMP based on the Community Name, IP address and Privilege. Sets are supported ONLY in the Gandalf WAN proxy agent. To set a new community entry, use the instance 25 as the index value. Example: snmpCommunityName.25 Set all objects in the entry using instance 25. When the last object is set, the agent checks for duplicate entries and returns an error status if any found, otherwise the new entry is inserted at the next available position in the table. Existing entries may be modified by setting the a new value using an existing instance. The agent rejects any attempt to duplicate an entry. Objects may be deleted by setting the community name to one or more spaces. The entry is deleted and any vacated row is filled in by moving the last valid row there. NOTE: The object snmpTrapRemotePort is not supported in the Gandalf WAN Proxy agent.')
snmpCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 3, 2, 1, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "snmpCommunityIndex"))
if mibBuilder.loadTexts: snmpCommunityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityEntry.setDescription('This is a list of attributes that make the Community Table.')
snmpCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityIndex.setDescription('An 8 bit value unique within the Community Name.')
snmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityName.setDescription('The name of a Community supported by this SNMP agent.')
snmpCommunityIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityIpAddr.setDescription('The Ip Address of a manager associated with a Community that will be supported by the SNMP agent. A value of zero means that all managers from that Community will be supported.')
snmpCommunityPriv = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityPriv.setStatus('mandatory')
if mibBuilder.loadTexts: snmpCommunityPriv.setDescription('The access priviledge associated with a Community.')
snmpTrapCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 64, 3, 2, 2), )
if mibBuilder.loadTexts: snmpTrapCommunityTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunityTable.setDescription('This table provide a management view of which device(s) (i.e. LAN Managers) this resource will send Trap to. Sets are supported ONLY in the Gandalf WAN proxy agent. To set a new community entry, use the instance 25 as the index value. Example: snmpTrapCommunityName.25 Set all objects in the entry using instance 25. When the last object is set, the agent checks for duplicate entries and returns an error status if any found, otherwise the new entry is inserted at the next available position in the table. Existing entries may be modified by setting the a new value using an existing instance. The agent rejects any attempt to duplicate an entry. Objects may be deleted by setting the community name to one or more spaces. The entry is deleted and any vacated row is filled in by moving the last valid row there.')
snmpTrapCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 64, 3, 2, 2, 1), ).setIndexNames((0, "GANDALF-ENTERPRISE-MIB", "snmpTrapCommunityIndex"))
if mibBuilder.loadTexts: snmpTrapCommunityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunityEntry.setDescription('This is a list of attributes that make the Trap Community Table.')
snmpTrapCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapCommunityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunityIndex.setDescription('An 8 bit value unique within the Community Name.')
snmpTrapCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunityName.setDescription('The name of a Trap Community associated with a LAN Manager.')
snmpTrapIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapIpAddr.setDescription('The Ip Address of a manager that will receive Traps generated by this SNMP agent.')
snmpTrapRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 64, 3, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapRemotePort.setDescription('The remote UDP port number used by an agent to receive Traps (usually port 162 is used).')
snmpTrapDescription = MibScalar((1, 3, 6, 1, 4, 1, 64, 3, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapDescription.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapDescription.setDescription("This attribute provide a description of Enterprise Specific Traps. This is also known as the 'interesting information' of an Enterprise Specific Trap.")
gCardInstalled = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,100))
if mibBuilder.loadTexts: gCardInstalled.setDescription('This trap indicates that a card was physically installed in the hub. The trap description identify the card slot number.')
gCardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,101))
if mibBuilder.loadTexts: gCardRemoved.setDescription('This trap indicates that a card was physically removed from the hub. The trap description identify the card slot number.')
gCardMismatch = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,102))
if mibBuilder.loadTexts: gCardMismatch.setDescription('This trap indicates that a card was physically installed in a slot configured with a different card type.')
gCardMismatchCleared = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,103))
if mibBuilder.loadTexts: gCardMismatchCleared.setDescription('This trap indicates that the slot causing a Card Mismatch was reconfigured with the proper card type.')
gPortThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,104))
if mibBuilder.loadTexts: gPortThresholdExceeded.setDescription('This trap indicates a time based or frame based threshold is exceeded on a given port. The trap description will indicate the type of threshold, as well as identifing the card and port number.')
gNvramFault = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,105))
if mibBuilder.loadTexts: gNvramFault.setDescription('This trap indicates a critical hardware failure: an NVRAM fault.')
gFiltDatabaseFull = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,106))
if mibBuilder.loadTexts: gFiltDatabaseFull.setDescription("This trap indicates that the number of entries in the Filtering Database has reached the bridge's storing capacity.")
gPowerSupplyFailed = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,107))
if mibBuilder.loadTexts: gPowerSupplyFailed.setDescription('This trap indicates that a fault was detected on a power supply. The trap description will indicate which of the two power supply is faulty.')
gLogThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,108))
if mibBuilder.loadTexts: gLogThresholdExceeded.setDescription('This trap indicates that the event log capacity was exceeded.')
gLinkMismatch = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,109))
if mibBuilder.loadTexts: gLinkMismatch.setDescription('This trap indicates that the configuration of a WAN port is incompatible with the network topology.')
gLinkMismatchCleared = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,110))
if mibBuilder.loadTexts: gLinkMismatchCleared.setDescription('This trap indicates that the condition causing a Link Mismatch was corrected.')
gNewRoot = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,111))
if mibBuilder.loadTexts: gNewRoot.setDescription('The newRoot trap indicates that the sending agent has become the new root of the Spanning Tree; the trap is sent by a bridge soon after its election as the new root, e.g., upon expiration of the Topology Change Timer immediately subsequent to its election.')
gTopologyChange = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,112))
if mibBuilder.loadTexts: gTopologyChange.setDescription('A topologyChange trap is sent by a bridge when any of its configured ports transitions from the Learning state to the Forwarding state, or from the Forwarding state to the Blocking state. The trap is not sent if a newRoot trap is sent for the same transition.')
gPortFailure = NotificationType((1, 3, 6, 1, 4, 1, 64) + (0,113))
if mibBuilder.loadTexts: gPortFailure.setDescription('A link to a port has failed. Possible reasons: 1. Master port idle receive timer has expired. Port has been disabled and declared faulty. Standby port will take over if ready. 2. Standby port idle receive timer has expired. Port has been disabled and declared faulty.')
mibBuilder.exportSymbols("GANDALF-ENTERPRISE-MIB", hmBasicCardEntry=hmBasicCardEntry, hmAddrTrackPortTable=hmAddrTrackPortTable, bridgeDot1dStpHoldTime=bridgeDot1dStpHoldTime, gCardRemoved=gCardRemoved, bridgeNumPorts=bridgeNumPorts, ieeeIntlMacRcvErrors=ieeeIntlMacRcvErrors, protocolFilterState=protocolFilterState, xpressway5250isdn_typ1=xpressway5250isdn_typ1, gandalf_generic=gandalf_generic, wanPhysLogicalPort=wanPhysLogicalPort, hubTimeSinceReset=hubTimeSinceReset, gandalf=gandalf, lanline5220e=lanline5220e, gtsplus=gtsplus, ieee8023Object=ieee8023Object, gCardIbmModeB=gCardIbmModeB, wanTxLinkUtilization=wanTxLinkUtilization, gPortMulticastFrames=gPortMulticastFrames, snmpTrapCommunityIndex=snmpTrapCommunityIndex, gPortLinkStatus=gPortLinkStatus, bridgeTpFdbTable=bridgeTpFdbTable, lanline5250i=lanline5250i, gCardRingNumberA=gCardRingNumberA, hubManID=hubManID, gPortAutoPartitionCount=gPortAutoPartitionCount, bridgeTpFdbEntry=bridgeTpFdbEntry, bridgeDot1dTpPortOutFrames=bridgeDot1dTpPortOutFrames, wanPhysPortId=wanPhysPortId, ieeeMacSubLayerStatus=ieeeMacSubLayerStatus, ieeeSqeTestErrors=ieeeSqeTestErrors, rsc9000=rsc9000, gandalf_products=gandalf_products, bridgeDot1dStpMaxAge=bridgeDot1dStpMaxAge, hubEEpromRev=hubEEpromRev, ieeeIfIndex=ieeeIfIndex, gPortSourceAddrChanges=gPortSourceAddrChanges, gLogThresholdExceeded=gLogThresholdExceeded, gPortPygmys=gPortPygmys, ieeeOctetsTxOk=ieeeOctetsTxOk, ganEventLogSeverity=ganEventLogSeverity, gCardType=gCardType, bridgeBaseAddress=bridgeBaseAddress, hubRelayActive=hubRelayActive, hubNumOfRelays=hubNumOfRelays, bridgeDot1dStpBridgeMaxAge=bridgeDot1dStpBridgeMaxAge, bridgeDot1dStpBridgeHelloTime=bridgeDot1dStpBridgeHelloTime, gPortRedundantPort=gPortRedundantPort, gandalf_termserver=gandalf_termserver, bridgeDot1dTpFdbStatus=bridgeDot1dTpFdbStatus, bridgeLogicalPortEntry=bridgeLogicalPortEntry, bridgeProtFiltTable=bridgeProtFiltTable, bridgeDot1dStpPortPriority=bridgeDot1dStpPortPriority, bridgeProtPriorityTable=bridgeProtPriorityTable, hubResetting=hubResetting, ieeeMcastFrmsTxOk=ieeeMcastFrmsTxOk, brProtPriorityId=brProtPriorityId, ganEventLogDate=ganEventLogDate, hubName=hubName, hmBasicPortEntry=hmBasicPortEntry, gProd_hub=gProd_hub, gCardName=gCardName, gPortReadableOctets=gPortReadableOctets, numberOfStaticEntries=numberOfStaticEntries, ganEventLogTime=ganEventLogTime, ieeeMcastRxStatus=ieeeMcastRxStatus, gPortFailure=gPortFailure, ieeeDefTx=ieeeDefTx, hmBasicPortTable=hmBasicPortTable, wanPhysFrameErrors=wanPhysFrameErrors, gCardMismatch=gCardMismatch, bridgeDot1dStpPortState=bridgeDot1dStpPortState, gPortCollisions=gPortCollisions, broadcastForwardingState=broadcastForwardingState, ieeeAlignErrors=ieeeAlignErrors, gPortFrameCheckSeqErrs=gPortFrameCheckSeqErrs, gandalf_router=gandalf_router, gCardMismatchCleared=gCardMismatchCleared, gPortConfiguration=gPortConfiguration, gCardRingNumberB=gCardRingNumberB, bridgeProtPriorityEntry=bridgeProtPriorityEntry, ieeeSingleCollFrms=ieeeSingleCollFrms, gCardIbmModeA=gCardIbmModeA, lanline5242=lanline5242, gPortRedundantCard=gPortRedundantCard, gandalf_2590=gandalf_2590, xpressway5250isdn_typ2=xpressway5250isdn_typ2, xbr6202=xbr6202, hmSelfTestCapability=hmSelfTestCapability, lanline5250L=lanline5250L, hubResetTimeStamp=hubResetTimeStamp, multicastForwardingState=multicastForwardingState, ieeeMacAddress=ieeeMacAddress, snmpCommunityName=snmpCommunityName, gandalf_rlanisdn=gandalf_rlanisdn, bridgeManProductVersion=bridgeManProductVersion, ieeePromRxStatus=ieeePromRxStatus, gNvramFault=gNvramFault, bridgeDot1dStpPortForwardTransitions=bridgeDot1dStpPortForwardTransitions, ieeeFrmsTxOk=ieeeFrmsTxOk, lanline5240i=lanline5240i, brProtPriorityName=brProtPriorityName, gandalf_wanProxy=gandalf_wanProxy, lanline5225i=lanline5225i, ieeeIfTable=ieeeIfTable, snmpCommunityIndex=snmpCommunityIndex, gProd_termserver=gProd_termserver, bridgeDot1dStpRootPort=bridgeDot1dStpRootPort, gTopologyChange=gTopologyChange, bridgeDot1dStpPortDesignatedRoot=bridgeDot1dStpPortDesignatedRoot, bridgeDot1dTpPortInFrames=bridgeDot1dTpPortInFrames, bridgeDot1dStpPortDesignatedCost=bridgeDot1dStpPortDesignatedCost, lanline5220L=lanline5220L, hubResetAction=hubResetAction, hubSelfTestID=hubSelfTestID, hubHealthState=hubHealthState, bridgeDot1dStaticAllowedToGoTo=bridgeDot1dStaticAllowedToGoTo, hubManProductVersion=hubManProductVersion, wanCompressionRatio=wanCompressionRatio, gPortBroadcastFrames=gPortBroadcastFrames, bridgeDot1dStpPortDesignatedBridge=bridgeDot1dStpPortDesignatedBridge, agingState=agingState, g2300=g2300, gPortRunts=gPortRunts, hmBasicCardTable=hmBasicCardTable, gPortReadableFrames=gPortReadableFrames, bridgeDot1dTpFdbPort=bridgeDot1dTpFdbPort, bridgeStpPortEntry=bridgeStpPortEntry, ieeeCsErrors=ieeeCsErrors, gPortPerfID=gPortPerfID, gPowerSupplyFailed=gPowerSupplyFailed, ieeeIntlMacTxError=ieeeIntlMacTxError, wanPhysDcdLevel=wanPhysDcdLevel, hubManTelephoneNum=hubManTelephoneNum, bridgeConfigObject=bridgeConfigObject, bridgeDot1dTpFdbAddress=bridgeDot1dTpFdbAddress, ieeeMultipleCollFrms=ieeeMultipleCollFrms, ieeeExcessColls=ieeeExcessColls, bridgeStpPortTable=bridgeStpPortTable, bridgeProtFiltEntry=bridgeProtFiltEntry, ieeeBcastFrmsRxOk=ieeeBcastFrmsRxOk, bridgeLogicalPortTable=bridgeLogicalPortTable, hubIEEE8023LmeOptions=hubIEEE8023LmeOptions, agingTime=agingTime, wanPhysTable=wanPhysTable, lanline5250fr=lanline5250fr, wgm2590_hub=wgm2590_hub, gCardBasicID=gCardBasicID, learningState=learningState, snmpTrapIpAddr=snmpTrapIpAddr, gandalf_experimental=gandalf_experimental, bridgeManID=bridgeManID, relayPerfID=relayPerfID, bridgeDot1dStaticReceivePort=bridgeDot1dStaticReceivePort, wanPhysPortName=wanPhysPortName, brProtFiltName=brProtFiltName, gFiltDatabaseFull=gFiltDatabaseFull, gCardRingSpeedB=gCardRingSpeedB, gCardAddrID=gCardAddrID, ganEventLogIndex=ganEventLogIndex, ieeeFrmsRxOk=ieeeFrmsRxOk, gPortAddrID=gPortAddrID, bridgeDot1dTpPort=bridgeDot1dTpPort, bridgeDot1dStpPortDesignatedPort=bridgeDot1dStpPortDesignatedPort, ganEventLogDescription=ganEventLogDescription, gPortAdminState=gPortAdminState, bridgeDot1dStaticStatus=bridgeDot1dStaticStatus, snmpTrapCommunityEntry=snmpTrapCommunityEntry, gProd_wan=gProd_wan, hubCardMap=hubCardMap, bridgeDot1dStpPortEnable=bridgeDot1dStpPortEnable, wanPhysLinkLevel=wanPhysLinkLevel, snmpTrapCommunityName=snmpTrapCommunityName, g2050=g2050, bridgeDot1dStpPortPathCost=bridgeDot1dStpPortPathCost, bridgeDot1dTpPortMaxInfo=bridgeDot1dTpPortMaxInfo, gPortID=gPortID, bridgeType=bridgeType, bridgeDot1dStaticAddress=bridgeDot1dStaticAddress, snmpTrapRemotePort=snmpTrapRemotePort, bridgeNumOfInterfaces=bridgeNumOfInterfaces, bridgeDot1dStpPriority=bridgeDot1dStpPriority, hubBasicID=hubBasicID, snmpCommunityPriv=snmpCommunityPriv, gProd_router=gProd_router, hubSecureMode=hubSecureMode, ganEventLogTable=ganEventLogTable, bridgeStaticTable=bridgeStaticTable, gPortType=gPortType, gProxy=gProxy, hmPerfMonCapability=hmPerfMonCapability, filterDatabaseSize=filterDatabaseSize, wanPhysEntry=wanPhysEntry, gProd_bridge=gProd_bridge, hubExecutingSelfTest=hubExecutingSelfTest, gandalf_hub=gandalf_hub, bridgeIpAddr=bridgeIpAddr, xbr6204=xbr6204, gandalf_wanNode=gandalf_wanNode, bridgeEEpromRev=bridgeEEpromRev, bridgeSerialNum=bridgeSerialNum, hubStandardRevision=hubStandardRevision, bridgeStaticObject=bridgeStaticObject, hubCardCapacity=hubCardCapacity, bridgeHubChassis=bridgeHubChassis, bridgeStaticEntry=bridgeStaticEntry, gandalfLog=gandalfLog, brProtFiltId=brProtFiltId, brProtPriorityIndex=brProtPriorityIndex, bridgeTpObject=bridgeTpObject, brProtPriorityLevel=brProtPriorityLevel, ieeeLateColls=ieeeLateColls, snmpCommunityEntry=snmpCommunityEntry, gandalf_bridge=gandalf_bridge, ieeeIfEntry=ieeeIfEntry, ganEventLogEventNum=ganEventLogEventNum, bridgeDot1dStpRootCost=bridgeDot1dStpRootCost, hmPerfMonPortTable=hmPerfMonPortTable, hubResourceType=hubResourceType, hubHealthData=hubHealthData, bridgeDot1dStpTimeSinceTopologyChange=bridgeDot1dStpTimeSinceTopologyChange, bridgeDot1dStpTopChanges=bridgeDot1dStpTopChanges, lanline5221=lanline5221, numberOfDynamicEntries=numberOfDynamicEntries, snmpTrapCommunityTable=snmpTrapCommunityTable, gCardInstalled=gCardInstalled, bridgeDot1dStpHelloTime=bridgeDot1dStpHelloTime, ieeeOorLengthFields=ieeeOorLengthFields, hubSystemResetting=hubSystemResetting, gPortAlarms=gPortAlarms, snmpTrapDescription=snmpTrapDescription, gLinkMismatchCleared=gLinkMismatchCleared, bridgeDot1dTpPortInDiscards=bridgeDot1dTpPortInDiscards, bridgeDot1dStpForwardDelay=bridgeDot1dStpForwardDelay, bridgeDot1dStpBridgeForwardDelay=bridgeDot1dStpBridgeForwardDelay, gPortAlignmentErrors=gPortAlignmentErrors, gCardPerfID=gCardPerfID, brProtFiltPortMap=brProtFiltPortMap, ieeeIrLengthErrors=ieeeIrLengthErrors, hmAddrTrackPortEntry=hmAddrTrackPortEntry, bridgeDot1dStpPort=bridgeDot1dStpPort, ecm1000=ecm1000, ieeeTxStatus=ieeeTxStatus, gCardNumberOfPorts=gCardNumberOfPorts, bridgePowerUpStatus=bridgePowerUpStatus, wanRxLinkUtilization=wanRxLinkUtilization, ieeeMcastFrmsRxOk=ieeeMcastFrmsRxOk, hubIPaddress=hubIPaddress, gPortEffectiveState=gPortEffectiveState, gandalf_nms=gandalf_nms, snmpCommunityTable=snmpCommunityTable, bridgeStpObject=bridgeStpObject, brProtFiltIndex=brProtFiltIndex, ieeeInitMac=ieeeInitMac, ieeeTooLongErrors=ieeeTooLongErrors)
mibBuilder.exportSymbols("GANDALF-ENTERPRISE-MIB", wanCompressionState=wanCompressionState, ganEventLogEntry=ganEventLogEntry, gts1000=gts1000, relayTotalCollisions=relayTotalCollisions, hubManProductID=hubManProductID, snmpCommunityIpAddr=snmpCommunityIpAddr, gPortAutoPartitionState=gPortAutoPartitionState, hmPerfMonRelayTable=hmPerfMonRelayTable, hubHealthText=hubHealthText, gProd_gateway=gProd_gateway, gPortLateCollisions=gPortLateCollisions, ieeeBcastFrmsTxOk=ieeeBcastFrmsTxOk, gLinkMismatch=gLinkMismatch, gCardRingSpeedA=gCardRingSpeedA, ieeeExcessDef=ieeeExcessDef, gCardID=gCardID, ieeeOctetsRxOk=ieeeOctetsRxOk, ieeeFcsErrors=ieeeFcsErrors, gPortName=gPortName, gPortFramesTooLong=gPortFramesTooLong, hmPerfMonRelayEntry=hmPerfMonRelayEntry, hmBasicCapability=hmBasicCapability, snmpAdminCapability=snmpAdminCapability, gNewRoot=gNewRoot, bridgeDot1dStpProtocolSpecification=bridgeDot1dStpProtocolSpecification, bridgeDot1dStpDesignatedRoot=bridgeDot1dStpDesignatedRoot, wgm2590_standalone=wgm2590_standalone, hmPerfMonPortEntry=hmPerfMonPortEntry, gPortThresholdExceeded=gPortThresholdExceeded, hmAddrTrackCapability=hmAddrTrackCapability, gPortLastSourceAddress=gPortLastSourceAddress, lanline5242er=lanline5242er, wanPhysicalObject=wanPhysicalObject)

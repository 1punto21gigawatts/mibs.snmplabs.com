#
# PySNMP MIB module SLED-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SLED-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
clabProjDocsis, = mibBuilder.importSymbols("CLAB-DEF-MIB", "clabProjDocsis")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Counter64, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, Integer32, IpAddress, Unsigned32, ObjectIdentity, MibIdentifier, TimeTicks, Bits, ModuleIdentity, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "Integer32", "IpAddress", "Unsigned32", "ObjectIdentity", "MibIdentifier", "TimeTicks", "Bits", "ModuleIdentity", "Counter32")
TimeStamp, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TruthValue", "DisplayString", "TextualConvention")
sledMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13))
sledMib.setRevisions(('2007-05-18 00:00', '2006-07-28 00:00', '2005-02-09 00:00', '2004-11-24 00:00', '2003-10-15 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: sledMib.setRevisionsDescriptions(('This revision is published as part of the CableLabs eDOCSIS Specification I12.', 'This revision is published as part of the CableLabs eDOCSIS Specification I09.', 'This revision is published as part of the CableLabs eDOCSIS Specification I05.', 'This revision is published as part of the CableLabs eDOCSIS Specification I04.', 'Initial version of the eDOCSIS SLED MIB module. This revision is published as part of the CableLabs eDOCSIS Specification I02.',))
if mibBuilder.loadTexts: sledMib.setLastUpdated('200705180000Z')
if mibBuilder.loadTexts: sledMib.setOrganization('CableLabs eDOCSIS Working Group')
if mibBuilder.loadTexts: sledMib.setContactInfo('Postal: Cable Television Laboratories, Inc 858 Coal Creek Circle Louisville, CO 80027 U.S.A. Phone: +1 303-661-9100 Fax: +1 303-661-9199 E-mail: mibs@cablelabs.com')
if mibBuilder.loadTexts: sledMib.setDescription('This MIB module provides the management objects necessary to configure and invoke the Software Loopback Application for eDOCSIS (SLED) functionality. Copyright 1999-2007 Cable Television Laboratories, Inc. All rights reserved.')
sledNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 0))
sledMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1))
sledMibNotificationsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 2))
sledMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 3))
sledGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 1))
sledLoopback = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 2))
sledPktGen = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3))
sledGlobalEnable = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledGlobalEnable.setStatus('current')
if mibBuilder.loadTexts: sledGlobalEnable.setDescription("This object allows the SLED functionality to be enabled/disabled. This object may only be updated prior to device registration. If the device has completed registration, any attempt to update the value of this object returns 'notWritable'. Prior to registration, if the value of this object is set to 'true', the SLED functionality is enabled and access to this MIB is allowed. Prior to registration, if the value of this object is set to 'false', the SLED functionality is disabled and any attempt to update other objects in this MIB returns 'noAccess'.")
sledLoopbackInterface = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 2, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledLoopbackInterface.setStatus('current')
if mibBuilder.loadTexts: sledLoopbackInterface.setDescription("The index of the logical CPE interface (LCI) that the SLED loopback function is attached to. If the index does not correspond to a LCI supported by this device, 'wrongValue' is returned. Any attempt to set this object while sledLoopbackEnable is set to 'true' returns'notWritable'.")
sledLoopbackEnable = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 2, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledLoopbackEnable.setStatus('current')
if mibBuilder.loadTexts: sledLoopbackEnable.setDescription("Setting this object to 'true' enables the loopback function. Setting this object to 'false' disables the loopback function. When enabled, the eCM removes the Ethernet FCS/CRC32 from the original packets. All Ethernet packets received by the SLED from the LCI are then processed as follows: 1. If the received Ethernet packet is greater than 1472 octets, the Ethernet packet is split into two fragments, the first consisting of the first 1472 octets of the Ethernet packet and the second containing the remaining octets, resulting in two payloads that are processed as described below. If the received Ethernet packet is less than or equal to 1472 octets, the entire packet will be processed as a single payload. 2. For each payload generated in step 1, the payload is appended to the contents of sledLoopbackPktHdr. 3. The mutable fields within sledLoopbackPktHdr MUST be recomputed. The mutable fields are IP Header Checksum, IP Total Length, UDP Checksum, and UDP Length. 4. If the Ethernet packet was fragmented in step 1, the appropriate IP header fields (Flags and Fragment Offset) are updated to indicate IP fragmentation These IP fragmentation header values will differ depending on if this is the first or second fragment being processed. 5. The Ethernet FCS is computed and appended. 6. The resulting Ethernet packet is transmitted to the LCI.")
sledLoopbackPktHdr = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(42, 42)).setFixedLength(42)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledLoopbackPktHdr.setStatus('current')
if mibBuilder.loadTexts: sledLoopbackPktHdr.setDescription("A properly formatted Ethernet(DIX)+IP+UDP headers for use in SLED loopback processing as described in sledLoopbackEnable. The object value contains mutable fields that are recomputed: the IP Header Checksum, IP Total Length, UDP Length, and UDP Checksum. Any attempt to set this object while sledLoopbackEnable is set to 'true' returns 'notWritable'.")
sledPktGenInterface = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledPktGenInterface.setStatus('current')
if mibBuilder.loadTexts: sledPktGenInterface.setDescription("The index of the logical CPE interface (LCI) that the SLED packet generation function is attached to. If the index does not correspond to a LCI supported by the device, 'wrongValue' is returned. Any attempt to set this object while sledPktGenTrigger is set to 'start' returns 'notWritable'.")
sledPktGenPayload = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 1518))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledPktGenPayload.setStatus('current')
if mibBuilder.loadTexts: sledPktGenPayload.setDescription("The properly formatted Ethernet packet payload to be generated. Any attempt to set this object while sledPktGenTrigger is set to 'start' returns 'notWritable'.")
sledPktGenRate = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 3), Unsigned32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledPktGenRate.setStatus('current')
if mibBuilder.loadTexts: sledPktGenRate.setDescription("The packet rate (in packets per second) that the SLED is to transmit the packet specified in the sledPktGenPayload. Any attempt to set this object while sledPktGenTrigger is set to 'start' returns 'notWritable'.")
sledPktGenNumPkts = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 4), Unsigned32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledPktGenNumPkts.setStatus('current')
if mibBuilder.loadTexts: sledPktGenNumPkts.setDescription("Number of packets to be generated at the rate specified by sledPktGenRate. Any attempt to set this object while sledPktGenTrigger has been set to 'start' will return 'notWritable'.")
sledPktGenTrigger = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2))).clone('stop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sledPktGenTrigger.setStatus('current')
if mibBuilder.loadTexts: sledPktGenTrigger.setDescription("This object controls the packet generation. Setting this object to 'start' causes the packet generation to begin. Reading this object will return 'start' if a packet generation is in progress, otherwise it will return 'stop'. Setting this object to 'stop' while packet generation is in progress aborts the packet generation. Setting this object to 'start' while packet generation is in progress, 'wrongValue' is returned.")
sledPktGenLastTrigger = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 1, 3, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sledPktGenLastTrigger.setStatus('current')
if mibBuilder.loadTexts: sledPktGenLastTrigger.setDescription('Value of sysUptime when the packet generation was last triggered.')
sledMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 3, 1))
sledMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 3, 2))
sledMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 3, 1, 1)).setObjects(("SLED-MIB", "sledMibBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sledMibCompliance = sledMibCompliance.setStatus('current')
if mibBuilder.loadTexts: sledMibCompliance.setDescription('The compliance statement for SLED.')
sledMibBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 13, 3, 2, 1)).setObjects(("SLED-MIB", "sledGlobalEnable"), ("SLED-MIB", "sledLoopbackInterface"), ("SLED-MIB", "sledLoopbackEnable"), ("SLED-MIB", "sledLoopbackPktHdr"), ("SLED-MIB", "sledPktGenInterface"), ("SLED-MIB", "sledPktGenPayload"), ("SLED-MIB", "sledPktGenRate"), ("SLED-MIB", "sledPktGenNumPkts"), ("SLED-MIB", "sledPktGenTrigger"), ("SLED-MIB", "sledPktGenLastTrigger"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sledMibBaseGroup = sledMibBaseGroup.setStatus('current')
if mibBuilder.loadTexts: sledMibBaseGroup.setDescription('Group of object in SLED MIB.')
mibBuilder.exportSymbols("SLED-MIB", sledMibCompliance=sledMibCompliance, sledLoopbackInterface=sledLoopbackInterface, sledPktGenTrigger=sledPktGenTrigger, sledPktGenInterface=sledPktGenInterface, sledPktGenPayload=sledPktGenPayload, sledMibGroups=sledMibGroups, sledGlobalEnable=sledGlobalEnable, sledMibNotificationsObjects=sledMibNotificationsObjects, sledMibObjects=sledMibObjects, sledLoopback=sledLoopback, sledPktGen=sledPktGen, sledNotifications=sledNotifications, sledLoopbackPktHdr=sledLoopbackPktHdr, sledGlobal=sledGlobal, sledMibBaseGroup=sledMibBaseGroup, sledPktGenRate=sledPktGenRate, sledLoopbackEnable=sledLoopbackEnable, PYSNMP_MODULE_ID=sledMib, sledMibConformance=sledMibConformance, sledPktGenLastTrigger=sledPktGenLastTrigger, sledPktGenNumPkts=sledPktGenNumPkts, sledMib=sledMib, sledMibCompliances=sledMibCompliances)

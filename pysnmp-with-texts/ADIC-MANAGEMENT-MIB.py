#
# PySNMP MIB module ADIC-MANAGEMENT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ADIC-MANAGEMENT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:13:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
AdicMibVersion, AdicInterfaceType, trapSequenceNumber, trapSeverity, trapIntendedUsage, AdicREDIdentifier, AdicEnable, componentId, trapSummaryText, hardware, AdicDateAndTime, AdicOnlineStatus, AdicDoorStatus, AdicAgentStatus, AdicComponentType, RowStatus = mibBuilder.importSymbols("ADIC-INTELLIGENT-STORAGE-MIB", "AdicMibVersion", "AdicInterfaceType", "trapSequenceNumber", "trapSeverity", "trapIntendedUsage", "AdicREDIdentifier", "AdicEnable", "componentId", "trapSummaryText", "hardware", "AdicDateAndTime", "AdicOnlineStatus", "AdicDoorStatus", "AdicAgentStatus", "AdicComponentType", "RowStatus")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Counter32, Integer32, ObjectIdentity, iso, Gauge32, Counter64, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, NotificationType, TimeTicks, Bits, Unsigned32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "Integer32", "ObjectIdentity", "iso", "Gauge32", "Counter64", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "NotificationType", "TimeTicks", "Bits", "Unsigned32", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
management = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20))
globalStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10))
globalEthernetManager = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15))
systemManager = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20))
persistentData = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 30))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40))
licensing = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50))
eventManager = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70))
physicalLibrary = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80))
logicalLibrary = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90))
ras = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100))
class Boolean(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class AdicEthernetSpeed(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("baseT10", 1), ("baseT100", 2))

class AdicBarCode(DisplayString):
    pass

class AdicSegmentType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("gripper", 1), ("storage", 2), ("ie", 3), ("drive", 4))

class AdicInstallStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ok", 1), ("inProgress", 2), ("failed", 3), ("updateAborted", 4))

class AdicFcPortType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("auto", 1), ("nPort", 2), ("nlPort", 3))

class AdicFcPortSpeed(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 1000, 2000))
    namedValues = NamedValues(("auto", 1), ("megabits1000", 1000), ("megabits2000", 2000))

class AdicStatusGroup(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 99))
    namedValues = NamedValues(("connectivity", 1), ("control", 2), ("cooling", 3), ("drivesAndMedia", 4), ("power", 5), ("robotics", 6), ("all", 99))

class AdicStatusGroupState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("good", 1), ("failed", 2), ("degraded", 3), ("warning", 4), ("informational", 5), ("unknown", 6), ("invalid", 7))

class AdicRasTicketState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 99))
    namedValues = NamedValues(("new", 1), ("open", 2), ("suspended", 3), ("closed", 4), ("verified", 5), ("all", 99))

class AdicFruSerialNumber(DisplayString):
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(0, 40)

class AdicRasTicketSeverity(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("high", 1), ("medium", 2), ("low", 3))

globalStatusTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10), )
if mibBuilder.loadTexts: globalStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatusTable.setDescription('')
globalStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: globalStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatusEntry.setDescription('')
role = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: role.setStatus('mandatory')
if mibBuilder.loadTexts: role.setDescription('The role of this MCB in the management hierarchy.')
status = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 2), AdicAgentStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: status.setStatus('mandatory')
if mibBuilder.loadTexts: status.setDescription('Status of this MCB.')
systemDateAndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 3), AdicDateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDateAndTime.setStatus('mandatory')
if mibBuilder.loadTexts: systemDateAndTime.setDescription('Current time as set on system realtime clock. Also allows system realtime clock to be set.')
networkTimeServer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkTimeServer1.setStatus('mandatory')
if mibBuilder.loadTexts: networkTimeServer1.setDescription('IP address of the time server to be used.')
networkTimeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ntp", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkTimeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: networkTimeProtocol.setDescription('Protocol to use when with network time server.')
networkTimeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 6), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkTimeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: networkTimeEnable.setDescription('Enable/disabled the use of a network time server.')
managementMibVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 7), AdicMibVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: managementMibVersion.setDescription('Version of the ADIC-MANAGEMENT-MIB on which this agent is based.')
enableDaylightSavingsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 8), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableDaylightSavingsTime.setStatus('mandatory')
if mibBuilder.loadTexts: enableDaylightSavingsTime.setDescription('Enable automatic adjustment of the system date and time for daylight savings time.')
networkTimeServer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 10, 10, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkTimeServer2.setStatus('mandatory')
if mibBuilder.loadTexts: networkTimeServer2.setDescription('IP address of the second time server to be used. Multiple time servers may be used for redundancy and (or) improved time accuracy.')
globalEthernetTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10), )
if mibBuilder.loadTexts: globalEthernetTable.setStatus('mandatory')
if mibBuilder.loadTexts: globalEthernetTable.setDescription("Some Ethernet settings/switches. Routing tables are part of MIB-II, so we don't include them here.")
globalEthernetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: globalEthernetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: globalEthernetEntry.setDescription('')
mcbHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcbHostName.setStatus('mandatory')
if mibBuilder.loadTexts: mcbHostName.setDescription('Host name of this MCB.')
ipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddress.setDescription("IP Address of this MCB's external Ethernet port.")
dhcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 3), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpStatus.setDescription('State of DHCP support.')
ipAddressSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddressSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddressSubnetMask.setDescription('Read-Write version of MIB-II ipAdEntNetMask Object. ** Description clause from MIB-II text ** The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
speedAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 5), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: speedAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: speedAutoNegotiation.setDescription('Enables/disables automatic Ehternet speed negotiation.')
preferredSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 6), AdicEthernetSpeed()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: preferredSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: preferredSpeed.setDescription('The preferred Ethernet speed for this Ethernet port.')
actualSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 7), AdicEthernetSpeed()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: actualSpeed.setDescription('The actual (negotiated) speed for this Ethernet port.')
ethernetDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 15, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetDuplex.setDescription('The duplex setting for this Ethernet port.')
systemManagerTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10), )
if mibBuilder.loadTexts: systemManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: systemManagerTable.setDescription('')
systemManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "softwareComponentIndex"))
if mibBuilder.loadTexts: systemManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: systemManagerEntry.setDescription('The MCB System Manager (MSM) provides the high level system management of the MCB. The primary role of the MSM is to configure, initialize, and maintain the software processes running on the MCB.')
softwareComponentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareComponentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: softwareComponentIndex.setDescription('Identifies which piece of MCB software is being addressed.')
processRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: processRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: processRowStatus.setDescription('Row status object for creating/deleting system components.')
processPhysicalMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPhysicalMemory.setStatus('mandatory')
if mibBuilder.loadTexts: processPhysicalMemory.setDescription('The size in kilobytes of the actual software process binary.')
processResidentMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processResidentMemory.setStatus('mandatory')
if mibBuilder.loadTexts: processResidentMemory.setDescription('The size in kilobytes of the software process portion that is currently resident in memory.')
softwareInstallationTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20), )
if mibBuilder.loadTexts: softwareInstallationTable.setStatus('mandatory')
if mibBuilder.loadTexts: softwareInstallationTable.setDescription('This table controls installation of software packages/updates.')
softwareInstallationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: softwareInstallationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: softwareInstallationEntry.setDescription('')
installPackageName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: installPackageName.setStatus('mandatory')
if mibBuilder.loadTexts: installPackageName.setDescription('Filename and path of the package to be installed. The management application writes the filename here, which initiates the update process.')
installProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("inProgress", 2), ("failed", 3), ("updateAborted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: installProcessStatus.setDescription('ok - installation successful - this is the intial state inProgress - software package in being installed failed - software package installation failed. The status should return failed until another write to installPackageFilename. updateAborted - software installation was cancel and system reverts back to previous version')
installCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("download", 1), ("install", 2), ("abort", 3), ("timeEstimate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: installCommand.setStatus('mandatory')
if mibBuilder.loadTexts: installCommand.setDescription('download - copy firmware bundle to MCB but do not install install - commence installation (could be current bundle or previously downloaded bundle) abort - abort installation in progress rollback - rollback to the previous version of the system identified by the value in the previousFirmwareVersion field. timeEstimate - provides a estimate on the overall download time for a previously downloaded bundle')
installStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: installStatusText.setDescription('Indicates time to complete the entire installation: example: Estimated time to complete download xx minutes')
currentFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: currentFirmwareVersion.setDescription('Firmware revision currently on the i2000.')
previousFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: previousFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: previousFirmwareVersion.setDescription('Previous firmware revision on the i2000 that is available for rollback.')
downloadedFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: downloadedFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: downloadedFirmwareVersion.setDescription('Identifier for a the bundle that was previously downloaded to the i2000 but not installed.')
componentsInBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: componentsInBundle.setStatus('mandatory')
if mibBuilder.loadTexts: componentsInBundle.setDescription('Identifies the components being installed with this bundle ********************************************************** (LSB) bit 0 - MCB bit 1 - CMB bit 2 - RCU bit 3 - FCB bit 4 - AMC')
mcbInstallStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcbInstallStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: mcbInstallStatusText.setDescription('Provides detailed information about the MCB component install Example: download status (inprogress, complete, failed, not being upgraded) : current component : time to complete MCB')
cmbInstallStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmbInstallStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: cmbInstallStatusText.setDescription('Provides detailed information about the CMB component install Example: download status (inprogress, complete, failed, not being upgraded) : current CMB : time to complete CMB/s')
rcuInstallStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcuInstallStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: rcuInstallStatusText.setDescription('Provides detailed information about the RCU component install Example: download status (inprogress, complete, failed, not being upgraded) : current component : time to complete RCU')
fcbInstallStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcbInstallStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: fcbInstallStatusText.setDescription('Provides detailed information about the FCB component install Example: download status (inprogress, complete, failed, not being upgraded) : current fcb : time to complete FCB/s')
amcInstallStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amcInstallStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: amcInstallStatusText.setDescription('Provides detailed information about the AMC component install Example: download status (inprogress, complete, failed, not being upgraded) : current component : time to complete AMC')
mcbInstallProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 14), AdicInstallStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcbInstallProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcbInstallProcessStatus.setDescription('')
cmbInstallProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 15), AdicInstallStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmbInstallProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cmbInstallProcessStatus.setDescription('')
rcuInstallProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 16), AdicInstallStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcuInstallProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rcuInstallProcessStatus.setDescription('')
fcbInstallProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 17), AdicInstallStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcbInstallProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcbInstallProcessStatus.setDescription('')
amcInstallProcessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 20, 20, 1, 18), AdicInstallStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amcInstallProcessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: amcInstallProcessStatus.setDescription('')
persistentDataTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 30, 10), )
if mibBuilder.loadTexts: persistentDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: persistentDataTable.setDescription('')
persistentDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 30, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: persistentDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: persistentDataEntry.setDescription('')
capacity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 30, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capacity.setStatus('mandatory')
if mibBuilder.loadTexts: capacity.setDescription('The number of kilobytes of file space on this MCB.')
freeSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 30, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeSpace.setStatus('mandatory')
if mibBuilder.loadTexts: freeSpace.setDescription('The number of kilobytes of availble (unused) file space on this MCB.')
userTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20), )
if mibBuilder.loadTexts: userTable.setStatus('obsolete')
if mibBuilder.loadTexts: userTable.setDescription('** This table is obsolete. **')
userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "userName"))
if mibBuilder.loadTexts: userEntry.setStatus('obsolete')
if mibBuilder.loadTexts: userEntry.setDescription('** This entry object is obsolete. **')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userName.setStatus('obsolete')
if mibBuilder.loadTexts: userName.setDescription("** This object is obsolete. ** User's name.")
userRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: userRowStatus.setDescription('** This object is obsolete. ** Standard Row Status object. Used primarily to delete users.')
userGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userGroup.setStatus('obsolete')
if mibBuilder.loadTexts: userGroup.setDescription("** This object is obsolete. ** User's group.")
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('obsolete')
if mibBuilder.loadTexts: userPassword.setDescription("** This object is obsolete. ** User's password.")
userLibAccessList = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 40, 20, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userLibAccessList.setStatus('obsolete')
if mibBuilder.loadTexts: userLibAccessList.setDescription('** This object is obsolete. ** Delimited list of logical library identifiers to which this use has access.')
licenseKeyTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10), )
if mibBuilder.loadTexts: licenseKeyTable.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyTable.setDescription('')
licenseKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "licenseKeyIndex"))
if mibBuilder.loadTexts: licenseKeyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyEntry.setDescription('')
licenseKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyIndex.setDescription('Ordinal inde for this table. Identifies a license key database entry. Each key may enable multiple features. A list of features enabled by each key can be found in the licenseFeatureTable.')
licenseKeyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenseKeyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyRowStatus.setDescription('Controls creation/deletion of rows in the license key database.')
key = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: key.setStatus('mandatory')
if mibBuilder.loadTexts: key.setDescription('The license key string.')
licenseKeyDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("transient", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyDuration.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyDuration.setDescription('Is this license key permanent or transient? Permanent keys have no expiration date, transient keys expire at the time found in the licenseKeyExpirationDate object.')
licenseKeyExpirationDate = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 5), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyExpirationDate.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyExpirationDate.setDescription('Exact date and time when this license key expires. Has no meaning if license key is permanent.')
licenseKeyAppliedDate = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 10, 1, 6), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyAppliedDate.setStatus('mandatory')
if mibBuilder.loadTexts: licenseKeyAppliedDate.setDescription('Date and time when the license key was applied. This field indicates the chronological order in which the keys were applied. If multiple keys enable the same feature, the most recent key supercedes older keys.')
licenseFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 20), )
if mibBuilder.loadTexts: licenseFeatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: licenseFeatureTable.setDescription('This table is a list of all features activated by a particular license key.')
licenseFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "licenseKeyIndex"), (0, "ADIC-MANAGEMENT-MIB", "licenseFeatureIndex"))
if mibBuilder.loadTexts: licenseFeatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: licenseFeatureEntry.setDescription('')
licenseFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseFeatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: licenseFeatureIndex.setDescription('Feature index for this table, as well as licensable feature table. If a feature is not licensed, the row corresponding to that feature does not appear here, but it does appear in the licensableFeatureTable, as do all licensableFeatures.')
featureName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 20, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureName.setStatus('mandatory')
if mibBuilder.loadTexts: featureName.setDescription("Name of the ADIC licensed feature enable by this row's license key. The key is specified by the value of licenseKeyIndex.")
licenseFeatureQuantity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseFeatureQuantity.setStatus('mandatory')
if mibBuilder.loadTexts: licenseFeatureQuantity.setDescription('The quantity of this licensed feature enabled by this license key, if applicable. For example, a license key which enables 1000 slots of Capacity-on-Demand storage would have quantity = 1000. For features which are not licensed by quantity, return 0.')
licensableFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 30), )
if mibBuilder.loadTexts: licensableFeatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: licensableFeatureTable.setDescription('This table is a list of all licensable features. It defines the mapping between a feature name and its licenseFeatureIndex.')
licensableFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 30, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "licenseFeatureIndex"))
if mibBuilder.loadTexts: licensableFeatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: licensableFeatureEntry.setDescription('')
licensableFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 30, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licensableFeatureName.setStatus('mandatory')
if mibBuilder.loadTexts: licensableFeatureName.setDescription('Name of the ADIC licensable feature to be displayed to the user.')
totalQuantityLicensed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 50, 30, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalQuantityLicensed.setStatus('mandatory')
if mibBuilder.loadTexts: totalQuantityLicensed.setDescription('The total licensed quantity for this feature. For features which are licensed by quantity, this object returns the sum of the indiviual quantities enabled by each license key (see licenseFeatureQuantity). For example, if there were two COD license keys installed, one for 500 slots and one for 1000 slots, totalQuantityLicensed would return 1500.')
registrationTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 10), )
if mibBuilder.loadTexts: registrationTable.setStatus('mandatory')
if mibBuilder.loadTexts: registrationTable.setDescription('')
registrationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "hostIpAddress"), (0, "ADIC-MANAGEMENT-MIB", "udpPort"))
if mibBuilder.loadTexts: registrationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: registrationEntry.setDescription('')
hostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostIpAddress.setDescription('Host IP address to which SNMP traps will be sent/forwarded.')
udpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 10, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: udpPort.setStatus('mandatory')
if mibBuilder.loadTexts: udpPort.setDescription('UDP Port number on which to send/forward SNMP traps.')
registrationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 10, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: registrationRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: registrationRowStatus.setDescription('Controls creation/deletion of rows in the notification (trap registration) table.')
logTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 20), )
if mibBuilder.loadTexts: logTable.setStatus('optional')
if mibBuilder.loadTexts: logTable.setDescription('** This table is optional ** Management functionality for general event logging. Log entries are not necessarily available via SNMP.')
logEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logName"))
if mibBuilder.loadTexts: logEntry.setStatus('optional')
if mibBuilder.loadTexts: logEntry.setDescription('** This entry object is optional **')
logName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 20, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logName.setStatus('optional')
if mibBuilder.loadTexts: logName.setDescription('** This object is optional. ** Name of the log to be accessed.')
logSnapshotTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 30), )
if mibBuilder.loadTexts: logSnapshotTable.setStatus('optional')
if mibBuilder.loadTexts: logSnapshotTable.setDescription('** This table is optional. ** Management functionality for generating a snapshot archive containing all of the system logs')
logSnapshotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 30, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: logSnapshotEntry.setStatus('optional')
if mibBuilder.loadTexts: logSnapshotEntry.setDescription('** This entry object is optional. **')
logSnapshotCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 70, 30, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("retrieveLogs", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: logSnapshotCommand.setStatus('optional')
if mibBuilder.loadTexts: logSnapshotCommand.setDescription('** This object is optional. ** Commands are: ********************** retrieveLogs - Gather snapshots of various system logs in preparation to build snapshot archive file.')
phGeneralInfoTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10), )
if mibBuilder.loadTexts: phGeneralInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: phGeneralInfoTable.setDescription('')
phGeneralInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: phGeneralInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phGeneralInfoEntry.setDescription('')
numElementDomains = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numElementDomains.setStatus('mandatory')
if mibBuilder.loadTexts: numElementDomains.setDescription('Number of element domains (such as DLT, LTO, 8mm, etc.) currently installed in this physical library.')
numPhSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numPhSlots.setStatus('mandatory')
if mibBuilder.loadTexts: numPhSlots.setDescription('')
numPhIESlots = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numPhIESlots.setStatus('mandatory')
if mibBuilder.loadTexts: numPhIESlots.setDescription('')
numPhDrives = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numPhDrives.setStatus('mandatory')
if mibBuilder.loadTexts: numPhDrives.setDescription('')
onlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 5), AdicOnlineStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: onlineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: onlineStatus.setDescription('')
readiness = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("notReady", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: readiness.setStatus('mandatory')
if mibBuilder.loadTexts: readiness.setDescription('')
autoInventoryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 7), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoInventoryMode.setStatus('mandatory')
if mibBuilder.loadTexts: autoInventoryMode.setDescription('')
autoCalibrateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 8), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoCalibrateMode.setStatus('mandatory')
if mibBuilder.loadTexts: autoCalibrateMode.setDescription('')
autoConfigureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 9), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoConfigureMode.setStatus('mandatory')
if mibBuilder.loadTexts: autoConfigureMode.setDescription('')
numPhAisles = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numPhAisles.setStatus('mandatory')
if mibBuilder.loadTexts: numPhAisles.setDescription('Number of aisles in this library.')
operatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("unload", 3), ("delayAndUnload", 4), ("noUnload", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: operatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: operatingMode.setDescription('Controls library behavior when retrieving tape from drives.')
numStorageCartridges = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numStorageCartridges.setStatus('mandatory')
if mibBuilder.loadTexts: numStorageCartridges.setDescription('Total number of storage cartridges present in the library')
numCleaningCartridges = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numCleaningCartridges.setStatus('mandatory')
if mibBuilder.loadTexts: numCleaningCartridges.setDescription('Total number of cleaning cartridges present in the library')
physLibraryManagerLun = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physLibraryManagerLun.setStatus('mandatory')
if mibBuilder.loadTexts: physLibraryManagerLun.setDescription('The SCSI logical unit number of the Physical Library Manager.')
physLibraryAutoCleaning = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 15), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: physLibraryAutoCleaning.setStatus('mandatory')
if mibBuilder.loadTexts: physLibraryAutoCleaning.setDescription('Enable/disable automatic drive cleaning for the entire physical library.')
physLibraryDoorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 16), AdicDoorStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physLibraryDoorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: physLibraryDoorStatus.setDescription('State of the library door: (open/closed,locked/unlocked).')
numPhFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numPhFrames.setStatus('mandatory')
if mibBuilder.loadTexts: numPhFrames.setDescription('The number of physical frames in the library.')
totalRawCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalRawCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: totalRawCapacity.setDescription('An estimate of the amount of data which the library can hold. Units are gigabytes. May be computed by multiplying the number of cells by the maximum number of gigabytes per tape.')
totalFreeCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalFreeCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: totalFreeCapacity.setDescription('An estimate of the unused data capacity of the library. Units are gigabytes. May be computed by multiplying the number of empty cells by the maximum number of gigabytes per tape.')
totalUsedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalUsedCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: totalUsedCapacity.setDescription('An estimate of the used data capacity of the library. Units are gigabytes. May be computed by multiplying the number of full cells by the maximum number of gigabytes per tape.')
logicalSNAdressingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 10, 1, 21), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: logicalSNAdressingMode.setStatus('mandatory')
if mibBuilder.loadTexts: logicalSNAdressingMode.setDescription('Enables/disables the logical serial number addressing feature.')
mediaDomainTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20), )
if mibBuilder.loadTexts: mediaDomainTable.setStatus('mandatory')
if mibBuilder.loadTexts: mediaDomainTable.setDescription('Table of all media domains installed in the library.')
mediaDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"))
if mibBuilder.loadTexts: mediaDomainEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mediaDomainEntry.setDescription('')
mediaDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mediaDomainIndex.setDescription('')
mediaDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: mediaDomainName.setDescription('')
numStorageElements = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numStorageElements.setStatus('mandatory')
if mibBuilder.loadTexts: numStorageElements.setDescription('Total number of storage elements for this media domain in this physical library.')
numIeElements = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numIeElements.setStatus('mandatory')
if mibBuilder.loadTexts: numIeElements.setDescription('Total number of import/export elements for this media domain in this physical library.')
numCleaningSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 20, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numCleaningSlots.setStatus('mandatory')
if mibBuilder.loadTexts: numCleaningSlots.setDescription('Returns the number of storage slots reserved for cleaning media of this domain. When set, the value is the total number of slots to reserve for cleaning media of this domain. The library will reserve a set of storage segments such that total number of storage slots is greater than or equal to numCleaningSlots.')
mediaTypeTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 30), )
if mibBuilder.loadTexts: mediaTypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: mediaTypeTable.setDescription('Table of media types.')
mediaTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 30, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"))
if mibBuilder.loadTexts: mediaTypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mediaTypeEntry.setDescription('')
mediaTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mediaTypeIndex.setDescription('')
mediaTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 30, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaTypeName.setStatus('mandatory')
if mibBuilder.loadTexts: mediaTypeName.setDescription('')
numDriveElements = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 30, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numDriveElements.setStatus('mandatory')
if mibBuilder.loadTexts: numDriveElements.setDescription('Number of drives for this media type.')
phFrameTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 41), )
if mibBuilder.loadTexts: phFrameTable.setStatus('optional')
if mibBuilder.loadTexts: phFrameTable.setDescription('** This table is optional ** This is a list of all the frames in the library.')
phFrameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 41, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"))
if mibBuilder.loadTexts: phFrameEntry.setStatus('optional')
if mibBuilder.loadTexts: phFrameEntry.setDescription('** This entry object is optional **')
phFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 41, 1, 1), AdicComponentType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phFrameType.setStatus('optional')
if mibBuilder.loadTexts: phFrameType.setDescription('** This object is optional ** Physical type of frame. Only controlModule(6) and expansionModule(7) values are actually valid for the frame type.')
phFrameSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 41, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phFrameSerialNumber.setStatus('optional')
if mibBuilder.loadTexts: phFrameSerialNumber.setDescription('** This object is optional ** Serial number of this frame, if available.')
phFrameNumRacks = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 41, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phFrameNumRacks.setStatus('optional')
if mibBuilder.loadTexts: phFrameNumRacks.setDescription('** This object is optional ** Number of racks in this frame.')
phSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55), )
if mibBuilder.loadTexts: phSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentTable.setDescription('This is a list of all the segments in the library.')
phSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentType"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentStartingRow"))
if mibBuilder.loadTexts: phSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentEntry.setDescription('')
phSegmentAisle = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentAisle.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentAisle.setDescription('Aisle coordinate value for this segment.')
phSegmentFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentFrame.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentFrame.setDescription('Frame coordinate value for this segment.')
phSegmentRack = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentRack.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentRack.setDescription('Rack coordinate value for this segment.')
phSegmentSection = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentSection.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentSection.setDescription('Section coordinate for this segment.')
phSegmentCol = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentCol.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentCol.setDescription('Column coordinate value for this segment.')
phSegmentStartingRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentStartingRow.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentStartingRow.setDescription('Row coordinate of the first element in this segment. This is useful to divide a column into multiple segments. For instance, a segment which contains rows 1 - 10 would have phSegmentStartingRow = 1. A segment which contains rows 11 - 20 in the same column would have phSegmentStartingRow = 11.')
phSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentSize.setDescription('Number of elements in this segment.')
phSegmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 8), AdicSegmentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentType.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentType.setDescription("This segment's type (storage, drive, I/E, etc.).")
phSegmentMediaDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentMediaDomain.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentMediaDomain.setDescription('Element domain of this segment. Points a row in the media domain table.')
phSegmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("installed", 1), ("notInstalled", 2), ("reservedForCleaning", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentStatus.setDescription('Status of this segment. May be installed, not installed, or reserved for use by the automatic cleaning service.')
phSegmentCodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("noCod", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegmentCodStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phSegmentCodStatus.setDescription('Capacity on Demand (COD) status for this segment. noCod means that COD is not enabled for this library.')
phSegStartingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 55, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phSegStartingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: phSegStartingAddress.setDescription('SCSI media changer element address of the first row in this segment. Element addresses are contiguous, so we can derive the address of each row in the segment from the address of the first row.')
phStorageSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 60), )
if mibBuilder.loadTexts: phStorageSegTable.setStatus('mandatory')
if mibBuilder.loadTexts: phStorageSegTable.setDescription('This is a list of all the storage segments in the library, indexed by their media domain and segment Index.')
phStorageSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 60, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentStartingRow"))
if mibBuilder.loadTexts: phStorageSegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phStorageSegEntry.setDescription('')
phStorageSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 60, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phStorageSegSize.setStatus('mandatory')
if mibBuilder.loadTexts: phStorageSegSize.setDescription('Number of elements in this segment.')
phIeSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70), )
if mibBuilder.loadTexts: phIeSegTable.setStatus('optional')
if mibBuilder.loadTexts: phIeSegTable.setDescription('** Some objects in this table are optional ** This is a list of all the I/E segments in the library, indexed by their media domain and segment index.')
phIeSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentStartingRow"))
if mibBuilder.loadTexts: phIeSegEntry.setStatus('optional')
if mibBuilder.loadTexts: phIeSegEntry.setDescription('** Some objects in this entry are optional **')
phIeSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeSegSize.setStatus('optional')
if mibBuilder.loadTexts: phIeSegSize.setDescription('Number of elements in this segment.')
phIeSegReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reserve", 1), ("release", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phIeSegReserve.setStatus('optional')
if mibBuilder.loadTexts: phIeSegReserve.setDescription('** This object is optional ** Mechanism to release and reserve this I/E segment.')
phIeSegReservedBy = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phIeSegReservedBy.setStatus('optional')
if mibBuilder.loadTexts: phIeSegReservedBy.setDescription('** This object is optional ** Indicator of who reserved this I/E segment.')
phIeSegOnlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("online", 1), ("offline", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phIeSegOnlineStatus.setStatus('optional')
if mibBuilder.loadTexts: phIeSegOnlineStatus.setDescription('** This object is optional ** Takes this I/E segment online/offline.')
phIeSegCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 70, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("import", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phIeSegCommand.setStatus('optional')
if mibBuilder.loadTexts: phIeSegCommand.setDescription('** This object is optional ** Issue a command to this I/E station.')
phIeStationTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 75), )
if mibBuilder.loadTexts: phIeStationTable.setStatus('mandatory')
if mibBuilder.loadTexts: phIeStationTable.setDescription('This is a list of all the I/E stations in the library')
phIeStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 75, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phIeStationNumber"))
if mibBuilder.loadTexts: phIeStationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phIeStationEntry.setDescription('')
phIeStationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 75, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeStationNumber.setStatus('mandatory')
if mibBuilder.loadTexts: phIeStationNumber.setDescription('Index of I/E station within a frame. If a frame has N I/E stations, the range of phIeStationNumber is 1 through N.')
phIeStationDoorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 75, 1, 2), AdicDoorStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeStationDoorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phIeStationDoorStatus.setDescription('Is the station door open/closed, locked/unlocked ?')
phIeStationREDId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 75, 1, 3), AdicREDIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeStationREDId.setStatus('mandatory')
if mibBuilder.loadTexts: phIeStationREDId.setDescription('Runtime Error Detection identifier for this import/export station.')
phDriveSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 80), )
if mibBuilder.loadTexts: phDriveSegTable.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSegTable.setDescription('This is a list of all the drive segments in the library, indexed by their media domain, media type and segment index.')
phDriveSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 80, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentStartingRow"))
if mibBuilder.loadTexts: phDriveSegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSegEntry.setDescription('')
phDriveSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 80, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveSegSize.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSegSize.setDescription('Number of drive elements in this segment.')
phDriveSegMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 80, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveSegMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSegMediaType.setDescription('Exact media type of this segment. With phSegmentMediaDomain, points a row in the media type table.')
phDriveSegInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 80, 1, 3), AdicInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveSegInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSegInterfaceType.setDescription('Data interface type of this segment. ')
phCleaningSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 85), )
if mibBuilder.loadTexts: phCleaningSegTable.setStatus('optional')
if mibBuilder.loadTexts: phCleaningSegTable.setDescription('** This table is optional ** This is a list of all the storage segments in the library which have been reserved for use by automatic cleaning services.')
phCleaningSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 85, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentStartingRow"))
if mibBuilder.loadTexts: phCleaningSegEntry.setStatus('optional')
if mibBuilder.loadTexts: phCleaningSegEntry.setDescription('** This entry object is optional **')
phCleaningSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 85, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phCleaningSegSize.setStatus('optional')
if mibBuilder.loadTexts: phCleaningSegSize.setDescription('** This object is optional ** Number of elements in this segment.')
phCleaningSegRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 85, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningSegRowStatus.setStatus('optional')
if mibBuilder.loadTexts: phCleaningSegRowStatus.setDescription('** This object is optional ** Management application use this object to to reserve segment for cleaning or release the segment for use as storage.')
phStorageSlotTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 90), )
if mibBuilder.loadTexts: phStorageSlotTable.setStatus('optional')
if mibBuilder.loadTexts: phStorageSlotTable.setDescription('** This table is optional **')
phStorageSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 90, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phStorageRow"))
if mibBuilder.loadTexts: phStorageSlotEntry.setStatus('optional')
if mibBuilder.loadTexts: phStorageSlotEntry.setDescription('** This entry object is optional **')
phStorageRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 90, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phStorageRow.setStatus('optional')
if mibBuilder.loadTexts: phStorageRow.setDescription('** This object is optional ** Row coordinate value for this storage slot.')
phStorageElementAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 90, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phStorageElementAddr.setStatus('optional')
if mibBuilder.loadTexts: phStorageElementAddr.setDescription('** This object is optional ** SCSI Medium Changer Element Address for this storage slot.')
phIeSlotTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100), )
if mibBuilder.loadTexts: phIeSlotTable.setStatus('optional')
if mibBuilder.loadTexts: phIeSlotTable.setDescription('** This table is optional **')
phIeSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phIeRow"))
if mibBuilder.loadTexts: phIeSlotEntry.setStatus('optional')
if mibBuilder.loadTexts: phIeSlotEntry.setDescription('** This entry object is optional **')
phIeRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeRow.setStatus('optional')
if mibBuilder.loadTexts: phIeRow.setDescription('** This object is optional ** Row coordinate value for this I/E slot')
phIeElementAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeElementAddr.setStatus('optional')
if mibBuilder.loadTexts: phIeElementAddr.setDescription('** This object is optional ** SCSI Medium Changer Element Address for this I/E slot.')
phIeMediaPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("error", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeMediaPresent.setStatus('optional')
if mibBuilder.loadTexts: phIeMediaPresent.setDescription('** This object is optional ** Is a media cartridge present in this slot? Values are: yes(1) - system is certain that a cartridge is present. no(2) - system is certain that a cartridge is not present. error(3) - an error ocurred while determining if media is present. ')
phIeMediaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 100, 1, 4), AdicBarCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phIeMediaId.setStatus('optional')
if mibBuilder.loadTexts: phIeMediaId.setDescription('** This object is optional ** Media ID bar code of cartridge in this I/E slot, if present and available. Returns zero length string if the bar code is not available for any reason.')
phDriveTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110), )
if mibBuilder.loadTexts: phDriveTable.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveTable.setDescription('')
phDriveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phDriveRow"))
if mibBuilder.loadTexts: phDriveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveEntry.setDescription('')
phDriveRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveRow.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveRow.setDescription('Row coordinate value for this drive element.')
phDriveElementAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveElementAddr.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveElementAddr.setDescription('SCSI Element Address for this drive element.')
phDriveScsiId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveScsiId.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveScsiId.setDescription('')
phDriveScsiLun = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveScsiLun.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveScsiLun.setDescription('')
phDriveWwn = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveWwn.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveWwn.setDescription('World Wide Node Name for this drive.')
phDriveVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveVendor.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveVendor.setDescription('Name of the vendor of this drive.')
phDriveProduct = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveProduct.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveProduct.setDescription('Product name of this drive.')
phDriveSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveSerialNumber.setDescription('')
phDriveNeedsCleaning = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("immediate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveNeedsCleaning.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveNeedsCleaning.setDescription('')
phDriveAutoCleaning = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 10), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveAutoCleaning.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveAutoCleaning.setDescription('Add or remove this drive from automatic cleaning list.')
phDriveInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 11), AdicInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveInterfaceType.setDescription('Data interface type (SCSI, Fibre Channel, etc.).')
phDriveFcLoopId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveFcLoopId.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveFcLoopId.setDescription('Loop ID for Fibre Channel interface drives, undefined for other interface type drives.')
phDriveFcLoopIdMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("soft", 1), ("hard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveFcLoopIdMode.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveFcLoopIdMode.setDescription('Loop ID Mode for Fibre Channel interface drives, undefined for other interface type drives. Controls negotiation of the port ID on the Fibre Channel connection.')
phDriveFcHardId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveFcHardId.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveFcHardId.setDescription("Preferred port ID Mode for Fibre Channel interface drives, undefined for other interface type drives. Used only when port ID mode is set to 'hard'.")
phDriveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("loading", 1), ("loaded", 2), ("unloading", 3), ("empty", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveStatus.setDescription('')
phDriveCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("reset", 3), ("powerOn", 4), ("powerOff", 5), ("powerCycle", 6), ("driveBrickUpdate", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveCommand.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveCommand.setDescription('Perform various operations on a drive: *************************************** online(1) - bring drive online offline(2) - take drive offline reset(3) - perform a warm reset powerOn(4) - perform power on powerOff(5) - peform power off powerCycle(6) - perform power cycle driveBrickUpdate(7) - download firmware to the drive brick')
phDriveFcPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveFcPortId.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveFcPortId.setDescription('Port ID for fabric attached Fibre Channel drives, undefined for other interface type drives.')
phDriveCompressionOn = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 18), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveCompressionOn.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveCompressionOn.setDescription('Is compression turned on for this drive?')
phDriveWriteProtected = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 19), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phDriveWriteProtected.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveWriteProtected.setDescription('Is write protection turned on for this drive?')
phDriveNumLoads = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveNumLoads.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveNumLoads.setDescription('Total number of loads for this drive. Count is for the entire lifetime of the drive.')
phDriveNumCleans = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveNumCleans.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveNumCleans.setDescription('Total number of cleaning operations peroformed on this drive. Count is for the entire lifetime of the drive.')
phDrivePowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("poweredOn", 1), ("poweredOff", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDrivePowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phDrivePowerStatus.setDescription('Is this drive powered on?')
phDriveReadErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveReadErrors.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveReadErrors.setDescription('Number of read errors for this drive. Count is for the entire lifetime of the drive.')
phDriveWriteErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveWriteErrors.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveWriteErrors.setDescription('Number of write errors for this drive. Count is for the entire lifetime of the drive.')
phDriveMbytesRead = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveMbytesRead.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveMbytesRead.setDescription('Number of megabytes of data read from this drive.')
phDriveMbytesWritten = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveMbytesWritten.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveMbytesWritten.setDescription('Number of megabytes of data written to this drive.')
phDriveFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 27), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveFirmwareVersion.setDescription('Firmware version for this drive.')
phDriveREDId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 28), AdicREDIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveREDId.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveREDId.setDescription('Runtime Error Detection identifier for this tape drive.')
phDriveOnlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 29), AdicOnlineStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveOnlineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveOnlineStatus.setDescription('Returns either online(1) or offline(2). The shutdown(3) state is not applicable to this object. To change the online state of the drive, set the phDriveCommand object to online(1) or offline(2).')
phDriveErrorCodeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveErrorCodeBytes.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveErrorCodeBytes.setDescription('String of bytes which contains error information about the drive. The meaning of each byte is as follows: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ byte 0: drive seven segment display code')
phDriveRasStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 31), AdicStatusGroupState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveRasStatus.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveRasStatus.setDescription('RAS status for this individual drive.')
phDriveWwPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 110, 1, 32), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phDriveWwPortName.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveWwPortName.setDescription('World Wide Port Name for this drive.')
phDriveStatHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112), )
if mibBuilder.loadTexts: phDriveStatHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveStatHistoryTable.setDescription("This table contains historical data on drive operations. Each row in the table gives various statistical data for a single drive over a one hour period. The table is indexed such that phIndex = 0 is the current hour's data, phIndex = 1 is one hour ago, phIndex = 2 is two hours ago, etc.")
phDriveStatHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phDriveRow"), (0, "ADIC-MANAGEMENT-MIB", "phHourIndex"))
if mibBuilder.loadTexts: phDriveStatHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phDriveStatHistoryEntry.setDescription('')
phHourIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phHourIndex.setStatus('mandatory')
if mibBuilder.loadTexts: phHourIndex.setDescription("Index into the historical data. The integer value is the number in the past the data the data was collected. For example, phHourIndex = 0 means the current hour's statistics, phHourIndex = 1 means one hour in the past, phHourIndex = 2 means two hours in the past.")
phHourlyMBytesRead = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phHourlyMBytesRead.setStatus('mandatory')
if mibBuilder.loadTexts: phHourlyMBytesRead.setDescription('Number of megabytes read by this drive during the one hour period indicated by phHourIndex.')
phHourlyMBytesWritten = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phHourlyMBytesWritten.setStatus('mandatory')
if mibBuilder.loadTexts: phHourlyMBytesWritten.setDescription('Number of megabytes written by this drive during the one hour period indicated by phHourIndex.')
phHourlyMounts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 112, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phHourlyMounts.setStatus('mandatory')
if mibBuilder.loadTexts: phHourlyMounts.setDescription('Number of mounts performed by this drive during the one hour period indicated by phHourIndex.')
phDrivePorts = MibIdentifier((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116))
fcDrivePortTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10), )
if mibBuilder.loadTexts: fcDrivePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcDrivePortTable.setDescription('This table contains objects pertaining to Fibre Channel port settings on native Fibre Channel drives.')
fcDrivePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phDriveRow"))
if mibBuilder.loadTexts: fcDrivePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcDrivePortEntry.setDescription('A row object describing a Fibre Channel port.')
fcPortPreferredSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1, 1), AdicFcPortSpeed()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcPortPreferredSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fcPortPreferredSpeed.setDescription('Preferred transmitter speed. Except for auto(1), the numerical value of this object is equal to the port speed in megabits per second. ******************************************* auto(1) - speed is auto-negotiated with no preferred speed megabits1000(1000) - 1000 megabits per second megabits2000(2000) - 2000 megabits per second')
fcPortNegotiatedSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1, 2), AdicFcPortSpeed()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcPortNegotiatedSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fcPortNegotiatedSpeed.setDescription('Actual transmitter speed as negotiated on the FC network. The numerical value of this object is equal to the port speed in megabits per second. Although auto(1) is defined in the AdicFcPortSpeed enumeration, the fcPortNegotiatedSpeed should never return this value. ******************************************* auto(1) - This object should never auto(1) megabits1000(1000) - 1000 megabits per second megabits2000(2000) - 2000 megabits per second')
fcPortPreferredType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1, 3), AdicFcPortType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcPortPreferredType.setStatus('mandatory')
if mibBuilder.loadTexts: fcPortPreferredType.setDescription('Preferred port type, such as N_Port or NL_Port. auto(1) means no preference, auto-negotiate.')
fcPortNegotiatedType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1, 4), AdicFcPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcPortNegotiatedType.setStatus('mandatory')
if mibBuilder.loadTexts: fcPortNegotiatedType.setDescription('Actual port type as negotiated on the FC network. Should never return auto(1).')
fcPortTypeQualifier = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 116, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcPortTypeQualifier.setStatus('mandatory')
if mibBuilder.loadTexts: fcPortTypeQualifier.setDescription('Is this a public or private port?')
phMediaTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120), )
if mibBuilder.loadTexts: phMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaTable.setDescription('')
phMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phMediaBarCode"))
if mibBuilder.loadTexts: phMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaEntry.setDescription('')
phMediaBarCode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 1), AdicBarCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaBarCode.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaBarCode.setDescription('')
phMediaDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaDomain.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaDomain.setDescription('')
phMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaType.setDescription('')
phMediaElementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaElementAddress.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaElementAddress.setDescription('Element address where this cartridge is physically located.')
phMediaMounts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaMounts.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaMounts.setDescription('Number of times this cartridge has been mounted.')
phMediaReadErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaReadErrors.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaReadErrors.setDescription('Number of errors when reading from this cartridge.')
phMediaWriteErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaWriteErrors.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaWriteErrors.setDescription('Number of errors when writing to this cartridge.')
phMediaCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaCapacity.setDescription('Capacity of this cartridge in megabytes. Returns -1 if capacity is unknown.')
phMediaFreeSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaFreeSpace.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaFreeSpace.setDescription('Amount of free space on this cartridge in megabytes. Returns -1 if free space is unknown.')
phMediaExported = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 10), Boolean()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaExported.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaExported.setDescription('Has this cartridge been exported from the library?')
phMediaImportTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 11), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaImportTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaImportTimestamp.setDescription("Timestamp when cartridge was imported. Compatible with the SMIv2 DateAndTime textual convention. Encode is as follows: field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC 0..11 10 11 minutes from UTC 0..59 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known, then timezone information (fields 8-10) is not present.")
phMediaExportTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 120, 1, 12), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phMediaExportTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: phMediaExportTimestamp.setDescription("Timestamp when cartridge was exported. Compatible with the SMIv2 DateAndTime textual convention. Encode is as follows: field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC 0..11 10 11 minutes from UTC 0..59 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known, then timezone information (fields 8-10) is not present.")
phTransportTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130), )
if mibBuilder.loadTexts: phTransportTable.setStatus('optional')
if mibBuilder.loadTexts: phTransportTable.setDescription('** This table is optional **')
phTransportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phTransportElementAddress"))
if mibBuilder.loadTexts: phTransportEntry.setStatus('optional')
if mibBuilder.loadTexts: phTransportEntry.setDescription('** This entry object is optional **')
phTransportElementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportElementAddress.setStatus('optional')
if mibBuilder.loadTexts: phTransportElementAddress.setDescription('** This object is optional **')
phTransportNumRecoveredGets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportNumRecoveredGets.setStatus('optional')
if mibBuilder.loadTexts: phTransportNumRecoveredGets.setDescription('** This object is optional ** Number of recovered get operations for this transport element. The count is for the entire lifetime of the library.')
phTransportNumRecoveredPuts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportNumRecoveredPuts.setStatus('optional')
if mibBuilder.loadTexts: phTransportNumRecoveredPuts.setDescription('** This object is optional ** Number of recovered put operations for this transport element. The count is for the entire lifetime of the library.')
phTransportNumRecoveredScans = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportNumRecoveredScans.setStatus('optional')
if mibBuilder.loadTexts: phTransportNumRecoveredScans.setDescription('** This object is optional ** Number of recovered scan operations for this transport element. The count is for the entire lifetime of the library.')
phTransportNumPuts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportNumPuts.setStatus('optional')
if mibBuilder.loadTexts: phTransportNumPuts.setDescription('** This object is optional ** Number put operations for this transport element. The count is for the entire lifetime of the library.')
phTransportREDId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 130, 1, 6), AdicREDIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportREDId.setStatus('optional')
if mibBuilder.loadTexts: phTransportREDId.setDescription('** This object is optional ** Runtime Error Detection identifier for this tape drive.')
phTransportDomainTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 132), )
if mibBuilder.loadTexts: phTransportDomainTable.setStatus('optional')
if mibBuilder.loadTexts: phTransportDomainTable.setDescription('** This table is optional **')
phTransportDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 132, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "phTransportElementAddress"), (0, "ADIC-MANAGEMENT-MIB", "phTransportDomainIndex"))
if mibBuilder.loadTexts: phTransportDomainEntry.setStatus('optional')
if mibBuilder.loadTexts: phTransportDomainEntry.setDescription('** This entry object is optional **')
phTransportDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 132, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phTransportDomainIndex.setStatus('optional')
if mibBuilder.loadTexts: phTransportDomainIndex.setDescription('** This object is optional **')
phCleaningMediaTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140), )
if mibBuilder.loadTexts: phCleaningMediaTable.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaTable.setDescription('** This table is optional ** This is a combination of data about slots reserved for automatic cleaning and the cleaning cartridges themselves. Since the relationship between slots and cartridges is one-to-one, we can combine these data.')
phCleaningMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "phSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "phCleaningMediaRow"))
if mibBuilder.loadTexts: phCleaningMediaEntry.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaEntry.setDescription('** This entry object is optional **')
phCleaningMediaRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phCleaningMediaRow.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaRow.setDescription('** This object is optional **')
phCleaningMediaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allocated", 1), ("unallocated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phCleaningMediaStatus.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaStatus.setDescription('** This object is optional ** Cleaning storage is allocated by segment; the value of phCleaningMediaStatus indicates if the slot is being used to store a cartridge or not. allocated(1) means this slot is home to cartridge. unallocated(2) means there is no cartridge associated with this slot.')
phCleaningMediaTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningMediaTypeIndex.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaTypeIndex.setDescription('** This object is optional ** Exact media type of this cleaning cartridge. Value points to a row in the Media Type table with mediaTypeIndex = phCleaningMediaTypeIndex.')
phCleaningMediaVendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningMediaVendorId.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaVendorId.setDescription('** This object is optional ** Vendor of drives that this cleaning cartridge is designed to clean. Value points to a row in the Vendor table with vendorIdIndex = phCleaningMediaVendorId.')
phCleaningMediaBarcode = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 5), AdicBarCode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningMediaBarcode.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaBarcode.setDescription('** This object is optional ** Barcode (if present).')
phCleaningMediaUseCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningMediaUseCount.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaUseCount.setDescription('** This object is optional ** Use count. May be set to any value to accomodate importing cartridges that have already been used.')
phCleaningMediaMaxUses = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phCleaningMediaMaxUses.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaMaxUses.setDescription('** This object is optional ** Maximum number of uses for this cartidge.')
phCleaningMediaImportTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 80, 140, 1, 8), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phCleaningMediaImportTimestamp.setStatus('optional')
if mibBuilder.loadTexts: phCleaningMediaImportTimestamp.setDescription("** This object is optional ** Timestamp when this cartridge was imported. Compatible with the SMIv2 DateAndTime textual convention. Encode is as follows: field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC 0..11 10 11 minutes from UTC 0..59 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known, then timezone information (fields 8-10) is not present.")
loGeneralInfoTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10), )
if mibBuilder.loadTexts: loGeneralInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: loGeneralInfoTable.setDescription('General information about the Logical Library Manager.')
loGeneralInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: loGeneralInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loGeneralInfoEntry.setDescription('')
maxLogicalLibraries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxLogicalLibraries.setStatus('mandatory')
if mibBuilder.loadTexts: maxLogicalLibraries.setDescription('Maximum number of logical libraries. This includes all media types.')
numLogicalLibraries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numLogicalLibraries.setStatus('mandatory')
if mibBuilder.loadTexts: numLogicalLibraries.setDescription('Current number of logical libraries configured. This includes all media types.')
masterOnlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("online", 1), ("offline", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: masterOnlineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: masterOnlineStatus.setDescription('')
numVendorIds = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numVendorIds.setStatus('mandatory')
if mibBuilder.loadTexts: numVendorIds.setDescription('')
autoPartitionTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 12), )
if mibBuilder.loadTexts: autoPartitionTable.setStatus('mandatory')
if mibBuilder.loadTexts: autoPartitionTable.setDescription('Variables pertaining to library auto partitioning.')
autoPartitionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 12, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "mediaDomainIndex"), (0, "ADIC-MANAGEMENT-MIB", "mediaTypeIndex"), (0, "ADIC-MANAGEMENT-MIB", "phDriveInterfaceType"))
if mibBuilder.loadTexts: autoPartitionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autoPartitionEntry.setDescription('Autopartitioning is based on the media domain, media type, and drive data port interface type.')
numAutoPartition = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 12, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numAutoPartition.setStatus('mandatory')
if mibBuilder.loadTexts: numAutoPartition.setDescription('Number of partitions to create upon automatic partitioning for a given media domain, media type and interface type.')
autoPartitionCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("autoPartition", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoPartitionCommand.setStatus('mandatory')
if mibBuilder.loadTexts: autoPartitionCommand.setDescription('Perform operation based on the media domain, media type, and interface type: autoPartition(1) - create the number of partitions indicated by the numAutoPartition object, with the library resouces divided equally among the partitions.')
vendorIdTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 15), )
if mibBuilder.loadTexts: vendorIdTable.setStatus('mandatory')
if mibBuilder.loadTexts: vendorIdTable.setDescription('Table of possible vendors.')
vendorIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 15, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "vendorIdIndex"))
if mibBuilder.loadTexts: vendorIdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vendorIdEntry.setDescription('')
vendorIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vendorIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vendorIdIndex.setDescription('')
vendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 15, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorName.setStatus('mandatory')
if mibBuilder.loadTexts: vendorName.setDescription('')
numProductIds = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numProductIds.setStatus('mandatory')
if mibBuilder.loadTexts: numProductIds.setDescription('')
productIdTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17), )
if mibBuilder.loadTexts: productIdTable.setStatus('mandatory')
if mibBuilder.loadTexts: productIdTable.setDescription('Table of possible product names and configuration constraints.')
productIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "vendorIdIndex"), (0, "ADIC-MANAGEMENT-MIB", "productIdIndex"))
if mibBuilder.loadTexts: productIdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: productIdEntry.setDescription('')
productIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: productIdIndex.setDescription('')
productIdName = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productIdName.setStatus('mandatory')
if mibBuilder.loadTexts: productIdName.setDescription('')
productDrivesMin = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productDrivesMin.setStatus('mandatory')
if mibBuilder.loadTexts: productDrivesMin.setDescription('')
productDrivesMax = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productDrivesMax.setStatus('mandatory')
if mibBuilder.loadTexts: productDrivesMax.setDescription('')
productSlotsMin = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productSlotsMin.setStatus('mandatory')
if mibBuilder.loadTexts: productSlotsMin.setDescription('')
productSlotsMax = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productSlotsMax.setStatus('mandatory')
if mibBuilder.loadTexts: productSlotsMax.setDescription('')
productIeMin = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productIeMin.setStatus('mandatory')
if mibBuilder.loadTexts: productIeMin.setDescription('')
productIeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 17, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productIeMax.setStatus('mandatory')
if mibBuilder.loadTexts: productIeMax.setDescription('')
logicalLibraryTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20), )
if mibBuilder.loadTexts: logicalLibraryTable.setStatus('mandatory')
if mibBuilder.loadTexts: logicalLibraryTable.setDescription('')
logicalLibraryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: logicalLibraryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: logicalLibraryEntry.setDescription('')
logicalLibraryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logicalLibraryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logicalLibraryIndex.setDescription('Identifies the Logical Library to be managed.')
command = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("createSimple", 1), ("createExpert", 2), ("modify", 3), ("delete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: command.setStatus('mandatory')
if mibBuilder.loadTexts: command.setDescription('')
name = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: name.setStatus('mandatory')
if mibBuilder.loadTexts: name.setDescription('')
assignedLun = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assignedLun.setStatus('mandatory')
if mibBuilder.loadTexts: assignedLun.setDescription("Assigned LUN of this library's (virtual) SCSI media changer. This can only be changed through the SANMgr proxy MIB device map table.")
vendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorId.setStatus('mandatory')
if mibBuilder.loadTexts: vendorId.setDescription('')
productId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productId.setStatus('mandatory')
if mibBuilder.loadTexts: productId.setDescription('')
mediaDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mediaDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mediaDomain.setDescription('Points to entry in the Physical Library MediaDomainTable.')
mediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mediaType.setStatus('mandatory')
if mibBuilder.loadTexts: mediaType.setDescription('Points to entry in the Physical Library MediaTypeTable.')
numSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numSlots.setStatus('mandatory')
if mibBuilder.loadTexts: numSlots.setDescription('')
numIE = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numIE.setStatus('mandatory')
if mibBuilder.loadTexts: numIE.setDescription('')
numDrives = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numDrives.setStatus('mandatory')
if mibBuilder.loadTexts: numDrives.setDescription('')
loStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("online", 1), ("offline", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loStatus.setStatus('mandatory')
if mibBuilder.loadTexts: loStatus.setDescription('')
automaticCleaning = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 13), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: automaticCleaning.setStatus('mandatory')
if mibBuilder.loadTexts: automaticCleaning.setDescription('Enables/Disables automatic cleaning for drives this logical library.')
mediaTypeChecking = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 14), AdicEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mediaTypeChecking.setStatus('mandatory')
if mibBuilder.loadTexts: mediaTypeChecking.setDescription('Enables/Disables media type checking for this logical library.')
serialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: serialNumber.setDescription('Serial Number of this logical library. Assigned by MCB when logical library is created.')
loInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 16), AdicInterfaceType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: loInterfaceType.setDescription('Type of data interface for this logical library.')
loNumLibraries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loNumLibraries.setStatus('obsolete')
if mibBuilder.loadTexts: loNumLibraries.setDescription('Formerly used in auto partition operation. Made obsolete by autoPartition table.')
loLtoTapeTags = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("prefix", 1), ("suffix", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loLtoTapeTags.setStatus('mandatory')
if mibBuilder.loadTexts: loLtoTapeTags.setDescription("Controls the inclusion of media type characters in the media barcodes for this logical library. For example, the LTO media type characters are 'L1' for LTO-1 and 'L2' for LTO-2. This object applies to logical libraries of all media domains, not just LTO (as the name suggests).")
loMediaTypeCheckingPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 20, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loMediaTypeCheckingPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: loMediaTypeCheckingPolicy.setDescription("Allows the user to specify special handling of media type information in barcodes. Values are: 0 - media type checking disabled; media type as derived from barcode is irrelevant. 911 - 'required'; barcode MUST be a valid ADIC barcode, the correct media type may be derived from the barcode using the ADIC algorithm. Other - 'override'; the media type may not be derived from the barcode, use this value instead. The value map is the same as the mediaTypeIndex variable: the logical library's mediaDomain variable specifies the media domain and loMediaTypeCheckingPolicy specifies the media type that will be assumed for all media in this logical library.")
loSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25), )
if mibBuilder.loadTexts: loSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentTable.setDescription('This is a list of all the segments in the library.')
loSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentType"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentStartingRow"))
if mibBuilder.loadTexts: loSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentEntry.setDescription('')
loSegmentAisle = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentAisle.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentAisle.setDescription('Aisle coordinate value for this segment.')
loSegmentFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentFrame.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentFrame.setDescription('Frame coordinate value for this segment.')
loSegmentRack = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentRack.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentRack.setDescription('Rack coordinate value for this segment.')
loSegmentSection = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentSection.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentSection.setDescription('Section coordinate for this segment.')
loSegmentCol = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentCol.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentCol.setDescription('Column coordinate value for this segment.')
loSegmentStartingRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentStartingRow.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentStartingRow.setDescription('Row coordinate of the first element in this segment. This is useful to divide a column into multiple segments. For instance, a segment which contains rows 1 - 10 would have loSegmentStartingRow = 1. A segment which contains rows 11 - 20 in the same column would have loSegmentStartingRow = 11.')
loSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentSize.setDescription('Number of elements in this segment.')
loSegmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 8), AdicSegmentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentType.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentType.setDescription('Type segment (storage, I/E, drive).')
loSegmentMediaDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentMediaDomain.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentMediaDomain.setDescription('Media domain for this segment. Points to a row in the media domain table.')
loSegmentBelongsTo = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loSegmentBelongsTo.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentBelongsTo.setDescription('logicalLibraryIndex to which this segment is allocated. This object has no meaning for an I/E segment since I/E segments may be shared. For I/E segments, the list of logical libaraies which share the segment may be found in the loSegmentAssignmentTable.')
loSegmentCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("allocate", 1), ("free", 2), ("reserveForCleaning", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loSegmentCommand.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentCommand.setDescription('Operation to perform using objects in varbind list.')
loSegmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allocated", 1), ("unallocated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentStatus.setDescription('Is this segment allocated to a logical library?')
loSegmentStartingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 25, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentStartingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentStartingAddress.setDescription('Logical SCSI element address of the first element (row) in this segment. Element addresses are contiguous within a segment and unique within a logical library.')
loSegmentBelongsToTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 27), )
if mibBuilder.loadTexts: loSegmentBelongsToTable.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentBelongsToTable.setDescription('This is a list of the logical libraries to which each segments belongs. Storage and drive segments belong to a maximum of one logical library, but I/E segments may be shared among several logical libraries.')
loSegmentBelongsToEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 27, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentType"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentStartingRow"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAssignedTo"))
if mibBuilder.loadTexts: loSegmentBelongsToEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentBelongsToEntry.setDescription('')
loSegmentAssignedTo = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 27, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loSegmentAssignedTo.setStatus('mandatory')
if mibBuilder.loadTexts: loSegmentAssignedTo.setDescription('logicalLibraryIndex to which this segment belongs.')
loStorageSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 30), )
if mibBuilder.loadTexts: loStorageSegTable.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSegTable.setDescription('This is a list of all the storage segments in the library, indexed by a flat segment index loStorageSegIndex.')
loStorageSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 30, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentStartingRow"))
if mibBuilder.loadTexts: loStorageSegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSegEntry.setDescription('')
loStorageSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStorageSegSize.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSegSize.setDescription('Number of storage elements in this segment.')
loStorageSegStartingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 30, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStorageSegStartingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSegStartingAddress.setDescription('Logical SCSI element address of the first element (row) in this storage segment. Element addresses are contiguous within a segment and unique within a logical library.')
loIeSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40), )
if mibBuilder.loadTexts: loIeSegTable.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegTable.setDescription('This is a list of all the I/E segments in the logical library, indexed by a flat segment index.')
loIeSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentStartingRow"))
if mibBuilder.loadTexts: loIeSegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegEntry.setDescription('')
loIeSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loIeSegSize.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegSize.setDescription('Number of I/E elements in this segment.')
loIeSegReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reserve", 1), ("release", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loIeSegReserve.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegReserve.setDescription('Mechanism to release and reserve this I/E segment.')
loIeSegReservedBy = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loIeSegReservedBy.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegReservedBy.setDescription('Index of logical library for which this I/E segment has been reserved.')
loIeSegStartingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 40, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loIeSegStartingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSegStartingAddress.setDescription('Logical SCSI element address of the first element (row) in this I/E segment. Element addresses are contiguous within a segment and unique within a logical library.')
loDriveSegTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50), )
if mibBuilder.loadTexts: loDriveSegTable.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegTable.setDescription('This is a list of all the drive segments in the library, indexed by their media domain, media type and segment index.')
loDriveSegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentStartingRow"))
if mibBuilder.loadTexts: loDriveSegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegEntry.setDescription('')
loDriveSegSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loDriveSegSize.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegSize.setDescription('Number of elements in this segment.')
loDriveSegStartingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loDriveSegStartingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegStartingAddress.setDescription('Logical SCSI element address of the first element (row) in this drive segment. Element addresses are contiguous within a segment and unique within a logical library.')
loDriveSegMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loDriveSegMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegMediaType.setDescription('Exact media type of this segment. With loSegmentMediaDomain, points a row in the media type table.')
loDriveSegInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 50, 1, 4), AdicInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loDriveSegInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveSegInterfaceType.setDescription('Data interface for this segment.')
loStorageSlotTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 60), )
if mibBuilder.loadTexts: loStorageSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSlotTable.setDescription('')
loStorageSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 60, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loStorageRow"))
if mibBuilder.loadTexts: loStorageSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageSlotEntry.setDescription('')
loStorageRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 60, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStorageRow.setStatus('mandatory')
if mibBuilder.loadTexts: loStorageRow.setDescription('Row coordinate value for this storage slot.')
loIeSlotTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 70), )
if mibBuilder.loadTexts: loIeSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSlotTable.setDescription('')
loIeSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 70, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loIeRow"))
if mibBuilder.loadTexts: loIeSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loIeSlotEntry.setDescription('')
loIeRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 70, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loIeRow.setStatus('mandatory')
if mibBuilder.loadTexts: loIeRow.setDescription('Row coordinate value for this storage slot.')
loDriveTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 80), )
if mibBuilder.loadTexts: loDriveTable.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveTable.setDescription('')
loDriveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 80, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentAisle"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentFrame"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentRack"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentSection"), (0, "ADIC-MANAGEMENT-MIB", "loSegmentCol"), (0, "ADIC-MANAGEMENT-MIB", "loDriveRow"))
if mibBuilder.loadTexts: loDriveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveEntry.setDescription('')
loDriveRow = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 80, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loDriveRow.setStatus('mandatory')
if mibBuilder.loadTexts: loDriveRow.setDescription('Row coordinate value for where this drive element is physically located.')
loStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90), )
if mibBuilder.loadTexts: loStatisticsTable.setStatus('optional')
if mibBuilder.loadTexts: loStatisticsTable.setDescription('** This table is optional ** Table of statistics for each logical library. Error counts, recovery counts, etc. .')
loStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: loStatisticsEntry.setStatus('optional')
if mibBuilder.loadTexts: loStatisticsEntry.setDescription('** This entry object is optional **')
loNumRecoveredGets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loNumRecoveredGets.setStatus('optional')
if mibBuilder.loadTexts: loNumRecoveredGets.setDescription('** This object is optional ** Number of recovered get operations for this logical library. The count is for the entire lifetime of the logical library.')
loNumRecoveredPuts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loNumRecoveredPuts.setStatus('optional')
if mibBuilder.loadTexts: loNumRecoveredPuts.setDescription('** This object is optional ** Number of recovered putt operations for this logical library. The count is for the entire lifetime of the logical library.')
loNumRecoveredScans = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loNumRecoveredScans.setStatus('optional')
if mibBuilder.loadTexts: loNumRecoveredScans.setDescription('** This object is optional ** Number of recovered scan operations for this logical library. The count is for the entire lifetime of the logical library.')
loStatsNumPuts = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStatsNumPuts.setStatus('optional')
if mibBuilder.loadTexts: loStatsNumPuts.setDescription('** This object is optional ** Number of put operations performed for this logical library. The count is for the entire lifetime of the logical library.')
loStatsNumPutRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStatsNumPutRetries.setStatus('optional')
if mibBuilder.loadTexts: loStatsNumPutRetries.setDescription('** This object is optional ** Number of retried put operations performed for this logical library. The count is for the entire lifetime of the logical library.')
loStatsNumGetRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStatsNumGetRetries.setStatus('optional')
if mibBuilder.loadTexts: loStatsNumGetRetries.setDescription('** This object is optional ** Number of retried get operations performed for this logical library. The count is for the entire lifetime of the logical library.')
loStatsNumScanRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 90, 90, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loStatsNumScanRetries.setStatus('optional')
if mibBuilder.loadTexts: loStatsNumScanRetries.setDescription('** This object is optional ** Number of retried scan operations performed for this logical library. The count is for the entire lifetime of the logical library.')
rasSystemStatusTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10), )
if mibBuilder.loadTexts: rasSystemStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rasSystemStatusTable.setDescription('Contains status information for various system status groups.')
rasSystemStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"))
if mibBuilder.loadTexts: rasSystemStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rasSystemStatusEntry.setDescription('Information for a particular system status group. The componentId index refers to the MCB through which the management application accesses the RAS manager. The rasStatusGroupIndex specifies the system status group for which the entry contains information.')
rasStatusGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 1), AdicStatusGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupIndex.setDescription('Identifies the system status group for which this row object contains information.')
rasStatusGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 2), AdicStatusGroupState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupStatus.setDescription("The status (or condition) of this system status group. Use of the 'indeterminate' state: 'indeterminate' is primarily for use in the rasStatusGroupPreviousStatus object, where there may not be any previous state information.")
rasStatusGroupPreviousStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 3), AdicStatusGroupState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupPreviousStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupPreviousStatus.setDescription("After a state change, this object gives the previous state of the system status group. If there is no previous state information available, such as when resetting the system, the previous state is 'indeterminate'.")
rasStatusGroupTextSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupTextSummary.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupTextSummary.setDescription("A brief message describing the state of this system status group. If the rasStatusGroupStatus is other than 'good', this object should return the reason why this is so.")
rasStatusGroupTotalTickets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupTotalTickets.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupTotalTickets.setDescription('The total number of RAS tickets created against this system status group.')
rasStatusGroupOpenTickets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupOpenTickets.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupOpenTickets.setDescription('The number of RAS tickets currently open against this system status group.')
rasStatusGroupActionsPending = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupActionsPending.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupActionsPending.setDescription('The number of actions pending against this system status group.')
rasStatusGroupLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 10, 1, 8), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasStatusGroupLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: rasStatusGroupLastChange.setDescription('Timestamp of the last time the status changed.')
rasTicketTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20), )
if mibBuilder.loadTexts: rasTicketTable.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketTable.setDescription('Contains one row for each ticket in the database.')
rasTicketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "rasTicketId"))
if mibBuilder.loadTexts: rasTicketEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketEntry.setDescription('Each entry contains information for a single RAS ticket. The componentId index refers to the MCB through which the management application accesses the RAS manager. The rasTicketId specifies the ticket instance.')
rasTicketId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketId.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketId.setDescription('Unique identifier for this ticket. The RAS system defines the ticket ID as an unsigned 32 bit integer, so it is declared here as a Guage32.')
rasTicketRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketRowStatus.setDescription('Controls creation and deletion of rows in this table. Creation of RAS tickets via SNMP is currently not permitted, so writing a value of createAndGo(4) or createAndWait(5) does not create a new row; it may return error indication.')
rasTicketState = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 3), AdicRasTicketState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketState.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketState.setDescription('')
rasTicketQualifier = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("resolved", 2), ("cannotDuplicate", 3), ("asDesigned", 4), ("manualOverride", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketQualifier.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketQualifier.setDescription('')
rasTicketPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketPriority.setDescription('')
rasTicketDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketDescription.setDescription('')
rasTicketStatusGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 7), AdicStatusGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketStatusGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketStatusGroup.setDescription('System status group to which this ticket belongs.')
rasTicketGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 8), AdicStatusGroupState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketGroupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketGroupStatus.setDescription('Status determination that this ticket indicates against its system status group.')
rasTicketClosedBy = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketClosedBy.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketClosedBy.setDescription('')
rasTicketVerifiedBy = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketVerifiedBy.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketVerifiedBy.setDescription('')
rasTicketComments = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketComments.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketComments.setDescription('')
rasTicketSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 12), AdicFruSerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketSerialNumber.setDescription('')
rasTicketTimeOpened = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 13), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketTimeOpened.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketTimeOpened.setDescription('Date and time when ticket was opened.')
rasTicketTimeClosed = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 14), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketTimeClosed.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketTimeClosed.setDescription('Date and time when ticket was closed.')
rasTicketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketCount.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketCount.setDescription('Number of times an attempt was made to open a duplicate ticket.')
rasTicketKeyReport = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 20, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasTicketKeyReport.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketKeyReport.setDescription('Contains 0 or a valid rasReportId value. Indicates which report is currently responsible for the severity of the ticket.')
rasReportTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30), )
if mibBuilder.loadTexts: rasReportTable.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportTable.setDescription('Contains one row for each ticket/report combination in the database. The table is indexed off the RAS Ticket Table, it may contain many RAS Report entries for a single RAS Ticket.')
rasReportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "rasTicketId"), (0, "ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: rasReportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportEntry.setDescription('Each entry contains information for a single RAS Report.')
rasReportId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportId.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportId.setDescription('Identifies the RAS Report for which this this row object contains information. The RAS system defines the report ID as an unsigned 32 bit integer, so it is declared here as a Guage32.')
rasReportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasReportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportRowStatus.setDescription('Controls creation and deletion of rows in the RAS Report table.')
rasReportTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 3), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportTimestamp.setDescription('Time when this event was generated.')
rasReportStatusGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 4), AdicStatusGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasReportStatusGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportStatusGroup.setDescription('The subsystem that is reporting the event.')
rasReportOrcData = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasReportOrcData.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportOrcData.setDescription('Event payload generated by the reporting subsystem.')
rasReportGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 6), AdicStatusGroupState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasReportGroupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportGroupStatus.setDescription('Status determination that this report indicates against the specific FRU.')
rasReportDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasReportDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportDescription.setDescription('')
rasReportOrcDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportOrcDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportOrcDescription.setDescription('Description of the operation result code.')
rasReportRepeatCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportRepeatCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportRepeatCounter.setDescription('Number of times an identical report has been generated.')
rasReportSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 10), AdicFruSerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportSerialNumber.setDescription('')
rasReportHeadReport = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 30, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasReportHeadReport.setStatus('mandatory')
if mibBuilder.loadTexts: rasReportHeadReport.setDescription('The head report field allows reports to be sorted according to FRU branch.')
rasFruStatTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50), )
if mibBuilder.loadTexts: rasFruStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatTable.setDescription('Each row dsecribes the history and RAS statistics for a single FRU.')
rasFruStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), (0, "ADIC-MANAGEMENT-MIB", "rasFruStatIndex"))
if mibBuilder.loadTexts: rasFruStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatEntry.setDescription('Each entry contains information for a single FRU.')
rasFruStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatIndex.setDescription('Flat index for the FRU statistics table.')
rasFruInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruInstanceId.setDescription('Uniquely identifies the FRU instance.')
rasFruStatStatusGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 3), AdicStatusGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatStatusGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatStatusGroup.setDescription('Status group to which this FRU belongs.')
rasFruStatFruCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("firmware", 1), ("pcba", 2), ("fan", 3), ("accessor", 4), ("picker", 5), ("power", 6), ("cable", 7), ("mailbox", 8), ("drive", 9), ("media", 10), ("label", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatFruCategory.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatFruCategory.setDescription('Category to which this FRU belongs.')
rasFruStatFruId = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatFruId.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatFruId.setDescription('FRU identifier.')
rasFruStatFirstReportTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 6), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatFirstReportTime.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatFirstReportTime.setDescription('Time when the first RAS report was generated for this FRU.')
rasFruStatLastReportTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 7), AdicDateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatLastReportTime.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatLastReportTime.setDescription('Time when the most recent RAS report was generated for this FRU.')
rasFruStatTotalTickets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatTotalTickets.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatTotalTickets.setDescription('Total number of RAS tickets created against this FRU, both open and closed tickets.')
rasFruStatOpenTickets = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatOpenTickets.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatOpenTickets.setDescription('Number of RAS tickets currently open against this FRU.')
rasFruStatSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 10), AdicFruSerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatSerialNumber.setDescription('The unique serial number of the FRU.')
rasFruStatState = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 50, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("current", 1), ("old", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rasFruStatState.setStatus('mandatory')
if mibBuilder.loadTexts: rasFruStatState.setDescription('State = current(1) indicates that the FRU is currently installed. State = old(2) indicates that the FRU has been removed and the data is historic.')
rasTicketFilterTable = MibTable((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 60), )
if mibBuilder.loadTexts: rasTicketFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketFilterTable.setDescription('Contains filter settings for ticket table walking. Only those rows which match the filter criteria will appear in the RAS ticket table when traversed using GetNext or GetBulk.')
rasTicketFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 60, 1), ).setIndexNames((0, "ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: rasTicketFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketFilterEntry.setDescription('')
rasTicketFilterStatusGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 60, 1, 1), AdicStatusGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketFilterStatusGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketFilterStatusGroup.setDescription('Identifies the system status group for which tickets will be returned.')
rasTicketFilterState = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 60, 1, 2), AdicRasTicketState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketFilterState.setDescription('Identifies the ticket state (open, closed, etc.) for which tickets will be returned.')
rasTicketFilterSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20, 100, 60, 1, 3), AdicRasTicketSeverity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasTicketFilterSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: rasTicketFilterSeverity.setDescription("Identifies the ticket severity for which tickets will be returned. ========================================= high: Tickets/reports with status 'failed' only. medium: Tickets/reports with status 'failed' or 'warning'. low: All tickets/reports.")
physLibraryActivity = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,100)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"))
if mibBuilder.loadTexts: physLibraryActivity.setDescription('')
physLibraryOnlineStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,101)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "onlineStatus"))
if mibBuilder.loadTexts: physLibraryOnlineStatusChange.setDescription('')
physLibraryDoorStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,102)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "physLibraryDoorStatus"))
if mibBuilder.loadTexts: physLibraryDoorStatusChange.setDescription('')
ieStationDoorStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,103)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phSegmentAisle"), ("ADIC-MANAGEMENT-MIB", "phSegmentFrame"), ("ADIC-MANAGEMENT-MIB", "phSegmentRack"), ("ADIC-MANAGEMENT-MIB", "phIeStationNumber"), ("ADIC-MANAGEMENT-MIB", "phIeStationDoorStatus"))
if mibBuilder.loadTexts: ieStationDoorStatusChange.setDescription('')
moveMediaComplete = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,104)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phStorageElementAddr"), ("ADIC-MANAGEMENT-MIB", "phStorageElementAddr"))
if mibBuilder.loadTexts: moveMediaComplete.setDescription('A piece of media has been move from one location to another. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) phStorageElementAddr - source element address phStorageElementAddr - destination element address')
tapeDriveAdded = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,105)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phDriveRow"))
if mibBuilder.loadTexts: tapeDriveAdded.setDescription("A tape drive was added to the library. This trap is issued when a tape drive previously unknown to the library becomes known. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) phDriveRow - row component of the drive's physical location in the library.")
tapeDriveRemoved = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,106)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phDriveRow"))
if mibBuilder.loadTexts: tapeDriveRemoved.setDescription("A tape drive was removed from the library. This trap is issued when a tape drive is removed from library's configuration. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) phDriveRow - row component of the drive's physical location in the library.")
mediaMounted = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,107)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phDriveRow"))
if mibBuilder.loadTexts: mediaMounted.setDescription("Media was mounted in the tape drive indicated in the trap payload. This trap is issued upon every mount operation. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) phDriveRow - row component of the drive's physical location in the library.")
mediaDismounted = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,108)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phDriveRow"), ("ADIC-MANAGEMENT-MIB", "phDriveMbytesRead"), ("ADIC-MANAGEMENT-MIB", "phDriveMbytesWritten"))
if mibBuilder.loadTexts: mediaDismounted.setDescription("Media was dismounted in the tape drive indicated in the trap payload. This trap is issued upon every dismount operation. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) phDriveRow - row component of the drive's physical location in the library. phDriveMbytesRead - over lifetime of drive phDriveMbytesWritten - over lifetime of drive")
ieStationInventoryPerformed = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,109)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-MANAGEMENT-MIB", "phIeElementAddr"), ("ADIC-MANAGEMENT-MIB", "phIeElementAddr"))
if mibBuilder.loadTexts: ieStationInventoryPerformed.setDescription('An inventory operation has been performed on an I/E station.')
rcuReady = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,110)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: rcuReady.setDescription('The RCU indicated in the payload has transitioned from the NotReady state to the Ready state.')
rcuNotReady = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,111)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"))
if mibBuilder.loadTexts: rcuNotReady.setDescription('The RCU indicated in the payload has transitioned from the NotReady state to the Ready state.')
driveActivityUpdate = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,112)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phHourlyMBytesRead"), ("ADIC-MANAGEMENT-MIB", "phHourlyMBytesWritten"), ("ADIC-MANAGEMENT-MIB", "phHourlyMounts"))
if mibBuilder.loadTexts: driveActivityUpdate.setDescription('Drive activity integrated over a fixed time period. Currently, the time period is one hour. NOTE: the drive is identified by the instance OID contained in the phHourlyMBytesRead, phHourlyMBytesWritten, and phHourlyWritten varbinds.')
driveBrickFwUpdateSuccess = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,113)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phDriveSerialNumber"), ("ADIC-MANAGEMENT-MIB", "phDriveFirmwareVersion"))
if mibBuilder.loadTexts: driveBrickFwUpdateSuccess.setDescription("Drive brick's firmware was successfully updated. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) trapSummaryText - brief message about the update phDriveSerialNumber - the drive serial number. The OID of the varbind encoded in the trap payload must be the full OID, column OID plus indices. phDriveFirmwareVersion - the drive firmware version identifier. The OID of the varbind encoded in the trap payload must be the full OID, column OID plus indices.")
driveBrickFwUpdateFailure = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,114)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phDriveSerialNumber"), ("ADIC-MANAGEMENT-MIB", "phDriveFirmwareVersion"))
if mibBuilder.loadTexts: driveBrickFwUpdateFailure.setDescription("Attempt to update drive brick's firmware has failed. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) trapSummaryText - brief message about the update phDriveSerialNumber - the drive serial number. The OID of the varbind encoded in the trap payload must be the full OID, column OID plus indices. phDriveFirmwareVersion - the drive firmware version identifier. The OID of the varbind encoded in the trap payload must be the full OID, column OID plus indices.")
physLibraryConfigurationChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,115)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"))
if mibBuilder.loadTexts: physLibraryConfigurationChange.setDescription("The physical configuration of the library has been changed, possibly invalidating the data in the management application's model. For example, an LTO magazine swapped for a DLT magazine. The management application should repopulate its data model.")
physLibraryRESChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,116)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phStorageElementAddr"), ("ADIC-MANAGEMENT-MIB", "phStorageElementAddr"))
if mibBuilder.loadTexts: physLibraryRESChange.setDescription('The physical library managers issues this trap when it detects that the Read Element Status data has changed. This generally occurs after an inventory. The range of elements specified by the last two varbinds may represent storage drive, or I/E elements.')
driveBrickFwUpdateStart = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,117)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "phDriveSerialNumber"))
if mibBuilder.loadTexts: driveBrickFwUpdateStart.setDescription('Drive brick firmware update has started. componentId - identifies MCB trapSequenceNumber - generic sequence number trapSeverity - should be informational(5) trapSummaryText - brief message about the update phDriveSerialNumber - the drive serial number. The OID of the varbind encoded in the trap payload must be the full OID, column OID plus indices.')
logicalLibraryActivity = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,200)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: logicalLibraryActivity.setDescription('')
logicalLibraryCreated = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,201)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: logicalLibraryCreated.setDescription('')
logicalLibraryModified = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,202)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: logicalLibraryModified.setDescription('')
logicalLibraryDeleted = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,203)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"))
if mibBuilder.loadTexts: logicalLibraryDeleted.setDescription('')
logicalLibraryOnlineStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,204)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "logicalLibraryIndex"), ("ADIC-MANAGEMENT-MIB", "loStatus"))
if mibBuilder.loadTexts: logicalLibraryOnlineStatusChange.setDescription('')
connectivityGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,400)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: connectivityGroupStatusChange.setDescription('The overall state of the connectivity system status group has changed. The present state of the connectivity status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
controlGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,401)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: controlGroupStatusChange.setDescription('The overall state of the control system status group has changed. The present state of the control status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
coolingGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,402)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: coolingGroupStatusChange.setDescription('The overall state of the cooling system status group has changed. The present state of the cooling status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
drivesAndMediaGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,403)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: drivesAndMediaGroupStatusChange.setDescription('The overall state of the drives and media system status group has changed. The present state of the drives and media status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
powerGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,404)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: powerGroupStatusChange.setDescription('The overall state of the power system status group has changed. The present state of the power status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
roboticsGroupStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,405)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"))
if mibBuilder.loadTexts: roboticsGroupStatusChange.setDescription('The overall state of the robotics system status group has changed. The present state of the robotics status group is given by the value of the rasStatusGroupStatus object in the trap payload.')
rasEventNotification = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,406)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupIndex"), ("ADIC-MANAGEMENT-MIB", "rasStatusGroupStatus"), ("ADIC-MANAGEMENT-MIB", "rasTicketId"), ("ADIC-MANAGEMENT-MIB", "rasReportId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapIntendedUsage"))
if mibBuilder.loadTexts: rasEventNotification.setDescription('A RAS event has occurred, possibly requiring action by the management application.')
logRetrievalComplete = NotificationType((1, 3, 6, 1, 4, 1, 3764, 1, 1, 200, 20) + (0,500)).setObjects(("ADIC-INTELLIGENT-STORAGE-MIB", "componentId"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSequenceNumber"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSeverity"), ("ADIC-INTELLIGENT-STORAGE-MIB", "trapSummaryText"))
if mibBuilder.loadTexts: logRetrievalComplete.setDescription('Indicates that the system has retrieved all remote log files as part of the capture snapshot procedure.')
mibBuilder.exportSymbols("ADIC-MANAGEMENT-MIB", phIeElementAddr=phIeElementAddr, licensableFeatureEntry=licensableFeatureEntry, vendorName=vendorName, phDriveMbytesWritten=phDriveMbytesWritten, phTransportDomainIndex=phTransportDomainIndex, loDriveSegMediaType=loDriveSegMediaType, loStatsNumScanRetries=loStatsNumScanRetries, mediaTypeEntry=mediaTypeEntry, phSegmentSize=phSegmentSize, rasTicketId=rasTicketId, phStorageElementAddr=phStorageElementAddr, loStorageSegTable=loStorageSegTable, loDriveEntry=loDriveEntry, numAutoPartition=numAutoPartition, systemManager=systemManager, registrationRowStatus=registrationRowStatus, powerGroupStatusChange=powerGroupStatusChange, phHourIndex=phHourIndex, role=role, userTable=userTable, loStorageSlotTable=loStorageSlotTable, phIeSegReservedBy=phIeSegReservedBy, autoCalibrateMode=autoCalibrateMode, phStorageRow=phStorageRow, productIdName=productIdName, phDriveScsiId=phDriveScsiId, phIeRow=phIeRow, rasStatusGroupPreviousStatus=rasStatusGroupPreviousStatus, numElementDomains=numElementDomains, loIeSegStartingAddress=loIeSegStartingAddress, rcuInstallProcessStatus=rcuInstallProcessStatus, phTransportDomainEntry=phTransportDomainEntry, rasFruStatTotalTickets=rasFruStatTotalTickets, rasReportId=rasReportId, logSnapshotEntry=logSnapshotEntry, productDrivesMax=productDrivesMax, loNumRecoveredGets=loNumRecoveredGets, loSegmentTable=loSegmentTable, loStorageSlotEntry=loStorageSlotEntry, processPhysicalMemory=processPhysicalMemory, phMediaWriteErrors=phMediaWriteErrors, rasTicketFilterTable=rasTicketFilterTable, rasReportGroupStatus=rasReportGroupStatus, rasFruStatEntry=rasFruStatEntry, logicalSNAdressingMode=logicalSNAdressingMode, phMediaCapacity=phMediaCapacity, rasStatusGroupStatus=rasStatusGroupStatus, phTransportNumRecoveredScans=phTransportNumRecoveredScans, phDriveRow=phDriveRow, rasTicketClosedBy=rasTicketClosedBy, phDriveErrorCodeBytes=phDriveErrorCodeBytes, rasFruStatState=rasFruStatState, AdicRasTicketSeverity=AdicRasTicketSeverity, mediaMounted=mediaMounted, vendorId=vendorId, rasReportRepeatCounter=rasReportRepeatCounter, rasTicketQualifier=rasTicketQualifier, phDriveCommand=phDriveCommand, phStorageSegTable=phStorageSegTable, Boolean=Boolean, fcPortPreferredSpeed=fcPortPreferredSpeed, rasReportDescription=rasReportDescription, phDriveREDId=phDriveREDId, loIeSegSize=loIeSegSize, rcuInstallStatusText=rcuInstallStatusText, rasTicketPriority=rasTicketPriority, AdicFcPortSpeed=AdicFcPortSpeed, rasReportTimestamp=rasReportTimestamp, productSlotsMax=productSlotsMax, ieStationInventoryPerformed=ieStationInventoryPerformed, AdicInstallStatus=AdicInstallStatus, processResidentMemory=processResidentMemory, licenseKeyIndex=licenseKeyIndex, systemManagerEntry=systemManagerEntry, userLibAccessList=userLibAccessList, autoPartitionEntry=autoPartitionEntry, logicalLibraryTable=logicalLibraryTable, logRetrievalComplete=logRetrievalComplete, logEntry=logEntry, loStorageRow=loStorageRow, logicalLibraryCreated=logicalLibraryCreated, dhcpStatus=dhcpStatus, totalRawCapacity=totalRawCapacity, vendorIdIndex=vendorIdIndex, currentFirmwareVersion=currentFirmwareVersion, numDrives=numDrives, phIeStationREDId=phIeStationREDId, rasTicketVerifiedBy=rasTicketVerifiedBy, mediaTypeTable=mediaTypeTable, phSegmentStartingRow=phSegmentStartingRow, AdicEthernetSpeed=AdicEthernetSpeed, loSegmentFrame=loSegmentFrame, softwareComponentIndex=softwareComponentIndex, phSegmentFrame=phSegmentFrame, tapeDriveAdded=tapeDriveAdded, rasFruStatLastReportTime=rasFruStatLastReportTime, phStorageSlotEntry=phStorageSlotEntry, loIeSegReservedBy=loIeSegReservedBy, downloadedFirmwareVersion=downloadedFirmwareVersion, numDriveElements=numDriveElements, totalFreeCapacity=totalFreeCapacity, phCleaningMediaTypeIndex=phCleaningMediaTypeIndex, loSegmentStartingAddress=loSegmentStartingAddress, rasTicketState=rasTicketState, loStatsNumPuts=loStatsNumPuts, connectivityGroupStatusChange=connectivityGroupStatusChange, loDriveSegStartingAddress=loDriveSegStartingAddress, rasFruStatFruCategory=rasFruStatFruCategory, readiness=readiness, phMediaDomain=phMediaDomain, physLibraryConfigurationChange=physLibraryConfigurationChange, globalStatus=globalStatus, numPhIESlots=numPhIESlots, phCleaningSegTable=phCleaningSegTable, loStorageSegStartingAddress=loStorageSegStartingAddress, physLibraryOnlineStatusChange=physLibraryOnlineStatusChange, phCleaningMediaBarcode=phCleaningMediaBarcode, phSegmentEntry=phSegmentEntry, productIdTable=productIdTable, numPhSlots=numPhSlots, phIeStationEntry=phIeStationEntry, rasReportEntry=rasReportEntry, phTransportNumRecoveredGets=phTransportNumRecoveredGets, mcbInstallStatusText=mcbInstallStatusText, moveMediaComplete=moveMediaComplete, mediaDomainName=mediaDomainName, mediaTypeChecking=mediaTypeChecking, licenseKeyTable=licenseKeyTable, numVendorIds=numVendorIds, productDrivesMin=productDrivesMin, phDriveNumCleans=phDriveNumCleans, rasReportRowStatus=rasReportRowStatus, phSegmentCol=phSegmentCol, logTable=logTable, cmbInstallStatusText=cmbInstallStatusText, rasTicketCount=rasTicketCount, physLibraryDoorStatusChange=physLibraryDoorStatusChange, loStatus=loStatus, mediaType=mediaType, loDriveRow=loDriveRow, loSegmentCol=loSegmentCol, rasTicketComments=rasTicketComments, phDriveNumLoads=phDriveNumLoads, phIeSlotTable=phIeSlotTable, numPhFrames=numPhFrames, phIeSegTable=phIeSegTable, status=status, networkTimeProtocol=networkTimeProtocol, productIdEntry=productIdEntry, loSegmentCommand=loSegmentCommand, AdicStatusGroup=AdicStatusGroup, AdicFcPortType=AdicFcPortType, loSegmentType=loSegmentType, phCleaningMediaTable=phCleaningMediaTable, rasReportTable=rasReportTable, fcPortPreferredType=fcPortPreferredType, phSegmentSection=phSegmentSection, cmbInstallProcessStatus=cmbInstallProcessStatus, licenseKeyAppliedDate=licenseKeyAppliedDate, globalEthernetTable=globalEthernetTable, logicalLibraryIndex=logicalLibraryIndex, phDriveSerialNumber=phDriveSerialNumber, globalStatusTable=globalStatusTable, installProcessStatus=installProcessStatus, phGeneralInfoTable=phGeneralInfoTable, productIeMax=productIeMax, licenseKeyDuration=licenseKeyDuration, phIeMediaId=phIeMediaId, loDriveSegTable=loDriveSegTable, phTransportElementAddress=phTransportElementAddress, rasFruInstanceId=rasFruInstanceId, phFrameEntry=phFrameEntry, rasFruStatOpenTickets=rasFruStatOpenTickets, mediaDomainTable=mediaDomainTable, componentsInBundle=componentsInBundle, phDriveStatHistoryTable=phDriveStatHistoryTable, loDriveSegSize=loDriveSegSize, phMediaReadErrors=phMediaReadErrors, rasStatusGroupLastChange=rasStatusGroupLastChange, phDriveStatHistoryEntry=phDriveStatHistoryEntry, coolingGroupStatusChange=coolingGroupStatusChange, phDriveAutoCleaning=phDriveAutoCleaning, rasTicketFilterSeverity=rasTicketFilterSeverity, masterOnlineStatus=masterOnlineStatus, networkTimeServer1=networkTimeServer1, rasStatusGroupOpenTickets=rasStatusGroupOpenTickets, enableDaylightSavingsTime=enableDaylightSavingsTime, loDriveSegEntry=loDriveSegEntry, fcbInstallProcessStatus=fcbInstallProcessStatus, phMediaExportTimestamp=phMediaExportTimestamp, AdicBarCode=AdicBarCode, autoPartitionCommand=autoPartitionCommand, rasTicketStatusGroup=rasTicketStatusGroup, loGeneralInfoTable=loGeneralInfoTable, phCleaningSegSize=phCleaningSegSize, fcPortNegotiatedSpeed=fcPortNegotiatedSpeed, mcbHostName=mcbHostName, rasReportOrcData=rasReportOrcData, phCleaningMediaEntry=phCleaningMediaEntry, mediaDomainIndex=mediaDomainIndex, loDriveTable=loDriveTable, phSegmentType=phSegmentType, loSegmentBelongsTo=loSegmentBelongsTo, registrationEntry=registrationEntry, phIeSegReserve=phIeSegReserve, phDriveScsiLun=phDriveScsiLun, phSegStartingAddress=phSegStartingAddress, vendorIdEntry=vendorIdEntry, loSegmentBelongsToTable=loSegmentBelongsToTable, loSegmentAisle=loSegmentAisle, phCleaningMediaMaxUses=phCleaningMediaMaxUses, loGeneralInfoEntry=loGeneralInfoEntry, mediaTypeName=mediaTypeName, logicalLibraryOnlineStatusChange=logicalLibraryOnlineStatusChange, physicalLibrary=physicalLibrary, userName=userName, loNumLibraries=loNumLibraries, driveBrickFwUpdateSuccess=driveBrickFwUpdateSuccess, phDriveVendor=phDriveVendor, phDriveFirmwareVersion=phDriveFirmwareVersion, fcDrivePortTable=fcDrivePortTable, productSlotsMin=productSlotsMin, phHourlyMounts=phHourlyMounts, phDrivePowerStatus=phDrivePowerStatus, logSnapshotCommand=logSnapshotCommand, softwareInstallationEntry=softwareInstallationEntry, phSegmentStatus=phSegmentStatus, key=key, rasFruStatIndex=rasFruStatIndex, phMediaType=phMediaType, rasEventNotification=rasEventNotification, rasFruStatSerialNumber=rasFruStatSerialNumber, phCleaningMediaVendorId=phCleaningMediaVendorId, phDriveWwPortName=phDriveWwPortName, AdicStatusGroupState=AdicStatusGroupState, rasSystemStatusEntry=rasSystemStatusEntry, ipAddressSubnetMask=ipAddressSubnetMask, phDriveFcPortId=phDriveFcPortId, numStorageCartridges=numStorageCartridges, globalStatusEntry=globalStatusEntry, hostIpAddress=hostIpAddress, phDriveStatus=phDriveStatus, phFrameTable=phFrameTable, phDriveRasStatus=phDriveRasStatus, rasReportStatusGroup=rasReportStatusGroup, drivesAndMediaGroupStatusChange=drivesAndMediaGroupStatusChange, licenseKeyExpirationDate=licenseKeyExpirationDate, licenseFeatureEntry=licenseFeatureEntry, driveActivityUpdate=driveActivityUpdate, rasReportSerialNumber=rasReportSerialNumber, rasTicketTimeClosed=rasTicketTimeClosed, phDriveFcLoopIdMode=phDriveFcLoopIdMode, phDriveSegMediaType=phDriveSegMediaType, systemManagerTable=systemManagerTable)
mibBuilder.exportSymbols("ADIC-MANAGEMENT-MIB", mediaDomain=mediaDomain, phCleaningMediaImportTimestamp=phCleaningMediaImportTimestamp, installStatusText=installStatusText, phDriveElementAddr=phDriveElementAddr, phIeSlotEntry=phIeSlotEntry, phCleaningSegRowStatus=phCleaningSegRowStatus, phDriveWriteProtected=phDriveWriteProtected, rasStatusGroupTotalTickets=rasStatusGroupTotalTickets, phTransportTable=phTransportTable, amcInstallStatusText=amcInstallStatusText, phTransportREDId=phTransportREDId, licenseFeatureTable=licenseFeatureTable, phMediaTable=phMediaTable, logSnapshotTable=logSnapshotTable, productIdIndex=productIdIndex, ieStationDoorStatusChange=ieStationDoorStatusChange, logName=logName, phMediaExported=phMediaExported, phDriveSegSize=phDriveSegSize, fcbInstallStatusText=fcbInstallStatusText, phMediaBarCode=phMediaBarCode, numSlots=numSlots, security=security, phDrivePorts=phDrivePorts, phDriveNeedsCleaning=phDriveNeedsCleaning, phStorageSegSize=phStorageSegSize, loSegmentEntry=loSegmentEntry, physLibraryActivity=physLibraryActivity, rasFruStatFirstReportTime=rasFruStatFirstReportTime, loIeSegEntry=loIeSegEntry, loStatsNumPutRetries=loStatsNumPutRetries, logicalLibraryActivity=logicalLibraryActivity, phDriveWwn=phDriveWwn, onlineStatus=onlineStatus, physLibraryRESChange=physLibraryRESChange, phIeSegOnlineStatus=phIeSegOnlineStatus, phDriveProduct=phDriveProduct, licensableFeatureTable=licensableFeatureTable, numLogicalLibraries=numLogicalLibraries, loSegmentSize=loSegmentSize, rasTicketTimeOpened=rasTicketTimeOpened, rasReportOrcDescription=rasReportOrcDescription, loIeSlotTable=loIeSlotTable, phStorageSlotTable=phStorageSlotTable, phMediaMounts=phMediaMounts, rasFruStatStatusGroup=rasFruStatStatusGroup, phFrameType=phFrameType, numIeElements=numIeElements, fcDrivePortEntry=fcDrivePortEntry, maxLogicalLibraries=maxLogicalLibraries, softwareInstallationTable=softwareInstallationTable, autoInventoryMode=autoInventoryMode, phDriveWriteErrors=phDriveWriteErrors, serialNumber=serialNumber, rcuNotReady=rcuNotReady, licensableFeatureName=licensableFeatureName, loDriveSegInterfaceType=loDriveSegInterfaceType, loSegmentStatus=loSegmentStatus, processRowStatus=processRowStatus, assignedLun=assignedLun, logicalLibraryDeleted=logicalLibraryDeleted, rasSystemStatusTable=rasSystemStatusTable, phFrameNumRacks=phFrameNumRacks, installCommand=installCommand, phTransportEntry=phTransportEntry, phTransportNumPuts=phTransportNumPuts, loMediaTypeCheckingPolicy=loMediaTypeCheckingPolicy, licenseFeatureQuantity=licenseFeatureQuantity, phIeStationDoorStatus=phIeStationDoorStatus, operatingMode=operatingMode, preferredSpeed=preferredSpeed, mediaTypeIndex=mediaTypeIndex, name=name, controlGroupStatusChange=controlGroupStatusChange, phDriveMbytesRead=phDriveMbytesRead, rasTicketFilterEntry=rasTicketFilterEntry, mediaDomainEntry=mediaDomainEntry, phSegmentMediaDomain=phSegmentMediaDomain, networkTimeEnable=networkTimeEnable, phSegmentAisle=phSegmentAisle, loIeRow=loIeRow, fcPortTypeQualifier=fcPortTypeQualifier, physLibraryDoorStatus=physLibraryDoorStatus, numProductIds=numProductIds, rasTicketKeyReport=rasTicketKeyReport, rasFruStatTable=rasFruStatTable, AdicRasTicketState=AdicRasTicketState, phMediaImportTimestamp=phMediaImportTimestamp, previousFirmwareVersion=previousFirmwareVersion, loIeSlotEntry=loIeSlotEntry, phDriveTable=phDriveTable, phDriveSegEntry=phDriveSegEntry, licenseKeyRowStatus=licenseKeyRowStatus, numPhAisles=numPhAisles, loStatisticsTable=loStatisticsTable, loIeSegTable=loIeSegTable, mcbInstallProcessStatus=mcbInstallProcessStatus, automaticCleaning=automaticCleaning, tapeDriveRemoved=tapeDriveRemoved, phHourlyMBytesRead=phHourlyMBytesRead, phCleaningMediaUseCount=phCleaningMediaUseCount, ipAddress=ipAddress, autoConfigureMode=autoConfigureMode, phTransportDomainTable=phTransportDomainTable, licensing=licensing, phIeStationNumber=phIeStationNumber, loInterfaceType=loInterfaceType, physLibraryManagerLun=physLibraryManagerLun, ethernetDuplex=ethernetDuplex, loNumRecoveredScans=loNumRecoveredScans, phIeSegCommand=phIeSegCommand, rasTicketFilterStatusGroup=rasTicketFilterStatusGroup, phTransportNumRecoveredPuts=phTransportNumRecoveredPuts, numCleaningCartridges=numCleaningCartridges, logicalLibrary=logicalLibrary, rasFruStatFruId=rasFruStatFruId, phStorageSegEntry=phStorageSegEntry, capacity=capacity, fcPortNegotiatedType=fcPortNegotiatedType, phDriveFcLoopId=phDriveFcLoopId, totalQuantityLicensed=totalQuantityLicensed, phSegmentTable=phSegmentTable, userRowStatus=userRowStatus, rasTicketSerialNumber=rasTicketSerialNumber, numStorageElements=numStorageElements, phIeMediaPresent=phIeMediaPresent, AdicSegmentType=AdicSegmentType, phFrameSerialNumber=phFrameSerialNumber, vendorIdTable=vendorIdTable, amcInstallProcessStatus=amcInstallProcessStatus, phDriveSegTable=phDriveSegTable, loNumRecoveredPuts=loNumRecoveredPuts, autoPartitionTable=autoPartitionTable, phDriveCompressionOn=phDriveCompressionOn, loStatsNumGetRetries=loStatsNumGetRetries, udpPort=udpPort, phSegmentCodStatus=phSegmentCodStatus, loSegmentStartingRow=loSegmentStartingRow, loSegmentAssignedTo=loSegmentAssignedTo, phDriveReadErrors=phDriveReadErrors, rasStatusGroupIndex=rasStatusGroupIndex, rasStatusGroupActionsPending=rasStatusGroupActionsPending, userEntry=userEntry, loStatisticsEntry=loStatisticsEntry, rasTicketGroupStatus=rasTicketGroupStatus, phIeStationTable=phIeStationTable, command=command, speedAutoNegotiation=speedAutoNegotiation, phDriveFcHardId=phDriveFcHardId, globalEthernetManager=globalEthernetManager, ras=ras, loSegmentMediaDomain=loSegmentMediaDomain, rcuReady=rcuReady, phGeneralInfoEntry=phGeneralInfoEntry, phCleaningMediaStatus=phCleaningMediaStatus, systemDateAndTime=systemDateAndTime, management=management, persistentData=persistentData, phCleaningMediaRow=phCleaningMediaRow, userGroup=userGroup, licenseKeyEntry=licenseKeyEntry, freeSpace=freeSpace, phIeSegSize=phIeSegSize, userPassword=userPassword, phSegmentRack=phSegmentRack, persistentDataTable=persistentDataTable, loIeSegReserve=loIeSegReserve, roboticsGroupStatusChange=roboticsGroupStatusChange, phDriveSegInterfaceType=phDriveSegInterfaceType, phDriveInterfaceType=phDriveInterfaceType, managementMibVersion=managementMibVersion, AdicFruSerialNumber=AdicFruSerialNumber, phCleaningSegEntry=phCleaningSegEntry, rasTicketFilterState=rasTicketFilterState, loSegmentSection=loSegmentSection, licenseFeatureIndex=licenseFeatureIndex, physLibraryAutoCleaning=physLibraryAutoCleaning, loSegmentRack=loSegmentRack, installPackageName=installPackageName, logicalLibraryModified=logicalLibraryModified, loStorageSegEntry=loStorageSegEntry, numPhDrives=numPhDrives, phDriveOnlineStatus=phDriveOnlineStatus, logicalLibraryEntry=logicalLibraryEntry, rasTicketRowStatus=rasTicketRowStatus, numCleaningSlots=numCleaningSlots, loSegmentBelongsToEntry=loSegmentBelongsToEntry, mediaDismounted=mediaDismounted, phHourlyMBytesWritten=phHourlyMBytesWritten, rasTicketDescription=rasTicketDescription, actualSpeed=actualSpeed, rasTicketTable=rasTicketTable, rasTicketEntry=rasTicketEntry, totalUsedCapacity=totalUsedCapacity, registrationTable=registrationTable, loLtoTapeTags=loLtoTapeTags, rasStatusGroupTextSummary=rasStatusGroupTextSummary, phIeSegEntry=phIeSegEntry, phMediaEntry=phMediaEntry, phMediaFreeSpace=phMediaFreeSpace, driveBrickFwUpdateFailure=driveBrickFwUpdateFailure, persistentDataEntry=persistentDataEntry, productId=productId, numIE=numIE, loStorageSegSize=loStorageSegSize, phMediaElementAddress=phMediaElementAddress, productIeMin=productIeMin, networkTimeServer2=networkTimeServer2, globalEthernetEntry=globalEthernetEntry, phDriveEntry=phDriveEntry, rasReportHeadReport=rasReportHeadReport, eventManager=eventManager, featureName=featureName, driveBrickFwUpdateStart=driveBrickFwUpdateStart)

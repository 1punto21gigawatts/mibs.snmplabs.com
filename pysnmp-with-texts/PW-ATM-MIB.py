#
# PySNMP MIB module PW-ATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PW-ATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
AtmVcIdentifier, AtmVpIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVcIdentifier", "AtmVpIdentifier")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
pwIndex, = mibBuilder.importSymbols("PW-STD-MIB", "pwIndex")
PerfIntervalCount, PerfCurrentCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfIntervalCount", "PerfCurrentCount")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Bits, mib_2, Gauge32, MibIdentifier, Integer32, iso, TimeTicks, Counter64, NotificationType, ModuleIdentity, Unsigned32, Counter32, IpAddress, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "mib-2", "Gauge32", "MibIdentifier", "Integer32", "iso", "TimeTicks", "Counter64", "NotificationType", "ModuleIdentity", "Unsigned32", "Counter32", "IpAddress", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, TruthValue, DisplayString, TextualConvention, RowPointer = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue", "DisplayString", "TextualConvention", "RowPointer")
pwAtmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 183))
pwAtmMIB.setRevisions(('2009-06-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pwAtmMIB.setRevisionsDescriptions(('Initial version published as RFC 5605.',))
if mibBuilder.loadTexts: pwAtmMIB.setLastUpdated('200906160000Z')
if mibBuilder.loadTexts: pwAtmMIB.setOrganization('Pseudowire Emulation Edge-to-Edge (PWE3) Working Group')
if mibBuilder.loadTexts: pwAtmMIB.setContactInfo('Thomas D. Nadeau Postal: BT BT Centre 81 Newgate Street London EC1A 7AJ United Kingdom Email: tom.nadeau@bt.com Orly Nicklass Postal: RADVISION Ltd. 24 Raul Wallenberg Tel Aviv, Israel Email: orlyn@radvision.com Discussion and general questions should be posed to the PWE3 Working Group (pwe3@ietf.org).')
if mibBuilder.loadTexts: pwAtmMIB.setDescription("This MIB contains managed object definitions for pseudowire emulation of ATM over Packet Switched Networks (PSNs). This MIB supplements the PW-STD-MIB module. The PW-STD-MIB contains structures and MIB associations generic to pseudowire (PW) emulation. PW-specific MIBs (such as this) contain config and stats for specific PW types. Copyright (c) 2009 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. - Neither the name of Internet Society, IETF or IETF Trust, nor the names of specific contributors, may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. This version of this MIB module is part of RFC 5605; see the RFC itself for full legal notices. ")
pwAtmNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 183, 0))
pwAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 183, 1))
pwAtmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 183, 2))
pwAtmOutboundTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 1), )
if mibBuilder.loadTexts: pwAtmOutboundTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundTable.setDescription('This table specifies the information for an ATM PW to be carried over the PSN in the outbound direction. An entry is created in this table for every entry in the pwTable with a pwType equal to one of the following: atmAal5SduVcc(2), atmCell1to1Vcc(12), atmCell1to1Vpc(13) or atmAal5PduVcc(14), or atmTransparent(3).')
pwAtmOutboundEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 1, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwAtmOutboundEntry.setReference('See [PWMIB].')
if mibBuilder.loadTexts: pwAtmOutboundEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundEntry.setDescription('A row in this table represents an ATM PW that needs to be adapted and carried over the PSN. This table is indexed by pwIndex from pwTable. Unless otherwise specified, all writeable objects in this table MUST NOT be changed after row activation in the generic pwTable, and values must persist after reboot.')
pwAtmOutboundAtmIf = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 1, 1, 1), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundAtmIf.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundAtmIf.setDescription('The ATM Interface that receives cells from the ATM network.')
pwAtmOutboundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 1, 1, 2), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundVpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundVpi.setDescription('VPI value of this ATM PW. The value may indicate the translated value when egress generates new VPI.')
pwAtmOutboundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 1, 1, 3), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundVci.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundVci.setDescription('VCI value of this ATM PW. The value may indicate the translated value when egress generates new VCI.')
pwAtmOutboundTrafficParamDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 1, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundTrafficParamDescr.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundTrafficParamDescr.setDescription('This object represents a pointer to an ATM traffic-parameter-specific row in either a private or standard table that will be employed while receiving cells from the ATM network. This row should contain a set of self-consistent ATM traffic parameters including the ATM traffic service category. A value of 0.0 indicates Best Effort.')
pwAtmOutboundRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundRowStatus.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundRowStatus.setDescription('This object is used to create, modify, or delete a row in this table. Unless otherwise specified, all writeable objects in this table MUST NOT be changed after row activation as explained in the pwAtmOutboundEntry. ')
pwAtmInboundTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 3), )
if mibBuilder.loadTexts: pwAtmInboundTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundTable.setDescription('This table specifies the information for an ATM PW in the inbound direction.')
pwAtmInboundEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 3, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwAtmInboundEntry.setReference('See [PWMIB].')
if mibBuilder.loadTexts: pwAtmInboundEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundEntry.setDescription('A row in this table represents an ATM PW that needs to be sent into the ATM network after reconstructing cells from packets received from a PSN. This table is indexed by pwIndex from pwTable. An entry is created in this table for every entry in the pwTable with a pwType equal to one of the following: atmAal5SduVcc(2), atmCell1to1Vcc(12), atmCell1to1Vpc(13), atmAal5PduVcc(14), or atmTransparent(3). Unless otherwise specified, all writeable objects in this table MUST NOT be changed after row activation in the generic pwTable, and values must persist after reboot.')
pwAtmInboundAtmIf = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundAtmIf.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundAtmIf.setDescription('The ATM Interface that sends cells into the ATM network after reconstructing cells from packets received from a PSN.')
pwAtmInboundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 3, 1, 2), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundVpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundVpi.setDescription('VPI value of this ATM PW. If the pwType is atmTransparent, then the value will be set to zero.')
pwAtmInboundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 3, 1, 3), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundVci.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundVci.setDescription('VCI value of this ATM PW. If the pwType is atmTransparent, atmCell1to1Vpc, or atmCellNto1Vpc, then the value will be set to zero.')
pwAtmInboundTrafficParamDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 3, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundTrafficParamDescr.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundTrafficParamDescr.setDescription('This object represents a pointer to an ATM traffic-parameter- specific row in either a private or standard table that will be employed while transmitting into the ATM network. This table contains a set of self-consistent ATM traffic parameters including the ATM traffic service category. A value of 0.0 indicates Best Effort.')
pwAtmInboundRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundRowStatus.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundRowStatus.setDescription('This object is used to create, modify, or delete a row in this table. Unless otherwise specified, all writeable objects in this table MUST NOT be changed after row activation as explained in the pwAtmInboundEntry. ')
pwAtmCfgTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 5), )
if mibBuilder.loadTexts: pwAtmCfgTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgTable.setDescription('This table specifies generic information for an ATM PW to be carried over PSN in any mode.')
pwAtmCfgEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 5, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwAtmCfgEntry.setReference('See [PWMIB].')
if mibBuilder.loadTexts: pwAtmCfgEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgEntry.setDescription('This table contains a set of parameters for the ATM PW that needs to be adapted and carried over the PSN. This table is indexed by pwIndex from pwTable. An entry is created for every new ATM type associated pwIndex in the pwTable. Unless otherwise specified, all read-write objects in this table MAY be changed when the PW is defined as not active, and all RW objects values must persist after reboot.')
pwAtmCfgMaxCellConcatenation = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwAtmCfgMaxCellConcatenation.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgMaxCellConcatenation.setDescription('The maximum number of ATM cells that can be concatenated into one PW packet towards the PSN. In a non-LDP or other signaling protocol environment, this object MAY be changed at anytime, but traffic might be interrupted; otherwise, it may be changed when PW is not active.')
pwAtmCfgFarEndMaxCellConcatenation = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwAtmCfgFarEndMaxCellConcatenation.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgFarEndMaxCellConcatenation.setDescription('The maximum number of ATM cells that can be concatenated into one PW packet towards PSN as reported by the far end. If there is no LDP in use, the object will either return a value of 0 or allow setting it for calculating protocol overhead.')
pwAtmCfgTimeoutMode = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwAtmCfgTimeoutMode.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgTimeoutMode.setDescription('This object determines whether or not a packet can be transmitted to the PSN based on timeout expiration for collecting cells. The actual handling of the timeout is implementation-specific; as such, this object may be changed at any time under proper consideration of the traffic interruption effect.')
pwAtmClpQosMapping = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 5, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwAtmClpQosMapping.setReference('See section 12 of [ATMENCAP].')
if mibBuilder.loadTexts: pwAtmClpQosMapping.setStatus('current')
if mibBuilder.loadTexts: pwAtmClpQosMapping.setDescription('This object indicates whether the Cell Loss Priority (CLP) bits should be considered when setting the value in the Quality-of-Service fields of the encapsulating protocol (e.g., EXP fields of the MPLS Label Stack). Selecting True allows the drop precedence to be preserved across the PSN. In transparent cell transport, the value of this object MUST be false(2); in other cases, it can be changed at any time.')
pwAtmOutboundNto1Table = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 6), )
if mibBuilder.loadTexts: pwAtmOutboundNto1Table.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1Table.setDescription('This table specifies the information for an ATM PW to be carried over the PSN in the outbound direction. Up to N entries can be created in this table for every entry in the pwTable with a pwType equal to: atmCellNto1Vcc(9) or atmCellNto1Vpc(10). An entry can be created only when the VP/VC are known. A single entry will be created in this table for every entry in the pwTable with a pwType equal to one of the following: atmCell1to1Vcc(12), atmCell1to1Vpc(13), atmAal5PduVcc(14), atmAal5SduVcc(2), or atmTransparent(3). ')
pwAtmOutboundNto1Entry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 6, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-ATM-MIB", "pwAtmOutboundNto1AtmIf"), (0, "PW-ATM-MIB", "pwAtmOutboundNto1Vpi"), (0, "PW-ATM-MIB", "pwAtmOutboundNto1Vci"))
if mibBuilder.loadTexts: pwAtmOutboundNto1Entry.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1Entry.setDescription('A row in this table represents an ATM PW that needs to be adapted and carried over PSN. This table is indexed by pwIndex from pwTable and the ATM interface with VPL/VCLs. In atmTransparent(3), Vpi and VCi will be 0xFFFF during set operation. Unless otherwise specified, all read-create objects in this table MUST NOT be changed after row activation and SHOULD remain unchanged after reboot.')
pwAtmOutboundNto1AtmIf = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: pwAtmOutboundNto1AtmIf.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1AtmIf.setDescription('The ATM Interface that receives cells from the ATM network.')
pwAtmOutboundNto1Vpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 2), AtmVpIdentifier())
if mibBuilder.loadTexts: pwAtmOutboundNto1Vpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1Vpi.setDescription('VPI value of this ATM PW. In atmTransparent(3), Vpi will be the equivalent of 0xFFFF.')
pwAtmOutboundNto1Vci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 3), AtmVcIdentifier())
if mibBuilder.loadTexts: pwAtmOutboundNto1Vci.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1Vci.setDescription('VCI value of this ATM PW. In atmTransparent(3), or the VP case, the value will be the equivalent of 0xFFFF.')
pwAtmOutboundNto1RowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundNto1RowStatus.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1RowStatus.setDescription('This object is used to create, modify or delete a row in this table.')
pwAtmOutboundNto1TrafficParamDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 5), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundNto1TrafficParamDescr.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1TrafficParamDescr.setDescription('This object represents a pointer to an ATM traffic-parameter- specific row in either private or standard table that will be employed while receiving cells from the ATM network. This table should contain a set of self-consistent ATM traffic parameters including the ATM traffic service category. A value of 0.0 indicates Best Effort.')
pwAtmOutboundNto1MappedVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundNto1MappedVpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1MappedVpi.setDescription('The egress-generated VPI value of this ATM PW. The entry is valid for PW type of atmCellNto1Vcc(9), atmCellNto1Vpc(10), atmCell1to1Vcc(12), or atmCell1to1Vpc(13). In other types, the value will be the equivalent of 0xFFFF. Value MAY be changed when the PW is defined as not active. ')
pwAtmOutboundNto1MappedVci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 6, 1, 7), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmOutboundNto1MappedVci.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1MappedVci.setDescription('The egress-generated VCI value of this ATM PW. The entry is valid for PW type of atmCellNto1Vcc(9), atmCellNto1Vpc(10), atmCell1to1Vcc(12), or atmCell1to1Vpc(13. In the VP case or other types, the value will be the equivalent of 0xFFFF. Value MAY be changed when the PW is defined as not active.')
pwAtmInboundNto1Table = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 7), )
if mibBuilder.loadTexts: pwAtmInboundNto1Table.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1Table.setDescription('This table specifies the information for an ATM PW to be carried over PSN in the Inbound direction. Up to N entries can be created in this table for every entry in the pwTable with a pwType equal to: atmCellNto1Vcc(9) or atmCellNto1Vpc(10). An entry can be created only when the VP/VC are known. A single entry will be created in this table for every entry in the pwTable with a pwType equal to one of the following: atmCell1to1Vcc(12), atmCell1to1Vpc(13), atmAal5PduVcc(14), atmAal5SduVcc(2), or atmTransparent(3).')
pwAtmInboundNto1Entry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 7, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-ATM-MIB", "pwAtmInboundNto1AtmIf"), (0, "PW-ATM-MIB", "pwAtmInboundNto1Vpi"), (0, "PW-ATM-MIB", "pwAtmInboundNto1Vci"))
if mibBuilder.loadTexts: pwAtmInboundNto1Entry.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1Entry.setDescription('A row in this table represents an ATM PW that needs to be adapted and carried over PSN. This table is indexed by pwIndex from pwTable and the ATM interface with VPL/VCLs. In atmTransparent(3), Vpi and VCi will be 0xFFFF during set operation. Unless otherwise specified, all Read-Create objects in this table MUST NOT be changed after row activation and SHOULD remain unchanged after reboot.')
pwAtmInboundNto1AtmIf = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: pwAtmInboundNto1AtmIf.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1AtmIf.setDescription('The ATM Interface that receives cells from the ATM network.')
pwAtmInboundNto1Vpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 2), AtmVpIdentifier())
if mibBuilder.loadTexts: pwAtmInboundNto1Vpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1Vpi.setDescription('VPI value of this ATM PW. In atmTransparent(3), Vpi will be the equivalent of 0xFFFF.')
pwAtmInboundNto1Vci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 3), AtmVcIdentifier())
if mibBuilder.loadTexts: pwAtmInboundNto1Vci.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1Vci.setDescription('VCI value of this ATM PW. In atmTransparent(3), or the VP case, the value will be the equivalent of 0xFFFF.')
pwAtmInboundNto1RowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundNto1RowStatus.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1RowStatus.setDescription('This object is used to create, modify, or delete a row in this table.')
pwAtmInboundNto1TrafficParamDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 5), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundNto1TrafficParamDescr.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1TrafficParamDescr.setDescription('This object represents a pointer to an ATM traffic-parameter- specific row in either a private or standard table that will be employed while receiving cells from the ATM network. This table should contain a set of self-consistent ATM traffic parameters including the ATM traffic service category. A value of 0.0 indicates Best Effort.')
pwAtmInboundNto1MappedVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundNto1MappedVpi.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1MappedVpi.setDescription('The generated VPI value of this ATM PW. The entry is valid for PW type of atmCellNto1Vcc(9), atmCellNto1Vpc(10), atmCell1to1Vcc(12), or atmCell1to1Vpc(13). In other types, the value will be the equivalent of 0xFFFF. Value MAY be changed when the PW is defined as not active.')
pwAtmInboundNto1MappedVci = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 7, 1, 7), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwAtmInboundNto1MappedVci.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1MappedVci.setDescription('The generated VCI value of this ATM PW. The entry is valid for PW type of atmCellNto1Vcc(9), atmCellNto1Vpc(10), atmCell1to1Vcc(12), or atmCell1to1Vpc(13. In the VP case or other types, the value will be the equivalent of 0xFFFF. Value MAY be changed when the PW is defined as not active.')
pwAtmPerfCurrentTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 8), )
if mibBuilder.loadTexts: pwAtmPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentTable.setDescription('The current 15-minute interval counts are in this table. This table provides performance information per ATM PW.')
pwAtmPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 8, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwAtmPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentEntry.setDescription('An entry in this table is created by the agent for every pwAtmCfgTable entry. After 15 minutes, the contents of this table entry are copied to a new entry in the pwAtmPerfInterval table and the counts in this entry are reset to zero.')
pwAtmPerfCurrentMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
pwAtmPerfCurrentPktsReOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this feature.')
pwAtmPerfCurrentPktsMisOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsMisOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsMisOrder.setDescription('Number of packets detected out of order (via control word sequence numbers).')
pwAtmPerfCurrentPktsTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsTimeout.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentPktsTimeout.setDescription('Number of packets transmitted due to timeout expiration while attempting to collect cells.')
pwAtmPerfCurrentCellsXmit = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsXmit.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsXmit.setDescription('Number of transmitted cells.')
pwAtmPerfCurrentCellsDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsDropped.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsDropped.setDescription('Number of dropped cells.')
pwAtmPerfCurrentCellsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsReceived.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentCellsReceived.setDescription('Number of received cells.')
pwAtmPerfCurrentUnknownCells = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 8, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfCurrentUnknownCells.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfCurrentUnknownCells.setDescription('Number of cells received from the PSN with unknown VPI or VCI values. This object is relevant only in N:1 mode.')
pwAtmPerfIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 9), )
if mibBuilder.loadTexts: pwAtmPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalTable.setDescription('This table provides performance information per ATM PW similar to the pwAtmPerfCurrentTable above. However, these counts represent historical 15 minute intervals. Typically, this table will have a maximum of 96 entries for a 24 hour period. ')
pwAtmPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 9, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-ATM-MIB", "pwAtmPerfIntervalNumber"))
if mibBuilder.loadTexts: pwAtmPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalEntry.setDescription('An entry in this table is created by the agent for every pwAtmPerfCurrentEntry that is 15 minutes old. The contents of the Current entry are copied to the new entry here. The Current entry then resets its counts to zero for the next current 15 minute interval. ')
pwAtmPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: pwAtmPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalNumber.setDescription('A number (normally between 1 and 96 to cover a 24 hour period) that identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1. The minimum range of N is 1 through 4. The default range is 1 through 32. The maximum value of N is 96.')
pwAtmPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
pwAtmPerfIntervalDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalDuration.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalDuration.setDescription("The duration of a particular interval in seconds. Adjustments in the system's time-of-day clock, may cause the interval to be greater or less than the normal value. Therefore, this actual interval value is provided.")
pwAtmPerfIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
pwAtmPerfIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this feature.')
pwAtmPerfIntervalPktsMisOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsMisOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsMisOrder.setDescription('Number of packets detected out of order (via control word sequence numbers).')
pwAtmPerfIntervalPktsTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsTimeout.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalPktsTimeout.setDescription('Number of packets transmitted due to timeout expiration.')
pwAtmPerfIntervalCellsXmit = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsXmit.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsXmit.setDescription('Number of transmitted cells.')
pwAtmPerfIntervalCellsDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsDropped.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsDropped.setDescription('Number of dropped cells.')
pwAtmPerfIntervalCellsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsReceived.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalCellsReceived.setDescription('Number of received cells.')
pwAtmPerfIntervalUnknownCells = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 9, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerfIntervalUnknownCells.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfIntervalUnknownCells.setDescription('Number of cells received from the PSN with unknown VPI or VCI values. This object is relevant only in N:1 mode.')
pwAtmPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 183, 1, 10), )
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalTable.setDescription('This table provides performance information per ATM PW similar to the pwAtmPerfIntervalTable above. However, these counters represent historical one-day intervals up to one full month.')
pwAtmPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 183, 1, 10, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-ATM-MIB", "pwAtmPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalEntry.setDescription('An entry is created in this table by the agent for every entry in the pwAtmCfgTable table.')
pwAtmPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 365)))
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalNumber.setDescription('The number of intervals, where 1 indicates current day measured period and 2 and above indicate previous days, respectively.')
pwAtmPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalValidData.setDescription('This object indicates if the data for this interval is valid.')
pwAtmPerf1DayIntervalDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalDuration.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalDuration.setDescription("The duration of a particular interval in seconds. Adjustments in the system's time-of-day clock may cause the interval to be greater or less than the normal value. Therefore, this actual interval value is provided.")
pwAtmPerf1DayIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
pwAtmPerf1DayIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this feature.')
pwAtmPerf1DayIntervalPktsMisOrder = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsMisOrder.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsMisOrder.setDescription('Number of packets detected out of order (via control word sequence numbers) and that could not be re-ordered.')
pwAtmPerf1DayIntervalPktsTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsTimeout.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalPktsTimeout.setDescription('Number of packets transmitted due to timeout expiration.')
pwAtmPerf1DayIntervalCellsXmit = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsXmit.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsXmit.setDescription('Number of transmitted cells.')
pwAtmPerf1DayIntervalCellsDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsDropped.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsDropped.setDescription('Number of dropped cells.')
pwAtmPerf1DayIntervalCellsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsReceived.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalCellsReceived.setDescription('Number of received cells.')
pwAtmPerf1DayIntervalUnknownCells = MibTableColumn((1, 3, 6, 1, 2, 1, 183, 1, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalUnknownCells.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerf1DayIntervalUnknownCells.setDescription('Number of cells received from the PSN with unknown VPI or VCI values. This object is relevant only in N:1 mode.')
pwAtmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 183, 2, 1))
pwAtmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 183, 2, 2))
pwAtmCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 183, 2, 1, 2)).setObjects(("PW-ATM-MIB", "pwAtmCfgGroup"), ("PW-ATM-MIB", "pwAtmPerfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmCompliance = pwAtmCompliance.setStatus('current')
if mibBuilder.loadTexts: pwAtmCompliance.setDescription('The compliance statement for agents that support ATM PW.')
pwAtmCfgGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 5)).setObjects(("PW-ATM-MIB", "pwAtmCfgMaxCellConcatenation"), ("PW-ATM-MIB", "pwAtmCfgFarEndMaxCellConcatenation"), ("PW-ATM-MIB", "pwAtmCfgTimeoutMode"), ("PW-ATM-MIB", "pwAtmClpQosMapping"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmCfgGroup = pwAtmCfgGroup.setStatus('current')
if mibBuilder.loadTexts: pwAtmCfgGroup.setDescription('Collection of objects for basic ATM PW configuration.')
pwAtmPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 6)).setObjects(("PW-ATM-MIB", "pwAtmPerfCurrentMissingPkts"), ("PW-ATM-MIB", "pwAtmPerfCurrentPktsReOrder"), ("PW-ATM-MIB", "pwAtmPerfCurrentPktsMisOrder"), ("PW-ATM-MIB", "pwAtmPerfCurrentPktsTimeout"), ("PW-ATM-MIB", "pwAtmPerfCurrentCellsXmit"), ("PW-ATM-MIB", "pwAtmPerfCurrentCellsDropped"), ("PW-ATM-MIB", "pwAtmPerfCurrentCellsReceived"), ("PW-ATM-MIB", "pwAtmPerfCurrentUnknownCells"), ("PW-ATM-MIB", "pwAtmPerfIntervalValidData"), ("PW-ATM-MIB", "pwAtmPerfIntervalDuration"), ("PW-ATM-MIB", "pwAtmPerfIntervalMissingPkts"), ("PW-ATM-MIB", "pwAtmPerfIntervalPktsReOrder"), ("PW-ATM-MIB", "pwAtmPerfIntervalPktsMisOrder"), ("PW-ATM-MIB", "pwAtmPerfIntervalPktsTimeout"), ("PW-ATM-MIB", "pwAtmPerfIntervalCellsXmit"), ("PW-ATM-MIB", "pwAtmPerfIntervalCellsDropped"), ("PW-ATM-MIB", "pwAtmPerfIntervalCellsReceived"), ("PW-ATM-MIB", "pwAtmPerfIntervalUnknownCells"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalValidData"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalDuration"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalMissingPkts"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalPktsReOrder"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalPktsMisOrder"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalPktsTimeout"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalCellsXmit"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalCellsDropped"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalCellsReceived"), ("PW-ATM-MIB", "pwAtmPerf1DayIntervalUnknownCells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmPerfGroup = pwAtmPerfGroup.setStatus('current')
if mibBuilder.loadTexts: pwAtmPerfGroup.setDescription('Collection of objects for basic ATM PW Performance.')
pwAtmOutbound1to1Group = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 7)).setObjects(("PW-ATM-MIB", "pwAtmOutboundAtmIf"), ("PW-ATM-MIB", "pwAtmOutboundVpi"), ("PW-ATM-MIB", "pwAtmOutboundVci"), ("PW-ATM-MIB", "pwAtmOutboundTrafficParamDescr"), ("PW-ATM-MIB", "pwAtmOutboundRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmOutbound1to1Group = pwAtmOutbound1to1Group.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutbound1to1Group.setDescription('Collection of objects for basic 1:1 ATM PW outbound configuration.')
pwAtmInbound1to1Group = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 8)).setObjects(("PW-ATM-MIB", "pwAtmInboundAtmIf"), ("PW-ATM-MIB", "pwAtmInboundVpi"), ("PW-ATM-MIB", "pwAtmInboundVci"), ("PW-ATM-MIB", "pwAtmInboundTrafficParamDescr"), ("PW-ATM-MIB", "pwAtmInboundRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmInbound1to1Group = pwAtmInbound1to1Group.setStatus('current')
if mibBuilder.loadTexts: pwAtmInbound1to1Group.setDescription('Collection of objects for basic 1:1 ATM PW inbound configuration.')
pwAtmOutboundNto1Group = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 9)).setObjects(("PW-ATM-MIB", "pwAtmOutboundNto1RowStatus"), ("PW-ATM-MIB", "pwAtmOutboundNto1TrafficParamDescr"), ("PW-ATM-MIB", "pwAtmOutboundNto1MappedVpi"), ("PW-ATM-MIB", "pwAtmOutboundNto1MappedVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmOutboundNto1Group = pwAtmOutboundNto1Group.setStatus('current')
if mibBuilder.loadTexts: pwAtmOutboundNto1Group.setDescription('Collection of objects for N:1, 1:1, or transparent ATM PW outbound configuration.')
pwAtmInboundNto1Group = ObjectGroup((1, 3, 6, 1, 2, 1, 183, 2, 2, 10)).setObjects(("PW-ATM-MIB", "pwAtmInboundNto1RowStatus"), ("PW-ATM-MIB", "pwAtmInboundNto1TrafficParamDescr"), ("PW-ATM-MIB", "pwAtmInboundNto1MappedVpi"), ("PW-ATM-MIB", "pwAtmInboundNto1MappedVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwAtmInboundNto1Group = pwAtmInboundNto1Group.setStatus('current')
if mibBuilder.loadTexts: pwAtmInboundNto1Group.setDescription('Collection of objects for N:1, 1:1, or transparent ATM PW inbound configuration.')
mibBuilder.exportSymbols("PW-ATM-MIB", pwAtmCompliances=pwAtmCompliances, pwAtmMIB=pwAtmMIB, pwAtmInboundNto1Group=pwAtmInboundNto1Group, pwAtmPerfIntervalDuration=pwAtmPerfIntervalDuration, pwAtmPerf1DayIntervalPktsMisOrder=pwAtmPerf1DayIntervalPktsMisOrder, pwAtmPerfIntervalUnknownCells=pwAtmPerfIntervalUnknownCells, pwAtmInboundNto1Table=pwAtmInboundNto1Table, pwAtmPerfCurrentPktsMisOrder=pwAtmPerfCurrentPktsMisOrder, pwAtmOutboundEntry=pwAtmOutboundEntry, pwAtmPerfIntervalCellsDropped=pwAtmPerfIntervalCellsDropped, pwAtmOutboundNto1RowStatus=pwAtmOutboundNto1RowStatus, pwAtmInboundNto1MappedVpi=pwAtmInboundNto1MappedVpi, pwAtmPerfCurrentCellsDropped=pwAtmPerfCurrentCellsDropped, pwAtmPerf1DayIntervalPktsReOrder=pwAtmPerf1DayIntervalPktsReOrder, pwAtmCompliance=pwAtmCompliance, pwAtmPerfCurrentPktsTimeout=pwAtmPerfCurrentPktsTimeout, pwAtmInboundVci=pwAtmInboundVci, pwAtmInboundRowStatus=pwAtmInboundRowStatus, pwAtmPerf1DayIntervalMissingPkts=pwAtmPerf1DayIntervalMissingPkts, pwAtmPerfCurrentCellsXmit=pwAtmPerfCurrentCellsXmit, pwAtmPerf1DayIntervalEntry=pwAtmPerf1DayIntervalEntry, pwAtmPerfCurrentCellsReceived=pwAtmPerfCurrentCellsReceived, pwAtmPerfIntervalPktsReOrder=pwAtmPerfIntervalPktsReOrder, pwAtmPerfIntervalCellsReceived=pwAtmPerfIntervalCellsReceived, pwAtmOutboundNto1Group=pwAtmOutboundNto1Group, pwAtmInboundTable=pwAtmInboundTable, pwAtmInbound1to1Group=pwAtmInbound1to1Group, pwAtmOutboundTrafficParamDescr=pwAtmOutboundTrafficParamDescr, pwAtmClpQosMapping=pwAtmClpQosMapping, pwAtmCfgMaxCellConcatenation=pwAtmCfgMaxCellConcatenation, pwAtmOutboundVpi=pwAtmOutboundVpi, pwAtmInboundNto1Entry=pwAtmInboundNto1Entry, pwAtmInboundEntry=pwAtmInboundEntry, pwAtmCfgTimeoutMode=pwAtmCfgTimeoutMode, pwAtmOutboundNto1Entry=pwAtmOutboundNto1Entry, pwAtmPerf1DayIntervalUnknownCells=pwAtmPerf1DayIntervalUnknownCells, pwAtmPerfIntervalMissingPkts=pwAtmPerfIntervalMissingPkts, pwAtmPerf1DayIntervalTable=pwAtmPerf1DayIntervalTable, pwAtmPerfIntervalPktsTimeout=pwAtmPerfIntervalPktsTimeout, pwAtmPerf1DayIntervalDuration=pwAtmPerf1DayIntervalDuration, pwAtmOutboundNto1MappedVci=pwAtmOutboundNto1MappedVci, pwAtmPerfCurrentEntry=pwAtmPerfCurrentEntry, pwAtmPerfIntervalEntry=pwAtmPerfIntervalEntry, pwAtmInboundNto1RowStatus=pwAtmInboundNto1RowStatus, pwAtmPerfGroup=pwAtmPerfGroup, PYSNMP_MODULE_ID=pwAtmMIB, pwAtmPerfCurrentTable=pwAtmPerfCurrentTable, pwAtmPerfIntervalTable=pwAtmPerfIntervalTable, pwAtmOutboundNto1AtmIf=pwAtmOutboundNto1AtmIf, pwAtmInboundNto1Vci=pwAtmInboundNto1Vci, pwAtmInboundNto1Vpi=pwAtmInboundNto1Vpi, pwAtmInboundNto1MappedVci=pwAtmInboundNto1MappedVci, pwAtmObjects=pwAtmObjects, pwAtmOutboundRowStatus=pwAtmOutboundRowStatus, pwAtmOutboundNto1MappedVpi=pwAtmOutboundNto1MappedVpi, pwAtmCfgGroup=pwAtmCfgGroup, pwAtmPerf1DayIntervalNumber=pwAtmPerf1DayIntervalNumber, pwAtmConformance=pwAtmConformance, pwAtmOutboundNto1Table=pwAtmOutboundNto1Table, pwAtmOutboundNto1Vci=pwAtmOutboundNto1Vci, pwAtmGroups=pwAtmGroups, pwAtmPerfIntervalValidData=pwAtmPerfIntervalValidData, pwAtmCfgTable=pwAtmCfgTable, pwAtmPerfIntervalCellsXmit=pwAtmPerfIntervalCellsXmit, pwAtmInboundNto1AtmIf=pwAtmInboundNto1AtmIf, pwAtmInboundVpi=pwAtmInboundVpi, pwAtmPerfCurrentUnknownCells=pwAtmPerfCurrentUnknownCells, pwAtmPerf1DayIntervalValidData=pwAtmPerf1DayIntervalValidData, pwAtmPerfIntervalNumber=pwAtmPerfIntervalNumber, pwAtmInboundNto1TrafficParamDescr=pwAtmInboundNto1TrafficParamDescr, pwAtmPerfIntervalPktsMisOrder=pwAtmPerfIntervalPktsMisOrder, pwAtmPerf1DayIntervalCellsXmit=pwAtmPerf1DayIntervalCellsXmit, pwAtmInboundAtmIf=pwAtmInboundAtmIf, pwAtmOutboundTable=pwAtmOutboundTable, pwAtmOutboundNto1TrafficParamDescr=pwAtmOutboundNto1TrafficParamDescr, pwAtmOutboundAtmIf=pwAtmOutboundAtmIf, pwAtmOutboundNto1Vpi=pwAtmOutboundNto1Vpi, pwAtmPerf1DayIntervalCellsReceived=pwAtmPerf1DayIntervalCellsReceived, pwAtmNotifications=pwAtmNotifications, pwAtmPerfCurrentMissingPkts=pwAtmPerfCurrentMissingPkts, pwAtmPerf1DayIntervalCellsDropped=pwAtmPerf1DayIntervalCellsDropped, pwAtmCfgEntry=pwAtmCfgEntry, pwAtmPerfCurrentPktsReOrder=pwAtmPerfCurrentPktsReOrder, pwAtmPerf1DayIntervalPktsTimeout=pwAtmPerf1DayIntervalPktsTimeout, pwAtmInboundTrafficParamDescr=pwAtmInboundTrafficParamDescr, pwAtmOutboundVci=pwAtmOutboundVci, pwAtmOutbound1to1Group=pwAtmOutbound1to1Group, pwAtmCfgFarEndMaxCellConcatenation=pwAtmCfgFarEndMaxCellConcatenation)

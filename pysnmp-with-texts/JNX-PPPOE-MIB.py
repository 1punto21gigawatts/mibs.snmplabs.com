#
# PySNMP MIB module JNX-PPPOE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JNX-PPPOE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
jnxPppoeMibRoot, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxPppoeMibRoot")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Integer32, ObjectIdentity, NotificationType, Gauge32, IpAddress, ModuleIdentity, Bits, MibIdentifier, TimeTicks, Unsigned32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Integer32", "ObjectIdentity", "NotificationType", "Gauge32", "IpAddress", "ModuleIdentity", "Bits", "MibIdentifier", "TimeTicks", "Unsigned32", "iso")
DisplayString, MacAddress, TruthValue, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "TruthValue", "RowStatus", "TextualConvention")
jnxPPPoEMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1))
jnxPPPoEMIB.setRevisions(('2013-06-13 00:00', '2010-07-22 09:42',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxPPPoEMIB.setRevisionsDescriptions(('Deprecated InterfaceIndex type and added InterfaceIndexOrZero type for jnxPPPoENextIfIndex and jnxPPPoESubIfNextIfIndex. Modified minimum range for jnxPPPoEIfServiceNameTable.', 'Initial version.',))
if mibBuilder.loadTexts: jnxPPPoEMIB.setLastUpdated('201007220942Z')
if mibBuilder.loadTexts: jnxPPPoEMIB.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxPPPoEMIB.setContactInfo(' Juniper Networks, Inc. Postal: 10 Technology Park Drive Westford, MA 01886-3146 USA Tel: +1 978 589 5800 Email: support@Juniper.net')
if mibBuilder.loadTexts: jnxPPPoEMIB.setDescription('The Point-to-Point Protocol over Ethernet (PPPoE) MIB for the Junos product family. This MIB contains managed objects for each of two interface layers: PPPoE interfaces, and PPPoE subinterfaces. For each of these layers, management objects are provided to query for an available interface index, and to create/delete interfaces of that type.')
class JnxPPPoEServiceNameAction(TextualConvention, Integer32):
    description = 'The set of Service-name action types. drop no PADO packet will be sent. terminate a PADO packet will be sent.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("drop", 0), ("terminate", 1))

jnxPPPoEObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1))
jnxPPPoEIfLayer = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1))
jnxPPPoESubIfLayer = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2))
jnxPPPoESummary = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3))
jnxPPPoEServices = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4))
jnxPPPoENextIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoENextIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoENextIfIndex.setDescription('Coordinate ifIndex value allocation for entries in jnxPPPoEIfTable. A GET of this object returns the next available ifIndex value to be used to create an entry in the associated interface table; or zero, if no valid ifIndex value is available. This object also returns a value of zero when it is the lexicographic successor of a varbind presented in an SNMP GETNEXT or GETBULK request, for which circumstance it is assumed that ifIndex allocation is unintended. Successive GETs will typically return different values, thus avoiding collisions among cooperating management clients seeking to create table entries simultaneously.')
jnxPPPoEIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2), )
if mibBuilder.loadTexts: jnxPPPoEIfTable.setReference('RFC 2156 A method for transmitting PPP over Ethernet')
if mibBuilder.loadTexts: jnxPPPoEIfTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfTable.setDescription('The parameters for the PPPoEservice on this interface.')
jnxPPPoEIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"))
if mibBuilder.loadTexts: jnxPPPoEIfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfEntry.setDescription('The Parameters for a particular PPPoEinterface. Creating/deleting entries in this table causes corresponding entries for be created/deleted in ifTable/ifXTable/jnxIfTable, and jnxPPPoEIfStatsTable.')
jnxPPPoEIfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: jnxPPPoEIfIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfIfIndex.setDescription('The ifIndex value of the corresponding ifEntry.')
jnxPPPoEIfMaxNumSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65335))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfMaxNumSessions.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfMaxNumSessions.setDescription('The number of sessions allowed on the PPPoEinterface, zero indicates unlimited.')
jnxPPPoEIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfRowStatus.setDescription('Controls creation/deletion of entries in this table with READ-CREATE maximum access, according to the RowStatus textual convention, constrained to support the following values only: createAndGo destroy To create an entry in this table, the following entry objects MUST be explicitly configured: jnxPPPoEIfRowStatus jnxPPPoEIfLowerIfIndex In addition, when creating an entry the following conditions must hold: A value for jnxPPPoEIfIndex must have been determined previously, by reading jnxPPPoENextIfIndex. The interface identified by jnxPPPoEIfLowerIfIndex must exist, and must be an interface type that permits layering of PPPoEabove it. A corresponding entry in ifTable/ifXTable/jnxIfTable is created or destroyed as a result of creating or destroying an entry in this table. The following values can be read from this object: active(1)')
jnxPPPoEIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLowerIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLowerIfIndex.setDescription('The ifIndex of an interface over which this PPPoEinterface is to be layered. A value of zero indicates no layering. An implementation may choose to require that a nonzero value be configured at entry creation.')
jnxPPPoEIfAcName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfAcName.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfAcName.setDescription('The name to use for the AC-NAME tag that is sent in any PADO that is sent on this interface.')
jnxPPPoEIfDupProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfDupProtect.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfDupProtect.setDescription('Flag to allow duplicate MAC addresses.')
jnxPPPoEIfPADIFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfPADIFlag.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfPADIFlag.setDescription('This flag controls whether we always respond to a PADI with a PADO regardless of the ability to create the session and allows the session establish phase to resolve it.')
jnxPPPoEIfAutoconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfAutoconfig.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfAutoconfig.setDescription('This flags determines whether the upper PPPoEinterface is created dynamically or statically. When enable(1) the interface is created dynamically.')
jnxPPPoEIfServiceNameTable = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfServiceNameTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfServiceNameTable.setDescription('Associate a PPPoEService Name Table with this interface for PADI processing.')
jnxPPPoEIfPadrRemoteCircuitIdCapture = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfPadrRemoteCircuitIdCapture.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfPadrRemoteCircuitIdCapture.setDescription('This flags determines whether the remote circuit id string will be captured and subsequently used as the NAS-PORT-ID radius attribute when it arrives as a tag in the PADR packet.')
jnxPPPoEIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(66, 65535), )).clone(1494)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfMtu.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfMtu.setDescription('The initial Maximum Transmit Unit (MTU) that the PPPoEmajor interface entity will advertise to the remote entity. If the value of this variable is 1 then the local PPPoEentity will use an MTU value determined by its underlying media interface. If the value of this variable is 2 then the local PPPoEentity will use a value determined by the PPPoEMax-Mtu-Tag transmitted from the client in the PADR packet. If no Max-Mtu-Tag is received, the value defaults to a maximum of 1494. The operational MTU is limited by the MTU of the underlying media interface minus the PPPoEframe overhead.')
jnxPPPoEIfLockoutMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMin.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMin.setDescription("The lower bound, in seconds, of the time range used to specify the duration of the lockout of the client from recognition for the specified interface. This only takes effect if jnxPPPoEIfAutoconfig is set for this interface. The ability to lockout the client in the event of an error in creating a PPP interface is enabled by default. The initial lockout duration is this object's value and increases exponentially for each failure that occurs for the client creating a PPP interface for the PPPoEinterface within the greater of 15 minutes and jnxPPPoEIfLockoutMax. The lockout duration for the client will not exceed jnxPPPoEIfLockoutMax. If the time between creation errors for the PPP interface for this interface is greater than the greater of 15 minutes and jnxPPPoEIfLockoutMax, then the lockout duration reverts to this object's value. To disable the ability to lockout the client from recognition in the event of an error in creating a PPP interface for the specified interface, the value of this object and jnxPPPoEIfLockoutMin must be set to 0. It is not recommended that this lockout feature be disabled except for debugging purposes or when this interface supports more than one session.")
jnxPPPoEIfLockoutMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMax.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMax.setDescription("The upper bound, in seconds, of the time range used to specify the duration of the lockout of the client from recognition for the specified interface. This only takes effect if jnxPPPoEIfAutoconfig is set for this interface. The ability to lockout the client from recognition in the event of an error in creating a PPP interface is enabled by default. The initial lockout duration is jnxPPPoEIfLockoutMin and increases exponentially for each failure that occurs for the client interface within the greater of 15 minutes and this object's value. The lockout duration for the client will not exceed jnxPPPoEIfLockoutMax. If the time between creation errors for the PPP interface for this interface is greater than the greater of 15 minutes and jnxPPPoEIfLockoutMax, then the lockout duration reverts to jnxPPPoEIfLockoutMin. To disable the ability to lockout the client from recognition in the event of an error in creating a PPP interface for the specified interface, the value of this object and jnxPPPoEIfLockoutMin must be set to 0. It is not recommended that this lockout feature be disabled except for debugging purposes or when this interface supports more than one session.")
jnxPPPoEIfDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 14), DisplayString().clone(' ')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfDynamicProfile.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfDynamicProfile.setDescription('Attach dynamic-profile to this interface')
jnxPPPoEIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3), )
if mibBuilder.loadTexts: jnxPPPoEIfStatsTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTable.setDescription('The statistics for the PPP over Ethernet Interface for the PPPoE service on this interface.')
jnxPPPoEIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"))
if mibBuilder.loadTexts: jnxPPPoEIfStatsEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsEntry.setDescription('The statistics for a particular PPPoEInterface.')
jnxPPPoEIfStatsRxPADI = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADI.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADI.setDescription('Number of PADI packets received.')
jnxPPPoEIfStatsTxPADO = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADO.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADO.setDescription('Number of PADO packets transmitted.')
jnxPPPoEIfStatsRxPADR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADR.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADR.setDescription('Number of PADR packets received.')
jnxPPPoEIfStatsTxPADS = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADS.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADS.setDescription('Number of PADS packets transmitted.')
jnxPPPoEIfStatsRxPADT = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADT.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADT.setDescription('Number of PADT packets received.')
jnxPPPoEIfStatsTxPADT = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADT.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADT.setDescription('Number of PADT packets transmitted.')
jnxPPPoEIfStatsRxInvVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvVersion.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvVersion.setDescription('Number of packets received with invalid version.')
jnxPPPoEIfStatsRxInvCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvCode.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvCode.setDescription('Number of packets received with invalid code.')
jnxPPPoEIfStatsRxInvTags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTags.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTags.setDescription('Number of packets received with invalid tags.')
jnxPPPoEIfStatsRxInvSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvSession.setStatus('obsolete')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvSession.setDescription('Number of packets received with invalid session identifiers. This object became obsolete when separate counters were added for PADI and PADR packets.')
jnxPPPoEIfStatsRxInvTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTypes.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTypes.setDescription('Number of packets received with invalid types.')
jnxPPPoEIfStatsRxInvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPackets.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPackets.setDescription('Number of invalid packets received.')
jnxPPPoEIfStatsRxInsufficientResources = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInsufficientResources.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInsufficientResources.setDescription('Number of session requests that could not be honored due to invalid resources.')
jnxPPPoEIfStatsTxPADM = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADM.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADM.setDescription('Number of PADM packets transmitted.')
jnxPPPoEIfStatsTxPADN = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADN.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADN.setDescription('Number of PADN packets transmitted.')
jnxPPPoEIfStatsRxInvTagLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTagLength.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTagLength.setDescription('Number of packets received with invalid tag length.')
jnxPPPoEIfStatsRxInvLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvLength.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvLength.setDescription('Number of packets received with invalid length.')
jnxPPPoEIfStatsRxInvPadISession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadISession.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadISession.setDescription('Number of PADI packets received with invalid session identifiers.')
jnxPPPoEIfStatsRxInvPadRSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadRSession.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadRSession.setDescription('Number of PADR packets received with invalid session identifiers.')
jnxPPPoEIfLockoutTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4), )
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTable.setDescription('The lockout configuration and state of a PPPoEclient on this interface.')
jnxPPPoEIfLockoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"), (0, "JNX-PPPOE-MIB", "jnxPPPoEIfLockoutClientAddress"))
if mibBuilder.loadTexts: jnxPPPoEIfLockoutEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutEntry.setDescription('Each entry contains the configuration and state of a particular PPPoEinterface client lockout.')
jnxPPPoEIfLockoutClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 1), MacAddress())
if mibBuilder.loadTexts: jnxPPPoEIfLockoutClientAddress.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutClientAddress.setDescription('The source MAC address if the client.')
jnxPPPoEIfLockoutTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTime.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTime.setDescription('The time duration, in seconds, currently used to lockout the specified encapsulation type from recognition for the specified interface. The reported value is within the range specified by jnxPPPoEIfLockoutMin and jnxPPPoEIfLockoutMax. A value of 0 indicates that no lockout is occurring for the encapsulation type for the specified interface.')
jnxPPPoEIfLockoutElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutElapsedTime.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutElapsedTime.setDescription('The elapsed time, in seconds, that the specified encapsulation type has been locked-out from recognition for the specified interface. Its value will not exceed that of jnxPPPoEIfLockoutTime. A value of 0 indicates that no lockout is occurring for the encapsulation type for the specified interface.')
jnxPPPoEIfLockoutNextTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutNextTime.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEIfLockoutNextTime.setDescription('The time duration, in seconds, that will be used to lockout the specified encapsulation type from recognition for the specified interface for the next event that results in a lockout condition. The reported value is within the range specified by jnxPPPoEIfLockoutMin and jnxPPPoEIfLockoutMax. When jnxPPPoEIfEnable is set to enable, a value of 0 indicates that lockout is prevented from occurring for the encapsulation type for the specified interface (i.e., jnxPPPoEIfLockoutMin and jnxPPPoEIfLockoutMax are both set to 0).')
jnxPPPoESubIfNextIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfNextIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfNextIfIndex.setDescription('Coordinate ifIndex value allocation for entries in jnxPPPoESubIfTable. A GET of this object returns the next available ifIndex value to be used to create an entry in the associated interface table; or zero, if no valid ifIndex value is available. This object also returns a value of zero when it is the lexicographic successor of a varbind presented in an SNMP GETNEXT or GETBULK request, for which circumstance it is assumed that ifIndex allocation is unintended. Successive GETs will typically return different values, thus avoiding collisions among cooperating management clients seeking to create table entries simultaneously.')
jnxPPPoESubIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2), )
if mibBuilder.loadTexts: jnxPPPoESubIfTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfTable.setDescription('This table contains entries for PPPoESubinterfaces present in the system.')
jnxPPPoESubIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoESubIfIndex"))
if mibBuilder.loadTexts: jnxPPPoESubIfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfEntry.setDescription('Each entry describes the characteristics of a PPPoESubinterface. With READ-CREATE maximum access ,creating/deleting entries in this table causes corresponding entries for be created /deleted in ifTable/ifXTable/jnxIfTable.')
jnxPPPoESubIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: jnxPPPoESubIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfIndex.setDescription('The ifIndex of the PPPoESubinterface. When creating entries in this table, suitable values for this object are determined by reading jnxPPPoESubNextIfIndex.')
jnxPPPoESubIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfRowStatus.setDescription('Controls creation/deletion of entries in this table with READ-CREATE maximum access ,according to the RowStatus textual convention, constrained to support the following values only: createAndGo destroy To create an entry in this table, the following entry objects MUST be explicitly configured: jnxPPPoESubIfRowStatus jnxPPPoESubIfLowerIfIndex In addition, when creating an entry the following conditions must hold: A value for jnxPPPoESubIfIndex must have been determined previously, by reading jnxPPPoESubIfNextIfIndex. The interface identified by jnxPPPoESubIfLowerIfIndex must exist, and must be a PPPoEinterface. A positive value configured for jnxPPPoESubIfId must not already be assigned to another subinterface layered onto the same underlying PPPoEinterface. A corresponding entry in ifTable/ifXTable/jnxIfTable is created or destroyed as a result of creating or destroying an entry in this table. The following values can be read from this object: active(1) ')
jnxPPPoESubIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfLowerIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfLowerIfIndex.setDescription('The ifIndex of a PPPoEinterface over which this PPPoESubinterface is to be layered. A value of zero indicates no layering. An implementation may choose to require that a nonzero value be configured at entry creation.')
jnxPPPoESubIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfId.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfId.setDescription('An integer identifier for the PPPoEsubinterface, used in conjunction with the command-line interface. It is provided here for cross-reference purposes only. The value must be unique among subinterfaces configured on the same underlying PPPoEinterface. If this object is not configured, or is configured with a value of -1, a nonzero value will be allocated internally and can be retrieved from this object after table entry creation has succeeded. A value of zero for this object is reserved for future use.')
jnxPPPoESubIfSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfSessionId.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfSessionId.setDescription('The current sessionId associated with this sub-interface.')
jnxPPPoESubIfMotm = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfMotm.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfMotm.setDescription('A message to send via a PADM on the sub-interface when the sub-interface transitions to the ifOperStatusUp state. The client may choose to display this message to the user.')
jnxPPPoESubIfUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfUrl.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESubIfUrl.setDescription('A URL to be sent via a PADM on the sub-interface when the sub-interface transitions to the ifOperStatusUp state. The client may use this URL as the initial web-page for the user.')
jnxPppoeSubIfQueueStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3), )
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsTable.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsTable.setDescription('Table containing the Queue parameters for the PPPoEsessions.')
jnxPppoeSubIfPerQueueStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoESubIfIndex"), (0, "JNX-PPPOE-MIB", "jnxPppoeSubIfQueueIndex"))
if mibBuilder.loadTexts: jnxPppoeSubIfPerQueueStatsEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfPerQueueStatsEntry.setDescription('The statistics for a particular trrafic class queue for PPPoEsub Interface(i.e. session). ). Forwarding class to queue number mapping is not always one-to-one. Forwarding classes and queues are the same only when default forwarding-class-to-queue mapping is in effect ')
jnxPppoeSubIfQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: jnxPppoeSubIfQueueIndex.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueIndex.setDescription('This attribute returns the queue index ranging from 0 to 7 of the queue configure on the PPPoEsubinterface to support the traffic class for PPPoEsession configured on that subinterface. Forwarding class to queue number mapping is not always one-to-one. Forwarding classes and queues are the same only when default forwarding-class-to-queue mapping is in effect.')
jnxPppoeSubIfQueueStatsPacketSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketSent.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketSent.setDescription('This attribute returns the counts of number of packet sent per PPPoEsession and per queue.')
jnxPppoeSubIfQueueStatsBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesSent.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesSent.setDescription('This attribute returns the counts of number of bytes sent per PPPoEsession and per queue.')
jnxPppoeSubIfQueueStatsPacketDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketDropped.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketDropped.setDescription('This attribute returns the number of packet dropped per PPPoEsession and per queue.')
jnxPppoeSubIfQueueStatsBytesDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesDropped.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesDropped.setDescription('This attribute returns the number of bytes dropped per PPPoEsession and per queue.')
jnxPppoeSubIfQueueStatsActualBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualBitRate.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualBitRate.setDescription('This attribute returns the actual bit rate for per PPPoEsession and per queue.')
jnxPppoeSubIfQueueStatsActualDroppedBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualDroppedBitRate.setStatus('current')
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualDroppedBitRate.setDescription('This attribute returns the actual dropped bit rate for per PPPoEsession and per queue.')
jnxPPPoEServiceNameTableTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1), )
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableTable.setDescription('This table contains entries for the PPPoEService-name tables.')
jnxPPPoEServiceNameTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableEntry.setDescription('The parameters for the PPPoEservice-name table.')
jnxPPPoEServiceNameTableName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableName.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableName.setDescription('Service-name table name.')
jnxPPPoEServiceNameTableRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableRowStatus.setDescription('Controls creation/deletion of entries in this table with READ-CREATE maximum access,according to the RowStatus textual convention, constrained to support the following values only: createAndGo destroy To create an entry in this table, the following entry objects MUST be explicitly configured: jnxPPPoEServiceNameTableRowStatus jnxPPPoEServiceNameTableName The Empty Service and Any service will be automatically configured for each Service Name Table created. On creating or deleting an entry in this table will create/destroy an entry for <Empty >Service and <Any> service in jnxServiceNameTable. A corresponding entry in jnxServiceNameTable gets created or destroyed as a result of creating or destroying an entry in this table. The following values can be read from this object: active(1) ')
jnxPPPoEServiceNameTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2), )
if mibBuilder.loadTexts: jnxPPPoEServiceNameTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameTable.setDescription('This table contains entries for the PPPoEService-names.')
jnxPPPoEServiceNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceName"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameEntry.setDescription('The parameters for the PPPoEservice-name table entry.')
jnxPPPoEServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: jnxPPPoEServiceName.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceName.setDescription('Service-name tag value.')
jnxPPPoEServiceNameAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 2), JnxPPPoEServiceNameAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAction.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAction.setDescription('Identifies the behavior when the the Service-name tag is received in a PADI frame.')
jnxPPPoEServiceNameDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameDynamicProfile.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameDynamicProfile.setDescription('Dynamic Profile associated with a Service-name.')
jnxPPPoEServiceNameRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameRoutingInstance.setDescription('Routing Instance associated with a Service-name.')
jnxPPPoEServiceNameMaxSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameMaxSessions.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameMaxSessions.setDescription('The Max Sessions value used to cap the number of active PPPoEssessions that may be established with the specified Service entry.')
jnxPPPoEServiceNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 6), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameRowStatus.setDescription('Controls creation/deletion of entries in this table with READ-CREATE maximum access ,according to the RowStatus textual convention, constrained to support the following values only: createAndGo destroy To create an entry in this table, the following entry objects MUST be explicitly configured: jnxPPPoEServiceNameRowStatus The Service name is configured via the INDEX specified. A corresponding entry in jnxPPPoEServiceNameAciAriTable is destroyed as a result of destroying an entry in this table. The following values can be read from this object: active(1)')
jnxPPPoEServiceNameAciAriTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3), )
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriTable.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriTable.setDescription('This table contains entries for the PPPoEServicename AciAri entries.')
jnxPPPoEServiceNameAciAriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1), ).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameAgentCircuitId"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameAgentRemoteId"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriEntry.setDescription('The parameters for the PPPoEservice-name AciAri table entry.')
jnxPPPoEServiceNameAgentCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)))
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentCircuitId.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentCircuitId.setDescription('ACI tag values that the PPPoEclient would send in the PADI/PADR control packet.')
jnxPPPoEServiceNameAgentRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)))
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentRemoteId.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentRemoteId.setDescription('ACI tag values that the PPPoEclient would send in the PADI/PADR control packet.')
jnxPPPoEServiceNameAciAriAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 3), JnxPPPoEServiceNameAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriAction.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriAction.setDescription('Identifies the behavior when the the Service-name with ACI/ARI pairs is received in a PADI frame.')
jnxPPPoEServiceNameAciAriDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriDynamicProfile.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriDynamicProfile.setDescription('Dynamic Profile associated with a Service-name and ACI/ARI pairs')
jnxPPPoEServiceNameAciAriRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRoutingInstance.setDescription('Routing-Instance associated with a Service-name and ACI/ARI pairs')
jnxPPPoEServiceNameAciAriStaticInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriStaticInterface.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriStaticInterface.setDescription('Static Interface associated with each ACI/ARI Entry.')
jnxPPPoEServiceNameAciAriRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 7), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRowStatus.setDescription('Controls creation/deletion of entries in this table with READ-CREATE maximum access, according to the RowStatus textual convention, constrained to support the following values only: createAndGo destroy To create an entry in this table, the following entry objects MUST be explicitly configured: jnxPPPoEServiceNameAciAriRowStatus The ACIARI Entry is configured via the INDEX specified. The following values can be read from this object: active(1)')
jnxPPPoEMajorInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEMajorInterfaceCount.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoEMajorInterfaceCount.setDescription('The total number of PPPoEmajor interfaces configured and created in the system.')
jnxPPPoESummaryMajorIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminUp.setReference('ifAdminStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminUp.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminUp.setDescription('The total number of PPPoEmajor interfaces in the system that are administratively configured to up(1).')
jnxPPPoESummaryMajorIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminDown.setReference('ifAdminStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminDown.setDescription('The total number of PPPoEmajor interfaces in the system that are administrateively configued to down(2).')
jnxPPPoESummaryMajorIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperUp.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperUp.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperUp.setDescription('The total number of PPPoEmajor interfaces in the system with an operational state of up(1).')
jnxPPPoESummaryMajorIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperDown.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperDown.setDescription('The total number of PPPoEmajor interfaces in the system with an operational state of down(2).')
jnxPPPoESummaryMajorIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfLowerLayerDown.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfLowerLayerDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfLowerLayerDown.setDescription('The total number of PPPoEmajor interfaces in the system with an operational state of lowerLayerDown(7).')
jnxPPPoESummaryMajorIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfNotPresent.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfNotPresent.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfNotPresent.setDescription('The total number of PPPoEmajor interfaces in the system with an operational state of notPresent(6).')
jnxPPPoESummarySubInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubInterfaceCount.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubInterfaceCount.setDescription('The total number of PPPoEsubinterfaces configured in the system.')
jnxPPPoESummarySubIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminUp.setReference('ifAdminStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminUp.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminUp.setDescription('The total number of PPPoEsubinterfaces in the system that are administratively configured to up(1).')
jnxPPPoESummarySubIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminDown.setReference('ifAdminStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminDown.setDescription('The total number of PPPoEsubinterfaces in the system that are administrateively configued to down(2).')
jnxPPPoESummarySubIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperUp.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperUp.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperUp.setDescription('The total number of PPPoEsubinterfaces in the system with an operational state of up(1).')
jnxPPPoESummarySubIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperDown.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperDown.setDescription('The total number of PPPoEsubinterfaces in the system with an operational state of down(2).')
jnxPPPoESummarySubIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfLowerLayerDown.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfLowerLayerDown.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfLowerLayerDown.setDescription('The total number of PPPoEsubinterfaces in the system with an operational state of lowerLayerDown(7).')
jnxPPPoESummarySubIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfNotPresent.setReference('ifOperStatus from IF-MIB')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfNotPresent.setStatus('current')
if mibBuilder.loadTexts: jnxPPPoESummarySubIfNotPresent.setDescription('The total number of PPPoEsubinterfaces in the system with an operational state of notPresent(6).')
jnxPPPoEConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4))
jnxPPPoECompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4, 1))
jnxPPPoEGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4, 2))
mibBuilder.exportSymbols("JNX-PPPOE-MIB", jnxPPPoEIfStatsRxInsufficientResources=jnxPPPoEIfStatsRxInsufficientResources, jnxPPPoEServiceNameAciAriTable=jnxPPPoEServiceNameAciAriTable, jnxPPPoEGroups=jnxPPPoEGroups, jnxPPPoEIfLockoutClientAddress=jnxPPPoEIfLockoutClientAddress, jnxPPPoEIfStatsRxInvVersion=jnxPPPoEIfStatsRxInvVersion, jnxPPPoESummarySubIfAdminUp=jnxPPPoESummarySubIfAdminUp, jnxPPPoESubIfLayer=jnxPPPoESubIfLayer, jnxPPPoEServiceNameTableName=jnxPPPoEServiceNameTableName, jnxPPPoEIfStatsTxPADN=jnxPPPoEIfStatsTxPADN, jnxPPPoESummaryMajorIfLowerLayerDown=jnxPPPoESummaryMajorIfLowerLayerDown, jnxPPPoEIfStatsRxInvSession=jnxPPPoEIfStatsRxInvSession, jnxPPPoESummarySubIfOperUp=jnxPPPoESummarySubIfOperUp, jnxPPPoEIfLockoutMin=jnxPPPoEIfLockoutMin, jnxPPPoEIfLockoutNextTime=jnxPPPoEIfLockoutNextTime, jnxPppoeSubIfQueueStatsActualDroppedBitRate=jnxPppoeSubIfQueueStatsActualDroppedBitRate, jnxPPPoEServiceNameAciAriEntry=jnxPPPoEServiceNameAciAriEntry, jnxPPPoEIfPadrRemoteCircuitIdCapture=jnxPPPoEIfPadrRemoteCircuitIdCapture, jnxPPPoEIfIfIndex=jnxPPPoEIfIfIndex, jnxPppoeSubIfQueueStatsBytesSent=jnxPppoeSubIfQueueStatsBytesSent, jnxPPPoEServiceNameRoutingInstance=jnxPPPoEServiceNameRoutingInstance, jnxPPPoEIfRowStatus=jnxPPPoEIfRowStatus, jnxPPPoESummaryMajorIfOperUp=jnxPPPoESummaryMajorIfOperUp, jnxPppoeSubIfQueueStatsPacketSent=jnxPppoeSubIfQueueStatsPacketSent, PYSNMP_MODULE_ID=jnxPPPoEMIB, jnxPppoeSubIfQueueStatsPacketDropped=jnxPppoeSubIfQueueStatsPacketDropped, jnxPPPoEServiceName=jnxPPPoEServiceName, jnxPPPoESummarySubIfAdminDown=jnxPPPoESummarySubIfAdminDown, jnxPPPoEIfServiceNameTable=jnxPPPoEIfServiceNameTable, jnxPPPoESummaryMajorIfNotPresent=jnxPPPoESummaryMajorIfNotPresent, jnxPPPoEIfStatsRxPADT=jnxPPPoEIfStatsRxPADT, jnxPPPoEServiceNameTable=jnxPPPoEServiceNameTable, jnxPppoeSubIfQueueStatsActualBitRate=jnxPppoeSubIfQueueStatsActualBitRate, jnxPPPoEIfStatsTable=jnxPPPoEIfStatsTable, jnxPPPoEIfStatsRxInvPadRSession=jnxPPPoEIfStatsRxInvPadRSession, jnxPPPoESubIfRowStatus=jnxPPPoESubIfRowStatus, jnxPPPoEIfMtu=jnxPPPoEIfMtu, jnxPPPoESubIfMotm=jnxPPPoESubIfMotm, jnxPPPoEIfLockoutEntry=jnxPPPoEIfLockoutEntry, jnxPPPoEServiceNameTableRowStatus=jnxPPPoEServiceNameTableRowStatus, jnxPPPoESubIfId=jnxPPPoESubIfId, jnxPPPoEIfStatsRxPADR=jnxPPPoEIfStatsRxPADR, jnxPPPoESummarySubIfLowerLayerDown=jnxPPPoESummarySubIfLowerLayerDown, jnxPPPoEIfStatsRxInvTagLength=jnxPPPoEIfStatsRxInvTagLength, jnxPPPoEServiceNameAciAriRoutingInstance=jnxPPPoEServiceNameAciAriRoutingInstance, jnxPPPoEIfStatsRxInvTypes=jnxPPPoEIfStatsRxInvTypes, jnxPPPoEIfLayer=jnxPPPoEIfLayer, jnxPPPoEObjects=jnxPPPoEObjects, jnxPppoeSubIfQueueStatsTable=jnxPppoeSubIfQueueStatsTable, jnxPPPoEIfStatsEntry=jnxPPPoEIfStatsEntry, jnxPPPoESubIfSessionId=jnxPPPoESubIfSessionId, jnxPPPoESummarySubInterfaceCount=jnxPPPoESummarySubInterfaceCount, jnxPPPoESummarySubIfOperDown=jnxPPPoESummarySubIfOperDown, jnxPPPoESummaryMajorIfOperDown=jnxPPPoESummaryMajorIfOperDown, jnxPPPoEServiceNameAgentRemoteId=jnxPPPoEServiceNameAgentRemoteId, jnxPppoeSubIfQueueIndex=jnxPppoeSubIfQueueIndex, jnxPPPoEIfLockoutTable=jnxPPPoEIfLockoutTable, jnxPPPoESubIfTable=jnxPPPoESubIfTable, jnxPPPoESummary=jnxPPPoESummary, jnxPPPoEIfLowerIfIndex=jnxPPPoEIfLowerIfIndex, jnxPPPoEIfStatsRxInvPadISession=jnxPPPoEIfStatsRxInvPadISession, jnxPPPoEIfStatsTxPADM=jnxPPPoEIfStatsTxPADM, jnxPPPoEIfLockoutMax=jnxPPPoEIfLockoutMax, jnxPPPoEIfDupProtect=jnxPPPoEIfDupProtect, jnxPPPoEIfStatsRxPADI=jnxPPPoEIfStatsRxPADI, jnxPPPoEServiceNameMaxSessions=jnxPPPoEServiceNameMaxSessions, jnxPPPoEIfEntry=jnxPPPoEIfEntry, jnxPPPoEIfAcName=jnxPPPoEIfAcName, jnxPPPoEServices=jnxPPPoEServices, jnxPPPoEMIB=jnxPPPoEMIB, jnxPPPoEServiceNameDynamicProfile=jnxPPPoEServiceNameDynamicProfile, jnxPPPoEConformance=jnxPPPoEConformance, jnxPPPoEIfLockoutTime=jnxPPPoEIfLockoutTime, jnxPPPoESubIfEntry=jnxPPPoESubIfEntry, jnxPPPoEIfMaxNumSessions=jnxPPPoEIfMaxNumSessions, jnxPPPoESubIfLowerIfIndex=jnxPPPoESubIfLowerIfIndex, jnxPPPoEIfTable=jnxPPPoEIfTable, jnxPPPoECompliances=jnxPPPoECompliances, jnxPPPoESubIfIndex=jnxPPPoESubIfIndex, jnxPPPoEIfStatsRxInvTags=jnxPPPoEIfStatsRxInvTags, jnxPPPoEIfPADIFlag=jnxPPPoEIfPADIFlag, jnxPPPoEServiceNameAction=jnxPPPoEServiceNameAction, jnxPPPoEServiceNameTableTable=jnxPPPoEServiceNameTableTable, jnxPPPoEServiceNameAciAriStaticInterface=jnxPPPoEServiceNameAciAriStaticInterface, jnxPPPoEIfStatsTxPADS=jnxPPPoEIfStatsTxPADS, jnxPPPoESummaryMajorIfAdminDown=jnxPPPoESummaryMajorIfAdminDown, jnxPPPoEIfDynamicProfile=jnxPPPoEIfDynamicProfile, JnxPPPoEServiceNameAction=JnxPPPoEServiceNameAction, jnxPPPoEMajorInterfaceCount=jnxPPPoEMajorInterfaceCount, jnxPPPoEIfStatsRxInvLength=jnxPPPoEIfStatsRxInvLength, jnxPPPoEIfStatsTxPADT=jnxPPPoEIfStatsTxPADT, jnxPPPoESubIfNextIfIndex=jnxPPPoESubIfNextIfIndex, jnxPppoeSubIfPerQueueStatsEntry=jnxPppoeSubIfPerQueueStatsEntry, jnxPPPoEServiceNameAgentCircuitId=jnxPPPoEServiceNameAgentCircuitId, jnxPPPoEServiceNameAciAriAction=jnxPPPoEServiceNameAciAriAction, jnxPPPoESummarySubIfNotPresent=jnxPPPoESummarySubIfNotPresent, jnxPPPoEIfStatsRxInvCode=jnxPPPoEIfStatsRxInvCode, jnxPPPoEServiceNameAciAriDynamicProfile=jnxPPPoEServiceNameAciAriDynamicProfile, jnxPPPoEServiceNameTableEntry=jnxPPPoEServiceNameTableEntry, jnxPPPoEIfAutoconfig=jnxPPPoEIfAutoconfig, jnxPPPoESubIfUrl=jnxPPPoESubIfUrl, jnxPPPoENextIfIndex=jnxPPPoENextIfIndex, jnxPPPoEIfLockoutElapsedTime=jnxPPPoEIfLockoutElapsedTime, jnxPPPoEIfStatsTxPADO=jnxPPPoEIfStatsTxPADO, jnxPppoeSubIfQueueStatsBytesDropped=jnxPppoeSubIfQueueStatsBytesDropped, jnxPPPoEIfStatsRxInvPackets=jnxPPPoEIfStatsRxInvPackets, jnxPPPoESummaryMajorIfAdminUp=jnxPPPoESummaryMajorIfAdminUp, jnxPPPoEServiceNameRowStatus=jnxPPPoEServiceNameRowStatus, jnxPPPoEServiceNameEntry=jnxPPPoEServiceNameEntry, jnxPPPoEServiceNameAciAriRowStatus=jnxPPPoEServiceNameAciAriRowStatus)

#
# PySNMP MIB module CXMCVOX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXMCVOX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:33:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
cxModuleHwPhysSlot, = mibBuilder.importSymbols("CXModuleHardware-MIB", "cxModuleHwPhysSlot")
cxMc600, = mibBuilder.importSymbols("CXProduct-SMI", "cxMc600")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Counter64, ModuleIdentity, Bits, NotificationType, IpAddress, ObjectIdentity, iso, NotificationType, Integer32, Gauge32, Counter32, MibIdentifier, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "ModuleIdentity", "Bits", "NotificationType", "IpAddress", "ObjectIdentity", "iso", "NotificationType", "Integer32", "Gauge32", "Counter32", "MibIdentifier", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cxMcVox = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2))
cxMcVoxGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1))
cxMcVoxGlobalAdmPathLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmPathLng.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmPathLng.setDescription('obsolete. The ReinitNet/ReinitPath commands have been replaced by ReinitRouting.')
cxMcVoxGlobalReinitPath = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalReinitPath.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxGlobalReinitPath.setDescription('The ReinitNet/ReinitPath commands have been replaced by ReinitRouting. ')
cxMcVoxGlobalClearPath = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearPath.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGlobalClearPath.setDescription("Path ID no longer exists with the new voice routing scheme Determines whether to restore all administrative Path IDs to the default factory settings. The setting of this object is dynamic. When set to 'yes' all administrative Path IDs will immediately change to the factory defaults. Options: no (1) yes (2) Default Value: no (1) Configuration Change: administrative (Voice Routing or VR).")
cxMcVoxGlobalReinitNet = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalReinitNet.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxGlobalReinitNet.setDescription('The ReinitNet/ReinitPath commands have been replaced by ReinitRouting.')
cxMcVoxGlobalClearNet = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearNet.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGlobalClearNet.setDescription("Network ID no longer exists in the new voice routing scheme (Voice Routing or VR). Determines whether to restore all administrative routing entries (i.e. network routing entries, Path IDs and Group IDs) to the default factory settings. The setting of this object is dynamic. When set to 'yes' all administrative routing entries will immediately change to the factory defaults. Options: no (1) yes (2) Default Value: no (1) Configuration Changed: administrative")
cxMcVoxGlobalAdmLocalId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone('          ')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmLocalId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmLocalId.setDescription('Determines the administrative ID (name) for the local voice station. Note: This object must be defined in order to obtain a successful voice connection. Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none Configuration Changed: administrative')
cxMcVoxGlobalOpeLocalId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpeLocalId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalOpeLocalId.setDescription('Displays the operative ID (name) for the local voice station. Note: This object must be defined in order to obtain a successful voice connection. You cannot modify this object. If you want to change the ID you must modify the object cxMcVoxGlobalAdmLocalId (of this table). Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none')
cxMcVoxGlobalTensionRing = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalTensionRing.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalTensionRing.setDescription('Displays the state of the ring generator power supply. The power supply resides on the ring generator card located on the voice I/O card. You cannot modify this object. Options: down (1) up (2) Default Value: none')
cxMcVoxGlobalTensionDc = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalTensionDc.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalTensionDc.setDescription('Displays the state of the DC power supply on the voice I/O card. Options: down (1): The DC power supply on the voice I/O card is down. up (2):The DC power supply on the voice I/O card is up. Default Value: none')
cxMcVoxGlobalTrapRing = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalTrapRing.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalTrapRing.setDescription("Determines if the ring generator power supply trap is generated. The setting of this object is dynamic. When set to 'enable', the SNMP agent immediately begins to monitor the ring generator power supply. Options: disable (1): No trap is generated. enable (2): Causes a trap message to be sent to the network management console each time a change occurs in the functional state (i.e., up or down) of the ring generator power supply. Default Value: disable (1) Configuration Changed: operative")
cxMcVoxGlobalTrapDc = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalTrapDc.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalTrapDc.setDescription("Determines if the DC power supply trap is generated. The setting of this object is dynamic. When set to 'enable', the SNMP agent immediately begins to monitor the DC power supply. Options: disable (1): No trap is generated. enable (2): Causes a trap message to be sent to the network management consoleto each time a change occurs in the functional state (i.e., up or down) of the voice I/O card DC power supply. Default Value: disable (1) Configuration Changed: operative")
cxMcVoxGlobalAdmGrpNbPoll = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmGrpNbPoll.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmGrpNbPoll.setDescription('The maximum number of remote voice station(s) that the the local voice station polls within a single call request has been moved from the Global Parameters group to the Group ID Entries group. Determines the maximum number of remote voice stations that the local voice station polls with a single call request. Note: This object is only relevant if at least one Group ID has been defined using the objects in the cxMcVox Administrative Grp Group. Range of Values: 1 to 20 Default Value: 4 Configuration Changed: administrative')
cxMcVoxGlobalOpeGrpNbPoll = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpeGrpNbPoll.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGlobalOpeGrpNbPoll.setDescription('The the maximum number of remote voice stations the local voice station polls with a single call request. has been moved from the Global Parameters group to the Group ID Entries group. Displays the maximum number of remote voice stations the local voice station polls with a single call request. Note: This object is only relevant if at least one Group ID has been defined with the objects in the cxMcVox Administrative Grp Group Table. You cannot modify this object. If you want to change this value you must modify the object cxMcVoxGlobalAdmNbPoll (of this table). Range of Values: 1 to 20 Default Value: 4')
cxMcVoxGlobalClearGrp = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearGrp.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalClearGrp.setDescription("Determines whether to restore all administrative Group IDs to the default factory settings. The setting of this object is dynamic. When set to 'yes' all administrative Group IDs will immediately change to the factory defaults. Options: no (1) yes (2) Default Value: no Configuration Changed: administrative")
cxMcVoxGlobalOpePathLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpePathLng.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxGlobalOpePathLng.setDescription('The Operational Path Length commands are now in the Operational Path table.')
cxMcVoxGlobalReinitRouting = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalReinitRouting.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalReinitRouting.setDescription("Triggers the reinitialization of the operative routing table. The setting of this object is dynamic. When set to 'yes', all administrative routing, path and group entries will be written to the operative routing table (i.e. will be in the active global configuration). Options: no (1) yes (2) Default Value: no (1) Configuration Changed: operative")
cxMcVoxGlobalForceDefConfig = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalForceDefConfig.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalForceDefConfig.setDescription("Determines whether the default factory configuration will replace both the administrative and operative configurations. The setting of this object is dynamic. When set to 'yes', this object triggers the immediate reconfiguration of all objects to the default factory settings. Options: no (1) yes (2) Default Value: no (1) Configuration Changed: administrative")
cxMcVoxGlobalReinitPinTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalReinitPinTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalReinitPinTable.setDescription("Saves the PIN table configuration in non-volatile memory, but only enables it if the object cxMcVoxGlobalAdmEnablePinTable is set to 'yes'. Options: no (1) yes (2) Default Value: no (1)")
cxMcVoxGlobalAdmEnablePinTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmEnablePinTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmEnablePinTable.setDescription('Specifies whether the voice station verifies PIN (Personal Identification Numbers) codes before allowing a connection to be established. Options: no (1) yes (2) Default Value: no (1)')
cxMcVoxGlobalOpeEnablePinTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpeEnablePinTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalOpeEnablePinTable.setDescription('Displays the operational state of PIN verification. Options: no (1) yes (2) Default Value: no (1)')
cxMcVoxGlobalReinitCodesTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalReinitCodesTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalReinitCodesTable.setDescription('Copy the planned zone code configuration table into active zone code table (non-volatile memory). Options: no (1) yes (2) Default Value: no (1)')
cxMcVoxGlobalAdmEnableCodesTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmEnableCodesTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmEnableCodesTable.setDescription('The CX900 does not currently support this object. Specifies whether the voice station verifies incoming telephone codes against its internal remote translation table. Options: no (1) yes (2) Default Value: no (1)')
cxMcVoxGlobalOpeEnableCodesTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpeEnableCodesTable.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalOpeEnableCodesTable.setDescription('The CX900 does not currently support this object. Displays the operational state of the remote translation table. Options: no (1) yes (2) Default Value: none')
cxMcVoxGlobalSoftRev = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalSoftRev.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalSoftRev.setDescription('Displays the software revision of the local voice station . You cannot modify this object. It is a display that the software provides. Range of Values: a maximum of 30 alphanumeric characters Default Value: none')
cxMcVoxGlobalGlmInBetwReqTime = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmInBetwReqTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmInBetwReqTime.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 2000 Default Value: 500')
cxMcVoxGlobalGlmMaxTimeToTxReq = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 101), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmMaxTimeToTxReq.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmMaxTimeToTxReq.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 20000 Default Value: 1500')
cxMcVoxGlobalGlmInBetwRespTime = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 102), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmInBetwRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmInBetwRespTime.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 20000 Default Value: 500')
cxMcVoxGlobalGlmMaxTimeToTxResp = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 103), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmMaxTimeToTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmMaxTimeToTxResp.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 20000 Default Value: 1500')
cxMcVoxGlobalGlmVoiceSilenceTime = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 104), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 60000)).clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmVoiceSilenceTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmVoiceSilenceTime.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 100 to 60000 Default Value: 3000')
cxMcVoxGlobalGlmSupervSilenceTime = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 105), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 60000)).clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGlmSupervSilenceTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGlmSupervSilenceTime.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 1000 to 60000 Default Value: 3000')
cxMcVoxGlobalGsdAutoCnctDelay = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 106), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalGsdAutoCnctDelay.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalGsdAutoCnctDelay.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 1 to 20000 Default Value: 1')
cxMcVoxGlobalClearLclExt = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 107), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearLclExt.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalClearLclExt.setDescription('Clears Local Extensions after the next Reset. Planned Local Extensions are cleared immediately. Options: no (1): Local Extensions are not cleared. yes (2): Local Extensions are cleared. Default Value: no (1) Configuration Change: administrative')
cxMcVoxGlobalClearRmtExt = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearRmtExt.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGlobalClearRmtExt.setDescription('Clears Remote Extensions after the next Reset. Planned Remote Extensions are cleared immediately. Options: no (1): Remote Extensions are not cleared. yes (2): Remote Extensions are cleared Default Value: no (1) Configuration Change: administrative')
cxMcVoxGlobalWanSlot = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 109), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalWanSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalWanSlot.setDescription('Determines the slot number of the FR600 card that is performing Voice Routing with the new Voice Routing scheme. Range of Values: 1 to 16 Default Value: 1')
cxMcVoxGlobalNetNbDigits = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 110), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalNetNbDigits.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalNetNbDigits.setDescription('Determines the number of digits used to represent Local Extensions, Remote Extensions and Remote Extension group IDs. Range of Values: 1 to 4 Default Value: 3')
cxMcVoxMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 111), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxMibLevel.setDescription('Used to determine current MIB module release supported by the agent. Object is in decimal.')
cxMcVoxGlobalRecogAcc = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 112), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalRecogAcc.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalRecogAcc.setDescription('This specifies whether to recognize the defined Access Code. With the option enabled, if the Access Code is recognized, it is stripped from the dialing digit flow and then the remaining digits are interpreted as the code that has been really dialed.')
cxMcVoxGlobalAccCode = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 113), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5)).clone('011')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAccCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalAccCode.setDescription('Determines the numeric code to access the international network. Range of Values: 1 to 5 numeric digits Default Value: 011 Configuration Changed: operational')
cxMcVoxGlobalAccCodeLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 114), Integer32().clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalAccCodeLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalAccCodeLng.setDescription('Determines the number of digits in the configured Access Code.')
cxMcVoxGlobalAdmPinCodeLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 115), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalAdmPinCodeLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalAdmPinCodeLng.setDescription('Determines the administrative number of digits in all Personal Identification Numbers (PINs).')
cxMcVoxGlobalOpePinCodeLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 116), Integer32().clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGlobalOpePinCodeLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalOpePinCodeLng.setDescription('Determines the operational number of digits in all Personal Identification Numbers (PINs).')
cxMcVoxGlobalClearHistoryTable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 117), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalClearHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalClearHistoryTable.setDescription('Determines whether to clear ALL logging information from the history table. Options: disable(1): No action enable(2): Clear history table completely')
cxMcVoxGlobalHistoryMaxNumberOfEntries = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 118), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 256)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalHistoryMaxNumberOfEntries.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalHistoryMaxNumberOfEntries.setDescription('The maximum number of entries in the history table.')
cxMcVoxGlobalHistoryPercentageFull = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 119), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 95)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalHistoryPercentageFull.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalHistoryPercentageFull.setDescription('The percentage of the history table that must be filled before a trap is sent to the management station.')
cxMcVoxGlobalTrapHistory = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalTrapHistory.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalTrapHistory.setDescription("Determines if the call history trap is generated. The setting of this object is dynamic. When set to 'enable', the SNMP agent immediately begins to monitor the call history trap. Options: disable (1): No trap is generated. enable (2): Causes a trap message to be sent to the network management console each time a change occurs in the functional state (i.e., up or down) of the ring generator power supply. Default Value: disable (1) Configuration Changed: operative")
cxMcVoxGlobalLseTimerT2 = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 121), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalLseTimerT2.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalLseTimerT2.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65535 Default Value: 500')
cxMcVoxGlobalLseTimerT3 = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 122), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(550)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalLseTimerT3.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalLseTimerT3.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65535 Default Value: 550')
cxMcVoxGlobalExtBitMask = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 1, 123), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGlobalExtBitMask.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGlobalExtBitMask.setDescription('This object is a bitmap that selects up to cxMcVoxGlobalNetNbDigits, which can be set up to 4 digits, corresponding to a bit that is set. The default value corresponds to 7 (or 00000111 in binary). Range of Values: 0 to 255 Default Value: 7')
cxMcVoxCfgTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2), )
if mibBuilder.loadTexts: cxMcVoxCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgTable.setDescription('Voice station configuration Table.')
cxMcVoxCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxCfgCardIndex"), (0, "CXMCVOX-MIB", "cxMcVoxCfgPortIndex"))
if mibBuilder.loadTexts: cxMcVoxCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgEntry.setDescription('Voice station configuration row definition.')
cxMcVoxCfgCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxCfgCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgCardIndex.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default Value: none')
cxMcVoxCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxCfgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgPortIndex.setDescription('Displays the number of the voice port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port. CX1000: up to 15 for the DI600 Default Value: none')
cxMcVoxCfgDriverAdmUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("em", 1), ("fxs", 2), ("fxo", 3))).clone('fxs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgDriverAdmUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgDriverAdmUsed.setDescription('Determines the administrative driver of the port. The driver controls which signals the port supports. A port can only support one type of driver at any one time. Depending on the type of driver you choose, you must perform further configuration using one of the following tables: - cxMcVoxEmAdmtable (for E&M drivers) - cxMcVoxFxsAdmTable (for FXS drivers) - cxMcVoxFxoAdmTable (for FXO drivers) Options: em (1): Recommended for a PBX connection. Provides RJ-12 and PB-45 port connectors. fxs (2): Recommended for a standard telephone connection, where the Memotec device simulates a Telco. The device provides the ring and dial tone. FXS can also be used for a PBX connection, and provides an RJ-12 port connector. fxo (3): Recommended for a standard telephone connection, where the Memotec device simulates a telephone. FXO can also be used for a PBX connection, and provides an RJ-12 port connector. Default Value: fxs (2) Configuration Changed: administrative')
cxMcVoxCfgDriverOpeUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("em", 1), ("fxs", 2), ("fxo", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxCfgDriverOpeUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgDriverOpeUsed.setDescription('Displays the operative driver currently running on the port. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxCfgDriverAdmUsed (of this table). Options: em (1) fxs (2) fxo (3) Default Value: fxs (2)')
cxMcVoxCfgTrapOnLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgTrapOnLine.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxCfgTrapOnLine.setDescription("Determines the state of the port's online trap. When set to 'enable', every time a fax or phone call begins (i.e. the port switches from online to offline), the SNMP agent generates a trap and sends it to the network management console. The setting of this object is dynamic. When set to'enable' the SNMP agent immediately begins to monitor the port. Options: disable (1) enable (2) Default Value: disable (1) Configuration Changed: operative")
cxMcVoxCfgTrapOffLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgTrapOffLine.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxCfgTrapOffLine.setDescription("Determines the state of the port's offline trap. When set to 'enable', every time a fax or phone call ends ( i.e. the port switches from offline to online) the SNMP agent generates a trap and sends it to the network management console. The setting of this object is dynamic. When set to'enable' the SNMP agent immediately begins to monitor the port. Options: disable (1) enable (2) Default Value: disable (1) Configuration Changed: operative")
cxMcVoxCfgTrapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgTrapStatus.setDescription("Determines the state of the port's status trap. When set to 'enable', every time the functional state of the voice channel changes (i.e. up or down) the SNMP agent generates a trap and sends it to the network management console. The setting of this object is dynamic. When set to'enable' the SNMP agent immediately begins to monitor the voice channel. Options: disable (1) enable (2) Default Value: disable (1) Configuration Changed: operative")
cxMcVoxCfgTrapState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgTrapState.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxCfgTrapState.setDescription("Determines the state of the port's outgoing calls trap. When set to 'enable', every time an outgoing call request is in process the SNMP agent generates a trap and sends it to the network management console. The setting of this object is dynamic. When set to'enable' the SNMP agent immediately begins to monitor the port. Options: disable (1) enable (2) Default Value: disable (1) Configuration Changed: operative")
cxMcVoxCfgTestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgTestPort.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxCfgTestPort.setDescription("Determines the state of the port's self test. When set to 'yes', this object triggers the port to intiate a self-test. The port examines various hardware components, for example the RAM, DPRAM and I/O access. Each test runs for less than 2 seconds. You can perform the test on either an open (call in progress) or closed channel. If you perform the test on an open channel the call that is in progress is disconnected. The user must place the call again after the test is complete. Note: The port must be set to 'enable' (using the object cxMcVoxEmAdmPortStatus, cxMcVoxFxoAdmstatus or cxMcVoxFxsAdmStatus) to be able to perform the self-test. You can view the results of the test in the cxMcVoxStatusTable. While the port is running a self-test, it is not functional. It will return to normal when the test is complete. The setting of this object is dynamic. When set to'yes' the port immediately begins to monitor itself. Options: no (1) yes (2) Default Value: no (1) Configuration Changed: operative ")
cxMcVoxCfgToneTest = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgToneTest.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgToneTest.setDescription("Determines the state of the port's standard tone test (1004Hz). When set to 'enable', this object triggers the port to perform a tone test. The port tests its voice sound quality by transmitting a 1004Hz tone. You can perform the test on either an open (call in progress) or closed channel. However, if you initiate the test on an open channel, the connection is not disrupted, but the local user will not be able to hear the remote user. The local user will only hear the tone the test generates. You must set this object to 'disable' to stop the test. It does not stop on its own. The setting of this object is dynamic. When set to'enable' the tone test begins immediately. Options: disable (1) enable (2) Default Value: disable (1) Configuration Changed: operative")
cxMcVoxCfgReinitPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgReinitPort.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxCfgReinitPort.setDescription("Determines the port's reinitialization state. The setting of this object is dynamic. When set to 'yes', this object triggers the port to write all administrative port configuration entries to the operative port configuration table (i.e. they will be in the active port configuration). Options: no (1) yes (2) Default Value: no (1) Configuration Changed: administrative")
cxMcVoxCfgClearPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgClearPort.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxCfgClearPort.setDescription("Determines whether to restore all administrative voice port configurations to the default factory settings. The setting of this object is dynamic. When set to 'yes' the configuration of the administrative voice port (as displays in the objects cxMcVoxCfgCardIndex and cxMcVoxCfgPortIndex) will immediately change to the factory defaults. Options: no (1) yes (2) Default Value: no (1) Configuration Changed: administrative")
cxMcVoxCfgOpeAcelpRev = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxCfgOpeAcelpRev.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxCfgOpeAcelpRev.setDescription('Displays the ACELP software revision currently running on the operative voice channel. Range of Values: 0 to 12 alphanumeric characters. You can use any combination of letters and numbers, however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: ACELP-2.BIN')
cxMcVoxCfgCmdImmTest = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgCmdImmTest.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgCmdImmTest.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 4294967295 Default Value: 0')
cxMcVoxCfgCmdTest = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgCmdTest.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgCmdTest.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 4294967295 Default Value: 0')
cxMcVoxCfgMaxPktFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgMaxPktFrame.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgMaxPktFrame.setDescription('The number of voice packet included in a voice frame. Less voice packet there is in a frame, bigger is the bandwitdh overhead on the WAN link, but better is the voice path end-to-end delay. The best compromise is a size of two (2) voice packets per voice frame, which correpsond to the default value.')
cxMcVoxCfgMaxSkew = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 125)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxCfgMaxSkew.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxCfgMaxSkew.setDescription('The number of msec of skew that the end-to-end synchronization algorithm must compensate.')
cxMcVoxStatAndLog = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3))
cxMcVoxStatusTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1), )
if mibBuilder.loadTexts: cxMcVoxStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusTable.setDescription('Voice station status table.')
cxMcVoxStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxStatusCardNumber"), (0, "CXMCVOX-MIB", "cxMcVoxStatusPortNumber"))
if mibBuilder.loadTexts: cxMcVoxStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusEntry.setDescription('Voice station status row definition.')
cxMcVoxStatusCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusCardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusCardNumber.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. It is a display that the software provides. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default Value: none')
cxMcVoxStatusPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusPortNumber.setDescription('Displays the number of the voice I/O port. You cannot modify this object. It is a display that the software provides. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port. CX1000: up to 15 for the DI600 Default Value: none')
cxMcVoxStatusPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 31, 32, 33, 34, 41, 42, 43, 44))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("no-voice-io", 3), ("boot-err-1", 31), ("boot-err-2", 32), ("boot-err-3", 33), ("boot-err-4", 34), ("appl-err-1", 41), ("appl-err-2", 42), ("appl-err-3", 43), ("appl-err-4", 44)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusPortStatus.setDescription('Displays the functional status of the port. You cannot modify this object. It is a display that the software provides. Options: disable (1): port is not functional enable (2): port is up and active no-voice-io (3): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-1 (31): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-2 (32): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-3 (33): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-4 (34): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-1 (41): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-2 (42): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-3 (43): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-4 (44): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: none')
cxMcVoxStatusHookLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusHookLocal.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusHookLocal.setDescription("Displays the state of the local port's ability to establish a connection. When the status shows 'on', the port is idle and ready to transmit. You cannot modify this object. It is a display that the software provides. Options: on (1): port is in the on-hook state and is able to establish a connection. off (2): port is in the off-hook state and cannot establish a connection. ")
cxMcVoxStatusHookRem = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusHookRem.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusHookRem.setDescription("Displays the state of the remote port's ability to establish a connection. When the status shows 'on', the remote port is idle and ready to transmit. You cannot modify this object. It is a display that the software provides. Options: on (1): port is in the on-hook state and is able to establish a connection. off (2): port is in the off-hook state and cannot establish a connection. unknown (3) ")
cxMcVoxStatusIoAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusIoAccess.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusIoAccess.setDescription('Displays the results of the test that the CPU performs on the accessibility of the voice channel control registers residing on the voice I/O card. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): CPU cannot access the voice channel registers on the voice I/O card. Contact Memotec service personnel. passed (2): CPU is able to access the voice channel registers on the voice I/O card. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none')
cxMcVoxStatusChannelAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusChannelAccess.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusChannelAccess.setDescription('Displays the results of the test the CPU performs on the DPRAM. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): CPU cannot access the DPRAM. Contact Memotec service personnel. passed (2): CPU is able to access DPRAM. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none')
cxMcVoxStatusDspRam = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusDspRam.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusDspRam.setDescription('Displays the results of the test the DSP performs on the accessibility of the RAM memory on the voice I/O card. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): DSP cannot access the RAM memory on the voice I/O card. Contact Memotec service personnel. passed (2): DSP is able to access RAM memory. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none')
cxMcVoxStatusDspDpram = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusDspDpram.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusDspDpram.setDescription("Displays the results of the test the DSP performs on the voice I/O card's DPRAM memory. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): DSP cannot access the DPRAM memory on the voice I/O card. Contact Memotec service personnel. passed (2): DSP is able to access DPRAM memory on the voice I/O card. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none")
cxMcVoxStatusSamplingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusSamplingTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusSamplingTime.setDescription('Displays the results of the test the DSP performs on the sampling rate of a voice stream. The DSP tests that the sampling rate is done at 8KHz. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): DSP cannot test sampling rate. Contact Memotec service personnel. passed (2): DSP is able to test sampling rate and it is at 8KHz. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none')
cxMcVoxStatusWatchdog = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fault", 1), ("passed", 2), ("inapplicable", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusWatchdog.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusWatchdog.setDescription('Displays the results of the test the CPU performs on the watchdog timer which resides on the voice I/O card. This object displays results from the self-test which you initiate using the object cxMcVoxCfgtestPort (of the cxMcVox Configuration Group table). You cannot modify this object. Options: fault (1): CPU cannot access the watchdog timer. Contact Memotec service personnel. passed (2): CPU is able to access watchdog timer and it is performing properly. inapplicable (3): self-test has not been run since last system reset. running (4): self-test is currently running. Results are not yet available. Default Value: none')
cxMcVoxStatusRemPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusRemPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusRemPortStatus.setDescription('Displays the channel number of the attached remote port. You cannot modify this object. Range of Values: 0-4294967295')
cxMcVoxStatusInputDbmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(700, 1050))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusInputDbmLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusInputDbmLevel.setDescription('Displays the current Dbm level of the input analog voice signal. You cannot modify this object. . Range of Values: 700 to 1050 (-30dBm to 5dBm) Default Value: none')
cxMcVoxStatusPhyIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("if-em", 1), ("if-fxs", 2), ("if-fxo", 3), ("if-absent", 4), ("if-unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusPhyIfType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusPhyIfType.setDescription('')
cxMcVoxStatusDspUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusDspUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusDspUtilization.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 1000 Default Value: none')
cxMcVoxStatusIOResetState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 1, 1, 101), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-reset", 1), ("normal", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatusIOResetState.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxStatusIOResetState.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Options: in-reset (1) normal (2) unknown (3)')
cxMcVoxEventTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2), )
if mibBuilder.loadTexts: cxMcVoxEventTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventTable.setDescription('OnLine/OffLine events table for incoming/outgoing calls.')
cxMcVoxEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxEventCardNumber"), (0, "CXMCVOX-MIB", "cxMcVoxEventPortNumber"), (0, "CXMCVOX-MIB", "cxMcVoxEventLogIndex"))
if mibBuilder.loadTexts: cxMcVoxEventEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventEntry.setDescription('Online/Offline events row definition.')
cxMcVoxEventCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventCardNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventCardNumber.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 4 Default Value: none')
cxMcVoxEventPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventPortNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventPortNumber.setDescription('Displays the number of the voice I/O port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port. CX1000: 1 or 2 Default Value: none')
cxMcVoxEventLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventLogIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventLogIndex.setDescription('Displays the index number of the event log. You cannot modify this object. Range of Values: 1 to 4294967295 Default Value: none')
cxMcVoxEventDateAndTimeOnLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventDateAndTimeOnLine.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventDateAndTimeOnLine.setDescription('Displays the date and time of the last online event. An online event is any incoming or outgoing call that the voice station generates. The format of the display is as follows: Year/Month/Date-Day-Hours:Minutes:Seconds You cannot modify this object. Range of Values: Year: 0-99 Month: 1-12 Date: 1-31 (day of the month) Day : 0-6 (day of the week - 0 being Sunday) Hours: 0-23 Minutes: 0-59 Seconds: 0-59 Default Value: none')
cxMcVoxEventDateAndTimeOffLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventDateAndTimeOffLine.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventDateAndTimeOffLine.setDescription('Displays the date and time of the last offline event. An offline event is any incoming or outgoing call that the voice station terminates. The format of the display is as follows: Year/Month/Date-Day-Hours:Minutes:Seconds You cannot modify this object. Range of Values: Year: 0-99 Month: 1-12 Date: 1-31 (day of the month) Day : 0-6 (day of the week - 0 being Sunday) Hours: 0-23 Minutes: 0-59 Seconds: 0-59 Default Value: none')
cxMcVoxEventPhoneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventPhoneNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventPhoneNumber.setDescription('Displays the phone number (including any voice mail digits) the user enters to reach a remote telephone or fax machine. This object is irrelevant for incoming calls. You cannot modify this object. Range of Values: 1 to 32 numeric digits Default Value: none')
cxMcVoxEventLnkState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("remUnavailable", 1), ("remError", 2), ("busy", 3), ("open", 4), ("errActiveChn", 5), ("errPath", 6), ("errLnk", 7), ("fixedLnkDown", 8), ("fixedLnkUp", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventLnkState.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventLnkState.setDescription('Displays the status of the link to the remote telephone or fax machine. You cannot modify this object. Options: remUnavailable (1): the routing specifies a remote chassis location that does not exist. remError (2): all voice ports at the specified remote are inactive and therefore cannot accept the call. It is possible that the remote ports are disabled or that the I/O card is not installed. busy (3): all voice ports at the specified remote are busy and therefore unavailable to accept the call. open (4): the call was successfully put through to a voice port at the remote location. errActiveChn (5): the end-user has replaced the receiver (on-hook) at the end of a call and then removed the receiver (off-hook) so quickly that the connection has not had sufficient time to completely disconnect. The end-user should wait a few seconds after replacing the receiver before attempting to place another call. errPath (6): the Path ID (dialing code) the user entered is not listed in the routing table. Check that the Path ID and routing are completely configured. errLnk (7): there is an error condition on the line between the local and remote link stations causing the link to be inactive. fixedLnkDown (8): Memotec use only. Contact Memotec service personnel if this value displays. fixedLnkUp (9): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: none')
cxMcVoxEventPin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEventPin.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventPin.setDescription('Displays the Personal Identification Number (PIN) that is validated against the local voice station card PIN number table. Range of Values: 2 to 8 numeric digits, each number from 0 to 9 Default Value: none')
cxMcVoxEventClrEvts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEventClrEvts.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEventClrEvts.setDescription('Determines whether to clear ALL logging information from the Event group table. Options: no (1) yes (2) Default Value: no (1) Configuration Change: none')
cxMcVoxStateTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3), )
if mibBuilder.loadTexts: cxMcVoxStateTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateTable.setDescription('Connections table for outgoing calls.')
cxMcVoxStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxStateCardNumber"), (0, "CXMCVOX-MIB", "cxMcVoxStatePortNumber"), (0, "CXMCVOX-MIB", "cxMcVoxStateLogIndex"))
if mibBuilder.loadTexts: cxMcVoxStateEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateEntry.setDescription('Outgoing call connection state row definition.')
cxMcVoxStateCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStateCardNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateCardNumber.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. It is a display that the software provides. Range of Values: CX900: 1 to 6 CX1000: 1 to 4 Default Value: none')
cxMcVoxStatePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatePortNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStatePortNumber.setDescription('Displays the number of the voice I/O port. You cannot modify this object. It is a display that the software provides. Options: CX900: 1 is the only acceptable value. Each I/O card on has 1 port. CX1000: 1 or 2 Default Value: none')
cxMcVoxStateLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStateLogIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateLogIndex.setDescription('Displays the number of the table row containing objects used for monitoring the path state. You cannot modify this object. Range of Values: 1 to 4294967295 Default Value: none')
cxMcVoxStatePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStatePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStatePathId.setDescription('Displays the Path ID or Group ID that the user dials to access the remote telephone or fax machine. Displays the Path ID or Group ID that the user dials to access the remote telephone or fax machine. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxPathAdmPathId of the cxMcVox Administrative Path Group. Range of Values: 1 to 4 numeric digits Default Value: none')
cxMcVoxStateDateAndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStateDateAndTime.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateDateAndTime.setDescription('Displays the date and time the link associated with the Path/Group ID changed state (i.e. the call was initiated). The format of the display is as follows: Year/Month/Date-Day-Hours:Minutes:Seconds You cannot modify this object. Range of Values: Year: 0-99 Month: 1-12 Date: 1-31 (day of the month) Day : 0-6 (day of the week, 0 being Sunday) Hours: 0-23 Minutes: 0-59 Seconds: 0-59 Default Value: none')
cxMcVoxStateLnkState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("remUnavailable", 1), ("remError", 2), ("busy", 3), ("open", 4), ("errActiveChn", 5), ("errPath", 6), ("errLnk", 7), ("fixedLnkDown", 8), ("fixedLnkUp", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStateLnkState.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateLnkState.setDescription('Displays the status of the link to the remote telephone or fax machine. You cannot modify this object. Options: remUnavailable (1): the routing specifies a remote chassis location that does not exist. remError (2): all voice ports at the specified remote are inactive and therefore cannot accept the call. It is possible that the remote ports are disabled or that the I/O card is not installed. busy (3): all voice ports at the specified remote are busy and therefore unavailable to accept the call. open (4): the call was successfully put through to a voice port at the remote location. errActiveChn (5): the end-user has replaced the receiver (on-hook) at the end of a call and then removed the receiver (off-hook) so quickly that the connection has not had sufficient time to completely disconnect. The end-user should wait a few seconds after replacing the receiver before attempting to place another call. errPath (6): the Path ID (dialing code) the user entered is not listed in the routing table. Check that the Path ID and routing are completely configured. errLnk (7): there is an error condition on the line between the local and remote link stations causing the link to be inactive. fixedLnkDown (8): Memotec use only. Contact Memotec sevice personnel if this value displays. fixedLnkUp (9): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: none')
cxMcVoxStateRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 3, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxStateRmtExt.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxStateRmtExt.setDescription('Displays the Remote Extension or Group ID that the user dials to access the remote telephone or fax machine. You cannot modify this object. Range of Values: 1 to 5 numeric digits Default Value: none')
cxMcVoxPathAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4), )
if mibBuilder.loadTexts: cxMcVoxPathAdmTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmTable.setDescription('Planned pathID table.')
cxMcVoxPathAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxPathAdmIndex"))
if mibBuilder.loadTexts: cxMcVoxPathAdmEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmEntry.setDescription('Planned pathID row definition.')
cxMcVoxPathAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathAdmIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmIndex.setDescription('Displays the index number of the Path ID. You cannot modify this object. Range of Values: 1 to 300 Default Value: none')
cxMcVoxPathAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxPathAdmRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: none Configuration Changed: administrative')
cxMcVoxPathAdmPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxPathAdmPathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmPathId.setDescription('Determines the administrative numeric dialing code that the user enters to access the remote telephone or fax machine. Note: The length of the ID must match the value you define for the object cxMcVoxPathAdmPathLng (of this table). Range of Values: 1 to 4 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxPathAdmRemStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxPathAdmRemStationId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmRemStationId.setDescription('Determines the administrative ID (name) of the remote voice station. Note: The remote voice station must exist in the Network Routing table before its ID can be defined. Range of Values: a maximum of 12 alphanumeric characters. All characters must be in capital letters. You can use any combination of letters and numbers, however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none Configuration Changed: administrative')
cxMcVoxPathAdmHunt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxPathAdmHunt.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmHunt.setDescription('Determines the port numbers included in the administrative Hunt Group. A Hunt Group identifies multiple ports on a single remote voice station (as defined with the object cxMcVoxPathAdmRemStationId of this table). The Path ID (defined using the object cxMcVoxPathAdmId of this table) references this Hunt Group during call establishment. Each port in the Hunt Group is polled until one of the ports accepts the call. A maximum of 32 ports can be in a single hunt group. Range of Values: 1 to 4294967295 Default Value: 65535 Configuration Changed: administrative')
cxMcVoxPathAdmLng = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxPathAdmLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathAdmLng.setDescription('Determines the length (in digits) of the administrative Path ID. Note: If you modify the current operative value to one that is a lower digit, the current operative Path IDs (using the higher value) will be lost once the administrative setting is initialized. Range of Values: 1 to 4 Default Value: 3 Configuration Changed: administrative')
cxMcVoxPathOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5), )
if mibBuilder.loadTexts: cxMcVoxPathOpeTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeTable.setDescription('Active pathID table.')
cxMcVoxPathOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxPathOpeIndex"))
if mibBuilder.loadTexts: cxMcVoxPathOpeEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeEntry.setDescription('Active pathID row definition.')
cxMcVoxPathOpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathOpeIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeIndex.setDescription('Displays the index number of the operational Path ID. You cannot modify this object. Range of Values: 1 to 300 Default Value: none')
cxMcVoxPathOpePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathOpePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpePathId.setDescription('Displays the operational Path ID. The Path ID is the numeric dialing code the user enters to gain access to the remote telephone or fax machine. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxPathAdmPathId of the cxMcVox Administrative Configuration Group. Range of Values: 1 to 4 digits Default Value: none ')
cxMcVoxPathOpeRemStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathOpeRemStationId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeRemStationId.setDescription(' Displays the operational ID (name) of the remote voice station. Note: The remote voice station must exist in the Network Routing table before its ID can be defined. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxNetAdmRemStationId of the cxMcVox Administrative Net group Range of Values: a maximum of 12 alphanumeric characters. All characters must be in capital letters. You can use any combination of letters and numbers, however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default: none')
cxMcVoxPathOpeHunt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathOpeHunt.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeHunt.setDescription('Displays the port numbers included in the operational Hunt Group. A Hunt Group identifies multiple ports on a single remote voice station (as defined with the object cxMcVoxPathAdmRemStationId of this table). The Path ID (defined using the object cxMcVoxPathAdmId of this table) references this hunt group during call establishment. Each port in the Hunt Group is polled until one of the ports accepts the call. A maximum of 8 ports can be in a single hunt group. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxPathAdmHunt of the cxMcVox Administrative Path Group. Range of Values: 1 to 4294967295 Default Value: 65535')
cxMcVoxPathOpeLng = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxPathOpeLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxPathOpeLng.setDescription('Displays the length (in digits) of the operative Path ID. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxPathAdmPathLng of the cxMcVox Administrative Path Group. Range of Values: 1 to 4 Default Value: 3')
cxMcVoxNetAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6), )
if mibBuilder.loadTexts: cxMcVoxNetAdmTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmTable.setDescription('Planned NET entries.')
cxMcVoxNetAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxNetAdmIndex"))
if mibBuilder.loadTexts: cxMcVoxNetAdmEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmEntry.setDescription('Planned NET row.')
cxMcVoxNetAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetAdmIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmIndex.setDescription('Displays the index number of the administrative network routing entry. You cannot modify this object. Range of Values: 1 to 300 Default Value: none')
cxMcVoxNetAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxNetAdmRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled Default Value: none Configuration Changed: administrative')
cxMcVoxNetAdmRemStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxNetAdmRemStationId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmRemStationId.setDescription('Determines the administrative ID (name) of the remote voice station. Range of Values: a maximum of 12 alphanumeric characters. All characters must be in capital letters. You can use any combination of letters and numbers, however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default: none Configuration Changed: administrative')
cxMcVoxNetAdmLocalLnkStation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxNetAdmLocalLnkStation.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmLocalLnkStation.setDescription("Determines the slot number holding the local CPU board supporting the GMF software. This value is always '1' if the CPU is in the CX900 architecture. Range of Values: CX900: 1 CX1000: 1 to 16 Default Value: 1 Configuration Changed: administrative")
cxMcVoxNetAdmRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxNetAdmRoute.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmRoute.setDescription('Determines the number that identifies the administrative link entry in the GMF (Gateway Mux Frame Relay). The network administrator assigns this number in sequential order starting at 1. You then must establish an internal system route from the GMF route number to a Frame Relay circuit alias using the objects gmfSRLink and gmfSRDestCircuitAlias of the GMF System Routing Definition Group. Range of Values: 1 to 1024 Default Value: 1 Configuration Changed: administrative')
cxMcVoxNetAdmRemVoxStation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxNetAdmRemVoxStation.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetAdmRemVoxStation.setDescription("Determines the slot number holding the remote CPU board that supports the voice software. This value is always '1' if the remote CPU is in the CX900 architecture. Range of Values: CX900: 1 CX1000: 1 to 16 Default Value: 1 Configuration Changed: administrative")
cxMcVoxNetOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7), )
if mibBuilder.loadTexts: cxMcVoxNetOpeTable.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeTable.setDescription('Active net entries table.')
cxMcVoxNetOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxNetOpeIndex"))
if mibBuilder.loadTexts: cxMcVoxNetOpeEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeEntry.setDescription('Active net entry row definition.')
cxMcVoxNetOpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetOpeIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeIndex.setDescription('Displays the index number of the operative network routing entry. You cannot modify this object Range of Values: 1 to 300 Default Value: none')
cxMcVoxNetOpeRemStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetOpeRemStationId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeRemStationId.setDescription('Displays the operative ID (name) of the remote voice station. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxNetAdmOpeRemStationId of the cxMcVox Administrative Net Group. Range of Values: a maximum of 12 alphanumeric characters. All characters must be in capital letters. You can use any combination of letters and numbers, however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default: none')
cxMcVoxNetOpeLocalLnkStation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetOpeLocalLnkStation.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeLocalLnkStation.setDescription("Displays the slot number holding the local CPU board supporting the GMF software. This value is always '1' if the CPU is in the CX900 architecture. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxNetAdmOpeLocalLnkStation of the cxMcVox Administrative Net Group. Range of Values: CX900: 1 CX1000: 1 to 16 Default Value: 1")
cxMcVoxNetOpeRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetOpeRoute.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeRoute.setDescription('Displays the number that identifies the operative link entry. The network administrator assigns this number to identify the route in the routing table. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxNetAdmOpeRoute of the cxMcVox Administrative Net Group. Range of Values: 1 to 1024 Default Value: 1')
cxMcVoxNetOpeRemVoxStation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxNetOpeRemVoxStation.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxNetOpeRemVoxStation.setDescription("Displays the slot number holding the remote CPU board that supports the voice software. This value is always '1' if the remote CPU is in the CX900 architecture. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxNetAdmRemVoxStation of the cxMcVox Administrative Net Group. Range of Values: CX900: 1 CX1000: 1 to 16 Default Value: 1")
cxMcVoxDriverAdm = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8))
cxMcVoxEmAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1), )
if mibBuilder.loadTexts: cxMcVoxEmAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmTable.setDescription('Voice station planned E&M Table.')
cxMcVoxEmAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxEmAdmCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxEmAdmPortUsed"))
if mibBuilder.loadTexts: cxMcVoxEmAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmEntry.setDescription('Voice station planned E&M row definition.')
cxMcVoxEmAdmCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmAdmCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxEmAdmPortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmAdmPortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmPortUsed.setDescription('Displays the number of the voice port. You cannot modify this object. It is a display that the software provides. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port. CX1000: up to 15 for the DI600 Default Value: none')
cxMcVoxEmAdmPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmPortStatus.setDescription('Determines the functional status of the administrative E&M port. Options: disable (1): port is not functional enable (2): port is up and active Default Value: disable (1) Configuration Changed: administrative')
cxMcVoxEmAdmVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmVocoder.setDescription('Determines the transmission speed (in bits per second) of the compressed voice stream on the administrative E&M port. Defining the speed also sets the ACELP voice compression ratio. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000 Configuration Changed: administrative')
cxMcVoxEmAdmFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the administrative E&M port. This value also determines the bandwidth required to pass FAX traffic through the voice software. This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: administrative')
cxMcVoxEmAdmAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxEmAdmAutoCnx.setDescription('Obsolete.')
cxMcVoxEmAdmPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmPathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEmAdmPathId.setDescription('Path IDs no longer exist in the new Voice Routing (VR) scheme. Determines the Path ID used for auto-connection on the administrative E&M port. The Path ID is a numeric dialing code the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathAdmPathLng of the cxMcVox Administrative Path Group. Range of Values: 1 to 4 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxEmAdmTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmissions on the administrative E&M port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxEmAdmRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the administrative E&M port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxEmAdmEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmEchoCancel.setDescription("Determines the state of echo cancellation on the administrative E&M port. When set to 'enable', at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxEmAdmType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type-1", 1), ("type-2", 2), ("type-3", 3), ("type-4", 4), ("type-5", 5))).clone('type-2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmType.setDescription('Determines the type of E&M interface on the administrative E&M port. Each of the five interface types has a unique signal-to-wire pattern. Make sure that you select the interface type that matches your PBX. Options: type-1 (1) type-2 (2) type-3 (3) type-4 (4) type-5 (5) Default Value: type-2 (2) Configuration Changed: administrative NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxEmAdmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reverse", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmMode.setDescription('Determines the signalling mode for the administrative E&M port. The signalling mode refers to the wires of the physical connection and how they are connected. The mode you select must match the type the PBX punch block uses or the port will not be able to communicate with it. Options: normal (1) reverse (2) Default Value: normal Configuration Changed: administrative')
cxMcVoxEmAdmDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2), ("mfR1", 3), ("mfR2", 4))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmDialType.setDescription('Determines the dialing method of the administrative E&M port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. Options: dtmf (1): (Dual Tone Multifrequence) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. mfR1 (3): R1 signaling protocol MultiFrequency (MF) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 dBm0 +- 1 dB (CCITT Recommendation Q.322). The difference in transmission level between the two frequencies comprises a signal that does not exceed 0.5 dB. mfR2 (4): R2 signaling protocol MultiFrequency (MF) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -8 dBm0 +- 1 dB (CCITT Recommendation Q.454). The difference in transmission level between the two frequencies comprises a signal that does not exceed 1 dB. Default Value: dtmf (1) Configuration Changed: administrative')
cxMcVoxEmAdmSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3), ("ac15", 4), ("openchn", 5), ("r2", 6), ("mfcr2", 7), ("isdn", 8))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmSignalType.setDescription("Determines the type of signalling on the administrative E&M port. The signalling type refers to the line seizure technique Options: normal (1) delay (2) wink (3) ac15 (4) openChn (5) R2 (6) MFCR2 (7) isdn (8) Note: If you select 'ac15' you must define the object cxMcVoxEmAdmDialType of this table. Default Value: normal Configuration Changed: administrative")
cxMcVoxEmAdmAc15Type = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15Type.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15Type.setDescription('Determines the type of AC15 signals the administrative E&M port uses to seize the line for transmission. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmAdmSignalType of this table) Options: normal (1) delay (2) Default Value: normal Configuration Changed: administrative')
cxMcVoxEmAdmAc15TimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15TimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15TimeOn.setDescription('Determines the length of time, in milliseconds, the AC15 pulse remains on. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmAdmSignalType of this table) Range of Values: 0 to 60000 Default Value: 60 Configuration Changed: administrative')
cxMcVoxEmAdmAc15TimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15TimeOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmAc15TimeOff.setDescription('Determines the length of time, in milliseconds, the AC15 pulse remains off. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmAdmSignalType of this table) Range of Values: 0 to 60000 Default Value: 40 Configuration Changed: administrative')
cxMcVoxEmAdmCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmCnctType.setDescription('Determines the method the administrative E&M port uses to make connections. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1) Configuration Changed: administrative')
cxMcVoxEmAdmRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmRingType.setDescription('Determines the ring type of the administrative E&M port. The ring types provide different ring timing to match the different ring cycles in networks. Options: north-american (1) international (2) Default Value: north-american (1) Configuration Changed: administrative')
cxMcVoxEmAdmRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the E&M port. The Remote Extension is a numeric dialing code that the user enters to gain access to the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxEmAdmRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone('          ')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxEmAdmRmtId.setDescription('Determines the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection via the fixed connection method. With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. Range of Values: A maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none Configuration Changed: administrative')
cxMcVoxEmAdmTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: administrative')
cxMcVoxEmAdmFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmFaxEnable.setDescription("Determines the state of the Memotec's FAX relay software on the administrative E&M port. When set to 'enable', at both ends, the Memotec's FAX relay software will be used to transfer FAX messages taking into account the 'cxMcVoxEmAdmFaxBw' object. Otherwise, when set to 'disable', at both ends, no FAX relay support is provided, and the FAX goes through the voice coder if supported. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxEmAdmBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1) Configuration Changed: administrative')
cxMcVoxEmAdmImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmAdmImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmImpedance.setDescription('Displays the input line impedance of the operative E&M interface. The value of this object can be modified in operational mode. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms (1) NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxEmAdmVoiceConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("two-wires", 1), ("four-wires", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmAdmVoiceConnection.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmAdmVoiceConnection.setDescription('Indicates which voice path is provided by the E&M interface. Options: two-wires (1) four-wires (2)')
cxMcVoxFxsAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2), )
if mibBuilder.loadTexts: cxMcVoxFxsAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmTable.setDescription('')
cxMcVoxFxsAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxFxsAdmCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxFxsAdmPortUsed"))
if mibBuilder.loadTexts: cxMcVoxFxsAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmEntry.setDescription('')
cxMcVoxFxsAdmCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsAdmCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxFxsAdmPortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsAdmPortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmPortUsed.setDescription('Displays the number of the voice port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port CX1000: 1 or 2 Default Value: none')
cxMcVoxFxsAdmPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmPortStatus.setDescription('Determines the functional status of the administrative port. Options: disable (1): port is not functional enable (2): port is up and active Default Value: disable (1) Configuration Changed: administrative')
cxMcVoxFxsAdmVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmVocoder.setDescription('Determines the transmission speed (in bits per second) of the compressed voice stream on the administrative FXS port. Defining the speed also sets the ACELP voice compression ratio. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000 (2) Configuration Changed: administrative')
cxMcVoxFxsAdmFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the administrative FXS port. This value also determines the bandwidth required to pass FAX traffic through the voice software.This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: administrative')
cxMcVoxFxsAdmAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsAdmAutoCnx.setDescription('obsolete')
cxMcVoxFxsAdmPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmPathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxFxsAdmPathId.setDescription('Path IDs no longer exist with the new Voice Routing (VR) scheme. The Path ID is a numeric dialing code the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathAdmPathLng of the cxMcVox Administrative Path Group Range of Values: 1 to 4 digits Default Value: none')
cxMcVoxFxsAdmTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmissions on the administrative FXS port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxFxsAdmRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the administrative FXS port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxFxsAdmEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmEchoCancel.setDescription("Determines the state of echo cancellation on the administrative FXS port. When set to 'enable' at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxFxsAdmSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ground-start", 1), ("loop-start", 2), ("did", 3))).clone('loop-start')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmSignaling.setDescription('Determines the type of signalling the administrative FXS port uses to seize the line. Options: ground-start (1) loop-start (2) did (3) Default Value: loop-start (2) Configuration Changed: administrative')
cxMcVoxFxsAdmTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmTimeOn.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsAdmTimeOn.setDescription('obsolete')
cxMcVoxFxsAdmTimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmTimeOff.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsAdmTimeOff.setDescription('obsolete')
cxMcVoxFxsAdmCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmCnctType.setDescription('Determines the method the administrative FXS port uses to make connections. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1) Configuration Changed: administrative')
cxMcVoxFxsAdmRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmRingType.setDescription('Determines the ring type of the administrative FXS port. The ring types provide different ring timing to match the different ring cycles in networks. Options: north-american (1) international (2) Default Value: north-american (1) Configuration Changed: administrative')
cxMcVoxFxsAdmImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmImpedance.setDescription('Determines the input line impedance of the administrative FXS port. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms (1) Configuration Changed: administrative NOTE: The option aus(4) is added only starting at version 11. NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxFxsAdmDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmDialType.setDescription('Determines the dialing method of the administrative FXS port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. Options: dtmf (1): (Dual Tone Multifrequence) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. Default Value: dtmf (1) Configuration Changed: administrative')
cxMcVoxFxsAdmDidSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmDidSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmDidSignalType.setDescription("Note: This object only applies to those ports with the object cxMcVoxFxsAdmSignaling set to 'did'. Determines the type of signaling on the administrative FXS port. The signaling type refers to the line seizure technique. Options: normal (1) delay (2) wink (3) Default Value: normal (1) Configuration Changed: administrative")
cxMcVoxFxsAdmRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the FXS port. The Remote Extension is a numeric dialing code that the user enters to access the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxFxsAdmRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone('          ')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxFxsAdmRmtId.setDescription('Determines the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection with fixed type connection. With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none Configuration Changed: administrative')
cxMcVoxFxsAdmTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: administrative')
cxMcVoxFxsAdmFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmFaxEnable.setDescription("Determines the state of the Memotec's FAX relay software on the administrative E&M port. When set to 'enable', at both ends, the Memotec's FAX relay software will be used to transfer FAX messages taking into account the 'cxMcVoxFxsAdmFaxBw' object. Otherwise, when set to 'disable', at both ends, no FAX relay support is provided, and the FAX goes through the voice coder if supported. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxFxsAdmBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsAdmBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsAdmBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1) Configuration Changed: administrative')
cxMcVoxFxoAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3), )
if mibBuilder.loadTexts: cxMcVoxFxoAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmTable.setDescription('cx Voice Station Administrative FXO Table.')
cxMcVoxFxoAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxFxoAdmCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxFxoAdmPortUsed"))
if mibBuilder.loadTexts: cxMcVoxFxoAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmEntry.setDescription('cx Voice Station Administrative FXO Entry ')
cxMcVoxFxoAdmCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoAdmCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. It is a display that the software provides. Range of Values CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxFxoAdmPortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoAdmPortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmPortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object. It is a display that the software provides. Options: CX900: 1 is the only acceptable value. Each I/O card only has 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxFxoAdmPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmPortStatus.setDescription('Determines the functional status of the administrative port. Options: disable (1): port is not functional enable (2): port is up and active Default Value: disable (1) Configuration Changed: administrative')
cxMcVoxFxoAdmVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmVocoder.setDescription('Determines the transmission speed (in bits per second) of the compressed voice stream on the administrative FXO port. Defining the speed also sets the ACELP voice compression ratio. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000 (2) Configuration Changed: administrative')
cxMcVoxFxoAdmFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the administrative FXO port. This value also determines the bandwidth required to pass FAX traffic through the voice software. This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: administrative')
cxMcVoxFxoAdmAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxoAdmAutoCnx.setDescription('obsolete')
cxMcVoxFxoAdmPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmPathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxFxoAdmPathId.setDescription('Path IDs no longer exist with the new Voice Routing (VR) scheme. The Path ID is a numeric dialing code the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathAdmPathLng of the cxMcVox Administrative Path Group. Range of Values: 1 to 4 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxFxoAdmTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmission on the administrative FXO port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxFxoAdmRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the administrative FXO port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: administrative')
cxMcVoxFxoAdmEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmEchoCancel.setDescription("Determines the state of echo cancellation on the administrative FXO port. When set to 'enable' at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxFxoAdmSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ground-start", 1), ("loop-start", 2), ("did", 3))).clone('loop-start')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmSignaling.setDescription('Determines the type of signalling the administrative FXO port uses to seize the line. Options: ground-start (1) loop-start (2) did (3) Default Value: loop-start (2) Configuration Changed: administrative')
cxMcVoxFxoAdmCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmCnctType.setDescription('Determines the method the administrative FXO port uses to make connections. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1) Configuration Changed: administrative')
cxMcVoxFxoAdmRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmRingType.setDescription('Determines the ring type of the administrative FXO port. The ring types provide different ring timing to match the different ring cycles in networks. Options: north-american (1) international (2) Default Value: north-american (1) Configuration Changed: administrative')
cxMcVoxFxoAdmImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmImpedance.setDescription('Determines the input line impedance of the administrative FXO interface. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms (1) Configuration Changed: administrative NOTE: The option aus(4) is added only starting at version 11. NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxFxoAdmDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmDialType.setDescription('Determines the dialing method of the administrative FXO port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. Options: dtmf (1): (Dual Tone Multifrequence) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. Default Value: dtmf 1) Configuration Changed: administrative')
cxMcVoxFxoAdmDidSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmDidSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmDidSignalType.setDescription("Note: This object only applies to those ports with the object cxMcVoxFxoAdmSignaling set to 'did'. Determines the type of signaling on the administrative FXO port. The signaling type refers to the line seizure technique. Options: normal (1) delay (2) wink (3) Default Value: normal (1) Configuration Changed: administrative")
cxMcVoxFxoAdmRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5)).clone('000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the FXO port. The Remote Extension is a numeric dialing code that the user enters to gain access to the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxFxoAdmRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10)).clone('          ')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxFxoAdmRmtId.setDescription('Determines the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection with fixed type connection. With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none Configuration Changed: administrative')
cxMcVoxFxoAdmTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: administrative')
cxMcVoxFxoAdmFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmFaxEnable.setDescription("Determines the state of the Memotec's FAX relay software on the administrative E&M port. When set to 'enable', at both ends, the Memotec's FAX relay software will be used to transfer FAX messages taking into account the 'cxMcVoxFxoAdmFaxBw' object. Otherwise, when set to 'disable', at both ends, no FAX relay support is provided, and the FAX goes through the voice coder if supported. Options: disable (1) enable (2) Default Value: enable (2) Configuration Changed: administrative")
cxMcVoxFxoAdmBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 8, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoAdmBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoAdmBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1) Configuration Changed: administrative')
cxMcVoxDriverOpe = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9))
cxMcVoxEmOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1), )
if mibBuilder.loadTexts: cxMcVoxEmOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeTable.setDescription('')
cxMcVoxEmOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxEmOpeCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxEmOpePortUsed"))
if mibBuilder.loadTexts: cxMcVoxEmOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeEntry.setDescription('')
cxMcVoxEmOpeCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxEmOpePortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpePortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpePortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card has only 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxEmOpePortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 31, 32, 33, 34, 41, 42, 43, 44))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("no-voice-io", 3), ("boot-err-1", 31), ("boot-err-2", 32), ("boot-err-3", 33), ("boot-err-4", 34), ("appl-err-1", 41), ("appl-err-2", 42), ("appl-err-3", 43), ("appl-err-4", 44))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpePortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpePortStatus.setDescription('Displays the functional status of the operative port. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmportStatus of the cxMcVox Administrative Driver Group. Options: disable (1): port is not functional enable (2): port is up and active no-voice-io (3): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-1 (31): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-2 (32): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-3 (33): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-4 (34): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-1 (41): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-2 (42): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-3 (43): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-4 (44): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: disable (1)')
cxMcVoxEmOpeVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeVocoder.setDescription('Displays the transmission speed (in bits per second) of the compressed voice stream on the operative E&M port. Defining the speed also sets the ACELP voice compression ratio. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmVocoder of the cxMcVox Administrative Driver Group. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000')
cxMcVoxEmOpeFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the operative E&M port. This value also determines the bandwidth required to pass FAX traffic through the voice software. This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: operative')
cxMcVoxEmOpeAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxEmOpeAutoCnx.setDescription('obsolete')
cxMcVoxEmOpePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxEmOpePathId.setDescription('Path IDs no longer exist in the new Voice Routing (VR) scheme. The Path ID is a numeric dialing code the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathOpePathLng of the cxMcVox Operative Path Group. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmPathId of the cxMcVox Administrative Driver Group. Range of Values: 1 to 4 numeric digits Default Value: none')
cxMcVoxEmOpeTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmissions on the operative E&M port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxEmOpeRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the operative E&M port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxEmOpeEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeEchoCancel.setDescription("Displays the state of echo cancellation on the operative E&M port. When set to 'enable' at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmEchoCancel of the cxMcVox Administrative Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxEmOpeType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type-1", 1), ("type-2", 2), ("type-3", 3), ("type-4", 4), ("type-5", 5))).clone('type-2')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeType.setDescription('Displays the type of E&M interface of the operative E&M port. Each of the five interface types has a unique signal-to-wire pattern. Be sure to select the interface type that matches your PBX. You cannot modify this object. If you want to change thevalue you must modify the object cxMcVoxEmAdmType of the cxMcVox Administrative Driver Group. Options: type-1 (1) type-2 (2) type-3 (3) type-4 (4) type-5 (5) Default Value: type-2 (2)')
cxMcVoxEmOpeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reverse", 2))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeMode.setDescription('Displays the signalling mode for the operative E&M port. The signalling mode refers to the wires of the physical connection and how they are connected. The mode you select must match the type the PBX punch block uses or the port will not be able to communicate with it. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmMode of the cxMcVox Administrative Driver Group. Options: normal (1) reverse (2) Default Value: normal (1)')
cxMcVoxEmOpeDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2), ("mfR1", 3), ("mfR2", 4))).clone('dtmf')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeDialType.setDescription('Displays the dialing method of the operative E&M port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmDialType of the cxMcVox Administrative Driver Group Options: dtmf (1): Dual Tone MultiFrequency uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. mfR1 (3): R1 signaling protocol MultiFrequency (MF) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 dBm0 +- 1 dB (CCITT Recommendation Q.322). The difference in transmission level between the two frequencies comprises a signal that does not exceed 0.5 dB. mfR2 (4): R2 signaling protocol MultiFrequency (MF) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -8 dBm0 +- 1 dB (CCITT Recommendation Q.454). The difference in transmission level between the two frequencies comprises a signal that does not exceed 1 dB. Default Value: dtmf (1)')
cxMcVoxEmOpeSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3), ("ac15", 4), ("openchn", 5), ("r2", 6), ("mfcr2", 7), ("isdn", 8))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeSignalType.setDescription('Displays the type of signalling the operative E&M port uses to seize the line. You cannot modify this object. If you want to change the value you must modify thee object cxMcVoxEmAdmSignalType of the cxMcVox Administrative Driver Group. Options: normal (1) delay (2) wink (3) ac15 (4) openChn (5) R2 (6) MFCR2 (7) isdn (8) Default Value: normal (1)')
cxMcVoxEmOpeAc15Type = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15Type.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15Type.setDescription('Displays the type of AC15 signals the operative E&M port uses to seize the line for transmission. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmAdmSignalType of the cxMcVox Administrative Driver Group). You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmAcType of the cxMcVox Administrative Driver Group. Options: normal (1) delay (2) Default Value: normal')
cxMcVoxEmOpeAc15TimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15TimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15TimeOn.setDescription('Determines the length of time, in milliseconds, the AC15 pulse remains on. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmOpeSignalType of this table). Range of Values: 0 to 60000 Default Value: 60 Configuration Changed: operative')
cxMcVoxEmOpeAc15TimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15TimeOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeAc15TimeOff.setDescription('Determines the length of time, in milliseconds, the AC15 pulse remains off. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmOpeSignalType of this table). Range of Values: 0 to 60000 Default Value: 40 Configuration Changed: operative')
cxMcVoxEmOpeCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeCnctType.setDescription('Displays the method the operative E&M port uses to make connections. This object is only relevant to E&M ports using the AC15 signalling type (as defined using the object cxMcVoxEmOpeSignalType of this table). You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmCnctType of the cxMcVox Administrative Driver Group. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1)')
cxMcVoxEmOpeRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeRingType.setDescription('Displays the ring type of the operative E&M port. The ring types provide different ring timing to match the different ring cycles in networks. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmRingType of the cxMcVox Administrative Driver Group. Options: north-american (1) international (2) Default Value: north-american (1)')
cxMcVoxEmOpeRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the E&M port. The Remote Extension is a numeric dialing code that the user enters to access to the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: operative')
cxMcVoxEmOpeRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxEmOpeRmtId.setDescription('Displays the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection via the fixed connection method. You cannot modify this object. If you want to change the ID you must modify the object cxMcVoxEmAdmRmtId (of this table). With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none')
cxMcVoxEmOpeTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: operational')
cxMcVoxEmOpeFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeFaxEnable.setDescription("Displays the state of the FAX on the operative E&M port. When set to 'enable' at both the local and remote ends, the FAX will be enabled. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxEmAdmFaxEnable of the cxMcVox Administrative Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxEmOpeBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1)')
cxMcVoxEmOpeImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxEmOpeImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeImpedance.setDescription('Displays the input line impedance of the operative E&M interface. The value of this object can be modified in operational mode. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms (1) NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxEmOpeVoiceConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("two-wires", 1), ("four-wires", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxEmOpeVoiceConnection.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxEmOpeVoiceConnection.setDescription('Indicates which voice path is provided by the E&M interface. Options: two-wires (1) four-wires (2)')
cxMcVoxFxsOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2), )
if mibBuilder.loadTexts: cxMcVoxFxsOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeTable.setDescription('cx Voice Station active FXS Table.')
cxMcVoxFxsOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxFxsOpeCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxFxsOpePortUsed"))
if mibBuilder.loadTexts: cxMcVoxFxsOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeEntry.setDescription('cx Voice Station active FXS Entry ')
cxMcVoxFxsOpeCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxFxsOpePortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpePortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpePortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object Options: CX900: 1 is the only acceptable value. Each I/O card has only 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxFxsOpePortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 31, 32, 33, 34, 41, 42, 43, 44))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("no-voice-io", 3), ("boot-err-1", 31), ("boot-err-2", 32), ("boot-err-3", 33), ("boot-err-4", 34), ("appl-err-1", 41), ("appl-err-2", 42), ("appl-err-3", 43), ("appl-err-4", 44))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpePortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpePortStatus.setDescription('Displays the functional status of the operative port. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmportStatus of the cxMcVox Administrative FXS Driver Group. Options: disable (1): port is not functional enabled (2): port is up and active no-voice-io (3): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-1 (31): = Memotec use only. Contact Memotec service personnel if this value displays. boot-err-2 (32): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-3 (33): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-4 (34): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-1 (41): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-2 (42): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-3 (43): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-4 (44): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: disable (1)')
cxMcVoxFxsOpeVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeVocoder.setDescription('Displays the transmission speed (in bits per second) of the compressed voice stream on the operative FXS port. Defining the speed also sets the ACELP voice compression ratio. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmVocoder of the cxMcVox Administrative FXS Driver Group. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000 (2)')
cxMcVoxFxsOpeFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsOpeFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the operative FXS port. This value also determines the bandwidth required to pass FAX traffic through the voice software. This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: operative')
cxMcVoxFxsOpeAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsOpeAutoCnx.setDescription('Obsolete')
cxMcVoxFxsOpePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxFxsOpePathId.setDescription('Path IDs no longer exist in the new Voice Routing (VR) scheme. The PathID was formerly used for auto-connection on the operative FXS port. The Path ID is a numeric dialing code the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathOpePathLng of the cxMcVox Operative Path Group. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmPathId of the cxMcVox Administrative FXS Driver Group. Range of Values: 1 to 4 numeric digits Default Value: none ')
cxMcVoxFxsOpeTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsOpeTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmissions on the operative FXS port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxFxsOpeRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsOpeRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the operative FXS port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxFxsOpeEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeEchoCancel.setDescription("Displays the state of echo cancellation on the operative FXS port. When set to 'enable' at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmEchoCancel of the cxMcVox Administrative FXS Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxFxsOpeSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ground-start", 1), ("loop-start", 2), ("did", 3))).clone('loop-start')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeSignaling.setDescription('Displays the type of signalling the operative FXS port uses to seize the line. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxfxsAdmSignaling of the cxMcVox Administrative FXS Driver Group. Options: ground-start (1) loop-start (2) did (3) Default Value: loop-start')
cxMcVoxFxsOpeTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeTimeOn.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsOpeTimeOn.setDescription('Obsolete')
cxMcVoxFxsOpeTimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(4000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeTimeOff.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxsOpeTimeOff.setDescription('Obsoleted')
cxMcVoxFxsOpeCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeCnctType.setDescription('Displays the method the operative FXS port uses to make connections. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmCnctType of the cxMcVox Administrative FXS Driver Group. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1)')
cxMcVoxFxsOpeRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeRingType.setDescription('Displays the ring type of the operative FXS port. The ring types provide different ring timing to match the different ring cycles in networks. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmRingType of the cxMcVox Administrative FXS Driver Group. Options: north-american (1) international (2) Default Value: north-american (1)')
cxMcVoxFxsOpeImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxsOpeImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeImpedance.setDescription('Displays the input line impedance of the operative FXS interface. The value of this object can be modified in operational mode. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms NOTE: The option aus(4) is added only starting at version 11. NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxFxsOpeDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeDialType.setDescription('Displays the dialing method of the operative FXS port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmDialType of the cxMcVox Administrative FXS Driver Group table. Options: dtmf (1): (Dual Tone Multifrequence) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. Default Value: dtmf (1)')
cxMcVoxFxsOpeDidSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeDidSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeDidSignalType.setDescription('Displays the type of signaling on the operative FXS port. The signaling type refers to the line seizure technique. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmDidSignalType of the cxMcVox Administrative FXS Driver Group table. Options normal (1) delay (2) wink (3) Default Value: normal (1)')
cxMcVoxFxsOpeRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the FXS port. The Remote Extension is a numeric dialing code that the user enters to gain access to the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: operative')
cxMcVoxFxsOpeRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxFxsOpeRmtId.setDescription('Displays the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection via the fixed connection method. With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. You cannot modify this object. If you want to change the ID you must modify the object cxMcVoxFxsAdmRmtId (of this table). Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none')
cxMcVoxFxsOpeTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: operational')
cxMcVoxFxsOpeFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeFaxEnable.setDescription("Displays the state of the FAX on the operative FXS port. When set to 'enable' at both the local and remote ends, the FAX will be enabled. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxsAdmFaxEnable of the cxMcVox Administrative FXS Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxFxsOpeBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxsOpeBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxsOpeBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1)')
cxMcVoxFxoOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3), )
if mibBuilder.loadTexts: cxMcVoxFxoOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeTable.setDescription('cx Voice Station active FXO Table.')
cxMcVoxFxoOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxFxoOpeCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxFxoOpePortUsed"))
if mibBuilder.loadTexts: cxMcVoxFxoOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeEntry.setDescription('cx Voice Station active FXO Entry ')
cxMcVoxFxoOpeCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000 1 to 8 Default: none')
cxMcVoxFxoOpePortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpePortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpePortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card has only 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxFxoOpePortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 31, 32, 33, 34, 41, 42, 43, 44))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("no-voice-io", 3), ("boot-err-1", 31), ("boot-err-2", 32), ("boot-err-3", 33), ("boot-err-4", 34), ("appl-err-1", 41), ("appl-err-2", 42), ("appl-err-3", 43), ("appl-err-4", 44))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpePortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpePortStatus.setDescription('Displays the functional status of the port. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmportStatus of the cxMcVox Administrative FXO Driver Group. Options: disable (1): port is not functional enable (2): port is up and active no-voice-io (3): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-1 (31): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-2 (32): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-3 (33): Memotec use only. Contact Memotec service personnel if this value displays. boot-err-4 (34): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-1 (41): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-2 (42): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-3 (43): Memotec use only. Contact Memotec service personnel if this value displays. appl-err-4 (44): Memotec use only. Contact Memotec service personnel if this value displays. Default Value: disable (1)')
cxMcVoxFxoOpeVocoder = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bps5800", 1), ("bps8000", 2), ("kbps40", 3), ("kbps32", 4), ("kbps24", 5), ("kbps16", 6), ("opt7", 7), ("opt8", 8))).clone('bps8000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeVocoder.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeVocoder.setDescription('Displays the transmission speed (in bits per second) of the compressed voice stream on the operative FXO port. Defining the speed also sets the ACELP voice compression ratio. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmVocoder of the cxMcVox Administrative FXO Driver Group. Options: bps5800 (1): compresses at a higher rate and uses slightly less bandwidth. bps8000 (2): compresses at approximately an 8:1 ratio (lower rate) with a higher quality voice sound at the receiving end. opt3 (3): ADPCM 40. opt4 (4): ADPCM 32. opt5 (5): ADPCM 24. opt6 (6): ADPCM 16. opt7 (7): Memotec use only. opt8 (8): Memotec use only. Default Value: bps8000 (2)')
cxMcVoxFxoOpeFaxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps2400", 1), ("bps4800", 2), ("bps7200", 3), ("bps9600", 4))).clone('bps7200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoOpeFaxBw.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeFaxBw.setDescription('Determines the speed (in bits per second) of the FAX channel on the operative FXO port. This value also determines the bandwidth required to pass FAX traffic through the voice software. This value can be set to match the speed of your FAX machine or it can be lowered to reduce bandwidth allocation. Options: bps2400 (1) bps4800 (2) bps7200 (3) bps9600 (4) Default Value: bps7200 (3) Configuration Changed: operative')
cxMcVoxFxoOpeAutoCnx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeAutoCnx.setStatus('obsolete')
if mibBuilder.loadTexts: cxMcVoxFxoOpeAutoCnx.setDescription('Obsolete')
cxMcVoxFxoOpePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxFxoOpePathId.setDescription('Path IDs no longer exist in the new Voice Routing (VR) scheme. The PathID was formerly used for auto-connection on the operative FXO port. The Path ID is a numeric dialing code that the user enters to gain access to the remote telephone or fax machine. Note: The number of digits in the Path ID must match the value of the object cxMcVoxPathOpePathLng of the cxMcVox Operative Path Group. You cannot modify this object. If you want to change the value you modify the object cxMcVoxFxoAdmPathId of the cxMcVox Administrative FXO Driver Group. Range of Values: 1 to 4 digits Default Value: none')
cxMcVoxFxoOpeTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoOpeTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeTxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice transmissions on the operative FXO port. The transmission gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Transmission gains should be modified during a connection (i.e. dynamically) as changes in the value affect the local listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxFxoOpeRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(960)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoOpeRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeRxGain.setDescription('Determines the value defining the sound intensity (loudness) of voice reception on the operative FXO port. The reception gain can be modified in the administrative configuration or be fine-tuned dynamically. Note: Reception gains should be modified during a connection (i.e. dynamically) as changes in the value affect the remote listener. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 960 Configuration Changed: operative')
cxMcVoxFxoOpeEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeEchoCancel.setDescription("Displays the state of echo cancellation on the operative FXO port. When set to 'enable' at both the local and remote ends, echo cancellation stops echoes from the remote that are heard through the receiver at the local end. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmEchoCancel of the cxMcVox Administrative FXO Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxFxoOpeSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ground-start", 1), ("loop-start", 2), ("did", 3))).clone('loop-start')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeSignaling.setDescription('Displays the type of signalling the operative FXO port uses to seize the line. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmSignaling of the cxMcVox Administrative FXO Driver Group. Options: ground-start (1) loop-start (2) did (3) Default Value: loop-start')
cxMcVoxFxoOpeCnctType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switched", 1), ("auto-connect", 2), ("fixed", 3))).clone('switched')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeCnctType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeCnctType.setDescription('Displays the method the operative FXO port uses to make connections. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmCnctType of the cxMcVox Administrative FXO Driver Group. Options: switched (1): the port connects each call according to the dialing code the user enters. auto-connect (2): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Any remote can connect to a port with an auto-connect configuration but when the local user initiates the call it always goes to the same remote. fixed (3): calls passing through this port always terminate at the same remote destination. The port connects to the remote as soon as the local receiver enters the off-hook state. Only the local and remote destinations of the connection can use this port. No other remote location can gain access to this port. Default Value: switched (1)')
cxMcVoxFxoOpeRingType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("north-american", 1), ("international", 2))).clone('north-american')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeRingType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeRingType.setDescription('Displays the ring type of the operative FXO port. The ring types provide different ring timing to match the different ring cycles in networks. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmRingType of the cxMcVox Administrative FXO Driver Group. Options: north-american (1) international (2) Default Value: north-american (1)')
cxMcVoxFxoOpeImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("i600-ohms", 1), ("i900-ohms", 2), ("att", 3), ("aus", 4))).clone('i600-ohms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxFxoOpeImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeImpedance.setDescription('Displays the input line impedance of the operative FXO interface. The value of this object can be modified in operational mode. Options: i600-ohms (1) i900-ohms (2) att (3) aus (4) Default Value: i600-ohms (1) NOTE: The option aus(4) is added only starting at version 11. NOTE: This object is READ-ONLY for the CX800.')
cxMcVoxFxoOpeDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeDialType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeDialType.setDescription('Displays the dialing method of the operative FXO port. The dialing method refers to the sound that occurs when the user enters each digit of the dialing code. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmDialType of the cxMcVox Administrative FXO Driver Group table. Options: dtmf (1): (Dual Tone Multifrequence) uses bursts of frequency pairs to identify the code the user dials. Tones are generated at a level of -7 plus or minus 3 dBm for the lower frequency groups and -5 plus or minus 3 dBm for the higher frequency group. The power level of the higher frequency tone is intentionally increased to compensate for the higher line loss. pulse (2): uses bursts (10 plus or minus 0.5 pps) of the main tone frequency (2280Hz) to generate the codes the user enters. Tones are generated at a level of -4 to -30 dBm for the 2280Hz frequency. The number of pulses during one second indicates the code the user dials. With the E&M interface, the voice station generates and detects pulses. Default Value: dtmf (1)')
cxMcVoxFxoOpeDidSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("delay", 2), ("wink", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeDidSignalType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeDidSignalType.setDescription('Displays the type of signaling on the operative FXO port. The signaling type refers to the line seizure technique. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmDidSignalType of the cxMcVox Administrative FXO Driver Group table. Options normal (1) delay (2) wink (3) Default Value: normal (1)')
cxMcVoxFxoOpeRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeRmtExt.setDescription('Determines the Remote Extension or Group Id used for auto-connection on the FXO port. The Remote Extension is a numeric dialing code that the user enters to gain access to the remote telephone or fax machine. Auto-connection is the connection method that this port uses. A particular Remote Extension or Group Id has been assigned to the port so that no dialing is required. Note: The number of digits in the Remote Extension is determined by the object cxMcVoxNetNbDigits of the cxMcVox Global Parameters Group. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: operative')
cxMcVoxFxoOpeRmtId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeRmtId.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxFxoOpeRmtId.setDescription('Displays the ID (name) for the remote voice station. Note: This object must be defined in order to obtain a successful voice connection via the fixed connection method. With the fixed connection method, a particular Remote Extension or Group Id is assigned to the port so that no dialing is required. The call to the remote is established as soon as the connection is configured. You cannot modify this object. If you want to change the ID you must modify the object cxMcVoxFxoAdmRmtId (of this table). Range of Values: a maximum of 10 alphanumeric characters in upper-case only. You can use any combination of letters and numbers; however you cannot use blank spaces. Use a dash or underscore as a delimiter. Default Value: none')
cxMcVoxFxoOpeTranspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emulate", 1), ("transparent", 2), ("local", 3))).clone('emulate')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeTranspMode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeTranspMode.setDescription('Determines the whether to use the Transparent mode on the administrative port. In the transparent mode, the local port will answer only after the called party has answered to the party to which the call is finally destinated. The Transparent mode is incompatible with Switched type of connection and is automatically disabled when Switched mode is selected (only applies to autoconnect and fixed connections). The Local mode lets the local port answer right away to a seizure. Options: emulate (1): Emulation mode is on transparent (2): Transparent mode on local (3): Local mode on Default Value: emulate (1) Configuration Changed: operational')
cxMcVoxFxoOpeFaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeFaxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeFaxEnable.setDescription("Displays the state of the FAX on the operative FXO port. When set to 'enable' at both the local and remote ends, the FAX will be enabled. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxFxoAdmFaxEnable of the cxMcVox Administrative FXO Driver Group. Options: disable (1) enable (2) Default Value: enable (2)")
cxMcVoxFxoOpeBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 9, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("master", 2), ("slave", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxFxoOpeBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxFxoOpeBroadcast.setDescription('Cetermines the state of the voice broadcast feature. When set to none, no broadcast is used. When set to master, ... Options: none (1) master (2) slave (3) Default Value: none (1)')
cxMcVoxDriverAdmPriv = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20))
cxMcVoxAdmPortPrivTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1), )
if mibBuilder.loadTexts: cxMcVoxAdmPortPrivTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPortPrivTable.setDescription('Voice station planned Table.')
cxMcVoxAdmPortPrivEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxAdmCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxAdmPortUsed"))
if mibBuilder.loadTexts: cxMcVoxAdmPortPrivEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPortPrivEntry.setDescription('Voice station planned row definition.')
cxMcVoxAdmCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxAdmCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object Range of Values: CX900: 1 to 6 CX1000: 1 to 4 Default: none')
cxMcVoxAdmPortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxAdmPortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object. It is a display that the software provides. Options: CX900: 1 is the only acceptable value. Each I/O card has only 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxAdmRingTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 2000')
cxMcVoxAdmRingTimeOff1 = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOff1.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOff1.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 4000')
cxMcVoxAdmRingTimeOff2 = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOff2.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmRingTimeOff2.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 2000')
cxMcVoxAdmEchoCancelLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmEchoCancelLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmEchoCancelLevel.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65535 Default Value: 100')
cxMcVoxAdmToneDelayAfterCnct = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmToneDelayAfterCnct.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmToneDelayAfterCnct.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 6000 Default Value: 1000')
cxMcVoxAdmToneDelayAfterFlash = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmToneDelayAfterFlash.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmToneDelayAfterFlash.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 6000 Default Value: 400')
cxMcVoxAdmToneOffsetTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmToneOffsetTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmToneOffsetTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxAdmVoiceOffsetTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmVoiceOffsetTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmVoiceOffsetTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxAdmAc15InterDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmAc15InterDigit.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmAc15InterDigit.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 800')
cxMcVoxAdmMfToneThold = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmMfToneThold.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmMfToneThold.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 255 Default Value: 60')
cxMcVoxAdmPulseTmin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmPulseTmin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPulseTmin.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 15')
cxMcVoxAdmPulseTmax = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmPulseTmax.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPulseTmax.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 125')
cxMcVoxAdmPulseInterDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(275)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmPulseInterDigit.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPulseInterDigit.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 275')
cxMcVoxAdmDtmfGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmDtmfGuard.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmDtmfGuard.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 255 Default Value: 40')
cxMcVoxAdmDtmfOpeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("minus-25", 1), ("minus-28", 2), ("minus-31", 3), ("minus-34", 4))).clone('minus-25')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmDtmfOpeLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmDtmfOpeLevel.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Options: minus-25 (1) minus-28 (2) minus-31 (3) minus-34 (4) Default Value: minus-25 (1)')
cxMcVoxAdmDtmfTxTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmDtmfTxTimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmDtmfTxTimeOn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 500 Default Value: 75')
cxMcVoxAdmDtmfTxTimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmDtmfTxTimeOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmDtmfTxTimeOff.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 500 Default Value: 75')
cxMcVoxAdmFlashTmin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFlashTmin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFlashTmin.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 200')
cxMcVoxAdmFlashTmax = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFlashTmax.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFlashTmax.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 800')
cxMcVoxAdmFlashTgen = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFlashTgen.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFlashTgen.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 500')
cxMcVoxAdmAfterToneSilences = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmAfterToneSilences.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmAfterToneSilences.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 127 Default Value: 64')
cxMcVoxAdmFaxTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxAdmFaxRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxRxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxAdmFaxHdlcFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxHdlcFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxHdlcFlags.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 127 Default Value: 2')
cxMcVoxAdmFaxPreambleDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxPreambleDuration.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmFaxPreambleDuration.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1000')
cxMcVoxAdmFaxPreambleDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxPreambleDelay.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmFaxPreambleDelay.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 900')
cxMcVoxAdmFaxCedToneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedToneDuration.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedToneDuration.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 500')
cxMcVoxAdmFaxInterProtoGap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxInterProtoGap.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxInterProtoGap.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 75')
cxMcVoxAdmFaxTimerDetectSync = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000)).clone(7500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxTimerDetectSync.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxTimerDetectSync.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65000 Default Value: 7500')
cxMcVoxAdmFaxTimerWaitId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000)).clone(40000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxTimerWaitId.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxTimerWaitId.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65000 Default Value: 40000')
cxMcVoxAdmFaxMinPreambleDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxMinPreambleDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxMinPreambleDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1000')
cxMcVoxAdmFaxMaxPreambleDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxPreambleDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxPreambleDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1200')
cxMcVoxAdmFaxMinPreambleDly = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxMinPreambleDly.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxMinPreambleDly.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 400')
cxMcVoxAdmFaxMaxPreambleDly = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxPreambleDly.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxPreambleDly.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 900')
cxMcVoxAdmFaxCedToneDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedToneDetection.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedToneDetection.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 500')
cxMcVoxAdmFaxCedMinToneDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(2600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedMinToneDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedMinToneDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 2600')
cxMcVoxAdmFaxCedMaxToneDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedMaxToneDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxCedMaxToneDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 4000')
cxMcVoxAdmFaxMaxHdlcFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 20, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxHdlcFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmFaxMaxHdlcFlags.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 127 Default Value: 32')
cxMcVoxDriverOpePriv = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21))
cxMcVoxOpePortPrivTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1), )
if mibBuilder.loadTexts: cxMcVoxOpePortPrivTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePortPrivTable.setDescription('Voice station planned Table.')
cxMcVoxOpePortPrivEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxOpeCardUsed"), (0, "CXMCVOX-MIB", "cxMcVoxOpePortUsed"))
if mibBuilder.loadTexts: cxMcVoxOpePortPrivEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePortPrivEntry.setDescription('Voice station planned row definition.')
cxMcVoxOpeCardUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeCardUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeCardUsed.setDescription('Displays the slot number of the voice I/O card. You cannot modify this object. Range of Values: CX900: 1 to 6 CX1000: 1 to 8 Default: none')
cxMcVoxOpePortUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpePortUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePortUsed.setDescription('Displays the number of the voice I/O port. You cannot modify this object. Options: CX900: 1 is the only acceptable value. Each I/O card has only 1 port. CX1000: up to 15 for the DI600 Default: none')
cxMcVoxOpeRingTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 2000')
cxMcVoxOpeRingTimeOff1 = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOff1.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOff1.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 4000')
cxMcVoxOpeRingTimeOff2 = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOff2.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeRingTimeOff2.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 10 to 10000 Default Value: 2000')
cxMcVoxOpeEchoCancelLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeEchoCancelLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeEchoCancelLevel.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65535 Default Value: 100')
cxMcVoxOpeToneDelayAfterCnct = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeToneDelayAfterCnct.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeToneDelayAfterCnct.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 6000 Default Value: 1000')
cxMcVoxOpeToneDelayAfterFlash = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeToneDelayAfterFlash.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeToneDelayAfterFlash.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 6000 Default Value: 400')
cxMcVoxOpeToneOffsetTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeToneOffsetTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeToneOffsetTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxOpeVoiceOffsetTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeVoiceOffsetTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeVoiceOffsetTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxOpeAc15InterDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeAc15InterDigit.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeAc15InterDigit.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 800')
cxMcVoxOpeMfToneThold = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeMfToneThold.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeMfToneThold.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 255 Default Value: 60')
cxMcVoxOpePulseTmin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpePulseTmin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePulseTmin.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 15')
cxMcVoxOpePulseTmax = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpePulseTmax.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePulseTmax.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 125')
cxMcVoxOpePulseInterDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000)).clone(275)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpePulseInterDigit.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePulseInterDigit.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 3000 Default Value: 275')
cxMcVoxOpeDtmfGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeDtmfGuard.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeDtmfGuard.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 255 Default Value: 40')
cxMcVoxOpeDtmfOpeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("minus-25", 1), ("minus-28", 2), ("minus-31", 3), ("minus-34", 4))).clone('minus-25')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeDtmfOpeLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeDtmfOpeLevel.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Options: minus-25 (1) minus-28 (2) minus-31 (3) minus-34 (4) Default Value: minus-25 (1)')
cxMcVoxOpeDtmfTxTimeOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(75)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeDtmfTxTimeOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeDtmfTxTimeOn.setDescription('This object is read-only. Range of Values: 0 to 500')
cxMcVoxOpeDtmfTxTimeOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(75)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeDtmfTxTimeOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeDtmfTxTimeOff.setDescription('This object is read-only. Range of Values: 0 to 500')
cxMcVoxOpeFlashTmin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFlashTmin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFlashTmin.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 200')
cxMcVoxOpeFlashTmax = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFlashTmax.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFlashTmax.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 800')
cxMcVoxOpeFlashTgen = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFlashTgen.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFlashTgen.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 50 to 10000 Default Value: 500')
cxMcVoxOpeAfterToneSilences = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeAfterToneSilences.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeAfterToneSilences.setDescription('This object is read-only. Range of Values: 0 to 127')
cxMcVoxOpeFaxTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxTxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxOpeFaxRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(820, 1180)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxRxGain.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 820 to 1180 (-18.0dB to 18.0dB) Default Value: 1000')
cxMcVoxOpeFaxHdlcFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxHdlcFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxHdlcFlags.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 127 Default Value: 2')
cxMcVoxOpeFaxPreambleDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxPreambleDuration.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeFaxPreambleDuration.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1000')
cxMcVoxOpeFaxPreambleDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxPreambleDelay.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeFaxPreambleDelay.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 900')
cxMcVoxOpeFaxCedToneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedToneDuration.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedToneDuration.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 500')
cxMcVoxOpeFaxInterProtoGap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxInterProtoGap.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxInterProtoGap.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 75')
cxMcVoxOpeFaxTimerDetectSync = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000)).clone(7500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxTimerDetectSync.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxTimerDetectSync.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65000 Default Value: 7500')
cxMcVoxOpeFaxTimerWaitId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000)).clone(40000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxTimerWaitId.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxTimerWaitId.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 65000 Default Value: 40000')
cxMcVoxOpeFaxMinPreambleDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxMinPreambleDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxMinPreambleDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1000')
cxMcVoxOpeFaxMaxPreambleDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxPreambleDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxPreambleDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 1200')
cxMcVoxOpeFaxMinPreambleDly = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxMinPreambleDly.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxMinPreambleDly.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 400')
cxMcVoxOpeFaxMaxPreambleDly = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxPreambleDly.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxPreambleDly.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 900')
cxMcVoxOpeFaxCedToneDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedToneDetection.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedToneDetection.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 500')
cxMcVoxOpeFaxCedMinToneDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(2600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedMinToneDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedMinToneDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 2600')
cxMcVoxOpeFaxCedMaxToneDur = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedMaxToneDur.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxCedMaxToneDur.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 4000')
cxMcVoxOpeFaxMaxHdlcFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 21, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxHdlcFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeFaxMaxHdlcFlags.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 127 Default Value: 32')
cxMcVoxTimerOpePriv = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23))
cxMcVoxOpeTimerPrivTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1), )
if mibBuilder.loadTexts: cxMcVoxOpeTimerPrivTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimerPrivTable.setDescription('Voice station planned Table.')
cxMcVoxOpeTimerPrivEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxOpeInterfaceType"))
if mibBuilder.loadTexts: cxMcVoxOpeTimerPrivEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimerPrivEntry.setDescription('Voice station planned row definition.')
cxMcVoxOpeInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("em", 1), ("fxs", 2), ("fxo", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeInterfaceType.setDescription('Displays the interface type of the voice I/O port. You cannot modify this object Options: em (1) fxs (2) fxo (3) Default: none')
cxMcVoxOpeTimeSeizeIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeSeizeIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeSeizeIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 50')
cxMcVoxOpeTimeWaitDialOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWaitDialOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWaitDialOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 100')
cxMcVoxOpeTimeWaitDialIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWaitDialIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWaitDialIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 200')
cxMcVoxOpeTimeDialOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeDialOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeDialOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 50')
cxMcVoxOpeTimeDialIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeDialIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeDialIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 30')
cxMcVoxOpeTimeSiOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeSiOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeSiOff.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 300')
cxMcVoxOpeTimeProceed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeProceed.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeProceed.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 30000')
cxMcVoxOpeTimeAnswer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeAnswer.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeAnswer.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 60000')
cxMcVoxOpeTimeBeforeToneOff = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(4000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeBeforeToneOff.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeBeforeToneOff.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 4000')
cxMcVoxOpeTimeWinkStartIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(220)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkStartIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkStartIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 220')
cxMcVoxOpeTimeWinkStartOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkStartOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkStartOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 125')
cxMcVoxOpeTimeWinkMin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(140)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkMin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkMin.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 140')
cxMcVoxOpeTimeWinkMax = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(290)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkMax.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeWinkMax.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 290')
cxMcVoxOpeTimeSeize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeSeize.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeSeize.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 250')
cxMcVoxOpeTimeDial = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(210)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeDial.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeDial.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 210')
cxMcVoxOpeTimeOffIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeOffIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeOffIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 900')
cxMcVoxOpeTimeSiOn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeSiOn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeSiOn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 100')
cxMcVoxOpeTimeOffOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeOffOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeOffOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 150')
cxMcVoxOpeTimeDiscIn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeDiscIn.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeDiscIn.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 250')
cxMcVoxOpeTimeDiscOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(650)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeDiscOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeDiscOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 650')
cxMcVoxOpeTimeToneOut = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 23, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(15000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxOpeTimeToneOut.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeTimeToneOut.setDescription('WARNING: YOU SHOULD NOT MODIFY THIS OBJECT WITHOUT THE SUPERVISION OF MEMOTEC PERSONNEL. Range of Values: 0 to 60000 Default Value: 15000')
cxMcVoxGrpIdAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10), )
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmTable.setDescription('Voice Station Group Id identification Table.')
cxMcVoxGrpIdAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxGrpIdAdmIndex"))
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmEntry.setDescription('Associates an entry in the GroupId table with a pathId-like identifier for that groupId.')
cxMcVoxGrpIdAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmIndex.setDescription('Displays the index number of the administrative Group ID. You cannot modify this object. It is a display that the software provides. Range of Values: 1 to 32 Default Value: none')
cxMcVoxGrpIdAdm = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpIdAdm.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdm.setDescription('Determines the administrative Group ID. The Group ID is a dialing code that the user enters to gain access to a remote telephone or FAX machine. The group contains up to 48 different Path IDs. Each of these Path IDs (i.e. specific routes to a destination) are polled until one of them is available to handle the call. Each of the Path IDs in the group must be on a separate CPU at the destination. Range of Values: 1 to 4 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxGrpIdLenAdm = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdLenAdm.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdLenAdm.setDescription('Determines the length (in digits) of the administrative Group ID. Range of Values: 1 to 4 Default Value: 3 Configuration Changed: administrative')
cxMcVoxGrpIdAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled. Default Value: valid (2) Configuration Changed: administrative')
cxMcVoxGrpIdAdmNbPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmNbPoll.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGrpIdAdmNbPoll.setDescription('Determines the maximum number of remote voice stations in an Extension Group that the local voice station polls with a single call request. Note: This object is only relevant if at least one Remote Extension Group ID has been defined using the objects in the cxMcVox Administrative Grp Group. Range of Values: 1 to 20 Default Value: 4 Configuration Changed: administrative')
cxMcVoxGrpIdOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11), )
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeTable.setDescription('cx Voice Station Group Id identification Table.')
cxMcVoxGrpIdOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxGrpIdOpeIndex"))
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeEntry.setDescription('Associates an entry in the GroupId table with a pathId-like identifier for that groupId.')
cxMcVoxGrpIdOpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeIndex.setDescription('Displays the index number of the operative Group ID. You cannot modify this object. Range of Values: 1 to 32 Default Value: none')
cxMcVoxGrpIdOpe = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdOpe.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdOpe.setDescription('Displays the operative Group ID. The Group ID is a dialing code the user enters to gain access to the remote telephone or FAX machine. The Group ID contains up to 48 different Path IDs. Each of these Path IDs (i.e. specific routes to a destination) are polled until one of them is available to handle the call. Each of the Path IDs in the group must be on a separate CPU at the destination. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxGrpIdAdm of the cxMcVox Administrative Group ID Identificastion Group. Range of Values: 1 to 4 numeric digits Default Value: none')
cxMcVoxGrpIdLenOpe = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdLenOpe.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpIdLenOpe.setDescription('Determines the length (in digits) of the operative Group ID. You cannot moify this object. If you want to change the value you must modify the object cxMcVoxGrpIdLenAdm of the cxMcVox Administrative GROUPID identification group Range of Values: 1 to 4 Default Value: 3')
cxMcVoxGrpIdOpeNbPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeNbPoll.setStatus('optional')
if mibBuilder.loadTexts: cxMcVoxGrpIdOpeNbPoll.setDescription('Determines the maximum number of remote voice stations in an Extension Group that the local voice station polls with a single call request. Note: This object is only relevant if at least one Remote Extension Group ID has been defined using the objects in the cxMcVox Operative Grp Group. Range of Values: 1 to 20 Default Value: 4 Configuration Changed: operative')
cxMcVoxGrpDefAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12), )
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmTable.setDescription('Planned GroupID definition table.')
cxMcVoxGrpDefAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxGrpDefAdmIndex"), (0, "CXMCVOX-MIB", "cxMcVoxGrpDefAdmPriority"))
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmEntry.setDescription('Planned GroupID row definition.')
cxMcVoxGrpDefAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmIndex.setDescription('Displays the index number of the administrative Group ID. You cannot modify this object. Range of Values: 1 to 32 Default Value: none')
cxMcVoxGrpDefAdmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmPriority.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmPriority.setDescription('Displays the polling priority level of the administrative Path ID. When the user places a call by entering the Group ID, all Path IDs that you include in the group will be polled according to their priority until one is available to handle the call. You add a Path ID to a Group ID using the object cxMcVoxGrpDefAdmPathId of this table. You cannot modify this object. Range of Values: 1 to 48. A value of 1 assigns the highest priority to the Path ID. Default Value: none')
cxMcVoxGrpDefAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled. Default: valid (2) Configuration Changed: administrative')
cxMcVoxGrpDefAdmPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmPathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmPathId.setDescription('Determines the Path ID you want to include in the administrative Group ID. When you include a Path ID in the Group ID, the software automatically assigns a polling priority to it (see the object cxMcVoxGrpDefAdmPriority of this table). When the user places a call by entering the Group ID, all Path IDs that you include in the group will be polled according to their priority until one is available to handle the call. Range of Values: 1 to 4 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxGrpDefAdmRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 12, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefAdmRmtExt.setDescription('Determines the Remote Extension that you want to include in the Group ID. When you include a Remote Extension in the Group ID, the software automatically assigns a polling priority to it (see the object cxMcVoxGrpDefAdmPriority of this table). When the user places a call by entering the Group ID, all Remote Extensions that you include in the group will be polled according to their priority until one is available to handle the call. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxGrpDefOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13), )
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeTable.setDescription('Active GroupID definition table.')
cxMcVoxGrpDefOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxGrpDefOpeIndex"), (0, "CXMCVOX-MIB", "cxMcVoxGrpDefOpePriority"))
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeEntry.setDescription('Active GroupID row definition.')
cxMcVoxGrpDefOpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeIndex.setDescription('Displays the index number of the operative Group ID. You cannot modify this object. Range of Values: 1 to 32 Default Value: none')
cxMcVoxGrpDefOpePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefOpePriority.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpePriority.setDescription('Displays the polling priority level of the operative Path ID. When the user places a call by entering the Group ID, all Path IDs that you include in the group will be polled according to their priority until one is available to handle the call. You add a Path ID to a Group ID using the object cxMcVoxGrpDefAdmPathId of the cxMcVox Administrative Grp Group. You cannot modify this object Range of Values: 1 to 48. A value of 1 assigns the highest priority to the Path ID. Default Value: none')
cxMcVoxGrpDefOpePathId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefOpePathId.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpePathId.setDescription('Displays the Path ID included in the operative Group ID. When you include a Path ID in the Group ID, the software automatically assigns a polling priority to it (see the object cxMcVoxGrpDefAdmPriority of this table). When the user places a call by entering the Group ID, all Path IDs that you include in the group will be polled according to their priority until one is available to handle the call. You cannot modify this object. If you want to change the value you must modify the object cxMcVoxGrpDefAdmPathId of the cxMcVox Administrative GRP Group Range of Values: 1 to 4 numeric digits Default Value: none')
cxMcVoxGrpDefOpeRmtExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 13, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeRmtExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxGrpDefOpeRmtExt.setDescription('Determines the Remote Extension that you want to include in the Group ID. When you include a Remote Extension in the Group ID, the software automatically assigns a polling priority to it (see the object cxMcVoxGrpDefOpePriority of this table). When the user places a call by entering the Group ID, all Remote Extensions that you include in the group will be polled according to their priority, until one is available to handle the call. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: operative')
cxMcVoxAdmPinTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 14), )
if mibBuilder.loadTexts: cxMcVoxAdmPinTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPinTable.setDescription('Personal identification number Table.')
cxMcVoxAdmPinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 14, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxAdmPinIndex"))
if mibBuilder.loadTexts: cxMcVoxAdmPinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPinEntry.setDescription('Personal identification number row definition.')
cxMcVoxAdmPinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxAdmPinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPinIndex.setDescription('Displays the index number of the Personal Identification Number (PIN). You cannot modify this object. Range of Values: 1 to 256 Default Value: none')
cxMcVoxAdmPinCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmPinCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPinCode.setDescription('Determines the Personal Identification Number (PIN) that is validated by the local voice station prior to a call being established. The local voice station verifies that the PIN included in the call request packet is listed in its PIN table. If it is not,the call will not be established and the user will hear a fast busy signal. Range of Values: 2 to 8 digits from 0 to 9 Default Value: none')
cxMcVoxAdmPinRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmPinRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmPinRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled Default Value: none')
cxMcVoxOpePinTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 15), )
if mibBuilder.loadTexts: cxMcVoxOpePinTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePinTable.setDescription('Personal identification number Table.')
cxMcVoxOpePinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 15, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxOpePinIndex"))
if mibBuilder.loadTexts: cxMcVoxOpePinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePinEntry.setDescription('Personal identification number row definition.')
cxMcVoxOpePinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpePinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePinIndex.setDescription('Displays the index number of the Personal identification Number (PIN). You cannot modify this object. Range of Values: 1 to 256. Default Value: none')
cxMcVoxOpePinCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpePinCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpePinCode.setDescription('Displays the Personal Identification Number (PIN) that is validated by the local voice station prior to a call being established. The local voice station verifies that the PIN included in the call request packet is listed in its PIN table. If it is not,the call will not be established and the user will hear a fast busy signal. Range of Values: 2 to 8 digits from 0 to 9 Default Value: none')
cxMcVoxAdmLclZoneTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16), )
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneTable.setDescription('Local Zone Codes Table.')
cxMcVoxAdmLclZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxAdmLclZoneIndex"))
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneEntry.setDescription('Local Zones codes row definition.')
cxMcVoxAdmLclZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneIndex.setDescription('Displays the index number of the administrative local zone code. Range of Values: 1 to 128. Default Value: none')
cxMcVoxAdmLclZoneCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneCode.setDescription('Determines the number of the administrative local zone code which will serve in the verification of the phone number to be dialed depending on where the remote site is installed. Range of Values: 1 to 4 digits from 0 to 9 Note: The * character is used as a wildcard character. Only one wildcard character can be used per zone code. Default Value: none')
cxMcVoxAdmLclZoneLng = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneLng.setDescription('Determines the length (in digits) of the administrative local zone code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxAdmLclZoneRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxAdmLclZoneRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled Default Value: none')
cxMcVoxOpeLclZoneTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 17), )
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneTable.setDescription('Local Zones Codes Table.')
cxMcVoxOpeLclZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 17, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxOpeLclZoneIndex"))
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneEntry.setDescription('Local Zones codes row definition.')
cxMcVoxOpeLclZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneIndex.setDescription('Displays the index number of the operational local zone code. Range of Values: 1 to 128. Default Value: none')
cxMcVoxOpeLclZoneCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 17, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneCode.setDescription('Displays the number of the operational local zone code which will serve in the verification of the phone number to be dialed depending on where the remote CX1000 is installed. You cannot modify this object. If you want to change the code you must change the setting of the cxMcVoxAdmLclZoneCode object in the cxMcVox Administrative Zone Codes Group. Range of Values: 1 to 4 digits from 0 to 9 Note: The * character is used as a wildcard character. Only one wildcard character can be used per zone code. Default Value: none')
cxMcVoxOpeLclZoneLng = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxOpeLclZoneLng.setDescription('Displays the length (in digits) of the operational local zone code. You cannot modify this object. If you want to change the length you must change the setting of the object cxMcVoxAdmLclZoneLng of the cxMccVox Administrative Local Zone Codes Group. Range of Values: 1 to 4 Default Value: none')
cxMcVoxAdmRTC = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18))
cxMcVoxAdmRTCCountry = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCCountry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCCountry.setDescription('The CX900 does not currently support this object. Determines the number of the administrative local country code which will serve in the verification of the phone number to be dialed depending on where the remote CX1000 is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxAdmRTCCountryLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCCountryLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCCountryLng.setDescription('The CX900 does not currently support this object. Determines the length (in digits) of the administrative local country code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxAdmRTCNonLclCountry = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclCountry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclCountry.setDescription('The CX900 does not currently support this object. Determines the number of the administrative local country code which will be inserted in front of the Country Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxAdmRTCNonLclCountryLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclCountryLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclCountryLng.setDescription('The CX900 does not currently support this object. Determines the length (in digits) of the administrative non local country code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxAdmRTCArea = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCArea.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCArea.setDescription('The CX900 does not currently support this object. Determines the number of the administrative local area code which will serve in the verification of the phone number to be dialed depending on where the remote CX1000 is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxAdmRTCAreaLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCAreaLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCAreaLng.setDescription('The CX900 does not currently support this object. Determines the length (in digits) of the administrative local area code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxAdmRTCNonLclArea = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclArea.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclArea.setDescription('The CX900 does not currently support this object. Determines the number of the administrative local area code which will be inserted in front of the Area Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxAdmRTCNonLclAreaLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclAreaLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclAreaLng.setDescription('The CX900 does not currently support this object. Determines the length (in digits) of the administrative non local area code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxAdmRTCNonLclZone = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclZone.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclZone.setDescription('The CX900 does not currently support this object. Determines the number of the administrative local zone code which will be inserted in front of the Zone Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxAdmRTCNonLclZoneLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 18, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclZoneLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxAdmRTCNonLclZoneLng.setDescription('The CX900 does not currently support this object. Determines the length (in digits) of the administrative non local zone code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxOpeRTC = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19))
cxMcVoxOpeRTCCountry = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCCountry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCCountry.setDescription('The CX900 does not currently support this object. Displays the number of the operative local country code which will serve in the verification of the phone number to be dialed depending on where the remote CX1000 is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none.')
cxMcVoxOpeRTCCountryLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCCountryLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCCountryLng.setDescription('The CX900 does not currently support this object. Displays the length (in digits) of the operative local country code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxOpeRTCNonLclCountry = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclCountry.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclCountry.setDescription('The CX900 does not currently support this object. Displays the number of the operative local country code which will be inserted in front of the Country Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxOpeRTCNonLclCountryLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclCountryLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclCountryLng.setDescription('The CX900 does not currently support this object. Displays the length (in digits) of the operative non local country code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxOpeRTCArea = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCArea.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCArea.setDescription('The CX900 does not currently support this object. Displays the number of the operative local area code which will serve in the verification of the phone number to be dialed depending on where the remote CX1000 is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxOpeRTCAreaLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCAreaLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCAreaLng.setDescription('The CX900 does not currently support this object. Displays the length (in digits) of the operative local area code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxOpeRTCNonLclArea = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclArea.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclArea.setDescription('The CX900 does not currently support this object. Displays the number of the operative local area code which will be inserted in front of the Area Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxOpeRTCNonLclAreaLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclAreaLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclAreaLng.setDescription('The CX900 does not currently support this object. Displays the length (in digits) of the operative non local area code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxOpeRTCNonLclZone = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclZone.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclZone.setDescription('The CX900 does not currently support this object. Displays the number of the operative local zone code which will be inserted in front of the Zone Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxOpeRTCNonLclZoneLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 19, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclZoneLng.setStatus('deprecated')
if mibBuilder.loadTexts: cxMcVoxOpeRTCNonLclZoneLng.setDescription('The CX900 does not currently support this object. Displays the length (in digits) of the operative non local zone code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxDiagTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24), )
if mibBuilder.loadTexts: cxMcVoxDiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagTable.setDescription('Voice station diagnostics and events Table.')
cxMcVoxDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxDiagCardIndex"), (0, "CXMCVOX-MIB", "cxMcVoxDiagPortIndex"))
if mibBuilder.loadTexts: cxMcVoxDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagEntry.setDescription('')
cxMcVoxDiagCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxDiagCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagCardIndex.setDescription('')
cxMcVoxDiagPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxDiagPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagPortIndex.setDescription('')
cxMcVoxDiagScvEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagScvEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagScvEvents.setDescription('')
cxMcVoxDiagGsdEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagGsdEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagGsdEvents.setDescription('')
cxMcVoxDiagToneInEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagToneInEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagToneInEvents.setDescription('')
cxMcVoxDiagToneOutEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagToneOutEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagToneOutEvents.setDescription('')
cxMcVoxDiagFaxInEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagFaxInEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagFaxInEvents.setDescription('')
cxMcVoxDiagFaxOutEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagFaxOutEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagFaxOutEvents.setDescription('')
cxMcVoxDiagGlmEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagGlmEvents.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagGlmEvents.setDescription('')
cxMcVoxDiagIbvDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagIbvDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagIbvDiags.setDescription('')
cxMcVoxDiagPcvDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagPcvDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagPcvDiags.setDescription('')
cxMcVoxDiagGcvDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagGcvDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagGcvDiags.setDescription('')
cxMcVoxDiagFaxDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagFaxDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagFaxDiags.setDescription('')
cxMcVoxDiagLseDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagLseDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagLseDiags.setDescription('')
cxMcVoxDiagScvDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagScvDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagScvDiags.setDescription('')
cxMcVoxDiagGlmDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 24, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-action", 1), ("trigger", 2), ("reset", 3))).clone('no-action')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxDiagGlmDiags.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxDiagGlmDiags.setDescription('')
cxMcVoxDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 25))
cxMcVoxLclExtAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26), )
if mibBuilder.loadTexts: cxMcVoxLclExtAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmTable.setDescription('Planned Local Extensions table.')
cxMcVoxLclExtAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxLclExtAdmIndex"))
if mibBuilder.loadTexts: cxMcVoxLclExtAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmEntry.setDescription('Planned Local Extensions row definition.')
cxMcVoxLclExtAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxLclExtAdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmIndex.setDescription('Displays the index number of the Remote Extension. You cannot modify this object. Range of Values: 1 to 64 Default Value: none')
cxMcVoxLclExtAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxLclExtAdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged; after the next reset the values are disabled and the row is deleted from the table. valid (2): values are enabled. Default Value: none Configuration Changed: administrative')
cxMcVoxLclExtAdmExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxLclExtAdmExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmExt.setDescription('Determines the numeric dialing code to be dialed by remote located parties to access the local telephone or fax machine. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: administrative')
cxMcVoxLclExtAdmHuntChnl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 26, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1073741823)).clone(1073741823)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxLclExtAdmHuntChnl.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtAdmHuntChnl.setDescription('Defines the local voice channels to be polled (hunted) during call establishment with the Local Extension (specified by object cxMcVoxLclExtAdmExt). This value acts as a mask so that all specified channels are polled until the call is accepted. This hunt channel mask includes a maximum of 30 voice channels. The default value includes all local voice channels. If you want to exclude specific channels, calculate the value by following these steps: 1. Decide which ports to include, for example, 1,5,8,29. 2. Convert the list of ports to a series of bits. Start with a list of 30 zeros. 00 0000 0000 0000 0000 0000 0000 0000 To include ports 1, 5, 8, and 29, place 1s in these positions. Numbering starts at 1 at the extreme right. 01 0000 0000 0000 0000 0000 1001 0001 3. Convert this number to hexadecimal. 10000091 4. Convert this number to decimal. 268 435 601 Range of Values: 1 to 1073741823 Default Value: 1073741823 Configuration Changed: administrative')
cxMcVoxLclExtOpeTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 27), )
if mibBuilder.loadTexts: cxMcVoxLclExtOpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtOpeTable.setDescription('Active Local Extensions table.')
cxMcVoxLclExtOpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 27, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxLclExtOpeIndex"))
if mibBuilder.loadTexts: cxMcVoxLclExtOpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtOpeEntry.setDescription('Active Local Extensions row definition.')
cxMcVoxLclExtOpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 27, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxLclExtOpeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtOpeIndex.setDescription('Displays the index number of the Remote Extension. You cannot modify this object. Range of Values: 1 to 64 Default Value: none')
cxMcVoxLclExtOpeExt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 27, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxLclExtOpeExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtOpeExt.setDescription('Determines the numeric dialing code to be dialed by remote located parties to access the local telephone or fax machine. Range of Values: 1 to 5 numeric digits Default Value: none Configuration Changed: operational')
cxMcVoxLclExtOpeHuntChnl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 27, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1073741823)).clone(1073741823)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxLclExtOpeHuntChnl.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxLclExtOpeHuntChnl.setDescription('Defines the local voice channels to be polled (hunted) during call establishment with the Local Extension (specified by object cxMcVoxLclExtAdmExt). This value acts as a mask so that all specified channels are polled until the call is accepted. This hunt channel mask includes a maximum of 30 voice channels. The default value includes all local voice channels. If you want to exclude specific channels, calculate the value by following these steps: 1. Decide which ports to include, for example, 1,5,8,29. 2. Convert the list of ports to a series of bits. Start with a list of 30 zeros. 00 0000 0000 0000 0000 0000 0000 0000 To include ports 1, 5, 8, and 29, place 1s in these positions. Numbering starts at 1 at the extreme right. 01 0000 0000 0000 0000 0000 1001 0001 3. Convert this number to hexadecimal. 10000091 4. Convert this number to decimal. 268 435 601 Range of Values: 1 to 1073741823 Default Value: 1073741823 Configuration Changed: operational')
cxMcVoxRegenOpe = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 28))
cxMcVoxRegenOpeExt = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 28, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxRegenOpeExt.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxRegenOpeExt.setDescription('The RegenOpeExt is used to specify if the local extension tones are to be regenerated.')
cxMcVoxRegenOpeGid = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 28, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxRegenOpeGid.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxRegenOpeGid.setDescription('The RegenOpeGid is used to specify if the group ids tones are to be regenerated.')
cxMcVoxRegenOpeNbDigits = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 28, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxRegenOpeNbDigits.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxRegenOpeNbDigits.setDescription('The number of digits to be regenerated.')
cxMcVoxRegenOpeExtBitMask = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 28, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxRegenOpeExtBitMask.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxRegenOpeExtBitMask.setDescription('This object is a bitmap that selects up to cxMcVoxRegenOpeNbDigits, which can be set up to 8 digits, corresponding to a bit that is set. The default value corresponds to 7 (or 00000111 in binary). Range of Values: 0 to 255 Default Value: 7')
cxMcVoxTranslOpe = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29))
cxMcVoxTranslOpeCntryCodeEnable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCodeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCodeEnable.setDescription('This specifies whether to translate the local country code.')
cxMcVoxTranslOpeCntryCode = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCode.setDescription('Displays the number of the operational local country code which will serve in the verification of the phone number to be dialed depending on where the remote site is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none.')
cxMcVoxTranslOpeCntryCodeLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCodeLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeCntryCodeLng.setDescription('Displays the length (in digits) of the operational local country code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxTranslOpeCCPrefix = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeCCPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeCCPrefix.setDescription('Displays the number of the operational local country code which will be inserted in front of the Country Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxTranslOpeCCPrefixLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxTranslOpeCCPrefixLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeCCPrefixLng.setDescription('Displays the length (in digits) of the operational non local country code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxTranslOpeAreaCodeEnable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCodeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCodeEnable.setDescription('This specifies whether to translate the local area code.')
cxMcVoxTranslOpeAreaCode = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('514')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCode.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCode.setDescription('Displays the number of the operational local area code which will serve in the verification of the phone number to be dialed depending on where the remote site is installed. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxTranslOpeAreaCodeLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCodeLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeAreaCodeLng.setDescription('Displays the length (in digits) of the operational local area code. Range of Values: 1 to 4. Default Value: none')
cxMcVoxTranslOpeACPrefix = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeACPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeACPrefix.setDescription('Displays the number of the operational local area code which will be inserted in front of the Area Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxTranslOpeACPrefixLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxTranslOpeACPrefixLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeACPrefixLng.setDescription('Displays the length (in digits) of the operational non local area code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxTranslOpeZoneCodeEnable = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeZoneCodeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeZoneCodeEnable.setDescription('This specifies whether to translate the local zone code.')
cxMcVoxTranslOpeZCPrefix = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone('7')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxMcVoxTranslOpeZCPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeZCPrefix.setDescription('Displays the number of the operational local zone code which will be inserted in front of the Zone Code if the latter does not correspond to the local country code parameter. Range of Values: 1 to 4 digits from 0 to 9 Default Value: none')
cxMcVoxTranslOpeZCPrefixLng = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 29, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxTranslOpeZCPrefixLng.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxTranslOpeZCPrefixLng.setDescription('Displays the length (in digits) of the operational non local zone code. Range of Values: 1 to 4 Default Value: none')
cxMcVoxHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30), )
if mibBuilder.loadTexts: cxMcVoxHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryTable.setDescription('OnLine/OffLine history table for incoming/outgoing calls.')
cxMcVoxHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1), ).setIndexNames((0, "CXMCVOX-MIB", "cxMcVoxHistoryIndex"))
if mibBuilder.loadTexts: cxMcVoxHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryEntry.setDescription('Online/Offline history row definition.')
cxMcVoxHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryIndex.setDescription('The index number of the history log.')
cxMcVoxHistoryLclCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryLclCardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryLclCardNumber.setDescription("Displays the voice I/O card slot displacement from the CPU card slot. As an example on the CX1000, card number 1 is directly behind the CPU card and card number 2 is one slot up. In the case of the CX900 product, this card number represents the logical slot corresponding to its physical slot as mapped in the 'voxcard' table. You cannot modify this object. Range of Values: 1 to 4 Default Value: none")
cxMcVoxHistoryLclPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryLclPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryLclPortNumber.setDescription('Displays the number of the voice I/O port. You cannot modify this object. Range of Values: 1 to 15 Default Value: none')
cxMcVoxHistoryRmtCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryRmtCardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryRmtCardNumber.setDescription('Displays the remote voice I/O card slot displacement from the CPU card slot. As an example on the CX1000, card number 1 is directly behind th You cannot modify this object. Range of Values: 1 to 4 Default Value: none')
cxMcVoxHistoryRmtPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryRmtPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryRmtPortNumber.setDescription('Displays the number of the voice I/O port that was reached at the remote location. You cannot modify this object. Range of Values: 1 to 15 Default Value: none')
cxMcVoxHistoryTimeStampOnLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryTimeStampOnLine.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryTimeStampOnLine.setDescription('Displays the time stamp of the last on-line event. An on-line event is any incoming or outgoing call that is started. The time stamp indicates the number of seconds elapsed since the last power up. You cannot modify this object. Range of Values: 1 to 4294967295 Default Value: none')
cxMcVoxHistoryTimeStampOffLine = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryTimeStampOffLine.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryTimeStampOffLine.setDescription('Displays the time stamp of the last off-line event. An off-line event is any incoming or outgoing call that the voice station terminates. The time stamp indicates the number of seconds elapsed since the last power up. You cannot modify this object. Range of Values: 1 to 4294967295 Default Value: none')
cxMcVoxHistoryLnkState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16)).clone('CallAborted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryLnkState.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryLnkState.setDescription("Displays the status of the link to the remote user. When the call is successful the status is either 'Incoming' or 'Outgoing'. Else the error type is displayed. You cannot modify this object. Options: Connection established: either 'Incoming' or 'Outgoing' Local port unavailable: 'LclPortUnavail' Remote extension unavailable: 'RmtExtUnavail' Remote ports busy: 'RmtPortsBusy' Invalid PIN: 'InvalidPIN' Call aborted: 'CallAborted' Default Value: 'CallAborted'")
cxMcVoxHistoryPin = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryPin.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryPin.setDescription('Displays the Personal Identification Number (PIN) that is validated against the local voice station card PIN number table. Range of Values: 2 to 8 numeric digits, each number from 0 to 9 Default Value: none')
cxMcVoxHistoryExtensionOrGrpId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryExtensionOrGrpId.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryExtensionOrGrpId.setDescription('Displays the extension or group ID the remote user has dialed to reach the local user. This object is irrelevant for outgoing calls. You cannot modify this object. Range of Values: 1 to 4 numeric digits Default Value: none')
cxMcVoxHistoryPhoneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2, 30, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxMcVoxHistoryPhoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cxMcVoxHistoryPhoneNumber.setDescription('For outgoing calls, this object displays the complete phone number (including any voice mail digits) the user entered to reach the remote user. This can include access code, country code, area code and zone code but excludes PIN number. For incoming calls, this object displays either the regenerated code or the translated code (or both). Codes that are dialed after the extension or group ID are also logged in this object both for outgoing and incoming calls. You cannot modify this object. Range of Values: 1 to 24 numeric digits Default Value: none')
cxMcVoxTrapStatus = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2) + (0,1)).setObjects(("CXModuleHardware-MIB", "cxModuleHwPhysSlot"), ("CXMCVOX-MIB", "cxMcVoxStatusCardNumber"), ("CXMCVOX-MIB", "cxMcVoxStatusPortNumber"), ("CXMCVOX-MIB", "cxMcVoxStatusPortStatus"))
if mibBuilder.loadTexts: cxMcVoxTrapStatus.setDescription('Reports that there is a change in the functional state of the voice channel. cxMcVoxTrapStatus = 1 if the port is disabled cxMcVoxTrapStatus = 2 if the port is enabled cxMcVoxTrapStatus = 3 if there is no I/O hardware')
cxMcVoxTrapRing = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2) + (0,2)).setObjects(("CXModuleHardware-MIB", "cxModuleHwPhysSlot"), ("CXMCVOX-MIB", "cxMcVoxGlobalTensionRing"))
if mibBuilder.loadTexts: cxMcVoxTrapRing.setDescription('Reports that there is a change in the functional state of the ring generator power supply. cxMcVoxTrapRing = 2 if the ringing generator is good cxMcVoxTrapRing = 1 otherwise')
cxMcVoxTrapDc = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2) + (0,3)).setObjects(("CXModuleHardware-MIB", "cxModuleHwPhysSlot"), ("CXMCVOX-MIB", "cxMcVoxGlobalTensionDc"))
if mibBuilder.loadTexts: cxMcVoxTrapDc.setDescription('Reports that there is a change in the functional state of the DC power supply. cxMcVoxGlobalTensionDc = 2 if the DC power supply is good cxMcVoxGlobalTensionDc = 1 otherwise')
cxMcVoxHistoryTrap = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 1, 2) + (0,4)).setObjects(("CXModuleHardware-MIB", "cxModuleHwPhysSlot"), ("CXMCVOX-MIB", "cxMcVoxHistoryIndex"), ("CXMCVOX-MIB", "cxMcVoxGlobalHistoryMaxNumberOfEntries"))
if mibBuilder.loadTexts: cxMcVoxHistoryTrap.setDescription('Informs the management station of the fact that the history table needs servicing.')
mibBuilder.exportSymbols("CXMCVOX-MIB", cxMcVoxCfgTrapOffLine=cxMcVoxCfgTrapOffLine, cxMcVoxAdmPinEntry=cxMcVoxAdmPinEntry, cxMcVoxPathAdmLng=cxMcVoxPathAdmLng, cxMcVoxEmAdmRmtId=cxMcVoxEmAdmRmtId, cxMcVoxOpeFaxPreambleDelay=cxMcVoxOpeFaxPreambleDelay, cxMcVoxDriverOpe=cxMcVoxDriverOpe, cxMcVoxGlobalReinitRouting=cxMcVoxGlobalReinitRouting, cxMcVoxTimerOpePriv=cxMcVoxTimerOpePriv, cxMcVoxStatusIoAccess=cxMcVoxStatusIoAccess, cxMcVoxAdmPulseTmin=cxMcVoxAdmPulseTmin, cxMcVoxHistoryTrap=cxMcVoxHistoryTrap, cxMcVoxTranslOpeCntryCodeEnable=cxMcVoxTranslOpeCntryCodeEnable, cxMcVoxGlobalClearRmtExt=cxMcVoxGlobalClearRmtExt, cxMcVoxFxsOpePortUsed=cxMcVoxFxsOpePortUsed, cxMcVoxGlobalSoftRev=cxMcVoxGlobalSoftRev, cxMcVoxNetOpeRemVoxStation=cxMcVoxNetOpeRemVoxStation, cxMcVoxNetOpeRemStationId=cxMcVoxNetOpeRemStationId, cxMcVoxDiagFaxDiags=cxMcVoxDiagFaxDiags, cxMcVoxAdmFaxTimerDetectSync=cxMcVoxAdmFaxTimerDetectSync, cxMcVoxFxoAdmCnctType=cxMcVoxFxoAdmCnctType, cxMcVoxGlobalReinitPinTable=cxMcVoxGlobalReinitPinTable, cxMcVoxFxoOpeAutoCnx=cxMcVoxFxoOpeAutoCnx, cxMcVoxNetAdmRemVoxStation=cxMcVoxNetAdmRemVoxStation, cxMcVoxAdmRTCCountry=cxMcVoxAdmRTCCountry, cxMcVoxOpeRTCNonLclZone=cxMcVoxOpeRTCNonLclZone, cxMcVoxTranslOpeZCPrefixLng=cxMcVoxTranslOpeZCPrefixLng, cxMcVoxAdmFaxPreambleDuration=cxMcVoxAdmFaxPreambleDuration, cxMcVoxAdmRTCNonLclArea=cxMcVoxAdmRTCNonLclArea, cxMcVoxEmOpeVoiceConnection=cxMcVoxEmOpeVoiceConnection, cxMcVoxFxsAdmCardUsed=cxMcVoxFxsAdmCardUsed, cxMcVoxTranslOpeACPrefix=cxMcVoxTranslOpeACPrefix, cxMcVoxStatusInputDbmLevel=cxMcVoxStatusInputDbmLevel, cxMcVoxFxsOpeRingType=cxMcVoxFxsOpeRingType, cxMcVoxStatusEntry=cxMcVoxStatusEntry, cxMcVoxEmAdmFaxBw=cxMcVoxEmAdmFaxBw, cxMcVoxGrpIdOpe=cxMcVoxGrpIdOpe, cxMcVoxOpeTimerPrivEntry=cxMcVoxOpeTimerPrivEntry, cxMcVoxOpeRTCNonLclZoneLng=cxMcVoxOpeRTCNonLclZoneLng, cxMcVoxAdmRTCCountryLng=cxMcVoxAdmRTCCountryLng, cxMcVoxStatusChannelAccess=cxMcVoxStatusChannelAccess, cxMcVoxOpeFlashTmax=cxMcVoxOpeFlashTmax, cxMcVoxHistoryEntry=cxMcVoxHistoryEntry, cxMcVoxFxoAdmTranspMode=cxMcVoxFxoAdmTranspMode, cxMcVoxHistoryLclCardNumber=cxMcVoxHistoryLclCardNumber, cxMcVoxFxsAdmTranspMode=cxMcVoxFxsAdmTranspMode, cxMcVoxEmOpeAc15TimeOff=cxMcVoxEmOpeAc15TimeOff, cxMcVoxEmOpeEchoCancel=cxMcVoxEmOpeEchoCancel, cxMcVoxAdmRingTimeOff2=cxMcVoxAdmRingTimeOff2, cxMcVoxFxsOpeAutoCnx=cxMcVoxFxsOpeAutoCnx, cxMcVoxEmOpeVocoder=cxMcVoxEmOpeVocoder, cxMcVoxHistoryLclPortNumber=cxMcVoxHistoryLclPortNumber, cxMcVoxOpeToneOffsetTxGain=cxMcVoxOpeToneOffsetTxGain, cxMcVoxEventPin=cxMcVoxEventPin, cxMcVoxEmAdmSignalType=cxMcVoxEmAdmSignalType, cxMcVoxAdmFlashTgen=cxMcVoxAdmFlashTgen, cxMcVoxAdmRingTimeOff1=cxMcVoxAdmRingTimeOff1, cxMcVoxGlobalHistoryMaxNumberOfEntries=cxMcVoxGlobalHistoryMaxNumberOfEntries, cxMcVoxHistoryTable=cxMcVoxHistoryTable, cxMcVoxHistoryPhoneNumber=cxMcVoxHistoryPhoneNumber, cxMcVoxGlobalAdmPathLng=cxMcVoxGlobalAdmPathLng, cxMcVoxFxsOpeTimeOff=cxMcVoxFxsOpeTimeOff, cxMcVoxAdmCardUsed=cxMcVoxAdmCardUsed, cxMcVoxFxoAdmAutoCnx=cxMcVoxFxoAdmAutoCnx, cxMcVoxTrapDc=cxMcVoxTrapDc, cxMcVoxGlobalForceDefConfig=cxMcVoxGlobalForceDefConfig, cxMcVoxFxsAdmTxGain=cxMcVoxFxsAdmTxGain, cxMcVoxStateTable=cxMcVoxStateTable, cxMcVoxEmAdmPortStatus=cxMcVoxEmAdmPortStatus, cxMcVoxGrpDefAdmRowStatus=cxMcVoxGrpDefAdmRowStatus, cxMcVoxEmOpeEntry=cxMcVoxEmOpeEntry, cxMcVoxOpeFaxMaxPreambleDur=cxMcVoxOpeFaxMaxPreambleDur, cxMcVoxNetAdmRowStatus=cxMcVoxNetAdmRowStatus, cxMcVoxEmOpeRmtExt=cxMcVoxEmOpeRmtExt, cxMcVoxCfgTrapState=cxMcVoxCfgTrapState, cxMcVoxOpeTimeDialIn=cxMcVoxOpeTimeDialIn, cxMcVoxGrpDefAdmEntry=cxMcVoxGrpDefAdmEntry, cxMcVoxOpeRTC=cxMcVoxOpeRTC, cxMcVoxNetAdmTable=cxMcVoxNetAdmTable, cxMcVoxEmOpePortStatus=cxMcVoxEmOpePortStatus, cxMcVoxEmOpeAutoCnx=cxMcVoxEmOpeAutoCnx, cxMcVoxGlobalTrapHistory=cxMcVoxGlobalTrapHistory, cxMcVoxFxsAdmRmtExt=cxMcVoxFxsAdmRmtExt, cxMcVoxOpeFaxMaxPreambleDly=cxMcVoxOpeFaxMaxPreambleDly, cxMcVoxAdmToneOffsetTxGain=cxMcVoxAdmToneOffsetTxGain, cxMcVoxOpeRTCNonLclArea=cxMcVoxOpeRTCNonLclArea, cxMcVoxFxoOpeRxGain=cxMcVoxFxoOpeRxGain, cxMcVoxFxoOpePathId=cxMcVoxFxoOpePathId, cxMcVoxCfgReinitPort=cxMcVoxCfgReinitPort, cxMcVoxPathOpeEntry=cxMcVoxPathOpeEntry, cxMcVoxOpeLclZoneIndex=cxMcVoxOpeLclZoneIndex, cxMcVoxOpeToneDelayAfterFlash=cxMcVoxOpeToneDelayAfterFlash, cxMcVoxOpeAc15InterDigit=cxMcVoxOpeAc15InterDigit, cxMcVoxCfgEntry=cxMcVoxCfgEntry, cxMcVoxFxoAdmTxGain=cxMcVoxFxoAdmTxGain, cxMcVoxDiagLseDiags=cxMcVoxDiagLseDiags, cxMcVoxAdmDtmfTxTimeOff=cxMcVoxAdmDtmfTxTimeOff, cxMcVoxGlobalGlmMaxTimeToTxReq=cxMcVoxGlobalGlmMaxTimeToTxReq, cxMcVoxGrpDefOpeTable=cxMcVoxGrpDefOpeTable, cxMcVoxOpeTimeProceed=cxMcVoxOpeTimeProceed, cxMcVoxFxsOpeTranspMode=cxMcVoxFxsOpeTranspMode, cxMcVoxHistoryExtensionOrGrpId=cxMcVoxHistoryExtensionOrGrpId, cxMcVoxGlobalOpeEnablePinTable=cxMcVoxGlobalOpeEnablePinTable, cxMcVoxOpeInterfaceType=cxMcVoxOpeInterfaceType, cxMcVoxOpeTimeDiscIn=cxMcVoxOpeTimeDiscIn, cxMcVoxFxsAdmBroadcast=cxMcVoxFxsAdmBroadcast, cxMcVoxGrpIdOpeIndex=cxMcVoxGrpIdOpeIndex, cxMcVoxStatusPhyIfType=cxMcVoxStatusPhyIfType, cxMcVoxEmAdmVoiceConnection=cxMcVoxEmAdmVoiceConnection, cxMcVoxGrpDefAdmPathId=cxMcVoxGrpDefAdmPathId, cxMcVoxGlobalGlmSupervSilenceTime=cxMcVoxGlobalGlmSupervSilenceTime, cxMcVoxGlobalLseTimerT2=cxMcVoxGlobalLseTimerT2, cxMcVoxFxsAdmFaxEnable=cxMcVoxFxsAdmFaxEnable, cxMcVoxAdmAc15InterDigit=cxMcVoxAdmAc15InterDigit, cxMcVoxOpeRTCArea=cxMcVoxOpeRTCArea, cxMcVoxEmOpePortUsed=cxMcVoxEmOpePortUsed, cxMcVoxDiagFaxInEvents=cxMcVoxDiagFaxInEvents, cxMcVoxCfgClearPort=cxMcVoxCfgClearPort, cxMcVoxFxoAdmSignaling=cxMcVoxFxoAdmSignaling, cxMcVoxEmOpeSignalType=cxMcVoxEmOpeSignalType, cxMcVoxEventTable=cxMcVoxEventTable, cxMcVoxOpeMfToneThold=cxMcVoxOpeMfToneThold, cxMcVoxEventCardNumber=cxMcVoxEventCardNumber, cxMcVoxFxsOpeRmtId=cxMcVoxFxsOpeRmtId, cxMcVoxEmOpeBroadcast=cxMcVoxEmOpeBroadcast, cxMcVoxGlobalOpeLocalId=cxMcVoxGlobalOpeLocalId, cxMcVoxDriverAdmPriv=cxMcVoxDriverAdmPriv, cxMcVoxAdmFaxCedMaxToneDur=cxMcVoxAdmFaxCedMaxToneDur, cxMcVoxGlobalWanSlot=cxMcVoxGlobalWanSlot, cxMcVoxOpeLclZoneLng=cxMcVoxOpeLclZoneLng, cxMcVoxDiagCardIndex=cxMcVoxDiagCardIndex, cxMcVoxDiagScvEvents=cxMcVoxDiagScvEvents, cxMcVoxAdmFaxTxGain=cxMcVoxAdmFaxTxGain, cxMcVoxOpeTimeDialOut=cxMcVoxOpeTimeDialOut, cxMcVoxAdmFaxCedToneDuration=cxMcVoxAdmFaxCedToneDuration, cxMcVoxOpeFlashTgen=cxMcVoxOpeFlashTgen, cxMcVoxOpeEchoCancelLevel=cxMcVoxOpeEchoCancelLevel, cxMcVoxEmAdmRxGain=cxMcVoxEmAdmRxGain, cxMcVoxCfgTestPort=cxMcVoxCfgTestPort, cxMcVoxFxsAdmRxGain=cxMcVoxFxsAdmRxGain, cxMcVoxDiagEntry=cxMcVoxDiagEntry, cxMcVoxOpeFaxCedToneDetection=cxMcVoxOpeFaxCedToneDetection, cxMcVoxEmOpeTable=cxMcVoxEmOpeTable, cxMcVoxEmAdmType=cxMcVoxEmAdmType, cxMcVoxEmAdmDialType=cxMcVoxEmAdmDialType, cxMcVoxPathOpeLng=cxMcVoxPathOpeLng, cxMcVoxOpeTimeWaitDialOut=cxMcVoxOpeTimeWaitDialOut, cxMcVoxPathAdmRemStationId=cxMcVoxPathAdmRemStationId, cxMcVoxOpeTimeDiscOut=cxMcVoxOpeTimeDiscOut, cxMcVoxDiagTable=cxMcVoxDiagTable, cxMcVoxOpeRTCCountry=cxMcVoxOpeRTCCountry, cxMcVoxHistoryRmtPortNumber=cxMcVoxHistoryRmtPortNumber, cxMcVoxDriverAdm=cxMcVoxDriverAdm, cxMcVoxGlobalReinitPath=cxMcVoxGlobalReinitPath, cxMcVoxAdmMfToneThold=cxMcVoxAdmMfToneThold, cxMcVoxOpeTimeSeizeIn=cxMcVoxOpeTimeSeizeIn, cxMcVoxAdmFaxMaxPreambleDly=cxMcVoxAdmFaxMaxPreambleDly, cxMcVoxOpePortPrivTable=cxMcVoxOpePortPrivTable, cxMcVoxGlobalClearLclExt=cxMcVoxGlobalClearLclExt, cxMcVoxGlobalRecogAcc=cxMcVoxGlobalRecogAcc, cxMcVoxEventLogIndex=cxMcVoxEventLogIndex, cxMcVoxAdmFaxMinPreambleDur=cxMcVoxAdmFaxMinPreambleDur, cxMcVoxGrpDefOpeIndex=cxMcVoxGrpDefOpeIndex, cxMcVoxGlobalLseTimerT3=cxMcVoxGlobalLseTimerT3, cxMcVoxAdmFaxCedToneDetection=cxMcVoxAdmFaxCedToneDetection, cxMcVoxFxoAdmFaxBw=cxMcVoxFxoAdmFaxBw, cxMcVoxGlobalNetNbDigits=cxMcVoxGlobalNetNbDigits, cxMcVoxGrpDefAdmRmtExt=cxMcVoxGrpDefAdmRmtExt, cxMcVoxFxsOpeVocoder=cxMcVoxFxsOpeVocoder, cxMcVoxAdmRTCAreaLng=cxMcVoxAdmRTCAreaLng, cxMcVoxAdmToneDelayAfterCnct=cxMcVoxAdmToneDelayAfterCnct, cxMcVoxStatusWatchdog=cxMcVoxStatusWatchdog, cxMcVoxFxsOpeRxGain=cxMcVoxFxsOpeRxGain, cxMcVoxGrpIdLenOpe=cxMcVoxGrpIdLenOpe, cxMcVoxAdmFlashTmin=cxMcVoxAdmFlashTmin, cxMcVoxCfgOpeAcelpRev=cxMcVoxCfgOpeAcelpRev, cxMcVoxPathAdmIndex=cxMcVoxPathAdmIndex, cxMcVoxCfgCmdImmTest=cxMcVoxCfgCmdImmTest, cxMcVoxFxsAdmAutoCnx=cxMcVoxFxsAdmAutoCnx, cxMcVoxTrapRing=cxMcVoxTrapRing, cxMcVoxAdmPinIndex=cxMcVoxAdmPinIndex, cxMcVoxFxoOpePortStatus=cxMcVoxFxoOpePortStatus, cxMcVoxFxsOpeCardUsed=cxMcVoxFxsOpeCardUsed, cxMcVoxLclExtOpeTable=cxMcVoxLclExtOpeTable, cxMcVoxStatePathId=cxMcVoxStatePathId, cxMcVoxLclExtAdmExt=cxMcVoxLclExtAdmExt, cxMcVoxTranslOpeZoneCodeEnable=cxMcVoxTranslOpeZoneCodeEnable, cxMcVoxFxoOpeTranspMode=cxMcVoxFxoOpeTranspMode, cxMcVoxAdmFaxTimerWaitId=cxMcVoxAdmFaxTimerWaitId, cxMcVoxLclExtOpeEntry=cxMcVoxLclExtOpeEntry, cxMcVoxDiagIbvDiags=cxMcVoxDiagIbvDiags, cxMcVoxFxsAdmPortUsed=cxMcVoxFxsAdmPortUsed, cxMcVoxTranslOpeAreaCodeLng=cxMcVoxTranslOpeAreaCodeLng, cxMcVoxFxoOpeDidSignalType=cxMcVoxFxoOpeDidSignalType, cxMcVoxFxsAdmEchoCancel=cxMcVoxFxsAdmEchoCancel, cxMcVoxOpePinCode=cxMcVoxOpePinCode, cxMcVoxDiagGlmEvents=cxMcVoxDiagGlmEvents, cxMcVoxFxoOpeFaxEnable=cxMcVoxFxoOpeFaxEnable, cxMcVoxEmAdmVocoder=cxMcVoxEmAdmVocoder, cxMcVoxFxoOpeBroadcast=cxMcVoxFxoOpeBroadcast, cxMcVoxTranslOpeZCPrefix=cxMcVoxTranslOpeZCPrefix, cxMcVoxGrpDefAdmPriority=cxMcVoxGrpDefAdmPriority, cxMcVoxEmAdmTxGain=cxMcVoxEmAdmTxGain, cxMcVoxOpeFaxInterProtoGap=cxMcVoxOpeFaxInterProtoGap, cxMcVoxOpeTimeOffIn=cxMcVoxOpeTimeOffIn, cxMcVoxLclExtAdmTable=cxMcVoxLclExtAdmTable, cxMcVoxEmAdmAc15Type=cxMcVoxEmAdmAc15Type, cxMcVoxPathAdmEntry=cxMcVoxPathAdmEntry, cxMcVoxEventDateAndTimeOffLine=cxMcVoxEventDateAndTimeOffLine, cxMcVoxEmOpeRingType=cxMcVoxEmOpeRingType, cxMcVoxStateLnkState=cxMcVoxStateLnkState, cxMcVoxAdmAfterToneSilences=cxMcVoxAdmAfterToneSilences, cxMcVoxRegenOpeExt=cxMcVoxRegenOpeExt, cxMcVoxOpeTimeWinkMax=cxMcVoxOpeTimeWinkMax, cxMcVoxFxoOpeCnctType=cxMcVoxFxoOpeCnctType, cxMcVoxOpeFlashTmin=cxMcVoxOpeFlashTmin, cxMcVoxGrpIdOpeNbPoll=cxMcVoxGrpIdOpeNbPoll, cxMcVoxOpePortUsed=cxMcVoxOpePortUsed, cxMcVoxLclExtAdmIndex=cxMcVoxLclExtAdmIndex, cxMcVoxPathOpePathId=cxMcVoxPathOpePathId, cxMcVoxEventEntry=cxMcVoxEventEntry, cxMcVoxNetOpeTable=cxMcVoxNetOpeTable, cxMcVoxTranslOpeAreaCode=cxMcVoxTranslOpeAreaCode, cxMcVoxEmOpeTxGain=cxMcVoxEmOpeTxGain, cxMcVoxOpeTimeWinkMin=cxMcVoxOpeTimeWinkMin, cxMcVoxFxoAdmFaxEnable=cxMcVoxFxoAdmFaxEnable, cxMcVoxOpeLclZoneCode=cxMcVoxOpeLclZoneCode, cxMcVoxGrpIdAdmEntry=cxMcVoxGrpIdAdmEntry, cxMcVoxFxsOpeBroadcast=cxMcVoxFxsOpeBroadcast, cxMcVoxFxsAdmVocoder=cxMcVoxFxsAdmVocoder, cxMcVoxEmOpeType=cxMcVoxEmOpeType, cxMcVoxOpeTimeSeize=cxMcVoxOpeTimeSeize, cxMcVoxAdmDtmfTxTimeOn=cxMcVoxAdmDtmfTxTimeOn, cxMcVoxAdmEchoCancelLevel=cxMcVoxAdmEchoCancelLevel, cxMcVoxAdmLclZoneRowStatus=cxMcVoxAdmLclZoneRowStatus, cxMcVoxDiagPortIndex=cxMcVoxDiagPortIndex, cxMcVoxGlobalTensionDc=cxMcVoxGlobalTensionDc, cxMcVoxOpeFaxRxGain=cxMcVoxOpeFaxRxGain, cxMcVoxOpeDtmfTxTimeOff=cxMcVoxOpeDtmfTxTimeOff, cxMcVoxFxsOpeDidSignalType=cxMcVoxFxsOpeDidSignalType, cxMcVoxOpePortPrivEntry=cxMcVoxOpePortPrivEntry, cxMcVoxStatusHookRem=cxMcVoxStatusHookRem, cxMcVoxGlobalAdmPinCodeLng=cxMcVoxGlobalAdmPinCodeLng, cxMcVoxAdmFaxMaxPreambleDur=cxMcVoxAdmFaxMaxPreambleDur, cxMcVoxDownload=cxMcVoxDownload, cxMcVoxGrpDefOpePriority=cxMcVoxGrpDefOpePriority, cxMcVoxEventPhoneNumber=cxMcVoxEventPhoneNumber, cxMcVoxGlobalOpePathLng=cxMcVoxGlobalOpePathLng, cxMcVoxNetAdmEntry=cxMcVoxNetAdmEntry, cxMcVoxTrapStatus=cxMcVoxTrapStatus, cxMcVoxTranslOpeCntryCode=cxMcVoxTranslOpeCntryCode, cxMcVoxStatusPortNumber=cxMcVoxStatusPortNumber, cxMcVoxEmAdmBroadcast=cxMcVoxEmAdmBroadcast, cxMcVoxFxsOpeEchoCancel=cxMcVoxFxsOpeEchoCancel, cxMcVoxGrpIdAdmTable=cxMcVoxGrpIdAdmTable)
mibBuilder.exportSymbols("CXMCVOX-MIB", cxMcVoxFxsAdmTimeOff=cxMcVoxFxsAdmTimeOff, cxMcVoxEmAdmRingType=cxMcVoxEmAdmRingType, cxMcVoxAdmRTCNonLclZoneLng=cxMcVoxAdmRTCNonLclZoneLng, cxMcVoxGlobalReinitCodesTable=cxMcVoxGlobalReinitCodesTable, cxMcVoxFxsOpePathId=cxMcVoxFxsOpePathId, cxMcVoxFxsOpeTxGain=cxMcVoxFxsOpeTxGain, cxMcVoxOpeFaxMaxHdlcFlags=cxMcVoxOpeFaxMaxHdlcFlags, cxMcVoxEmAdmEntry=cxMcVoxEmAdmEntry, cxMcVoxAdmLclZoneTable=cxMcVoxAdmLclZoneTable, cxMcVoxOpeDtmfTxTimeOn=cxMcVoxOpeDtmfTxTimeOn, cxMcVoxStatusRemPortStatus=cxMcVoxStatusRemPortStatus, cxMcVoxFxoOpeEntry=cxMcVoxFxoOpeEntry, cxMcVoxNetAdmRoute=cxMcVoxNetAdmRoute, cxMcVoxOpeFaxTxGain=cxMcVoxOpeFaxTxGain, cxMcVoxGlobal=cxMcVoxGlobal, cxMcVoxCfgDriverAdmUsed=cxMcVoxCfgDriverAdmUsed, cxMcVoxHistoryTimeStampOnLine=cxMcVoxHistoryTimeStampOnLine, cxMcVoxCfgTrapStatus=cxMcVoxCfgTrapStatus, cxMcVoxFxoAdmBroadcast=cxMcVoxFxoAdmBroadcast, cxMcVoxAdmRingTimeOn=cxMcVoxAdmRingTimeOn, cxMcVoxLclExtAdmHuntChnl=cxMcVoxLclExtAdmHuntChnl, cxMcVoxAdmFaxMaxHdlcFlags=cxMcVoxAdmFaxMaxHdlcFlags, cxMcVoxEmOpeFaxBw=cxMcVoxEmOpeFaxBw, cxMcVoxFxoOpeRmtExt=cxMcVoxFxoOpeRmtExt, cxMcVoxEmOpeAc15TimeOn=cxMcVoxEmOpeAc15TimeOn, cxMcVoxFxsOpePortStatus=cxMcVoxFxsOpePortStatus, cxMcVoxStateCardNumber=cxMcVoxStateCardNumber, cxMcVoxEmOpeDialType=cxMcVoxEmOpeDialType, cxMcVoxTranslOpeCntryCodeLng=cxMcVoxTranslOpeCntryCodeLng, cxMcVoxAdmPinRowStatus=cxMcVoxAdmPinRowStatus, cxMcVoxAdmFaxCedMinToneDur=cxMcVoxAdmFaxCedMinToneDur, cxMcVoxFxoAdmTable=cxMcVoxFxoAdmTable, cxMcVoxFxsOpeRmtExt=cxMcVoxFxsOpeRmtExt, cxMcVoxGlobalAdmEnablePinTable=cxMcVoxGlobalAdmEnablePinTable, cxMcVoxGrpIdOpeEntry=cxMcVoxGrpIdOpeEntry, cxMcVoxOpeFaxMinPreambleDly=cxMcVoxOpeFaxMinPreambleDly, cxMcVoxOpeLclZoneTable=cxMcVoxOpeLclZoneTable, cxMcVoxEmOpeRmtId=cxMcVoxEmOpeRmtId, cxMcVoxOpeDtmfGuard=cxMcVoxOpeDtmfGuard, cxMcVoxOpeTimeWinkStartIn=cxMcVoxOpeTimeWinkStartIn, cxMcVoxGlobalAccCode=cxMcVoxGlobalAccCode, cxMcVoxFxsOpeFaxEnable=cxMcVoxFxsOpeFaxEnable, cxMcVoxStatusPortStatus=cxMcVoxStatusPortStatus, cxMcVoxGrpDefAdmIndex=cxMcVoxGrpDefAdmIndex, cxMcVoxFxoOpeTxGain=cxMcVoxFxoOpeTxGain, cxMcVoxGlobalAdmGrpNbPoll=cxMcVoxGlobalAdmGrpNbPoll, cxMcVoxOpeTimerPrivTable=cxMcVoxOpeTimerPrivTable, cxMcVoxStatusTable=cxMcVoxStatusTable, cxMcVoxCfgTable=cxMcVoxCfgTable, cxMcVoxTranslOpeACPrefixLng=cxMcVoxTranslOpeACPrefixLng, cxMcVoxFxoAdmEchoCancel=cxMcVoxFxoAdmEchoCancel, cxMcVoxCfgCardIndex=cxMcVoxCfgCardIndex, cxMcVoxGlobalClearGrp=cxMcVoxGlobalClearGrp, cxMcVoxFxsAdmDialType=cxMcVoxFxsAdmDialType, cxMcVoxHistoryLnkState=cxMcVoxHistoryLnkState, cxMcVoxTranslOpeCCPrefixLng=cxMcVoxTranslOpeCCPrefixLng, cxMcVoxEmAdmFaxEnable=cxMcVoxEmAdmFaxEnable, cxMcVoxEmOpeImpedance=cxMcVoxEmOpeImpedance, cxMcVoxOpeTimeAnswer=cxMcVoxOpeTimeAnswer, cxMcVoxEmOpePathId=cxMcVoxEmOpePathId, cxMcVoxOpeCardUsed=cxMcVoxOpeCardUsed, cxMcVoxGlobalClearPath=cxMcVoxGlobalClearPath, cxMcVoxFxsOpeFaxBw=cxMcVoxFxsOpeFaxBw, cxMcVoxGrpDefOpePathId=cxMcVoxGrpDefOpePathId, cxMcVoxAdmFaxRxGain=cxMcVoxAdmFaxRxGain, cxMcVoxDiagToneInEvents=cxMcVoxDiagToneInEvents, cxMcVoxGrpIdAdm=cxMcVoxGrpIdAdm, cxMcVoxEmOpeCnctType=cxMcVoxEmOpeCnctType, cxMcVoxGlobalGlmInBetwRespTime=cxMcVoxGlobalGlmInBetwRespTime, cxMcVoxGlobalOpeGrpNbPoll=cxMcVoxGlobalOpeGrpNbPoll, cxMcVoxAdmRTCNonLclAreaLng=cxMcVoxAdmRTCNonLclAreaLng, cxMcVoxCfgTrapOnLine=cxMcVoxCfgTrapOnLine, cxMcVoxOpePinIndex=cxMcVoxOpePinIndex, cxMcVoxOpeFaxCedMinToneDur=cxMcVoxOpeFaxCedMinToneDur, cxMcVoxAdmLclZoneCode=cxMcVoxAdmLclZoneCode, cxMcVoxAdmFaxInterProtoGap=cxMcVoxAdmFaxInterProtoGap, cxMcVoxLclExtAdmRowStatus=cxMcVoxLclExtAdmRowStatus, cxMcVoxOpePinTable=cxMcVoxOpePinTable, cxMcVoxGlobalOpeEnableCodesTable=cxMcVoxGlobalOpeEnableCodesTable, cxMcVoxPathOpeHunt=cxMcVoxPathOpeHunt, cxMcVoxFxsAdmRingType=cxMcVoxFxsAdmRingType, cxMcVoxFxsAdmDidSignalType=cxMcVoxFxsAdmDidSignalType, cxMcVoxTranslOpe=cxMcVoxTranslOpe, cxMcVoxStateDateAndTime=cxMcVoxStateDateAndTime, cxMcVoxStatusDspDpram=cxMcVoxStatusDspDpram, cxMcVoxHistoryRmtCardNumber=cxMcVoxHistoryRmtCardNumber, cxMcVoxFxoOpeSignaling=cxMcVoxFxoOpeSignaling, cxMcVoxFxsAdmRmtId=cxMcVoxFxsAdmRmtId, cxMcVoxAdmRTCNonLclCountry=cxMcVoxAdmRTCNonLclCountry, cxMcVoxGlobalTrapDc=cxMcVoxGlobalTrapDc, cxMcVoxEmAdmPathId=cxMcVoxEmAdmPathId, cxMcVoxGrpIdAdmNbPoll=cxMcVoxGrpIdAdmNbPoll, cxMcVoxOpeFaxCedToneDuration=cxMcVoxOpeFaxCedToneDuration, cxMcVoxOpeFaxTimerWaitId=cxMcVoxOpeFaxTimerWaitId, cxMcVoxFxoOpeCardUsed=cxMcVoxFxoOpeCardUsed, cxMcVoxEmOpeRxGain=cxMcVoxEmOpeRxGain, cxMcVoxEmAdmCardUsed=cxMcVoxEmAdmCardUsed, cxMcVoxEmOpeTranspMode=cxMcVoxEmOpeTranspMode, cxMcVoxOpeVoiceOffsetTxGain=cxMcVoxOpeVoiceOffsetTxGain, cxMcVoxOpeTimeToneOut=cxMcVoxOpeTimeToneOut, cxMcVoxGrpIdAdmIndex=cxMcVoxGrpIdAdmIndex, cxMcVoxFxsOpeEntry=cxMcVoxFxsOpeEntry, cxMcVoxAdmLclZoneLng=cxMcVoxAdmLclZoneLng, cxMcVoxDiagFaxOutEvents=cxMcVoxDiagFaxOutEvents, cxMcVoxTranslOpeAreaCodeEnable=cxMcVoxTranslOpeAreaCodeEnable, cxMcVoxCfgMaxSkew=cxMcVoxCfgMaxSkew, cxMcVoxFxsOpeSignaling=cxMcVoxFxsOpeSignaling, cxMcVoxLclExtOpeHuntChnl=cxMcVoxLclExtOpeHuntChnl, cxMcVoxEmAdmRmtExt=cxMcVoxEmAdmRmtExt, cxMcVoxFxoAdmDidSignalType=cxMcVoxFxoAdmDidSignalType, cxMcVoxTranslOpeCCPrefix=cxMcVoxTranslOpeCCPrefix, cxMcVoxOpeTimeWinkStartOut=cxMcVoxOpeTimeWinkStartOut, cxMcVoxFxsOpeDialType=cxMcVoxFxsOpeDialType, cxMcVoxFxoOpeTable=cxMcVoxFxoOpeTable, cxMcVoxOpeRTCNonLclAreaLng=cxMcVoxOpeRTCNonLclAreaLng, cxMcVoxFxsOpeTimeOn=cxMcVoxFxsOpeTimeOn, cxMcVoxOpeTimeSiOff=cxMcVoxOpeTimeSiOff, cxMcVoxGlobalTensionRing=cxMcVoxGlobalTensionRing, cxMcVoxEmAdmCnctType=cxMcVoxEmAdmCnctType, cxMcVoxStatePortNumber=cxMcVoxStatePortNumber, cxMcVoxNetOpeIndex=cxMcVoxNetOpeIndex, cxMcVoxEmAdmEchoCancel=cxMcVoxEmAdmEchoCancel, cxMcVoxAdmDtmfOpeLevel=cxMcVoxAdmDtmfOpeLevel, cxMcVoxGrpIdOpeTable=cxMcVoxGrpIdOpeTable, cxMcVoxNetOpeEntry=cxMcVoxNetOpeEntry, cxMcVoxFxsAdmPathId=cxMcVoxFxsAdmPathId, cxMcVoxRegenOpeNbDigits=cxMcVoxRegenOpeNbDigits, cxMcVoxOpeRingTimeOff1=cxMcVoxOpeRingTimeOff1, cxMcVoxLclExtOpeIndex=cxMcVoxLclExtOpeIndex, cxMcVoxNetAdmIndex=cxMcVoxNetAdmIndex, cxMcVoxFxsAdmPortStatus=cxMcVoxFxsAdmPortStatus, cxMcVoxAdmPulseInterDigit=cxMcVoxAdmPulseInterDigit, cxMcVoxLclExtOpeExt=cxMcVoxLclExtOpeExt, cxMcVoxStatusHookLocal=cxMcVoxStatusHookLocal, cxMcVoxFxoAdmEntry=cxMcVoxFxoAdmEntry, cxMcVoxOpePinEntry=cxMcVoxOpePinEntry, cxMcVoxPathOpeTable=cxMcVoxPathOpeTable, cxMcVoxOpePulseTmin=cxMcVoxOpePulseTmin, cxMcVoxStateRmtExt=cxMcVoxStateRmtExt, cxMcVoxNetAdmRemStationId=cxMcVoxNetAdmRemStationId, cxMcVoxPathOpeIndex=cxMcVoxPathOpeIndex, cxMcVoxStatusIOResetState=cxMcVoxStatusIOResetState, cxMcVoxFxoAdmRxGain=cxMcVoxFxoAdmRxGain, cxMcVoxGlobalGlmVoiceSilenceTime=cxMcVoxGlobalGlmVoiceSilenceTime, cxMcVoxOpePulseInterDigit=cxMcVoxOpePulseInterDigit, cxMcVoxDiagScvDiags=cxMcVoxDiagScvDiags, cxMcVoxAdmRTCNonLclZone=cxMcVoxAdmRTCNonLclZone, cxMcVoxOpeLclZoneEntry=cxMcVoxOpeLclZoneEntry, cxMcVoxCfgCmdTest=cxMcVoxCfgCmdTest, cxMcVoxOpeTimeSiOn=cxMcVoxOpeTimeSiOn, cxMcVoxGlobalOpePinCodeLng=cxMcVoxGlobalOpePinCodeLng, cxMcVoxGrpDefOpeEntry=cxMcVoxGrpDefOpeEntry, cxMcVoxOpeAfterToneSilences=cxMcVoxOpeAfterToneSilences, cxMcVoxRegenOpeExtBitMask=cxMcVoxRegenOpeExtBitMask, cxMcVoxGrpIdAdmRowStatus=cxMcVoxGrpIdAdmRowStatus, cxMcVoxFxoAdmDialType=cxMcVoxFxoAdmDialType, cxMcVoxAdmFaxMinPreambleDly=cxMcVoxAdmFaxMinPreambleDly, cxMcVoxDiagGlmDiags=cxMcVoxDiagGlmDiags, cxMcVoxEmOpeFaxEnable=cxMcVoxEmOpeFaxEnable, cxMcVoxAdmVoiceOffsetTxGain=cxMcVoxAdmVoiceOffsetTxGain, cxMcVoxFxoOpeRingType=cxMcVoxFxoOpeRingType, cxMcVoxHistoryPin=cxMcVoxHistoryPin, cxMcVoxOpeTimeOffOut=cxMcVoxOpeTimeOffOut, cxMcVoxGlobalGlmMaxTimeToTxResp=cxMcVoxGlobalGlmMaxTimeToTxResp, cxMcVoxFxoOpeEchoCancel=cxMcVoxFxoOpeEchoCancel, cxMcVoxGlobalAdmLocalId=cxMcVoxGlobalAdmLocalId, cxMcVoxHistoryIndex=cxMcVoxHistoryIndex, cxMcVoxDriverOpePriv=cxMcVoxDriverOpePriv, cxMcVoxGlobalExtBitMask=cxMcVoxGlobalExtBitMask, cxMcVoxEventDateAndTimeOnLine=cxMcVoxEventDateAndTimeOnLine, cxMcVoxOpeToneDelayAfterCnct=cxMcVoxOpeToneDelayAfterCnct, cxMcVoxFxsAdmFaxBw=cxMcVoxFxsAdmFaxBw, cxMcVoxOpeFaxMinPreambleDur=cxMcVoxOpeFaxMinPreambleDur, cxMcVoxFxsAdmTimeOn=cxMcVoxFxsAdmTimeOn, cxMcVoxOpeFaxPreambleDuration=cxMcVoxOpeFaxPreambleDuration, cxMcVoxPathAdmTable=cxMcVoxPathAdmTable, cxMcVoxCfgPortIndex=cxMcVoxCfgPortIndex, cxMcVoxFxsOpeCnctType=cxMcVoxFxsOpeCnctType, cxMcVoxGlobalClearHistoryTable=cxMcVoxGlobalClearHistoryTable, cxMcVoxGlobalTrapRing=cxMcVoxGlobalTrapRing, cxMcVoxOpeRingTimeOn=cxMcVoxOpeRingTimeOn, cxMcVoxMibLevel=cxMcVoxMibLevel, cxMcVoxLclExtAdmEntry=cxMcVoxLclExtAdmEntry, cxMcVoxStatAndLog=cxMcVoxStatAndLog, cxMcVoxStatusDspRam=cxMcVoxStatusDspRam, cxMcVoxGlobalClearNet=cxMcVoxGlobalClearNet, cxMcVoxPathAdmPathId=cxMcVoxPathAdmPathId, cxMcVoxAdmPortPrivEntry=cxMcVoxAdmPortPrivEntry, cxMcVoxGrpIdLenAdm=cxMcVoxGrpIdLenAdm, cxMcVoxDiagPcvDiags=cxMcVoxDiagPcvDiags, cxMcVoxAdmPortUsed=cxMcVoxAdmPortUsed, cxMcVoxOpeTimeWaitDialIn=cxMcVoxOpeTimeWaitDialIn, cxMcVoxEmAdmAc15TimeOn=cxMcVoxEmAdmAc15TimeOn, cxMcVoxGlobalGlmInBetwReqTime=cxMcVoxGlobalGlmInBetwReqTime, cxMcVoxStatusCardNumber=cxMcVoxStatusCardNumber, cxMcVoxFxoAdmPortUsed=cxMcVoxFxoAdmPortUsed, cxMcVoxAdmDtmfGuard=cxMcVoxAdmDtmfGuard, cxMcVoxAdmRTCArea=cxMcVoxAdmRTCArea, cxMcVoxRegenOpe=cxMcVoxRegenOpe, cxMcVoxAdmLclZoneEntry=cxMcVoxAdmLclZoneEntry, cxMcVoxAdmPulseTmax=cxMcVoxAdmPulseTmax, cxMcVoxEmAdmTable=cxMcVoxEmAdmTable, cxMcVoxFxoAdmPortStatus=cxMcVoxFxoAdmPortStatus, cxMcVoxGlobalGsdAutoCnctDelay=cxMcVoxGlobalGsdAutoCnctDelay, cxMcVoxFxsAdmEntry=cxMcVoxFxsAdmEntry, cxMcVoxGlobalAccCodeLng=cxMcVoxGlobalAccCodeLng, cxMcVoxEmOpeCardUsed=cxMcVoxEmOpeCardUsed, cxMcVoxGrpDefAdmTable=cxMcVoxGrpDefAdmTable, cxMcVoxGlobalHistoryPercentageFull=cxMcVoxGlobalHistoryPercentageFull, cxMcVoxOpeRTCNonLclCountryLng=cxMcVoxOpeRTCNonLclCountryLng, cxMcVoxCfgDriverOpeUsed=cxMcVoxCfgDriverOpeUsed, cxMcVoxEmAdmMode=cxMcVoxEmAdmMode, cxMcVoxFxoOpeImpedance=cxMcVoxFxoOpeImpedance, cxMcVoxAdmToneDelayAfterFlash=cxMcVoxAdmToneDelayAfterFlash, cxMcVoxFxoAdmVocoder=cxMcVoxFxoAdmVocoder, cxMcVoxOpeTimeBeforeToneOff=cxMcVoxOpeTimeBeforeToneOff, cxMcVoxHistoryTimeStampOffLine=cxMcVoxHistoryTimeStampOffLine, cxMcVoxAdmRTCNonLclCountryLng=cxMcVoxAdmRTCNonLclCountryLng, cxMcVoxAdmFaxPreambleDelay=cxMcVoxAdmFaxPreambleDelay, cxMcVoxOpeRTCAreaLng=cxMcVoxOpeRTCAreaLng, cxMcVox=cxMcVox, cxMcVoxAdmPinTable=cxMcVoxAdmPinTable, cxMcVoxFxoOpeDialType=cxMcVoxFxoOpeDialType, cxMcVoxPathAdmRowStatus=cxMcVoxPathAdmRowStatus, cxMcVoxEmAdmAutoCnx=cxMcVoxEmAdmAutoCnx, cxMcVoxFxsAdmCnctType=cxMcVoxFxsAdmCnctType, cxMcVoxFxoOpeVocoder=cxMcVoxFxoOpeVocoder, cxMcVoxDiagGcvDiags=cxMcVoxDiagGcvDiags, cxMcVoxFxoAdmImpedance=cxMcVoxFxoAdmImpedance, cxMcVoxOpeFaxTimerDetectSync=cxMcVoxOpeFaxTimerDetectSync, cxMcVoxNetOpeLocalLnkStation=cxMcVoxNetOpeLocalLnkStation, cxMcVoxFxoOpePortUsed=cxMcVoxFxoOpePortUsed, cxMcVoxFxsAdmTable=cxMcVoxFxsAdmTable, cxMcVoxStatusSamplingTime=cxMcVoxStatusSamplingTime, cxMcVoxGlobalAdmEnableCodesTable=cxMcVoxGlobalAdmEnableCodesTable, cxMcVoxOpeRTCNonLclCountry=cxMcVoxOpeRTCNonLclCountry, cxMcVoxAdmRTC=cxMcVoxAdmRTC, cxMcVoxStateLogIndex=cxMcVoxStateLogIndex, cxMcVoxEventClrEvts=cxMcVoxEventClrEvts, cxMcVoxFxoAdmRmtId=cxMcVoxFxoAdmRmtId, cxMcVoxEmAdmAc15TimeOff=cxMcVoxEmAdmAc15TimeOff, cxMcVoxEmAdmImpedance=cxMcVoxEmAdmImpedance, cxMcVoxFxoOpeRmtId=cxMcVoxFxoOpeRmtId, cxMcVoxDiagToneOutEvents=cxMcVoxDiagToneOutEvents, cxMcVoxPathAdmHunt=cxMcVoxPathAdmHunt, cxMcVoxFxoAdmPathId=cxMcVoxFxoAdmPathId, cxMcVoxPathOpeRemStationId=cxMcVoxPathOpeRemStationId, cxMcVoxFxsAdmImpedance=cxMcVoxFxsAdmImpedance, cxMcVoxOpePulseTmax=cxMcVoxOpePulseTmax, cxMcVoxNetOpeRoute=cxMcVoxNetOpeRoute, cxMcVoxAdmFaxHdlcFlags=cxMcVoxAdmFaxHdlcFlags, cxMcVoxNetAdmLocalLnkStation=cxMcVoxNetAdmLocalLnkStation, cxMcVoxEmAdmTranspMode=cxMcVoxEmAdmTranspMode, cxMcVoxOpeRTCCountryLng=cxMcVoxOpeRTCCountryLng)
mibBuilder.exportSymbols("CXMCVOX-MIB", cxMcVoxOpeFaxHdlcFlags=cxMcVoxOpeFaxHdlcFlags, cxMcVoxFxoAdmCardUsed=cxMcVoxFxoAdmCardUsed, cxMcVoxFxoOpeFaxBw=cxMcVoxFxoOpeFaxBw, cxMcVoxGrpDefOpeRmtExt=cxMcVoxGrpDefOpeRmtExt, cxMcVoxEventPortNumber=cxMcVoxEventPortNumber, cxMcVoxRegenOpeGid=cxMcVoxRegenOpeGid, cxMcVoxFxsAdmSignaling=cxMcVoxFxsAdmSignaling, cxMcVoxOpeFaxCedMaxToneDur=cxMcVoxOpeFaxCedMaxToneDur, cxMcVoxCfgToneTest=cxMcVoxCfgToneTest, cxMcVoxOpeTimeDial=cxMcVoxOpeTimeDial, cxMcVoxCfgMaxPktFrame=cxMcVoxCfgMaxPktFrame, cxMcVoxEmOpeMode=cxMcVoxEmOpeMode, cxMcVoxFxsOpeTable=cxMcVoxFxsOpeTable, cxMcVoxAdmPortPrivTable=cxMcVoxAdmPortPrivTable, cxMcVoxEventLnkState=cxMcVoxEventLnkState, cxMcVoxFxoAdmRmtExt=cxMcVoxFxoAdmRmtExt, cxMcVoxOpeRingTimeOff2=cxMcVoxOpeRingTimeOff2, cxMcVoxFxoAdmRingType=cxMcVoxFxoAdmRingType, cxMcVoxEmAdmPortUsed=cxMcVoxEmAdmPortUsed, cxMcVoxAdmPinCode=cxMcVoxAdmPinCode, cxMcVoxFxsOpeImpedance=cxMcVoxFxsOpeImpedance, cxMcVoxGlobalReinitNet=cxMcVoxGlobalReinitNet, cxMcVoxAdmFlashTmax=cxMcVoxAdmFlashTmax, cxMcVoxDiagGsdEvents=cxMcVoxDiagGsdEvents, cxMcVoxStatusDspUtilization=cxMcVoxStatusDspUtilization, cxMcVoxStateEntry=cxMcVoxStateEntry, cxMcVoxOpeDtmfOpeLevel=cxMcVoxOpeDtmfOpeLevel, cxMcVoxEmOpeAc15Type=cxMcVoxEmOpeAc15Type, cxMcVoxAdmLclZoneIndex=cxMcVoxAdmLclZoneIndex)

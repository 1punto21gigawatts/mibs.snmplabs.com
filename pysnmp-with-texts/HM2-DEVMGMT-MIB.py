#
# PySNMP MIB module HM2-DEVMGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-DEVMGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
hm2ConfigurationMibs, HmEnabledStatus, HmTimeSeconds1970 = mibBuilder.importSymbols("HM2-TC-MIB", "hm2ConfigurationMibs", "HmEnabledStatus", "HmTimeSeconds1970")
IANAifType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAifType")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Integer32, IpAddress, Counter64, ObjectIdentity, NotificationType, TimeTicks, MibIdentifier, ModuleIdentity, Bits, iso, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "IpAddress", "Counter64", "ObjectIdentity", "NotificationType", "TimeTicks", "MibIdentifier", "ModuleIdentity", "Bits", "iso", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
hm2DeviceMgmtMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 10))
hm2DeviceMgmtMib.setRevisions(('2012-10-10 00:00', '2011-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2DeviceMgmtMib.setRevisionsDescriptions(('hm2SfpThresholdTable table added to store SFP thresholds.', 'Initial version.',))
if mibBuilder.loadTexts: hm2DeviceMgmtMib.setLastUpdated('201210100000Z')
if mibBuilder.loadTexts: hm2DeviceMgmtMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2DeviceMgmtMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2DeviceMgmtMib.setDescription('Hirschmann Device Management MIB. Copyright (C) 2012. All Rights Reserved.')
class Hm2DeviceExtNVMType(TextualConvention, Integer32):
    reference = 'RFC3164 - 4.1.1: Table 2'
    description = 'Type of an external non volatile memory device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none", 0), ("sd", 1), ("usb", 2), ("serial", 3))

hm2DeviceMgmtMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 0))
hm2DeviceMgmtMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1))
hm2DeviceMgmtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 1))
hm2DeviceMgmtActionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2))
hm2DeviceMgmtSoftwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3))
hm2DeviceMgmtHardwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4))
hm2DeviceMgmtTemperatureGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 5))
hm2IfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6))
hm2SfpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7))
hm2ExtNvmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8))
hm2AutoDisableGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9))
hm2UnitGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10))
hm2ModuleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11))
hm2DevMgmtProductId = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 1, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtProductId.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtProductId.setDescription('Manufacturer-defined product identifier (product family + product ID). Example:Objekt-ID 1.3.6.1.4.1.248.11.2.1.1 is the hm2ProductFamily EES and Objekt-ID 1.3.6.1.4.1.248.11.2.1.1.2 is the Product ID for ees25-0600')
hm2DevMgmtProductDescr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtProductDescr.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtProductDescr.setDescription('Manufacturer-defined product description.')
hm2DevMgmtSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSerialNumber.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSerialNumber.setDescription('Manufacturer-defined serial number of the device.')
hm2DevMgmtActionReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionReset.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionReset.setDescription("Setting the object to 'reset' has the same effect as a power-on sequence (cold start) Reading the object always returns 'other'.")
hm2DevMgmtActionFlushFDB = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushFDB", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushFDB.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushFDB.setDescription("Setting the object to 'flushFDB' will flush the forwarding database of the switch. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushARP = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushARP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushARP.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushARP.setDescription("Setting the object to 'flushARP' will flush the ARP cache. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushIGS = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushIGS", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIGS.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIGS.setDescription("Setting the object to 'flushIGS' will flush all dynamically learnt IGMP snooping entries. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushPortStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushPortStats", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushPortStats.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushPortStats.setDescription("Setting the object to 'flushPortStats' will flush all port statistics. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushEmailLogStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushEmailLogCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushEmailLogStats.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushEmailLogStats.setDescription("Setting the object to 'flushEmailLogCounters' will flush all email logging statistics. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushMMRP = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushMMRP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMMRP.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMMRP.setDescription("Setting the object to 'flushMMRP' will flush all MMRP counters. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushMVRP = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushMVRP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMVRP.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMVRP.setDescription("Setting the object to 'flushMVRP' will flush all MVRP counters. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushMSRP = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushMSRP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMSRP.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushMSRP.setDescription("Setting the object to 'flushMSRP' will flush all MSRP counters. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushIeee8021AS = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushIeee8021AS", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIeee8021AS.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIeee8021AS.setDescription("Setting the object to 'flushIeee8021AS' will flush all IEEE8021AS related counters. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushDnsClientCache = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushDnsClientCache", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushDnsClientCache.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushDnsClientCache.setDescription("Setting the object to 'flushDnsClientCache' will flush all DNS client cache records. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushDnsCachingServerCache = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushDnsCachingServerCache", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushDnsCachingServerCache.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushDnsCachingServerCache.setDescription("Setting the object to 'flushDnsCachingServerCache' will flush all DNS caching server cache records. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushIpUdpHelperStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushIpUdpHelperStats", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIpUdpHelperStats.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushIpUdpHelperStats.setDescription("Setting the object to 'flushIpUdpHelperStats' will flush all ip udp helper statistics. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushAclStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("flushAclStats", 2), ("flushAclMacStats", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushAclStats.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushAclStats.setDescription("Setting the object to 'flushAclStats' will flush all acl statistics from the AgentAclRuleTable. Setting the object to 'flushAclMacStats' will flush all acl statistics from the AgentAclMacRuleTable. Reading the object always returns 'other'.")
hm2DevMgmtActionFlushLdapUserCache = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushLdapUserCache", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionFlushLdapUserCache.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionFlushLdapUserCache.setDescription("Setting the object to 'flushLdapUserCache' will flush all cached users from LDAP queries to an Active Directory Server. Reading the object always returns 'other'.")
hm2DevMgmtActionDelayPreset = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtActionDelayPreset.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionDelayPreset.setDescription('Time in seconds until a reset that was triggered over the hm2DevMgmtActionReset object is executed. Writing a zero will cancel any scheduled reset.')
hm2DevMgmtActionDelayCurrent = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 2, 101), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtActionDelayCurrent.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtActionDelayCurrent.setDescription('If a delayed reset is scheduled this object will decrement from the start value to zero.')
hm2DeviceMgmtSoftwareVersionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1))
hm2DevMgmtSwVersBootcode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwVersBootcode.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwVersBootcode.setDescription('Software version of the boot code.')
hm2DevMgmtSwVersTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10), )
if mibBuilder.loadTexts: hm2DevMgmtSwVersTable.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwVersTable.setDescription('This table contains all information related to running and stored software versions on the device. The limit are 24 firmware (*.bin) files in up to 5 directory levels.')
hm2DevMgmtSwVersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2DevMgmtSwFileLocation"), (0, "HM2-DEVMGMT-MIB", "hm2DevMgmtSwFileType"), (0, "HM2-DEVMGMT-MIB", "hm2DevMgmtSwFileIdx"))
if mibBuilder.loadTexts: hm2DevMgmtSwVersEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwVersEntry.setDescription('The entry of the hm2DevMgmtSwVersTable.')
hm2DevMgmtSwFileLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ram", 1), ("flash", 2), ("sd-card", 3), ("usb", 4))))
if mibBuilder.loadTexts: hm2DevMgmtSwFileLocation.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwFileLocation.setDescription('Indicates the file location (ram, flash, sd-card or usb).')
hm2DevMgmtSwFileType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("firmware", 1), ("applet", 2), ("logic", 3))))
if mibBuilder.loadTexts: hm2DevMgmtSwFileType.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwFileType.setDescription('Indicates the file type (firmware, applet, logic).')
hm2DevMgmtSwFileIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)))
if mibBuilder.loadTexts: hm2DevMgmtSwFileIdx.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwFileIdx.setDescription('Indicates the index. For flash the index has the following meaning: - flash.xxx.1 = bootable version in flash (ROM) - flash.xxx.2 = backup version in flash (BAK)')
hm2DevMgmtSwFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwFileName.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwFileName.setDescription('Indicates the file name.')
hm2DevMgmtSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwVersion.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwVersion.setDescription('Version of the stored software.')
hm2DevMgmtSwMajorRelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwMajorRelNum.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwMajorRelNum.setDescription('Shows the major release number of the firmware.')
hm2DevMgmtSwMinorRelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwMinorRelNum.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwMinorRelNum.setDescription('Shows the minor release number of the firmware.')
hm2DevMgmtSwBugfixRelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 3, 1, 10, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwBugfixRelNum.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwBugfixRelNum.setDescription('Shows the bug fix release number of the firmware.')
hm2DevMgmtHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtHwVersion.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtHwVersion.setDescription('Version of the device hardware.')
hm2DevMgmtSwitchingCoreVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtSwitchingCoreVersion.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtSwitchingCoreVersion.setDescription('Version of the device hardware.')
hm2DeviceMgmtLogicVersionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5))
hm2DevMgmtLogicVersTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5, 1), )
if mibBuilder.loadTexts: hm2DevMgmtLogicVersTable.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtLogicVersTable.setDescription('The table displays all versions of supported logic modules.')
hm2DevMgmtLogicVersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5, 1, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2DevMgmtLogicIdx"))
if mibBuilder.loadTexts: hm2DevMgmtLogicVersEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtLogicVersEntry.setDescription('The entry of the hm2DevMgmtLogicVersTable.')
hm2DevMgmtLogicIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: hm2DevMgmtLogicIdx.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtLogicIdx.setDescription('Index of the module to display.')
hm2DevMgmtLogicAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtLogicAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtLogicAddress.setDescription('Address of the logic module in fpga.')
hm2DevMgmtLogicVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 4, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtLogicVersion.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtLogicVersion.setDescription('Version of the logic module in fpga.')
hm2DevMgmtTemperature = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DevMgmtTemperature.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtTemperature.setDescription('This object is used to identify the temperature within a device in units of centigrade (Celsius).')
hm2DevMgmtTemperatureUpperLimit = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-99, 99)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtTemperatureUpperLimit.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtTemperatureUpperLimit.setDescription('This object is used to define a maximum level for the temperature within a device. If the temperature rises above this upper limit, the management station will be notified by a hm2DevMgmtTemperature trap.')
hm2DevMgmtTemperatureLowerLimit = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-99, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DevMgmtTemperatureLowerLimit.setStatus('current')
if mibBuilder.loadTexts: hm2DevMgmtTemperatureLowerLimit.setDescription('This object is used to define a minimum level for the temperature within a device. If the temperature falls below this lower limit, the management station will be notified by a hm2DevMgmtTemperature trap.')
hm2IfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1), )
if mibBuilder.loadTexts: hm2IfaceTable.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceTable.setDescription('This table contains extended PHY capabilities and configuration options.')
hm2IfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2IfacePhysIndex"))
if mibBuilder.loadTexts: hm2IfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceEntry.setDescription('Entry with the configuration options and supported features of a port.')
hm2IfacePhysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2IfacePhysIndex.setStatus('current')
if mibBuilder.loadTexts: hm2IfacePhysIndex.setDescription('The index of the available physical interfaces.')
hm2IfacePortCapabilityBits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 2), Bits().clone(namedValues=NamedValues(("manual-mdix", 0), ("auto-mdix", 1), ("auto-power-down", 2), ("energy-efficient-ethernet", 3), ("cable-test", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfacePortCapabilityBits.setStatus('current')
if mibBuilder.loadTexts: hm2IfacePortCapabilityBits.setDescription('manual-mdix - port supports MDIX and MDI auto-mdix - port supports MDIX and Auto-MDIX auto-power-down - port can enter low power mode if no link is established energy-efficient-ethernet - port supports EEE cable-test - port supports cable testing')
hm2IfaceCableCrossing = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mdi", 1), ("mdix", 2), ("auto-mdix", 3), ("unsupported", 4))).clone('mdix')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IfaceCableCrossing.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceCableCrossing.setDescription("This variable configures the cable crossing on twisted pair cables. When set to 'mdi', the device does not swap the send and receive line pairs of the TP cable for this port. When set to 'mdix', the device swaps the send and receive line pairs of the TP cable for this port. When set to 'auto-mdix', the port uses the auto crossover mode. 'Unsupported' is shown, if a port does not support cable crossing or auto-negotiation is disabled. It is not possible to set 'unsupported' to any type of port.")
hm2IfacePowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 4), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IfacePowerState.setStatus('current')
if mibBuilder.loadTexts: hm2IfacePowerState.setDescription("This variable configures the power on the interface. When set to 'enable' that means the interface-power is on (power up) When set to 'disable' that means the interface-power is off (power down) The interface power state settings have no effect if the interface admin state (ifAdminStatus) is enabled")
hm2IfaceAutoPowerDown = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto-power-down", 1), ("no-power-save", 2), ("energy-efficient-ethernet", 3), ("unsupported", 4))).clone('no-power-save')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IfaceAutoPowerDown.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceAutoPowerDown.setDescription("This variable configures the automatic power save mode on the interface. When set to 'auto-power-down', the port goes in a low power mode if no link is detected. When set to 'no-power-save', the port does not use the automatic power save mode. When set to 'energy-efficient-ethernet', the port uses energy-efficient-ethernet mode to save the power. 'Unsupported' is shown, if a port does not support automatic power save mode.")
hm2IfaceOperAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceOperAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceOperAdminStatus.setDescription('This variable shows the operational admin state of a specific interface. The operational state could be different to the ifAdminStatus if the interface is forced to down by other means like hm2AutoDisableIntfOperState.')
hm2IfaceLayoutTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2), )
if mibBuilder.loadTexts: hm2IfaceLayoutTable.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutTable.setDescription("This table does contain the layout of the interface modules or blocks. It contains all possible physical and logical items. This table can be used to determine any interface index according to 'IfEntry' that may exist and the name of this interface. ")
hm2IfaceLayoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2IfaceLayoutIndex"))
if mibBuilder.loadTexts: hm2IfaceLayoutEntry.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutEntry.setDescription('An entry of a module or block of interfaces.')
hm2IfaceLayoutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: hm2IfaceLayoutIndex.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutIndex.setDescription('The index used for this table.')
hm2IfaceLayoutStartIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutStartIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutStartIfIndex.setDescription('It specifies the first interface index of this block or module.')
hm2IfaceLayoutEndIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutEndIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutEndIfIndex.setDescription('It specifies the last interface index of this block or module that can exist for this particular device. The amount of interfaces between first and last may not be equal than to the maximum interface per module.')
hm2IfaceLayoutModuleCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutModuleCapacity.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutModuleCapacity.setDescription('It is the Number of modules in that block. Currently not used and it is always 0.')
hm2IfaceLayoutModulePortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutModulePortCapacity.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutModulePortCapacity.setDescription('Number of interfaces that one module can contain. Currently not used and it is always 0')
hm2IfaceLayoutFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutFormat.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutFormat.setDescription("This specifies a format string that can be used to determine the textual representation of an interface in this block. following wildcards are supported: %i the absolute interface number according to 'IfEntry'. %p the relative number based on hm2IfaceLayoutStartIfIndex %s the block number from 'hm2IfaceLayoutIndex' %vid the vlan of the routing interface %lre the name of the redundancy port (prp or hsr)")
hm2IfaceLayoutIfIndexType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 2, 1, 7), IANAifType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceLayoutIfIndexType.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceLayoutIfIndexType.setDescription('Type of the interfaces in that block according to IANA-Type table.')
hm2IfaceExtTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 3), )
if mibBuilder.loadTexts: hm2IfaceExtTable.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceExtTable.setDescription('This table contains additional information about the interfaces.')
hm2IfaceExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2IfaceExtEntry.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceExtEntry.setDescription('.')
hm2IfaceExtIfRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 24, 136, 161, 169, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1101, 1102, 1201, 1202))).clone(namedValues=NamedValues(("ethernetCsmacd", 6), ("softwareLoopback", 24), ("l3ipvlan", 136), ("ieee8023adLag", 161), ("shdsl", 169), ("ringPort", 1001), ("subringPort", 1002), ("couplingPort", 1003), ("routerPort", 1004), ("probePort", 1005), ("cpuPort", 1006), ("servicePort", 1007), ("outOfBandMgmtPort", 1008), ("lagMember", 1101), ("lreMember", 1102), ("lreInterface", 1201), ("ringLagInterface", 1202)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IfaceExtIfRole.setStatus('current')
if mibBuilder.loadTexts: hm2IfaceExtIfRole.setDescription('The current role of the interface.')
hm2SfpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1), )
if mibBuilder.loadTexts: hm2SfpInfoTable.setStatus('current')
if mibBuilder.loadTexts: hm2SfpInfoTable.setDescription('This table contains variables for each SFP.')
hm2SfpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2SfpInfoEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SfpInfoEntry.setDescription('Entry for a detected SFP.')
hm2SfpModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6))).clone(namedValues=NamedValues(("sfp", 3), ("xfp", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpModuleType.setStatus('current')
if mibBuilder.loadTexts: hm2SfpModuleType.setDescription('Type of the module. SFP or SFP+ (3), XFP (6).')
hm2SfpMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 30, 31, 32, 40, 41, 50))).clone(namedValues=NamedValues(("ge-1000-base-sx", 1), ("ge-1000-base-lx", 2), ("ge-1000-base-cx", 4), ("fe-100base-lx", 5), ("fe-100base-fx", 6), ("ge-1000-base-t", 8), ("unsupported", 9), ("oc3-mm-sr", 10), ("oc3-sm-ir", 11), ("oc3-sm-lr", 12), ("oc12-mm-sr", 13), ("oc12-sm-ir", 14), ("oc12-sm-lr", 15), ("oc48-sr", 16), ("oc48-ir", 17), ("oc48-lr", 18), ("xfp-10gbase-sr", 30), ("xfp-10gbase-lr", 31), ("xfp-10gbase-er", 32), ("microfx", 40), ("pof", 41), ("m-sfp-2500", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMediaType.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMediaType.setDescription("The SFP's Media Type")
hm2SfpConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 7, 8, 11, 33, 34, 128))).clone(namedValues=NamedValues(("nonSfp", 1), ("fiberjack", 6), ("lc", 7), ("mtrj", 8), ("opticalPigtail", 11), ("copperPigtail", 33), ("rj45", 34), ("vendorSpecific", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpConnector.setStatus('current')
if mibBuilder.loadTexts: hm2SfpConnector.setDescription("The SFP's Connector Type.")
hm2SfpVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpVendorName.setStatus('current')
if mibBuilder.loadTexts: hm2SfpVendorName.setDescription("The SFP's vendor name (ASCII).")
hm2SfpVendorOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpVendorOUI.setStatus('current')
if mibBuilder.loadTexts: hm2SfpVendorOUI.setDescription('The vendor organizationally unique identifier field (OUI).')
hm2SfpPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpPartNumber.setStatus('current')
if mibBuilder.loadTexts: hm2SfpPartNumber.setDescription('The part number of the module (ASCII).')
hm2SfpPartRev = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpPartRev.setStatus('current')
if mibBuilder.loadTexts: hm2SfpPartRev.setDescription('The revision number of the module (ASCII).')
hm2SfpSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpSerialNum.setStatus('current')
if mibBuilder.loadTexts: hm2SfpSerialNum.setDescription("The SFP's serial number provided by vendor (ASCII).")
hm2SfpDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpDateCode.setStatus('current')
if mibBuilder.loadTexts: hm2SfpDateCode.setDescription("The SFP's vendor manufacturing date code. Format is YY:MM:DD.")
hm2SfpInfoVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpInfoVersion.setStatus('current')
if mibBuilder.loadTexts: hm2SfpInfoVersion.setDescription("Version of SFP's Hirschmann information. Contains -1 in case of a device read error.")
hm2SfpInfoPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: hm2SfpInfoPartNumber.setDescription("Part Number of SFP's Hirschmann information.")
hm2SfpInfoPartId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpInfoPartId.setStatus('current')
if mibBuilder.loadTexts: hm2SfpInfoPartId.setDescription("Part Identifier of SFP's Hirschmann information.")
hm2SfpBitRateNominal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpBitRateNominal.setStatus('current')
if mibBuilder.loadTexts: hm2SfpBitRateNominal.setDescription("The SFP's nominal bitrate in units of MBits/sec. Contains -1 in case of a device read error.")
hm2SfpBitRateMin = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpBitRateMin.setStatus('current')
if mibBuilder.loadTexts: hm2SfpBitRateMin.setDescription('The minimum bit rate is specified in units of 100 Megabits per second, rounded off to the nearest 100 Megabits per second. A value of 0 indicates that the minimum bit rate is not specified.')
hm2SfpBitRateMax = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpBitRateMax.setStatus('current')
if mibBuilder.loadTexts: hm2SfpBitRateMax.setDescription('The maximum bit rate is specified in units of 100 Megabits per second, rounded off to the nearest 100 Megabits per second. A value of 0 indicates that the maximum bit rate is not specified.')
hm2SfpMaxLength_fiber_9 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 16), Integer32()).setLabel("hm2SfpMaxLength-fiber-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_9.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_9.setDescription("Max. usable length for the cable type '9/125 micrometer fiber' with this SFP in units of meters.")
hm2SfpMaxLength_fiber_50 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 17), Integer32()).setLabel("hm2SfpMaxLength-fiber-50").setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_50.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_50.setDescription("Max. usable length for the cable type '50/125 micrometer fiber' with this SFP in units of meters.")
hm2SfpMaxLength_fiber_e50 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 18), Integer32()).setLabel("hm2SfpMaxLength-fiber-e50").setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_e50.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_e50.setDescription("Max. usable length for the cable type 'EBW 50/125 micrometer fiber' with this SFP in units of meters or -1 if not supported.")
hm2SfpMaxLength_fiber_62_5 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 19), Integer32()).setLabel("hm2SfpMaxLength-fiber-62-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_62_5.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMaxLength_fiber_62_5.setDescription("Max. usable length for the cable type '62.5/125 micrometer fiber' with this SFP in units of meters.")
hm2SfpMaxLength_copper = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 20), Integer32()).setLabel("hm2SfpMaxLength-copper").setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpMaxLength_copper.setStatus('current')
if mibBuilder.loadTexts: hm2SfpMaxLength_copper.setDescription("Max. usable length for the cable type 'copper' with this SFP in units of meters.")
hm2SfpWaveLength = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpWaveLength.setStatus('current')
if mibBuilder.loadTexts: hm2SfpWaveLength.setDescription('Nominal transmitter output wavelength at room temperature. The laser wavelength in nm (units of 0.05nm).')
hm2SfpWaveLengthTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpWaveLengthTolerance.setStatus('current')
if mibBuilder.loadTexts: hm2SfpWaveLengthTolerance.setDescription('The +/- range of transmitter output wavelength under normal operating conditions or -1 if not supported.')
hm2SfpEnhancedOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 23), Bits().clone(namedValues=NamedValues(("none", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpEnhancedOptions.setStatus('current')
if mibBuilder.loadTexts: hm2SfpEnhancedOptions.setDescription('Not supported.')
hm2SfpSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpSupported.setStatus('current')
if mibBuilder.loadTexts: hm2SfpSupported.setDescription('The SFP is supported by the device (true) or not (false).')
hm2SfpSupportedReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("hirschmannID", 1), ("whiteList", 2), ("wrongSpeed", 3), ("noneEthernet", 4), ("tpSfpNotSupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpSupportedReason.setStatus('current')
if mibBuilder.loadTexts: hm2SfpSupportedReason.setDescription('The reason why this SFP is supported.')
hm2SfpDiagTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2), )
if mibBuilder.loadTexts: hm2SfpDiagTable.setStatus('current')
if mibBuilder.loadTexts: hm2SfpDiagTable.setDescription('This table contains variables for each SFP.')
hm2SfpDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2SfpDiagEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SfpDiagEntry.setDescription('Entry for a detected SFP.')
hm2SfpCurrentBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentBitRate.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentBitRate.setDescription('The current bit rate in units of Megabits per second.')
hm2SfpCurrentTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentTemperature.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentTemperature.setDescription('This signed integer is used to identify the temperature within the SFP in units of centigrade (Celsius). Contains -1000 in case of a device read error.')
hm2SfpCurrentTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentTxPower.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentTxPower.setDescription("The SFP's internally measured Tx Power in units of 1/10 microwatt or -1 if it is not supported.")
hm2SfpCurrentRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentRxPower.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentRxPower.setDescription("The SFP's internally measured Rx Power in units of 1/10 microWatts or -10000 if not supportted.")
hm2SfpCurrentTxPowerdBm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentTxPowerdBm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentTxPowerdBm.setDescription("The SFP's internally measured Tx Power in units of dBm. (ASCII representation of a floating point number). - if not supported.")
hm2SfpCurrentRxPowerdBm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentRxPowerdBm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentRxPowerdBm.setDescription("The SFP's internally measured Rx Power in units of dBm. (ASCII representation of a floating point number). - if not supported.")
hm2SfpCurrentRxPowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("alarm", 3), ("unsupported", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpCurrentRxPowerState.setStatus('current')
if mibBuilder.loadTexts: hm2SfpCurrentRxPowerState.setDescription("The state of the SFP's internally measured Rx.")
hm2SfpWLGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 3))
hm2SfpWLStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("present", 1), ("absent", 2), ("not-supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpWLStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SfpWLStatus.setDescription('Status of the SFP White List. present(1): a white list is present on the device absent(2): no white list is present on the device not-supported(3): white list feature is not supported in this device')
hm2SfpThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4), )
if mibBuilder.loadTexts: hm2SfpThresholdTable.setStatus('current')
if mibBuilder.loadTexts: hm2SfpThresholdTable.setDescription('This table contains the thresholds for each SFP.')
hm2SfpThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2SfpThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SfpThresholdEntry.setDescription('Entry for a detected SFP.')
hm2SfpTemperatureHighAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTemperatureHighAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTemperatureHighAlarm.setDescription("The SFP's Temperature High Alarm threshold in units of centigrade (Celsius). It is -1000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTemperatureHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTemperatureHighWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTemperatureHighWarning.setDescription("The SFP's Temperature High Warning threshold in units of centigrade (Celsius). It is -1000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTemperatureLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTemperatureLowAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTemperatureLowAlarm.setDescription("The SFP's Temperature Low Alarm threshold in units of centigrade (Celsius). It is -1000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTemperatureLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTemperatureLowWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTemperatureLowWarning.setDescription("The SFP's Temperature Low Warning threshold in units of centigrade (Celsius). It is -1000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerHighAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerHighAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerHighAlarm.setDescription("The SFP's Tx Power High Alarm threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerHighWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerHighWarning.setDescription("The SFP's Tx Power High Warning threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerLowAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerLowAlarm.setDescription("The SFP's Tx Power Low Alarm threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerLowWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerLowWarning.setDescription("The SFP's Tx Power Low Warning threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerHighAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerHighAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerHighAlarm.setDescription("The SFP's Rx Power High Alarm threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerHighWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerHighWarning.setDescription("The SFP's Rx Power High Warning threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerLowAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerLowAlarm.setDescription("The SFP's Rx Power Low Alarm threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerLowWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerLowWarning.setDescription("The SFP's Rx Power Low Warning threshold in units of 0.1uW. It is -10000 if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerdBmHighAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 13), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerdBmHighAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerdBmHighAlarm.setDescription("The SFP's Tx Power High Alarm threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerdBmHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 14), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerdBmHighWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerdBmHighWarning.setDescription("The SFP's Tx Power High Warning threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerdBmLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 15), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerdBmLowAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerdBmLowAlarm.setDescription("The SFP's Tx Power Low Alarm threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpTxPowerdBmLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 16), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpTxPowerdBmLowWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpTxPowerdBmLowWarning.setDescription("The SFP's Tx Power Low Warning threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerdBmHighAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 17), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerdBmHighAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerdBmHighAlarm.setDescription("The SFP's Rx Power High Alarm threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerdBmHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 18), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerdBmHighWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerdBmHighWarning.setDescription("The SFP's Rx Power High Warning threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerdBmLowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 19), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerdBmLowAlarm.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerdBmLowAlarm.setDescription("The SFP's Rx Power Low Alarm threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2SfpRxPowerdBmLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 7, 4, 1, 20), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SfpRxPowerdBmLowWarning.setStatus('current')
if mibBuilder.loadTexts: hm2SfpRxPowerdBmLowWarning.setDescription("The SFP's Rx Power Low Warning threshold in units of dBm (ASCII representation of floating point number). It is N/A if the SFP device does not support it or in case of a device read error.")
hm2ExtNvmGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 1))
hm2ExtNvmChooseActive = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 1, 1), Hm2DeviceExtNVMType().clone('sd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmChooseActive.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmChooseActive.setDescription('The user can choose which external NV memory to use for file operations.')
hm2ExtNvmLogDevice = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 1, 2), Hm2DeviceExtNVMType().clone('sd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmLogDevice.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmLogDevice.setDescription('The user can choose which external NV memory to use for persistent logging.')
hm2ExtNvmAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("compatibility", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmAdminMode.setDescription('Switches the USB bus between High Speed (normal) and Full Speed (compatibility). This setting only takes effect after a reboot.')
hm2ExtNvmOperMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("compatibility", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmOperMode.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmOperMode.setDescription('Shows the USB mode the device is currently operating in.')
hm2ExtNvmTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2), )
if mibBuilder.loadTexts: hm2ExtNvmTable.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmTable.setDescription('This table contains variables for each nvram.')
hm2ExtNvmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2ExtNvmTableIndex"))
if mibBuilder.loadTexts: hm2ExtNvmEntry.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmEntry.setDescription('Entry for an external nvram.')
hm2ExtNvmTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 1), Hm2DeviceExtNVMType())
if mibBuilder.loadTexts: hm2ExtNvmTableIndex.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmTableIndex.setDescription('Index')
hm2ExtNvmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notPresent", 1), ("removed", 2), ("ok", 3), ("outOfMemory", 4), ("genericErr", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmStatus.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmStatus.setDescription('Status of the external non-volatile memory. notPresent(1): external non-volatile memory has not been detected. removed(2): external non-volatile memory was removed in running mode of the agent. ok(3): external non-volatile memory is present and OK. outOfMemory(4): external non-volatile memory is full. genericErr(5): Any other failure, e.g. hardware malfunction.')
hm2ExtNvmManufacturerId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmManufacturerId.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmManufacturerId.setDescription('The manufacturer ID.')
hm2ExtNvmHWRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmHWRevision.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmHWRevision.setDescription('The application ID.')
hm2ExtNvmProductName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmProductName.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmProductName.setDescription('The product name.')
hm2ExtNvmVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmVersion.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmVersion.setDescription('The version.')
hm2ExtNvmSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmSerialNum.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmSerialNum.setDescription('The serial number provided by vendor (ASCII).')
hm2ExtNvmAutomaticSoftwareLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 8), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmAutomaticSoftwareLoad.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmAutomaticSoftwareLoad.setDescription("Enable or disable Automatic loading of a software image from the external non-volatile memory. A file named 'startup.txt' must be present on the external non-volatile memory and contain the line 'autoUpdate=filename'.")
hm2ExtNvmConfigLoadPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("first", 1), ("second", 2), ("third", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmConfigLoadPriority.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmConfigLoadPriority.setDescription('Set the priority of this external non-volatile memory for loading the configuration while booting. The configuration on the device with the lowest priority is loaded. Setting this variable to 0 disables loading of a configuration from this device.')
hm2ExtNvmConfigSave = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 10), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmConfigSave.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmConfigSave.setDescription('Enable or disable Automatic saving of the configuration to the external non-volatile memory. If this is enabled, saving the configuration of the device to its internal nvram also stores in on this external nvram.')
hm2ExtNvmWritable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 11), HmEnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ExtNvmWritable.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmWritable.setDescription('Shows if writing to the device is possible, i.e. if it is write protected.')
hm2ExtNvmAutomaticSshKeyLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 8, 2, 1, 12), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ExtNvmAutomaticSshKeyLoad.setStatus('current')
if mibBuilder.loadTexts: hm2ExtNvmAutomaticSshKeyLoad.setDescription("Enable or disable automatic loading of a SSH key from the external non-volatile memory. A file named 'startup.txt' must be present on the external non-volatile memory and contain the line 'autoUpdateRSA=' and/or 'autoUpdateDSA='.")
hm2AutoDisableIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1), )
if mibBuilder.loadTexts: hm2AutoDisableIntfTable.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfTable.setDescription('Port Auto Disable interface table.')
hm2AutoDisableIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2IfacePhysIndex"))
if mibBuilder.loadTexts: hm2AutoDisableIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfEntry.setDescription('Port Auto Disable interface entry.')
hm2AutoDisableIntfRemainingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableIntfRemainingTime.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfRemainingTime.setDescription('Remaining time in seconds until the re-activation of the port.')
hm2AutoDisableIntfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableIntfComponentName.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfComponentName.setDescription('Name of the component that triggered the error')
hm2AutoDisableIntfErrorReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 0), ("link-flap", 1), ("crc-error", 2), ("duplex-mismatch", 3), ("dhcp-snooping", 4), ("arp-rate", 5), ("bpdu-rate", 6), ("mac-based-port-security", 7), ("overload-detection", 8), ("speed-duplex", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableIntfErrorReason.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfErrorReason.setDescription('Error disable reason')
hm2AutoDisableIntfTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(30, 4294967295), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AutoDisableIntfTimer.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfTimer.setDescription('Timer value in seconds after a deactivated port is activated again. Possible values are: 30-4294967295. A value of 0 disables the timer.')
hm2AutoDisableIntfReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AutoDisableIntfReset.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfReset.setDescription('Port Auto Disable interface reset.')
hm2AutoDisableIntfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableIntfOperState.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfOperState.setDescription('Status of Auto Disable interface admin state. Active means that a component has encountered an error and Auto-Disable has turned off the interface. Inactive means that currently there is no error')
hm2AutoDisableIntfErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 1, 1, 7), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableIntfErrorTime.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableIntfErrorTime.setDescription('Local system time (hm2SystemLocalTime) when the error occured.')
hm2AutoDisableReasonTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 2), )
if mibBuilder.loadTexts: hm2AutoDisableReasonTable.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableReasonTable.setDescription('Possible reasons for Auto Disable')
hm2AutoDisableReasonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 2, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2AutoDisableReasons"))
if mibBuilder.loadTexts: hm2AutoDisableReasonEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableReasonEntry.setDescription('Port Auto Disable interface entry.')
hm2AutoDisableReasons = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("link-flap", 1), ("crc-error", 2), ("duplex-mismatch", 3), ("dhcp-snooping", 4), ("arp-rate", 5), ("bpdu-rate", 6), ("mac-based-port-security", 7), ("overload-detection", 8), ("speed-duplex", 9))))
if mibBuilder.loadTexts: hm2AutoDisableReasons.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableReasons.setDescription('Reason for deactivation a port')
hm2AutoDisableReasonOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 2, 1, 2), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AutoDisableReasonOperation.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableReasonOperation.setDescription('Enables/disables recovery by resaon on this device.')
hm2AutoDisableReasonCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("port-monitor", 2), ("network-security", 3), ("l2-redundancy", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AutoDisableReasonCategory.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisableReasonCategory.setDescription('Auto Disable Reason Category')
hm2UnitTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10, 100), )
if mibBuilder.loadTexts: hm2UnitTable.setStatus('current')
if mibBuilder.loadTexts: hm2UnitTable.setDescription('This table contains unit capabilities and configuration options.')
hm2UnitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10, 100, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2UnitIndex"))
if mibBuilder.loadTexts: hm2UnitEntry.setStatus('current')
if mibBuilder.loadTexts: hm2UnitEntry.setDescription('Entry with the configuration options and supported features of a unit.')
hm2UnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10, 100, 1, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2UnitIndex.setStatus('current')
if mibBuilder.loadTexts: hm2UnitIndex.setDescription('The index of the available unit.')
hm2UnitMaxModuleCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10, 100, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2UnitMaxModuleCapacity.setStatus('current')
if mibBuilder.loadTexts: hm2UnitMaxModuleCapacity.setDescription('Maximum number of modules that this unit can contain in this system.')
hm2UnitMaxModulePortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 10, 100, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2UnitMaxModulePortCapacity.setStatus('current')
if mibBuilder.loadTexts: hm2UnitMaxModulePortCapacity.setDescription('Maximum number of ports that a module can contain in this unit.')
hm2ModuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100), )
if mibBuilder.loadTexts: hm2ModuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleTable.setDescription('This table contains capabilities and configuration options of device modules.')
hm2ModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1), ).setIndexNames((0, "HM2-DEVMGMT-MIB", "hm2UnitIndex"), (0, "HM2-DEVMGMT-MIB", "hm2ModuleIndex"))
if mibBuilder.loadTexts: hm2ModuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleEntry.setDescription('Entry with the configuration options and supported features of a device module.')
hm2ModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2ModuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleIndex.setDescription('The index of the available module.')
hm2ModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleId.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleId.setDescription('Manufacturer-defined product identifier (module family + product ID). Example: Object-ID 1.3.6.1.4.1.248.11.2.2.1 is the hm2ModuleFamily MSM and Object-ID 1.3.6.1.4.1.248.11.2.2.1.1 is the Product ID for msm-4tx')
hm2ModuleDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 3), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleDescription.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleDescription.setDescription('Description of the module. This value cannot be written by external entities (only for internal purposes).')
hm2ModuleProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleProductCode.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleProductCode.setDescription('Product Code of the module.')
hm2ModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleVersion.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleVersion.setDescription('Version of the module.')
hm2ModuleNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleNumOfPorts.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleNumOfPorts.setDescription('The numberOfPorts is the number of ports contained within the module. Within each module, the ports are uniquely numbered in the range from 1 to numberOfPorts.')
hm2ModuleFirstMauIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleFirstMauIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hm2ModuleFirstMauIndex.setDescription('Value of the first mauIndex used by the module. **NOTE: This object is obsolete in favour of hm2ModuleFirstIfIndex.**')
hm2ModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("physical", 1), ("configurable", 2), ("remove", 3), ("fix", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleStatus.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleStatus.setDescription('Status of the module. If the value is physical(1), then the module is plugged in, if the value is configurable, the ports can be configured, but the card is absent, with the value remove(3) written to the agent the card can be logically removed. The value fix(4) is for modules which cannot be removed.')
hm2ModuleSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleSerialNum.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleSerialNum.setDescription('The serial number provided by vendor (ASCII).')
hm2ModuleMinSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleMinSWVersion.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleMinSWVersion.setDescription('The minimum software version required to support this module.')
hm2ModuleCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 11), Bits().clone(namedValues=NamedValues(("poe", 0), ("fpga", 1), ("ptp", 2), ("io-module", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleCapability.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleCapability.setDescription('poe - module supports Power over Ethernet, fpga - module has a FPGA, ptp - module supports PTP, io-module - module is an IO module. This value cannot be written by external entities (only for internal purposes).')
hm2ModuleInternalID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleInternalID.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleInternalID.setDescription('An internal ID of the Module. This value cannot be written by external entities (only for internal purposes).')
hm2ModuleInternalIDVariant = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleInternalIDVariant.setStatus('obsolete')
if mibBuilder.loadTexts: hm2ModuleInternalIDVariant.setDescription('An internal variant ID of the Module. **NOTE: This object is obsolete.**')
hm2ModuleFirstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModuleFirstIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleFirstIfIndex.setDescription('Value of the first ifIndex used by the module.')
hm2ModuleAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 10, 1, 11, 100, 1, 15), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModuleAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleAdminState.setDescription('Enable or disable the module. If disabled, module plugged in this slot will not be activated. ')
hm2SfpChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 10, 0, 1)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2SfpChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hm2SfpChangeTrap.setDescription('This trap is sent when a SFP has been added or removed. It is also sent for an otherwise unsupported SFP.')
hm2AutoDisablePortTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 10, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("HM2-DEVMGMT-MIB", "hm2IfaceOperAdminStatus"), ("HM2-DEVMGMT-MIB", "hm2AutoDisableIntfErrorReason"))
if mibBuilder.loadTexts: hm2AutoDisablePortTrap.setStatus('current')
if mibBuilder.loadTexts: hm2AutoDisablePortTrap.setDescription('This trap is sent if the port has been disabled or enabled by auto disable feature.')
hm2ModulePluggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 10, 0, 3)).setObjects(("HM2-DEVMGMT-MIB", "hm2UnitIndex"), ("HM2-DEVMGMT-MIB", "hm2ModuleIndex"))
if mibBuilder.loadTexts: hm2ModulePluggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2ModulePluggedTrap.setDescription('This trap is sent if a module is plugged into a unit.')
hm2ModuleRemovedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 10, 0, 4)).setObjects(("HM2-DEVMGMT-MIB", "hm2UnitIndex"), ("HM2-DEVMGMT-MIB", "hm2ModuleIndex"))
if mibBuilder.loadTexts: hm2ModuleRemovedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2ModuleRemovedTrap.setDescription('This trap is sent if a module is removed from a unit.')
hm2SFPRxPowerChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 10, 0, 5)).setObjects(("HM2-DEVMGMT-MIB", "hm2SfpCurrentRxPowerState"))
if mibBuilder.loadTexts: hm2SFPRxPowerChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hm2SFPRxPowerChangeTrap.setDescription('This trap is sent when the state (hm2SfpCurrentRxPowerState) of the rx power of a SFP changes.')
mibBuilder.exportSymbols("HM2-DEVMGMT-MIB", hm2ExtNvmAutomaticSshKeyLoad=hm2ExtNvmAutomaticSshKeyLoad, hm2DevMgmtActionDelayPreset=hm2DevMgmtActionDelayPreset, hm2SfpInfoVersion=hm2SfpInfoVersion, hm2SfpThresholdTable=hm2SfpThresholdTable, hm2SfpEnhancedOptions=hm2SfpEnhancedOptions, hm2SfpDiagEntry=hm2SfpDiagEntry, hm2ModuleIndex=hm2ModuleIndex, hm2IfaceLayoutStartIfIndex=hm2IfaceLayoutStartIfIndex, hm2SfpTxPowerLowAlarm=hm2SfpTxPowerLowAlarm, hm2IfaceLayoutModuleCapacity=hm2IfaceLayoutModuleCapacity, hm2DevMgmtSwVersEntry=hm2DevMgmtSwVersEntry, hm2ExtNvmWritable=hm2ExtNvmWritable, hm2SfpTxPowerHighAlarm=hm2SfpTxPowerHighAlarm, hm2SfpPartRev=hm2SfpPartRev, hm2ExtNvmHWRevision=hm2ExtNvmHWRevision, hm2ModuleProductCode=hm2ModuleProductCode, hm2SfpMaxLength_fiber_50=hm2SfpMaxLength_fiber_50, hm2DevMgmtSwBugfixRelNum=hm2DevMgmtSwBugfixRelNum, hm2DevMgmtActionFlushEmailLogStats=hm2DevMgmtActionFlushEmailLogStats, hm2DevMgmtActionFlushPortStats=hm2DevMgmtActionFlushPortStats, hm2ExtNvmConfigSave=hm2ExtNvmConfigSave, hm2IfaceExtIfRole=hm2IfaceExtIfRole, hm2DevMgmtSwMajorRelNum=hm2DevMgmtSwMajorRelNum, hm2DeviceMgmtMibObjects=hm2DeviceMgmtMibObjects, hm2DeviceMgmtGroup=hm2DeviceMgmtGroup, hm2ModuleVersion=hm2ModuleVersion, hm2DevMgmtActionDelayCurrent=hm2DevMgmtActionDelayCurrent, hm2DevMgmtProductDescr=hm2DevMgmtProductDescr, hm2SfpSupportedReason=hm2SfpSupportedReason, hm2DevMgmtActionFlushMVRP=hm2DevMgmtActionFlushMVRP, hm2IfaceLayoutFormat=hm2IfaceLayoutFormat, hm2SfpWaveLength=hm2SfpWaveLength, hm2ExtNvmConfigLoadPriority=hm2ExtNvmConfigLoadPriority, hm2DevMgmtActionFlushFDB=hm2DevMgmtActionFlushFDB, hm2SfpWaveLengthTolerance=hm2SfpWaveLengthTolerance, hm2SfpRxPowerdBmHighAlarm=hm2SfpRxPowerdBmHighAlarm, hm2DevMgmtSwitchingCoreVersion=hm2DevMgmtSwitchingCoreVersion, hm2ExtNvmAdminMode=hm2ExtNvmAdminMode, hm2SfpMaxLength_fiber_62_5=hm2SfpMaxLength_fiber_62_5, hm2DevMgmtActionFlushARP=hm2DevMgmtActionFlushARP, hm2SfpModuleType=hm2SfpModuleType, hm2DeviceMgmtMib=hm2DeviceMgmtMib, hm2DevMgmtActionFlushMSRP=hm2DevMgmtActionFlushMSRP, hm2UnitIndex=hm2UnitIndex, hm2ExtNvmOperMode=hm2ExtNvmOperMode, hm2AutoDisableIntfTable=hm2AutoDisableIntfTable, hm2ExtNvmProductName=hm2ExtNvmProductName, hm2IfaceLayoutIfIndexType=hm2IfaceLayoutIfIndexType, hm2IfaceGroup=hm2IfaceGroup, hm2DevMgmtProductId=hm2DevMgmtProductId, hm2ExtNvmLogDevice=hm2ExtNvmLogDevice, hm2SfpCurrentBitRate=hm2SfpCurrentBitRate, hm2SfpInfoPartId=hm2SfpInfoPartId, hm2SfpBitRateNominal=hm2SfpBitRateNominal, hm2SfpRxPowerdBmLowAlarm=hm2SfpRxPowerdBmLowAlarm, hm2DevMgmtSwFileType=hm2DevMgmtSwFileType, hm2DevMgmtActionReset=hm2DevMgmtActionReset, hm2DevMgmtActionFlushIeee8021AS=hm2DevMgmtActionFlushIeee8021AS, hm2DevMgmtLogicVersion=hm2DevMgmtLogicVersion, hm2IfaceCableCrossing=hm2IfaceCableCrossing, hm2SfpCurrentTxPowerdBm=hm2SfpCurrentTxPowerdBm, hm2IfacePowerState=hm2IfacePowerState, hm2SfpTemperatureHighAlarm=hm2SfpTemperatureHighAlarm, hm2DevMgmtSwVersion=hm2DevMgmtSwVersion, hm2DevMgmtTemperatureLowerLimit=hm2DevMgmtTemperatureLowerLimit, hm2UnitMaxModulePortCapacity=hm2UnitMaxModulePortCapacity, hm2SfpCurrentTxPower=hm2SfpCurrentTxPower, hm2SfpRxPowerdBmHighWarning=hm2SfpRxPowerdBmHighWarning, hm2UnitTable=hm2UnitTable, hm2DevMgmtSerialNumber=hm2DevMgmtSerialNumber, hm2AutoDisableIntfErrorTime=hm2AutoDisableIntfErrorTime, hm2SFPRxPowerChangeTrap=hm2SFPRxPowerChangeTrap, hm2DeviceMgmtTemperatureGroup=hm2DeviceMgmtTemperatureGroup, hm2IfaceTable=hm2IfaceTable, hm2AutoDisablePortTrap=hm2AutoDisablePortTrap, hm2ModuleCapability=hm2ModuleCapability, hm2DevMgmtActionFlushLdapUserCache=hm2DevMgmtActionFlushLdapUserCache, hm2SfpInfoPartNumber=hm2SfpInfoPartNumber, hm2SfpTxPowerdBmHighAlarm=hm2SfpTxPowerdBmHighAlarm, hm2DevMgmtSwFileIdx=hm2DevMgmtSwFileIdx, hm2SfpRxPowerdBmLowWarning=hm2SfpRxPowerdBmLowWarning, hm2DevMgmtLogicVersEntry=hm2DevMgmtLogicVersEntry, hm2SfpBitRateMin=hm2SfpBitRateMin, hm2SfpTemperatureHighWarning=hm2SfpTemperatureHighWarning, hm2IfaceLayoutEndIfIndex=hm2IfaceLayoutEndIfIndex, hm2DevMgmtLogicAddress=hm2DevMgmtLogicAddress, hm2UnitEntry=hm2UnitEntry, hm2AutoDisableGroup=hm2AutoDisableGroup, hm2IfaceEntry=hm2IfaceEntry, hm2DevMgmtSwFileLocation=hm2DevMgmtSwFileLocation, hm2DevMgmtLogicVersTable=hm2DevMgmtLogicVersTable, hm2SfpRxPowerLowWarning=hm2SfpRxPowerLowWarning, hm2ExtNvmAutomaticSoftwareLoad=hm2ExtNvmAutomaticSoftwareLoad, hm2SfpSerialNum=hm2SfpSerialNum, hm2ModulePluggedTrap=hm2ModulePluggedTrap, hm2SfpMaxLength_fiber_e50=hm2SfpMaxLength_fiber_e50, hm2AutoDisableIntfReset=hm2AutoDisableIntfReset, hm2AutoDisableReasons=hm2AutoDisableReasons, hm2SfpWLStatus=hm2SfpWLStatus, hm2ModuleSerialNum=hm2ModuleSerialNum, hm2SfpTemperatureLowAlarm=hm2SfpTemperatureLowAlarm, hm2ModuleRemovedTrap=hm2ModuleRemovedTrap, hm2IfaceLayoutModulePortCapacity=hm2IfaceLayoutModulePortCapacity, hm2ModuleTable=hm2ModuleTable, hm2AutoDisableIntfRemainingTime=hm2AutoDisableIntfRemainingTime, hm2DevMgmtSwFileName=hm2DevMgmtSwFileName, hm2AutoDisableReasonTable=hm2AutoDisableReasonTable, hm2ExtNvmGroup=hm2ExtNvmGroup, hm2SfpWLGroup=hm2SfpWLGroup, hm2SfpVendorOUI=hm2SfpVendorOUI, hm2SfpMaxLength_fiber_9=hm2SfpMaxLength_fiber_9, hm2SfpCurrentRxPowerState=hm2SfpCurrentRxPowerState, hm2SfpTxPowerdBmLowWarning=hm2SfpTxPowerdBmLowWarning, hm2DeviceMgmtMibNotifications=hm2DeviceMgmtMibNotifications, hm2IfaceLayoutTable=hm2IfaceLayoutTable, hm2AutoDisableIntfEntry=hm2AutoDisableIntfEntry, hm2DeviceMgmtSoftwareVersionGroup=hm2DeviceMgmtSoftwareVersionGroup, hm2SfpDiagTable=hm2SfpDiagTable, hm2DevMgmtActionFlushAclStats=hm2DevMgmtActionFlushAclStats, hm2SfpGroup=hm2SfpGroup, hm2SfpInfoTable=hm2SfpInfoTable, hm2AutoDisableIntfOperState=hm2AutoDisableIntfOperState, hm2SfpRxPowerHighAlarm=hm2SfpRxPowerHighAlarm, hm2SfpMaxLength_copper=hm2SfpMaxLength_copper, hm2AutoDisableIntfComponentName=hm2AutoDisableIntfComponentName, hm2SfpBitRateMax=hm2SfpBitRateMax, hm2DevMgmtHwVersion=hm2DevMgmtHwVersion, hm2DevMgmtActionFlushIGS=hm2DevMgmtActionFlushIGS, hm2SfpRxPowerHighWarning=hm2SfpRxPowerHighWarning, hm2DevMgmtActionFlushDnsClientCache=hm2DevMgmtActionFlushDnsClientCache, hm2SfpCurrentTemperature=hm2SfpCurrentTemperature, hm2DevMgmtSwVersTable=hm2DevMgmtSwVersTable, hm2SfpRxPowerLowAlarm=hm2SfpRxPowerLowAlarm, hm2SfpTxPowerdBmLowAlarm=hm2SfpTxPowerdBmLowAlarm, hm2IfaceExtEntry=hm2IfaceExtEntry, hm2ExtNvmSerialNum=hm2ExtNvmSerialNum, hm2DevMgmtSwMinorRelNum=hm2DevMgmtSwMinorRelNum, hm2DevMgmtActionFlushIpUdpHelperStats=hm2DevMgmtActionFlushIpUdpHelperStats, hm2ExtNvmManufacturerId=hm2ExtNvmManufacturerId, hm2ExtNvmGeneralGroup=hm2ExtNvmGeneralGroup, hm2ExtNvmTable=hm2ExtNvmTable, hm2ExtNvmTableIndex=hm2ExtNvmTableIndex, hm2DeviceMgmtSoftwareGroup=hm2DeviceMgmtSoftwareGroup, hm2ModuleId=hm2ModuleId, hm2ModuleFirstMauIndex=hm2ModuleFirstMauIndex, hm2ModuleMinSWVersion=hm2ModuleMinSWVersion, hm2ModuleEntry=hm2ModuleEntry, Hm2DeviceExtNVMType=Hm2DeviceExtNVMType, hm2UnitMaxModuleCapacity=hm2UnitMaxModuleCapacity, hm2SfpConnector=hm2SfpConnector, hm2IfaceLayoutIndex=hm2IfaceLayoutIndex, hm2AutoDisableIntfErrorReason=hm2AutoDisableIntfErrorReason, hm2SfpCurrentRxPowerdBm=hm2SfpCurrentRxPowerdBm, hm2AutoDisableReasonEntry=hm2AutoDisableReasonEntry, hm2IfacePhysIndex=hm2IfacePhysIndex, hm2IfaceOperAdminStatus=hm2IfaceOperAdminStatus, hm2ModuleNumOfPorts=hm2ModuleNumOfPorts, hm2SfpTxPowerHighWarning=hm2SfpTxPowerHighWarning, hm2SfpTxPowerdBmHighWarning=hm2SfpTxPowerdBmHighWarning, hm2IfaceExtTable=hm2IfaceExtTable, hm2AutoDisableReasonCategory=hm2AutoDisableReasonCategory, hm2ModuleInternalID=hm2ModuleInternalID, hm2SfpDateCode=hm2SfpDateCode, hm2DeviceMgmtActionGroup=hm2DeviceMgmtActionGroup, hm2DevMgmtTemperatureUpperLimit=hm2DevMgmtTemperatureUpperLimit, hm2ExtNvmEntry=hm2ExtNvmEntry, hm2ModuleInternalIDVariant=hm2ModuleInternalIDVariant, PYSNMP_MODULE_ID=hm2DeviceMgmtMib, hm2SfpTxPowerLowWarning=hm2SfpTxPowerLowWarning, hm2ModuleDescription=hm2ModuleDescription, hm2SfpVendorName=hm2SfpVendorName, hm2SfpSupported=hm2SfpSupported, hm2ExtNvmVersion=hm2ExtNvmVersion, hm2DevMgmtLogicIdx=hm2DevMgmtLogicIdx, hm2SfpCurrentRxPower=hm2SfpCurrentRxPower, hm2SfpChangeTrap=hm2SfpChangeTrap, hm2ModuleAdminState=hm2ModuleAdminState, hm2DevMgmtTemperature=hm2DevMgmtTemperature, hm2DevMgmtActionFlushDnsCachingServerCache=hm2DevMgmtActionFlushDnsCachingServerCache, hm2DevMgmtSwVersBootcode=hm2DevMgmtSwVersBootcode, hm2ExtNvmStatus=hm2ExtNvmStatus, hm2SfpThresholdEntry=hm2SfpThresholdEntry, hm2DeviceMgmtLogicVersionGroup=hm2DeviceMgmtLogicVersionGroup, hm2SfpInfoEntry=hm2SfpInfoEntry, hm2ModuleStatus=hm2ModuleStatus, hm2SfpPartNumber=hm2SfpPartNumber, hm2SfpMediaType=hm2SfpMediaType, hm2AutoDisableReasonOperation=hm2AutoDisableReasonOperation, hm2DevMgmtActionFlushMMRP=hm2DevMgmtActionFlushMMRP, hm2IfaceLayoutEntry=hm2IfaceLayoutEntry, hm2AutoDisableIntfTimer=hm2AutoDisableIntfTimer, hm2UnitGroup=hm2UnitGroup, hm2IfacePortCapabilityBits=hm2IfacePortCapabilityBits, hm2SfpTemperatureLowWarning=hm2SfpTemperatureLowWarning, hm2IfaceAutoPowerDown=hm2IfaceAutoPowerDown, hm2ModuleFirstIfIndex=hm2ModuleFirstIfIndex, hm2ExtNvmChooseActive=hm2ExtNvmChooseActive, hm2DeviceMgmtHardwareGroup=hm2DeviceMgmtHardwareGroup, hm2ModuleGroup=hm2ModuleGroup)

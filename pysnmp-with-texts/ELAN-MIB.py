#
# PySNMP MIB module ELAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ELAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:59:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
AtmLaneAddress, LecDataFrameFormat, LecDataFrameSize = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "AtmLaneAddress", "LecDataFrameFormat", "LecDataFrameSize")
MacAddress, = mibBuilder.importSymbols("RFC1286-MIB", "MacAddress")
AutonomousType, = mibBuilder.importSymbols("RFC1316-MIB", "AutonomousType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, IpAddress, ObjectIdentity, Bits, Counter32, iso, Gauge32, MibIdentifier, Unsigned32, TimeTicks, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, enterprises, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "ObjectIdentity", "Bits", "Counter32", "iso", "Gauge32", "MibIdentifier", "Unsigned32", "TimeTicks", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "enterprises", "NotificationType")
TextualConvention, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TimeStamp")
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfLanEmulation = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3))
elanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2))
class IfIndexOrZero(Integer32):
    pass

class ElanLocalIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class AtmLaneMask(OctetString):
    pass

class TlvSelectorIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class PolicySelectorIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class LecsErrLogIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

elanAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1))
elanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2))
elanLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3))
elanLecsConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1))
elanLecsFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2))
elanLecsStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3))
elanAdminPolicyVal = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1))
byAtmAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 1))
byMacAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 2))
byRouteDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 3))
byLanType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 4))
byPktSize = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 1, 1, 5))
elanConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elanConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfNextId.setDescription('The next available ELAN index provided by the agent. The value of this object can be used as the index to the elanConfTable during creation.')
elanConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2), )
if mibBuilder.loadTexts: elanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTable.setDescription('This table contains all Emulated LANs (ELANs) this agent manages. An ELAN is defined by the ELAN name, a set of TLVs, and other parameters. After an ELAN is created, members of the ELAN such as the LAN Emulation Server (LES) or Client (LEC) can be added to this ELAN entry in their repective tables. There are four memebers to an ELAN and they are LECS, LES, BUS (Broadcast and Unknown Server ) and LEC. The support of LECS is optional. The addition and deletion of LECS is done in the elanLecsConfGroup defined in this MIB. The addition and deletion of the LEC are done in the LEC Assignment tables defined in this ELAN Configuration group. The addition and deletion of the LES are also defined in this group. The addition and deletion of the BUS are done in the LES MIB due to the fact that LEC learns the BUS address only from the LES it corresponds to.')
elanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1), ).setIndexNames((0, "ELAN-MIB", "elanConfIndex"))
if mibBuilder.loadTexts: elanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfEntry.setDescription('Each entry in this table represents an Emulated LAN. Objects elanConfIndex and elanConfRowStatus are required during row creation and deletion. ')
elanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 1), ElanLocalIndex())
if mibBuilder.loadTexts: elanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfIndex.setDescription('A value which uniquely identifies a conceptual row in the elanConfTable. If the conceptual row identified by this value of elanConfIndex is recreated following an agent restart, the same value of elanConfIndex must be used to identify the recreated row.')
elanConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfName.setReference('The name of this Emulated LAN entry. When this object length is zero then the ELAN name is not specified. The clients assigned to this ELAN will also have a zero length string as the ELAN name. Note that ELAN name may be used as cross reference to the LES MIB and BUS MIB though not required. Multiple ELANs with no ELAN name specified will cause conflicts in reference to LES and BUS MIBs.')
if mibBuilder.loadTexts: elanConfName.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfName.setDescription('The name of this Emulated LAN entry. When this object length is zero then the ELAN name is not specified. The clients assigned to this ELAN will also have a zero length string as the ELAN name. Note that ELAN name may be used as cross reference to the LES MIB and BUS MIB though not required. Multiple ELANs with no ELAN name specified will cause conflicts in reference to LES and BUS MIBs.')
elanConfTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 3), TlvSelectorIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfTlvIndex.setDescription('The value of this object identifies one or more rows in the lecsTlvTable which applies to this ELAN. This object is set to zero if 1) LECS is not supported. or 2) there is no TLV associated with this entry. If the LEC assignment policy type is by TLVs, then the LECS matches the TLVs in the CONFIGURE request with TLVs assigned to each ELAN, and assign the requestor to the matching ELAN. If the LECS receives a CONFIGURE request with no TLV, the LECS may try to match it to the entry in this table with a zero value elanConfTlvIndex. In the case there is more than one entry in this table with zero value elanConfTlvIndex, the behavior of the LECS is not specified.')
elanConfLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 4), LecDataFrameFormat()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfLanType.setReference('The LAN type of this ELAN entry. This object is required to be either 802.3 or 802.5. If the LEC assignment policy is by LAN type. That is, if the LECS is assigning the LEC to ELAN according to its LAN type, this object is used to indicate the LAN type of the ELAN.')
if mibBuilder.loadTexts: elanConfLanType.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfLanType.setDescription('The LAN type of this ELAN entry. This object is required to be either 802.3 or 802.5. If the LEC assignment policy is by LAN type. That is, if the LECS is assigning the LEC to ELAN according to its LAN type, this object is used to indicate the LAN type of the ELAN.')
elanConfMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 5), LecDataFrameSize()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfMaxFrameSize.setReference('The maximum data frame size of this ELAN entry. The maximum AAL-5 SDU size of a data frame that this ELAN can support. This object is required to be one of the enumerations except other(1) when the LEC assignment policy is by Data Frame Size. That is, if LECS is assigning the LEC to ELAN according to its maximum data frame size, this object is used to specify the frame size supported by this ELAN.')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfMaxFrameSize.setDescription('The maximum data frame size of this ELAN entry. The maximum AAL-5 SDU size of a data frame that this ELAN can support. This object is required to be one of the enumerations except other(1) when the LEC assignment policy is by Data Frame Size. That is, if LECS is assigning the LEC to ELAN according to its maximum data frame size, this object is used to specify the frame size supported by this ELAN.')
elanConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanConfRowStatus.setReference('This object is used to create or delete entries in the elanConfTable.')
if mibBuilder.loadTexts: elanConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanConfRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
elanLesTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3), )
if mibBuilder.loadTexts: elanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesTable.setDescription('This table contains all LESs for each ELAN specified in the elanConfTable. Each ELAN can have more than one LES providing LAN Emulation services. Each LES can service only one ELAN. The table is indexed by the elanConfIndex which points to the ELAN this LES is providing service to, and elanLesIndex which unquely identifies a LES. This table is used for configuration of an ELAN only, that is, creating a LES in this table does not instantiate a LES in the network. It is done in the LES MIB.')
elanLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1), ).setIndexNames((0, "ELAN-MIB", "elanConfIndex"), (0, "ELAN-MIB", "elanLesIndex"))
if mibBuilder.loadTexts: elanLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesEntry.setDescription('Each entry in this table represents a LES/Emulated LAN pair. Object elanLesAtmAddress besides elanLesRowStatus is also required during row creation.')
elanLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: elanLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesIndex.setDescription('An arbitrary number which uniquely identifies the LES this entry pertains to.')
elanLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesAtmAddress.setDescription('The ATM address of the LES entry. If LECS is supported, the value of this object is the LES ATM address LECS returns to the LEC in the CONFIGURE response. If LECS is not supported, the value of this object pertains to the LES ATM address network manager provides to the LEC. The LEC assigned to this ELAN uses this ATM address as the called party address in the JOIN request. The calling party address used by LES in the JOIN response is not specified by this MIB.')
elanLesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLesRowStatus.setReference('This object is used to create or delete entries in the elanLesfTable.')
if mibBuilder.loadTexts: elanLesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLesRowStatus.setDescription('This object is used to create or delete entries in the elanLesfTable.')
elanPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4), )
if mibBuilder.loadTexts: elanPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyTable.setDescription("This table contains all policies this agent supports for assigning a LEC to an ELAN. A set of policies with the same or different priorities can be selected by the entity which provides ELAN configuration service such as the LECS. The policy with the highest priority or with the smallest elanPolicyPriority , is evaluated first. The policies with the same elanPolicyPriority are evaluated at the same time with the AND operation. When LECS receives a configure request, it checks it's policies selected from this table to determine which ELAN and LES the LEC will join. This table is indexed by a selector index and a policy index. The policy index unquely identifies a policy and the selector index allows multiple policies be selected by one LECS or an entity that is providing ELAN configuration service.")
elanPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1), ).setIndexNames((0, "ELAN-MIB", "elanPolicySelectorIndex"), (0, "ELAN-MIB", "elanPolicyIndex"))
if mibBuilder.loadTexts: elanPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyEntry.setDescription('Each entry in this table represents a policy supported by the entity which provides ELAN configuration services. Each policy can be used to evaluate the CONFIGURE request from the LEC in determining which ELAN it belongs to. ')
elanPolicySelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 1), PolicySelectorIndexType())
if mibBuilder.loadTexts: elanPolicySelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicySelectorIndex.setDescription('The value of this object indicates a group of policies that can be selected by the ELAN configuration service provider such as the LECS.')
elanPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: elanPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyIndex.setDescription('The value of this object uniquely identifies a single policy entry in this table. ')
elanPolicyPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyPriority.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyPriority.setDescription('The priority of this policy entry. Policies are evaluated by the entity which provides ELAN configuration service (LECS) by their priorities. Policies with the same priority values should be evludated at the same time with an AND operation. That is, if one of the policy with the same priority is not met, the evluation should fail. The value 1 has the highest priority.')
elanPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 4), AutonomousType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyType.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyType.setDescription('The type of this policy. The value of this object is an object identifier points to a leaf in the elanAdminGroup The value of this object has to exist in the tree before being modified or created. A vender can use a vender specific policy added to the elanAdminPolicyVal or a separate vender tree. The agent is not required to support every types specified in the elanAdminGroup under elanAdminPolicyVal.')
elanPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanPolicyRowStatus.setReference('This object is used to create or delete entries in the elanPolicyTable.')
if mibBuilder.loadTexts: elanPolicyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanPolicyRowStatus.setDescription('This object is used to create or delete entries in the elanPolicyTable.')
elanLecAtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5), )
if mibBuilder.loadTexts: elanLecAtmAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrTable.setDescription("This table is used to assign a LEC to an ELAN by ATM address. When the by ATM address policy is used, this table is used to specify the LEC's ATM address or portion of an ATM address. The ATM address is used by the LECS or other entity which serves the LANE configuration function to determine the ELAN membership. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, the LEC's ATM address and an ATM address mask. Portions of ATM address can be used in dertermining ELAN membership by using both the ATM address and the mask.")
elanLecAtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1), ).setIndexNames((0, "ELAN-MIB", "elanConfIndex"), (0, "ELAN-MIB", "elanLesIndex"), (0, "ELAN-MIB", "elanLecAtmAddress"), (0, "ELAN-MIB", "elanLecAtmMask"))
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddrEntry.setDescription('Each entry represents a LEC to ELAN binding.')
elanLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 1), AtmLaneAddress())
if mibBuilder.loadTexts: elanLecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmAddress.setDescription('The value of this object is the ATM address of a LAN Emulation client. This object and the object elanLecAtmMask are used to form an ATM address or portion of an ATM address to be used by the LECS in determining the ELAN membership when the policy of this LECS is by ATM address.')
elanLecAtmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecAtmMask.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmMask.setDescription("The ATM address mask associated with the object elanLecAtmAddress. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
elanLecAtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecAtmRowStatus.setReference('This object is used to create or destroy entries in this table.')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecAtmRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecMacAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6), )
if mibBuilder.loadTexts: elanLecMacAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrTable.setDescription("This table is used to assign a LEC to an ELAN by MAC address. When the byMacAddress policy is used, this table is used to specify the LEC's ELAN membership by ATM address. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's MAC address.")
elanLecMacAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1), ).setIndexNames((0, "ELAN-MIB", "elanConfIndex"), (0, "ELAN-MIB", "elanLesIndex"), (0, "ELAN-MIB", "elanLecMacAddress"))
if mibBuilder.loadTexts: elanLecMacAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddrEntry.setDescription('Each entry represents a LEC to ELAN binding.')
elanLecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 1), MacAddress())
if mibBuilder.loadTexts: elanLecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacAddress.setDescription('The value of this object is the MAC address of a LAN Emulation client. When a CONFIGURE request is received with this MAC address, it will be assigned to the ELAN which elanConfIndex is pointing to.')
elanLecMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 6, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecMacRowStatus.setReference('This object is used to create or destroy entries in this table.')
if mibBuilder.loadTexts: elanLecMacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecMacRowStatus.setDescription('This object is used to create or destroy entries in this table.')
elanLecRdTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7), )
if mibBuilder.loadTexts: elanLecRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdTable.setDescription("This table is used to assign a LEC to an ELAN by Route Descriptor. When the by Route Descriptor policy is used, this table is used to specify the LEC's ELAN membership by Route Descriptor. This table is indexed by the elanConfIndex which points to the ELAN this LEC belongs, the elanLesIndex which points to the LES this LEC should join, and the LEC's Route Descriptors.")
elanLecRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1), ).setIndexNames((0, "ELAN-MIB", "elanConfIndex"), (0, "ELAN-MIB", "elanLesIndex"), (0, "ELAN-MIB", "elanLecRdSegId"), (0, "ELAN-MIB", "elanLecRdBridgeNum"))
if mibBuilder.loadTexts: elanLecRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdEntry.setDescription('Each entry represents a LEC to ELAN binding. ')
elanLecRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: elanLecRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdSegId.setDescription('The LAN ID portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
elanLecRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: elanLecRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdBridgeNum.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
elanLecRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 2, 7, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecRdRowStatus.setReference('This object is used to create or destroy entries in this table.')
if mibBuilder.loadTexts: elanLecRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecRdRowStatus.setDescription('This object is used to create or destroy entries in this table.')
lecsConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 1), ElanLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfNextId.setDescription('The next available LECS index. The value of this object can be used as the index to the lecsTable during creation.')
lecsConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2), )
if mibBuilder.loadTexts: lecsConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfTable.setDescription('This table contains the configuration information of all LECS this agent manages. This table can also be used to create, delete or configure a LECS.')
lecsConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1), ).setIndexNames((0, "ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: lecsConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfEntry.setDescription("Each entry represents a LECS this agent maintains. Objects lecsAtmIfIndex, lecsAtmAddrSpec, and lecsAtmAddrMask cannot be modified unless the lecsAdminStatus is set to down(2). And the change doesn't take effect until the lecsAdminStatus is set to up(1).")
lecsConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: lecsConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfIndex.setDescription('An arbitrary integer which represents a LECS this agent manages. If the conceptual row identified by this value of lecsConfIndex is recreated following an agent restart, the same value of elanConfIndex must be used to identify the recreated row.')
lecsAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 2), IfIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmIfIndex.setDescription('An ATM interface which the LECS receives CONFIGURE requests from. This value must match an existing value in the ifTable. This object is set to zero when the ATM interface is not specified or there is more than one ATM interface used by the LECS.')
lecsAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 3), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrSpec.setDescription('An ATM address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the LECS on the designated ATM interface will use to derive the actual ATM address from the network or ILMI. The derived ATM address is specified in the object lecsAtmAddrActual, which is used to receive CONFIGURE requests. The value of this object, if not specified, is defaulted to the well-known LECS ATM address specified in the LAN Emulation Spec. 1.0.')
lecsAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 4), AtmLaneMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrMask.setDescription("The ATM address mask associated with the object lecsAtmAddrSpec. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
lecsAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrActual.setDescription(" The resulting ATM address that the LECS is accepting CONFIGURE requests on the interface indicated by the object lecsAtmIfIndex. This address is the result of the specified ATM address, its mask and interaction through the ILMI with the switch. Note that this object is only valid when the corresponding lecsOperStatus is 'up'.")
lecsPolicySelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 6), PolicySelectorIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsPolicySelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsPolicySelIndex.setDescription('The set of policies used by this LECS in dertermining requesters ELAN membership. The policies are defined in the elanPolicyTable. The value of this object must exist in the elanPolicyTable.')
lecsLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLastInitialized.setDescription('The value of the sysUpTime since LECS has last entered the state indicated by the object lecsOperStatus.')
lecsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsOperStatus.setDescription(" This object reflects the actual state of the LECS which may differ from that of the lecsAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding lecsAdminStatus is 'up'.")
lecsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAdminStatus.setDescription('The desired state of the LECS on this interface as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lecsOperStatus.')
lecsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 2, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsRowStatus.setReference('This object is used to create or delete entries in this table.')
if mibBuilder.loadTexts: lecsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRowStatus.setDescription('This object is used to create or delete entries in this table.')
lecsElanTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3), )
if mibBuilder.loadTexts: lecsElanTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanTable.setDescription('This table contains the mapping between ELANs and LECS. One LECS can manage more than one ELAN and one ELAN can only be managed by a LECS. When a LECS is deleted from the lecsConfTable, all entries associated with this entry will also be deleted.')
lecsElanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1), )
if mibBuilder.loadTexts: lecsElanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanEntry.setDescription('Each entry represents an ELAN to LECS mapping.')
elanLecsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 3, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elanLecsRowStatus.setReference('This object is used to create or delete an entry from this table.')
if mibBuilder.loadTexts: elanLecsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: elanLecsRowStatus.setDescription('This object is used to create or delete an entry from this table.')
lecsTlvTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4), )
if mibBuilder.loadTexts: lecsTlvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTable.setDescription('This table contains all TLVs this agent supports. This includes not only the standard TLVs specified in the LAN Emulation Spec. 1.0 [1] but also the additional parameters exchanged between the LECS and LEC. This table is indexed by a selector index, which allows more than one TLV to be selected by an ELAN; and the TLV tag, which specified the type of the TLV; and a TLV index which is used to distinguish between different entries with the same TLV tag. How does the LECS treat the TLVs that are not specified in this table in the CONFIGURE requests are not defined in this MIB.')
lecsTlvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1), ).setIndexNames((0, "ELAN-MIB", "lecsTlvSelectorIndex"), (0, "ELAN-MIB", "lecsTlvTag"), (0, "ELAN-MIB", "lecsTlvIndex"))
if mibBuilder.loadTexts: lecsTlvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvEntry.setDescription('Each entry represents a set of TLV encodings for an ELAN represented by the elanConfIndex. Objects lecsTlvVal and lecsTlvRowStatus are required during row creation.')
lecsTlvSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 1), TlvSelectorIndexType())
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvSelectorIndex.setDescription('The value of this object indicates a group of TLVs that can be selected.')
lecsTlvTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 2), OctetString())
if mibBuilder.loadTexts: lecsTlvTag.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvTag.setDescription('The value of this object represents the type of the contents of the lecsTlvVal field in the entry. The OUI field in this object occupies the first ( or most significant )3 octets. The OUI value 00-A0-3E is used for the standard values defined by the ATM Forum specification.')
lecsTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: lecsTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvIndex.setDescription('The index of this TLV encoding entry. The value of this object can be used to distinguish between different entries with the same lecsTlvTag value.')
lecsTlvVal = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvVal.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvVal.setDescription('The value of this TLV entry.')
lecsTlvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 1, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsTlvRowStatus.setReference('This object is used to create or destroy entries in this table. ')
if mibBuilder.loadTexts: lecsTlvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTlvRowStatus.setDescription('This object is used to create or destroy entries in this table. ')
lecsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1), )
if mibBuilder.loadTexts: lecsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsTable.setDescription(' A (conceptual) table of statistics associated with all LECS instances on the device.')
lecsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1), )
if mibBuilder.loadTexts: lecsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatsEntry.setDescription(' A (conceptual) row in the lecsStatsTable which corresponds to the statistics kept by a particular instance of a LECS.')
lecsStatSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatSuccessful.setDescription('The number of CONFIGURE requests successfully granted since the agent was last initialized.')
lecsStatInBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInBadFrames.setDescription('The number of mal formed CONFIGURE requests dropped by the LECS.')
lecsStatInvalidParam = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidParam.setReference('The number of CONFIGURE requests rejected due to the invalid request parameters error.')
if mibBuilder.loadTexts: lecsStatInvalidParam.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidParam.setDescription('The number of CONFIGURE requests rejected due to the invalid request parameters error.')
lecsStatInsufRes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufRes.setReference('The number of CONFIGURE requests rejected due to the insufficent resources to grant request error.')
if mibBuilder.loadTexts: lecsStatInsufRes.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufRes.setDescription('The number of CONFIGURE requests rejected due to the insufficent resources to grant request error.')
lecsStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatAccDenied.setReference('The number of CONFIGURE requests rejected due to the access denied error.')
if mibBuilder.loadTexts: lecsStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatAccDenied.setDescription('The number of CONFIGURE requests rejected due to the access denied error.')
lecsStatInvalidReq = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidReq.setReference('The number of CONFIGURE requests rejected due to the invalid requester-id error.')
if mibBuilder.loadTexts: lecsStatInvalidReq.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidReq.setDescription('The number of CONFIGURE requests rejected due to the invalid requester-id error.')
lecsStatInvalidDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidDest.setReference('The number of CONFIGURE requests rejected due to the invalid destination error.')
if mibBuilder.loadTexts: lecsStatInvalidDest.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidDest.setDescription('The number of CONFIGURE requests rejected due to the invalid destination error.')
lecsStatInvalidAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInvalidAddr.setReference('The number of CONFIGURE requests rejected due to the invalid ATM address error.')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInvalidAddr.setDescription('The number of CONFIGURE requests rejected due to the invalid ATM address error.')
lecsStatNoConf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatNoConf.setReference('The number of CONFIGURE requests rejected due to the LE Client is not recognized error.')
if mibBuilder.loadTexts: lecsStatNoConf.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatNoConf.setDescription('The number of CONFIGURE requests rejected due to the LE Client is not recognized error.')
lecsStatConfError = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatConfError.setReference('The number of CONFIGURE requests rejected due to the LE_CONFIGURE error.')
if mibBuilder.loadTexts: lecsStatConfError.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatConfError.setDescription('The number of CONFIGURE requests rejected due to the LE_CONFIGURE error.')
lecsStatInsufInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsStatInsufInfo.setReference('The number of CONFIGURE requests rejected due to the insufficient information error.')
if mibBuilder.loadTexts: lecsStatInsufInfo.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatInsufInfo.setDescription('The number of CONFIGURE requests rejected due to the insufficient information error.')
lecsErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1), )
if mibBuilder.loadTexts: lecsErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlTable.setDescription('This table contains error log control information of all LECS instances. This table is an extention to the lecsConfTable. It is used to enable or disable error logs for a particular LECS entry.')
lecsErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1), )
if mibBuilder.loadTexts: lecsErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlEntry.setDescription('Each entry represents a LECS entry in the lecsConfTable.')
lecsErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlAdminStatus.setDescription('This object is used to enable/disable error logging for the LECS.')
lecsErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlOperStatus.setDescription('This object is used to indicate the result of a set operation to the object lecsErrCtlAdminStatus. If the error log was successfully started, it is in active(2) mode. Otherwise, it is set to either outOfRes(3) or failed(4) for the respective reasons.')
lecsErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlClearLog.setDescription('This object is used to clear the error log entries associated with this LECS.')
lecsErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlMaxEntries.setDescription('The maximum entries of the error log a LECS can support.')
lecsErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 1, 1, 5), LecsErrLogIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrCtlLastEntry.setDescription('The index to the last entry in the error log table associated with this LECS.')
lecsErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2), )
if mibBuilder.loadTexts: lecsErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTable.setDescription('This table contains error logs of the LECS instances enabled in the lecsErrCtlTable. This table is indexed by the LECS instance index and an arbitrary integer uniquely identifies an error log.')
lecsErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1), ).setIndexNames((0, "ELAN-MIB", "lecsConfIndex"), (0, "ELAN-MIB", "lecsErrLogIndex"))
if mibBuilder.loadTexts: lecsErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogEntry.setDescription('Each entry represents a LEC that was rejected due to a violation against the policies or an error.')
lecsErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 1), LecsErrLogIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogIndex.setDescription('An arbitrary integer which uniquely identifies an error log entry. This number ranges from 1 to the value of the object lecsErrCtlMaxEntries times number of LECS error log capability enabled. The enabling/disabling of the error log capability is done in the lecsErrCtlTable.')
lecsErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogAtmAddr.setDescription('The ATM address of the requester which sends the CONFIGURE request and causes the error to occur. The corresponding error code is specified in the object lecsErrLogErrCode.')
lecsErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogErrCode.setDescription('The Error code which indicates the cause of the error triggered by the CONFIGURE request sent by the requester indicated by the value of the object lecsErrLogAtmAddr.')
lecsErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 3, 2, 2, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: lecsErrLogTime.setDescription('The sysUpTime when this entry was logged by the LECS.')
elanMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4))
elanMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1))
elanMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 2))
elanMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 2, 1))
elanCConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 1))
elanLecAssignByAtmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 2))
elanLecAssignByMacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 3))
elanLecAssignByRdGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 4))
lecsCStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 5))
lecsCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 6))
lecsCFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 2, 4, 1, 7))
mibBuilder.exportSymbols("ELAN-MIB", elanPolicyRowStatus=elanPolicyRowStatus, elanLecAtmAddress=elanLecAtmAddress, elanLesIndex=elanLesIndex, LecsErrLogIndexType=LecsErrLogIndexType, elanConfMaxFrameSize=elanConfMaxFrameSize, TlvSelectorIndexType=TlvSelectorIndexType, elanConfRowStatus=elanConfRowStatus, lecsStatInvalidParam=lecsStatInvalidParam, lecsCStatGroup=lecsCStatGroup, atmForumNetworkManagement=atmForumNetworkManagement, elanAdminGroup=elanAdminGroup, lecsAtmAddrActual=lecsAtmAddrActual, elanLesAtmAddress=elanLesAtmAddress, lecsElanEntry=lecsElanEntry, elanMIBGroups=elanMIBGroups, byMacAddr=byMacAddr, lecsAtmAddrMask=lecsAtmAddrMask, lecsCFaultGroup=lecsCFaultGroup, elanLecMacRowStatus=elanLecMacRowStatus, elanCConfGroup=elanCConfGroup, elanConfLanType=elanConfLanType, byRouteDescriptor=byRouteDescriptor, elanLecRdTable=elanLecRdTable, lecsConfTable=lecsConfTable, elanConfTable=elanConfTable, elanConfName=elanConfName, elanLecRdRowStatus=elanLecRdRowStatus, lecsLastInitialized=lecsLastInitialized, elanLecAtmAddrTable=elanLecAtmAddrTable, elanMIBCompliances=elanMIBCompliances, elanMIB=elanMIB, lecsErrCtlLastEntry=lecsErrCtlLastEntry, lecsStatConfError=lecsStatConfError, elanConfEntry=elanConfEntry, lecsStatInvalidReq=lecsStatInvalidReq, elanConfTlvIndex=elanConfTlvIndex, byPktSize=byPktSize, lecsOperStatus=lecsOperStatus, lecsTlvIndex=lecsTlvIndex, lecsElanTable=lecsElanTable, lecsPolicySelIndex=lecsPolicySelIndex, elanPolicyIndex=elanPolicyIndex, lecsRowStatus=lecsRowStatus, lecsStatAccDenied=lecsStatAccDenied, elanPolicyTable=elanPolicyTable, elanConfGroup=elanConfGroup, elanPolicyPriority=elanPolicyPriority, elanLecMacAddress=elanLecMacAddress, lecsErrLogAtmAddr=lecsErrLogAtmAddr, lecsCGroup=lecsCGroup, lecsErrLogTable=lecsErrLogTable, elanConfIndex=elanConfIndex, lecsErrLogTime=lecsErrLogTime, lecsStatInBadFrames=lecsStatInBadFrames, elanPolicyEntry=elanPolicyEntry, lecsAdminStatus=lecsAdminStatus, lecsTlvTag=lecsTlvTag, lecsErrCtlOperStatus=lecsErrCtlOperStatus, elanMIBConformance=elanMIBConformance, lecsStatNoConf=lecsStatNoConf, IfIndexOrZero=IfIndexOrZero, elanPolicySelectorIndex=elanPolicySelectorIndex, lecsStatInvalidAddr=lecsStatInvalidAddr, elanLecsConfGroup=elanLecsConfGroup, lecsAtmAddrSpec=lecsAtmAddrSpec, elanLecMacAddrEntry=elanLecMacAddrEntry, elanLesRowStatus=elanLesRowStatus, elanLecAtmAddrEntry=elanLecAtmAddrEntry, lecsStatInsufRes=lecsStatInsufRes, lecsStatInsufInfo=lecsStatInsufInfo, lecsErrCtlEntry=lecsErrCtlEntry, elanLecsStatGroup=elanLecsStatGroup, atmForum=atmForum, atmfLanEmulation=atmfLanEmulation, lecsErrLogIndex=lecsErrLogIndex, elanLecRdEntry=elanLecRdEntry, elanLesTable=elanLesTable, lecsErrLogEntry=lecsErrLogEntry, elanLecAtmRowStatus=elanLecAtmRowStatus, elanLecMacAddrTable=elanLecMacAddrTable, lecsErrCtlClearLog=lecsErrCtlClearLog, AtmLaneMask=AtmLaneMask, lecsTlvSelectorIndex=lecsTlvSelectorIndex, lecsConfIndex=lecsConfIndex, elanLecAssignByAtmGroup=elanLecAssignByAtmGroup, lecsStatInvalidDest=lecsStatInvalidDest, elanLecAssignByRdGroup=elanLecAssignByRdGroup, lecsStatsTable=lecsStatsTable, elanLecsFaultGroup=elanLecsFaultGroup, lecsTlvRowStatus=lecsTlvRowStatus, lecsTlvTable=lecsTlvTable, elanLecRdBridgeNum=elanLecRdBridgeNum, elanLecAtmMask=elanLecAtmMask, lecsErrCtlMaxEntries=lecsErrCtlMaxEntries, lecsErrCtlAdminStatus=lecsErrCtlAdminStatus, lecsErrLogErrCode=lecsErrLogErrCode, lecsStatSuccessful=lecsStatSuccessful, ElanLocalIndex=ElanLocalIndex, lecsConfEntry=lecsConfEntry, lecsConfNextId=lecsConfNextId, elanConfNextId=elanConfNextId, lecsAtmIfIndex=lecsAtmIfIndex, elanMIBCompliance=elanMIBCompliance, elanLecAssignByMacGroup=elanLecAssignByMacGroup, lecsTlvEntry=lecsTlvEntry, lecsStatsEntry=lecsStatsEntry, lecsErrCtlTable=lecsErrCtlTable, PolicySelectorIndexType=PolicySelectorIndexType, byAtmAddr=byAtmAddr, lecsTlvVal=lecsTlvVal, elanLecsGroup=elanLecsGroup, elanPolicyType=elanPolicyType, elanAdminPolicyVal=elanAdminPolicyVal, byLanType=byLanType, elanLecsRowStatus=elanLecsRowStatus, elanLecRdSegId=elanLecRdSegId, elanLesEntry=elanLesEntry)

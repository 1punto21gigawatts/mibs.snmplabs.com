#
# PySNMP MIB module CXIoHardware-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXIoHardware-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:32:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
Alias, cxIoHardware = mibBuilder.importSymbols("CXProduct-SMI", "Alias", "cxIoHardware")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, NotificationType, Integer32, TimeTicks, Unsigned32, Counter64, Counter32, MibIdentifier, IpAddress, ModuleIdentity, ObjectIdentity, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "NotificationType", "Integer32", "TimeTicks", "Unsigned32", "Counter64", "Counter32", "MibIdentifier", "IpAddress", "ModuleIdentity", "ObjectIdentity", "Bits", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cxIoCardAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1), )
if mibBuilder.loadTexts: cxIoCardAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmTable.setDescription('Administrative table used to configure the required I/O card hardware.')
cxIoCardAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1), ).setIndexNames((0, "CXIoHardware-MIB", "cxIoCardAdmIndex"))
if mibBuilder.loadTexts: cxIoCardAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmEntry.setDescription('The parameters required to fully specify the I/O card.')
cxIoCardAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardAdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmIndex.setDescription('Index used for table management only. No other MIB object refers to this index.')
cxIoCardAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2), ("disabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoCardAdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmRowStatus.setDescription('Indicates whether a particular I/O card is configured within the MIB. Options: invalid (1): Deletes an I/O card entry (row) from the MIB table. valid (2): Creates an I/O card entry (row) in the MIB table. disabled (3): No I/O card entries being created or deleted. Default Value: disabled (3) Configuration Changed: operative')
cxIoCardAdmAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 3), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoCardAdmAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmAlias.setDescription('Identifies an alias or alternative name for this card. This alias is recorded in the port administrative table to link it to the correct I/O card. Range of Values: 0 to 35 alphanumeric characters beginning with a non-numeric character Default Value: none Configuration Changed: administrative')
cxIoCardAdmPhysSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoCardAdmPhysSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmPhysSlot.setDescription('Identifies the CX1000 I/O slot being configured. Range of Values: 1 - 16 Default Value: none Configuration Changed: administrative')
cxIoCardAdmType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("iuscFourPortCard", 1), ("lanCard", 2), ("vceCmpCard", 3), ("tokenRingCard", 4), ("ethernetCard", 5), ("isdnCard", 6), ("digitalVceCmpCard", 7), ("highSpeedFr4LIDCard", 8), ("octalV34ModemCard", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoCardAdmType.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmType.setDescription('Identifies the type of card that occupies or will occupy this slot. Options: iuscFourPortCard (1): a proprietary I/O card lanCard (2): a LAN adapter such as an Ethernet or Token-Ring card vceCmpCard (3): a voice Compression Card tokenRingCard (4): a Token-Ring I/O card for TL600 ethernetCard (5): an Ethernet I/O card for EL600 isdnCard (6): a T1/E1 ISDN I/O card digitalVceCmpCard (7): a Digital Voice Compression Card ( 15 channels ) highSpeedFr4LIDCard (8): a high speed frame relay 4-LID I/O card octalV34ModemCard (9): an octal V.34 modem I/O card Default Value: none Related Objects: cxIoCardAdmState cxIoCardAdmPhysSlot Configuration Changed: administrative')
cxIoCardAdmState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardAdmState.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardAdmState.setDescription('Indicates whether the card type configured using the cxIoCardAdmType object matches the card inserted in the slot. Options: invalid (1): The configured card type does not match the card inserted in the slot. You must adjust one or the other. valid (2): The configured card typed matches the card inserted in the slot. Related Objects: cxIoCardAdmPhysSlot cxIoCardAdmType')
cxIoPortAdmTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2), )
if mibBuilder.loadTexts: cxIoPortAdmTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmTable.setDescription('Administrative table used to configure the required I/O port hardware.')
cxIoPortAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1), ).setIndexNames((0, "CXIoHardware-MIB", "cxIoPortAdmIndex"))
if mibBuilder.loadTexts: cxIoPortAdmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmEntry.setDescription('The parameters required to fully specify the I/O port.')
cxIoPortAdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoPortAdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmIndex.setDescription('Index used for table management only. No other MIB object refers to this index.')
cxIoPortAdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2), ("disabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoPortAdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmRowStatus.setDescription('Indicates whether a particular I/O port is configured within the MIB. Options: invalid (1): Deletes an I/O port entry (row) from the MIB table. valid (2): Creates an I/O port entry (row) in the MIB table. disabled (3): No I/O port entries (rows) created or deleted. Default Value: disabled (3) Configuration Changed: operative')
cxIoPortAdmAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1, 3), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoPortAdmAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmAlias.setDescription('Specifies an alias or alternative name for this hardware port. This alias is used by the related driver SAP to link it to the correct I/O hardware port. Range of Values: 0 to 35 alphanumeric characters beginning with a non-numeric character Default Value: none Configuration Changed: administrative')
cxIoPortAdmCardAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1, 4), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoPortAdmCardAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmCardAlias.setDescription('Specifies the alias of the I/O card containing this port. Range of Values: 0 to 35 alphanumeric characters beginning with a non-numeric character Default Value: none Related Objects: cxIoCardAdmAlias Configuration Changed: administrative')
cxIoPortAdmCardLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoPortAdmCardLocalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoPortAdmCardLocalIndex.setDescription("Defines this port's position on the I/O card. This information is presented as an index. Note: To move to a different port on an I/O card, you need only change this value. Range of Values: Dependent on I/O card type Configuration Changed: administrative")
cxIoCardOperTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3), )
if mibBuilder.loadTexts: cxIoCardOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperTable.setDescription('Table describing what the software detects at each I/O slot on this CPU card')
cxIoCardOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1), ).setIndexNames((0, "CXIoHardware-MIB", "cxIoCardOperPhysSlot"))
if mibBuilder.loadTexts: cxIoCardOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperEntry.setDescription('Contains all parameters describing the detected I/O cards. The rows in this table are always defined since they cannot be created or deleted. The number of rows represents the maximum number of I/O cards a CPU card can support. For the current CX1000 chassis, eight I/O slots are available. The cxIoCardOperState object determines whether the I/O slot is occupied by an I/O card. The table index corresponds to the physical slot number of the chassis. From the current I/O-to-CPU slot relation defined, the first index in this table is equal to the CPU card slot number. The last index in this table is the CPU card slot number plus 7. Entries for which no corresponding slot number exists in the chassis are not defined. For example, on a CPU card using slot 14, the I/O card index ranges from 14 to 21; however, the entries related to slot numbers 18 to 21 will not be used since no such slots exist.')
cxIoCardOperPhysSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperPhysSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperPhysSlot.setDescription('Identifies the CX1000 I/O slot being described.')
cxIoCardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperState.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperState.setDescription('Indicates whether the particular I/O card is physically present.')
cxIoCardOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("iuscFourPortCard", 1), ("lanCard", 2), ("vceCmpCard", 3), ("tokenRingCard", 4), ("ethernetCard", 5), ("isdnCard", 6), ("digitalVceCmpCard", 7), ("highSpeedFr4LIDCard", 8), ("octalV34ModemCard", 9), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperType.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperType.setDescription('Identifies the type of card occupying this slot. This information is detected by the CX1000. Options: iuscFourPortCard (1): a proprietary I/O card lanCard (2): a LAN adapter such as an Ethernet or Token-Ring card for CL600 vceCmpCard (3): a voice Compression Card tokenRingCard (4): a Token-Ring I/O card for TL600 ethernetCard (5): an Ethernet I/O card for EL600 isdnCard (6): a T1/E1 ISDN I/O card digitalVceCmpCard (7): a Digital Voice Compression Card ( 15 channels ) highSpeedFr4LIDCard (8): a high speed frame relay 4-LID I/O card octalV34ModemCard (9): an octal V.34 modem I/O card other (255): none of the above. ')
cxIoCardOperRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperRevision.setDescription('The revision number read from the I/O card ID register.')
cxIoCardOperAssemblyAndEco = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperAssemblyAndEco.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperAssemblyAndEco.setDescription('The assembly and ECO numbers read from the I/O card assembly and ECO registers.')
cxIoCardOperSpecialEco = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIoCardOperSpecialEco.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoCardOperSpecialEco.setDescription('The special ECO number read from the I/O card special ECO register.')
cxIoHwCardTypeTrapReport = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxIoHwCardTypeTrapReport.setStatus('mandatory')
if mibBuilder.loadTexts: cxIoHwCardTypeTrapReport.setDescription("Indicates whether a mismatch between the value of the cxIoCardAdmType object (the configured card type) and the physical card inserted in the slot should generate a cxIoHwCardTypeTrap. Options: disabled (1): No action taken when a mismatch is detected. enabled (2): Generates a 'cxIoHwCardTypeTrap' when a mismatch is detected. Default Value: disabled (1) Related Objects: cxIoHwCardTypeTrap cxIoCardAdmType cxIoCardOperType Configuration Changed: administrative")
cxIHMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxIHMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxIHMibLevel.setDescription('Used to determine current MIB module release supported by the agent. Object is in decimal.')
cxIoHwCardTypeTrap = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 5, 2) + (0,1)).setObjects(("CXIoHardware-MIB", "cxIoCardOperPhysSlot"), ("CXIoHardware-MIB", "cxIoCardOperState"), ("CXIoHardware-MIB", "cxIoCardOperType"))
if mibBuilder.loadTexts: cxIoHwCardTypeTrap.setDescription('Indicates that a mismatch exists between the configured card type and card type detected in the slot by the software. A trap is also produced if the slot is empty. Related Objects: cxIoCardOperPhysSlot cxIoCardOperState, cxIoCardOperType')
mibBuilder.exportSymbols("CXIoHardware-MIB", cxIoPortAdmAlias=cxIoPortAdmAlias, cxIoCardOperSpecialEco=cxIoCardOperSpecialEco, cxIoPortAdmEntry=cxIoPortAdmEntry, cxIoCardOperTable=cxIoCardOperTable, cxIoCardOperType=cxIoCardOperType, cxIoPortAdmCardAlias=cxIoPortAdmCardAlias, cxIoCardOperEntry=cxIoCardOperEntry, cxIoHwCardTypeTrapReport=cxIoHwCardTypeTrapReport, cxIoHwCardTypeTrap=cxIoHwCardTypeTrap, cxIoCardAdmIndex=cxIoCardAdmIndex, cxIoCardAdmState=cxIoCardAdmState, cxIoCardOperAssemblyAndEco=cxIoCardOperAssemblyAndEco, cxIoCardAdmType=cxIoCardAdmType, cxIoCardAdmPhysSlot=cxIoCardAdmPhysSlot, cxIoCardAdmEntry=cxIoCardAdmEntry, cxIoPortAdmTable=cxIoPortAdmTable, cxIHMibLevel=cxIHMibLevel, cxIoPortAdmCardLocalIndex=cxIoPortAdmCardLocalIndex, cxIoCardAdmRowStatus=cxIoCardAdmRowStatus, cxIoCardOperRevision=cxIoCardOperRevision, cxIoCardOperState=cxIoCardOperState, cxIoPortAdmIndex=cxIoPortAdmIndex, cxIoCardOperPhysSlot=cxIoCardOperPhysSlot, cxIoCardAdmAlias=cxIoCardAdmAlias, cxIoPortAdmRowStatus=cxIoPortAdmRowStatus, cxIoCardAdmTable=cxIoCardAdmTable)

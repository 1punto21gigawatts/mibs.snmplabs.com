#
# PySNMP MIB module JUNIPER-JS-SCREENING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-JS-SCREENING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:59:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ifName, = mibBuilder.importSymbols("IF-MIB", "ifName")
jnxJsScreening, = mibBuilder.importSymbols("JUNIPER-JS-SMI", "jnxJsScreening")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, ModuleIdentity, Integer32, Bits, IpAddress, MibIdentifier, TimeTicks, ObjectIdentity, Unsigned32, Counter32, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "ModuleIdentity", "Integer32", "Bits", "IpAddress", "MibIdentifier", "TimeTicks", "ObjectIdentity", "Unsigned32", "Counter32", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
jnxJsScreenMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1))
jnxJsScreenMIB.setRevisions(('2014-04-02 00:00', '2013-11-07 00:00', '2013-06-06 00:00', '2012-04-06 10:30', '2009-02-04 00:00', '2007-09-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxJsScreenMIB.setRevisionsDescriptions(('Added IPv6 Tunneling Screen statistics MIBs Add new trap var bindings for IPv6 Tunneling Screen', 'Added Udp Port Scan screen statistics MIBs Add new trap var bindings for Udp Port Scan', 'Added IPv6 screen statistics MIBs Add new traps', 'Added TCP/UDP sweeping MIBs Put trap to under routing category', 'Added following new trap tresholds: jnxJsScreenSynFloodSrcThresh jnxJsScreenSynFloodDstThresh jnxJsScreenSessLimitSrcThresh jnxJsScreenSessLimitDstThresh Added following new counters: jnxJsScreenMonSynFloodSrc jnxJsScreenMonSynFloodDst Deprecated following objects: jnxJsScreenSynAttackQueSize jnxJsScreenSynAttackAgeTime', 'Creation Date',))
if mibBuilder.loadTexts: jnxJsScreenMIB.setLastUpdated('201404020000Z')
if mibBuilder.loadTexts: jnxJsScreenMIB.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxJsScreenMIB.setContactInfo('Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net HTTP://www.juniper.net')
if mibBuilder.loadTexts: jnxJsScreenMIB.setDescription('This module defines the MIB for Juniper Enterprise Firewall screen functionality. Juniper documentation is recommended as the reference. Juniper Security Firewall provides various detection methods and defense mechanisms to combat exploits at all stages of the path of execution. These includes: Setting screen options Firwall DOS attacks Network DOS attack OS specific DOS attack Fragment reassembly ')
jnxJsScreenNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0))
jnxJsScreenObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1))
jnxJsScreenTrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2))
jnxJsScreenMonTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1), )
if mibBuilder.loadTexts: jnxJsScreenMonTable.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTable.setDescription("Juniper security Firewall can allow DI protection on each of the device's physical interface. This table collects the screen attributes that monitor the various attacks. The screen options can be enabled at security zone bounded to a interface or interfaces. When these options apply to traffic reaching the device through interfaces (via a zone), they offers protection against malicious information gathering probe or an attack to compromise, disable, or harm a network or network resources.")
jnxJsScreenMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1), ).setIndexNames((1, "JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"))
if mibBuilder.loadTexts: jnxJsScreenMonEntry.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonEntry.setDescription('The screen option monitoring statistics entry. Each entry is uniquely identified by the zone name. The data is collected on a per zone basis. There can be multiple interfaces bound to a particular zones. Hence, the statistics are aggregated across the interfaces on a per zone basis. ')
jnxJsScreenZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxJsScreenZoneName.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenZoneName.setDescription('The name of the security zone under which the statistics are collected. ')
jnxJsScreenNumOfIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenNumOfIf.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenNumOfIf.setDescription('Number of interfaces bound to this zone. Each counter contains the aggregated data of all the interfaces')
jnxJsScreenMonSynAttk = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynAttk.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSynAttk.setDescription('The SYN (TCP connection request) attack is a common denial of service (DoS) technique characterized by the following pattern: - Using a spoofed IP address not in use on the Internet, an attacker sends multiple SYN packets to the target machine. - For each SYN packet received, the target machine allocates resources and sends an acknowledgement (SYN-ACK) to the source IP address. This can cause the target machine to allocate resources for more than 3 minutes to respond to just one i SYN attack, hence wasting resources. This attribute records the number of SYN attacks.')
jnxJsScreenMonTearDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTearDrop.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTearDrop.setDescription('Teardrop attacks exploit the reassembly of fragmented IP packets. In the IP header, one of the fields is the fragment offset field, which indicates one of the fields is the fragment offset field. It indicates the starting position of the data contained in a fragmented packet relative to the data of the original unfragmented packet. When the sum of the offset and size of one fragmented packet differ from that of the next fragmented packet, the packets overlap. The server attempting to reassemble the packet can crash, especially if it is running an older operating system that has this vulnerability. When this option is enabled, the security device detects this discrepancy in a fragmented packet and drops it and this attribute counts the number of packets dropped.')
jnxJsScreenMonSrcRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSrcRoute.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSrcRoute.setDescription('IP source route options can be used to hide their true address and access restricted areas of a network by specifying a different path. The security device should be able to either block any packets with loose or strict source route options set or detect such packets and then record the event for the ingress interface. This attribute records either the loose source route option or strict source route attack packets.')
jnxJsScreenMonPingDeath = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonPingDeath.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonPingDeath.setDescription('The maximum allowable IP packet size is 65,535 bytes, including the packet header (typically 20 bytes long). An ICMP echo request is an IP packet with a pseudo header, which is 8 bytes long. Therefore, the maximum allowable size of the data area of an ICMP echo request is 65,507 bytes. However, many ping implementations allow the user to specify a packet size larger than 65,507 bytes. A grossly oversized ICMP packet can trigger a range of adverse system reactions such as denial of service (DoS), crashing, freezing, and rebooting. When the Ping Death option is enabled, the device detects and rejects such oversized and irregular packet sizes even when the attacker hides the total packet size by purposefully fragmenting it. This attributes counts the ping of death attack packets.')
jnxJsScreenMonAddrSpoof = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonAddrSpoof.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonAddrSpoof.setDescription('One method to gain access to a restricted network is to insert a bogus source address in the packet header to make the packet appear to come from a trusted source. This technique is called IP spoofing. The mechanism to detect IP spoofing relies on route table entries. For example, if a packet with source IP address 10.1.1.6 arrives at port eth3, but the device has a route to 10.1.1.0/24 through port eth1. IP spoofing checking notes that this address arrived at an invalid interface as defined in the route table. A valid packet from 10.1.1.6 can only arrive via eth1, not eth3. The device concludes that the packet has a spoofed source IP address and discards it. This attribute records the address spoofing attack packets.')
jnxJsScreenMonLand = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLand.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonLand.setDescription('A combined SYN attack with IP spoof is referred to as Land attack. A Land attack occurs when an attacker sends spoofed SYN packets containing the IP address of the victim as both the destination and source IP address. The receiving system responds by sending the SYN-ACK packet to itself, creating an empty connection that lasts until the idle timeout value is reached. Flooding a system with such empty connections can overwhelm the system, causing a DoS. This attribute records the land attack packets.')
jnxJsScreenMonIcmpFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFlood.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFlood.setDescription('An ICMP flood typically occurs when ICMP echo requests overload its victim with so many requests that it expends all its resources responding until it can no longer process valid network traffic. With the ICMP flood protection feature enabled, and a threshold set. If the threshold exceeded, the system invokes the flood attack protection feature. The default threshold value is 1000 packets per second. If the threshold is exceeded, the security device ignores further ICMP echo requests for the remainder of that second plus the next second as well. This attribute records the ICMP flood attack packets.')
jnxJsScreenMonUdpFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonUdpFlood.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonUdpFlood.setDescription('UDP flooding occurs when an attacker sends IP packets containing UDP datagrams with the purpose of slowing down the victim to the point that it can no longer handle valid connections. With the UDP flood protection feature enabled, a threshold can be set which once exceeded, the system invokes the UDP flood attack protection feature. The default threshold value is 1000 packets per second. If the number of UDP datagrams from one or more sources to a single destination exceeds this threshold, security device ignores further UDP datagrams to that destination for the remainder of that second plus the next second as well. This attribute records the UDP flood attack packets.')
jnxJsScreenMonWinnuke = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonWinnuke.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonWinnuke.setDescription('WinNuke is a DoS attack targeting any computer on the internet running Windows. The attacker sends a TCP segment, usually to NetBIOS port 139 with the urgent (URG) flag set, to a host with an established connection. This introduces a NetBIOS fragment overlap, which causes many machines running Windows to crash. This attributes counts the netbios attack.')
jnxJsScreenMonPortScan = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonPortScan.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonPortScan.setDescription('A port scan occurs when one source IP address sends IP packets containing TCP SYN segments to a defined number of different ports at the same destination IP address within a defined interval. The purpose of this attack is to scan the available services in the hope that at least one port will respond, thus identifying a service of the target. The device should internally log the number of different ports scanned from one remote source. This attribute records the port scan attempt attack packets.')
jnxJsScreenMonIpSweep = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpSweep.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpSweep.setDescription('An address sweep occurs when one source IP address sends a defined number of ICMP packets to different hosts within a defined interval. The purpose of this attack is to send ICMP packets, typically echo requests, to various hosts in the hope that at least one replies, thus uncovering an address of the target. The device internally log the number of ICMP packets to different addresses from one remote source. This attributes records the address sweep attemp attack packets.')
jnxJsScreenMonSynFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFrag.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSynFrag.setDescription('IP encapsulates a TCP SYN segment in the IP packet that initiates a TCP connection. The purpose is to initiate a connection and to invoke a SYN/ACK segment response. The SYN segment typically does not contain any data since the IP packet is small and there is no legitimate reason for it to be fragmented. A fragmented SYN packet is anomalous and is suspectful. To be cautious, it might be helpful to block such these fragments from entering the protected network. When the syn fragmentation check is enable, the security device detects and drops the packets when the IP header indicates that the packet has been fragmented while the SYN flag is set in the TCP header. This attributes records the detection of the SYN fragments.')
jnxJsScreenMonTcpNoFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpNoFlag.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTcpNoFlag.setDescription("A normal TCP segment header has at least one flag control set. A TCP segment with no control flags set is an anomalous event. Operating systems respond to such anomalies in different ways. The response, or even lack of response, from the targeted device can provide a clue as to the target's OS type. When this option is enabled, if the device discovers such a header with a missing or malformed flags field, it drops the packet. The attribure records the detection of TCP without flag set packets.")
jnxJsScreenMonIpUnknownProt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpUnknownProt.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpUnknownProt.setDescription('According to RFC 1700, some protocol types in IP header are reserved and unassigned at this time. Precisely because these protocols are undefined, there is no way to know in advance if a particular unknown protocol is benign or malicious. Unless your network makes use of a non-standard protocol with reserved or unassigned protocol number, a cautious stance is to block such unknown elements from entering your protected network. When the Unknown Protocol Protection SCREEN option is enabled, the security device drops packets when the protocol field contains a protocol ID number of 137 or greater by default. This attribute records the detection of Unknown protocol IP packets.')
jnxJsScreenMonIpOptBad = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptBad.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptBad.setDescription('IP protocol specifies a set of eight options that provide special routing controls, diagnostic tools, and security. These eight options can be used for malicious objectives. Either intentionally or accidentally, attackers sometimes misconfigure IP options, producing either incomplete or malformed fields. The misformatting is anomalous and potentially harmful to the intended recipient. When the Bad IP Option Protection SCREEN option is enabled, the security device detects and blocks packets when any IP option in the IP packet header is incorrectly formatted. This attributes records the detection of the IP bad option packets.')
jnxJsScreenMonIpOptRecRt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptRecRt.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptRecRt.setDescription('The IP standard RFC 791 specifies a set of options to provide special routing controls, diagnostic tools, and security. These options appear after the destination address in an IP packet header. When they do appear, they are frequently being put to some nefarious use. Record option is one of these options that an attacker can use for reconnaissance or for some unknown but suspicious purpose When record IP option is received, the security device flags this as an network reconnaissance attack and records the event for the ingress interface. This attribute records the detection of IP record option packets.')
jnxJsScreenMonIpOptTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptTimestamp.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptTimestamp.setDescription('The IP standard RFC 791 specifies a set of options to provide special routing controls, diagnostic tools, and security. These options appear after the destination address in an IP packet header. When they do appear, they are frequently being put to some nefarious use. Timestamp is one of these options that an attacker can use for reconnaissance or for some unknown but suspicious purpose When timestamp IP option is received, the security device flags this as an network reconnaissance attack and records the event for the ingress interface. This attribute records the detection of IP timestamp option packets.')
jnxJsScreenMonIpOptSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSecurity.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSecurity.setDescription('The IP standard RFC 791 specifies a set of options to provide special routing controls, diagnostic tools, and security. These options appear after the destination address in an IP packet header. When they do appear, they are frequently being put to some nefarious use. Security is one of these options that an attacker can use for reconnaissance or for some unknown but suspicious purpose When the security IP option is received, the security device flags this as an network reconnaissance attack and records the event for the ingress interface. This attribute records the detection of IP security option packets.')
jnxJsScreenMonIpOptLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptLSR.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptLSR.setDescription('Attackers can use IP source route options to hide their true address and access restricted areas of a network by specifying a different path. The security device should be able to either block any packets with loose or strict source route options set or detect such packets and then record the event for the ingress interface. This attribute records the detection of loose source route packets.')
jnxJsScreenMonIpOptSSR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSSR.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSSR.setDescription('Attackers can use IP source route options to hide their true address and access restricted areas of a network by specifying a different path. The security device should be able to either block any packets with loose or strict source route options set or detect such packets and then record the event for the ingress interface. This attribute records the detection of strict source route packets.')
jnxJsScreenMonIpOptStream = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptStream.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpOptStream.setDescription('The IP standard RFC 791 specifies a set of options to provide special routing controls, diagnostic tools, and security. These options appear after the destination address in an IP packet header. When they do appear, they are frequently being put to some nefarious use. Stream is one of these options that an attacker can use for reconnaissance or for some unknown but suspicious purpose When the security IP option is received, the security device flags this as an network reconnaissance attack and records the event for the ingress interface. This attribute records the detect of IP stream option packets.')
jnxJsScreenMonIcmpFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFrag.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFrag.setDescription('ICMP provides error reporting and network probe capabilities. ICMP packets contain very short messages, there is no legitimate reason for ICMP packets to be fragmented. If an ICMP packet is so large that it must be fragmented, something has gone amiss. With the ICMP Fragment Protection SCREEN option enabled, the device should be able to block any ICMP packet with the More Fragments flag set, or with an offset value indicated in the offset field. This attribute counts the ICMP fragment packets.')
jnxJsScreenMonIcmpLarge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpLarge.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIcmpLarge.setDescription('ICMP packets contain very short messages, there is no legitimate reason for ICMP packets to be fragmented. If an ICMP packet is unusually large, something is wrong. For example, the Loki program uses ICMP as a channel for transmitting covert messages. The presence of large ICMP packets might expose a compromised machine acting as a Loki agent. It might also indicate some other kind of shifty activity. When the the Large Size ICMP Packet Protection SCREEN option is enabled, the device drops ICMP packets with a length greater than 1024 bytes. This attribute records the detection of large ICMP packets.')
jnxJsScreenMonTcpSynFin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpSynFin.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTcpSynFin.setDescription('Both the SYN and FIN control flags are not normally set in the same TCP segment header. The SYN flag synchronizes sequence numbers to initiate a TCP connection. The FIN flag indicates the end of data transmission to finish a TCP connection. Their purposes are mutually exclusive. A TCP header with the SYN and FIN flags set is anomalous TCP behavior, causing various responses from the recipient, depending on the OS. When block both syn and fin option is enable, the device drops the packet when it discovers such a header This attribute records the TCP syn fin both set packet dropped.')
jnxJsScreenMonTcpFinNoAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpFinNoAck.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTcpFinNoAck.setDescription('A FIN scan sends TCP segments with the FIN flag set in an attempt to provoke a response and thereby discover an active host or an active port on a host. The use of TCP segments with the FIN flag set might evade detection and thereby help the attacker succeed in his or her reconnaissance efforts. This attributes records the detection of the TCP fin set without ack bit set packets.')
jnxJsScreenMonLimitSessSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessSrc.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessSrc.setDescription('All the virus-generated traffic originates from the same IP address (generally from a infected server), a source-based session limit ensures that the firewall can curb such excessive amounts of traffic. Based on a threshold value, if the number of concurrent sessions required to fill up the session table of the particular firewall. The default maximum for source-based session limit is 128 concurrent sessions, which can be adjusted to accordingly. This attribute records the number of the session connection based on the source IP that exceeds the specified limit.')
jnxJsScreenMonLimitSessDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessDest.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessDest.setDescription("The user can limit the number of concurrent sessions to the same destination IP address. A wily attacker can launch a distributed denial-of-service (DDoS) attack using 'zombie agents'. Setting a destination-based session limit can ensure that device allows only an acceptable number of concurrent connection requests, no matter what the source, to reach any one host. The default maximum for destination-based session limit is 128 concurrent sessions. This attribute records the number of session connection based on the destination source IP address that exceeds the specified limit.")
jnxJsScreenMonSynAckAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynAckAck.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSynAckAck.setDescription('When an authentication user initiates a Telnet or FTP connection, the user sends a SYN segment to the Telnet or FTP server. The device intercepts the SYN segment, creates an entry in its session table, and proxies a SYN-ACK segment to the user. The user then replies with an ACK segment. At that point, the initial 3-way handshake is complete. The device sends a login prompt to the user. When a malicisou user does not log in, but instead continue initiating SYN-ACK-ACK sessions, the firewall session table can fill up to the point where the device begins rejecting legitimate connection requests. When the SYN-ACK-ACK proxy protection option is enabled, after the number of connections from the same IP address reaches the SYN-ACK-ACK proxy threshold, the device rejects further connection requests from that IP address. By default, the threshold is 512 connections from any single IP address. The attribute records the detection of SYN ACK ACK attack.')
jnxJsScreenMonIpFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpFrag.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpFrag.setDescription("As packets travels, it is sometimes necessary to break a packet into smaller fragments based upon the maximum transmission unit (MTU) of each network. IP fragments might contain an attacker's attempt to exploit the vulnerabilities in the packet reassembly code of specific IP stack implementations. When the victim receives these packets, the results can range from processing the packets incorrectly to crashing the entire system. When the block IP framentation flag is enabled, the device blocks all IP packet fragments that it receives at interfaces bound to that zone. This attribute counts the number of block IP fragment packets.")
jnxJsScreenSynAttackThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynAttackThresh.setDescription('The number of SYN segments to the same destination address and port number per second required to activate the SYN proxying mechanism. In order to set the appropriate threshold value, it requires a through knowledge of the normal traffic patterns at site For example, if the security device normally gets 2000 SYN segments per second, the threshold value should be set at 3000/second. This attribute displays the configured SYN attack threshold value.')
jnxJsScreenSynAttackTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackTimeout.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynAttackTimeout.setDescription('The maximum length of time before a half-completed connection is dropped from the queue. The default is 20 seconds. This attributes display the SYN attack timeout value.')
jnxJsScreenSynAttackAlmTh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackAlmTh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynAttackAlmTh.setDescription('The syn attack alarm threshold causes an alarm to be generated when the number of proxied, half-complete TCP connection requests per second requests to the same destination address and port number exceeds its value. This attribute display the SYN attack alarm threshold value.')
jnxJsScreenSynAttackQueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackQueSize.setStatus('deprecated')
if mibBuilder.loadTexts: jnxJsScreenSynAttackQueSize.setDescription('The number of proxied connection requests held in the proxied connection queue before the device starts rejecting new connection requests. This attribute displays the SYN attack queue size. This object has been deprecated.')
jnxJsScreenSynAttackAgeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackAgeTime.setStatus('deprecated')
if mibBuilder.loadTexts: jnxJsScreenSynAttackAgeTime.setDescription('SYN flood age time. This object has been deprecated.')
jnxJsScreenIcmpFloodThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenIcmpFloodThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenIcmpFloodThresh.setDescription('ICMP flooding occurs when an attacker sends IP packets containing ICMP datagrams with the purpose of slowing down the victim to the point that it can no longer handle valid connections. This attributes display the ICMP attack alarm threshold value.')
jnxJsScreenUdpFloodThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenUdpFloodThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenUdpFloodThresh.setDescription('UDP flooding occurs when an attacker sends IP packets containing UDP datagrams with the purpose of slowing down the victim to the point that it can no longer handle valid connections. The default threshold value is 1000 packets per second. This attribute displays the UDP attack alarm threshold value.')
jnxJsScreenPortScanThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenPortScanThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenPortScanThresh.setDescription('The port scan threshold interval is in microseconds. The default threshold value is 5000. The valid threshold range is 1000-1000000. By using the default settings, if a remote host scans 10 ports in 0.005 seconds (5000 microseconds), the device flags this as a port scan attack, and rejects all further packets from the remote source for the remainder of the specified timeout period. The device detects and drops the tenth packet that meets the port scan attack criterion. This attribute displays the port scan threshold value.')
jnxJsScreenIpSweepThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenIpSweepThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenIpSweepThresh.setDescription('The IP sweep threshold interval is in microseconds. The default threshold value is 5000. The valid threshold range is 1000-1000000. By using the default settings, if a remote host sends ICMP traffic to 10 addresses in 0.005 seconds (5000 microseconds), the security device flags this as an address sweep attack, and rejects all further ICMP echo requests from that host for the remainder of the specified threshold time period. The device detects and drops the tenth packet that meets the address sweep attack criterion. This attribute holds the UDP attack alarm threshold.')
jnxJsScreenSynAckAckThres = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAckAckThres.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynAckAckThres.setDescription('SYN ack ack alarm threshold value.')
jnxJsScreenMonIpv6ExtHdr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpv6ExtHdr.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpv6ExtHdr.setDescription('In one IPv6 packet, one or more extension headers may appear before the encapsulated payload after the mandatory header. User can screen any one or several extension headers. When the extension header screen is enabled, the device screens all IPv6 packets with specific header. The attribute counts the number of block IPv6 extension packets.')
jnxJsScreenMonIpv6HopOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 43), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpv6HopOpt.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpv6HopOpt.setDescription('In one IPv6 hop by hop option extension header, it carries a variable number options. User can screen any one or several options. When the hop by hop option screen is enabled, the device screens all IPv6 packets with specific option type. The attribute counts the number of block IPv6 option type packets.')
jnxJsScreenMonIpv6DstOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 44), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpv6DstOpt.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpv6DstOpt.setDescription('In one IPv6 destination option extension header, it carries a variable number options. User can screen any one or several options. When the destination option screen is enabled, the device screens all IPv6 packets with specific option type. The attribute counts the number of block IPv6 option type packets.')
jnxJsScreenMonIpv6ExtLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 45), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpv6ExtLimit.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpv6ExtLimit.setDescription('In one IPv6 packet, one or more extension headers may appear before the encapsulated payload. User can screen IPv6 packets if their extension header number is larger than one limit. When the extension header limit screen is enabled, the device screens IPv6 packets with more than one limit extension headers. The attribute counts the number of block IPv6 packets.')
jnxJsScreenMonIpMalIpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 46), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpMalIpv6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpMalIpv6.setDescription('One IPv6 packets may contain malformed header, the device tries to block these packets to protect downstream devices. When the malformed IPv6 screen is enabled, the device screens IPv6 packets with malformed header. The attribute counts the number of block malformed header IPv6 packets.')
jnxJsScreenMonIcmpMalIcmpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 47), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpMalIcmpv6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIcmpMalIcmpv6.setDescription('One ICMPv6 packets may contain malformed content, the device tries to block these packets to protect downstream devices. When the malformed ICMPv6 screen is enabled, the device screens ICMPv6 packets with malformed content. The attribute counts the number of block malformed ICMPv6 packets.')
jnxJsScreenIpv6ExtNumLim = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenIpv6ExtNumLim.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenIpv6ExtNumLim.setDescription('IPv6 extension header number limit value.')
jnxJsScreenUdpPortScanThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenUdpPortScanThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenUdpPortScanThresh.setDescription('The UDP port scan threshold interval is in microseconds. The default threshold value is 5000. The valid threshold range is 1000-1000000. By using the default settings, if a remote host scans 10 ports in 0.005 seconds (5000 microseconds), the device flags this as a udp port scan attack, and rejects all further packets from the remote source for the remainder of the specified timeout period. The device detects and drops the tenth packet that meets the port scan attack criterion. This attribute displays the UDP port scan threshold value.')
jnxJsScreenMonUdpPortScan = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 50), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonUdpPortScan.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonUdpPortScan.setDescription('A UDP port scan occurs when one source IP address sends UDP packets to a defined number of different ports at the same destination IP address within a defined interval. The purpose of this attack is to scan the available services in the hope that at least one port will respond, thus identifying a service of the target. The device should internally log the number of different ports scanned from one remote source. This attribute records the UDP port scan attempt attack packets.')
jnxJsScreenMonIpTunnelGre6in4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 51), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre6in4.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre6in4.setDescription('When an IP GRE 6in4 Tunnel packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP GRE 6in4 Tunnel attempt attack packets.')
jnxJsScreenMonIpTunnelGre4in6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 52), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre4in6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre4in6.setDescription('When an IP GRE 4in6 Tunnel packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP GRE 4in6 Tunnel attempt attack packets.')
jnxJsScreenMonIpTunnelGre6in6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 53), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre6in6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre6in6.setDescription('When an IP GRE 6in6 Tunnel packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP GRE 6in6 Tunnel attempt attack packets.')
jnxJsScreenMonIpTunnelGre4in4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 54), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre4in4.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelGre4in4.setDescription('When an IP GRE 4in4 Tunnel packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP GRE 4in4 Tunnel attempt attack packets.')
jnxJsScreenMonIpTunnelIpInUdpTeredo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 55), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpInUdpTeredo.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpInUdpTeredo.setDescription('When an IPinUDP Teredo Tunnel packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IPinUDP Teredo Tunnel attempt attack packets.')
jnxJsScreenMonIpTunnelBadInnerHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 56), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelBadInnerHeader.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelBadInnerHeader.setDescription('When an IP Tunnel Bad Inner Header packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel Bad Inner Header attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp6to4relay = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 57), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6to4relay.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6to4relay.setDescription('When an IP Tunnel IPinIP 6to4 relay packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 6to4 relay attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp6in4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 58), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6in4.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6in4.setDescription('When an IP Tunnel IPinIP 6in4 packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 6in4 attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp6over4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 59), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6over4.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6over4.setDescription('When an IP Tunnel IPinIP 6over4 packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 6over4 attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp4in6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 60), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp4in6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp4in6.setDescription('When an IP Tunnel IPinIP 4in6 packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 4in6 attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp4in4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 61), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp4in4.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp4in4.setDescription('When an IP Tunnel IPinIP 4in4 packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 4in4 attempt attack packets.')
jnxJsScreenMonIpTunnelIpIp6in6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 62), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6in6.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIp6in6.setDescription('When an IP Tunnel IPinIP 6in6 packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP 6in6 attempt attack packets.')
jnxJsScreenMonIpTunnelIpIpIsatap = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 63), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIpIsatap.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIpIsatap.setDescription('When an IP Tunnel IPinIP ISATAP packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP ISATAP attempt attack packets.')
jnxJsScreenMonIpTunnelIpIpDsLite = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 64), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIpDsLite.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonIpTunnelIpIpDsLite.setDescription('When an IP Tunnel IPinIP DS-Lite packet meets the attack criteria specified by current configuration, it will be counted in this statisitic. This attribute records the IP Tunnel IPinIP DS-Lite attempt attack packets.')
jnxJsScreenMonThreshTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2), )
if mibBuilder.loadTexts: jnxJsScreenMonThreshTable.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonThreshTable.setDescription('This table is a read-only table that augments the jnxJsScreenMonTable. The purpose of this table is to keep threshold and counter information about Syn Flood and Session Limit.')
jnxJsScreenMonThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1), ).setMaxAccess("readonly")
jnxJsScreenMonEntry.registerAugmentions(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenMonThreshEntry"))
jnxJsScreenMonThreshEntry.setIndexNames(*jnxJsScreenMonEntry.getIndexNames())
if mibBuilder.loadTexts: jnxJsScreenMonThreshEntry.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonThreshEntry.setDescription('Syn Flood and Session Limit thresholds and counts.')
jnxJsScreenSynFloodSrcThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynFloodSrcThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynFloodSrcThresh.setDescription('The number of SYN segments received per second from a single source IP - regardless of the destination IP address and port number - before the security device begins dropping connection requests from that source.')
jnxJsScreenSynFloodDstThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynFloodDstThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSynFloodDstThresh.setDescription('The number of SYN segments received per second from a single destination IP address before the security device begins dropping connection requests to that destination. If a protected host runs multiple services, you might want to set a threshold based on destination IP address only - regardless of the destination port number.')
jnxJsScreenSessLimitSrcThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSessLimitSrcThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSessLimitSrcThresh.setDescription('The security device can impose a limit on the number of SYN segments permitted from a single source IP address.')
jnxJsScreenSessLimitDstThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSessLimitDstThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSessLimitDstThresh.setDescription('The security device can impose a limit on the number of SYN segments permitted to a single destination IP address.')
jnxJsScreenMonSynFloodSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodSrc.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodSrc.setDescription('The number of concurrent sessions from the same source IP address.')
jnxJsScreenMonSynFloodDst = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodDst.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodDst.setDescription('The number of concurrent sessions to the same destination IP address.')
jnxJsScreenSweepTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3), )
if mibBuilder.loadTexts: jnxJsScreenSweepTable.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSweepTable.setDescription('This table is a read-only table that augments the jnxJsScreenMonTable. The purpose of this table is to add counters and thresholds for TCP/UDP sweep feature.')
jnxJsScreenSweepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3, 1), )
jnxJsScreenMonEntry.registerAugmentions(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenSweepEntry"))
jnxJsScreenSweepEntry.setIndexNames(*jnxJsScreenMonEntry.getIndexNames())
if mibBuilder.loadTexts: jnxJsScreenSweepEntry.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenSweepEntry.setDescription('TCP/UDP sweep thresholds and counters.')
jnxJsScreenTcpSweepThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenTcpSweepThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenTcpSweepThresh.setDescription('The TCP sweep threshold interval is in microseconds. The default threshold value is 5000. The valid threshold range is 1000-1000000. By using the default settings, if a remote host initiates TCP connection to 10 addresses in 0.005 seconds(5000 microseconds), the security device flags this as an TCP sweep attack, and rejects all further new TCP connections initiated from that host for the remainder of the specified threshold time period. This attribute holds the TCP sweep attack threshold.')
jnxJsScreenUdpSweepThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenUdpSweepThresh.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenUdpSweepThresh.setDescription('The UDP sweep threshold interval is in microseconds. The default threshold value is 5000. The valid threshold range is 1000-1000000. By using the default settings, if a remote host has UDP connection to 10 addresses in 0.005 seconds(5000 microseconds), the security device flags this as an UDP sweep attack, and rejects all further new UDP connections from that host for the remainder of the specified threshold time period. This attribute holds the UDP sweep attack threshold.')
jnxJsScreenMonTcpSweep = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpSweep.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonTcpSweep.setDescription('The number of TCP sessions dropped due to TCP sweeping attack.')
jnxJsScreenMonUdpSweep = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonUdpSweep.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenMonUdpSweep.setDescription('The number of UDP packets dropped due to UDP sweeping attack.')
jnxJsScreenAttack = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0, 1)).setObjects(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"), ("IF-MIB", "ifName"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackType"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackCounter"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackDescr"))
if mibBuilder.loadTexts: jnxJsScreenAttack.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenAttack.setDescription('A per min bytes exceed trap signifies that the number of bytes per minutes has exceeds the specified threshold. jnxJsScreenZoneName: the zone name under which the attack is occuring. ifName the interface at which the attack is occuring. jnxJsScreenAttackType: type of attack. jnxJsScreenAttackCounter: the number of attacks recorded based on the particular screening options enabled. The value of this counter is the aggregated statistic of all the interfaces bound to the mentioned zone. jnxJsScreenAttackDescr: a general text description of the this attack or the trap.')
jnxJsScreenCfgChange = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0, 2)).setObjects(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackType"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenCfgStatus"))
if mibBuilder.loadTexts: jnxJsScreenCfgChange.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenCfgChange.setDescription('The screening configuration change trap signifies that an screening option has been changed(enabled or disabled). A disable feature may implies a security hole. jnxJsScreenZoneName is the zone at which the changed option is applicable to. jnxJsScreenAttackType the screen feature. jnxJsScreenCfgStatus: either enabled or disabled')
jnxJsScreenAttackType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54))).clone(namedValues=NamedValues(("icmpFlood", 1), ("udpFlood", 2), ("portScanning", 3), ("ipSweeping", 4), ("synfloodSrcIP", 5), ("synfloodDstIP", 6), ("sessLimitSrcBased", 7), ("sessLimitDestBased", 8), ("synAckAck", 9), ("synAttack", 10), ("winNuke", 11), ("tearDrop", 12), ("ipAddressSpoof", 13), ("pingDeath", 14), ("sourceRoute", 15), ("landAttack", 16), ("synFragmentation", 17), ("tcpNoFlag", 18), ("ipUnknownProtocol", 19), ("ipOptionBad", 20), ("ipOptionRecRt", 21), ("ipOptionTimeStamp", 22), ("ipOptionSecurity", 23), ("ipOptionLSR", 24), ("ipOptionSRR", 25), ("ipOptionStream", 26), ("icmpFragmentation", 27), ("icmpLarge", 28), ("tcpSynFin", 29), ("tcpFinNoAck", 30), ("ipFragmentation", 31), ("tcpSweeping", 32), ("udpSweeping", 33), ("ipv6exthdr", 34), ("ipv6hbyhopt", 35), ("ipv6dstopt", 36), ("ipv6extlim", 37), ("ipv6malhdr", 38), ("icmpv6malpkt", 39), ("udpportScanning", 40), ("ipTunnelGre6in4", 41), ("ipTunnelGre4in6", 42), ("ipTunnelGre6in6", 43), ("ipTunnelGre4in4", 44), ("ipTunnelIpInUdpTeredo", 45), ("ipTunnelBadInnerHeader", 46), ("ipTunnelIpIp6to4relay", 47), ("ipTunnelIpIp6in4", 48), ("ipTunnelIpIp6over4", 49), ("ipTunnelIpIp4in6", 50), ("ipTunnelIpIp4in4", 51), ("ipTunnelIpIp6in6", 52), ("ipTunnelIpIpIsatap", 53), ("ipTunnelIpIpDsLite", 54)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxJsScreenAttackType.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenAttackType.setDescription('The type of attacks that the device support.')
jnxJsScreenAttackCounter = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 2), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxJsScreenAttackCounter.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenAttackCounter.setDescription('The threshold value that triggers the trap to be generated.')
jnxJsScreenAttackDescr = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxJsScreenAttackDescr.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenAttackDescr.setDescription('The description pertinent to the attack trap.')
jnxJsScreenCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxJsScreenCfgStatus.setStatus('current')
if mibBuilder.loadTexts: jnxJsScreenCfgStatus.setDescription('The screening option configuration status: enabled or disabled.')
mibBuilder.exportSymbols("JUNIPER-JS-SCREENING-MIB", jnxJsScreenMonIpMalIpv6=jnxJsScreenMonIpMalIpv6, jnxJsScreenMonIpTunnelIpInUdpTeredo=jnxJsScreenMonIpTunnelIpInUdpTeredo, jnxJsScreenMonIcmpFlood=jnxJsScreenMonIcmpFlood, jnxJsScreenMonIpOptRecRt=jnxJsScreenMonIpOptRecRt, jnxJsScreenUdpSweepThresh=jnxJsScreenUdpSweepThresh, jnxJsScreenMonEntry=jnxJsScreenMonEntry, jnxJsScreenMonTcpSweep=jnxJsScreenMonTcpSweep, jnxJsScreenMonTcpNoFlag=jnxJsScreenMonTcpNoFlag, jnxJsScreenSynAttackAgeTime=jnxJsScreenSynAttackAgeTime, jnxJsScreenUdpFloodThresh=jnxJsScreenUdpFloodThresh, jnxJsScreenAttackDescr=jnxJsScreenAttackDescr, jnxJsScreenMonLimitSessDest=jnxJsScreenMonLimitSessDest, jnxJsScreenMonIpTunnelIpIpIsatap=jnxJsScreenMonIpTunnelIpIpIsatap, jnxJsScreenMonIpTunnelBadInnerHeader=jnxJsScreenMonIpTunnelBadInnerHeader, jnxJsScreenSynAttackTimeout=jnxJsScreenSynAttackTimeout, jnxJsScreenMonAddrSpoof=jnxJsScreenMonAddrSpoof, jnxJsScreenMonWinnuke=jnxJsScreenMonWinnuke, jnxJsScreenMonIpTunnelIpIp4in6=jnxJsScreenMonIpTunnelIpIp4in6, jnxJsScreenMonIpTunnelGre6in4=jnxJsScreenMonIpTunnelGre6in4, jnxJsScreenSessLimitDstThresh=jnxJsScreenSessLimitDstThresh, jnxJsScreenMonIpTunnelIpIp6in6=jnxJsScreenMonIpTunnelIpIp6in6, jnxJsScreenMonTearDrop=jnxJsScreenMonTearDrop, jnxJsScreenMonUdpFlood=jnxJsScreenMonUdpFlood, jnxJsScreenMonIcmpLarge=jnxJsScreenMonIcmpLarge, jnxJsScreenMonLand=jnxJsScreenMonLand, jnxJsScreenMonPingDeath=jnxJsScreenMonPingDeath, jnxJsScreenPortScanThresh=jnxJsScreenPortScanThresh, jnxJsScreenObjects=jnxJsScreenObjects, jnxJsScreenMonIpOptStream=jnxJsScreenMonIpOptStream, jnxJsScreenMonIpTunnelGre4in4=jnxJsScreenMonIpTunnelGre4in4, jnxJsScreenMonIpSweep=jnxJsScreenMonIpSweep, jnxJsScreenIpv6ExtNumLim=jnxJsScreenIpv6ExtNumLim, jnxJsScreenTcpSweepThresh=jnxJsScreenTcpSweepThresh, jnxJsScreenSweepTable=jnxJsScreenSweepTable, jnxJsScreenMonIpOptSecurity=jnxJsScreenMonIpOptSecurity, jnxJsScreenCfgStatus=jnxJsScreenCfgStatus, jnxJsScreenMonIpTunnelIpIpDsLite=jnxJsScreenMonIpTunnelIpIpDsLite, jnxJsScreenMonTcpFinNoAck=jnxJsScreenMonTcpFinNoAck, jnxJsScreenMonUdpPortScan=jnxJsScreenMonUdpPortScan, jnxJsScreenMonTable=jnxJsScreenMonTable, jnxJsScreenSynAttackThresh=jnxJsScreenSynAttackThresh, jnxJsScreenMonSynFrag=jnxJsScreenMonSynFrag, jnxJsScreenMonSrcRoute=jnxJsScreenMonSrcRoute, jnxJsScreenMonIcmpMalIcmpv6=jnxJsScreenMonIcmpMalIcmpv6, jnxJsScreenMonIpOptLSR=jnxJsScreenMonIpOptLSR, jnxJsScreenMonIpTunnelGre6in6=jnxJsScreenMonIpTunnelGre6in6, jnxJsScreenCfgChange=jnxJsScreenCfgChange, jnxJsScreenMonIpOptSSR=jnxJsScreenMonIpOptSSR, jnxJsScreenIpSweepThresh=jnxJsScreenIpSweepThresh, jnxJsScreenTrapVars=jnxJsScreenTrapVars, jnxJsScreenMonPortScan=jnxJsScreenMonPortScan, jnxJsScreenMonSynFloodDst=jnxJsScreenMonSynFloodDst, jnxJsScreenNumOfIf=jnxJsScreenNumOfIf, jnxJsScreenMonIpv6ExtLimit=jnxJsScreenMonIpv6ExtLimit, jnxJsScreenMonIpv6ExtHdr=jnxJsScreenMonIpv6ExtHdr, jnxJsScreenSynAckAckThres=jnxJsScreenSynAckAckThres, jnxJsScreenMonIpUnknownProt=jnxJsScreenMonIpUnknownProt, jnxJsScreenMonIpOptTimestamp=jnxJsScreenMonIpOptTimestamp, jnxJsScreenMonIcmpFrag=jnxJsScreenMonIcmpFrag, jnxJsScreenMonIpv6DstOpt=jnxJsScreenMonIpv6DstOpt, jnxJsScreenSessLimitSrcThresh=jnxJsScreenSessLimitSrcThresh, jnxJsScreenMIB=jnxJsScreenMIB, jnxJsScreenMonTcpSynFin=jnxJsScreenMonTcpSynFin, jnxJsScreenSynFloodSrcThresh=jnxJsScreenSynFloodSrcThresh, jnxJsScreenMonIpOptBad=jnxJsScreenMonIpOptBad, jnxJsScreenMonUdpSweep=jnxJsScreenMonUdpSweep, jnxJsScreenMonIpTunnelIpIp6in4=jnxJsScreenMonIpTunnelIpIp6in4, jnxJsScreenSweepEntry=jnxJsScreenSweepEntry, jnxJsScreenAttackCounter=jnxJsScreenAttackCounter, jnxJsScreenMonIpv6HopOpt=jnxJsScreenMonIpv6HopOpt, jnxJsScreenAttack=jnxJsScreenAttack, jnxJsScreenMonIpFrag=jnxJsScreenMonIpFrag, jnxJsScreenUdpPortScanThresh=jnxJsScreenUdpPortScanThresh, PYSNMP_MODULE_ID=jnxJsScreenMIB, jnxJsScreenZoneName=jnxJsScreenZoneName, jnxJsScreenMonSynFloodSrc=jnxJsScreenMonSynFloodSrc, jnxJsScreenMonLimitSessSrc=jnxJsScreenMonLimitSessSrc, jnxJsScreenIcmpFloodThresh=jnxJsScreenIcmpFloodThresh, jnxJsScreenMonThreshTable=jnxJsScreenMonThreshTable, jnxJsScreenMonIpTunnelIpIp6to4relay=jnxJsScreenMonIpTunnelIpIp6to4relay, jnxJsScreenMonSynAckAck=jnxJsScreenMonSynAckAck, jnxJsScreenMonIpTunnelGre4in6=jnxJsScreenMonIpTunnelGre4in6, jnxJsScreenSynAttackQueSize=jnxJsScreenSynAttackQueSize, jnxJsScreenMonIpTunnelIpIp6over4=jnxJsScreenMonIpTunnelIpIp6over4, jnxJsScreenMonThreshEntry=jnxJsScreenMonThreshEntry, jnxJsScreenAttackType=jnxJsScreenAttackType, jnxJsScreenMonSynAttk=jnxJsScreenMonSynAttk, jnxJsScreenMonIpTunnelIpIp4in4=jnxJsScreenMonIpTunnelIpIp4in4, jnxJsScreenNotifications=jnxJsScreenNotifications, jnxJsScreenSynAttackAlmTh=jnxJsScreenSynAttackAlmTh, jnxJsScreenSynFloodDstThresh=jnxJsScreenSynFloodDstThresh)

#
# PySNMP MIB module RIVERSTONE-RATELIMIT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RIVERSTONE-RATELIMIT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:57:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero")
riverstoneMibs, = mibBuilder.importSymbols("RIVERSTONE-SMI-MIB", "riverstoneMibs")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Counter32, Gauge32, TimeTicks, Counter64, IpAddress, iso, NotificationType, Integer32, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, ModuleIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "TimeTicks", "Counter64", "IpAddress", "iso", "NotificationType", "Integer32", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "ModuleIdentity", "Bits")
TruthValue, TextualConvention, StorageType, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "StorageType", "RowStatus", "DisplayString")
rsRateLimitMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25))
rsRateLimitMIB.setRevisions(('2002-10-10 00:00', '2001-07-06 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rsRateLimitMIB.setRevisionsDescriptions(('Second revision. Added more types and tables for Layer 2 rate limiting features and deprecated some invalid values.', 'First version.',))
if mibBuilder.loadTexts: rsRateLimitMIB.setLastUpdated('200210100000Z')
if mibBuilder.loadTexts: rsRateLimitMIB.setOrganization('Riverstone Networks, Inc')
if mibBuilder.loadTexts: rsRateLimitMIB.setContactInfo('Riverstone Networks, Inc 5200 Great America Parkway Santa Clara CA USA 95054 PHONE:+1 408.878.6500 EMAIL: nms-eng@riverstonenet.com WEB: http://www.riverstonenet.com')
if mibBuilder.loadTexts: rsRateLimitMIB.setDescription('This mib module defines the Riverstone Networks enterpise MIB for rate limit module. http://www.riverstonenet.com/products. Copyright (C) Riverstone Networks, Inc 2000')
class RsRateLimit(TextualConvention, Unsigned32):
    description = 'Rate limit on the selected traffic flow is specified using this data type. For RS Platform, this value can be set from 3000..1000000000 bits per second on all line cards.'
    status = 'current'

class RsBurst(TextualConvention, Unsigned32):
    description = 'Burst traffic rate on the selected traffic flow is specified using this data type. For RS platform, the valid range is 10,000..1000000000 bits per second. This is used for dual token bucket meter or Burst Safe(TM) meter'
    status = 'current'

class RsAdminStatus(TextualConvention, Integer32):
    description = 'Specifies the administrative status enabled or disabled'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class RsDistAmong(TextualConvention, Integer32):
    reference = "Refer Riverstone Networks white paper entitled 'An Overview on Rate Limiting' http://www.riverstonenet.com/technology/rate.shtml"
    description = "Distribute the unused 'bandwidth' among n number of flows, keeping a minimum specified bandwidth For example if the Software based AggregateRate is 10,000,000 MinBandwidth is 500,000 for each flow and Number of flows is 'n =15' leftOverBandwidth = AggregateRate -(n * MinBandwidth) 'leftOverBandwidth' is distributed among RsDistAmong number of flows. RsDistAmong is 5 leftOverBandwidth = 10,000,000 - (15 * 500,000) = 2,500,000 5 flows among 15 will get an extra 2,500,000/5 = 500000 bps "
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 10)

class RsMeterType(TextualConvention, Integer32):
    reference = "Refer Riverstone Networks white paper entitled 'An Overview on Rate Limiting' http://www.riverstonenet.com/technology/rate.shtml"
    description = 'The type of meter service. The value perFlow(1) indicates that this entry specifies a per L3 flow rate limit. softwareFlowAggregate(2) indicates that this entry specifies a software based rate limit aggregate. This is deprecated. hardwareFlowAggregate(3) indicates that this entry specifies a hardware based flow aggregation rate limit perPort(4) indicates that this entry specifies a port-level rate limit service. burstsafe(5) indicates that this entry specifies a dual bucket rate limit. l2(6) indicates that this entry specifies a layer 2 rate limit service. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("perFlow", 1), ("softwareFlowAggregate", 2), ("hardwareFlowAggregate", 3), ("perPort", 4), ("burstsafe", 5), ("l2", 6))

class RsMeterInterval(TextualConvention, Integer32):
    reference = "Refer Riverstone Networks white paper entitled 'An Overview on Rate Limiting' http://www.riverstonenet.com/technology/rate.shtml"
    description = "RS rate limiting is based on credit bucket scheme. A bucket is filled with certain number of credits, and credits are deducted over a given time period. When the time period is expired, the bucket is filled again with the same number of credits. This TC can be used to select time period. This feature does not allow user to specify the period in 'seconds' but a set of numbers from 0 to 10 only. "
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 10)

class RsLabel(TextualConvention, OctetString):
    description = ' ASCII character which are Letters,Digits and Under Scores Strings beginning with Digits and Underscores are not allowed '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 30)

class RsTOS(TextualConvention, Integer32):
    description = 'In IPv4 its the TOS byte of IP packet header. Unsigned integer value which can be mapped to TOS or DSCP depending on the associated rate limit action type'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class RsIfDirection(TextualConvention, Integer32):
    description = " Specifies a direction of data travel on interface. 'inbound' traffic is operated on during reception from the interface, while 'outbound' traffic is operated on prior to transmission on the interface. 'both' traffic is operated during both reception and prior to transmission on the interface. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("inbound", 1), ("outbound", 2), ("both", 3), ("unknown", 4))

class RsAction(TextualConvention, Integer32):
    description = 'Different actions allowed on the RS switch router Can be associated with rsTBMeterTable, or rsPortRLTable for rate limit purposes Note: not all the actions may be applicable to all the modules '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    namedValues = NamedValues(("noAction", 1), ("dropPackets", 2), ("setPriorityLow", 3), ("setPriorityMedium", 4), ("setPriorityHigh", 5), ("lowerPriority", 6), ("lowerPriorityExceptControl", 7), ("tosRewrite", 8), ("tosRewriteAndLowerPriority", 9), ("tosPrecedenceRewrite", 10), ("tosPrecedenceRewriteAndLowerPriority", 11), ("markPackets", 12))

rsRateLimitNotifications = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 0))
if mibBuilder.loadTexts: rsRateLimitNotifications.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitNotifications.setDescription('Group for Rate Limit related Notifications')
rsTBMeter = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5))
if mibBuilder.loadTexts: rsTBMeter.setStatus('current')
if mibBuilder.loadTexts: rsTBMeter.setDescription('Token Bucket Meter Table and associated objects')
if mibBuilder.loadTexts: rsTBMeter.setReference("Refer Riverstone Networks white paper 'An Overview of RateLimiting' for more details")
rsTBMeterApply = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10))
if mibBuilder.loadTexts: rsTBMeterApply.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApply.setDescription(' Meter Apply table and associated objects')
if mibBuilder.loadTexts: rsTBMeterApply.setReference("Refer Riverstone Networks white paper 'An Overview of RateLimiting' for more details")
rsTBMeterApplyMonitor = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15))
if mibBuilder.loadTexts: rsTBMeterApplyMonitor.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyMonitor.setDescription(' Group of token bucket rate limit monitor objects ')
rsPortRateLimit = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20))
if mibBuilder.loadTexts: rsPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: rsPortRateLimit.setDescription('Input and Output Port based rate limit tables')
if mibBuilder.loadTexts: rsPortRateLimit.setReference("Refer Riverstone Networks white paper 'An Overview of RateLimiting' for more details")
rsPortRLMonitor = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25))
if mibBuilder.loadTexts: rsPortRLMonitor.setStatus('current')
if mibBuilder.loadTexts: rsPortRLMonitor.setDescription(' Group of port based rate limit monitor objects ')
rsL2RateLimit = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26))
if mibBuilder.loadTexts: rsL2RateLimit.setStatus('current')
if mibBuilder.loadTexts: rsL2RateLimit.setDescription('L2 based rate limit tables')
rsL2RLMonitor = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29))
if mibBuilder.loadTexts: rsL2RLMonitor.setStatus('current')
if mibBuilder.loadTexts: rsL2RLMonitor.setDescription(' Group of l2 based rate limit monitor objects ')
rsRateLimitModes = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30))
if mibBuilder.loadTexts: rsRateLimitModes.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitModes.setDescription(' Group of rate limit mode configuration on RS platform ')
rsRateLimitGroups = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33))
if mibBuilder.loadTexts: rsRateLimitGroups.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroups.setDescription(' All different kinds of groupings used in RS rate limiting')
rsRateLimitConformance = ObjectIdentity((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35))
if mibBuilder.loadTexts: rsRateLimitConformance.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitConformance.setDescription('rate limit conformance group ')
rsTBMeterLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterLastChanged.setDescription(' The value of sysUpTime when last SET operation succeeds on this table. ')
rsTBMeterCount = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterCount.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterCount.setDescription('Total number of entries in the table ')
rsTBMeterErrorMessage = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterErrorMessage.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterErrorMessage.setDescription('Description of the error caused from the last SET operation that failed on this table')
rsTBMeterTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4), )
if mibBuilder.loadTexts: rsTBMeterTable.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterTable.setDescription('Token bucket service entry table')
rsTBMeterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1), ).setIndexNames((0, "RIVERSTONE-RATELIMIT-MIB", "rsTBMeterId"))
if mibBuilder.loadTexts: rsTBMeterEntry.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterEntry.setDescription("A record containing a token bucket service parameters. A new row can be created by setting the appropriate value in the table entry with RowStatus to CreateAndGo. The columns in this table are modifiable when the state of entry RowStatus is equal to 'NotInService' or 'NotReady'")
rsTBMeterId = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 1), RsLabel())
if mibBuilder.loadTexts: rsTBMeterId.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterId.setDescription('The administratively assigned name to this Meter entry. This name must be unique across the rate-limit module including port based rate limit module Note: name must be unique across the RS platform ratelimit module ')
rsTBMeterType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 2), RsMeterType().clone('perFlow')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterType.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterType.setDescription('The type of meter service. The value perFlow(1) indicates that this entry specifies a per L3 flow rate limit. For this type the rsTBMeterRate can take a value between 3000 and 1000000000. Agent must ignore the value in the following fields while validating the row: rsTBMeterBurst RsBurst, rsTBMeterBurstFailAction RsAction, rsTBMeterBurstFailActionRewrite RsTOS, -- rsTBMeterMinimumBandwidth RsRateLimit, -- rsTBMeterDistributeAmong RsDistAmong, softwareFlowAggregate(2) value is deprecated. -- softwareFlowAggregate(2) indicates that this -- entry specifies a software based rate limit aggregate. -- Agent must ignore the value in the following fields while -- validating the row: -- -- rsTBMeterBurst RsBurst, -- rsTBMeterBurstFailAction RsAction, -- rsTBMeterBurstFailActionRewrite RsTOS, hardwareFlowAggregate(3) indicates that this entry specifies a hardware based flow aggregation rate limit For this type the rsTBMeterRate can take a value between 0 and 1000000000. Agent must ignore the value in the following fields while validating the row: rsTBMeterBurst RsBurst, rsTBMeterBurstFailAction RsAction, rsTBMeterBurstFailActionRewrite RsTOS, -- rsTBMeterMinimumBandwidth RsRateLimit, -- rsTBMeterDistributeAmong RsDistAmong, perPort(4) indicates that this entry specifies a port-level rate limit service. For this type the rsTBMeterRate can take a value between 3000 and 1000000000 in outbound direction and between 0 and 1000000000 in inbound direction. Agent must ignore the value in the following fields while validating the row: rsTBMeterBurst RsBurst, rsTBMeterBurstFailAction RsAction, rsTBMeterBurstFailActionRewrite RsTOS, -- rsTBMeterMinimumBandwidth RsRateLimit, -- rsTBMeterDistributeAmong RsDistAmong, burstsafe(5) indicates that this entry specifies a dual bucket rate limit. For this type the rsTBMeterRate can take a value between 10000 and 1000000000. Agent must ignore the value in the following fields while validating the row: -- rsTBMeterMinimumBandwidth RsRateLimit, -- rsTBMeterDistributeAmong RsDistAmong, l2(6) indicates that this entry specifies a layer 2 rate limit. For this type the rsTBMeterRate can take a value between 0 and 1000000000. Agent must ignore the value in the following fields while validating the row: rsTBMeterBurst RsBurst, rsTBMeterBurstFailAction RsAction, rsTBMeterBurstFailActionRewrite RsTOS, ')
rsTBMeterRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 3), RsRateLimit().clone(3000)).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterRate.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterRate.setDescription('Token Bucket rate in bits per second. Refer to the Description of rsTBMeterType for acceptable values. ')
rsTBMeterBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 4), RsBurst().clone(10000)).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterBurst.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterBurst.setDescription(' The burst traffic rate (size) supported. This attribute is used only when rsTBMeterType is set to burstsafe(5) For RS platform rate ranges from 10000 to 1000000000. ')
rsTBMeterInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 5), RsMeterInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterInterval.setReference("Refer Riverstone Networks white paper 'An Overview of RateLimiting' for more details")
if mibBuilder.loadTexts: rsTBMeterInterval.setStatus('deprecated')
if mibBuilder.loadTexts: rsTBMeterInterval.setDescription(' The time interval used with the token bucket. ')
rsTBMeterFailAction = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 6), RsAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterFailAction.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterFailAction.setDescription(' The fail action to take when the traffic rate exceeds rsTBMeterRate. If the Action value indicates TOS rewrite or TOS Precedence rewrite, appropriate rewrite value should be in rsTBMeterFailActionRewrite. ')
rsTBMeterFailActionRewrite = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 7), RsTOS()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterFailActionRewrite.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterFailActionRewrite.setDescription(' TOS or TOS Precedence rewrite when the traffic exceeds rsTBMeterRate. rsTBMeterFailAction indicates this object value either TOS or TOS Precedence The object is ignored by agent if rsTBMeterFailAction does not indicate rewrite option. ')
rsTBMeterBurstFailAction = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 8), RsAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterBurstFailAction.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterBurstFailAction.setDescription(' The fail action to take when the traffic rate exceeds rsTBMeterBurst. If the Action value indicates TOS rewrite or TOS Precedence rewrite, appropriate rewrite value should be in rsTBMeterBurstFailActionRewrite. ')
rsTBMeterBurstFailActionRewrite = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 9), RsTOS()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterBurstFailActionRewrite.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterBurstFailActionRewrite.setDescription(' TOS or TOS Precedence rewrite when the traffic exceeds rsTBMeterBurst, rsTBMeterBurstFailAction indicates this object value either TOS or TOS Precedence The object is ignored by agent if rsTBMeterBurstFailAction does not indicate rewrite option. ')
rsTBMeterMinimumBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 10), RsRateLimit().clone(3000)).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterMinimumBandwidth.setStatus('deprecated')
if mibBuilder.loadTexts: rsTBMeterMinimumBandwidth.setDescription("The minimum bandwidth to allocate for each flow when rsTBMeterType is 'softwareFlowAggreage' For RS platform rate ranges from 3000 to 1000000000. ")
rsTBMeterDistributeAmong = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 11), RsDistAmong().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterDistributeAmong.setStatus('deprecated')
if mibBuilder.loadTexts: rsTBMeterDistributeAmong.setDescription('The rate-limit module allocates the minimum specified bandwidth to each matching flow,and the leftover bandwidth of rsTBMeterAccessRate will be distributed among these number of flow.')
rsTBMeterStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 12), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3))).clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterStorageType.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterStorageType.setDescription('Specify if entry should be persistent or not. ')
rsTBMeterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 5, 4, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterStatus.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a meter. Writable variable may not be modified when the row is active. ')
rsTBMeterApplyLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterApplyLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsTBMeterApplyCount = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterApplyCount.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyCount.setDescription('The current number of entries in rsTBMeterApplyTable ')
rsTBMeterApplyErrorMessage = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterApplyErrorMessage.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyErrorMessage.setDescription('Description of the error of the last SET operations to fail on this table')
rsTBMeterApplyMasterAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 4), RsAdminStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTBMeterApplyMasterAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyMasterAdminStatus.setDescription(' This object enables or disables all the entries in rsTBMeterApplyTable. This behaves like master fuse and do not change individual states of each row. User must check the state of this object before he tries to enable the state of entry. ')
rsTBMeterApplyTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5), )
if mibBuilder.loadTexts: rsTBMeterApplyTable.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyTable.setDescription('This table associates rate limits with interfaces. In particular, a profile from the rsTBMeter table with name rsTBMeterId2 is applied on certain IP interfaces and ports specified by ifIndex with classifier specified by rsTBMeterApplyAclName ')
rsTBMeterApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyDirection"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyAclName"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsTBMeterId2"))
if mibBuilder.loadTexts: rsTBMeterApplyEntry.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyEntry.setDescription("'ifIndex' is imported from IF-MIB. For RS platform, this value must point to an entry that has ifType of IP interface(126) ethernetCsmacd(6) L4 bridging MUST be enabled on the port before creating the entry. To enable/disable the L4 bridging state on a particular port use VLAN-EXTENSION-MIB module. The columns in this table are modifiable when the state of rsTBMeterApplyStatus equal to NotInService, NotReady. ")
rsTBMeterApplyDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 1), RsIfDirection().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: rsTBMeterApplyDirection.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyDirection.setDescription('Interface traffic direction. ')
rsTBMeterApplyAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 2), RsLabel())
if mibBuilder.loadTexts: rsTBMeterApplyAclName.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyAclName.setDescription('Access Control List name or Classifier Name, Must exist on the underlying system before activation. ')
rsTBMeterId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 3), RsLabel())
if mibBuilder.loadTexts: rsTBMeterId2.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterId2.setDescription('The meter id from rsTBMeterEntry.rsTBMeterId. rsTBMeterId must be an active row in rsTBMeterTable. ')
rsTBMeterApplyOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterApplyOwner.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyOwner.setDescription("The owner of this rate limit apply entry. The exact semantics of this string are subject to the security policy defined by the security administrator. If this entry was created via Command Line Interface, this will be set to 'monitor' ")
rsTBMeterApplyAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 5), RsAdminStatus().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterApplyAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyAdminStatus.setDescription('The desired state of the rate limit entry.')
rsTBMeterApplyStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 6), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3))).clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterApplyStorageType.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyStorageType.setDescription('Specify if entry should be persistent or not.')
rsTBMeterApplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 10, 5, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsTBMeterApplyStatus.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterApplyStatus.setDescription('Allows to create a new row and modify or destroy an existing row in the manner described in the definition of the RowStatus textual convention ')
rsPortRLLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsPortRLLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsPortRLCount = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLCount.setStatus('current')
if mibBuilder.loadTexts: rsPortRLCount.setDescription('The current number of entries in rsPortRLTable ')
rsPortRLErrorMessage = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLErrorMessage.setStatus('current')
if mibBuilder.loadTexts: rsPortRLErrorMessage.setDescription('Description of the error caused when the last SET operation failed on this table')
rsPortRLMasterAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 4), RsAdminStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPortRLMasterAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsPortRLMasterAdminStatus.setDescription(' This object enables or disables all the entries in rsPortRLTable. This behaves like master fuse and do not change individual states of each row. User must check the state of this object before he tries to enable the state of an entry in rsPortRLTAble. ')
rsPortRLTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5), )
if mibBuilder.loadTexts: rsPortRLTable.setStatus('current')
if mibBuilder.loadTexts: rsPortRLTable.setDescription('An entry which allows to create port based ratelimit service and to activate it on a physical port')
rsPortRLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsPortRLDirection"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsPortRLMeterId"))
if mibBuilder.loadTexts: rsPortRLEntry.setStatus('current')
if mibBuilder.loadTexts: rsPortRLEntry.setDescription("'ifIndex' is imported from IF-MIB, which carries an index for physical port. For RS platform, this value must point to an entry that has ifType of ethernetCsmacd(6). The columns in this table are modifiable when the state of rsPortRLStatus equal to NotInService, NotReady. ")
rsPortRLDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 1), RsIfDirection().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: rsPortRLDirection.setStatus('current')
if mibBuilder.loadTexts: rsPortRLDirection.setDescription('Input/Output direction to apply rate limit on a port ')
rsPortRLMeterId = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 2), RsLabel())
if mibBuilder.loadTexts: rsPortRLMeterId.setStatus('current')
if mibBuilder.loadTexts: rsPortRLMeterId.setDescription('Administratively assigned name to port based rate limit entry Note: name must be unique across the RS platform ratelimit module ')
rsPortRLOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLOwner.setStatus('current')
if mibBuilder.loadTexts: rsPortRLOwner.setDescription('The owner of this entry. The exact semantics of this string are subject to the security policy defined by the security administrator.')
rsPortRLRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 4), RsRateLimit().clone(3000)).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLRate.setStatus('current')
if mibBuilder.loadTexts: rsPortRLRate.setDescription('Rate to limit port traffic to. For RS platform rate ranges from 3000 to 1000000000. ')
rsPortRLFailAction = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 5), RsAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLFailAction.setStatus('current')
if mibBuilder.loadTexts: rsPortRLFailAction.setDescription(' The action to take when the traffic rate exceeds rsPortRLRate. If the Action value indicates TOS rewrite or TOS Precedence rewrite, appropriate rewrite value should be in rsPortRLFailActionRewrite. ')
rsPortRLFailActionRewrite = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 6), RsTOS()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLFailActionRewrite.setStatus('current')
if mibBuilder.loadTexts: rsPortRLFailActionRewrite.setDescription(' TOS or TOS Precedence rewrite when the traffic exceeds rsPortRLRate. rsPortRLFailAction indicates this object value either TOS or TOS Precedence The object is ignored by agent if rsPortRLFailAction does not indicate rewrite option. ')
rsPortRLInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 7), RsMeterInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLInterval.setReference("Refer Riverstone Networks white paper 'An Overview of RateLimiting' for more details")
if mibBuilder.loadTexts: rsPortRLInterval.setStatus('deprecated')
if mibBuilder.loadTexts: rsPortRLInterval.setDescription(' The time interval used with the token bucket. ')
rsPortRLAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 8), RsAdminStatus().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsPortRLAdminStatus.setDescription('The desired state of the rate limit entry.')
rsPortRLStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 9), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3))).clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLStorageType.setStatus('current')
if mibBuilder.loadTexts: rsPortRLStorageType.setDescription('Specify if entry should be persistent or not. ')
rsPortRLStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 20, 5, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsPortRLStatus.setStatus('current')
if mibBuilder.loadTexts: rsPortRLStatus.setDescription(' Allows to create a new row and modify or destroy an existing row in the manner described in the definition of the RowStatus textual convention ')
rsL2RLApplyLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLApplyLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsL2RLApplyCount = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLApplyCount.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyCount.setDescription('The current number of entries in rsL2RLApplyTable ')
rsL2RLApplyErrorMessage = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLApplyErrorMessage.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyErrorMessage.setDescription('Description of the error of the last SET operations to fail on this table')
rsL2RLApplyMasterAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 4), RsAdminStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsL2RLApplyMasterAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyMasterAdminStatus.setDescription(' This object enables or disables all the entries in rsL2RLApplyTable. This behaves like master fuse and do not change individual states of each row. User must check the state of this object before he tries to enable the state of entry. ')
rsL2RLApplyTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5), )
if mibBuilder.loadTexts: rsL2RLApplyTable.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyTable.setDescription('This table associates rate limits with port / portgroups / filter / filtergroups. In particular, a profile from the rsTBMeter table with name rsTBMeterId is applied on certain ports specified by ifIndex or the port groups specified with rsL2RLApplyPortGroupName with filter specified by rsL2RLApplyFilterName or the filter groups specified with the rsL2RLApplyFilterName or the classifier mentioned in the entry. ')
rsL2RLApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1), ).setIndexNames((0, "RIVERSTONE-RATELIMIT-MIB", "rsTBMeterId"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyDirection"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyIfIndex"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyPortGroupName"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyFilterName"))
if mibBuilder.loadTexts: rsL2RLApplyEntry.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyEntry.setDescription("'ifIndex' is imported from IF-MIB. For RS platform, this value must point to an entry that has ifType of ethernetCsmacd(6) The columns in this table are modifiable when the state of rsL2RLApplyStatus equal to NotInService, NotReady. ")
rsL2RLApplyDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 1), RsIfDirection().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: rsL2RLApplyDirection.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyDirection.setDescription('Interface traffic direction. ')
rsL2RLApplyIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 2), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rsL2RLApplyIfIndex.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyIfIndex.setDescription('When the service is applied on a single port, this value should be the ifIndex of the port where the service is applied. If it is applied on a group of ports, this value should be zero. If it is nonZero, the rsL2RLApplyPortGroupName should be a zero length octet string.')
rsL2RLApplyPortGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 3), RsLabel())
if mibBuilder.loadTexts: rsL2RLApplyPortGroupName.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyPortGroupName.setDescription('This object identifies one or more rows in the rsRLPortGroupTable, when it of length nonzero. In this case the rsL2RLApplyIfIndex should be zero. If the service is applied on a single port, this object is supposed to be a zero length octet string.')
rsL2RLApplyFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 4), RsLabel())
if mibBuilder.loadTexts: rsL2RLApplyFilterName.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyFilterName.setDescription('Filter name or Classifier Name, Must exist on the underlying system before activation. If rsL2RLIsFilterGroup is set to true, then this name specifies the filter group name. The actual filters associated to this entry are specified in rsRLFilterGroupTable. If both filter and port groups are present, this value should be same as the rsL2RLApplyPortGroupName. ')
rsL2RLIsFilterGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLIsFilterGroup.setStatus('current')
if mibBuilder.loadTexts: rsL2RLIsFilterGroup.setDescription('When this value is set to true, then rsL2RLApplyFilterName specifies the group of filters mentioned in the rsRLFilterGroupTable. If set to false, the rsL2RLApplyFilterName specifies the filter name associated with the service.')
rsL2RLApplyOnePGrouping = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("other", 1), ("group1", 2), ("group2", 3), ("group3", 4), ("group4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLApplyOnePGrouping.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyOnePGrouping.setDescription('This object specifies the 802.1p priority groupings for which this service is to be applied. Currently, 4 different groups can be constructed and those priorities which are not in any groups is put under other category.')
rsL2RLApplyOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLApplyOwner.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyOwner.setDescription("The owner of this rate limit apply entry. The exact semantics of this string are subject to the security policy defined by the security administrator. If this entry was created via Command Line Interface, this will be set to 'monitor' ")
rsL2RLApplyAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 8), RsAdminStatus().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLApplyAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyAdminStatus.setDescription('The desired state of the rate limit entry.')
rsL2RLApplyStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 9), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3))).clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLApplyStorageType.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyStorageType.setDescription('Specify if entry should be persistent or not.')
rsL2RLApplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 26, 5, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsL2RLApplyStatus.setStatus('current')
if mibBuilder.loadTexts: rsL2RLApplyStatus.setDescription('Allows to create a new row and modify or destroy an existing row in the manner described in the definition of the RowStatus textual convention ')
rsRLModeLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLModeLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsRLModeLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsRLModeTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2), )
if mibBuilder.loadTexts: rsRLModeTable.setStatus('current')
if mibBuilder.loadTexts: rsRLModeTable.setDescription('Entry of rate limit mode and input port ratelimit state The rows in this table are created dynamically by inserting line cards in their respective slots of the underlying system. When a slot/module is activated resulting entry in this table will have the default operating modes. Essentially the ratelimit mode and input port ratelimit status value. Certain SET operation on this entry might fail if the underlying hardware does not support the mode. ')
rsRLModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: rsRLModeEntry.setStatus('current')
if mibBuilder.loadTexts: rsRLModeEntry.setDescription(' A record containing ratelimt mode on given module/slot. The columns in this entry are modifiable. This is indexed by entPhysicalIndex whose entPhysicalClass == module(9). ')
rsRLModeType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flowMode", 1), ("aggregateMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRLModeType.setStatus('current')
if mibBuilder.loadTexts: rsRLModeType.setDescription(" Type of rate limit modes supported on this slot Value is writable only when rsRLModeCapabilityBits has rlMode(0) set to '1'. The table below relates the ratelimit type supported in each Mode. +---------------------+----------+--------------+ |RsMeterType | flowMode | aggregateMode| +---------------------+----------+--------------+ |perFlow(1) | X | | |softFlowAgg(2) | X | | |hardFlowAgg(3) | | X | |perPort(4) -input | | X | |perPort(4) -output | X | X | +---------------------+----------+--------------+ X indicates supported. ")
rsRLModeInputPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1, 2), RsAdminStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRLModeInputPortStatus.setStatus('current')
if mibBuilder.loadTexts: rsRLModeInputPortStatus.setDescription(" Input Port RateLimit status on this slot. Value is writable only when rsRLModeCapabilityBits has rlInputPortRateLimit set to '1'. ")
rsRLModeCapabilityBits = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1, 3), Bits().clone(namedValues=NamedValues(("rlMode", 0), ("rlInputPortRateLimit", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLModeCapabilityBits.setStatus('current')
if mibBuilder.loadTexts: rsRLModeCapabilityBits.setDescription(' Specifies the Module capability. rlMode(0) if set to 1 indicates the Module supports the Flow or Aggregate mode. rlInputPortRateLimit(1) if set to 1 indicates the Module supports input port based rate limiting. ')
rsRLModeEntryLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLModeEntryLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsRLModeEntryLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this entry')
rsRLModeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 30, 2, 1, 5), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3))).clone('volatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRLModeStorageType.setStatus('current')
if mibBuilder.loadTexts: rsRLModeStorageType.setDescription(' Storage type for this entry. ')
rsRLPortGroupLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLPortGroupLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsRLPortGroupTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 2), )
if mibBuilder.loadTexts: rsRLPortGroupTable.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupTable.setDescription('This table is to associate one or more ports as a group.')
rsRLPortGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 2, 1), ).setIndexNames((0, "RIVERSTONE-RATELIMIT-MIB", "rsRLPortGroupName"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rsRLPortGroupEntry.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupEntry.setDescription(' A record containing group name and ifIndex.')
rsRLPortGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 2, 1, 1), RsLabel())
if mibBuilder.loadTexts: rsRLPortGroupName.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupName.setDescription('The administratively assigned name to this PortGroup entry. ')
rsRLPortGroupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 2, 1, 2), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLPortGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupStorageType.setDescription(' Storage type for this entry. The value of this entry will be the same as the one specified in the row of rsL2RLApplyTable where this group is used. If none of the entries use this group, then the storage type will be volatile. ')
rsRLPortGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsRLPortGroupStatus.setStatus('current')
if mibBuilder.loadTexts: rsRLPortGroupStatus.setDescription('Allows to create a new row and modify or destroy an existing row in the manner described in the definition of the RowStatus textual convention ')
rsRLFilterGroupLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLFilterGroupLastChanged.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupLastChanged.setDescription('The value of sysUpTime when last SET operation succeeds on this table')
rsRLFilterGroupTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4), )
if mibBuilder.loadTexts: rsRLFilterGroupTable.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupTable.setDescription('This table is to associate one or more ports as a group.')
rsRLFilterGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4, 1), ).setIndexNames((0, "RIVERSTONE-RATELIMIT-MIB", "rsRLFilterGroupName"), (0, "RIVERSTONE-RATELIMIT-MIB", "rsRLFilterName"))
if mibBuilder.loadTexts: rsRLFilterGroupEntry.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupEntry.setDescription(' A record containing group name and filter name.')
rsRLFilterGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4, 1, 1), RsLabel())
if mibBuilder.loadTexts: rsRLFilterGroupName.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupName.setDescription('The administratively assigned name to this FilterGroup entry. ')
rsRLFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4, 1, 2), RsLabel())
if mibBuilder.loadTexts: rsRLFilterName.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterName.setDescription('The name of the filter part of this group. ')
rsRLFilterGroupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4, 1, 3), StorageType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("volatile", 2), ("nonVolatile", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRLFilterGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupStorageType.setDescription(' Storage type for this entry. The value of this entry will be the same as the one specified in the row of rsL2RLApplyTable where this group is used. If none of the entries use this group, then the storage type will be volatile. ')
rsRLFilterGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 33, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rsRLFilterGroupStatus.setStatus('current')
if mibBuilder.loadTexts: rsRLFilterGroupStatus.setDescription('Allows to create a new row and modify or destroy an existing row in the manner described in the definition of the RowStatus textual convention ')
rsTBMeterMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1), )
if mibBuilder.loadTexts: rsTBMeterMonitorTable.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterMonitorTable.setDescription(' Table which carries exceed count for each token bucket meter applied on Access Control List. ')
rsTBMeterMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1, 1), )
rsTBMeterApplyEntry.registerAugmentions(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterMonitorEntry"))
rsTBMeterMonitorEntry.setIndexNames(*rsTBMeterApplyEntry.getIndexNames())
if mibBuilder.loadTexts: rsTBMeterMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterMonitorEntry.setDescription(' This is a read only table of exceed count for each token bucket entry applied on Access Contol List. ')
rsTBMeterExceedByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterExceedByteCount.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterExceedByteCount.setDescription(' Total number of bytes exceeded as a result of traffic rate limiting on a particular rsTBMeterApplyEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsTBMeterCounterDiscontinuityTime. ')
rsTBMeterCounterDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterCounterDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterCounterDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which this counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.')
rsTBMeterExceedPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterExceedPacketCount.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterExceedPacketCount.setDescription(' Total number of packets exceeded the specified traffic rate limiting on a particular rsTBMeterApplyEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsTBMeterCounterDiscontinuityTime. ')
rsTBMeterExceedBurstPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 15, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTBMeterExceedBurstPacketCount.setStatus('current')
if mibBuilder.loadTexts: rsTBMeterExceedBurstPacketCount.setDescription(' Total number of packets exceeded the specified burst rate on a particular rsTBMeterApplyEntry entry. This is object is valid only when the rsTBMeterType is burstsafe(5) in the row referred by the rsTBMeterId2 in the rsTBMeterTable. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsTBMeterCounterDiscontinuityTime. ')
rsPortRLMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25, 1), )
if mibBuilder.loadTexts: rsPortRLMonitorTable.setStatus('current')
if mibBuilder.loadTexts: rsPortRLMonitorTable.setDescription(' Table which carries exceed count for each token bucket meter applied on the port based ones. ')
rsPortRLMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25, 1, 1), )
rsPortRLEntry.registerAugmentions(("RIVERSTONE-RATELIMIT-MIB", "rsPortRLMonitorEntry"))
rsPortRLMonitorEntry.setIndexNames(*rsPortRLEntry.getIndexNames())
if mibBuilder.loadTexts: rsPortRLMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: rsPortRLMonitorEntry.setDescription(' This is a read only table of exceed count for each token bucket entry applied the port based ones. ')
rsPortRLExceedByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLExceedByteCount.setStatus('current')
if mibBuilder.loadTexts: rsPortRLExceedByteCount.setDescription(' Total number of bytes exceeded as a result of traffic rate limiting on a particular rsPortRLEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsPortRLCounterDiscontinuityTime. ')
rsPortRLCounterDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLCounterDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: rsPortRLCounterDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which this counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.')
rsPortRLExceedPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 25, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPortRLExceedPacketCount.setStatus('current')
if mibBuilder.loadTexts: rsPortRLExceedPacketCount.setDescription(' Total number of packets that exceeded the specified traffic rate limiting on a particular rsPortRLEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsPortRLCounterDiscontinuityTime. ')
rsL2RLMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29, 1), )
if mibBuilder.loadTexts: rsL2RLMonitorTable.setStatus('current')
if mibBuilder.loadTexts: rsL2RLMonitorTable.setDescription(' Table which carries exceed count for each token bucket meter applied on L2 Filter or Filter Group. ')
rsL2RLMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29, 1, 1), )
rsL2RLApplyEntry.registerAugmentions(("RIVERSTONE-RATELIMIT-MIB", "rsL2RLMonitorEntry"))
rsL2RLMonitorEntry.setIndexNames(*rsL2RLApplyEntry.getIndexNames())
if mibBuilder.loadTexts: rsL2RLMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: rsL2RLMonitorEntry.setDescription(' This is a read only table of exceed count for each token bucket entry applied on L2 Filter or Filter Groups. ')
rsL2RLExceedByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLExceedByteCount.setStatus('current')
if mibBuilder.loadTexts: rsL2RLExceedByteCount.setDescription(' Total number of bytes that exceeded the specified traffic rate limiting on a particular rsL2RLApplyEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsL2RLCounterDiscontinuityTime. ')
rsL2RLExceedPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLExceedPacketCount.setStatus('current')
if mibBuilder.loadTexts: rsL2RLExceedPacketCount.setDescription(' Total number of packets that exceeded the specified traffic rate limiting on a particular rsL2RLApplyEntry entry. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of rsL2RLCounterDiscontinuityTime. ')
rsL2RLCounterDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5567, 2, 25, 29, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsL2RLCounterDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: rsL2RLCounterDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which this counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.')
rsRateLimitCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 1))
rsRateLimitGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2))
rsRateLimitComplianceV2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 1, 2)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsRateLimitGroup1"), ("RIVERSTONE-RATELIMIT-MIB", "rsRateLimitGroup2"), ("RIVERSTONE-RATELIMIT-MIB", "rsRateLimitGroup6"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitComplianceV2 = rsRateLimitComplianceV2.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitComplianceV2.setDescription('rsRateLimitGroup1 and rsRateLimitGroup2 is mandatory for implementation of this MIB. This compliance is deprecated and replaced by rsRateLimitComplianceV2')
rsRateLimitCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 1, 1)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsRateLimitGroup1"), ("RIVERSTONE-RATELIMIT-MIB", "rsRateLimitGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitCompliance = rsRateLimitCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: rsRateLimitCompliance.setDescription('rsRateLimitGroup1 and rsRateLimitGroup2 is mandatory for implementation of this MIB. This compliance is deprecated and replaced by rsRateLimitComplianceV2')
rsRateLimitGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 1)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterErrorMessage"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterType"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterRate"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterBurst"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterFailAction"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterFailActionRewrite"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterBurstFailActionRewrite"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyErrorMessage"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyMasterAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyOwner"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterApplyStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup1 = rsRateLimitGroup1.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup1.setDescription('A set of managed objects that make up version 0.1 of the RS rate limit MIB Group.')
rsRateLimitGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 2)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsPortRLLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLErrorMessage"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLMasterAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLOwner"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLRate"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLFailAction"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLFailActionRewrite"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup2 = rsRateLimitGroup2.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup2.setDescription('A set of managed objects that make up version 0.1 of the RS rate limit MIB Group for port based rate limiting.')
rsRateLimitGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 3)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsRLModeLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLModeType"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLModeCapabilityBits"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLModeInputPortStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLModeEntryLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLModeStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup3 = rsRateLimitGroup3.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup3.setDescription('This group is mandatory for all RS platforms that support port or interface based rate limits')
rsRateLimitGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 4)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterBurstFailAction"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterMinimumBandwidth"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterDistributeAmong"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterInterval"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup4 = rsRateLimitGroup4.setStatus('deprecated')
if mibBuilder.loadTexts: rsRateLimitGroup4.setDescription('This optional group applies to RS Product line that supports dual rate token bucket metering (aka Burst Safe (tm) This group is replaced by rsRateLimitGroup4V2')
rsRateLimitGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 5)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterExceedByteCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterCounterDiscontinuityTime"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLExceedByteCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLCounterDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup5 = rsRateLimitGroup5.setStatus('deprecated')
if mibBuilder.loadTexts: rsRateLimitGroup5.setDescription(' Optional Group of rate limit monitor objects. This group is replaced by rsRateLimitGroup5V2. ')
rsRateLimitGroup4V2 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 6)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterBurstFailAction"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup4V2 = rsRateLimitGroup4V2.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup4V2.setDescription('This optional group applies to RS Product line that supports dual rate token bucket metering (aka Burst Safe (tm)')
rsRateLimitGroup5V2 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 7)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterExceedByteCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterExceedPacketCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterCounterDiscontinuityTime"), ("RIVERSTONE-RATELIMIT-MIB", "rsTBMeterExceedBurstPacketCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLExceedByteCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLExceedPacketCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsPortRLCounterDiscontinuityTime"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLExceedByteCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLExceedPacketCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLCounterDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup5V2 = rsRateLimitGroup5V2.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup5V2.setDescription(' Optional Group of rate limit monitor objects ')
rsRateLimitGroup6 = ObjectGroup((1, 3, 6, 1, 4, 1, 5567, 2, 25, 35, 2, 8)).setObjects(("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyCount"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyErrorMessage"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyMasterAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLIsFilterGroup"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyOnePGrouping"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyOwner"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyAdminStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsL2RLApplyStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLFilterGroupLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLPortGroupStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLPortGroupStatus"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLPortGroupLastChanged"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLFilterGroupStorageType"), ("RIVERSTONE-RATELIMIT-MIB", "rsRLFilterGroupStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rsRateLimitGroup6 = rsRateLimitGroup6.setStatus('current')
if mibBuilder.loadTexts: rsRateLimitGroup6.setDescription('A set of managed objects that make up version 0.2 of the RS rate limit MIB Group for l2 based rate limiting.')
mibBuilder.exportSymbols("RIVERSTONE-RATELIMIT-MIB", rsRateLimitGroup4=rsRateLimitGroup4, rsRLFilterGroupLastChanged=rsRLFilterGroupLastChanged, rsPortRLStatus=rsPortRLStatus, rsL2RLExceedByteCount=rsL2RLExceedByteCount, rsL2RLApplyMasterAdminStatus=rsL2RLApplyMasterAdminStatus, rsL2RLApplyFilterName=rsL2RLApplyFilterName, rsRLModeTable=rsRLModeTable, rsTBMeterMonitorTable=rsTBMeterMonitorTable, rsTBMeterInterval=rsTBMeterInterval, rsTBMeterId=rsTBMeterId, rsL2RLApplyTable=rsL2RLApplyTable, rsRLPortGroupName=rsRLPortGroupName, rsL2RateLimit=rsL2RateLimit, rsPortRLInterval=rsPortRLInterval, rsRLPortGroupStorageType=rsRLPortGroupStorageType, rsPortRLMeterId=rsPortRLMeterId, RsDistAmong=RsDistAmong, rsRateLimitMIB=rsRateLimitMIB, rsTBMeterApplyEntry=rsTBMeterApplyEntry, rsRLModeEntryLastChanged=rsRLModeEntryLastChanged, rsPortRLEntry=rsPortRLEntry, rsPortRLLastChanged=rsPortRLLastChanged, rsTBMeterStatus=rsTBMeterStatus, rsPortRLCount=rsPortRLCount, RsLabel=RsLabel, rsL2RLApplyCount=rsL2RLApplyCount, PYSNMP_MODULE_ID=rsRateLimitMIB, rsL2RLApplyOnePGrouping=rsL2RLApplyOnePGrouping, rsL2RLApplyErrorMessage=rsL2RLApplyErrorMessage, RsTOS=RsTOS, rsTBMeterDistributeAmong=rsTBMeterDistributeAmong, rsTBMeterApplyAdminStatus=rsTBMeterApplyAdminStatus, rsRateLimitGroup=rsRateLimitGroup, rsTBMeterErrorMessage=rsTBMeterErrorMessage, rsRLModeType=rsRLModeType, rsL2RLApplyLastChanged=rsL2RLApplyLastChanged, RsMeterType=RsMeterType, rsTBMeterApplyTable=rsTBMeterApplyTable, rsTBMeterApplyErrorMessage=rsTBMeterApplyErrorMessage, rsTBMeterApplyMasterAdminStatus=rsTBMeterApplyMasterAdminStatus, rsTBMeterMonitorEntry=rsTBMeterMonitorEntry, rsTBMeterFailAction=rsTBMeterFailAction, rsPortRLTable=rsPortRLTable, rsTBMeterApplyOwner=rsTBMeterApplyOwner, rsL2RLApplyStorageType=rsL2RLApplyStorageType, rsRateLimitGroup4V2=rsRateLimitGroup4V2, rsL2RLMonitor=rsL2RLMonitor, rsRLFilterGroupEntry=rsRLFilterGroupEntry, rsTBMeterExceedPacketCount=rsTBMeterExceedPacketCount, RsIfDirection=RsIfDirection, rsL2RLApplyOwner=rsL2RLApplyOwner, rsTBMeterBurstFailAction=rsTBMeterBurstFailAction, rsPortRLOwner=rsPortRLOwner, RsRateLimit=RsRateLimit, rsRLPortGroupEntry=rsRLPortGroupEntry, rsRLModeInputPortStatus=rsRLModeInputPortStatus, rsPortRLMonitor=rsPortRLMonitor, rsRateLimitCompliances=rsRateLimitCompliances, rsL2RLApplyIfIndex=rsL2RLApplyIfIndex, rsL2RLExceedPacketCount=rsL2RLExceedPacketCount, rsTBMeterApplyLastChanged=rsTBMeterApplyLastChanged, rsTBMeterRate=rsTBMeterRate, rsTBMeterCount=rsTBMeterCount, rsTBMeterMinimumBandwidth=rsTBMeterMinimumBandwidth, rsTBMeterApplyAclName=rsTBMeterApplyAclName, rsPortRLFailAction=rsPortRLFailAction, rsTBMeterApplyStorageType=rsTBMeterApplyStorageType, rsTBMeterLastChanged=rsTBMeterLastChanged, rsPortRLStorageType=rsPortRLStorageType, rsTBMeterApplyMonitor=rsTBMeterApplyMonitor, rsPortRLExceedByteCount=rsPortRLExceedByteCount, rsRLPortGroupTable=rsRLPortGroupTable, rsRateLimitModes=rsRateLimitModes, rsTBMeterApply=rsTBMeterApply, rsPortRLMonitorEntry=rsPortRLMonitorEntry, rsRateLimitGroup2=rsRateLimitGroup2, rsPortRLErrorMessage=rsPortRLErrorMessage, rsRLFilterGroupStatus=rsRLFilterGroupStatus, rsRateLimitGroup5=rsRateLimitGroup5, rsRateLimitGroup6=rsRateLimitGroup6, rsRateLimitNotifications=rsRateLimitNotifications, rsRateLimitGroup1=rsRateLimitGroup1, rsL2RLApplyDirection=rsL2RLApplyDirection, rsTBMeterBurst=rsTBMeterBurst, rsRLFilterGroupName=rsRLFilterGroupName, rsTBMeterApplyCount=rsTBMeterApplyCount, rsRLFilterGroupStorageType=rsRLFilterGroupStorageType, rsRateLimitConformance=rsRateLimitConformance, rsTBMeterExceedBurstPacketCount=rsTBMeterExceedBurstPacketCount, rsPortRLExceedPacketCount=rsPortRLExceedPacketCount, rsTBMeterStorageType=rsTBMeterStorageType, rsRLPortGroupStatus=rsRLPortGroupStatus, rsL2RLMonitorEntry=rsL2RLMonitorEntry, rsPortRLMasterAdminStatus=rsPortRLMasterAdminStatus, rsTBMeterCounterDiscontinuityTime=rsTBMeterCounterDiscontinuityTime, rsRateLimitGroup3=rsRateLimitGroup3, rsL2RLCounterDiscontinuityTime=rsL2RLCounterDiscontinuityTime, rsTBMeterApplyDirection=rsTBMeterApplyDirection, rsRLFilterName=rsRLFilterName, rsL2RLIsFilterGroup=rsL2RLIsFilterGroup, rsTBMeterExceedByteCount=rsTBMeterExceedByteCount, rsRateLimitGroup5V2=rsRateLimitGroup5V2, rsTBMeterEntry=rsTBMeterEntry, rsPortRLFailActionRewrite=rsPortRLFailActionRewrite, rsRLModeLastChanged=rsRLModeLastChanged, rsPortRLAdminStatus=rsPortRLAdminStatus, rsRLModeCapabilityBits=rsRLModeCapabilityBits, rsL2RLApplyPortGroupName=rsL2RLApplyPortGroupName, RsAdminStatus=RsAdminStatus, rsL2RLApplyStatus=rsL2RLApplyStatus, rsTBMeterBurstFailActionRewrite=rsTBMeterBurstFailActionRewrite, rsPortRLRate=rsPortRLRate, rsTBMeterId2=rsTBMeterId2, rsTBMeterTable=rsTBMeterTable, rsRateLimitGroups=rsRateLimitGroups, rsPortRLDirection=rsPortRLDirection, rsPortRateLimit=rsPortRateLimit, rsTBMeterType=rsTBMeterType, rsRateLimitComplianceV2=rsRateLimitComplianceV2, rsTBMeter=rsTBMeter, rsRLFilterGroupTable=rsRLFilterGroupTable, rsPortRLCounterDiscontinuityTime=rsPortRLCounterDiscontinuityTime, rsL2RLApplyEntry=rsL2RLApplyEntry, rsPortRLMonitorTable=rsPortRLMonitorTable, rsRateLimitCompliance=rsRateLimitCompliance, rsRLModeStorageType=rsRLModeStorageType, rsRLPortGroupLastChanged=rsRLPortGroupLastChanged, RsBurst=RsBurst, rsL2RLMonitorTable=rsL2RLMonitorTable, RsAction=RsAction, rsTBMeterFailActionRewrite=rsTBMeterFailActionRewrite, RsMeterInterval=RsMeterInterval, rsL2RLApplyAdminStatus=rsL2RLApplyAdminStatus, rsRLModeEntry=rsRLModeEntry, rsTBMeterApplyStatus=rsTBMeterApplyStatus)

#
# PySNMP MIB module BMA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BMA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:39:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
IbDataPort, infinibandMIB = mibBuilder.importSymbols("IB-TC-MIB", "IbDataPort", "infinibandMIB")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
TimeTicks, Counter64, ObjectIdentity, MibIdentifier, Bits, IpAddress, Counter32, NotificationType, Unsigned32, Integer32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter64", "ObjectIdentity", "MibIdentifier", "Bits", "IpAddress", "Counter32", "NotificationType", "Unsigned32", "Integer32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Gauge32")
TextualConvention, DateAndTime, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DateAndTime", "TruthValue", "DisplayString")
ibBmaMIB = ModuleIdentity((1, 3, 6, 1, 3, 117, 5))
ibBmaMIB.setRevisions(('2005-09-01 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ibBmaMIB.setRevisionsDescriptions(('Initial version published as part of RFC XXXX.',))
if mibBuilder.loadTexts: ibBmaMIB.setLastUpdated('200509011200Z')
if mibBuilder.loadTexts: ibBmaMIB.setOrganization('IETF IP Over IB (IPOIB) Working Group')
if mibBuilder.loadTexts: ibBmaMIB.setContactInfo('Sean Harnedy (sharnedy@mangrovesystems.com) Mangrove Systems, Inc.')
if mibBuilder.loadTexts: ibBmaMIB.setDescription('Copyright (C) The Internet Society (2005). The initial version of this MIB module was published in RFC XXXX; for full legal notices see the RFC itself. Supplementary information may be available on http://www.ietf.org/copyrights/ianamib.html. This module contains managed object definitions for the Baseboard Management Agent instrumentation for an InfiniBand Baseboard Management Agent (BMA).')
ibBmaObjects = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1))
ibBmaConformance = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 2))
ibBmaBmuInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 1))
ibBmaBaseboardManagedUnitType = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ibModule", 1), ("nonModule", 2), ("managedChassis", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBaseboardManagedUnitType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2 Baseboard Management; and Vol. 2. Chapter 12 Hardware Management.')
if mibBuilder.loadTexts: ibBmaBaseboardManagedUnitType.setStatus('current')
if mibBuilder.loadTexts: ibBmaBaseboardManagedUnitType.setDescription('The Baseboard Managed Unit (BMU) that contains the BMA is one of three basic types. If the BMU contains an interface to the InfiniBand Management Link (IB-ML) it is called an IB-Module and returns ibModule(1). If the BMU does not contain the IB-ML, it is called a non-Module and returns nonModule(2). If the BMU is part of a managed chassis and contains the Chassis Management Entity (CME) it will return managedChassis(3).')
ibBmaIsIBMLSupported = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsIBMLSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.1; Table 205 Baseboard Management ClassPortInfo:Capability Mask.')
if mibBuilder.loadTexts: ibBmaIsIBMLSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsIBMLSupported.setDescription('Flag that indicates whether direct access to IB-ML is supported.')
ibBmaIBMLImplementation = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ibMlPhysical", 1), ("ibMlVirtual", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIBMLImplementation.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.1; Section 13.2.3.2.2 Virtual IB-ML Vol. 2.')
if mibBuilder.loadTexts: ibBmaIBMLImplementation.setStatus('current')
if mibBuilder.loadTexts: ibBmaIBMLImplementation.setDescription('Indicates whether the IB-ML is a physical or virtual implementation. This object is only meaningful if ibBmaIsIBMLSupported has a value of true(1). If the IB-ML implementation type is not known, the unknown(3) value is returned.')
ibBmaBKeyInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 2))
ibBmaIsBKeyNVRAM = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 2, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsBKeyNVRAM.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.1; Table 205 Baseboard Management ClassPortInfo:Capability Mask.')
if mibBuilder.loadTexts: ibBmaIsBKeyNVRAM.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsBKeyNVRAM.setDescription('Flag that indicates whether the Baseboard Management key (B_Key) is being stored in NVRAM.')
ibBmaBKeyValue = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBKeyValue.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.3; Table 208 BKeyInfo; BKeyInfo:B_Key.')
if mibBuilder.loadTexts: ibBmaBKeyValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaBKeyValue.setDescription('The eight-byte Baseboard Management key that is used in all BM MADs sent and received by all valid Baseboard Managers. If the value is all zeroes, B_Key checking is not done by the BMA. Each BMA in a node has one B_Key.')
ibBmaBKeyProtectBit = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 2, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBKeyProtectBit.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.4.6; Table 211 Protection Levels.')
if mibBuilder.loadTexts: ibBmaBKeyProtectBit.setStatus('current')
if mibBuilder.loadTexts: ibBmaBKeyProtectBit.setDescription("Flag that controls B_Key prototection levels at the BMA. If the ibBmaBKeyValue is zero, no protection is provided for any ibBmaBKeyProtectBit value. If this value is false(2), protection is provided, but any BM can read this BMA's B_Key value (i.e., ibBmaBKeyValue). If this value is true(1), protection is provided depending on the value of the B_Key lease period (ibBmaBKeyLeasePeriod). If the lease period is non-zero, the BMA does not allow anyone to read the B_Key until the lease period has expired. If the lease period is zero, the BMA does not allow the B_Key in the node to be read by other BMs.")
ibBmaBKeyLeasePeriod = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBKeyLeasePeriod.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.3; Table 208 BKeyInfo; BKeyInfo:B_KeyLeasePeriod.')
if mibBuilder.loadTexts: ibBmaBKeyLeasePeriod.setStatus('current')
if mibBuilder.loadTexts: ibBmaBKeyLeasePeriod.setDescription('Specifies the timer value of the B_Key lease period (in seconds). The lease period indicates how long the B_Key Protection bit is to remain non-zero after a BMSet(BKeyInfo) MAD that fails the B_Key authentication check is dropped. When the value is 0, the lease period shall never expire (i.e., infinite).')
ibBmaBKeyViolations = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBKeyViolations.setReference('InfiniBand Architecture Release 1.0.a. Vol. 1. Section 16.2.3.3; Table 208 BKeyInfo; BKeyInfo:B_KeyViolations.')
if mibBuilder.loadTexts: ibBmaBKeyViolations.setStatus('current')
if mibBuilder.loadTexts: ibBmaBKeyViolations.setDescription('Counts the number of MAD packets that have been received at this node since power-on or reset that have been dropped due to a failed B_Key check. Note, if this counter is not implemented by the node, the value 65535 shall be returned.')
ibBmaVpd = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3))
ibBmaModuleInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 1))
ibBmaModuleInfoTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1), )
if mibBuilder.loadTexts: ibBmaModuleInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaModuleInfoTable.setDescription('This table contains objects that describe the Module class and the number of InfiniBand and IB-ML links exiting the Module. Non-Modules can also utilize this information to describe their link and IB-ML connection support.')
ibBmaModuleInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaModuleInfoIndex"))
if mibBuilder.loadTexts: ibBmaModuleInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaModuleInfoEntry.setDescription('The column definitions for the Module Info table.')
ibBmaModuleInfoIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ibBmaModuleInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaModuleInfoIndex.setDescription('Index into the Module Info table.')
ibBmaModInfoModGuid = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoModGuid.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoModGuid.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoModGuid.setDescription('The GUID (EUI-64 ID) assigned to this module.')
ibBmaModInfoModType = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notInfiniBandModule", 1), ("infiniBandModule", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoModType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoModType.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoModType.setDescription('InfiniBand module type.')
ibBmaModInfoModClass = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tca", 1), ("hca", 2), ("switch", 3), ("router", 4), ("oneXrepeater", 5), ("fourXrepeater", 6), ("twelveXrepeater", 7), ("other", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoModClass.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoModClass.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoModClass.setDescription('InfiniBand module class.')
ibBmaModInfoNodeCount = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoNodeCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoNodeCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoNodeCount.setDescription('Number of InfiniBand nodes on this module with unique NodeGUIDs.')
ibBmaModInfoLinkCount = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoLinkCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoLinkCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoLinkCount.setDescription('Number of InfiniBand links on this module with unique PortGuids (i.e., NodeGUID plus Port Number).')
ibBmaModInfoBckplaneLinkCnt = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoBckplaneLinkCnt.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoBckplaneLinkCnt.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoBckplaneLinkCnt.setDescription('Number of InfiniBand links exiting this module through its backplane connectors. If the module is not an InfiniBand module, this count is the number of InfiniBand links that exit the module.')
ibBmaModInfoIbmlCount = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoIbmlCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoIbmlCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoIbmlCount.setDescription('Number of IB-ML interfaces on this module.')
ibBmaModInfoBckPlaneIbmlCnt = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoBckPlaneIbmlCnt.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record. Table 105 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoBckPlaneIbmlCnt.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoBckPlaneIbmlCnt.setDescription('Number of IB-MLs exiting this module through its backplane connectors. If the module is not an InfiniBand module, this count is the number of IB-MLs that exit the module.')
ibBmaModInfoModuleSize = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoModuleSize.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoModuleSize.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoModuleSize.setDescription('Eight-byte bit map for the volumetric information for standard form factors (in millimeters).')
ibBmaModInfoFormFactor = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("unspecified", 1), ("nonRemovable", 2), ("standard", 3), ("standardWide", 4), ("tall", 5), ("tallWide", 6), ("pci", 7), ("lowProfilePci", 8), ("compactPci", 9), ("vme", 10), ("internalMezzanineBoard", 11), ("cardEdgeBoard", 12), ("deviceBay", 13), ("otherRemovable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaModInfoFormFactor.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.6 ModuleInfo Record.')
if mibBuilder.loadTexts: ibBmaModInfoFormFactor.setStatus('current')
if mibBuilder.loadTexts: ibBmaModInfoFormFactor.setDescription('The Module Form Factor.')
ibBmaChassisInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 2))
ibBmaChasInfoChassisGuid = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoChassisGuid.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record iand Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoChassisGuid.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoChassisGuid.setDescription('The GUID assigned to this chassis.')
ibBmaChasInfoSlotCount = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoSlotCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoSlotCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoSlotCount.setDescription('Total number of InfiniBand module slots in this chassis.')
ibBmaChasInfoSlotTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3), )
if mibBuilder.loadTexts: ibBmaChasInfoSlotTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoSlotTable.setDescription('This table contains objects that describe the Chassis and slot-specific information for Chassis VPD accessed from an InfiniBand Module or a CME.')
ibBmaChasInfoSlotEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaChasInfoSlotIndex"))
if mibBuilder.loadTexts: ibBmaChasInfoSlotEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoSlotEntry.setDescription('The column definitions for the Chassis Info table.')
ibBmaChasInfoSlotIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibBmaChasInfoSlotIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoSlotIndex.setDescription('Chassis slot index.')
ibBmaChasInfoAssignedSlotNum = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoAssignedSlotNum.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoAssignedSlotNum.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoAssignedSlotNum.setDescription('Slot number assigned to the CME and the Chassis containing the CME. If the slot number is unspecified or occupied by a non-Module, the value returned will be 0xFF(255).')
ibBmaChasInfoSlotConnStatus = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notImplemented", 1), ("oneConnectToStandardSlot", 2), ("oneConnectToTallSlot", 3), ("twoConnectToTallSlot", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoSlotConnStatus.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoSlotConnStatus.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoSlotConnStatus.setDescription('Chassis slot connector status.')
ibBmaChasInfoCmeAccess = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("accessViaPriPort", 2), ("notAccessible", 3), ("reserved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoCmeAccess.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoCmeAccess.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoCmeAccess.setDescription('Chassis CME access.')
ibBmaChasInfoProxyAccess = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noProxyAccess", 1), ("hasProxyAccess", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoProxyAccess.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoProxyAccess.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoProxyAccess.setDescription('Chassis proxy access.')
ibBmaChasInfoLockDrivesCtr = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("lockDrivesCmeCtr", 2), ("lockReleaseForCmeCtr", 3), ("reserved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoLockDrivesCtr.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoLockDrivesCtr.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoLockDrivesCtr.setDescription('Indicates whether the lock (if present) keeps CME_CTR deasserted until the lock is released. The value lockDrivesCmeCtr(2) is used if the CME uses only the state of the lock to drive the CME_CTR. The value of lockReleaseFromCmeCtr(3) indicates that the CME_CTR will not be asserted unless the lock is released. Also, the CME has other criteria that can also cause the CME_CTR to be kept deasserted.')
ibBmaChasInfoMechLockPresent = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("hasLock", 2), ("noLock", 3), ("reserved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaChasInfoMechLockPresent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.7 ChassisInfo Record and Table 106.')
if mibBuilder.loadTexts: ibBmaChasInfoMechLockPresent.setStatus('current')
if mibBuilder.loadTexts: ibBmaChasInfoMechLockPresent.setDescription('Indicates whether there is a mechnical lock associated with this slot. A mechnical lock physically prevents the removal of the Module from the slot. The implementation can be mechnical or electro-mechanical.')
ibBmaFruInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 3))
ibBmaFruInfoTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1), )
if mibBuilder.loadTexts: ibBmaFruInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoTable.setDescription('This table contains objects that describe the FRU records present in the managed device.')
ibBmaFruInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaFruInfoIndex"))
if mibBuilder.loadTexts: ibBmaFruInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoEntry.setDescription('The column definitions for the FRU Info table.')
ibBmaFruInfoIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibBmaFruInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoIndex.setDescription('FRU Info index.')
ibBmaFruInfoType = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unspecified", 1), ("infinibandModule", 2), ("infinibandModBackplane", 3), ("infinibandSwitchMod", 4), ("mainChassis", 5), ("platformSystem", 6), ("standaloneProduct", 7), ("boardOrCard", 8), ("powerConverterSuppyMod", 9), ("otherModAssembly", 10), ("coolingModule", 11), ("subChassis", 12), ("processorModule", 13), ("memoryModule", 14), ("memoryCard", 15), ("oem", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoType.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoType.setDescription('The Field Replaceable Unit (FRU) type.')
ibBmaFruInfoGuidType = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("guid64", 2), ("guid48", 3), ("guid16", 4), ("guid8", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoGuidType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoGuidType.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoGuidType.setDescription('The FRU GUID type.')
ibBmaFruInfoGuidValue = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoGuidValue.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoGuidValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoGuidValue.setDescription('The GUID assigned to this FRU. Needs to hold the longest possible GUID type (guid16(4)).')
ibBmaFruInfoSerialNumber = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoSerialNumber.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoSerialNumber.setDescription('The FRU serial number.')
ibBmaFruInfoPartNumber = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoPartNumber.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoPartNumber.setDescription('The FRU Part Number.')
ibBmaFruInfoModelName = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoModelName.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoModelName.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoModelName.setDescription('The model name is assigned by the FRU manufacturer.')
ibBmaFruInfoVersion = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoVersion.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoVersion.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoVersion.setDescription('The FRU version is assigned by the FRU manufacturer.')
ibBmaFruInfoManufacturerName = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerName.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerName.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerName.setDescription('The FRU Manufacturer Name.')
ibBmaFruInfoProductName = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoProductName.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoProductName.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoProductName.setDescription('The FRU Product name.')
ibBmaFruInfoManufacturerID = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerID.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerID.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoManufacturerID.setDescription('The FRU Manufacturer ID.')
ibBmaFruInfoManDateAndTime = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 3, 1, 1, 12), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaFruInfoManDateAndTime.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.8 FRUInfo Record. Table 107 FRUInfo Record.')
if mibBuilder.loadTexts: ibBmaFruInfoManDateAndTime.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoManDateAndTime.setDescription('Manufacture date and time.')
ibBmaPortConnectInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 4))
ibBmaPortConNumConnection = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPortConNumConnection.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.9 PortConnectionInfo Record. Table 108 PortConnectionInfoRecord.')
if mibBuilder.loadTexts: ibBmaPortConNumConnection.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConNumConnection.setDescription('Number of port connections.')
ibBmaPortConnectTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2), )
if mibBuilder.loadTexts: ibBmaPortConnectTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConnectTable.setDescription('This table contains objects that describe the Port Connections present in the managed device.')
ibBmaPortConnectEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaPortConnectIndex"))
if mibBuilder.loadTexts: ibBmaPortConnectEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConnectEntry.setDescription('The column definitions for the Port Connection table.')
ibBmaPortConnectIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibBmaPortConnectIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConnectIndex.setDescription('Index for the Port Connection table.')
ibBmaPortConInternalCon = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("terminateWithoutGoing", 2), ("terminateAfterGoing", 3), ("noInternelConnection", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPortConInternalCon.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.9 PortConnectionInfo Record. Table 108 PortConnectionInfoRecord.')
if mibBuilder.loadTexts: ibBmaPortConInternalCon.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConInternalCon.setDescription('Internal connection type.')
ibBmaPortConMediaClass = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unspecified", 1), ("copper", 2), ("fiber", 3), ("pcb", 4), ("repeaterThenCopper", 5), ("repeaterThenFiber", 6), ("repeaterThenNode", 7), ("reserved", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPortConMediaClass.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.9 PortConnectionInfo Record. Table 108 PortConnectionInfoRecord.')
if mibBuilder.loadTexts: ibBmaPortConMediaClass.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConMediaClass.setDescription('Connection Media Class.')
ibBmaPortConConClass = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unspecified", 1), ("nonSpecifyRemovable", 2), ("backplaneSide", 3), ("moduleSide", 4), ("nonRemovable", 5), ("noInfo", 6), ("reserved", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPortConConClass.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.9 PortConnectionInfo Record. Table 108 PortConnectionInfoRecord.')
if mibBuilder.loadTexts: ibBmaPortConConClass.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConConClass.setDescription('Connection Class.')
ibBmaModPowerInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 5))
ibBmaOperThermalPower = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 131071))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOperThermalPower.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaOperThermalPower.setStatus('current')
if mibBuilder.loadTexts: ibBmaOperThermalPower.setDescription('Maximum amount of power dissipated under normal operation including any vendor supplied exerciser over any sliding 60 second window expressed in mW. If this value is unspecified, a 0 should be returned.')
ibBmaOperCurrent = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOperCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaOperCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaOperCurrent.setDescription('Maximum amount of current drawn under normal operation including any vendor supplied exerciser across the range of VBulk (expressed in mA). If this value is unspecified, a 0 should be returned.')
ibBmaIdleCurrent = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIdleCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaIdleCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaIdleCurrent.setDescription('Amount of current that a fully initialized device draws when waiting for functional requests (in mA). If this value is unspecified, a 0 will be returned.')
ibBmaInitCurrent = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaInitCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaInitCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaInitCurrent.setDescription('Amount of current drawn during Modules Built-in self test or self-initialization execution across the range of VBulk (in mA). If this value is unspecified, a 0 will be returned.')
ibBmaInitTime = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaInitTime.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaInitTime.setStatus('current')
if mibBuilder.loadTexts: ibBmaInitTime.setDescription("Amount of time (in 10's of ms) from the end of Module Reset to the end of BIST and/or module self-initialization complete under non-fault conditions. The module must be ready for normal operation at the conclusion of this time, excluding any external software driven initialization. If the value is unspecified, a 0 will be returned.")
ibBmaIsMStandbySupported = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsMStandbySupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaIsMStandbySupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsMStandbySupported.setDescription('Capability flag to indicate if MStandby is supported.')
ibBmaIsPowerMgmtSupported = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsPowerMgmtSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaIsPowerMgmtSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsPowerMgmtSupported.setDescription('Capability flag to indicate if power management is supported.')
ibBmaIsUSleepSupported = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsUSleepSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaIsUSleepSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsUSleepSupported.setDescription('Capability flag to indicate if USleep is supported.')
ibBmaIsUStandbySupported = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaIsUStandbySupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaIsUStandbySupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaIsUStandbySupported.setDescription('Capability flag to indicate if UStandby is supported.')
ibBmaPowerClass = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("powerClass1", 2), ("powerClass2", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPowerClass.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaPowerClass.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerClass.setDescription('Power class.')
ibBmaRedundantPower = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 1), ("noRedundancy", 2), ("redundancy", 3), ("reserved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaRedundantPower.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.10 ModulePowerInfo Record. Table 109 ModulePowerInfoRecord.')
if mibBuilder.loadTexts: ibBmaRedundantPower.setStatus('current')
if mibBuilder.loadTexts: ibBmaRedundantPower.setDescription('Redundant power converter capability.')
ibBmaPowerMgmtInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 6))
ibBmaPowerMgmtIocCount = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPowerMgmtIocCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPowerMgmtIocCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerMgmtIocCount.setDescription('Number of IOC capabilities.')
ibBmaPowerMgmtIocTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2), )
if mibBuilder.loadTexts: ibBmaPowerMgmtIocTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerMgmtIocTable.setDescription('This table contains objects that describe the Power Management for each IOC.')
ibBmaPowerMgmtIocEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaPowerMgmtIocIndex"))
if mibBuilder.loadTexts: ibBmaPowerMgmtIocEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerMgmtIocEntry.setDescription('The column definitions for the Power Managment IOC table.')
ibBmaPowerMgmtIocIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibBmaPowerMgmtIocIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerMgmtIocIndex.setDescription('Index for the Power Management IOC table.')
ibBmaPMIsIDozeSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMIsIDozeSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMIsIDozeSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMIsIDozeSupported.setDescription('Flag for Is I Doze supported.')
ibBmaPMIsINapSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMIsINapSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMIsINapSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMIsINapSupported.setDescription('Flag for Is I Nap supported.')
ibBmaPMIsISleepSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMIsISleepSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMIsISleepSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMIsISleepSupported.setDescription('Flag for Is I Sleep supported.')
ibBmaPMIsIStandbySupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMIsIStandbySupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMIsIStandbySupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMIsIStandbySupported.setDescription('Flag for Is I Standby supported.')
ibBmaPMWREIsIDozeSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMWREIsIDozeSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMWREIsIDozeSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMWREIsIDozeSupported.setDescription('Flag for Is WRE I Doze supported.')
ibBmaPMWREIsINapSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMWREIsINapSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMWREIsINapSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMWREIsINapSupported.setDescription('Flag for Is WRE I Nap supported.')
ibBmaPMWREIsISleepSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMWREIsISleepSupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMWREIsISleepSupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMWREIsISleepSupported.setDescription('Flag for Is WRE I Sleep supported.')
ibBmaPMWREIsIStandbySupported = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPMWREIsIStandbySupported.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPMWREIsIStandbySupported.setStatus('current')
if mibBuilder.loadTexts: ibBmaPMWREIsIStandbySupported.setDescription('Flag for Is WRE I Standby supported.')
ibBmaPwrMgtIDozeCurrent = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPwrMgtIDozeCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPwrMgtIDozeCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaPwrMgtIDozeCurrent.setDescription('The amount of total current drawn from the Bulk Power while in I-Doze PM state. The range is from 0 to 16,384 milliAmps.')
ibBmaPwrMgtINapCurrent = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPwrMgtINapCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPwrMgtINapCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaPwrMgtINapCurrent.setDescription('The amount of total current drawn from the Bulk Power while in I-Nap PM state. The range is from 0 to 16,384 milliAmps.')
ibBmaPwrMgtISleepCurrent = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPwrMgtISleepCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPwrMgtISleepCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaPwrMgtISleepCurrent.setDescription('The amount of total current drawn from the Bulk Power while in I-Sleep PM state. The range is from 0 to 16,384 milliAmps.')
ibBmaPwrMgtIStandbyCurrent = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 6, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaPwrMgtIStandbyCurrent.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.11 IOCOMInfo Record. Table 110 IOCPMInfo Record.')
if mibBuilder.loadTexts: ibBmaPwrMgtIStandbyCurrent.setStatus('current')
if mibBuilder.loadTexts: ibBmaPwrMgtIStandbyCurrent.setDescription('The amount of total current drawn from the Auxilliary Power while in I-Standby PM state. The Bulk Power drawn is defined to be 0 amps. The range is from 0 to 16,384 milliAmps.')
ibBmaCmeInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 7))
ibBmaCmeGuidType = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("guid64", 2), ("guid48", 3), ("guid16", 4), ("guid8", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaCmeGuidType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.12; Table 111 CmeInfo Record.')
if mibBuilder.loadTexts: ibBmaCmeGuidType.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeGuidType.setDescription('The CME GUID type.')
ibBmaCmeGuidValue = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 7, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaCmeGuidValue.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.12; Table 111 CmeInfo Record.')
if mibBuilder.loadTexts: ibBmaCmeGuidValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeGuidValue.setDescription('The GUID assigned to this CME. Needs to hold the longest possible GUID type (guid16(4)).')
ibBmaCmeFirmMinorRev = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 7, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaCmeFirmMinorRev.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.12; Table 111 CmeInfo Record.')
if mibBuilder.loadTexts: ibBmaCmeFirmMinorRev.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeFirmMinorRev.setDescription('The minor revision of the CME firmware.')
ibBmaCmeFirmMajorRev = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 7, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaCmeFirmMajorRev.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.12; Table 111 CmeInfo Record.')
if mibBuilder.loadTexts: ibBmaCmeFirmMajorRev.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeFirmMajorRev.setDescription('The major revision of the CME firmware.')
ibBmaCmeSlotNumbers = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 7, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaCmeSlotNumbers.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.12; Table 111 CmeInfo Record.')
if mibBuilder.loadTexts: ibBmaCmeSlotNumbers.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeSlotNumbers.setDescription('A 256 bit mask representing IB ports for which the CME provides IB-ML access. The mask allows slot numbers to be non-sequential. Slot numbers must be in the range 1 to 254. 0 is assigned to the CME and its containing Chassis via CME.')
ibBmaOemInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 8))
ibBmaOemTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1), )
if mibBuilder.loadTexts: ibBmaOemTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemTable.setDescription('This table contains objects that describe the OEM entries.')
ibBmaOemEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaOemIndex"))
if mibBuilder.loadTexts: ibBmaOemEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemEntry.setDescription('The column definitions for the OEM table.')
ibBmaOemIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibBmaOemIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemIndex.setDescription('Index for the OEM table.')
ibBmaOemIdType = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("companyId", 2), ("enterpriseNumBased", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOemIdType.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemIdType.setDescription('The OEM ID type.')
ibBmaOemIdValue = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOemIdValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemIdValue.setDescription('The OEM ID value.')
ibBmaOemDataLength = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOemDataLength.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemDataLength.setDescription('The OEM Data field length.')
ibBmaOemDataBuf = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 8, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaOemDataBuf.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemDataBuf.setDescription('The OEM Data buffer.')
ibBmaBuddyInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 9))
ibBmaBuddyCount = MibScalar((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBuddyCount.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.14; Table 113 BuddyInfo Record.')
if mibBuilder.loadTexts: ibBmaBuddyCount.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyCount.setDescription('The Buddy count. This is the number of InfiniBand nodes, excluding this node, that belong to the same enclosure as the node reporting this record. If no other node belongs to the same enclosure, the value will be 0 and there will be no entries in the ibBmaBuddyTable.')
ibBmaBuddyTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 2), )
if mibBuilder.loadTexts: ibBmaBuddyTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyTable.setDescription('A table containing BMA Buddy Record information.')
ibBmaBuddyEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 2, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaBuddyIndex"))
if mibBuilder.loadTexts: ibBmaBuddyEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyEntry.setDescription('A conceptual row of the ibBmaBuddyTable containing information about a particular Buddy table entry.')
ibBmaBuddyIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ibBmaBuddyIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyIndex.setDescription('Index that identifies this Buddy table entry.')
ibBmaBuddyGuidType = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("guid64", 2), ("guid48", 3), ("guid16", 4), ("guid8", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBuddyGuidType.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.14; Table 113 BuddyInfo Record.')
if mibBuilder.loadTexts: ibBmaBuddyGuidType.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyGuidType.setDescription('The Buddy node GUID type.')
ibBmaBuddyGuidValue = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 9, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaBuddyGuidValue.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.14; Table 113 BuddyInfo Record.')
if mibBuilder.loadTexts: ibBmaBuddyGuidValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyGuidValue.setDescription('The GUID assigned to this node. Needs to hold the longest possible GUID type (guid16(4)).')
ibBmaAssetTagInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 1, 3, 10))
ibBmaAssetTagTable = MibTable((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1), )
if mibBuilder.loadTexts: ibBmaAssetTagTable.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagTable.setDescription('A table containing BMA Asset Tag information.')
ibBmaAssetTagEntry = MibTableRow((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1, 1), ).setIndexNames((0, "BMA-MIB", "ibBmaAssetTagIndex"))
if mibBuilder.loadTexts: ibBmaAssetTagEntry.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagEntry.setDescription('A conceptual row of the ibBmaAssetTagTable containing information about a particular Asset Tag entry.')
ibBmaAssetTagIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ibBmaAssetTagIndex.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagIndex.setDescription('Index that identifies this Asset Tag table entry.')
ibBmaAssetTagFruHandle = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaAssetTagFruHandle.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.15; Table 114 AssetTagRecord.')
if mibBuilder.loadTexts: ibBmaAssetTagFruHandle.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagFruHandle.setDescription('The FRU handle.')
ibBmaAssetTagLength = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaAssetTagLength.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.15; Table 114 AssetTagRecord.')
if mibBuilder.loadTexts: ibBmaAssetTagLength.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagLength.setDescription('The length of the ibBmaAssetTagValue object.')
ibBmaAssetTagValue = MibTableColumn((1, 3, 6, 1, 3, 117, 5, 1, 3, 10, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibBmaAssetTagValue.setReference('InfiniBand Architecture Release 1.0.a. Vol. 2. Section 13.7.15; Table 114 AssetTagRecord.')
if mibBuilder.loadTexts: ibBmaAssetTagValue.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagValue.setDescription('The Asset Tag.')
ibBmaCompliances = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 2, 1))
ibBmaGroups = MibIdentifier((1, 3, 6, 1, 3, 117, 5, 2, 2))
ibBmaBasicNodeCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 5, 2, 1, 1)).setObjects(("BMA-MIB", "ibBmaBmuInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaBasicNodeCompliance = ibBmaBasicNodeCompliance.setStatus('current')
if mibBuilder.loadTexts: ibBmaBasicNodeCompliance.setDescription('The basic node implementation requirements for agents that support the IPOIB BMA MIB.')
ibBmaFullNodeCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 5, 2, 1, 2)).setObjects(("BMA-MIB", "ibBmaBmuInfoGroup"), ("BMA-MIB", "ibBmaBKeyInfoGroup"), ("BMA-MIB", "ibBmaModuleInfoGroup"), ("BMA-MIB", "ibBmaChassisInfoGroup"), ("BMA-MIB", "ibBmaFruInfoGroup"), ("BMA-MIB", "ibBmaPortConnectInfoGroup"), ("BMA-MIB", "ibBmaModPowerInfoGroup"), ("BMA-MIB", "ibBmaPowerMgmtInfoGroup"), ("BMA-MIB", "ibBmaCmeInfoGroup"), ("BMA-MIB", "ibBmaOemInfoGroup"), ("BMA-MIB", "ibBmaBuddyInfoGroup"), ("BMA-MIB", "ibBmaAssetTagInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaFullNodeCompliance = ibBmaFullNodeCompliance.setStatus('current')
if mibBuilder.loadTexts: ibBmaFullNodeCompliance.setDescription('The full node implementation requirements for agents that support the IPOIB BMA MIB.')
ibBmaBmuInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 1)).setObjects(("BMA-MIB", "ibBmaBaseboardManagedUnitType"), ("BMA-MIB", "ibBmaIsIBMLSupported"), ("BMA-MIB", "ibBmaIBMLImplementation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaBmuInfoGroup = ibBmaBmuInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaBmuInfoGroup.setDescription('The ibBmaBmuInfoGroup defines the MIB objects that describe information about the Baseboard Management Unit (BMU).')
ibBmaBKeyInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 2)).setObjects(("BMA-MIB", "ibBmaIsBKeyNVRAM"), ("BMA-MIB", "ibBmaBKeyValue"), ("BMA-MIB", "ibBmaBKeyProtectBit"), ("BMA-MIB", "ibBmaBKeyLeasePeriod"), ("BMA-MIB", "ibBmaBKeyViolations"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaBKeyInfoGroup = ibBmaBKeyInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaBKeyInfoGroup.setDescription('The ibBmaBKeyInfo Group defines the MIB objects that describe information about the Baseboard Management keys (B_Keys).')
ibBmaModuleInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 3)).setObjects(("BMA-MIB", "ibBmaModInfoModGuid"), ("BMA-MIB", "ibBmaModInfoModType"), ("BMA-MIB", "ibBmaModInfoModClass"), ("BMA-MIB", "ibBmaModInfoNodeCount"), ("BMA-MIB", "ibBmaModInfoLinkCount"), ("BMA-MIB", "ibBmaModInfoBckplaneLinkCnt"), ("BMA-MIB", "ibBmaModInfoIbmlCount"), ("BMA-MIB", "ibBmaModInfoBckPlaneIbmlCnt"), ("BMA-MIB", "ibBmaModInfoModuleSize"), ("BMA-MIB", "ibBmaModInfoFormFactor"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaModuleInfoGroup = ibBmaModuleInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaModuleInfoGroup.setDescription('The ibBmaModuleInfo Group defines the MIB objects that describe information about the module.')
ibBmaChassisInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 4)).setObjects(("BMA-MIB", "ibBmaChasInfoChassisGuid"), ("BMA-MIB", "ibBmaChasInfoSlotCount"), ("BMA-MIB", "ibBmaChasInfoAssignedSlotNum"), ("BMA-MIB", "ibBmaChasInfoSlotConnStatus"), ("BMA-MIB", "ibBmaChasInfoCmeAccess"), ("BMA-MIB", "ibBmaChasInfoProxyAccess"), ("BMA-MIB", "ibBmaChasInfoLockDrivesCtr"), ("BMA-MIB", "ibBmaChasInfoMechLockPresent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaChassisInfoGroup = ibBmaChassisInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaChassisInfoGroup.setDescription('The ibBmaChassisInfo Group defines the MIB objects that describe information about a managed chassis.')
ibBmaFruInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 5)).setObjects(("BMA-MIB", "ibBmaFruInfoType"), ("BMA-MIB", "ibBmaFruInfoGuidType"), ("BMA-MIB", "ibBmaFruInfoGuidValue"), ("BMA-MIB", "ibBmaFruInfoSerialNumber"), ("BMA-MIB", "ibBmaFruInfoPartNumber"), ("BMA-MIB", "ibBmaFruInfoModelName"), ("BMA-MIB", "ibBmaFruInfoVersion"), ("BMA-MIB", "ibBmaFruInfoManufacturerName"), ("BMA-MIB", "ibBmaFruInfoProductName"), ("BMA-MIB", "ibBmaFruInfoManufacturerID"), ("BMA-MIB", "ibBmaFruInfoManDateAndTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaFruInfoGroup = ibBmaFruInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaFruInfoGroup.setDescription('The ibBmaFruInfo Group defines the MIB objects that describe information about the Fru attributes.')
ibBmaPortConnectInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 6)).setObjects(("BMA-MIB", "ibBmaPortConNumConnection"), ("BMA-MIB", "ibBmaPortConInternalCon"), ("BMA-MIB", "ibBmaPortConMediaClass"), ("BMA-MIB", "ibBmaPortConConClass"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaPortConnectInfoGroup = ibBmaPortConnectInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaPortConnectInfoGroup.setDescription('The ibBmaPortConnectInfo Group defines the MIB objects that describe information about the port connections.')
ibBmaModPowerInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 7)).setObjects(("BMA-MIB", "ibBmaOperThermalPower"), ("BMA-MIB", "ibBmaOperCurrent"), ("BMA-MIB", "ibBmaIdleCurrent"), ("BMA-MIB", "ibBmaInitCurrent"), ("BMA-MIB", "ibBmaInitTime"), ("BMA-MIB", "ibBmaIsMStandbySupported"), ("BMA-MIB", "ibBmaIsPowerMgmtSupported"), ("BMA-MIB", "ibBmaIsUSleepSupported"), ("BMA-MIB", "ibBmaIsUStandbySupported"), ("BMA-MIB", "ibBmaPowerClass"), ("BMA-MIB", "ibBmaRedundantPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaModPowerInfoGroup = ibBmaModPowerInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaModPowerInfoGroup.setDescription('The ibBmaModPowerInfo Group defines the MIB objects that describe information about the power attributes of the module.')
ibBmaPowerMgmtInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 8)).setObjects(("BMA-MIB", "ibBmaPowerMgmtIocCount"), ("BMA-MIB", "ibBmaPMIsIDozeSupported"), ("BMA-MIB", "ibBmaPMIsINapSupported"), ("BMA-MIB", "ibBmaPMIsISleepSupported"), ("BMA-MIB", "ibBmaPMIsIStandbySupported"), ("BMA-MIB", "ibBmaPMWREIsIDozeSupported"), ("BMA-MIB", "ibBmaPMWREIsINapSupported"), ("BMA-MIB", "ibBmaPMWREIsISleepSupported"), ("BMA-MIB", "ibBmaPMWREIsIStandbySupported"), ("BMA-MIB", "ibBmaPwrMgtIDozeCurrent"), ("BMA-MIB", "ibBmaPwrMgtINapCurrent"), ("BMA-MIB", "ibBmaPwrMgtISleepCurrent"), ("BMA-MIB", "ibBmaPwrMgtIStandbyCurrent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaPowerMgmtInfoGroup = ibBmaPowerMgmtInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaPowerMgmtInfoGroup.setDescription('The ibBmaPowerMgmtInfo Group defines the MIB objects that describe information about power management.')
ibBmaCmeInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 9)).setObjects(("BMA-MIB", "ibBmaCmeGuidType"), ("BMA-MIB", "ibBmaCmeGuidValue"), ("BMA-MIB", "ibBmaCmeFirmMinorRev"), ("BMA-MIB", "ibBmaCmeFirmMajorRev"), ("BMA-MIB", "ibBmaCmeSlotNumbers"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaCmeInfoGroup = ibBmaCmeInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaCmeInfoGroup.setDescription('The ibBmaCmeInfo Group defines the MIB objects that describe information about the CME.')
ibBmaOemInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 10)).setObjects(("BMA-MIB", "ibBmaOemIdType"), ("BMA-MIB", "ibBmaOemIdValue"), ("BMA-MIB", "ibBmaOemDataLength"), ("BMA-MIB", "ibBmaOemDataBuf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaOemInfoGroup = ibBmaOemInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaOemInfoGroup.setDescription('The ibBmaOemInfo Group defines the MIB objects that describe information about OEM data.')
ibBmaBuddyInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 11)).setObjects(("BMA-MIB", "ibBmaBuddyCount"), ("BMA-MIB", "ibBmaBuddyGuidType"), ("BMA-MIB", "ibBmaBuddyGuidValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaBuddyInfoGroup = ibBmaBuddyInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaBuddyInfoGroup.setDescription('The ibBmaBuddyInfo Group defines the MIB objects that describe information about the Buddy Info.')
ibBmaAssetTagInfoGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 5, 2, 2, 12)).setObjects(("BMA-MIB", "ibBmaAssetTagFruHandle"), ("BMA-MIB", "ibBmaAssetTagLength"), ("BMA-MIB", "ibBmaAssetTagValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibBmaAssetTagInfoGroup = ibBmaAssetTagInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ibBmaAssetTagInfoGroup.setDescription('The ibBmaAssetTagInfo Group defines the MIB objects that describe information about the asset tags.')
mibBuilder.exportSymbols("BMA-MIB", ibBmaModInfoModuleSize=ibBmaModInfoModuleSize, ibBmaBuddyTable=ibBmaBuddyTable, ibBmaChasInfoMechLockPresent=ibBmaChasInfoMechLockPresent, ibBmaBmuInfoGroup=ibBmaBmuInfoGroup, ibBmaBKeyViolations=ibBmaBKeyViolations, ibBmaConformance=ibBmaConformance, ibBmaModuleInfoEntry=ibBmaModuleInfoEntry, ibBmaOperThermalPower=ibBmaOperThermalPower, ibBmaPMWREIsINapSupported=ibBmaPMWREIsINapSupported, ibBmaFullNodeCompliance=ibBmaFullNodeCompliance, ibBmaFruInfoProductName=ibBmaFruInfoProductName, ibBmaChasInfoLockDrivesCtr=ibBmaChasInfoLockDrivesCtr, ibBmaBuddyInfoGroup=ibBmaBuddyInfoGroup, ibBmaOemIndex=ibBmaOemIndex, ibBmaChasInfoSlotIndex=ibBmaChasInfoSlotIndex, ibBmaChasInfoSlotTable=ibBmaChasInfoSlotTable, ibBmaCmeInfoGroup=ibBmaCmeInfoGroup, ibBmaChassisInfo=ibBmaChassisInfo, ibBmaFruInfoManDateAndTime=ibBmaFruInfoManDateAndTime, ibBmaAssetTagFruHandle=ibBmaAssetTagFruHandle, ibBmaPowerMgmtIocEntry=ibBmaPowerMgmtIocEntry, ibBmaBaseboardManagedUnitType=ibBmaBaseboardManagedUnitType, ibBmaFruInfoPartNumber=ibBmaFruInfoPartNumber, ibBmaFruInfoEntry=ibBmaFruInfoEntry, ibBmaBKeyProtectBit=ibBmaBKeyProtectBit, ibBmaIsBKeyNVRAM=ibBmaIsBKeyNVRAM, ibBmaPwrMgtIStandbyCurrent=ibBmaPwrMgtIStandbyCurrent, ibBmaPMIsIDozeSupported=ibBmaPMIsIDozeSupported, ibBmaCmeSlotNumbers=ibBmaCmeSlotNumbers, ibBmaIsIBMLSupported=ibBmaIsIBMLSupported, ibBmaFruInfoVersion=ibBmaFruInfoVersion, ibBmaPwrMgtISleepCurrent=ibBmaPwrMgtISleepCurrent, ibBmaFruInfoModelName=ibBmaFruInfoModelName, ibBmaCmeFirmMinorRev=ibBmaCmeFirmMinorRev, ibBmaFruInfoManufacturerID=ibBmaFruInfoManufacturerID, ibBmaModuleInfoIndex=ibBmaModuleInfoIndex, ibBmaFruInfo=ibBmaFruInfo, ibBmaFruInfoTable=ibBmaFruInfoTable, ibBmaIsUSleepSupported=ibBmaIsUSleepSupported, ibBmaOemDataBuf=ibBmaOemDataBuf, ibBmaOemIdType=ibBmaOemIdType, ibBmaChasInfoChassisGuid=ibBmaChasInfoChassisGuid, ibBmaPortConnectEntry=ibBmaPortConnectEntry, ibBmaModPowerInfo=ibBmaModPowerInfo, ibBmaFruInfoSerialNumber=ibBmaFruInfoSerialNumber, ibBmaAssetTagEntry=ibBmaAssetTagEntry, ibBmaModInfoFormFactor=ibBmaModInfoFormFactor, ibBmaPowerMgmtIocCount=ibBmaPowerMgmtIocCount, ibBmaPortConMediaClass=ibBmaPortConMediaClass, ibBmaPMIsISleepSupported=ibBmaPMIsISleepSupported, ibBmaOemInfo=ibBmaOemInfo, ibBmaBuddyIndex=ibBmaBuddyIndex, ibBmaModuleInfoGroup=ibBmaModuleInfoGroup, ibBmaBuddyCount=ibBmaBuddyCount, ibBmaPortConConClass=ibBmaPortConConClass, ibBmaIdleCurrent=ibBmaIdleCurrent, ibBmaChasInfoSlotEntry=ibBmaChasInfoSlotEntry, ibBmaInitTime=ibBmaInitTime, ibBmaModuleInfoTable=ibBmaModuleInfoTable, ibBmaPortConnectInfo=ibBmaPortConnectInfo, ibBmaMIB=ibBmaMIB, ibBmaCmeFirmMajorRev=ibBmaCmeFirmMajorRev, ibBmaModInfoLinkCount=ibBmaModInfoLinkCount, ibBmaPortConnectInfoGroup=ibBmaPortConnectInfoGroup, ibBmaFruInfoIndex=ibBmaFruInfoIndex, ibBmaModInfoNodeCount=ibBmaModInfoNodeCount, ibBmaPMWREIsIStandbySupported=ibBmaPMWREIsIStandbySupported, ibBmaGroups=ibBmaGroups, ibBmaPowerMgmtIocIndex=ibBmaPowerMgmtIocIndex, ibBmaAssetTagTable=ibBmaAssetTagTable, ibBmaFruInfoGroup=ibBmaFruInfoGroup, ibBmaPwrMgtIDozeCurrent=ibBmaPwrMgtIDozeCurrent, ibBmaPortConInternalCon=ibBmaPortConInternalCon, ibBmaBuddyInfo=ibBmaBuddyInfo, ibBmaPwrMgtINapCurrent=ibBmaPwrMgtINapCurrent, ibBmaAssetTagValue=ibBmaAssetTagValue, ibBmaPMIsINapSupported=ibBmaPMIsINapSupported, ibBmaFruInfoManufacturerName=ibBmaFruInfoManufacturerName, ibBmaPowerClass=ibBmaPowerClass, ibBmaModInfoModClass=ibBmaModInfoModClass, ibBmaBasicNodeCompliance=ibBmaBasicNodeCompliance, ibBmaAssetTagIndex=ibBmaAssetTagIndex, ibBmaCompliances=ibBmaCompliances, ibBmaFruInfoType=ibBmaFruInfoType, ibBmaOemTable=ibBmaOemTable, ibBmaCmeInfo=ibBmaCmeInfo, ibBmaModInfoIbmlCount=ibBmaModInfoIbmlCount, ibBmaObjects=ibBmaObjects, ibBmaOemIdValue=ibBmaOemIdValue, ibBmaChassisInfoGroup=ibBmaChassisInfoGroup, ibBmaBKeyInfoGroup=ibBmaBKeyInfoGroup, ibBmaModInfoModGuid=ibBmaModInfoModGuid, ibBmaCmeGuidType=ibBmaCmeGuidType, ibBmaCmeGuidValue=ibBmaCmeGuidValue, ibBmaPowerMgmtInfo=ibBmaPowerMgmtInfo, ibBmaModuleInfo=ibBmaModuleInfo, ibBmaBuddyEntry=ibBmaBuddyEntry, ibBmaPMWREIsISleepSupported=ibBmaPMWREIsISleepSupported, ibBmaOperCurrent=ibBmaOperCurrent, ibBmaPowerMgmtIocTable=ibBmaPowerMgmtIocTable, ibBmaBuddyGuidValue=ibBmaBuddyGuidValue, PYSNMP_MODULE_ID=ibBmaMIB, ibBmaBKeyLeasePeriod=ibBmaBKeyLeasePeriod, ibBmaInitCurrent=ibBmaInitCurrent, ibBmaModInfoBckPlaneIbmlCnt=ibBmaModInfoBckPlaneIbmlCnt, ibBmaPowerMgmtInfoGroup=ibBmaPowerMgmtInfoGroup, ibBmaModPowerInfoGroup=ibBmaModPowerInfoGroup, ibBmaChasInfoSlotCount=ibBmaChasInfoSlotCount, ibBmaChasInfoCmeAccess=ibBmaChasInfoCmeAccess, ibBmaIsUStandbySupported=ibBmaIsUStandbySupported, ibBmaBKeyValue=ibBmaBKeyValue, ibBmaOemInfoGroup=ibBmaOemInfoGroup, ibBmaPortConnectTable=ibBmaPortConnectTable, ibBmaRedundantPower=ibBmaRedundantPower, ibBmaPMIsIStandbySupported=ibBmaPMIsIStandbySupported, ibBmaChasInfoProxyAccess=ibBmaChasInfoProxyAccess, ibBmaIsMStandbySupported=ibBmaIsMStandbySupported, ibBmaIsPowerMgmtSupported=ibBmaIsPowerMgmtSupported, ibBmaBuddyGuidType=ibBmaBuddyGuidType, ibBmaFruInfoGuidValue=ibBmaFruInfoGuidValue, ibBmaModInfoModType=ibBmaModInfoModType, ibBmaFruInfoGuidType=ibBmaFruInfoGuidType, ibBmaPortConNumConnection=ibBmaPortConNumConnection, ibBmaVpd=ibBmaVpd, ibBmaOemEntry=ibBmaOemEntry, ibBmaPMWREIsIDozeSupported=ibBmaPMWREIsIDozeSupported, ibBmaChasInfoAssignedSlotNum=ibBmaChasInfoAssignedSlotNum, ibBmaAssetTagInfo=ibBmaAssetTagInfo, ibBmaChasInfoSlotConnStatus=ibBmaChasInfoSlotConnStatus, ibBmaBKeyInfo=ibBmaBKeyInfo, ibBmaAssetTagLength=ibBmaAssetTagLength, ibBmaIBMLImplementation=ibBmaIBMLImplementation, ibBmaOemDataLength=ibBmaOemDataLength, ibBmaPortConnectIndex=ibBmaPortConnectIndex, ibBmaBmuInfo=ibBmaBmuInfo, ibBmaAssetTagInfoGroup=ibBmaAssetTagInfoGroup, ibBmaModInfoBckplaneLinkCnt=ibBmaModInfoBckplaneLinkCnt)

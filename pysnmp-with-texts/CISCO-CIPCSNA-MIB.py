#
# PySNMP MIB module CISCO-CIPCSNA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CIPCSNA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:53:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
cipCardSubChannelIndex, cipCardEntryIndex, cipCardDtrBrdIndex = mibBuilder.importSymbols("CISCO-CHANNEL-MIB", "cipCardSubChannelIndex", "cipCardEntryIndex", "cipCardDtrBrdIndex")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
llcSapNumber, llcPortVirtualIndex = mibBuilder.importSymbols("CISCO-SNA-LLC-MIB", "llcSapNumber", "llcPortVirtualIndex")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Bits, IpAddress, ModuleIdentity, NotificationType, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Integer32, ObjectIdentity, Counter32, TimeTicks, iso, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "IpAddress", "ModuleIdentity", "NotificationType", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Integer32", "ObjectIdentity", "Counter32", "TimeTicks", "iso", "Gauge32")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
ciscoCipCsnaMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 33))
ciscoCipCsnaMIB.setRevisions(('1998-01-06 00:00', '1995-08-21 00:00', '1995-04-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCipCsnaMIB.setRevisionsDescriptions(("With the addition of Cisco's new Channel Port Adapter cards, all the references to CIP in the MIB description and object descriptions are changed to CMCC (Cisco Mainframe Channel Connection). The object names in the form of cip... or cipCard... will remain the same, but will be valid objects for the Channel Port Adapter cards. Change the maximum number of llc2 sessions supported from 4000 to 6000.", 'Minor cleanups to pacify mib compiler.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoCipCsnaMIB.setLastUpdated('9508210000Z')
if mibBuilder.loadTexts: ciscoCipCsnaMIB.setOrganization('cisco IBM engineering Working Group')
if mibBuilder.loadTexts: ciscoCipCsnaMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoCipCsnaMIB.setDescription("This is the Management Information Base (MIB) module for objects used to manage the cisco Systems Network Architecture (SNA) support on Cisco Mainframe Channel Connection (CMCC) cards, also called the CIP-SNA feature. --------------------------------------------------- | Acronym Definitions: | | CMCC = Cisco Mainframe Channel Connection | | CIP = Channel Interface Processor | | CTA = Channel Transport Architecture | | SNA = Systems Network Architecture | | CIP-SNA = CNA = CSNA = SNA Support on | | a CMCC card | --------------------------------------------------- This mib consists of the following tables: 1) CSNA Administration 2) CSNA Operational 3) CSNA Statistics 4) Max Sessions Administration 5) Max Sessions Operational 8) LLC2/CSNA Connection mapping The following is a set of IBM channel terminology: 1) The Channel Subsystem is the way a host performs I/O. 2) A Channel Path is the path to the Channel Control Unit. In the Cisco CMCC environment, this is the path of the channel to the physical router, itself. This path is needed because the physical channel may be directed (switched) through a device called an ESCON director. The path defined from the host to the Control Unit can be different than the path from the Control Unit to the host. For an in-depth definition of how this number is derived, see the cipCardCsnaAdminPath object. 3) A Sub-Channel and Device are exactly the same thing. The term Sub-Channel was introduced for ESCON (IBM's serial fiber optic) channel interface. Previously the term Device was used, and it mapped directly to hardware (in most situations) via a Parallel Channel Adapter (PCA). Another name for PCA is Bus & Tag. In the Cisco CMCC environment, the Sub-Channel is controlled by the Channel Systems Network Architecture (CSNA) feature. For an in-depth definition of how this number is derived, see the cipCardCsnaAdminDevice object. NOTE: The terminology of Sub-Channel and Sub-Channel Index are two completely different entities! See below for Sub-Channel Index. 4) An I/O Device is the entity that is addressed by the combination of Sub-Channel and Device. This directly maps to the cipCardCsnaAdminTable. NOTE: The Channel Systems Network Architecture (CSNA) feature may have multiple sub-channels/devices defined for its control. Also NOTE: That we have defined an object with the name cipCardSubChannelIndex and this object is the two hex octet Channel Path values concatenated with the second hex (the first octet is not used) octet Device value and then converted to an INTEGER (Unsigned). The exact description is taken from the CISCO-CHANNEL-MIB cipCardSubChannelIndex OBJECT-TYPE SYNTAX INTEGER MAX-ACCESS read-only STATUS current DESCRIPTION This indicates which subchannel is being referenced for a particular daughter board on a CMCC card. This value is constructed as follows: path * 256 + device Path and device are the values in CipCardClawConfigTable. ::= { cipCardSubChannelEntry 1 } In this mib, the last two lines change to Path and device are the values in the cipCardCsnaAdminTable. 5) XCA Major Nodes. The XCA major node binds the Channel Path (from the hosts perspective)/Sub- Channel number (i.e. I/O Device), to a CIP internal LAN Adapter of a specific type with a unique SAP Number. That same I/O Device can also be bound to the same LAN Adapter of the same type with a different SAP, and/or the same I/O Device can be bound to any other Adapter and any unique SAP on that Adapter. The binding allows the I/O Device to talk to the Adapter. The SAP allows multiple connections to the same Adapter. The following is an example of the hardware with the above names showing there locations. |----- Channel Path ------| Eg. 150F and 190A ================= ========== | Router A with | | HOST 1 |--- ============ | Control Unit | ========== |__15| ESCON |_____| & Virtual | ____| Director | | I/O Devices | ========== | 19============ | via the CSNA | | HOST 2 |--- -----| feature. | ========== | ================= | Eg. 0100, | ========== Direct Connection | | HOST 3 |--------------------- ========== The following example configuration of a router that shows the entities managed by the CIPCSNA MIB. ------------ ------------ | HOST 1 | | HOST 3 | | & HOST 2 | | | ------------ ------------ || || Router A ----------------------------------------- | ------------------------------------- | | | ----------- --------- | | | | | ESCON 0 | | PCA 1 | | | | | ----------- --------- | | | | | | | | ---------------------- | | | | | CSNA Feature | | | | | | Control Unit F & A | | | | | | for ESCON 0 | | | | | ---------------------- | | | | | | | | CMCC CARD 6 | | | ------------------------------------- | | | ----------------------------------------- The first table is the Cisco Mainframe Channel Connection (CMCC) Channel Systems Network Architecture support (CSNA) Administration table. Each entry created in this table will create an I/O Device that can be attached to the host (via a host VTAM XCA Major Node command). The indices of the table are: * The CMCC Card Slot Index * The Daughter Board Index * The Sub-Channel Index NOTE: In the above discussion, this value is defined to be a combination of the Channel Path and Device (really the address of an I/O Device). The fields included in this table represent: * Channel Path * Device NOTE: The two fields above are the same values as the above Sub-Channel Index. * The configured maximum block delay time * The configured suggested block delay length * The configured maximum block length NOTE: The channel uses data blocks that accumulate data before it sends it to the host. * The row control variable In the example above, three entries would be defined. The first entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 0 - Sub-Channel Index of 0x150F00 or 1380096 - Channel Path of 0x150F or 5391 - Device of 00 - rest can be defaulted The second entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 0 - Sub-Channel Index of 0x190A00 or 1640960 - Channel Path of 0x190A or 6410 - Device of 00 - rest can be defaulted The third entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 1 - Sub-Channel Index of 0x010000 or 65536 - Channel Path of 0x0100 or 256 - Device of 00 - rest can be defaulted The next table is an augmented table to the first table. It keeps the operational status of the first table. The indices are the same as the first table. The fields included in this table represent: * The current operational state of a this table entry * The current operational maximum block delay time * The current operational suggested block delay length * The current operational maximum block length In the example above, three entries would be defined. The first entry would be: - CMCCC Card Slot 0 - CMCC Daughter Board 0 - Sub-Channel Index of 0x150F00 or 1380096 - rest will be determined by the agent The second entry would be: - CMCC Card Slot 0 - CIP Daughter Board 0 - Sub-Channel Index of 0x190A00 or 1640960 - rest will be determined by the agent The second entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 1 - Sub-Channel Index of 0x010000 or 65536 - rest will be determined by the agent The next table is an augmented table to the first table. It keeps the statistics for the Channel Systems Network Architecture (CSNA) counters. The indices are the same as the first table. The fields included in this table represent: * Blocks transmitted * Blocks received * Bytes transmitted * Bytes received * Blocks transmitted by maximum block delay time * Blocks transmitted by the suggested block delay length * Blocks transmitted by maximum block length In the example above, three entries would be defined. The first entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 0 - Sub-Channel Index of 0x150F00 or 1380096 - rest will be determined by the agent The second entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 0 - Sub-Channel Index of 0x190A00 or 1640960 - rest will be determined by the agent The second entry would be: - CMCC Card Slot 0 - CMCC Daughter Board 1 - Sub-Channel Index of 0x010000 or 65536 - rest will be determined by the agent The next table is maximum sessions Admin table. The one entry in this table defines the configured maximum sessions supported on the whole CMCC card. The one index is: * The ifIndex addresses the virtual CMCC interface The one field in this table represents: * The maximum sessions for this card In the example above, the one entry would be defined. - ifIndex is created by the agent - the maximum sessions would be within the range The next table is the operational maximum sessions table. This table is an augmented table to the maximum sessions Admin table. The entries in this table display the current maximum sessions supported on the whole CMCC card. The indices are the same as the maximum sessions Admin table. The one field in this table represents: * The current operational maximum sessions for this card In the example above, the one entry would be defined. - ifIndex is created by the agent - the maximum sessions would be within the range The next table is the statistical maximum sessions table. This table is an augmented table to the maximum sessions Admin table. The entries in this table displays the current high water maximum sessions supported on the whole CMCC card and the number of allocation errors that have occurred when attempting to increase the number of sessions. The indices are the same as the maximum sessions Admin table. The one field in this table represents: * The current operational maximum sessions for this card In the example above, the one entry would be defined. - ifIndex is created by the agent - the highest maximum sessions that has occurred since the last re-boot. - the number of allocation errors when extending the number of sessions. The last table is the SNA Connection table. Each entry in this table represents a connection from an I/O Device (Channel Path/Device) address to a CMCC internal LAN Adapter for a single SAP address. Multiple entries in this table can represent the same LAN Adapter with the use of a different SAP. The entries in this table are created when VTAM on a host creates an XCA Major Node definition. That definition will tell the router what I/O Device address are to be bound to which CMCC internal LAN Adapter (of a type) and which SAP will be used to carry traffic. The indices of the table are: * The ifIndex that addresses the virtual CMCC interface * The virtual interface identifying a unique CMCC internal MAC Adapter. This definition used is defined in the CISCO-SNA-LLC-MIB as llcPortVirtualIndex. * The SAP used by this connection. NOTE: The SAP definition used is defined in the CISCO-SNA-LLC-MIB. The fields included in this table represent: * The number of currently active sessions over this connection * The slot of the CMCC card. * The port on the CMCC card that the Path/Device (subchannel is configured. * The Channel Path used by this connection * The Device used by this connection In the example above, the number entries would depend upon the VTAM configuration. Each entry would be: - ifIndex is created by the agent - one of the LAN identifiers from one of the entries in the CMCC internal LAN table. - one of the adapter identifiers from one the entries in the CMCC internal LAN Adapter table. - the SAP provided by the XCA Major Node command - the number of currently active sessions - the slot of the CMCC card. - the port on the CMCC card. - the Channel Path from one entry in the first table - the Device from same entry as the Channel Path in the first table ")
class ChannelPath(TextualConvention, OctetString):
    description = "This channel path is a two octet value made up of the following values: ------------------------------------------------------ Path 01-FF For a directly attached ESCON channel or any parallel channel, this value is 01 unless the system administrator has configured another value. For a channel attached through an ESCON director switch, this value will be the path that, from the router point of view, exits the switch and attaches to the host. ------------------------------------------------------ Channel logical address 0-F For a directly attached ESCON channel or any parallel channel, this value is 0. If the host is running in Logical Partition (LPAR) mode, this is the channel logical address associated with the channel and defined in the IOCP configuration file used by VTAM. The default for this part of the path argument is 0. Otherwise, the channel logical address associated with the channel is defined in the IOCP configuration file used by VTAM. ------------------------------------------------------ Control unit logical address 0-F For a directly attached ESCON channel or any parallel channel, this value defaults to 0. If this value is specified in the IOCP file, used by VTAM, then match that value here. Otherwise, the control unit logical address is specified in the IOCP configuration file's CNTLUNIT statement for the host channel in the CUADD parameter. ------------------------------------------------------ For example, for path C7, channel logical address 9, control unit logical address 4, the 2 octet value is C7:94. NOTE: Knowledge of creating and using IOCP configuration files for VTAM is a prerequisite."
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 2)

class ChannelDevice(TextualConvention, OctetString):
    description = 'Two octet hex device address for the device the Systems Network Architecture (SNA) host will use to communicate with the Channel Systems Network Architecture (CSNA) feature on the CMCC card. The first octet will always be zero for consistency with other CMCC MIBs. For example, for device address 1C (decimal 28) the 2 octet value is 00:1C.'
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 2)

cipCsnaObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 1))
cipCsnaChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1))
cipSession = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2))
cipCsnaConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3))
cipCardCsnaAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1), )
if mibBuilder.loadTexts: cipCardCsnaAdminTable.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminTable.setDescription('This table contains configuration information for the Channel Systems Network Architecture (CSNA) feature on the CMCC card.')
cipCardCsnaAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardDtrBrdIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardSubChannelIndex"))
if mibBuilder.loadTexts: cipCardCsnaAdminEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminEntry.setDescription('A list of CSNA configuration values.')
cipCardCsnaAdminPath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 1), ChannelPath()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminPath.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminPath.setDescription('The Channel Path for this Channel Systems Network Architecture table entry. For more information see the textual convention ChannelPath.')
cipCardCsnaAdminDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 2), ChannelDevice()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminDevice.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminDevice.setDescription('Two octet hex device address for the device the SNA host will use to communicate with the CSNA feature on the CMCC card. For more information see the textual convention ChannelDevice.')
cipCardCsnaAdminBlockDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(10)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminBlockDelayTime.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminBlockDelayTime.setDescription('The Block Delay Time is the maximum amount of time the CSNA feature can hold a set of requests before it must transmit the block to the host. The Block must be sent when this time has expired, even if the block has not reached the suggested Block Delay Length.')
cipCardCsnaAdminBlockDelayLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(20470)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminBlockDelayLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminBlockDelayLength.setDescription('The Block Delay Length is the suggested size of a block before it is transmitted to the host. The Block Delay Length is used to force a transmit of a block when all information currently being processed has been placed in the block and the real block size exceeds this Block Delay Length size. The size of the block can grow larger than the Block Delay Length size, but must never exceed the Maximum Block Length before being transmitted.')
cipCardCsnaAdminMaxBlockLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4096, 65535)).clone(20470)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminMaxBlockLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminMaxBlockLength.setDescription('The Maximum block length is the maximum size that an inbound channel I/O block my attain before being sent to the host. The block must be smaller or equal to this value.')
cipCardCsnaAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipCardCsnaAdminRowStatus.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaAdminRowStatus.setDescription("This object is used by a Management Station to create or delete the row entry in the cipCardCsnaAdminTable following the the RowStatus textual convention. Upon successful creation of the row, an Agent automatically creates a corresponding entry in the cipCardCsnaOperTable with the cipCardCsnaOperState equal to 'inactive (1)'. The Management Station can initiate row deletion, by setting this value to 'destroy (6)'. The Agent will then delete the rows corresponding to this CSNA instance from both the cipCardCsnaAdminTable and cipCardCsnaOperTable.")
cipCardCsnaOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2), )
if mibBuilder.loadTexts: cipCardCsnaOperTable.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperTable.setDescription('This table contains operation values and status information for the Channel Systems Network Architecture (CSNA) feature on the CMCC card.')
cipCardCsnaOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardDtrBrdIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardSubChannelIndex"))
if mibBuilder.loadTexts: cipCardCsnaOperEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperEntry.setDescription('A list of CSNA operational and status values. The entries are created by the Agent. They have read-only access.')
cipCardCsnaOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("closed", 0), ("pendingOpen", 1), ("open", 2), ("pendingSetup", 3), ("setupComplete", 4), ("pendingClose", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaOperState.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperState.setDescription('The current state of the CSNA entry. The values have the following meanings: closed - Link is closed. pendingOpen - An Open Subchannel command has been received from the host. open - Subchannel is open. pendingSetup - Host has queried for LAN info. setupComplete - LAN info has been sent to the host. pendingClose - A Close Subchannel command has been received from the host. ')
cipCardCsnaOperSlowDownState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("normal", 0), ("slowDownSent", 1), ("slowDownReceived", 2), ("slowDownSentAndReceived", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaOperSlowDownState.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperSlowDownState.setDescription('The current state of the CSNA slow down condition. A channel device will turn on the slow down bit whenever insufficient buffering is available to receive data from the adjacent channel device. The values have the following meanings: normal - Link is normal. slowDownSent - The router has put VTAM into a slow down state. slowDownReceived - VTAM has put the router into a slow down state. slowDownSentReceived - Both VTAM and the router are in a slow down state. ')
cipCardCsnaOperBlockDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaOperBlockDelayTime.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperBlockDelayTime.setDescription('The current Block Delay Time value being used by this instance of CSNA path/device (subchannel).')
cipCardCsnaOperBlockDelayLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaOperBlockDelayLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperBlockDelayLength.setDescription('The current Block Delay Length being used by this instance of CSNA path/device (subchannel).')
cipCardCsnaOperMaxBlockLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4096, 65535))).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaOperMaxBlockLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaOperMaxBlockLength.setDescription('The current Maximum block length being used by this instance of CSNA path/device (subchannel).')
cipCardCsnaStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3), )
if mibBuilder.loadTexts: cipCardCsnaStatsTable.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsTable.setDescription('This table contains statistics information for the Channel Systems Network Architectures (CSNA) feature on the CMCC card.')
cipCardCsnaStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardDtrBrdIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardSubChannelIndex"))
if mibBuilder.loadTexts: cipCardCsnaStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsEntry.setDescription('A list of CSNA statistics. The entries are created by the Agent. They have read-only access.')
cipCardCsnaStatsBlocksTxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxd.setDescription('The number of Blocks Transmitted.')
cipCardCsnaStatsBlocksRxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksRxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksRxd.setDescription('The number of Blocks Received.')
cipCardCsnaStatsBytesTxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 3), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxd.setDescription('The number of Bytes Transmitted. NOTE: To support SNMP Version 1 Managers, this variable is supplied as a 32 bit value which can wrap very frequently.')
cipCardCsnaStatsHCBytesTxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 4), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxd.setDescription('The number of Bytes Transmitted. NOTE: This is a 64 bit (High Capacity) version of the cipCardCsnaStatsBytesTxd counter for use with SNMP Version 2 Managers')
cipCardCsnaStatsBytesRxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 5), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBytesRxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBytesRxd.setDescription('The number of Bytes Received. NOTE: To support SNMP Version 1 Managers, this variable is supplied as a 32 bit value which can wrap very frequently.')
cipCardCsnaStatsHCBytesRxd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 6), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesRxd.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesRxd.setDescription('The number of Bytes Received. NOTE: This is a 64 bit (High Capacity) version of the cipCardCsnaStatsBytesRxd counter for use with SNMP Version 2 Managers')
cipCardCsnaStatsBlocksTxByBlockDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByBlockDelayTime.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByBlockDelayTime.setDescription('The number of Blocks Transmitted when the Block Delay Time has been exceeded.')
cipCardCsnaStatsBytesTxByBlockDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByBlockDelayTime.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByBlockDelayTime.setDescription('The number of Bytes Transmitted when the Block Delay Time has been exceeded.')
cipCardCsnaStatsHCBytesTxByBlockDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByBlockDelayTime.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByBlockDelayTime.setDescription('The number of Bytes Transmitted when the Block Delay Time has been exceeded. NOTE: This is a 64 bit (High Capacity) version of the cipCardCsnaStatsBytesTxByBlockDelayTime counter for use with SNMP Version 2 Managers')
cipCardCsnaStatsBlocksTxByBlockDelayLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByBlockDelayLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByBlockDelayLength.setDescription('The number of Blocks Transmitted when the suggested Block Delay Length has been exceeded.')
cipCardCsnaStatsBytesTxByBlockDelayLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByBlockDelayLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByBlockDelayLength.setDescription('The number of Bytes Transmitted when the suggested Block Delay Length has been exceeded.')
cipCardCsnaStatsHCBytesTxByBlockDelayLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByBlockDelayLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByBlockDelayLength.setDescription('The number of Bytes Transmitted when the suggested Block Delay Length has been exceeded. NOTE: This is a 64 bit (High Capacity) version of the cipCardCsnaStatsBytesTxByBlockDelayLength counter for use with SNMP Version 2 Managers')
cipCardCsnaStatsBlocksTxByMaxBlockLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByMaxBlockLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBlocksTxByMaxBlockLength.setDescription('The number of Blocks Transmitted when the Maximum block length has been exceeded.')
cipCardCsnaStatsBytesTxByMaxBlockLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByMaxBlockLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsBytesTxByMaxBlockLength.setDescription('The number of Bytes Transmitted when the Maximum block length has been exceeded.')
cipCardCsnaStatsHCBytesTxByMaxBlockLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByMaxBlockLength.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsHCBytesTxByMaxBlockLength.setDescription('The number of Bytes Transmitted when the Maximum block length has been exceeded. NOTE: This is a 64 bit (High Capacity) version of the cipCardCsnaStatsBytesTxByBlockDelayLength counter for use with SNMP Version 2 Managers')
cipCardCsnaStatsSlowDownsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsSlowDownsReceived.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsSlowDownsReceived.setDescription('The number of times the slow down bit was detected in a channel I/O block received from VTAM. This condition causes the router to stop transmitting data to VTAM over the channel until the slow down condition has been cleared.')
cipCardCsnaStatsSlowDownsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaStatsSlowDownsSent.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaStatsSlowDownsSent.setDescription('The number of times the slow down bit was set by the router to stop VTAM from sending any more channel I/O blocks. This condition stays in effect until the router clears the slow down condition.')
cipCardSessionsAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 1), )
if mibBuilder.loadTexts: cipCardSessionsAdminTable.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsAdminTable.setDescription('This table contains configured values for CSNA sessions supported on the CMCC card.')
cipCardSessionsAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"))
if mibBuilder.loadTexts: cipCardSessionsAdminEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsAdminEntry.setDescription('A list of CMCC specific Session configuration values.')
cipCardAdminMaxLlc2Sessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardAdminMaxLlc2Sessions.setStatus('current')
if mibBuilder.loadTexts: cipCardAdminMaxLlc2Sessions.setDescription('The configured maximum number of LLC2 sessions allowed on a CMCC card. A value of zero indicates that the maximum should only be limited by the amount of available memory on the CMCC. A value greater than zero indicates the maximum number of sessions the CMCC will support given there is enough memory available on the CMCC card. This value can be set at any time, however it will only affect the Maximum number of LLC2 sessions supported on a CIP the first time it is set and only if the value it is being set to is greater than the current value for cipCardStatsHiWaterLlc2Sessions.')
cipCardSessionsOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 2), )
if mibBuilder.loadTexts: cipCardSessionsOperTable.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsOperTable.setDescription('This table contains the current value for the maximum number of sessions that can be supported on the CMCC card.')
cipCardSessionsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"))
if mibBuilder.loadTexts: cipCardSessionsOperEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsOperEntry.setDescription('A list of CMCC specific Session values.')
cipCardOperMaxLlc2Sessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardOperMaxLlc2Sessions.setStatus('current')
if mibBuilder.loadTexts: cipCardOperMaxLlc2Sessions.setDescription('This value indicates the current number of LLC2 sessions that can be supported on this CMCC card. If this value is zero, then the limit of LLC2 sessions on the CMCC card is only limited by the amount of memory available.')
cipCardSessionsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 3), )
if mibBuilder.loadTexts: cipCardSessionsStatsTable.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsStatsTable.setDescription('This table contains the statistic value(s) for the maximum number of sessions that can be supported on the CMCC card.')
cipCardSessionsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"))
if mibBuilder.loadTexts: cipCardSessionsStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardSessionsStatsEntry.setDescription('A list of CMCC specific Session values.')
cipCardStatsHiWaterLlc2Sessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 3, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardStatsHiWaterLlc2Sessions.setStatus('current')
if mibBuilder.loadTexts: cipCardStatsHiWaterLlc2Sessions.setDescription('High water LLC2 sessions count per CMCC card. If cipCardOperMaxLlc2Sessions is zero (0), then this value starts at 256 Llc2 sessions and will be incremented in values of 64 as more active concurrent LLC2 sessions are established. If cipCardOperMaxLlc2Sessions is greater then zero (0), then this value will either be equal to the cipCardOperMaxLlc2Sessions given enough memory is available on the CMCC card to support that many LLC2 sessions or the the value will be less than cipCardOperMaxLlc2Sessions, reflecting the maximum number of LLC2 sessions the CMCC card can support.')
cipCardStatsLlc2SessionAllocationErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardStatsLlc2SessionAllocationErrs.setStatus('current')
if mibBuilder.loadTexts: cipCardStatsLlc2SessionAllocationErrs.setDescription('This value represents the number of memory allocation errors that have occurred when attempting to create a new block of memory for the LLC2 session buffer pool.')
cipCardCsnaConnTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1), )
if mibBuilder.loadTexts: cipCardCsnaConnTable.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaConnTable.setDescription('This table contains the map between VTAM (the I/O Device Address) and the CMCC LAN Adapter/Mac Address/SAP. For example: Channel Path Channel Path & Device & Device | \\ \\ / / | | \\ \\ / / | SAPS 04 04 04 04 04 04 08 \\ \\ / / 08 | \\ \\/ / | | \\ /\\ / | | \\ / \\ / | | \\ / \\/ | | v /\\ | | ______/ \\ / \\_____ | Adpt Adpt Adpt')
cipCardCsnaConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-SNA-LLC-MIB", "llcPortVirtualIndex"), (0, "CISCO-SNA-LLC-MIB", "llcSapNumber"))
if mibBuilder.loadTexts: cipCardCsnaConnEntry.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaConnEntry.setDescription('A list of CSNA internal LAN Adapter connection values. The first three indices allow the mapping to the LAN and Adapter. To obtain the mapping to the llc SAP table, use the ifIndex, llcSapNumber, and the MAC Address (from the CMCC internal LAN Adapter table).')
cipCardCsnaConnActiveSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaConnActiveSessions.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaConnActiveSessions.setDescription('The Active Sessions in this VTAM to CMCC LAN Adapter/Mac Address mapping.')
cipCardCsnaSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaSlot.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaSlot.setDescription('Slot number of the CMCC card that the Path and Device are configured.')
cipCardCsnaPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaPort.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaPort.setDescription('Port number on the CMCC card that the Path and Device are configured.')
cipCardCsnaConnPath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1, 4), ChannelPath()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaConnPath.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaConnPath.setDescription('Hex path identifier used by this instance of CMCC LAN adapter/SAP to connect SNA sessions to VTAM. For more information see the textual convention ChannelPath.')
cipCardCsnaConnDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 33, 1, 3, 1, 1, 5), ChannelDevice()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipCardCsnaConnDevice.setStatus('current')
if mibBuilder.loadTexts: cipCardCsnaConnDevice.setDescription('Two digit hex device address used by this CMCC LAN adapter/SAP instance to connect SNA sessions to VTAM. For more information see the textual convention ChannelDevice.')
cipCsnaNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 2))
cipCsnaNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 2, 0))
cipCsnaOpenDuplicateSapFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 33, 2, 0, 1)).setObjects(("CISCO-CIPCSNA-MIB", "cipCardCsnaSlot"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaPort"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaConnPath"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaConnDevice"))
if mibBuilder.loadTexts: cipCsnaOpenDuplicateSapFailure.setStatus('current')
if mibBuilder.loadTexts: cipCsnaOpenDuplicateSapFailure.setDescription('This trap indicates that VTAM attempted to open a SAP that was already open via another Path/Device on this CMCC card.')
cipCsnaLlc2ConnectionLimitExceeded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 33, 2, 0, 2)).setObjects(("CISCO-CIPCSNA-MIB", "cipCardAdminMaxLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardOperMaxLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardStatsHiWaterLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardStatsLlc2SessionAllocationErrs"))
if mibBuilder.loadTexts: cipCsnaLlc2ConnectionLimitExceeded.setStatus('current')
if mibBuilder.loadTexts: cipCsnaLlc2ConnectionLimitExceeded.setDescription('This trap indicates that a connection attempt was rejected due to a connection resource limitation')
ciscoCipCsnaMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 3))
ciscoCipCsnaMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 1))
ciscoCipCsnaMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 2))
ciscoCipCsnaMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 1, 1)).setObjects(("CISCO-CIPCSNA-MIB", "ciscoCsnaGroup"), ("CISCO-CIPCSNA-MIB", "ciscoMaxSessionsGroup"), ("CISCO-CIPCSNA-MIB", "ciscoCsnaConnGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCipCsnaMibCompliance = ciscoCipCsnaMibCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoCipCsnaMibCompliance.setDescription('The compliance statement for the Channel Systems Network Architecture (CSNA) feature.')
ciscoCsnaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 2, 1)).setObjects(("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminPath"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminDevice"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminBlockDelayTime"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminBlockDelayLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminMaxBlockLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaAdminRowStatus"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaOperState"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaOperSlowDownState"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaOperBlockDelayTime"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaOperBlockDelayLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaOperMaxBlockLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBlocksTxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBlocksRxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBytesTxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsHCBytesTxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBytesRxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsHCBytesRxd"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBlocksTxByBlockDelayTime"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBytesTxByBlockDelayTime"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsHCBytesTxByBlockDelayTime"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBlocksTxByBlockDelayLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBytesTxByBlockDelayLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsHCBytesTxByBlockDelayLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBlocksTxByMaxBlockLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsBytesTxByMaxBlockLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsHCBytesTxByMaxBlockLength"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsSlowDownsSent"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaStatsSlowDownsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCsnaGroup = ciscoCsnaGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoCsnaGroup.setDescription('A collection of objects providing (Channel Systems Network Architecture (CSNA) Administration, Operational status and Statistics.')
ciscoMaxSessionsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 2, 2)).setObjects(("CISCO-CIPCSNA-MIB", "cipCardAdminMaxLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardOperMaxLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardStatsHiWaterLlc2Sessions"), ("CISCO-CIPCSNA-MIB", "cipCardStatsLlc2SessionAllocationErrs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoMaxSessionsGroup = ciscoMaxSessionsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoMaxSessionsGroup.setDescription('A collection of objects providing the information on the maximum number of sessions supported on a CMCC card.')
ciscoCsnaConnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 33, 3, 2, 3)).setObjects(("CISCO-CIPCSNA-MIB", "cipCardCsnaConnActiveSessions"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaSlot"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaPort"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaConnPath"), ("CISCO-CIPCSNA-MIB", "cipCardCsnaConnDevice"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCsnaConnGroup = ciscoCsnaConnGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoCsnaConnGroup.setDescription('A collection of objects providing CMCC LAN adapter/SAP connection mapping to the Path/Device (subchannel).')
mibBuilder.exportSymbols("CISCO-CIPCSNA-MIB", cipCardCsnaStatsHCBytesTxByBlockDelayLength=cipCardCsnaStatsHCBytesTxByBlockDelayLength, cipCardCsnaStatsHCBytesTxByMaxBlockLength=cipCardCsnaStatsHCBytesTxByMaxBlockLength, cipCardCsnaAdminMaxBlockLength=cipCardCsnaAdminMaxBlockLength, cipCardCsnaStatsBytesTxByBlockDelayTime=cipCardCsnaStatsBytesTxByBlockDelayTime, cipCardCsnaPort=cipCardCsnaPort, cipCardCsnaConnDevice=cipCardCsnaConnDevice, ciscoCipCsnaMibCompliances=ciscoCipCsnaMibCompliances, ciscoCipCsnaMIB=ciscoCipCsnaMIB, cipSession=cipSession, cipCardCsnaAdminDevice=cipCardCsnaAdminDevice, cipCardCsnaConnPath=cipCardCsnaConnPath, cipCardSessionsAdminEntry=cipCardSessionsAdminEntry, PYSNMP_MODULE_ID=ciscoCipCsnaMIB, cipCardCsnaOperState=cipCardCsnaOperState, cipCardStatsHiWaterLlc2Sessions=cipCardStatsHiWaterLlc2Sessions, ChannelDevice=ChannelDevice, cipCardCsnaStatsBlocksTxByBlockDelayLength=cipCardCsnaStatsBlocksTxByBlockDelayLength, cipCsnaLlc2ConnectionLimitExceeded=cipCsnaLlc2ConnectionLimitExceeded, cipCardSessionsOperTable=cipCardSessionsOperTable, ChannelPath=ChannelPath, cipCardCsnaStatsBlocksTxd=cipCardCsnaStatsBlocksTxd, cipCardCsnaOperTable=cipCardCsnaOperTable, cipCardSessionsAdminTable=cipCardSessionsAdminTable, cipCardCsnaSlot=cipCardCsnaSlot, cipCardCsnaOperMaxBlockLength=cipCardCsnaOperMaxBlockLength, cipCardCsnaAdminRowStatus=cipCardCsnaAdminRowStatus, cipCsnaNotifications=cipCsnaNotifications, ciscoCipCsnaMibGroups=ciscoCipCsnaMibGroups, cipCardCsnaOperEntry=cipCardCsnaOperEntry, cipCardCsnaAdminBlockDelayLength=cipCardCsnaAdminBlockDelayLength, cipCardCsnaStatsBytesRxd=cipCardCsnaStatsBytesRxd, cipCardCsnaStatsBlocksRxd=cipCardCsnaStatsBlocksRxd, cipCardCsnaStatsBytesTxd=cipCardCsnaStatsBytesTxd, cipCardOperMaxLlc2Sessions=cipCardOperMaxLlc2Sessions, cipCardCsnaAdminTable=cipCardCsnaAdminTable, cipCardSessionsStatsTable=cipCardSessionsStatsTable, cipCardCsnaStatsHCBytesTxd=cipCardCsnaStatsHCBytesTxd, cipCardCsnaConnTable=cipCardCsnaConnTable, cipCardCsnaAdminEntry=cipCardCsnaAdminEntry, cipCardCsnaOperBlockDelayLength=cipCardCsnaOperBlockDelayLength, cipCardCsnaStatsSlowDownsReceived=cipCardCsnaStatsSlowDownsReceived, cipCsnaObjects=cipCsnaObjects, cipCardCsnaAdminBlockDelayTime=cipCardCsnaAdminBlockDelayTime, cipCsnaChannel=cipCsnaChannel, cipCardCsnaStatsBytesTxByBlockDelayLength=cipCardCsnaStatsBytesTxByBlockDelayLength, ciscoCsnaGroup=ciscoCsnaGroup, cipCardCsnaStatsTable=cipCardCsnaStatsTable, cipCardCsnaConnEntry=cipCardCsnaConnEntry, cipCsnaNotificationPrefix=cipCsnaNotificationPrefix, cipCardCsnaOperSlowDownState=cipCardCsnaOperSlowDownState, cipCardCsnaStatsBlocksTxByMaxBlockLength=cipCardCsnaStatsBlocksTxByMaxBlockLength, cipCardCsnaStatsEntry=cipCardCsnaStatsEntry, cipCardCsnaAdminPath=cipCardCsnaAdminPath, ciscoCipCsnaMibConformance=ciscoCipCsnaMibConformance, cipCardCsnaConnActiveSessions=cipCardCsnaConnActiveSessions, cipCardCsnaOperBlockDelayTime=cipCardCsnaOperBlockDelayTime, cipCardCsnaStatsBlocksTxByBlockDelayTime=cipCardCsnaStatsBlocksTxByBlockDelayTime, cipCsnaConnection=cipCsnaConnection, cipCardCsnaStatsBytesTxByMaxBlockLength=cipCardCsnaStatsBytesTxByMaxBlockLength, cipCardStatsLlc2SessionAllocationErrs=cipCardStatsLlc2SessionAllocationErrs, cipCardSessionsOperEntry=cipCardSessionsOperEntry, cipCsnaOpenDuplicateSapFailure=cipCsnaOpenDuplicateSapFailure, cipCardAdminMaxLlc2Sessions=cipCardAdminMaxLlc2Sessions, ciscoCsnaConnGroup=ciscoCsnaConnGroup, cipCardCsnaStatsHCBytesRxd=cipCardCsnaStatsHCBytesRxd, cipCardSessionsStatsEntry=cipCardSessionsStatsEntry, cipCardCsnaStatsHCBytesTxByBlockDelayTime=cipCardCsnaStatsHCBytesTxByBlockDelayTime, ciscoCipCsnaMibCompliance=ciscoCipCsnaMibCompliance, cipCardCsnaStatsSlowDownsSent=cipCardCsnaStatsSlowDownsSent, ciscoMaxSessionsGroup=ciscoMaxSessionsGroup)

#
# PySNMP MIB module MPC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:14:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
AtmAddr, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr")
lecIndex, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "lecIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Bits, enterprises, Integer32, ObjectIdentity, NotificationType, IpAddress, MibIdentifier, ModuleIdentity, Unsigned32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, Counter32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "enterprises", "Integer32", "ObjectIdentity", "NotificationType", "IpAddress", "MibIdentifier", "ModuleIdentity", "Unsigned32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "Counter32", "Counter64")
MacAddress, TimeInterval, TextualConvention, TimeStamp, DisplayString, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TimeInterval", "TextualConvention", "TimeStamp", "DisplayString", "RowStatus", "TruthValue")
class AtmAddr(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(13, 13), ValueSizeConstraint(20, 20), )
mpoaMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 8, 1))
mpoaMIB.setRevisions(('1998-11-09 00:00', '1998-05-22 00:00', '1998-02-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mpoaMIB.setRevisionsDescriptions(('MPOA v 1.1, Nov 9, 1998 Version of the MIB module MPOA-MIB that is contained in the MPOA v1.1 document. The difference between af-mpoa-0092.000 and this version is the mpcMpsMacAddressTable has been obsoleted. The mpcMpsMultipleMacAddressTable has been added. The mpcMpsMultipleMacAddressTable replaces the mpcMpsMacAddressTable.', 'Final Ballot Version, May 22, 1998 Version of the MIB module MPOA-MIB that is in: AF-MPOA-0092.000.', 'Straw Ballot Revision 1.0, February 25, 1998 Version of the MIB module MPOA-MIB that is in STR-MPOA-MIB-01.01.',))
if mibBuilder.loadTexts: mpoaMIB.setLastUpdated('9811090000Z')
if mibBuilder.loadTexts: mpoaMIB.setOrganization('ATM Forum LANE/MPOA Working Group')
if mibBuilder.loadTexts: mpoaMIB.setContactInfo('The ATM Forum 2570 West El Camino Real, Suite 304 Mountain View, CA 94040-1313 USA Tel: +1-650-949-6700 Fax: +1-650-949-6705 Web: http://www.atmforum.com E-mail: info@atmforum.com')
if mibBuilder.loadTexts: mpoaMIB.setDescription('This module defines a portion of the management information base (MIB) for managing Multiprotocol Over ATM clients and servers which was revised based on MPOA Errata contained in MPOA v1.1. The difference between af-mpoa-0092.000 and this version is the mpcMpsMacAddressTable has been obsoleted. The mpcMpsMultipleMacAddressTable has been added. The mpcMpsMultipleMacAddressTable replaces the mpcMpsMacAddressTable.')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfMpoa = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8))
class LecIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the LEC for which the entry contains management information. The value of this object for a particular LAN Emulation Client (LEC) has the same value as the lecIndex object, defined in the LAN-EMULATION-CLIENT MIB, for the same LEC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class AtmConfigAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are: NSAP SEL Byte (1 octet) E.164 (8 octets), and NSAP (20 octets). Note: If the 1 octet NSAP SEL is given, the other 19 octets of the NSAP are derived from the system either through ILMI or another method. Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(1, 1), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
class InternetworkAddrType(TextualConvention, Integer32):
    reference = 'Assigned Numbers, RFC1700, ADDRESS FAMILY NUMBERS'
    description = 'Internetwork Layer Address Types. Values are defined in Assigned Numbers, RFC1700. Note: not all of these values make sense in all contexts where this type is used in this MIB, but they are included for completeness.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("other", 0), ("ipV4", 1), ("ipV6", 2), ("nsap", 3), ("hdlc", 4), ("bbn1822", 5), ("ieee802", 6), ("e163", 7), ("e164", 8), ("f69", 9), ("x121", 10), ("ipx", 11), ("appleTalk", 12), ("decnetIV", 13), ("banyanVines", 14), ("e164WithNsap", 15))

class InternetworkAddr(TextualConvention, OctetString):
    description = 'The value of an internetwork layer address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 60)

class MpcIndex(TextualConvention, Integer32):
    description = 'A unique value, for each MPOA client which this SNMP agent manages. It is recommended that values are assigned contiguously starting from 1. The value for each MPOA Client must remain constant, even if the MPOA Client or SNMP agent is re-initialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MpsIndex(TextualConvention, Integer32):
    description = 'A unique value, for each MPOA Server which this SNMP agent manages. It is recommended that values are assigned contiguously starting from 1. The value for each MPOA Server must remain constant, even if the MPOA Server or SNMP agent is re-initialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

mpoaMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1))
mpoaCommonObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 1))
mpcObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2))
mpcNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mpcNextIndex.setStatus('current')
if mibBuilder.loadTexts: mpcNextIndex.setDescription("This object contains an appropriate value to be used for mpcIndex when creating entries in the mpcConfigTable. The value 0 indicates that no new rows can be created. Otherwise, it is recommended that values are assigned contiguously, starting from 1. MPC creation by a Manager: To obtain the mpcIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. If the value retrieved is 0 (zero), the manager cannot create a row. After each retrieval of a non-zero value, the manager should issue a management protocol SET operation using the value just retrieved. If the SET is successful, the agent should update the value to the next unassigned index, or zero if appropriate. NOTE: the manager may also issue a set on this object with a value of its own choosing. If the set is successful, the manager may use this value for the mpcIndex. In this case, the agent would update the value to the next unassigned index, or zero if appropriate. The definition of `next unassigned index' is any mpcNextIndex value that has not yet been set by a manager, or reserved by the agent (see next paragraph), since this agent was last re-initialized. MPC creation by an Agent: When a row in the mpcConfigTable is created by an agent, the agent should reserve the value of the index by updating the value of this object to the next unassigned index or zero if appropriate. Thus, a manager will not be able to set an index reserved by an agent. In the situation of an agent re-initialization, all currently used mpcIndexes must be preserved. In other words, the Agent should store in non-volatile memory all of the currently used mpcIndexes (along with all necessary configuration information from the mpcConfigTable). When the agent is re-initialized, the mpcNextIndex value is any valid Integer32 value which is not being used as an mpcIndex, except 0 which maintains its original definition of indicating that a row cannot be created.")
mpcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2), )
if mibBuilder.loadTexts: mpcConfigTable.setStatus('current')
if mibBuilder.loadTexts: mpcConfigTable.setDescription('The MPOA Client Configuration Table. This table contains configuration information for all MPOA Clients which this agent manages.')
mpcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1), ).setIndexNames((0, "MPC-MIB", "mpcIndex"))
if mibBuilder.loadTexts: mpcConfigEntry.setStatus('current')
if mibBuilder.loadTexts: mpcConfigEntry.setDescription('MPOA Client Configuration Entry. Each entry contains configuration information for one MPOA Client. The configuration information, including the mpcIndex, must be restored after a re-initialization of an MPC or a re-initialization of the SNMP agent.')
mpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 1), MpcIndex())
if mibBuilder.loadTexts: mpcIndex.setStatus('current')
if mibBuilder.loadTexts: mpcIndex.setDescription("A value which uniquely identifies this conceptual row in the mpcConfigTable. The `mpcNextIndex' object needs to be used to determine the value of this object. A row cannot be added, unless the mpcCtrlAtmAddress is unique. In the event of either an MPC re-initialization or an agent re-initialization, the value of this mpcIndex must remain the same. In other words, the row needs to be saved and restored in the event of an MPC or SNMP Agent re-initialization.")
mpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcRowStatus.setStatus('current')
if mibBuilder.loadTexts: mpcRowStatus.setDescription("This object allows creation and deletion of MPOA Clients. Within each conceptual mpcConfigTable row, writable objects may be modified, regardless of the value of mpcRowStatus. It is not necessary to set a row's status to `notInService' first. A row cannot be created, unless the mpcAtmCtrlAddress in this table is unique. When an MPOA Client is created via this object, it will initially have `mpcActualState' = `initialState'")
mpcConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpcConfigMode.setDescription('Indicates whether this MPC should auto-configure the next time it is (re-)initialized. During the (re-)initialization of this MPC, if the mode is automatic(1), the LECS is contacted and requests are made for all MPC-p* parameters. Otherwise, if the mode is manual(2), the values of the configuration parameters are obtained from the mpcConfigTableand the mpcProtocolTable. In other words, when the MPC is first initialized, it can use the default or configured values from the mpcConfigTable and mpcProtocolTable. If the mode is manual (2), no further action is required. If the mode is automatic (1), then the LECS should be contacted and all available MPC-p1 to MPC-p6 parameters would be retrieved. These parameters would then overwrite the existing MPC-p1 to MPC-p6 parameters. The actual values are reflected in the mpcActualTable.')
mpcCtrlAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 4), AtmConfigAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcCtrlAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcCtrlAtmAddr.setDescription("The MPC's Control ATM Address. There exists one Control ATM Address per MPC, therefore, the value of this entry is unique within the table. The control ATM Address is the address which is used by the MPC in its requests to the MPS. The value of this object should not change, once created.")
mpcSCSetupFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcSCSetupFrameCount.setStatus('current')
if mibBuilder.loadTexts: mpcSCSetupFrameCount.setDescription('This represents the MPC-p1 Short-cut setup frame count parameter. The MPC-p1 value is frames measured over mpcSCFrameTime seconds. Flow detection is protocol independent. i.e. all network layers mpcProtocolEntries for this MPC share the flow rate specification. A value of 1 causes all flows to initiate resolution/shortcut process.')
mpcSCSetupFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcSCSetupFrameTime.setStatus('current')
if mibBuilder.loadTexts: mpcSCSetupFrameTime.setDescription('MPC-p2 Short-cut setup frame time, in seconds.')
mpcInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpcInitialRetryTime.setDescription("MPC-p4 is the initial value for the retry time out period used for timing out MPOA Resolution Requests in seconds. Retry time consists of this initial time-out (MPC-p4) and a retry multiplier (MPC-c1). If a response is not received, then another request is sent with a timeout of `retry time' * MPC-c1 seconds, or until mpcRetryTimeMaximum.")
mpcRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(40)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpcRetryTimeMaximum.setDescription('MPC-p5 cumulative max value for Retry Time (MPC-p4). Retries are attempted at intervals determined by the algorithm described in the definition of mpcIntialRetryTime.')
mpcHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1200)).clone(160)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mpcHoldDownTime.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.1.2.1 MPC Parameters')
if mibBuilder.loadTexts: mpcHoldDownTime.setStatus('current')
if mibBuilder.loadTexts: mpcHoldDownTime.setDescription('MPC-p6 Hold Down Time Minimum time to wait before reinitiating a failed resolution attempt. Default is mpcRetryTimeMaximum * 4.')
mpcActualTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3), )
if mibBuilder.loadTexts: mpcActualTable.setStatus('current')
if mibBuilder.loadTexts: mpcActualTable.setDescription('MPOA Client Actual Table. A read-only table which contains state information and reflects the actual values which these MPOA Clients are using. The actual values may differ from the configured values. For example, the mpcConfigMode takes affect only during (re-)initialization of the MPC. The MPC-p1 to MPC-p6 parameters may differ from the configured values because, if the MPC was (re-)initialized and the mpcConfigMode was set to automatic (1) then some, perhaps all, of the MPC-p1 to MPC-p6 parameters were retrieved from the LECS and the values from the LECS may differ from the configured/default values of the mpcConfigTable. NOTE: after re-initialization a set to an object in the mpcConfigTable which changes the value of the object will be reflect in this Table, except for a set to the mpcConfigMode which takes effect only during re-initialization.')
mpcActualEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1), )
mpcConfigEntry.registerAugmentions(("MPC-MIB", "mpcActualEntry"))
mpcActualEntry.setIndexNames(*mpcConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpcActualEntry.setStatus('current')
if mibBuilder.loadTexts: mpcActualEntry.setDescription("An entry in the MPC Actual Table. An entry represents a specific MPOA Client's state information and the actual values which are being used by the MPOA Client. For example, the corresponding mpcConfigEntry contains default and/or configured parameters, if mpcConfigMode was set to manual, then these are the objects values' which are reflected for the mpcActualEntry. However, if the mpcConfigMode is automatic, then the mpcActualEntry will be all the corresponding mpcConfigEntry's object, excluding any objects which were retrieved from the LECS. In other words, the objects retrieved from the LECS during the (re-)initialization of the MPC overwrite any of the default and/or configured values. NOTE: any subsequent `set' to the configured values, e.g. an SNMP set operation, which is successful could result in a change to an mpcConfigTable value, and will be reflected in this table as well.")
mpcActualState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("initialState", 2), ("up", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualState.setStatus('current')
if mibBuilder.loadTexts: mpcActualState.setDescription('This object indicates the actual state of the MPOA Client.')
mpcDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mpcDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this MPC's counters experienced a discontinuity. The relevant counters are the specific instances associated with this MPC. If discontinuities have not occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
mpcActualConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualConfigMode.setStatus('current')
if mibBuilder.loadTexts: mpcActualConfigMode.setDescription('Indicates whether this MPC auto-configured when it was last (re-)initialized.')
mpcActualSCSetupFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualSCSetupFrameCount.setStatus('current')
if mibBuilder.loadTexts: mpcActualSCSetupFrameCount.setDescription('MPC-p1 Short-cut setup frame count. In frames measured over mpcShortcutFrameTime seconds. Flow detection is protocol independent. i.e. all network layers mpcProtocolEntry share the flow rate specification. A value of 1 implies that resolutions for short-cuts are attempted for all flows.')
mpcActualSCSetupFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualSCSetupFrameTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualSCSetupFrameTime.setDescription('Actual MPC-p2 Short-cut setup frame time, in seconds.')
mpcActualInitialRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualInitialRetryTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualInitialRetryTime.setDescription('Actual MPC-p4 is initial value for the retry time out.')
mpcActualRetryTimeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Section 4.3 MPOA Retry Mechanism')
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setStatus('current')
if mibBuilder.loadTexts: mpcActualRetryTimeMaximum.setDescription('MPC-p5 cumulative maximum value for Retry Time (MPC-p4). Retries are attempted at intervals determined by the algorithm described in the definition of mpcActualInitialRetryTime.')
mpcActualHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcActualHoldDownTime.setStatus('current')
if mibBuilder.loadTexts: mpcActualHoldDownTime.setDescription('MPC-p6 Hold Down Time Minimum time to wait before reinitiating a failed resolution attempt. The default value is mpcRetryTimeMaximum * 4.')
mpcStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5), )
if mibBuilder.loadTexts: mpcStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: mpcStatisticsTable.setDescription('A read-only table which contains statistical information for all MPOA Clients that this agent manages.')
mpcStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1), )
mpcConfigEntry.registerAugmentions(("MPC-MIB", "mpcStatisticsEntry"))
mpcStatisticsEntry.setIndexNames(*mpcConfigEntry.getIndexNames())
if mibBuilder.loadTexts: mpcStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: mpcStatisticsEntry.setDescription('Each row in this table contains statistics for one MPOA Client.')
mpcStatTxMpoaResolveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaResolveRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaResolveRequests.setDescription('The number of MPOA Resolve Requests transmitted by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaResolveReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyAcks.setDescription('The number of positively acknowledged MPC Resolved Replies received by this MPC with an MPOA CIE Code of 0x00 (Success). Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re- initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaResolveReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufECResources.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x81, `Insufficient resources to accept egress cache entry'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufSCResources.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x82, `Insufficient resources to accept the shortcut'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyInsufEitherResources.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x83, `Insufficient resources to accept either shortcut or egress cache entry'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedInetProt.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x84, `Unsupported Internework Layer protocol'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnsupportedMacEncaps.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x85, `Unsupported MAC layer encapsulation'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaResolveReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaResolveReplyUnspecifiedOther.setDescription("The number of MPOA Resolution Replies received with an MPOA CIE Code of 0x88, `Unspecified/Other'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxMpoaImpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaImpRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaImpRequests.setDescription('The number of MPOA Cache Imposition Requests received by this MPC. Discontinuities in the value of this counter can occur at re- initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxMpoaImpReplyAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyAcks.setDescription("The number of successful MPOA Cache Imposition replies transmitted by this MPC with an MPOA CIE Code of 0x00 `Success'. Discontinuities in the value of this counter can occur at re- initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufECResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufECResources.setDescription("The number of MPOA Cache Imposition Replies transmitted with an MPOA CIE Code of 0x81, `Insufficient resources to accept egress cache entry'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufSCResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufSCResources.setDescription("The number of MPOA Imposition Replies transmitted with an MPOA CIE Code of 0x82, `Insufficient resources to accept shortcut'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyInsufEitherResources = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyInsufEitherResources.setDescription("The number of MPOA Imposition Replies transmitted with an MPOA CIE Code of 0x83, `Insufficient resources to accept either shortcut or egress cache entry'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnsupportedInetProt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedInetProt.setDescription("The number of MPOA Imposition Replies transmitted with an MPOA CIE Code of 0x84, `Unsupported Internetwork Layer protocol'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnsupportedMacEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnsupportedMacEncaps.setDescription("The number of MPOA Imposition Replies transmitted with an MPOA CIE Code of 0x85, `Unsupported MAC Layer encapsulation'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaImpReplyUnspecifiedOther = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 62.')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaImpReplyUnspecifiedOther.setDescription("The number of MPOA Imposition Replies transmitted with an MPOA CIE Code of 0x88, `Unspecified/Other'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatTxMpoaEgressCachePurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaEgressCachePurgeRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaEgressCachePurgeRequests.setDescription('The number of MPOA Egress Cache Purge Requests transmitted by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaEgressCachePurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaEgressCachePurgeReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaEgressCachePurgeReplies.setDescription('The number of MPOA Egress Cache Purge Replies received by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaKeepAlives = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaKeepAlives.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaKeepAlives.setDescription('The number of MPOA Keep Alive messages received by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaTriggers.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaTriggers.setDescription('The number of MPOA Trigger messages received by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxMpoaDataPlanePurges = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxMpoaDataPlanePurges.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxMpoaDataPlanePurges.setDescription('The number of MPOA Data Plane Purge messages received by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxMpoaDataPlanePurges = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxMpoaDataPlanePurges.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxMpoaDataPlanePurges.setDescription('The number of MPOA Data Plane Purge messages transmitted by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxNhrpPurgeRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxNhrpPurgeRequests.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxNhrpPurgeRequests.setDescription('The number of Purge Requests received by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatTxNhrpPurgeReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatTxNhrpPurgeReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatTxNhrpPurgeReplies.setDescription('The number of Purge Replies transmitted by this MPC. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.')
mpcStatRxErrUnrecognizedExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrUnrecognizedExtensions.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrUnrecognizedExtensions.setDescription("The number of Error Indication packets received by this MPC with the error code `Unrecognized Extension'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrLoopDetecteds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrLoopDetecteds.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrLoopDetecteds.setDescription("The number of Error Indication packets received by this MPC with the error code `Loop Detected'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrProtoAddrUnreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrProtoAddrUnreachables.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrProtoAddrUnreachables.setDescription("The number of Error Indication packets received by this MPC with the error code `Protocol Address Unreachable'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrProtoErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrProtoErrors.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrProtoErrors.setDescription("The number of Error Indication packets received by this MPC with the error code `Protocol Errors'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrSduSizeExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrSduSizeExceededs.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrSduSizeExceededs.setDescription("The number of Error Indication packets received by this MPC with the error code `SDU Size Exceeded'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrInvalidExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrInvalidExtensions.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrInvalidExtensions.setDescription("The number of Error Indication packets received by this MPC with the error code `Invalid Extensions'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrInvalidReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrInvalidReplies.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrInvalidReplies.setDescription("The number of Error Indication packets received by this MPC with the error code `Invalid Reply'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrAuthenticationFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrAuthenticationFailures.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrAuthenticationFailures.setDescription("The number of Error Indication packets received by this MPC with the error code `Authentication Failure'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcStatRxErrHopCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcStatRxErrHopCountExceededs.setStatus('current')
if mibBuilder.loadTexts: mpcStatRxErrHopCountExceededs.setDescription("The number of Error Indication packets received by this MPC with the error code `Hop Count Exceeded'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and/or re-initialization of the MPC, and at other times, as indicated by the value of mpcDiscontinuityTime.")
mpcMpsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8), )
if mibBuilder.loadTexts: mpcMpsTable.setStatus('current')
if mibBuilder.loadTexts: mpcMpsTable.setDescription('This is a read-only table which contains information about the MPSs that these MPCs know about.')
mpcMpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1), ).setIndexNames((0, "MPC-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcMpsEntry.setStatus('current')
if mibBuilder.loadTexts: mpcMpsEntry.setDescription('A row created by an MPC. The MPC learns about an MPS and creates a row.')
mpcMpsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1, 1), MpsIndex())
if mibBuilder.loadTexts: mpcMpsIndex.setStatus('current')
if mibBuilder.loadTexts: mpcMpsIndex.setDescription("The MPS's index which is used to identify a row in this table.")
mpcMpsAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 8, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcMpsAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcMpsAtmAddr.setDescription('The Control ATM Address of the MPS')
mpcIngressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12), )
if mibBuilder.loadTexts: mpcIngressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTable.setDescription('This table contains information for MPC Caches for the ingress MPC.')
mpcIngressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1), ).setIndexNames((0, "MPC-MIB", "mpcIngressCacheDestInetworkAddrType"), (0, "MPC-MIB", "mpcIngressCacheDestAddr"), (0, "MPC-MIB", "mpcIndex"), (0, "MPC-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcIngressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEntry.setDescription("An entry contains control information for a row in a MPC's Ingress Cache.")
mpcIngressCacheDestInetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 1), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestInetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestInetworkAddrType.setDescription('The type of the destination internetwork layer address.')
mpcIngressCacheDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 2), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestAddr.setDescription('The destination internetwork layer address for which this entry is defined.')
mpcIngressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCachePrefixLen.setDescription('Defines an equivalence class of addresses that match Prefix Length bit positions of the destination internetwork layer address.')
mpcIngressCacheDestAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 4), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheDestAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheDestAtmAddr.setDescription('The Destination ATM Address received in the MPOA Resolution Reply.')
mpcIngressCacheSrcAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 5), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheSrcAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheSrcAtmAddr.setDescription('The Source ATM Address for the MPOA Resolution Request.')
mpcIngressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setReference('Multiprotocol Over ATM, Letter Ballot, Appendix I.2.')
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEntryState.setDescription("The present state of this MPC ingress cache. The states are: doesNotExist (1) -- the state is not yet available inactive (2) -- state exists, entry is not yet active. For an example, if using the Finite State Machine Appendix I.2, then the states Cached and query are considered `inactive'. active (3) -- state exists, entry is active. For an example, if using the Finite State Machine in Appendix I.2, then the states resolved and refresh are considered `active'. negative (4) -- state exists, entry is negative, which could mean a NAK response was received, or entry is doing a retry, etc. For example, if using the Finite State Machine in Appendix I.2, then the state `hold down' is considered `negative'.")
mpcIngressCacheEgressCacheTagValid = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTagValid.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTagValid.setDescription('If the value of this object is true(1), then a valid Egress Cache Tag is present and the value of the Egress Cache Tag is in mpcIngressCacheEgressCacheTag. Otherwise, if this value is false(2), then there was no Egress Cache Tag, and the value of mpcIngressCacheEgressCacheTag is undefined.')
mpcIngressCacheEgressCacheTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setReference('Multiprotocol Over ATM Version 1.0 (Letter Ballot), Section 4.4.4.1.')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheEgressCacheTag.setDescription('If a valid Egress Cache Tag is present, then this object contains the value of that tag. To determine if this object contains a valid value, mpcIngressCacheEgressTagValid should be used.')
mpcIngressCacheLastNhrpCieCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setReference('Normative section 4.4.6.1.1 of Multiprotocol Over ATM Version 1.0 (Letter Ballot)')
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheLastNhrpCieCode.setDescription('The last NHRP CIE code received for this entry. This value is valid only during the Hold Down period of the cache entry. This value is undefined otherwise.')
mpcIngressCacheSigErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheSigErrCode.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheSigErrCode.setDescription('Error code or Success of the last sinalling request for this cache entry.')
mpcIngressCacheRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheRetries.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheRetries.setDescription('The current number of times this MPC has issued a resolution request since it received a valid reply.')
mpcIngressCacheTimeUntilNextResolutionRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 12), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheTimeUntilNextResolutionRequest.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheTimeUntilNextResolutionRequest.setDescription('The amount of time the MPC must wait before issuing the next resolution request.')
mpcIngressCacheHoldingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 13), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheHoldingTime.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheHoldingTime.setDescription("The time that this MPC's Ingress Cache Entry will remain valid. If the mpcIngressCacheEntryState is not active this value will be zero.")
mpcIngressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setReference('Lane V2 LUNI TLVs. AF-LANE-0084 page 122')
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpcIngressCacheServiceCategory.setDescription('The service categories supported for this shortcut.')
mpcEgressCacheTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15), )
if mibBuilder.loadTexts: mpcEgressCacheTable.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheTable.setDescription('This table contains Egress Cache information for all the MPCs which this agent manages.')
mpcEgressCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1), ).setIndexNames((0, "MPC-MIB", "mpcEgressCacheId"), (0, "MPC-MIB", "mpcIndex"), (0, "MPC-MIB", "mpcMpsIndex"))
if mibBuilder.loadTexts: mpcEgressCacheEntry.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEntry.setDescription("An entry in the MPOA Client's Egress Cache table.")
mpcEgressCacheId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheId.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheId.setDescription('Cache ID Provided by the MPS in the Cache Imposition Request.')
mpcEgressCacheInetworkAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 2), InternetworkAddrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheInetworkAddrType.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheInetworkAddrType.setDescription('Type of Internetwork Address in this cache entry.')
mpcEgressCacheIDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 3), InternetworkAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheIDestAddr.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheIDestAddr.setDescription('The destination internetwork layer address for which this entry is defined.')
mpcEgressCachePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCachePrefixLen.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCachePrefixLen.setDescription('Defines an equivalence class of addresses that match Prefix Length bit positions of the destination internetwork layer address.')
mpcEgressCacheEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doesNotExist", 1), ("inactive", 2), ("active", 3), ("negative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setReference('MPOA Letter Ballot, Appendix I.5.')
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEntryState.setDescription("The present state of this MPC egress cache entry. The states are: doesNotExist (1) -- the state is not yet available, inactive (2) -- state exists, entry is not yet active, active (3) -- state exists, entry is active. For example,if using the Finite State Machine in Appendix 1.5, the states active and flooding are `active' state. negative (4) -- state exists, entry is negative. For example,if using the Finite State Machine in Appendix 1.5, the state purging is `negative'.")
mpcEgressCacheEgressCacheTagValid = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTagValid.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTagValid.setDescription('If the value of this object is true(1), then a valid Egress Cache Tag is present and the value of the Egress Cache Tag is in mpcEgressCacheEgressCacheTag. Otherwise, if this value is false(2), then there was no Egress Cache Tag, and the value of mpcEgressCacheEgressCacheTag is undefined.')
mpcEgressCacheEgressCacheTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTag.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheEgressCacheTag.setDescription('If a valid Egress Cache Tag is present, then this object contains the value of that tag. To determine if this object contains a valid value, mpcEgressCacheEgressCacheTagValid should be used.')
mpcEgressCacheHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheHoldTime.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheHoldTime.setDescription('The remaining time for which this entry is valid.')
mpcEgressCacheDataLinkHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheDataLinkHeader.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheDataLinkHeader.setDescription('The DataLink header that the egress client rebuilds the original DataLink packet with.')
mpcEgressCacheIngressMpcDataAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 10), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setReference('Multiprotocol Over ATM. AF-MPOA-0087.000. Page 81.')
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheIngressMpcDataAtmAddr.setDescription('The Data ATM Address of the ingress MPC that issued the MPOA Resolution request')
mpcEgressCacheLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 11), LecIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheLecIndex.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheLecIndex.setDescription('This is the lecIndex of the LANE Client that this flow is associated with. This can be used to get the ELAN name as well as other LANE parameters.')
mpcEgressCacheServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 15, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setReference('Lane V2 LUNI TLVs. AF-LANE-0084, page 122.')
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setStatus('current')
if mibBuilder.loadTexts: mpcEgressCacheServiceCategory.setDescription('This is a bitmap describing the service categories supported for this shortcut. This value represents an inclusive OR of the bits: bit 1 - if rt-VBR is supported, bit 2 - if nrt-VBR is supported, bit 4 - if ABR is supported, bit 8 - if CBR is supported A value of 0 (zero) indicates that UBR is supported.')
mpcMpsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 1, 2, 16))
mpoaMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2))
mpoaMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 1))
mpoaMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 8, 1, 2, 2))
mibBuilder.exportSymbols("MPC-MIB", mpcActualTable=mpcActualTable, atmForum=atmForum, mpcStatRxErrAuthenticationFailures=mpcStatRxErrAuthenticationFailures, mpcStatTxMpoaImpReplyAcks=mpcStatTxMpoaImpReplyAcks, mpcActualEntry=mpcActualEntry, mpcStatTxMpoaImpReplyInsufECResources=mpcStatTxMpoaImpReplyInsufECResources, mpcIngressCacheDestAtmAddr=mpcIngressCacheDestAtmAddr, mpcEgressCacheIDestAddr=mpcEgressCacheIDestAddr, mpcActualRetryTimeMaximum=mpcActualRetryTimeMaximum, mpcStatisticsTable=mpcStatisticsTable, mpcEgressCacheDataLinkHeader=mpcEgressCacheDataLinkHeader, MpcIndex=MpcIndex, mpcActualInitialRetryTime=mpcActualInitialRetryTime, mpcStatRxMpoaImpRequests=mpcStatRxMpoaImpRequests, mpcEgressCacheId=mpcEgressCacheId, MpsIndex=MpsIndex, mpoaMIBConformance=mpoaMIBConformance, mpcActualSCSetupFrameTime=mpcActualSCSetupFrameTime, mpcStatRxMpoaKeepAlives=mpcStatRxMpoaKeepAlives, mpcMpsEntry=mpcMpsEntry, mpcNextIndex=mpcNextIndex, mpcStatisticsEntry=mpcStatisticsEntry, mpcMpsTable=mpcMpsTable, mpcStatTxMpoaEgressCachePurgeRequests=mpcStatTxMpoaEgressCachePurgeRequests, mpcStatRxMpoaResolveReplyUnsupportedInetProt=mpcStatRxMpoaResolveReplyUnsupportedInetProt, mpcStatTxNhrpPurgeReplies=mpcStatTxNhrpPurgeReplies, mpcEgressCacheEgressCacheTag=mpcEgressCacheEgressCacheTag, mpcIngressCacheRetries=mpcIngressCacheRetries, mpcStatRxErrInvalidExtensions=mpcStatRxErrInvalidExtensions, mpcStatTxMpoaImpReplyInsufEitherResources=mpcStatTxMpoaImpReplyInsufEitherResources, mpcIngressCacheServiceCategory=mpcIngressCacheServiceCategory, mpoaMIBObjects=mpoaMIBObjects, mpoaCommonObjects=mpoaCommonObjects, mpcStatRxMpoaTriggers=mpcStatRxMpoaTriggers, atmfMpoa=atmfMpoa, mpcStatTxMpoaImpReplyInsufSCResources=mpcStatTxMpoaImpReplyInsufSCResources, mpcMpsAtmAddr=mpcMpsAtmAddr, mpcEgressCacheLecIndex=mpcEgressCacheLecIndex, mpcIngressCacheSrcAtmAddr=mpcIngressCacheSrcAtmAddr, mpcStatRxErrLoopDetecteds=mpcStatRxErrLoopDetecteds, mpcStatRxMpoaResolveReplyUnspecifiedOther=mpcStatRxMpoaResolveReplyUnspecifiedOther, mpcStatRxErrHopCountExceededs=mpcStatRxErrHopCountExceededs, mpcEgressCacheEntryState=mpcEgressCacheEntryState, mpcSCSetupFrameCount=mpcSCSetupFrameCount, mpcStatRxErrSduSizeExceededs=mpcStatRxErrSduSizeExceededs, mpcIngressCacheDestAddr=mpcIngressCacheDestAddr, mpcStatRxMpoaResolveReplyInsufECResources=mpcStatRxMpoaResolveReplyInsufECResources, mpcStatRxMpoaResolveReplyInsufEitherResources=mpcStatRxMpoaResolveReplyInsufEitherResources, mpcRetryTimeMaximum=mpcRetryTimeMaximum, LecIndex=LecIndex, mpcIngressCacheEgressCacheTagValid=mpcIngressCacheEgressCacheTagValid, mpcSCSetupFrameTime=mpcSCSetupFrameTime, mpcDiscontinuityTime=mpcDiscontinuityTime, mpcEgressCacheIngressMpcDataAtmAddr=mpcEgressCacheIngressMpcDataAtmAddr, mpcInitialRetryTime=mpcInitialRetryTime, mpcStatTxMpoaImpReplyUnsupportedInetProt=mpcStatTxMpoaImpReplyUnsupportedInetProt, mpcHoldDownTime=mpcHoldDownTime, mpcEgressCacheEntry=mpcEgressCacheEntry, mpoaMIBCompliances=mpoaMIBCompliances, mpcActualState=mpcActualState, mpoaMIB=mpoaMIB, mpcIndex=mpcIndex, mpcStatTxMpoaDataPlanePurges=mpcStatTxMpoaDataPlanePurges, PYSNMP_MODULE_ID=mpoaMIB, mpcStatRxErrProtoErrors=mpcStatRxErrProtoErrors, AtmAddr=AtmAddr, mpcIngressCachePrefixLen=mpcIngressCachePrefixLen, mpcEgressCacheHoldTime=mpcEgressCacheHoldTime, mpcStatRxMpoaResolveReplyUnsupportedMacEncaps=mpcStatRxMpoaResolveReplyUnsupportedMacEncaps, mpcIngressCacheLastNhrpCieCode=mpcIngressCacheLastNhrpCieCode, InternetworkAddr=InternetworkAddr, mpcEgressCacheEgressCacheTagValid=mpcEgressCacheEgressCacheTagValid, mpcIngressCacheEntryState=mpcIngressCacheEntryState, mpcEgressCacheInetworkAddrType=mpcEgressCacheInetworkAddrType, mpcStatTxMpoaImpReplyUnsupportedMacEncaps=mpcStatTxMpoaImpReplyUnsupportedMacEncaps, mpcRowStatus=mpcRowStatus, mpcIngressCacheHoldingTime=mpcIngressCacheHoldingTime, mpcConfigTable=mpcConfigTable, mpcMpsObjects=mpcMpsObjects, mpcIngressCacheTimeUntilNextResolutionRequest=mpcIngressCacheTimeUntilNextResolutionRequest, mpcEgressCacheTable=mpcEgressCacheTable, mpcEgressCacheServiceCategory=mpcEgressCacheServiceCategory, atmForumNetworkManagement=atmForumNetworkManagement, mpcStatTxMpoaImpReplyUnspecifiedOther=mpcStatTxMpoaImpReplyUnspecifiedOther, mpcActualSCSetupFrameCount=mpcActualSCSetupFrameCount, mpcEgressCachePrefixLen=mpcEgressCachePrefixLen, mpcObjects=mpcObjects, AtmConfigAddr=AtmConfigAddr, mpcStatRxMpoaDataPlanePurges=mpcStatRxMpoaDataPlanePurges, mpcIngressCacheEgressCacheTag=mpcIngressCacheEgressCacheTag, mpcStatRxNhrpPurgeRequests=mpcStatRxNhrpPurgeRequests, mpcConfigMode=mpcConfigMode, mpcConfigEntry=mpcConfigEntry, mpcActualHoldDownTime=mpcActualHoldDownTime, mpcCtrlAtmAddr=mpcCtrlAtmAddr, mpcIngressCacheTable=mpcIngressCacheTable, mpcStatRxErrUnrecognizedExtensions=mpcStatRxErrUnrecognizedExtensions, mpcMpsIndex=mpcMpsIndex, mpcStatRxMpoaEgressCachePurgeReplies=mpcStatRxMpoaEgressCachePurgeReplies, mpcIngressCacheSigErrCode=mpcIngressCacheSigErrCode, mpcStatRxErrProtoAddrUnreachables=mpcStatRxErrProtoAddrUnreachables, InternetworkAddrType=InternetworkAddrType, mpcStatTxMpoaResolveRequests=mpcStatTxMpoaResolveRequests, mpcStatRxMpoaResolveReplyInsufSCResources=mpcStatRxMpoaResolveReplyInsufSCResources, mpcIngressCacheDestInetworkAddrType=mpcIngressCacheDestInetworkAddrType, mpcIngressCacheEntry=mpcIngressCacheEntry, mpcStatRxMpoaResolveReplyAcks=mpcStatRxMpoaResolveReplyAcks, mpoaMIBGroups=mpoaMIBGroups, mpcActualConfigMode=mpcActualConfigMode, mpcStatRxErrInvalidReplies=mpcStatRxErrInvalidReplies)

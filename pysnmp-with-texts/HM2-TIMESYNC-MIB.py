#
# PySNMP MIB module HM2-TIMESYNC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-TIMESYNC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
HmTimeSeconds1970, hm2ConfigurationMibs, HmEnabledStatus = mibBuilder.importSymbols("HM2-TC-MIB", "HmTimeSeconds1970", "hm2ConfigurationMibs", "HmEnabledStatus")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressType, InetPortNumber, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetPortNumber", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, MibIdentifier, IpAddress, ModuleIdentity, NotificationType, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, iso, Gauge32, Unsigned32, Bits, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibIdentifier", "IpAddress", "ModuleIdentity", "NotificationType", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "iso", "Gauge32", "Unsigned32", "Bits", "ObjectIdentity")
DisplayString, TruthValue, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "RowStatus", "TextualConvention")
hm2TimeSyncMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 50))
hm2TimeSyncMib.setRevisions(('2011-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2TimeSyncMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2TimeSyncMib.setLastUpdated('201103160000Z')
if mibBuilder.loadTexts: hm2TimeSyncMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2TimeSyncMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2TimeSyncMib.setDescription('Hirschmann Time Sync MIB. Copyright (C) 2011. All Rights Reserved.')
class HmSntpClientServerStatus(TextualConvention, Integer32):
    reference = 'RFC 4330 - Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI; Section 4.'
    description = "The status of the last received response from a configured server. other - None of the following enumeration values. success - The SNTP operation was successful and the system time was updated. requestTimedOut - An SNTP poll request timed out without receiving a response from the SNTP server. badDateEncoded - The time provided by the SNTP server was not valid. versionNotSupported - The SNTP version supported by the server is not compatible with the version supported by the client. This is indicated by the server returning a version later than the version configured for that server or a version of '0'. serverUnsychronized - The SNTP server is not synchronized with its peers. This is indicated via the 'leap indicator' field on the SNTP message. serverKissOfDeath - The SNTP server indicated that no further polls are to be sent to this server. This is indicated by a stratum field field equal to 0 in a message received from a server."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("other", 1), ("success", 2), ("requestTimedOut", 3), ("badDateEncoded", 4), ("versionNotSupported", 5), ("serverUnsychronized", 6), ("serverKissOfDeath", 7))

class Hm2Ptp2LogSyncIntervalTc(TextualConvention, Integer32):
    description = 'Logarithm to the base of 2 of the mean synchronization interval.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(-2, -1, 0, 1))
    namedValues = NamedValues(("msec-250", -2), ("msec-500", -1), ("sec-1", 0), ("sec-2", 1))

class Hm2Ptp2LogPdelayReqIntervalTc(TextualConvention, Integer32):
    description = 'Logarithm to the base of 2 of the minimum PDelay Request interval (used for p2p-delay).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("sec-1", 0), ("sec-2", 1), ("sec-4", 2), ("sec-8", 3), ("sec-16", 4), ("sec-32", 5))

class PtpTimeInterval(TextualConvention, OctetString):
    reference = 'IEEE 1588-2008 Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems'
    description = 'The scaledNanoseconds member is the time interval expressed in units of nanoseconds and multiplied by 2^+16. Positive or negative time intervals outside the maximum range of this data type shall be encoded as the largest positive and negative values of the data type respectively. For example: 2.5 ns is expressed as: (hex) 0x0000 0000 0002 8000'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class PtpTimeStamp(TextualConvention, OctetString):
    reference = 'IEEE P1588 Standard '
    description = 'first 48 bit: seconds since 1.1.1970 last 32 bit: nanoseconds'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(10, 10)
    fixedLength = 10

class PtpPortIdentity(TextualConvention, OctetString):
    reference = 'IEEE 1588-2008 Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems'
    description = "The PtpPortIdentity type identifies a PTP port. The first 8 octets within this value specifies the ClockIdentity. The last 2 octets within this value specifies the port number. For example: '00 80 63 FF FF 00 00 00 00 01'. ClockIdentity is '008063FFFF000000' and port number is '0001'"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(10, 10)
    fixedLength = 10

class PtpClockIdentity(TextualConvention, OctetString):
    reference = 'IEEE 1588-2008 Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems'
    description = "The PtpClockIdentity type identifies a PTP clock. The PtpClockIdentity shall be in the IEEE EUI-64 format. For example: '008063FFFF000000'"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class PtpClockQuality(TextualConvention, OctetString):
    reference = 'IEEE 1588-2008 Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems'
    description = 'The PtpClockQuality represents the quality of a clock. The first octet represents the clock class. The second octet represents the clockAccuracy and the last two octets represent the offsetScaledLogVariance For example: '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

hm2TimeSyncMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 0))
hm2TimeSyncMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1))
hm2TimeSyncMibSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3))
hm2SystemTimeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 1))
hm2SntpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2))
hm2NtpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3))
hm2PtpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4))
hm2IrigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5))
hm2SystemUtcTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 1, 1), HmTimeSeconds1970()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SystemUtcTime.setStatus('current')
if mibBuilder.loadTexts: hm2SystemUtcTime.setDescription('Time measured in seconds since 00:00:00 UTC, January 1, 1970. The clock of the device may be set using this variable.')
hm2SystemTimeSource = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 1), ("sntp", 2), ("ntp", 3), ("ptp", 4), ("gps", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SystemTimeSource.setStatus('current')
if mibBuilder.loadTexts: hm2SystemTimeSource.setDescription('Shows the source of the system time.')
hm2SystemLocalTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SystemLocalTime.setStatus('current')
if mibBuilder.loadTexts: hm2SystemLocalTime.setDescription('The current local time. This includes the timezone offset and if supported summertime offset. Measured in seconds since 00:00:00, January 1, 1970.')
hm2SystemLocalOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-780, 840)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SystemLocalOffset.setStatus('current')
if mibBuilder.loadTexts: hm2SystemLocalOffset.setDescription('The difference between the local timezone and UTC in minutes.')
hm2SntpServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 1))
hm2SntpServerBroadcastGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2))
hm2SntpClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3))
hm2SntpServerAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerAdminState.setDescription('Enables/disables SNTP server admin mode.')
hm2SntpServerPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 1, 2), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(123)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerPort.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerPort.setDescription('The local port number used to listen for client requests.')
hm2SntpServerOnlyIfSync = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 1, 3), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerOnlyIfSync.setReference('RFC4330 - 6. SNTP Server Operations')
if mibBuilder.loadTexts: hm2SntpServerOnlyIfSync.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerOnlyIfSync.setDescription('The SNTP server is enabled only if synchronized to another external time reference. (e.g. NTP or PTP).')
hm2SntpServerStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("notSynchronized", 2), ("syncToLocal", 3), ("syncToRefclock", 4), ("syncToRemoteServer", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SntpServerStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerStatus.setDescription('Operational status of the SNTP server.')
hm2SntpServerBroadcastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerBroadcastAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastAdminState.setDescription('Enables/disables SNTP server broadcast admin mode.')
hm2SntpServerBroadcastAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 2), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerBroadcastAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastAddrType.setDescription('Address type.')
hm2SntpServerBroadcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerBroadcastAddr.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastAddr.setDescription('Destination address for SNTP broadcast or multicast.')
hm2SntpServerBroadcastPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 4), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(123)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerBroadcastPort.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastPort.setDescription('The port number to send the broadcast packets to the clients.')
hm2SntpServerBroadcastInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1024)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpServerBroadcastInterval.setReference('RFC4330 - 6. SNTP Server Operations')
if mibBuilder.loadTexts: hm2SntpServerBroadcastInterval.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastInterval.setDescription('Interval of SNTP broadcast messages send in seconds.')
hm2SntpServerBroadcastVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 10), )
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanTable.setDescription('This table contains all VLANs used for SNTP server broadcast or multicast messages.')
hm2SntpServerBroadcastVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 10, 1), ).setIndexNames((0, "HM2-TIMESYNC-MIB", "hm2SntpServerBroadcastVlan"))
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanEntry.setDescription('The SNTP broadcast server VLAN objects.')
hm2SntpServerBroadcastVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlan.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlan.setDescription('VLAN used for SNTP server broadcast or multicast messages.')
hm2SntpServerBroadcastVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 2, 10, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SntpServerBroadcastVlanRowStatus.setDescription("Indicates the status of an entry in this table, and is used to create/delete entries. Objects within this table can by changed while the status is 'active'.")
hm2SntpClientAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpClientAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientAdminState.setDescription('Enables/disables the SNTP client admin mode.')
hm2SntpClientOperatingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("broadcast", 2))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpClientOperatingMode.setReference('RFC4330 - 5. SNTP Client Operations')
if mibBuilder.loadTexts: hm2SntpClientOperatingMode.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientOperatingMode.setDescription("Enables/disables SNTP client operating mode. In 'unicast' mode, the client sends a request to a designated unicast server and expects a reply from that server. In 'broadcast' client mode, it sends no request and waits for a broadcast from one or more broadcast servers.")
hm2SntpClientDisableAfterSync = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 3), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpClientDisableAfterSync.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientDisableAfterSync.setDescription("When set to 'enable' the SNTP client is disabled after the device is synchronized the first time successfully to a SNTP server.")
hm2SntpClientRequestInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpClientRequestInterval.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientRequestInterval.setDescription('SNTP client request interval in seconds.')
hm2SntpClientStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5))).clone(namedValues=NamedValues(("disabled", 1), ("notSynchronized", 2), ("synchronizedToRemoteServer", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SntpClientStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientStatus.setDescription('Overall operational status of the SNTP client.')
hm2SntpClientBroadcastRecvTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 2048)).clone(320)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SntpClientBroadcastRecvTimeout.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientBroadcastRecvTimeout.setDescription("Time in seconds after the client in broadcast client mode will change the status from 'synchronizedToRemoteServer' to 'notSynchronized' if no broadcast packets are received.")
hm2SntpClientServerAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10), )
if mibBuilder.loadTexts: hm2SntpClientServerAddrTable.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerAddrTable.setDescription('This table contains objects to configure SNTP client connections.')
hm2SntpClientServerAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1), ).setIndexNames((0, "HM2-TIMESYNC-MIB", "hm2SntpClientServerIndex"))
if mibBuilder.loadTexts: hm2SntpClientServerAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerAddrEntry.setDescription('The SNTP client connection objects.')
hm2SntpClientServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: hm2SntpClientServerIndex.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerIndex.setDescription('Index for server table.')
hm2SntpClientServerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpClientServerAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerAddrType.setDescription('Address type.')
hm2SntpClientServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpClientServerAddr.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerAddr.setDescription('The address of the external time server.')
hm2SntpClientServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 4), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(123)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpClientServerPort.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerPort.setDescription('The port number of the external time server.')
hm2SntpClientServerDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpClientServerDescr.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerDescr.setDescription('The description of the server configured.')
hm2SntpClientServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 6), HmSntpClientServerStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SntpClientServerStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerStatus.setDescription('Status of the SNTP client - server connection.')
hm2SntpClientServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 2, 3, 10, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SntpClientServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientServerRowStatus.setDescription("Indicates the status of an entry in this table, and is used to create/delete entries. Objects within this table can by changed while the status is 'active'.")
hm2NtpGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 1))
hm2NtpOperatingState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("notSynchronized", 2), ("syncToLocal", 3), ("syncToRefclock", 4), ("syncToRemoteServer", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NtpOperatingState.setStatus('current')
if mibBuilder.loadTexts: hm2NtpOperatingState.setDescription('Operational status of the NTP server/client.')
hm2NtpServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 2))
hm2NtpServerConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 2, 1))
hm2NtpServerAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 2, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NtpServerAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2NtpServerAdminState.setDescription('Enables/disables the NTP server.')
hm2NtpServerOperatingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("symmetric", 1), ("client-server", 2))).clone('client-server')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NtpServerOperatingMode.setStatus('current')
if mibBuilder.loadTexts: hm2NtpServerOperatingMode.setDescription('NTP server operating mode.')
hm2NtpServerLocalClockStratum = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NtpServerLocalClockStratum.setStatus('current')
if mibBuilder.loadTexts: hm2NtpServerLocalClockStratum.setDescription('The stratum to be used for the case that the server is only synchronized to the local clock')
hm2NtpClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3))
hm2NtpClientConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 1))
hm2NtpClientAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NtpClientAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientAdminState.setDescription('Enables/disables the NTP client.')
hm2NtpClientOperatingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("broadcast", 2))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NtpClientOperatingMode.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientOperatingMode.setDescription('NTP client operating mode.')
hm2NtpClientServerAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4), )
if mibBuilder.loadTexts: hm2NtpClientServerAddrTable.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerAddrTable.setDescription('This table contains variables for each interface of the switch.')
hm2NtpClientServerAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1), ).setIndexNames((0, "HM2-TIMESYNC-MIB", "hm2NtpClientServerIndex"))
if mibBuilder.loadTexts: hm2NtpClientServerAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerAddrEntry.setDescription('This entry contains variables for each interface of the switch.')
hm2NtpClientServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: hm2NtpClientServerIndex.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerIndex.setDescription('Index for Server table.')
hm2NtpClientServerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerAddressType.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerAddressType.setDescription('Address type for external time server. Currently, only IPv4 and DNS is supported.')
hm2NtpClientServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerAddress.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerAddress.setDescription('The address of the external time server.')
hm2NtpClientServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 4), InetPortNumber().clone(123)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerPort.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerPort.setDescription('The port number of the external time server. Zero is not allowed as port number.')
hm2NtpClientServerInitialBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 5), HmEnabledStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerInitialBurst.setReference('RFC5905 - 52. Poll Process Operations')
if mibBuilder.loadTexts: hm2NtpClientServerInitialBurst.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerInitialBurst.setDescription('The initial burst is intended to speed up the initial synchronization. Use with caution as it can cause a overload situation on the server.')
hm2NtpClientServerBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 6), HmEnabledStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerBurst.setReference('RFC5905 - 52. Poll Process Operations')
if mibBuilder.loadTexts: hm2NtpClientServerBurst.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerBurst.setDescription('The burst mode can be used to increase the precision on links with high jitter e.g. GSM/UMTS links')
hm2NtpClientServerPrefer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerPrefer.setReference('RFC5905 - 96. System Process')
if mibBuilder.loadTexts: hm2NtpClientServerPrefer.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerPrefer.setDescription('The prefer flag can be used to mark the peer as preferred. Among a set of correctly operating peers, this one will be chosen as synchronization source.')
hm2NtpClientServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("protocolError", 2), ("notSynchronized", 3), ("notResponding", 4), ("synchronizing", 5), ("synchronized", 6), ("genericError", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NtpClientServerStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerStatus.setDescription('Status of the NTP client server connection.')
hm2NtpClientServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 4, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientServerRowStatus.setDescription("Indicates the status of an entry in this table, and is used to create/delete entries. Objects within this table can be changed while the status is 'active'.")
hm2NtpClientListenAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5), )
if mibBuilder.loadTexts: hm2NtpClientListenAddrTable.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrTable.setDescription('Client table.')
hm2NtpClientListenAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1), ).setIndexNames((0, "HM2-TIMESYNC-MIB", "hm2NtpClientListenAddrIndex"))
if mibBuilder.loadTexts: hm2NtpClientListenAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrEntry.setDescription('Client entry.')
hm2NtpClientListenAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: hm2NtpClientListenAddrIndex.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrIndex.setDescription('Index for server table.')
hm2NtpClientListenAddrAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientListenAddrAddressType.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrAddressType.setDescription('Address type for external time server. Currently, only IPv4 and DNS is supported.')
hm2NtpClientListenAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientListenAddrAddress.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrAddress.setDescription('The address of the external time server.')
hm2NtpClientListenAddrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 4), InetPortNumber().clone(123)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientListenAddrPort.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrPort.setDescription('The port number of the external time server. Zero is not allowed as port number.')
hm2NtpClientListenAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("protocolError", 2), ("notSynchronized", 3), ("notResponding", 4), ("synchronizing", 5), ("synchronized", 6), ("genericError", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NtpClientListenAddrStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrStatus.setDescription('Status of the NTP client server connection.')
hm2NtpClientListenAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 3, 3, 5, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2NtpClientListenAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NtpClientListenAddrRowStatus.setDescription("Indicates the status of an entry in this table, and is used to create/delete entries. Objects within this table can by changed while the status is 'active'.")
hm2PtpGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1))
hm2PtpEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpEnable.setStatus('current')
if mibBuilder.loadTexts: hm2PtpEnable.setDescription('Enable or disable the Precision Time Protocol (PTP) on this node.')
hm2PtpClockMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("v2-boundary-clock", 2), ("v2-transparent-clock", 3))).clone('v2-transparent-clock')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpClockMode.setStatus('current')
if mibBuilder.loadTexts: hm2PtpClockMode.setDescription('This members value shall indicate which clock mode is used.')
hm2PtpProfile = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user-defined", 1), ("default-e2e", 2), ("default-p2p", 3))).clone('default-e2e')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpProfile.setStatus('current')
if mibBuilder.loadTexts: hm2PtpProfile.setDescription('Configures PTP parameters to a specific profile. Setting the object to user-defined (1) has no effect.')
hm2PtpIsSynchronized = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PtpIsSynchronized.setStatus('current')
if mibBuilder.loadTexts: hm2PtpIsSynchronized.setDescription('If the clock is synchronized to the current Master this object is set to true. Otherwise it is set to false. The clock sets this object to true, if the offset (ns) to the current Master is less than hm2PtpSyncLowerBound. The clock sets this object to false, if the offset (ns) to the current Master is bigger than hm2PtpSyncUpperBound.')
hm2PtpSyncLowerBound = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999999999)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpSyncLowerBound.setStatus('current')
if mibBuilder.loadTexts: hm2PtpSyncLowerBound.setDescription('This object defines when the hm2PtpIsSynchronized object is set to true. If the absolute value of the offset is smaller than hm2PtpSyncLowerBound, the hm2PtpIsSynchronized is set true. The value is interpreted as nanoseconds.')
hm2PtpSyncUpperBound = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(31, 1000000000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpSyncUpperBound.setStatus('current')
if mibBuilder.loadTexts: hm2PtpSyncUpperBound.setDescription('This object defines when the hm2PtpIsSynchronized object is set to false. If the absolute value of the offset is bigger than hm2PtpSyncUpperBound, the hm2PtpIsSynchronized is set false. The value is interpreted as nanoseconds.')
hm2PtpAbsMaxOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PtpAbsMaxOffset.setStatus('current')
if mibBuilder.loadTexts: hm2PtpAbsMaxOffset.setDescription('This members value shall indicate the absolute value for the maximum offset between its parent and this node. The value is set to zero if the offset is the first time smaller than hm2PtpSyncLowerBound. Offsets bigger than +/-1 second are indicated by the maximum value.')
hm2PtpTimeSeconds = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 8), PtpTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PtpTimeSeconds.setStatus('current')
if mibBuilder.loadTexts: hm2PtpTimeSeconds.setDescription('Current PTP time in PTP timescale')
hm2PtpManagement = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PtpManagement.setStatus('current')
if mibBuilder.loadTexts: hm2PtpManagement.setDescription('If set to true PTP management via PTP management messages is enabled.')
hm2Ptp2Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2))
hm2Ptp2Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1))
hm2Ptp2TwoStepClock = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TwoStepClock.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TwoStepClock.setDescription('A value of true indicates that this node is a two-step device.')
hm2Ptp2ClockIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 2), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ClockIdentity.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ClockIdentity.setDescription('This value is the clock identity of the local clock.')
hm2Ptp2ClockQuality = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 3), PtpClockQuality()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ClockQuality.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ClockQuality.setDescription('Clock quality of the local clock.')
hm2Ptp2ClockClass = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ClockClass.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ClockClass.setDescription('First octet of hm2Ptp2ClockQuality. This represents the clock class of the local clock.')
hm2Ptp2ClockAccuracy = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))).clone(namedValues=NamedValues(("within25ns", 32), ("within100ns", 33), ("within250ns", 34), ("within1000ns", 35), ("within2500ns", 36), ("within10us", 37), ("within25us", 38), ("within100us", 39), ("within250us", 40), ("within1000us", 41), ("within2500us", 42), ("within10ms", 43), ("within25ms", 44), ("within100ms", 45), ("within250ms", 46), ("within1s", 47), ("within10s", 48), ("beyond10s", 49), ("unknown", 254)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ClockAccuracy.setDescription('Second octet of hm2Ptp2ClockQuality. This represents the clock accuracy of the local clock.')
hm2Ptp2ClockVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ClockVariance.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ClockVariance.setDescription('Last two octets of hm2Ptp2ClockQuality. This represents the clock variance of the local clock.')
hm2Ptp2Priority1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2Priority1.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2Priority1.setDescription('Priority 1 value of the local clock')
hm2Ptp2Priority2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2Priority2.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2Priority2.setDescription('Priority 2 value of the local clock')
hm2Ptp2DomainNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2DomainNumber.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2DomainNumber.setDescription('PTP domain number of the local clock.')
hm2Ptp2StepsRemoved = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2StepsRemoved.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2StepsRemoved.setDescription('The value of hm2Ptp2StepsRemoved is the number of communication paths traversed between the local clock and the grandmaster clock.')
hm2Ptp2OffsetFromMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 11), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2OffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2OffsetFromMaster.setDescription('Current value of the time difference between master and slave measured by this clock.')
hm2Ptp2MeanPathDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 12), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2MeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2MeanPathDelay.setDescription('Current value of the mean propagation time (e2e-delay) between Master and Slave. This is only valid if hm2Ptp2DelayMechanism is set to e2e on the current slave port.')
hm2Ptp2ParentPortIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 13), PtpPortIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ParentPortIdentity.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ParentPortIdentity.setDescription('The port identity value of the port on the master that issues the synchronization messages used to synchronize this clock.')
hm2Ptp2ParentStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ParentStats.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ParentStats.setDescription('A value of True indicates that the objects hm2Ptp2ObservedParentOffsetScaledLogVariance and hm2Ptp2ObservedParentClockPhaseChangeRate are valid.')
hm2Ptp2ObservedParentOffsetScaledLogVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ObservedParentOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ObservedParentOffsetScaledLogVariance.setDescription('Estimate of the parent clocks PTP variance observed by this clock.')
hm2Ptp2ObservedParentClockPhaseChangeRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2ObservedParentClockPhaseChangeRate.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2ObservedParentClockPhaseChangeRate.setDescription('Estimate of the phase change rate (drift) observed by this clock.')
hm2Ptp2GrandmasterIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 17), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterIdentity.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterIdentity.setDescription('ClockIdentity of the Grandmaster clock synchronizing this clock.')
hm2Ptp2GrandmasterClockQuality = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 18), PtpClockQuality()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockQuality.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockQuality.setDescription('ClockQuality of the Grandmaster clock synchronizing this clock.')
hm2Ptp2GrandmasterClockClass = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockClass.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockClass.setDescription('First octet of hm2Ptp2GrandmasterClockQuality. This represents the grand masters clock class.')
hm2Ptp2GrandmasterClockAccuracy = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))).clone(namedValues=NamedValues(("within25ns", 32), ("within100ns", 33), ("within250ns", 34), ("within1000ns", 35), ("within2500ns", 36), ("within10us", 37), ("within25us", 38), ("within100us", 39), ("within250us", 40), ("within1000us", 41), ("within2500us", 42), ("within10ms", 43), ("within25ms", 44), ("within100ms", 45), ("within250ms", 46), ("within1s", 47), ("within10s", 48), ("beyond10s", 49), ("unknown", 254)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockAccuracy.setDescription('Second octet of hm2Ptp2GrandmasterClockAccuracy. This represents the grand masters clock accuracy.')
hm2Ptp2GrandmasterClockVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockVariance.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterClockVariance.setDescription('Last two octets of hm2Ptp2GrandmasterClockQuality. This represents the grand masters clock variance.')
hm2Ptp2GrandmasterPriority1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterPriority1.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterPriority1.setDescription('Priority 1 value of the grand master clock.')
hm2Ptp2GrandmasterPriority2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2GrandmasterPriority2.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2GrandmasterPriority2.setDescription('Priority 2 value of the grand master clock.')
hm2Ptp2CurrentUtcOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767)).clone(37)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2CurrentUtcOffset.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2CurrentUtcOffset.setDescription('Current difference between the PTP timescale (TAI) and UTC in seconds.')
hm2Ptp2CurrentUtcOffsetValid = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2CurrentUtcOffsetValid.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2CurrentUtcOffsetValid.setDescription('A value of True indicates that the hm2Ptp2CurrentUtcOffset is known to be correct.')
hm2Ptp2Leap59 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 26), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2Leap59.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2Leap59.setDescription('A value of true indicates that the last minute of the current UTC day contains 59 seconds.')
hm2Ptp2Leap61 = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 27), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2Leap61.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2Leap61.setDescription('A value of true indicates that the last minute of the current UTC day contains 61 seconds.')
hm2Ptp2TimeTraceable = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 28), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TimeTraceable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TimeTraceable.setDescription('A value of True indicates that the current time is traceable to a primary reference.')
hm2Ptp2FrequencyTraceable = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 29), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2FrequencyTraceable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2FrequencyTraceable.setDescription('A value of True indicates that the frequency determining the timescale is traceable to a primary reference.')
hm2Ptp2PtpTimescale = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 30), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2PtpTimescale.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PtpTimescale.setDescription('A value of True indicates that the clocks timescale is PTP.')
hm2Ptp2TimeSource = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160))).clone(namedValues=NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOscillator", 160))).clone('internalOscillator')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TimeSource.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TimeSource.setDescription('The source of time used by the Grandmaster clock.')
hm2Ptp2PortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2), )
if mibBuilder.loadTexts: hm2Ptp2PortTable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PortTable.setDescription('This table contains variables for each PTP2 port of the switch.')
hm2Ptp2PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2Ptp2PortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PortEntry.setDescription('Entry for one port.')
hm2Ptp2PortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2PortEnable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PortEnable.setDescription('Enable or disable the sending and receiving / processing of PTP synchronization messages.')
hm2Ptp2PortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("pre-master", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2PortState.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PortState.setDescription('State of the PTP2 port instance.')
hm2Ptp2LogDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2LogDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2LogDelayReqInterval.setDescription('Logarithm to the base of 2 of the minimum DelayRequest interval used to measure the e2e-delay.')
hm2Ptp2PeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 4), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2PeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PeerMeanPathDelay.setDescription('If hm2Ptp2DelayMechanism is set to p2p this value is an estimate of the current one-way propagation delay (p2p-delay).')
hm2Ptp2LogAnnounceInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("sec-1", 0), ("sec-2", 1), ("sec-4", 2), ("sec-8", 3), ("sec-16", 4))).clone('sec-2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2LogAnnounceInterval.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2LogAnnounceInterval.setDescription('Logarithm to the base of 2 of the mean announce interval.')
hm2Ptp2AnnounceReceiptTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2AnnounceReceiptTimeout.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2AnnounceReceiptTimeout.setDescription('Announce receipt timeout in multiples of hm2Ptp2LogAnnounceInterval.')
hm2Ptp2LogSyncInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 7), Hm2Ptp2LogSyncIntervalTc().clone('sec-1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2LogSyncInterval.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2LogSyncInterval.setDescription('Logarithm to the base of 2 of the mean synchronization interval.')
hm2Ptp2DelayMechanism = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254))).clone(namedValues=NamedValues(("e2e", 1), ("p2p", 2), ("disabled", 254))).clone('e2e')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2DelayMechanism.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2DelayMechanism.setDescription('This value indicates the propagation delay measuring option used by this port.')
hm2Ptp2LogPdelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 9), Hm2Ptp2LogPdelayReqIntervalTc().clone('sec-1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2LogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2LogPdelayReqInterval.setDescription('Logarithm to the base of 2 of the minimum PDelay Request interval (used for p2p-delay).')
hm2Ptp2VersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptpVersion1", 1), ("ptpVersion2", 2))).clone('ptpVersion2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2VersionNumber.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2VersionNumber.setDescription('PTP version in use on this port (always ptpVersion2).')
hm2Ptp2NetworkProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("udpIpv4", 1), ("ieee8023", 3))).clone('ieee8023')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2NetworkProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2NetworkProtocol.setDescription('Current configured network transport protocol of this port.')
hm2Ptp2V1Compatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2V1Compatibility.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2V1Compatibility.setDescription('If set to on all PTPv2 messages will be padded to the length of a PTPv1 frame. This is required by some hardware.')
hm2Ptp2DelayAsymmetry = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2000000000, 2000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2DelayAsymmetry.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2DelayAsymmetry.setDescription('Asymmetry of the link connected to this port in nanoseconds. The hm2Ptp2DelayAsymmetry is positive when the master-to-slave propagation time is longer than the slave-to-master propagation time.')
hm2Ptp2PortCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 14), Bits().clone(namedValues=NamedValues(("reserved", 0), ("one-step", 1), ("e2e-delay", 2), ("p2p-delay", 3), ("ptp2Ieee8023", 4), ("ptp2UdpIpv4", 5), ("ptp2UdpIpv6", 6), ("asymmCorrection", 7), ("halfDuplex", 8), ("ptp2UdpE2EGlobal", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2PortCapability.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2PortCapability.setDescription('This object shows the capability of the ptp port.')
hm2Ptp2VlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4042)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2VlanID.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2VlanID.setDescription('VLAN in which PTP packets are send. With a value of -1 all packets are send untagged')
hm2Ptp2VlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2VlanPriority.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2VlanPriority.setDescription('VLAN priority of tagged ptp packets')
hm2Ptp2TCObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3))
hm2Ptp2TCConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1))
hm2Ptp2TCClockIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 1), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCClockIdentity.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCClockIdentity.setDescription('This value is the clock identity of the transparent clock.')
hm2Ptp2TCDelayMechanism = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254))).clone(namedValues=NamedValues(("e2e", 1), ("p2p", 2), ("e2e-optimized", 3), ("disabled", 254))).clone('e2e')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCDelayMechanism.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCDelayMechanism.setDescription('Configures the transparent clock to be either a e2e- or p2p-transparent clock. If supported a value of e2e-optimized sets the clock to e2e mode where delay requests are only forwarded on the port where the current Master (hm2Ptp2TCCurrentMaster) is connected.')
hm2Ptp2TCPrimaryDomain = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCPrimaryDomain.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCPrimaryDomain.setDescription('PTP domain number of the primary syntonization domain.')
hm2Ptp2TCSyntonized = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCSyntonized.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCSyntonized.setDescription('A value of true indicates that the syntonization of the transparent clock is enabled.')
hm2Ptp2TCNetworkProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("udpIpv4", 1), ("ieee8023", 3))).clone('ieee8023')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCNetworkProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCNetworkProtocol.setDescription('Current configured network transport protocol of the transparent clock.')
hm2Ptp2TCCurrentMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 6), PtpPortIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCCurrentMaster.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCCurrentMaster.setDescription('The port identity value of the port on the master that issues the synchronization messages used to syntonize/synchronize this clock.')
hm2Ptp2TCMultiDomainMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCMultiDomainMode.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCMultiDomainMode.setDescription('If set to false, PTP messages from domains other than hm2Ptp2TCPrimaryDomain are ignored.')
hm2Ptp2TCSyncLocalClock = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCSyncLocalClock.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCSyncLocalClock.setDescription('Enable synchronisation of the local clock (TC hybrid mode). This requires syntonization to be enabled. All transparent clock operations are still done based on the syntonized clock.')
hm2Ptp2TCOffsetFromMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 9), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCOffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCOffsetFromMaster.setDescription('Current value of the time difference between Master and this clock measured by this clock. This object is only valid if hm2Ptp2TCSyncLocalClock is set to true.')
hm2Ptp2TCMeanPathDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 10), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCMeanPathDelay.setDescription('Current value of the mean propagation time (e2e-delay) between Master and Slave. This object is only valid for e2e-transparent-clock and hm2Ptp2TCSyncLocalClock is set to true.')
hm2Ptp2TCVlanID = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4095)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCVlanID.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCVlanID.setDescription('VLAN in which PTP packets are send. With a value of -1 all packets are send untagged.')
hm2Ptp2TCVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCVlanPriority.setDescription('VLAN priority of tagged PTP packets.')
hm2Ptp2TCCapability = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 1, 13), Bits().clone(namedValues=NamedValues(("reserved", 0), ("one-step", 1), ("e2e-delay", 2), ("p2p-delay", 3), ("ptp2Ieee8023", 4), ("ptp2UdpIpv4", 5), ("ptp2UdpIpv6", 6), ("asymmCorrection", 7), ("halfDuplex", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCCapability.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCCapability.setDescription('This object shows the capability of the TC.')
hm2Ptp2TCPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2), )
if mibBuilder.loadTexts: hm2Ptp2TCPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCPortTable.setDescription('This table contains variables for each PTP2 TC port of the switch.')
hm2Ptp2TCPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2Ptp2TCPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCPortEntry.setDescription('Entry for one port.')
hm2Ptp2TCPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCPortEnable.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCPortEnable.setDescription('Enable or disable the sending and receiving / processing of PTP synchronization messages.')
hm2Ptp2TCLogPdelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1, 2), Hm2Ptp2LogPdelayReqIntervalTc().clone('sec-1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCLogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCLogPdelayReqInterval.setDescription('Logarithm to the base of 2 of the minimum PDelay Request interval (used for p2p-delay).')
hm2Ptp2TCFaulty = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCFaulty.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCFaulty.setDescription('True if port is in Faulty state.')
hm2Ptp2TCPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1, 4), PtpTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Ptp2TCPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCPeerMeanPathDelay.setDescription('This value is an estimate of the current one way propagation delay of a p2p-transparent-clock.')
hm2Ptp2TCDelayAsymmetry = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 4, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2000000000, 2000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Ptp2TCDelayAsymmetry.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2TCDelayAsymmetry.setDescription('Asymmetry of the link connected to this port in nanoseconds. The hm2Ptp2TCDelayAsymmetry is positive when the master-to-slave propagation time is longer than the slave-to-master propagation time.')
hm2IrigAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IrigAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2IrigAdminStatus.setDescription('Enables/disables the IRIG-B output.')
hm2IrigMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("irig-b000", 0), ("irig-b001", 1), ("irig-b002", 2), ("irig-b003", 3), ("irig-b004", 4), ("irig-b005", 5), ("irig-b006", 6), ("irig-b007", 7))).clone('irig-b003')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IrigMode.setStatus('current')
if mibBuilder.loadTexts: hm2IrigMode.setDescription('Set the IRIG Mode, allowed values: (See https://wsmrc2vger.wsmr.army.mil/rcc/manuals/200-04/TT-45.pdf) irig-b000 (0) - Mode IRIG B000, BCDtoy, CF, SBS irig-b001 (1) - Mode IRIG B001, BCDtoy, CF irig-b002 (2) - Mode IRIG B002, BCDtoy irig-b003 (3) - Mode IRIG B003, BCDtoy, SBS irig-b004 (4) - Mode IRIG B004, BCDtoy, BCDyear, CF, SBS irig-b005 (5) - Mode IRIG B005, BCDtoy, BCDyear, CF irig-b006 (6) - Mode IRIG B006, BCDtoy, BCDyear irig-b007 (7) - Mode IRIG B007, BCDtoy, BCDyear, SBS with BCDtoy: binary coded decimal time of year BCDyear: binary coded decimal year CF: control functions SBS: straight binary seconds of day only modes b002,B003,B006 and b007 are supported.')
hm2IrigPpsAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 3), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IrigPpsAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2IrigPpsAdminStatus.setDescription('Enables/disables the pps output.')
hm2IrigTimeMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("utc", 1), ("local", 2))).clone('utc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2IrigTimeMode.setStatus('current')
if mibBuilder.loadTexts: hm2IrigTimeMode.setDescription('Define the IRIG-B time base (UTC or local).')
hm2IrigOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 5), HmEnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IrigOperStatus.setStatus('current')
if mibBuilder.loadTexts: hm2IrigOperStatus.setDescription('Current operational status of the IRIG-B output. ')
hm2IrigTimeQuality = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 50, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("locked", 0), ("within1ns", 1), ("within10ns", 2), ("within100ns", 3), ("within1us", 4), ("within10us", 5), ("within100us", 6), ("within1ms", 7), ("within10ms", 8), ("within100ms", 9), ("within1s", 10), ("within10s", 11), ("within100s", 12), ("within1000s", 13), ("within10000s", 14), ("failure", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2IrigTimeQuality.setStatus('current')
if mibBuilder.loadTexts: hm2IrigTimeQuality.setDescription('Current IRIG-B time quality according to IEEE 1344.')
hm2TimeSyncSystemTimeSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 1))
hm2TimeSyncSntpSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 2))
hm2TimeSyncNtpSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 3))
hm2TimeSyncPtpSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 4))
hm2TimeSyncIrigSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 5))
hm2TimeSyncSntpSESIpv4PortNumberPairInUse = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 2, 1))
if mibBuilder.loadTexts: hm2TimeSyncSntpSESIpv4PortNumberPairInUse.setStatus('current')
if mibBuilder.loadTexts: hm2TimeSyncSntpSESIpv4PortNumberPairInUse.setDescription('Indicates that the given IPv4 address / port number combination is already in use.')
hm2TimeSyncSntpSESDnsPortNumberPairInUse = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 50, 3, 2, 2))
if mibBuilder.loadTexts: hm2TimeSyncSntpSESDnsPortNumberPairInUse.setStatus('current')
if mibBuilder.loadTexts: hm2TimeSyncSntpSESDnsPortNumberPairInUse.setDescription('Indicates that the given DNS name / port number combination is already in use.')
hm2Ptp2SynchronizationChange = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 50, 0, 1)).setObjects(("HM2-TIMESYNC-MIB", "hm2PtpIsSynchronized"))
if mibBuilder.loadTexts: hm2Ptp2SynchronizationChange.setStatus('current')
if mibBuilder.loadTexts: hm2Ptp2SynchronizationChange.setDescription('This notification is sent if the PTP synchronization status is changed.')
hm2SntpClientSynchronizationChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 50, 0, 10)).setObjects(("HM2-TIMESYNC-MIB", "hm2SntpClientStatus"))
if mibBuilder.loadTexts: hm2SntpClientSynchronizationChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hm2SntpClientSynchronizationChangeTrap.setDescription('This notification is sent if the SNTP synchronization status (hm2SntpClientStatus) is changed.')
mibBuilder.exportSymbols("HM2-TIMESYNC-MIB", hm2SntpServerStatus=hm2SntpServerStatus, hm2TimeSyncMib=hm2TimeSyncMib, hm2SntpServerBroadcastInterval=hm2SntpServerBroadcastInterval, hm2SntpClientServerAddr=hm2SntpClientServerAddr, hm2Ptp2Leap61=hm2Ptp2Leap61, hm2PtpClockMode=hm2PtpClockMode, hm2NtpServerOperatingMode=hm2NtpServerOperatingMode, hm2IrigTimeQuality=hm2IrigTimeQuality, hm2TimeSyncSntpSESGroup=hm2TimeSyncSntpSESGroup, hm2Ptp2VlanPriority=hm2Ptp2VlanPriority, hm2TimeSyncSystemTimeSESGroup=hm2TimeSyncSystemTimeSESGroup, hm2Ptp2GrandmasterPriority2=hm2Ptp2GrandmasterPriority2, hm2Ptp2ClockIdentity=hm2Ptp2ClockIdentity, hm2Ptp2PortEnable=hm2Ptp2PortEnable, hm2Ptp2ClockClass=hm2Ptp2ClockClass, hm2Ptp2Objects=hm2Ptp2Objects, hm2Ptp2NetworkProtocol=hm2Ptp2NetworkProtocol, hm2Ptp2TimeTraceable=hm2Ptp2TimeTraceable, hm2NtpClientServerPort=hm2NtpClientServerPort, hm2NtpServerConfigGroup=hm2NtpServerConfigGroup, hm2SntpClientServerDescr=hm2SntpClientServerDescr, hm2Ptp2TwoStepClock=hm2Ptp2TwoStepClock, hm2IrigMode=hm2IrigMode, hm2Ptp2CurrentUtcOffset=hm2Ptp2CurrentUtcOffset, hm2NtpClientListenAddrStatus=hm2NtpClientListenAddrStatus, hm2SntpServerOnlyIfSync=hm2SntpServerOnlyIfSync, hm2NtpClientListenAddrTable=hm2NtpClientListenAddrTable, hm2Ptp2Configuration=hm2Ptp2Configuration, hm2NtpClientOperatingMode=hm2NtpClientOperatingMode, hm2NtpClientServerAddrEntry=hm2NtpClientServerAddrEntry, hm2IrigGroup=hm2IrigGroup, hm2NtpClientServerBurst=hm2NtpClientServerBurst, hm2SntpServerBroadcastGroup=hm2SntpServerBroadcastGroup, hm2SystemLocalOffset=hm2SystemLocalOffset, hm2Ptp2TimeSource=hm2Ptp2TimeSource, hm2NtpGeneralGroup=hm2NtpGeneralGroup, hm2IrigOperStatus=hm2IrigOperStatus, hm2SntpServerBroadcastVlanRowStatus=hm2SntpServerBroadcastVlanRowStatus, hm2Ptp2PortTable=hm2Ptp2PortTable, hm2Ptp2TCCapability=hm2Ptp2TCCapability, hm2Ptp2VersionNumber=hm2Ptp2VersionNumber, hm2NtpClientListenAddrEntry=hm2NtpClientListenAddrEntry, hm2Ptp2GrandmasterClockAccuracy=hm2Ptp2GrandmasterClockAccuracy, hm2Ptp2V1Compatibility=hm2Ptp2V1Compatibility, hm2NtpClientListenAddrRowStatus=hm2NtpClientListenAddrRowStatus, hm2Ptp2ClockQuality=hm2Ptp2ClockQuality, hm2SntpServerBroadcastVlanTable=hm2SntpServerBroadcastVlanTable, hm2Ptp2DelayMechanism=hm2Ptp2DelayMechanism, hm2PtpManagement=hm2PtpManagement, hm2Ptp2ParentPortIdentity=hm2Ptp2ParentPortIdentity, hm2Ptp2LogSyncInterval=hm2Ptp2LogSyncInterval, hm2Ptp2LogPdelayReqInterval=hm2Ptp2LogPdelayReqInterval, hm2SntpClientServerRowStatus=hm2SntpClientServerRowStatus, hm2TimeSyncSntpSESDnsPortNumberPairInUse=hm2TimeSyncSntpSESDnsPortNumberPairInUse, hm2Ptp2GrandmasterIdentity=hm2Ptp2GrandmasterIdentity, PYSNMP_MODULE_ID=hm2TimeSyncMib, hm2Ptp2FrequencyTraceable=hm2Ptp2FrequencyTraceable, hm2Ptp2TCVlanID=hm2Ptp2TCVlanID, hm2SntpClientSynchronizationChangeTrap=hm2SntpClientSynchronizationChangeTrap, hm2PtpIsSynchronized=hm2PtpIsSynchronized, hm2NtpServerGroup=hm2NtpServerGroup, hm2SntpServerBroadcastVlan=hm2SntpServerBroadcastVlan, hm2SystemUtcTime=hm2SystemUtcTime, hm2NtpClientServerRowStatus=hm2NtpClientServerRowStatus, hm2PtpSyncLowerBound=hm2PtpSyncLowerBound, hm2Ptp2TCNetworkProtocol=hm2Ptp2TCNetworkProtocol, hm2Ptp2TCObjects=hm2Ptp2TCObjects, hm2SntpClientServerStatus=hm2SntpClientServerStatus, hm2Ptp2DomainNumber=hm2Ptp2DomainNumber, hm2Ptp2TCDelayAsymmetry=hm2Ptp2TCDelayAsymmetry, hm2NtpClientAdminState=hm2NtpClientAdminState, hm2SntpClientDisableAfterSync=hm2SntpClientDisableAfterSync, hm2Ptp2TCPrimaryDomain=hm2Ptp2TCPrimaryDomain, hm2Ptp2TCLogPdelayReqInterval=hm2Ptp2TCLogPdelayReqInterval, hm2SntpClientStatus=hm2SntpClientStatus, hm2Ptp2GrandmasterClockClass=hm2Ptp2GrandmasterClockClass, PtpTimeStamp=PtpTimeStamp, hm2SntpServerBroadcastAdminState=hm2SntpServerBroadcastAdminState, hm2NtpClientServerAddress=hm2NtpClientServerAddress, hm2Ptp2TCFaulty=hm2Ptp2TCFaulty, hm2Ptp2ClockVariance=hm2Ptp2ClockVariance, hm2Ptp2SynchronizationChange=hm2Ptp2SynchronizationChange, hm2SystemLocalTime=hm2SystemLocalTime, hm2SntpClientServerIndex=hm2SntpClientServerIndex, PtpClockQuality=PtpClockQuality, PtpClockIdentity=PtpClockIdentity, hm2Ptp2Leap59=hm2Ptp2Leap59, hm2NtpClientListenAddrAddress=hm2NtpClientListenAddrAddress, hm2NtpClientConfigGroup=hm2NtpClientConfigGroup, hm2SntpServerBroadcastPort=hm2SntpServerBroadcastPort, PtpTimeInterval=PtpTimeInterval, hm2Ptp2ClockAccuracy=hm2Ptp2ClockAccuracy, hm2NtpGroup=hm2NtpGroup, hm2PtpEnable=hm2PtpEnable, hm2Ptp2CurrentUtcOffsetValid=hm2Ptp2CurrentUtcOffsetValid, hm2Ptp2TCVlanPriority=hm2Ptp2TCVlanPriority, hm2SystemTimeSource=hm2SystemTimeSource, hm2NtpClientGroup=hm2NtpClientGroup, hm2NtpServerAdminState=hm2NtpServerAdminState, hm2PtpTimeSeconds=hm2PtpTimeSeconds, hm2Ptp2TCCurrentMaster=hm2Ptp2TCCurrentMaster, hm2PtpGlobal=hm2PtpGlobal, hm2NtpClientServerAddrTable=hm2NtpClientServerAddrTable, hm2Ptp2PortEntry=hm2Ptp2PortEntry, hm2SntpServerBroadcastVlanEntry=hm2SntpServerBroadcastVlanEntry, hm2SntpGroup=hm2SntpGroup, hm2Ptp2VlanID=hm2Ptp2VlanID, hm2SntpServerGroup=hm2SntpServerGroup, hm2Ptp2PortCapability=hm2Ptp2PortCapability, Hm2Ptp2LogSyncIntervalTc=Hm2Ptp2LogSyncIntervalTc, hm2Ptp2LogDelayReqInterval=hm2Ptp2LogDelayReqInterval, hm2Ptp2Priority1=hm2Ptp2Priority1, hm2SntpServerAdminState=hm2SntpServerAdminState, hm2IrigAdminStatus=hm2IrigAdminStatus, hm2SntpClientAdminState=hm2SntpClientAdminState, hm2Ptp2DelayAsymmetry=hm2Ptp2DelayAsymmetry, hm2Ptp2TCOffsetFromMaster=hm2Ptp2TCOffsetFromMaster, hm2TimeSyncPtpSESGroup=hm2TimeSyncPtpSESGroup, hm2Ptp2TCPortEnable=hm2Ptp2TCPortEnable, hm2TimeSyncIrigSESGroup=hm2TimeSyncIrigSESGroup, hm2NtpClientServerPrefer=hm2NtpClientServerPrefer, hm2Ptp2LogAnnounceInterval=hm2Ptp2LogAnnounceInterval, hm2NtpServerLocalClockStratum=hm2NtpServerLocalClockStratum, hm2NtpClientServerAddressType=hm2NtpClientServerAddressType, hm2Ptp2Priority2=hm2Ptp2Priority2, PtpPortIdentity=PtpPortIdentity, hm2Ptp2TCPortTable=hm2Ptp2TCPortTable, hm2NtpClientListenAddrAddressType=hm2NtpClientListenAddrAddressType, hm2Ptp2OffsetFromMaster=hm2Ptp2OffsetFromMaster, hm2Ptp2PortState=hm2Ptp2PortState, hm2PtpSyncUpperBound=hm2PtpSyncUpperBound, hm2NtpClientServerInitialBurst=hm2NtpClientServerInitialBurst, hm2SntpClientServerAddrEntry=hm2SntpClientServerAddrEntry, hm2Ptp2TCPortEntry=hm2Ptp2TCPortEntry, hm2Ptp2ObservedParentClockPhaseChangeRate=hm2Ptp2ObservedParentClockPhaseChangeRate, hm2SntpClientRequestInterval=hm2SntpClientRequestInterval, hm2TimeSyncMibObjects=hm2TimeSyncMibObjects, hm2Ptp2MeanPathDelay=hm2Ptp2MeanPathDelay, hm2Ptp2ObservedParentOffsetScaledLogVariance=hm2Ptp2ObservedParentOffsetScaledLogVariance, hm2Ptp2TCSyncLocalClock=hm2Ptp2TCSyncLocalClock, hm2Ptp2GrandmasterClockQuality=hm2Ptp2GrandmasterClockQuality, hm2PtpGroup=hm2PtpGroup, hm2SntpClientServerAddrType=hm2SntpClientServerAddrType, hm2SntpClientOperatingMode=hm2SntpClientOperatingMode, hm2TimeSyncNtpSESGroup=hm2TimeSyncNtpSESGroup, hm2SystemTimeGroup=hm2SystemTimeGroup, hm2IrigTimeMode=hm2IrigTimeMode, hm2Ptp2TCDelayMechanism=hm2Ptp2TCDelayMechanism, hm2NtpClientServerIndex=hm2NtpClientServerIndex, hm2TimeSyncMibNotifications=hm2TimeSyncMibNotifications, hm2SntpClientServerAddrTable=hm2SntpClientServerAddrTable, hm2Ptp2StepsRemoved=hm2Ptp2StepsRemoved, hm2Ptp2PtpTimescale=hm2Ptp2PtpTimescale, hm2Ptp2TCMultiDomainMode=hm2Ptp2TCMultiDomainMode, hm2IrigPpsAdminStatus=hm2IrigPpsAdminStatus, hm2Ptp2ParentStats=hm2Ptp2ParentStats, hm2TimeSyncSntpSESIpv4PortNumberPairInUse=hm2TimeSyncSntpSESIpv4PortNumberPairInUse, hm2Ptp2TCSyntonized=hm2Ptp2TCSyntonized, hm2NtpOperatingState=hm2NtpOperatingState, hm2NtpClientListenAddrIndex=hm2NtpClientListenAddrIndex, Hm2Ptp2LogPdelayReqIntervalTc=Hm2Ptp2LogPdelayReqIntervalTc, hm2Ptp2PeerMeanPathDelay=hm2Ptp2PeerMeanPathDelay, hm2NtpClientListenAddrPort=hm2NtpClientListenAddrPort, HmSntpClientServerStatus=HmSntpClientServerStatus, hm2PtpProfile=hm2PtpProfile, hm2Ptp2TCPeerMeanPathDelay=hm2Ptp2TCPeerMeanPathDelay, hm2Ptp2AnnounceReceiptTimeout=hm2Ptp2AnnounceReceiptTimeout, hm2SntpClientGroup=hm2SntpClientGroup, hm2SntpServerBroadcastAddrType=hm2SntpServerBroadcastAddrType, hm2NtpClientServerStatus=hm2NtpClientServerStatus, hm2SntpServerBroadcastAddr=hm2SntpServerBroadcastAddr, hm2SntpServerPort=hm2SntpServerPort, hm2Ptp2GrandmasterPriority1=hm2Ptp2GrandmasterPriority1, hm2Ptp2GrandmasterClockVariance=hm2Ptp2GrandmasterClockVariance, hm2Ptp2TCConfiguration=hm2Ptp2TCConfiguration, hm2TimeSyncMibSNMPExtensionGroup=hm2TimeSyncMibSNMPExtensionGroup, hm2Ptp2TCMeanPathDelay=hm2Ptp2TCMeanPathDelay, hm2Ptp2TCClockIdentity=hm2Ptp2TCClockIdentity, hm2SntpClientBroadcastRecvTimeout=hm2SntpClientBroadcastRecvTimeout, hm2PtpAbsMaxOffset=hm2PtpAbsMaxOffset, hm2SntpClientServerPort=hm2SntpClientServerPort)

#
# PySNMP MIB module LEXMARK-MPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LEXMARK-MPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
lexmark, lexmarkModules = mibBuilder.importSymbols("LEXMARK-ROOT-MIB", "lexmark", "lexmarkModules")
AdminStatusTC, PaperTypeTC, UnitsTC, StatusTC, KeyValueTC, PaperSizeTC = mibBuilder.importSymbols("LEXMARK-TC-MIB", "AdminStatusTC", "PaperTypeTC", "UnitsTC", "StatusTC", "KeyValueTC", "PaperSizeTC")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Unsigned32, Gauge32, NotificationType, ObjectIdentity, Counter64, Integer32, Counter32, iso, Bits, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "NotificationType", "ObjectIdentity", "Counter64", "Integer32", "Counter32", "iso", "Bits", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "IpAddress", "TimeTicks")
DisplayString, TextualConvention, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "DateAndTime")
mpsMibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 641, 4, 4))
mpsMibModule.setRevisions(('2011-04-04 12:57', '2010-12-22 20:06', '2010-12-01 23:00', '2009-11-24 20:40',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mpsMibModule.setRevisionsDescriptions(('Version 1.2.0 Added values printerPageCount(80) and modularPageCount(81) to paperGeneralCountType definition.', 'Version 1.1.0 Added values transferUnit(16) and optionTransferUnit(272) to hwInventoryType definition.', 'Version 1.0.0 of the LEXMARK-MPS-MIB', 'Version 0.0.1 Initial release of LEXMARK-MPS-MIB',))
if mibBuilder.loadTexts: mpsMibModule.setLastUpdated('201104041257Z')
if mibBuilder.loadTexts: mpsMibModule.setOrganization('Lexmark International, Inc.')
if mibBuilder.loadTexts: mpsMibModule.setContactInfo('snmpmib@lexmark.com')
if mibBuilder.loadTexts: mpsMibModule.setDescription('The MIB module for information on devices connected through a print server. Information should be provided by the devices themselves. Copyright (C) 2009 Lexmark International, Inc.')
mps = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6))
mpsMIBAdminInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 1))
mpsMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 1, 1))
mpsMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 1, 2))
device = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 2))
inventory = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 3))
stats = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 4))
alerts = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 5))
logs = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 6))
applications = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 7))
generalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 4, 1))
paperStats = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 4, 2))
scanStats = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 4, 3))
supplyStats = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 4, 4))
class SupplyTypeTC(TextualConvention, Integer32):
    description = 'Type of supply'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("inkCartridge", 3), ("inkBottle", 4), ("inkPrinthead", 5), ("toner", 6), ("photoconductor", 7), ("transferModule", 8), ("fuser", 9), ("wastetonerBox", 10), ("staples", 11), ("holepunchBox", 12))

class CartridgeTypeTC(TextualConvention, Integer32):
    description = 'Type of supply cartridge. If this integer is looked at as a binary number, the bottom 4 bits define general information about the cartridge, and higher level bits will determine if the cartridge is a returnProgram, refill, etc. - bit 0-3 - General cartridge type - bit 4 - Return Program cartridge - bit 5 - Refilled Cartridge'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 21, 22, 23, 37, 38, 39, 53, 54, 55))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("invalid", 3), ("shipWith", 4), ("standard", 5), ("highYieldStandard", 6), ("extraHighYieldStandard", 7), ("returnProgram", 21), ("highYieldReturnProgram", 22), ("extraHighYieldReturnProgram", 23), ("refilledStandard", 37), ("refilledHighYieldStandard", 38), ("refilledExtraHighYieldStandard", 39), ("refilledReturnProgram", 53), ("refilledHighYieldReturnProgram", 54), ("refilledExtraHighYieldReturnProgram", 55))

class SeverityTC(TextualConvention, Integer32):
    description = "A list of possible alert codes. Definitions: informational - Status messages that do not require user intervention. Examples: 'Fuser Warming', 'Scanner warming' warning - A condition that may effect the ability of the device to function in the near future. Examples: 'Toner Low', 'Tray 1 Empty' critical - A condition that will keep the device from functioning until it is addressed by the user or admin. Critical errors can be addressed without power cycling the device. Examples: 'Load Tray 1', 'Black Toner Empty' serviceRequired - A condition that keeps the device from functioning and can not be addressed by the user or admin. serviceRequired errors will require power cycling the device to replace a defective part. Examples: 'NVRAM failure', 'Memory Error'"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("informational", 3), ("warning", 4), ("critical", 5), ("serviceRequired", 6))

class AlertCodeTC(TextualConvention, Integer32):
    description = 'A list of possible alert codes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 200, 201, 202, 203, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 300, 301, 302, 303, 304, 305, 400, 401, 402, 403, 404, 500, 501, 600, 601, 602, 603, 604, 605, 606, 607, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 800, 801, 802, 803, 804, 805, 900, 901, 1000, 1001, 1002, 20000))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("coverOpen", 3), ("coverClosed", 4), ("interlockOpen", 5), ("interlockClosed", 6), ("doorOpen", 7), ("doorClosed", 8), ("calibrating", 9), ("alignmentFailed", 10), ("warrantyOverrideRequired", 11), ("printHeadCarrierPathObstructed", 12), ("heldJobsMayNotBeRestored", 13), ("busy", 14), ("waiting", 15), ("subunitErrorOther", 100), ("subunitLifeAlmostOver", 101), ("subunitLifeOver", 102), ("subunitJammed", 103), ("subunitUnderTemperature", 104), ("subunitOverTemperature", 105), ("subunitInsufficientMemory", 106), ("subunitMemoryFull", 107), ("subunitNVFailure", 108), ("subunitDisabled", 109), ("subunitCommunicationError", 110), ("supplyErrorOther", 200), ("supplyOk", 201), ("supplyEarlyWarning", 202), ("supplyNearFull", 203), ("supplyFull", 205), ("supplyNearLow", 206), ("supplyLow", 207), ("supplyNearEmpty", 208), ("supplyEmpty", 209), ("supplyLifeAlmostOver", 210), ("supplyLifeOver", 211), ("supplyNearReplace", 212), ("supplyReplace", 213), ("supplyMissing", 214), ("supplyInvalid", 215), ("supplyDefective", 216), ("supplyImproperInstall", 217), ("supplyUnsupported", 218), ("supplyUncalibrated", 219), ("inputMediaErrorOther", 300), ("inputMediaTrayMissing", 301), ("inputMediaSupplyLow", 302), ("inputMediaSupplyEmpty", 303), ("inputMediaChangeRequest", 304), ("inputMediaLoadRequest", 305), ("outputMediaErrorOther", 400), ("outputMediaTrayMissing", 401), ("outputMediaNearFull", 402), ("outputMediaFull", 403), ("outputMediaEmptyRequest", 404), ("mediaPathErrorOther", 500), ("mediaPathPaperJam", 501), ("scannerErrorOther", 600), ("scannerLampWarming", 601), ("scannerLampLifeWarning", 602), ("scannerLampError", 603), ("scannerADFJam", 604), ("scannerStalled", 605), ("scannerLocked", 606), ("scannerDisabled", 607), ("faxErrorOther", 700), ("faxStorageNearFull", 701), ("faxStorageFull", 702), ("faxStorageSendNearFull", 703), ("faxStorageSendFull", 704), ("faxStorageReceiveNearFull", 705), ("faxStorageReceiveFull", 706), ("faxPhoneLineDisconnected", 707), ("faxDisabled", 708), ("faxConfigurationError", 709), ("interpreterErrorOther", 800), ("interpreterInsufficientMemory", 801), ("interpreterOutOfMemory", 802), ("interpreterComplexPage", 803), ("interpreterJobHardwareMismatch", 804), ("interpreterPrintDataExceedsMediaSize", 805), ("emailErrorOther", 900), ("emailConfigurationError", 901), ("storageErrorOther", 1000), ("storageUnformatted", 1001), ("storageFull", 1002), ("neverError", 20000))

deviceMibLocalization = MibScalar((1, 3, 6, 1, 4, 1, 641, 6, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceMibLocalization.setStatus('current')
if mibBuilder.loadTexts: deviceMibLocalization.setDescription('The value of the prtLocalizationIndex in the Printer-MIB which corresponds to the language, country, and character set to be used for encoding any of the translated objects in this MIB. This object does NOT change the localization of the console. The default value for this object should be the language chosen by the user during the initial setup. When read this object should return the current localization value.')
deviceTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 2, 3), )
if mibBuilder.loadTexts: deviceTable.setStatus('current')
if mibBuilder.loadTexts: deviceTable.setDescription('A table of the devices attached. Because the top level implementation of this mib may be on a print server, it is possible to have multiple printers attached. This table should list all devices being serviced by this print server.')
deviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"))
if mibBuilder.loadTexts: deviceEntry.setStatus('current')
if mibBuilder.loadTexts: deviceEntry.setDescription('An entry containing information on a device.')
deviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: deviceIndex.setStatus('current')
if mibBuilder.loadTexts: deviceIndex.setDescription('A unique value used to identify this device.')
devicePort = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devicePort.setStatus('current')
if mibBuilder.loadTexts: devicePort.setDescription('The number of the port this device is attached to. If this is an internal network adapter, the port should be 1. Multiport ENAs should list an appropriate number.')
deviceHrDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceHrDeviceIndex.setStatus('current')
if mibBuilder.loadTexts: deviceHrDeviceIndex.setDescription('The index in the hrDeviceTable that corresponds to this device.')
deviceModel = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceModel.setStatus('current')
if mibBuilder.loadTexts: deviceModel.setDescription('UTF-8 encoded text to describe this device. This should match the model name of the device.')
deviceSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSerialNumber.setStatus('current')
if mibBuilder.loadTexts: deviceSerialNumber.setDescription('Primary serial number for this device')
deviceMibVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMibVersion.setStatus('current')
if mibBuilder.loadTexts: deviceMibVersion.setDescription('The version of this mib supported by the device. This will be in the form of x.y.z.')
deviceInstallDate = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceInstallDate.setStatus('current')
if mibBuilder.loadTexts: deviceInstallDate.setDescription('The install date of the device. This information should be provided by the attached device')
deviceMibSupportLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 16, 32, 48))).clone(namedValues=NamedValues(("none", 0), ("minimum", 1), ("value", 16), ("feature", 32), ("enterprise", 48)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMibSupportLevel.setStatus('current')
if mibBuilder.loadTexts: deviceMibSupportLevel.setDescription('The support level of this device. An attached device can support various levels of this MIB, which is indicated in deviceMibSupportLevel. The device should claim the highest support level for which it supports EVERYTHING included in that level. A device may support additional items beyond the claimed level, the list given is just the minimum required implementation to claim a given support level. Support Level definition: none: The device referred to does not support any items in this mib minimum: The following items in the following table must be implemented paperGeneralCountTable: totalPrinted (sides) totalMonoPrinted (sides) totalColorPrinted (sides) (only necessary if a color box) value: All items in minimum plus genCountTable porCount paperGeneralCountTable: All applicable counts supplyInventoryTable For all user replaceable supplies swInventoryTable All software components listed with a minimum of swInventoryName and swInventoryRevision being reported only for code revs on menus page. currentSuppliesTable For all user replaceable supplies deviceAlertTable All critical alerts (device is down) should be listed feature: All items in value plus genCountTable faxesSent (if applicable) scanCount (if applicable) hwInventoryTable All major hardware items (printEngine, installed options) swInventoryTable All code levels including downloaded apps and solutions. paperSidesCount Table A minimum of 9 size/type combinations must be supported paperSheetsCount Table A minimum of 9 size/type combinations must be supported supplyHistoryTable A minimum of the last 3 ink/toner cartridges for mono products A minimum of the last 2 ink/toner cartridges of each colorant type for color products. supplyHistogram Table For all ink/toner cartridges. deviceAlertTable All alerts should be listed. enterprise: All items in feature plus genCountTable Any applicable counts (including power counts) paperSidesCount Table A minimum of 17 size/type combinations must be supported paperSheetsCount Table A minimum of 17 size/type combinations must be supported paperNupCountTable Counts should be included for all applicable nup settings paperJobSizeTable A minimum of 5 buckets of job size should be implemented. scanCountTable For all applicable scan types supplyHistoryTable A minimum of the last 5 ink/toner cartridges for mono products A minimum of the last 3 ink/toner cartridges of each colorant type for color products.')
hwInventoryTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 3, 1), )
if mibBuilder.loadTexts: hwInventoryTable.setStatus('current')
if mibBuilder.loadTexts: hwInventoryTable.setDescription('A table of the hardware items associated with this device. If the item is tracked by the supplies tables (ie fuser), it should NOT be tracked here. Standard (built-in) options such as input trays, output bins, duplexers, harddrives, etc, SHOULD be included in this table. A row for the basic print engine should be included as well. Examples: - All electronic cards - All hardware options - Op-Panel - Fax Card - Scanner - Any item that has a code version associated with it.')
hwInventoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "hwInventoryIndex"))
if mibBuilder.loadTexts: hwInventoryEntry.setStatus('current')
if mibBuilder.loadTexts: hwInventoryEntry.setDescription('An entry containing information on a hardware item.')
hwInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hwInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: hwInventoryIndex.setDescription('A unique value used to identify this hardware item.')
hwInventoryParentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryParentIndex.setStatus('current')
if mibBuilder.loadTexts: hwInventoryParentIndex.setDescription('The hwInventoryIndex of the hardware device that the item in this row is tied to. If there is no parent, this object should read 0. The base printer itself should only be used as a parent for devices that are integrated into it. ie RIP card, tray one, fax card, scanner. Items that are options such as extra input trays, external duplexers, and add on output bins should rate their own row with no parent. Examples: 5-bin mailbox The mailbox unit as a whole would be one row, with a parent of 0. Each of the mailboxes would be row, with the parent of each mailbox pointing back to the mailbox unit. Finisher The finisher as a whole would be one row, with a parent of 0. The options of the finsher; output bins, stapler, hole punch, would each merit an individual row with the finisher unit as the parent ')
hwInventoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 257, 258, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("printEngine", 3), ("electronicCard", 4), ("duplexer", 5), ("inputTray", 6), ("outputTray", 7), ("finishingDevice", 8), ("scanner", 9), ("faxCard", 10), ("memory", 11), ("nonVolitileMemory", 12), ("keyboard", 13), ("panel", 14), ("cardSwipe", 15), ("transferUnit", 16), ("optionUnknown", 257), ("optionOther", 258), ("optionDuplexer", 261), ("optionInputTray", 262), ("optionOutputTray", 263), ("optionFinishingDevice", 264), ("optionScanner", 265), ("optionFaxCard", 266), ("optionMemory", 267), ("optionNonVolitileMemory", 268), ("optionKeyboard", 269), ("optionPanel", 270), ("optionCardSwipe", 271), ("optionTransferUnit", 272)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryType.setStatus('current')
if mibBuilder.loadTexts: hwInventoryType.setDescription('The type of item row is describing. There is base set of possible items types and then a set of optional bits that can describe more about how this item is used. Bitmap - bits 0-7 - General description - bit 8 - Optional hardware. 0 - built in, 1 - optional item ')
hwInventoryAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 4), AdminStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwInventoryAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwInventoryAdminStatus.setDescription('The current administrative status for this device. If supported by the device, this may be used to control the status of this hardware component. If the device does not support changing the administrative status via snmp, the set should fail and the current admin status should be returned.')
hwInventoryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 5), StatusTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryStatus.setStatus('current')
if mibBuilder.loadTexts: hwInventoryStatus.setDescription('The current status of this item.')
hwInventoryPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryPartNumber.setStatus('current')
if mibBuilder.loadTexts: hwInventoryPartNumber.setDescription('The part number for the item. If unknown, this string should be blank.')
hwInventorySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventorySerialNumber.setStatus('current')
if mibBuilder.loadTexts: hwInventorySerialNumber.setDescription('The serial number for the item. If unknown, this string should be blank.')
hwInventoryDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryDescription.setStatus('current')
if mibBuilder.loadTexts: hwInventoryDescription.setDescription('The description for the item. If unknown, this string should be blank. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
hwInventoryData = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 1, 1, 9), KeyValueTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInventoryData.setStatus('current')
if mibBuilder.loadTexts: hwInventoryData.setDescription('A set of key=value; pairs that give additional information on this hardware unit.')
supplyInventoryTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 3, 2), )
if mibBuilder.loadTexts: supplyInventoryTable.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryTable.setDescription('A table of the supplies used by this device')
supplyInventoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 3, 2, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "supplyInventoryIndex"))
if mibBuilder.loadTexts: supplyInventoryEntry.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryEntry.setDescription('An entry containing information on a supply.')
supplyInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: supplyInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryIndex.setDescription('A unique value used to identify this supply.')
supplyInventoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 2, 1, 2), SupplyTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyInventoryType.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryType.setDescription('The type of supply as referenced in the SupplyTypeTC that this row is describing.')
supplyInventoryColorantValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyInventoryColorantValue.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryColorantValue.setDescription("The name of the color using standard string names from ISO 10175 (DPA) and ISO 10180 (SPDL) which are: other unknown white red green blue cyan magenta yellow black If a supply doesn't have a color associated with it, the value of 'none' should be returned.")
supplyInventoryDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 2, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyInventoryDescription.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryDescription.setDescription('The description of this supply. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
swInventoryTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 3, 3), )
if mibBuilder.loadTexts: swInventoryTable.setStatus('current')
if mibBuilder.loadTexts: swInventoryTable.setDescription('A table of the software installed on this device')
swInventoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "swInventoryIndex"))
if mibBuilder.loadTexts: swInventoryEntry.setStatus('current')
if mibBuilder.loadTexts: swInventoryEntry.setDescription('An entry containing information on a software package')
swInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: swInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: swInventoryIndex.setDescription('A unique value used to identify this software item.')
swInventoryParentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryParentIndex.setStatus('current')
if mibBuilder.loadTexts: swInventoryParentIndex.setDescription('The swInventoryIndex of the software object that the item in this row is tied to. If there is no parent, this object should read 0. Example: An application framework is installed. It should have an swInventoryParentIndex of 0. If applications are installed that use that framework, those should have an swInventoryParentIndex that points to the application framework.')
swInventoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("operatingSystem", 3), ("hardware", 4), ("application", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryType.setStatus('current')
if mibBuilder.loadTexts: swInventoryType.setDescription('The type of software item this row describes.')
swInventoryAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 4), AdminStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swInventoryAdminStatus.setStatus('current')
if mibBuilder.loadTexts: swInventoryAdminStatus.setDescription('The current administrative status of this software. If supported by the device, this may be used to control the status of this software component. If the device does not support changing the administrative status via snmp, the set should fail and the current admin status should be returned.')
swInventoryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 5), StatusTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryStatus.setStatus('current')
if mibBuilder.loadTexts: swInventoryStatus.setDescription('The current status of this software.')
swInventoryName = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryName.setStatus('current')
if mibBuilder.loadTexts: swInventoryName.setDescription('The name of this software item. This should be a specific, unique string.')
swInventoryRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryRevision.setStatus('current')
if mibBuilder.loadTexts: swInventoryRevision.setDescription('The revision of the install.')
swInventoryDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryDescription.setStatus('current')
if mibBuilder.loadTexts: swInventoryDescription.setDescription('The description for the item. If unknown, this string should be blank. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
swInventoryHWIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryHWIndex.setStatus('current')
if mibBuilder.loadTexts: swInventoryHWIndex.setDescription("The index of the row in the hwInventoryTable that indicates the hardware this software is associated with. If unknown, this should return 0. For instance, if the duplex unit has it's own firmware revision, it's parent would be the duplex hardware item in the hwInventoryTable.")
swInventoryData = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 3, 3, 1, 10), KeyValueTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swInventoryData.setStatus('current')
if mibBuilder.loadTexts: swInventoryData.setDescription('A set of key=value; pairs that give additional information on this software unit.')
genCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1), )
if mibBuilder.loadTexts: genCountTable.setStatus('current')
if mibBuilder.loadTexts: genCountTable.setDescription('A table of general counts. These rows are intended to count items and events for the device other than page usages or supply usage. This table should only include counters that make sense for the device, and are tracked for the device. In other words, if a count is zero, and can never be anything other than zero, it should not be returned.')
genCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "genCountIndex"))
if mibBuilder.loadTexts: genCountEntry.setStatus('current')
if mibBuilder.loadTexts: genCountEntry.setDescription('An entry containing a general counter.')
genCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: genCountIndex.setStatus('current')
if mibBuilder.loadTexts: genCountIndex.setDescription('The index of this row in the genCountTable')
genCountType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 32, 33, 34, 35, 36, 37, 38, 64, 65, 66, 67, 96, 97, 98, 99, 100, 101, 128))).clone(namedValues=NamedValues(("porCount", 1), ("sleepCount", 2), ("hibernateCount", 3), ("printCalibrateCount", 4), ("powerOnTime", 32), ("powerActiveTime", 33), ("powerIdleTime", 34), ("powerSleepTime", 35), ("powerHibernateTime", 36), ("powerOffTime", 37), ("warmupTotalTime", 38), ("lifetimeBlackCoverage", 64), ("lifetimeCyanCoverage", 65), ("lifetimeYellowCoverage", 66), ("lifetimeMagentaCoverage", 67), ("faxesSent", 96), ("paperJams", 97), ("scannerJams", 98), ("loadPaperPrompts", 99), ("changePaperPrompts", 100), ("coverOpens", 101), ("usbInsertions", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCountType.setStatus('current')
if mibBuilder.loadTexts: genCountType.setDescription('The type of item this counter is counting.')
genCountUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1, 1, 3), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCountUnits.setStatus('current')
if mibBuilder.loadTexts: genCountUnits.setDescription('The units this item is counting in')
genCountValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCountValue.setStatus('current')
if mibBuilder.loadTexts: genCountValue.setDescription('The value of this counter')
paperGeneralCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1), )
if mibBuilder.loadTexts: paperGeneralCountTable.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountTable.setDescription('A table of general counts for sheets and pages printed')
paperGeneralCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "paperGeneralCountIndex"))
if mibBuilder.loadTexts: paperGeneralCountEntry.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountEntry.setDescription('An entry containing a general counter for sheets and pages printed. This table should only include items that make sense for this product. For instance, the printColor count should not be returned for mono products.')
paperGeneralCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: paperGeneralCountIndex.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountIndex.setDescription('The index of this row in the paperGeneralCountTable')
paperGeneralCountType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 16, 17, 18, 32, 33, 34, 48, 49, 50, 64, 65, 66, 67, 80, 81))).clone(namedValues=NamedValues(("totalPicked", 1), ("totalSafe", 2), ("totalMonoSafe", 3), ("totalColorSafe", 4), ("printNHold", 5), ("usbDirect", 6), ("printTotal", 16), ("printMono", 17), ("printColor", 18), ("copyTotal", 32), ("copyMono", 33), ("copyColor", 34), ("faxTotal", 48), ("faxMono", 49), ("faxColor", 50), ("blankTotal", 64), ("blankPrint", 65), ("blankCopy", 66), ("blankFax", 67), ("printerPageCount", 80), ("modularPageCount", 81)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperGeneralCountType.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountType.setDescription('The type of item this counter is counting.')
paperGeneralCountUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1, 1, 3), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperGeneralCountUnits.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountUnits.setDescription('The units this item is counting in. For this table this should always be in units of Sheets or Sides')
paperGeneralCountValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperGeneralCountValue.setStatus('current')
if mibBuilder.loadTexts: paperGeneralCountValue.setDescription('The value of the item this row is counting')
paperSidesCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2), )
if mibBuilder.loadTexts: paperSidesCountTable.setStatus('current')
if mibBuilder.loadTexts: paperSidesCountTable.setDescription('A table of sides counts for various printed size/type combinations')
paperSidesCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "paperSidesCountIndex"))
if mibBuilder.loadTexts: paperSidesCountEntry.setStatus('current')
if mibBuilder.loadTexts: paperSidesCountEntry.setDescription('An entry containing information on the number of sides printed for a given size/type combination.')
paperSidesCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: paperSidesCountIndex.setStatus('current')
if mibBuilder.loadTexts: paperSidesCountIndex.setDescription('The index of this row in the paperSidesCountTable')
paperSidesPaperSize = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 2), PaperSizeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesPaperSize.setStatus('current')
if mibBuilder.loadTexts: paperSidesPaperSize.setDescription('The size of the paper ')
paperSidesPaperType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 3), PaperTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesPaperType.setStatus('current')
if mibBuilder.loadTexts: paperSidesPaperType.setDescription('The type of the paper')
paperSidesMonoPicked = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesMonoPicked.setStatus('current')
if mibBuilder.loadTexts: paperSidesMonoPicked.setDescription('The number of sides (impressions) of mono pages picked')
paperSidesColorPicked = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesColorPicked.setStatus('current')
if mibBuilder.loadTexts: paperSidesColorPicked.setDescription('The number of sides (impressions) of color pages picked')
paperSidesMonoSafe = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesMonoSafe.setStatus('current')
if mibBuilder.loadTexts: paperSidesMonoSafe.setDescription('The number of sides (impressions) of mono pages that have been printed and delivered into an output bin')
paperSidesColorSafe = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSidesColorSafe.setStatus('current')
if mibBuilder.loadTexts: paperSidesColorSafe.setDescription('The number of sides (impressions) of color pages that have been printed and delivered into an output bin')
paperSheetsCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3), )
if mibBuilder.loadTexts: paperSheetsCountTable.setStatus('current')
if mibBuilder.loadTexts: paperSheetsCountTable.setDescription('A table of sheet (page) counts for various printed size/type combinations')
paperSheetsCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "paperSheetsCountIndex"))
if mibBuilder.loadTexts: paperSheetsCountEntry.setStatus('current')
if mibBuilder.loadTexts: paperSheetsCountEntry.setDescription('An entry containing information on the number of sheets (pages) printed for a given size/type combination.')
paperSheetsCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: paperSheetsCountIndex.setStatus('current')
if mibBuilder.loadTexts: paperSheetsCountIndex.setDescription('The index of this row in the paperSheetsCountTable')
paperSheetsPaperSize = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1, 2), PaperSizeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSheetsPaperSize.setStatus('current')
if mibBuilder.loadTexts: paperSheetsPaperSize.setDescription('The size of the paper ')
paperSheetsPaperType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1, 3), PaperTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSheetsPaperType.setStatus('current')
if mibBuilder.loadTexts: paperSheetsPaperType.setDescription('The type of the paper')
paperSheetsPicked = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSheetsPicked.setStatus('current')
if mibBuilder.loadTexts: paperSheetsPicked.setDescription('The number of sheets (pages) picked')
paperSheetsSafe = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperSheetsSafe.setStatus('current')
if mibBuilder.loadTexts: paperSheetsSafe.setDescription('The number of sheets (pages) that have been printed and delivered into an output bin')
paperNupCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4), )
if mibBuilder.loadTexts: paperNupCountTable.setStatus('current')
if mibBuilder.loadTexts: paperNupCountTable.setDescription('A table of counts to show how many jobs have been printed with various multipage print (nup) settings. This table may be sparse, nup values that have a count of 0 are not expected to be returned.')
paperNupCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "paperNupCountIndex"))
if mibBuilder.loadTexts: paperNupCountEntry.setStatus('current')
if mibBuilder.loadTexts: paperNupCountEntry.setDescription("An entry containing information on how much the printer's Nup feature has been used.")
paperNupCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: paperNupCountIndex.setStatus('current')
if mibBuilder.loadTexts: paperNupCountIndex.setDescription('The index of this row in the paperNupCountTable')
paperNupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 9, 12, 16))).clone(namedValues=NamedValues(("off", 1), ("twoUp", 2), ("threeUp", 3), ("fourUp", 4), ("sixUp", 6), ("nineUp", 9), ("twelveUp", 12), ("sixteenUp", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperNupNumber.setStatus('current')
if mibBuilder.loadTexts: paperNupNumber.setDescription('The Nup number for the jobs this row is describing. This is the number of logical sides (impressions) that appear on one side of the printed sheet')
paperNupSides = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperNupSides.setStatus('current')
if mibBuilder.loadTexts: paperNupSides.setDescription('The number of physical sides of paper that have been printed using this value of Nup')
paperNupLogicalSides = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperNupLogicalSides.setStatus('current')
if mibBuilder.loadTexts: paperNupLogicalSides.setDescription('The number of logical sides that have been printed using this value of Nup. For example, if a user prints a 3 page job using an Nup value of 4, the paperNupSides counter will be incremented by 1, and paperNupLogicalSides will be incremented by 3.')
paperJobSizeTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5), )
if mibBuilder.loadTexts: paperJobSizeTable.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeTable.setDescription('Table to indicate how many jobs of different size have been printed. This table may be sparse. Only job size buckets that have a non-zero count in them should be returned.')
paperJobSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "paperJobSizeIndex"))
if mibBuilder.loadTexts: paperJobSizeEntry.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeEntry.setDescription('An entry containing information on how many jobs of different sizes have been printed.')
paperJobSizeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: paperJobSizeIndex.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeIndex.setDescription('The index of this row in the paperJobSizeTable')
paperJobSizeMinimum = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperJobSizeMinimum.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeMinimum.setDescription('The minimum number of printed sides for jobs described by this row')
paperJobSizeMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperJobSizeMaximum.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeMaximum.setDescription('The maximum number of printed sides for jobs described by this row')
paperJobSizeSideCount = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperJobSizeSideCount.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeSideCount.setDescription('The total number of sides printed for all jobs where the number of sides for the job was between paperJobSizeMinimum and paperJobSizeMaximum (inclusive)')
paperJobSizeJobCount = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paperJobSizeJobCount.setStatus('current')
if mibBuilder.loadTexts: paperJobSizeJobCount.setDescription('The total number of jobs printed where the number of sides for the job was between paperJobSizeMinimum and paperJobSizeMaximum (inclusive)')
scanCountTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1), )
if mibBuilder.loadTexts: scanCountTable.setStatus('current')
if mibBuilder.loadTexts: scanCountTable.setDescription("A table of scan counts. This table should only return counts that apply to this product. For instance, fax scan counts should not be returned if the product doesn't support fax.")
scanCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "scanCountIndex"))
if mibBuilder.loadTexts: scanCountEntry.setStatus('current')
if mibBuilder.loadTexts: scanCountEntry.setDescription('An entry containing information on a supply.')
scanCountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: scanCountIndex.setStatus('current')
if mibBuilder.loadTexts: scanCountIndex.setDescription('The index of this row in the scanCountTable')
scanCountType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 257, 258, 259, 260, 261, 769, 770, 771, 772, 773))).clone(namedValues=NamedValues(("copyAdf", 1), ("faxAdf", 2), ("scanToEmailAdf", 3), ("scanToNetAdf", 4), ("scanToLocalHostAdf", 5), ("copyFlatbed", 257), ("faxFlatbed", 258), ("scanToEmailFlatbed", 259), ("scanToNetFlatbed", 260), ("scanToLocalHostFlatbed", 261), ("copyDuplex", 769), ("faxDuplex", 770), ("scanToEmailDuplex", 771), ("scanToNetDuplex", 772), ("scanToLocalHostDuplex", 773)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanCountType.setStatus('current')
if mibBuilder.loadTexts: scanCountType.setDescription('Enumeration of the type of scan that is being counted. - bit 0-7 - Application using the scanned image - bit 8 - adf or flatbed. 0 = flatbed, 1 = adf - bit 9 - Duplex scan (both sides scanned at the same time). This bit should only be set if bit 8 (adf) is also set')
scanCountSize = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1, 3), PaperSizeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanCountSize.setStatus('current')
if mibBuilder.loadTexts: scanCountSize.setDescription("Enumeration of the size of the paper that was scanned. If the scan is a full glass flatbed scan, the size should be 'universal'.")
scanCountSides = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanCountSides.setStatus('current')
if mibBuilder.loadTexts: scanCountSides.setDescription('Count of the number of sides of paper that were scanned.')
scanCountSheets = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanCountSheets.setStatus('current')
if mibBuilder.loadTexts: scanCountSheets.setDescription('Count of the number of sheets of paper that were scanned.')
currentSuppliesTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1), )
if mibBuilder.loadTexts: currentSuppliesTable.setStatus('current')
if mibBuilder.loadTexts: currentSuppliesTable.setDescription('A table of the supplies currently in use')
currentSuppliesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "currentSupplyIndex"))
if mibBuilder.loadTexts: currentSuppliesEntry.setStatus('current')
if mibBuilder.loadTexts: currentSuppliesEntry.setDescription('An entry containing information on a supply.')
currentSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: currentSupplyIndex.setStatus('current')
if mibBuilder.loadTexts: currentSupplyIndex.setDescription('The index of the row for a given supply in the currentSuppliesTable')
currentSupplyInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: currentSupplyInventoryIndex.setDescription('The index of the row in the supplyInventoryTable that corresponds to this supply.')
currentSupplyType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 3), SupplyTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyType.setStatus('current')
if mibBuilder.loadTexts: currentSupplyType.setDescription('The type of supply as referenced in the SupplyTypeTC that this row is describing.')
currentSupplyColorantValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyColorantValue.setStatus('current')
if mibBuilder.loadTexts: currentSupplyColorantValue.setDescription("The name of the color using standard string names from ISO 10175 (DPA) and ISO 10180 (SPDL) which are: other unknown white red green blue cyan magenta yellow black If a supply doesn't have a color associated with it, the value of 'none' should be returned.")
currentSupplyDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyDescription.setStatus('current')
if mibBuilder.loadTexts: currentSupplyDescription.setDescription('The description of this supply. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
currentSupplySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplySerialNumber.setStatus('current')
if mibBuilder.loadTexts: currentSupplySerialNumber.setDescription('The serial number (if known) of this supply. If not known, this field should be blank.')
currentSupplyPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyPartNumber.setStatus('current')
if mibBuilder.loadTexts: currentSupplyPartNumber.setDescription('The part number (if known) of this supply. If not known, this field should be blank.')
currentSupplyClass = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filled", 1), ("consumed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyClass.setStatus('current')
if mibBuilder.loadTexts: currentSupplyClass.setDescription('The type of this supply. Whether it is one that is consumed (such as toner) or filled (such as a waste box)')
currentSupplyCartridgeType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 9), CartridgeTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCartridgeType.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCartridgeType.setDescription('The type of cartridge that this is as defined in CartridgeTypeTC. Supplies that are not a toner/ink cartridge should return other(2)')
currentSupplyInstallDate = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyInstallDate.setStatus('current')
if mibBuilder.loadTexts: currentSupplyInstallDate.setDescription('The date this particular supply was installed.')
currentSupplyPageCountAtInstall = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyPageCountAtInstall.setStatus('current')
if mibBuilder.loadTexts: currentSupplyPageCountAtInstall.setDescription('The page count of the printer when this supply was installed.')
currentSupplyCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("ok", 3), ("low", 4), ("empty", 5), ("invalid", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCurrentStatus.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCurrentStatus.setDescription('The status of this supply')
currentSupplyCapacityUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 13), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCapacityUnit.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCapacityUnit.setDescription('The units used to measure the capacity of a supply')
currentSupplyCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCapacity.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCapacity.setDescription('The average expected total capacity of this supply in currentSupplyCapacityUnits')
currentSupplyFirstKnownLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyFirstKnownLevel.setStatus('current')
if mibBuilder.loadTexts: currentSupplyFirstKnownLevel.setDescription('The first known supply level for this supply in currentSupplyCapacityUnits')
currentSupplyCurrentLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCurrentLevel.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCurrentLevel.setDescription('The estimated amount of this supply remaining in currentSupplyCapacityUnits')
currentSupplyUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyUsage.setStatus('current')
if mibBuilder.loadTexts: currentSupplyUsage.setDescription('The amount of this supply that has been used in currentSupplyCapacityUnits. This number may give different results from currentSupplyCurrentLevel, as it only accounts for where the supply is used in creating a page. For instance, it would account for pages where a certain toner color was put down. However even if that color is not put down on a page, some toner may be used in the calibration operation (for instance) and that use would be only reflected in currentSupplyCurrentLevel')
currentSupplyCalibrations = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCalibrations.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCalibrations.setDescription('The number of calibration cycles that have occurred while this supply was installed. Only calibration cycles involving this supply should be counted.')
currentSupplyCoverage = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentSupplyCoverage.setStatus('current')
if mibBuilder.loadTexts: currentSupplyCoverage.setDescription('Absolute value for the coverage usage of this supply. Coverage is an additive amount of this supply used for all pages that this supply has been used for. Supplies for which this is not meaningful (ie toner waste box) should return 0.')
supplyHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2), )
if mibBuilder.loadTexts: supplyHistoryTable.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryTable.setDescription('A table of information on supplies used previously in the device')
supplyHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "supplyHistoryIndex"))
if mibBuilder.loadTexts: supplyHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryEntry.setDescription('An entry containing information on a supply.')
supplyHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: supplyHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryIndex.setDescription('The index of the history item for a give current Supply and Device. Devices may report on the previous 0 or more of each of supplies in the currentSupplyTable')
supplyHistoryInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryInventoryIndex.setDescription('The index of the row in the supplyInventoryTable that corresponds to this supply.')
supplyHistorySupplyType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 3), SupplyTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistorySupplyType.setStatus('current')
if mibBuilder.loadTexts: supplyHistorySupplyType.setDescription('The type of supply as referenced in the SupplyTypeTC that this row is describing.')
supplyHistoryColorantValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryColorantValue.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryColorantValue.setDescription("The name of the color using standard string names from ISO 10175 (DPA) and ISO 10180 (SPDL) which are: other unknown white red green blue cyan magenta yellow black If a supply doesn't have a color associated with it, the value of 'none' should be returned.")
supplyHistoryDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryDescription.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryDescription.setDescription('The description of this supply. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
supplyHistorySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistorySerialNumber.setStatus('current')
if mibBuilder.loadTexts: supplyHistorySerialNumber.setDescription('The serial number (if known) of this supply. If not known, this field should be blank.')
supplyHistoryCartridgeType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 7), CartridgeTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryCartridgeType.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryCartridgeType.setDescription('The type of cartridge that this is as defined in CartridgeTypeTC. Supplies that are not a toner/ink cartridge should return other(2)')
supplyHistoryInstallDate = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryInstallDate.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryInstallDate.setDescription('The date this supply was first installed.')
supplyHistoryPageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryPageCount.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryPageCount.setDescription('The number of page sides (impressions) that were printed while this supply was installed in the device.')
supplyHistoryCapacityUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 10), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryCapacityUnit.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryCapacityUnit.setDescription('The units used to measure the capacity of a supply')
supplyHistoryCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryCapacity.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryCapacity.setDescription('The average expected total capacity of this supply in capacity units')
supplyHistoryLastLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryLastLevel.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryLastLevel.setDescription('The last recorded level for this supply (in capacity units)')
supplyHistoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryUsage.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryUsage.setDescription('The amount of this supply that was used in supplyHistoryCapacityUnits')
supplyHistoryCalibrations = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryCalibrations.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryCalibrations.setDescription('The number of calibration cycles that have occurred while this supply was installed. Only calibration cycles involving this supply should be counted.')
supplyHistoryCoverage = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistoryCoverage.setStatus('current')
if mibBuilder.loadTexts: supplyHistoryCoverage.setDescription('Absolute value for the coverage usage of this supply. Coverage is an additive amount of this supply used for all pages that this supply has been used for.')
supplyHistogramTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3), )
if mibBuilder.loadTexts: supplyHistogramTable.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramTable.setDescription('A table of information on supplies used previously in the device')
supplyHistogramEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "supplyHistogramIndex"))
if mibBuilder.loadTexts: supplyHistogramEntry.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramEntry.setDescription('An entry containing information on a supply.')
supplyHistogramIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: supplyHistogramIndex.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramIndex.setDescription('The index of this histogram row')
supplyHistogramInventoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramInventoryIndex.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramInventoryIndex.setDescription('The index of the row in the supplyInventoryTable that corresponds to this supply.')
supplyHistogramSupplyType = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 3), SupplyTypeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramSupplyType.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramSupplyType.setDescription('The type of supply as referenced in the SupplyTypeTC that this row is describing.')
supplyHistogramColorantValue = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramColorantValue.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramColorantValue.setDescription("The name of the color using standard string names from ISO 10175 (DPA) and ISO 10180 (SPDL) which are: other unknown white red green blue cyan magenta yellow black If a supply doesn't have a color associated with it, the value of 'none' should be returned.")
supplyHistogramDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramDescription.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramDescription.setDescription('The description of this supply. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
supplyHistogramCapacityUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 6), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramCapacityUnit.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramCapacityUnit.setDescription('The units used to measure the capacity of a supply')
supplyHistogramCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramCapacity.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramCapacity.setDescription('The average expected total capacity of this supply in capacity units')
supplyHistogramCount = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramCount.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramCount.setDescription('The amount of this supply that was used in supplyHistogramCountUnits (for the corresponding current supply). This is intended to count the number of supplies of a given size that have been used over the life of this product.')
supplyHistogramCountUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 4, 4, 3, 1, 9), UnitsTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: supplyHistogramCountUnits.setStatus('current')
if mibBuilder.loadTexts: supplyHistogramCountUnits.setDescription('The units that this supply is measured in.')
deviceAlertTable = MibTable((1, 3, 6, 1, 4, 1, 641, 6, 5, 1), )
if mibBuilder.loadTexts: deviceAlertTable.setStatus('current')
if mibBuilder.loadTexts: deviceAlertTable.setDescription('A table of alerts on the devices.')
deviceAlertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1), ).setIndexNames((0, "LEXMARK-MPS-MIB", "deviceIndex"), (0, "LEXMARK-MPS-MIB", "deviceAlertIndex"))
if mibBuilder.loadTexts: deviceAlertEntry.setStatus('current')
if mibBuilder.loadTexts: deviceAlertEntry.setDescription('An entry containing information about this alert.')
deviceAlertIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertIndex.setStatus('current')
if mibBuilder.loadTexts: deviceAlertIndex.setDescription('The index of this alert in the alert table. This table is expected to be rather dynamic, with rows added as alert conditions occur on devices, and then the rows being removed as alert conditions are cleared. The data in this table should not persist over a POR, but should be reset when the printer is reset, with appropriated items being added back in as the printer finds them. While this OID is marked as read-only, it should not be returned as table-column, which means it should be treated as not-accessible. It is marked as read-only in the MIB only because many MIB compilers will complain about this being called not-accessible since the trap can return this index.')
deviceAlertConfigTableNode = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("hwInventoryTable", 2), ("supplyInventoryTable", 3), ("swInventoryTable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertConfigTableNode.setStatus('current')
if mibBuilder.loadTexts: deviceAlertConfigTableNode.setDescription("The subnode of the device node that indicates the table the holds information about the item this alert refers to. For instance, if the alert is a hardware alert, this object should hold the value of '2', indicating that the alert is for a member of the device.hwInventoryTable. Common values of this would be 2 -> hwInventoryTable 3 -> supplyInventoryTable 4 -> swInventoryTable")
deviceAlertConfigTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertConfigTableIndex.setStatus('current')
if mibBuilder.loadTexts: deviceAlertConfigTableIndex.setDescription("The index of the row of the table indicated by deviceAlertConfigTableNode that corresponds to the item that this alert pertains to. For instance, if a printer's fuser is the first item listed in the supplyInventoryTable, then deviceAlertConfigTableNode = 3 and deviceAlertConfigTableIndex = 1.")
deviceAlertSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 4), SeverityTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertSeverity.setStatus('current')
if mibBuilder.loadTexts: deviceAlertSeverity.setDescription('The severity of this alert')
deviceAlertCode = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 5), AlertCodeTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertCode.setStatus('current')
if mibBuilder.loadTexts: deviceAlertCode.setDescription('An alert code to indicate what type of alert condition this row refers to')
deviceAlertDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertDescription.setStatus('current')
if mibBuilder.loadTexts: deviceAlertDescription.setDescription('A description of the alert condition. If changing localization is supported, this description should be displayed in the language set in deviceMibLocalization.')
deviceAlertData = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 7), KeyValueTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertData.setStatus('current')
if mibBuilder.loadTexts: deviceAlertData.setDescription('A key=value; encoded string of information regarding this row.')
deviceAlertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 641, 6, 5, 1, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlertTime.setStatus('current')
if mibBuilder.loadTexts: deviceAlertTime.setDescription('The time and date when this alert was added to the table.')
deviceV1AlertMPS = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 5, 2))
deviceV2AlertMPSPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 641, 6, 5, 2, 0))
deviceV2AlertMPS = NotificationType((1, 3, 6, 1, 4, 1, 641, 6, 5, 2, 0, 1)).setObjects(("LEXMARK-MPS-MIB", "deviceAlertIndex"), ("LEXMARK-MPS-MIB", "deviceAlertConfigTableNode"), ("LEXMARK-MPS-MIB", "deviceAlertConfigTableIndex"), ("LEXMARK-MPS-MIB", "deviceAlertSeverity"), ("LEXMARK-MPS-MIB", "deviceAlertCode"), ("LEXMARK-MPS-MIB", "deviceAlertDescription"), ("LEXMARK-MPS-MIB", "deviceAlertData"), ("LEXMARK-MPS-MIB", "deviceAlertTime"))
if mibBuilder.loadTexts: deviceV2AlertMPS.setStatus('current')
if mibBuilder.loadTexts: deviceV2AlertMPS.setDescription('This trap is sent whenever a critical or serviceRequired event is added to the deviceAlertTable.')
deviceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 1)).setObjects(("LEXMARK-MPS-MIB", "deviceMibLocalization"), ("LEXMARK-MPS-MIB", "devicePort"), ("LEXMARK-MPS-MIB", "deviceHrDeviceIndex"), ("LEXMARK-MPS-MIB", "deviceModel"), ("LEXMARK-MPS-MIB", "deviceSerialNumber"), ("LEXMARK-MPS-MIB", "deviceMibVersion"), ("LEXMARK-MPS-MIB", "deviceInstallDate"), ("LEXMARK-MPS-MIB", "deviceMibSupportLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    deviceGroup = deviceGroup.setStatus('current')
if mibBuilder.loadTexts: deviceGroup.setDescription('The Device Group.')
hwInventoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 2)).setObjects(("LEXMARK-MPS-MIB", "hwInventoryParentIndex"), ("LEXMARK-MPS-MIB", "hwInventoryType"), ("LEXMARK-MPS-MIB", "hwInventoryAdminStatus"), ("LEXMARK-MPS-MIB", "hwInventoryStatus"), ("LEXMARK-MPS-MIB", "hwInventoryPartNumber"), ("LEXMARK-MPS-MIB", "hwInventorySerialNumber"), ("LEXMARK-MPS-MIB", "hwInventoryDescription"), ("LEXMARK-MPS-MIB", "hwInventoryData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwInventoryGroup = hwInventoryGroup.setStatus('current')
if mibBuilder.loadTexts: hwInventoryGroup.setDescription('The Hardware Inventory Group.')
supplyInventoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 3)).setObjects(("LEXMARK-MPS-MIB", "supplyInventoryType"), ("LEXMARK-MPS-MIB", "supplyInventoryColorantValue"), ("LEXMARK-MPS-MIB", "supplyInventoryDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    supplyInventoryGroup = supplyInventoryGroup.setStatus('current')
if mibBuilder.loadTexts: supplyInventoryGroup.setDescription('The supplies inventory Group.')
swInventoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 4)).setObjects(("LEXMARK-MPS-MIB", "swInventoryParentIndex"), ("LEXMARK-MPS-MIB", "swInventoryType"), ("LEXMARK-MPS-MIB", "swInventoryName"), ("LEXMARK-MPS-MIB", "swInventoryRevision"), ("LEXMARK-MPS-MIB", "swInventoryAdminStatus"), ("LEXMARK-MPS-MIB", "swInventoryStatus"), ("LEXMARK-MPS-MIB", "swInventoryDescription"), ("LEXMARK-MPS-MIB", "swInventoryHWIndex"), ("LEXMARK-MPS-MIB", "swInventoryData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    swInventoryGroup = swInventoryGroup.setStatus('current')
if mibBuilder.loadTexts: swInventoryGroup.setDescription('The Software Inventory Group.')
statsGeneralCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 5)).setObjects(("LEXMARK-MPS-MIB", "genCountType"), ("LEXMARK-MPS-MIB", "genCountUnits"), ("LEXMARK-MPS-MIB", "genCountValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsGeneralCountGroup = statsGeneralCountGroup.setStatus('current')
if mibBuilder.loadTexts: statsGeneralCountGroup.setDescription('The general scan counts and statistics group.')
statsPaperGeneralCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 6)).setObjects(("LEXMARK-MPS-MIB", "paperGeneralCountType"), ("LEXMARK-MPS-MIB", "paperGeneralCountUnits"), ("LEXMARK-MPS-MIB", "paperGeneralCountValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsPaperGeneralCountGroup = statsPaperGeneralCountGroup.setStatus('current')
if mibBuilder.loadTexts: statsPaperGeneralCountGroup.setDescription('The general paper usage count group.')
statsPaperSidesCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 7)).setObjects(("LEXMARK-MPS-MIB", "paperSidesPaperSize"), ("LEXMARK-MPS-MIB", "paperSidesPaperType"), ("LEXMARK-MPS-MIB", "paperSidesMonoPicked"), ("LEXMARK-MPS-MIB", "paperSidesColorPicked"), ("LEXMARK-MPS-MIB", "paperSidesMonoSafe"), ("LEXMARK-MPS-MIB", "paperSidesColorSafe"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsPaperSidesCountGroup = statsPaperSidesCountGroup.setStatus('current')
if mibBuilder.loadTexts: statsPaperSidesCountGroup.setDescription('The paper sides count group.')
statsPaperSheetsCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 8)).setObjects(("LEXMARK-MPS-MIB", "paperSheetsPaperSize"), ("LEXMARK-MPS-MIB", "paperSheetsPaperType"), ("LEXMARK-MPS-MIB", "paperSheetsPicked"), ("LEXMARK-MPS-MIB", "paperSheetsSafe"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsPaperSheetsCountGroup = statsPaperSheetsCountGroup.setStatus('current')
if mibBuilder.loadTexts: statsPaperSheetsCountGroup.setDescription('The paper sheets count group.')
statsPaperNupCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 9)).setObjects(("LEXMARK-MPS-MIB", "paperNupNumber"), ("LEXMARK-MPS-MIB", "paperNupSides"), ("LEXMARK-MPS-MIB", "paperNupLogicalSides"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsPaperNupCountGroup = statsPaperNupCountGroup.setStatus('current')
if mibBuilder.loadTexts: statsPaperNupCountGroup.setDescription('The paper sheets count group.')
statsPaperJobSizeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 10)).setObjects(("LEXMARK-MPS-MIB", "paperJobSizeMinimum"), ("LEXMARK-MPS-MIB", "paperJobSizeMaximum"), ("LEXMARK-MPS-MIB", "paperJobSizeSideCount"), ("LEXMARK-MPS-MIB", "paperJobSizeJobCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsPaperJobSizeGroup = statsPaperJobSizeGroup.setStatus('current')
if mibBuilder.loadTexts: statsPaperJobSizeGroup.setDescription('The job size group.')
statsScanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 11)).setObjects(("LEXMARK-MPS-MIB", "scanCountType"), ("LEXMARK-MPS-MIB", "scanCountSize"), ("LEXMARK-MPS-MIB", "scanCountSides"), ("LEXMARK-MPS-MIB", "scanCountSheets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsScanGroup = statsScanGroup.setStatus('current')
if mibBuilder.loadTexts: statsScanGroup.setDescription('The scan counts and statistics group.')
statsCurrentSuppliesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 12)).setObjects(("LEXMARK-MPS-MIB", "currentSupplyInventoryIndex"), ("LEXMARK-MPS-MIB", "currentSupplyType"), ("LEXMARK-MPS-MIB", "currentSupplyColorantValue"), ("LEXMARK-MPS-MIB", "currentSupplySerialNumber"), ("LEXMARK-MPS-MIB", "currentSupplyPartNumber"), ("LEXMARK-MPS-MIB", "currentSupplyCapacity"), ("LEXMARK-MPS-MIB", "currentSupplyPageCountAtInstall"), ("LEXMARK-MPS-MIB", "currentSupplyCapacityUnit"), ("LEXMARK-MPS-MIB", "currentSupplyClass"), ("LEXMARK-MPS-MIB", "currentSupplyCartridgeType"), ("LEXMARK-MPS-MIB", "currentSupplyInstallDate"), ("LEXMARK-MPS-MIB", "currentSupplyDescription"), ("LEXMARK-MPS-MIB", "currentSupplyCurrentLevel"), ("LEXMARK-MPS-MIB", "currentSupplyCurrentStatus"), ("LEXMARK-MPS-MIB", "currentSupplyUsage"), ("LEXMARK-MPS-MIB", "currentSupplyCoverage"), ("LEXMARK-MPS-MIB", "currentSupplyCalibrations"), ("LEXMARK-MPS-MIB", "currentSupplyFirstKnownLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsCurrentSuppliesGroup = statsCurrentSuppliesGroup.setStatus('current')
if mibBuilder.loadTexts: statsCurrentSuppliesGroup.setDescription('The current supplies listing group')
statsSupplyHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 13)).setObjects(("LEXMARK-MPS-MIB", "supplyHistoryInventoryIndex"), ("LEXMARK-MPS-MIB", "supplyHistorySupplyType"), ("LEXMARK-MPS-MIB", "supplyHistoryColorantValue"), ("LEXMARK-MPS-MIB", "supplyHistoryDescription"), ("LEXMARK-MPS-MIB", "supplyHistorySerialNumber"), ("LEXMARK-MPS-MIB", "supplyHistoryCartridgeType"), ("LEXMARK-MPS-MIB", "supplyHistoryInstallDate"), ("LEXMARK-MPS-MIB", "supplyHistoryPageCount"), ("LEXMARK-MPS-MIB", "supplyHistoryCapacityUnit"), ("LEXMARK-MPS-MIB", "supplyHistoryCapacity"), ("LEXMARK-MPS-MIB", "supplyHistoryLastLevel"), ("LEXMARK-MPS-MIB", "supplyHistoryUsage"), ("LEXMARK-MPS-MIB", "supplyHistoryCalibrations"), ("LEXMARK-MPS-MIB", "supplyHistoryCoverage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsSupplyHistoryGroup = statsSupplyHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: statsSupplyHistoryGroup.setDescription('The supplies history listing group')
statsSupplyHistogramGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 14)).setObjects(("LEXMARK-MPS-MIB", "supplyHistogramInventoryIndex"), ("LEXMARK-MPS-MIB", "supplyHistogramSupplyType"), ("LEXMARK-MPS-MIB", "supplyHistogramColorantValue"), ("LEXMARK-MPS-MIB", "supplyHistogramDescription"), ("LEXMARK-MPS-MIB", "supplyHistogramCapacityUnit"), ("LEXMARK-MPS-MIB", "supplyHistogramCapacity"), ("LEXMARK-MPS-MIB", "supplyHistogramCount"), ("LEXMARK-MPS-MIB", "supplyHistogramCountUnits"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    statsSupplyHistogramGroup = statsSupplyHistogramGroup.setStatus('current')
if mibBuilder.loadTexts: statsSupplyHistogramGroup.setDescription('The supplies histogram group')
deviceAlertGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 641, 6, 1, 2, 16)).setObjects(("LEXMARK-MPS-MIB", "deviceAlertIndex"), ("LEXMARK-MPS-MIB", "deviceAlertConfigTableNode"), ("LEXMARK-MPS-MIB", "deviceAlertConfigTableIndex"), ("LEXMARK-MPS-MIB", "deviceAlertSeverity"), ("LEXMARK-MPS-MIB", "deviceAlertCode"), ("LEXMARK-MPS-MIB", "deviceAlertDescription"), ("LEXMARK-MPS-MIB", "deviceAlertData"), ("LEXMARK-MPS-MIB", "deviceAlertTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    deviceAlertGroup = deviceAlertGroup.setStatus('current')
if mibBuilder.loadTexts: deviceAlertGroup.setDescription('The device alert group')
mpsMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 641, 6, 1, 1, 1)).setObjects(("LEXMARK-MPS-MIB", "deviceGroup"), ("LEXMARK-MPS-MIB", "deviceGroup"), ("LEXMARK-MPS-MIB", "hwInventoryGroup"), ("LEXMARK-MPS-MIB", "supplyInventoryGroup"), ("LEXMARK-MPS-MIB", "swInventoryGroup"), ("LEXMARK-MPS-MIB", "statsGeneralCountGroup"), ("LEXMARK-MPS-MIB", "statsPaperGeneralCountGroup"), ("LEXMARK-MPS-MIB", "statsPaperSidesCountGroup"), ("LEXMARK-MPS-MIB", "statsPaperSheetsCountGroup"), ("LEXMARK-MPS-MIB", "statsPaperNupCountGroup"), ("LEXMARK-MPS-MIB", "statsPaperJobSizeGroup"), ("LEXMARK-MPS-MIB", "statsScanGroup"), ("LEXMARK-MPS-MIB", "statsCurrentSuppliesGroup"), ("LEXMARK-MPS-MIB", "statsSupplyHistoryGroup"), ("LEXMARK-MPS-MIB", "statsSupplyHistogramGroup"), ("LEXMARK-MPS-MIB", "deviceAlertGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mpsMIBCompliance = mpsMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: mpsMIBCompliance.setDescription("The requirements for conformance to the LEXMARK mps MIB We expect printers to support one of four levels of support. The following list shows the minimum level of support that must be implemented. Additional tables may be supported at the device's descretion. Note: For tables that count sides/sheets, if duplex is not supported on a device it only needs to ever count sides. ")
mibBuilder.exportSymbols("LEXMARK-MPS-MIB", supplyHistogramDescription=supplyHistogramDescription, currentSupplyCapacity=currentSupplyCapacity, supplyHistogramEntry=supplyHistogramEntry, paperSidesColorPicked=paperSidesColorPicked, paperNupSides=paperNupSides, CartridgeTypeTC=CartridgeTypeTC, genCountUnits=genCountUnits, PYSNMP_MODULE_ID=mpsMibModule, paperSheetsPaperSize=paperSheetsPaperSize, deviceAlertDescription=deviceAlertDescription, paperGeneralCountUnits=paperGeneralCountUnits, deviceAlertConfigTableIndex=deviceAlertConfigTableIndex, stats=stats, supplyHistogramTable=supplyHistogramTable, hwInventoryPartNumber=hwInventoryPartNumber, currentSupplyCalibrations=currentSupplyCalibrations, deviceHrDeviceIndex=deviceHrDeviceIndex, scanCountType=scanCountType, paperSheetsCountEntry=paperSheetsCountEntry, currentSupplyCoverage=currentSupplyCoverage, paperJobSizeMaximum=paperJobSizeMaximum, paperJobSizeTable=paperJobSizeTable, supplyHistogramInventoryIndex=supplyHistogramInventoryIndex, paperGeneralCountType=paperGeneralCountType, hwInventoryStatus=hwInventoryStatus, paperJobSizeSideCount=paperJobSizeSideCount, paperSheetsPaperType=paperSheetsPaperType, paperStats=paperStats, AlertCodeTC=AlertCodeTC, swInventoryGroup=swInventoryGroup, paperSidesMonoSafe=paperSidesMonoSafe, supplyHistoryInstallDate=supplyHistoryInstallDate, paperNupLogicalSides=paperNupLogicalSides, supplyInventoryTable=supplyInventoryTable, currentSupplyCurrentStatus=currentSupplyCurrentStatus, supplyHistogramColorantValue=supplyHistogramColorantValue, genCountTable=genCountTable, deviceAlertGroup=deviceAlertGroup, supplyHistorySupplyType=supplyHistorySupplyType, deviceAlertEntry=deviceAlertEntry, scanCountTable=scanCountTable, paperGeneralCountEntry=paperGeneralCountEntry, supplyHistogramCapacityUnit=supplyHistogramCapacityUnit, deviceMibSupportLevel=deviceMibSupportLevel, deviceAlertIndex=deviceAlertIndex, statsSupplyHistogramGroup=statsSupplyHistogramGroup, paperNupCountEntry=paperNupCountEntry, currentSupplyInventoryIndex=currentSupplyInventoryIndex, currentSupplyFirstKnownLevel=currentSupplyFirstKnownLevel, supplyHistoryIndex=supplyHistoryIndex, deviceInstallDate=deviceInstallDate, hwInventoryIndex=hwInventoryIndex, currentSupplyColorantValue=currentSupplyColorantValue, paperGeneralCountIndex=paperGeneralCountIndex, statsSupplyHistoryGroup=statsSupplyHistoryGroup, currentSupplyCapacityUnit=currentSupplyCapacityUnit, hwInventoryTable=hwInventoryTable, inventory=inventory, paperSheetsCountIndex=paperSheetsCountIndex, deviceAlertSeverity=deviceAlertSeverity, paperSidesCountEntry=paperSidesCountEntry, supplyHistoryCartridgeType=supplyHistoryCartridgeType, SupplyTypeTC=SupplyTypeTC, deviceTable=deviceTable, alerts=alerts, supplyInventoryIndex=supplyInventoryIndex, deviceAlertData=deviceAlertData, mpsMIBGroups=mpsMIBGroups, paperSidesMonoPicked=paperSidesMonoPicked, currentSupplyCurrentLevel=currentSupplyCurrentLevel, currentSupplyInstallDate=currentSupplyInstallDate, scanCountEntry=scanCountEntry, paperNupNumber=paperNupNumber, hwInventoryDescription=hwInventoryDescription, swInventoryIndex=swInventoryIndex, paperGeneralCountTable=paperGeneralCountTable, supplyHistogramCount=supplyHistogramCount, swInventoryDescription=swInventoryDescription, supplyInventoryType=supplyInventoryType, hwInventoryData=hwInventoryData, hwInventoryType=hwInventoryType, currentSupplyIndex=currentSupplyIndex, supplyHistoryCalibrations=supplyHistoryCalibrations, deviceMibVersion=deviceMibVersion, supplyHistogramCountUnits=supplyHistogramCountUnits, swInventoryAdminStatus=swInventoryAdminStatus, supplyHistogramIndex=supplyHistogramIndex, generalStats=generalStats, deviceModel=deviceModel, swInventoryTable=swInventoryTable, supplyHistoryUsage=supplyHistoryUsage, currentSupplyType=currentSupplyType, currentSupplyCartridgeType=currentSupplyCartridgeType, supplyHistoryCapacityUnit=supplyHistoryCapacityUnit, swInventoryParentIndex=swInventoryParentIndex, mpsMIBAdminInfo=mpsMIBAdminInfo, supplyHistoryPageCount=supplyHistoryPageCount, logs=logs, supplyHistoryLastLevel=supplyHistoryLastLevel, mpsMIBCompliance=mpsMIBCompliance, mpsMIBCompliances=mpsMIBCompliances, swInventoryStatus=swInventoryStatus, paperJobSizeEntry=paperJobSizeEntry, currentSupplyPageCountAtInstall=currentSupplyPageCountAtInstall, deviceEntry=deviceEntry, statsPaperJobSizeGroup=statsPaperJobSizeGroup, hwInventorySerialNumber=hwInventorySerialNumber, swInventoryRevision=swInventoryRevision, swInventoryData=swInventoryData, deviceV2AlertMPSPrefix=deviceV2AlertMPSPrefix, supplyInventoryGroup=supplyInventoryGroup, deviceSerialNumber=deviceSerialNumber, deviceIndex=deviceIndex, hwInventoryEntry=hwInventoryEntry, statsPaperGeneralCountGroup=statsPaperGeneralCountGroup, paperSheetsPicked=paperSheetsPicked, paperSidesCountTable=paperSidesCountTable, scanCountSize=scanCountSize, mps=mps, paperSidesPaperType=paperSidesPaperType, deviceAlertConfigTableNode=deviceAlertConfigTableNode, scanCountSheets=scanCountSheets, deviceV2AlertMPS=deviceV2AlertMPS, statsGeneralCountGroup=statsGeneralCountGroup, statsPaperNupCountGroup=statsPaperNupCountGroup, device=device, supplyInventoryDescription=supplyInventoryDescription, genCountIndex=genCountIndex, supplyInventoryColorantValue=supplyInventoryColorantValue, swInventoryName=swInventoryName, paperSidesColorSafe=paperSidesColorSafe, scanCountSides=scanCountSides, paperJobSizeJobCount=paperJobSizeJobCount, SeverityTC=SeverityTC, swInventoryHWIndex=swInventoryHWIndex, deviceAlertTime=deviceAlertTime, genCountType=genCountType, hwInventoryParentIndex=hwInventoryParentIndex, deviceMibLocalization=deviceMibLocalization, currentSuppliesTable=currentSuppliesTable, currentSupplyUsage=currentSupplyUsage, statsPaperSidesCountGroup=statsPaperSidesCountGroup, paperSidesCountIndex=paperSidesCountIndex, deviceAlertCode=deviceAlertCode, supplyHistoryTable=supplyHistoryTable, paperNupCountTable=paperNupCountTable, paperSheetsSafe=paperSheetsSafe, supplyHistoryColorantValue=supplyHistoryColorantValue, paperJobSizeMinimum=paperJobSizeMinimum, swInventoryType=swInventoryType, paperJobSizeIndex=paperJobSizeIndex, supplyHistoryCoverage=supplyHistoryCoverage, deviceAlertTable=deviceAlertTable, swInventoryEntry=swInventoryEntry, currentSupplyDescription=currentSupplyDescription, supplyHistorySerialNumber=supplyHistorySerialNumber, paperSidesPaperSize=paperSidesPaperSize, currentSupplySerialNumber=currentSupplySerialNumber, supplyHistoryEntry=supplyHistoryEntry, genCountValue=genCountValue, deviceV1AlertMPS=deviceV1AlertMPS, mpsMibModule=mpsMibModule, paperSheetsCountTable=paperSheetsCountTable, supplyHistogramSupplyType=supplyHistogramSupplyType, currentSuppliesEntry=currentSuppliesEntry, devicePort=devicePort, supplyInventoryEntry=supplyInventoryEntry, applications=applications, genCountEntry=genCountEntry, paperNupCountIndex=paperNupCountIndex, supplyHistoryCapacity=supplyHistoryCapacity, statsPaperSheetsCountGroup=statsPaperSheetsCountGroup, statsCurrentSuppliesGroup=statsCurrentSuppliesGroup, supplyHistogramCapacity=supplyHistogramCapacity, scanStats=scanStats, currentSupplyPartNumber=currentSupplyPartNumber, paperGeneralCountValue=paperGeneralCountValue, supplyHistoryInventoryIndex=supplyHistoryInventoryIndex, currentSupplyClass=currentSupplyClass, hwInventoryGroup=hwInventoryGroup, statsScanGroup=statsScanGroup, hwInventoryAdminStatus=hwInventoryAdminStatus, supplyHistoryDescription=supplyHistoryDescription, scanCountIndex=scanCountIndex, supplyStats=supplyStats, deviceGroup=deviceGroup)

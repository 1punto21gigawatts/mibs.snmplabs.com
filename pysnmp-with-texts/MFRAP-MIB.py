#
# PySNMP MIB module MFRAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MFRAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:11:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, Gauge32, IpAddress, NotificationType, MibIdentifier, NotificationType, ObjectIdentity, Integer32, TimeTicks, internet, iso, ModuleIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Gauge32", "IpAddress", "NotificationType", "MibIdentifier", "NotificationType", "ObjectIdentity", "Integer32", "TimeTicks", "internet", "iso", "ModuleIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
sync = MibIdentifier((1, 3, 6, 1, 4, 1, 485))
mfrap = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8))
mfrapSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 1))
mfrapSysTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 1, 1))
mfrapSysType = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysType.setDescription('A textual description of the system model identifier. for example: SYNC-MFRAP')
mfrapSysSoftRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysSoftRev.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysSoftRev.setDescription('Displays the Software Revision of the application code installed in this node.')
mfrapSysHardRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysHardRev.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysHardRev.setDescription('Displays the Hardware Revision of the node.')
mfrapSysNumT1Installed = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumT1Installed.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumT1Installed.setDescription('The number of Wide Area Network (T1) ports that are installed. There is 1 on the MFRAP.')
mfrapSysNumDteInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumDteInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumDteInstalled.setDescription('The number of user serial data channels (DTE) that are installed. There is 1 on the MFRAP.')
mfrapSysNumMaintInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumMaintInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumMaintInstalled.setDescription('The number of Async Maintenance/Comm (console ports that are installed. There are 2 on the MFRAP: one for the console interface and one for SLIP management.')
mfrapSysName = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapSysName.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysName.setDescription('The user supplied name of the node. This object does not affect operation, but may be useful for network management.')
mfrapSysSerialNo = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysSerialNo.setDescription('The serial number of the board.')
mfrapSysResetNode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(321))).clone(namedValues=NamedValues(("reset-node", 321)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapSysResetNode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysResetNode.setDescription('Command to reset the node. NODE WILL BE OFF-LINE AND USER DATA WILL BE INTERRUPTED FOR APPROXIMATELY 15 SECONDS. Full network recovery may take longer. ')
mfrapSysAmtMemoryInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysAmtMemoryInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysAmtMemoryInstalled.setDescription('The amount of memory (RAM) installed (in megabytes).')
mfrapSysLocation = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapSysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysLocation.setDescription('The user supplied location of the node. This object does not affect operation, but may be useful for network management.')
mfrapSysContact = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapSysContact.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysContact.setDescription('The user supplied contact information for the node. This object does not affect operation, but may be useful for network management.')
mfrapSysPrompt = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapSysPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysPrompt.setDescription('Configurable Command Line Interface (CLI) prompt. CLI is the User Interface protocol used for directly attached VT100 terminal access and for remote access via Telnet.')
mfrapSysBootRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysBootRev.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysBootRev.setDescription('Displays the Software Revision of the Bootstrapping code installed in this node.')
mfrapSysNestId = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapSysNestId.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNestId.setDescription("The user supplied name of the nest where this card resides. This can be used to group all cards from the same nest together for network management. Note an MFRAP standalone unit will not allow this to be 'set' and will return the string 'standalone'.")
mfrapSysFeatureTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 1, 2))
mfrapSysSLIPSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysSLIPSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysSLIPSupported.setDescription('Shows whether the unit has SLIP (Serial Line IP) capability. SLIP is a method for out-of-band management that connects through the asynchronous terminal port.')
mfrapSysPPPSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysPPPSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysPPPSupported.setDescription('Shows whether the unit has PPP (Point to Point protocol) capability. PPP is a method for out-of-band management that connects through the asynchronous terminal port.')
mfrapSysRDOSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysRDOSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysRDOSupported.setDescription('Shows whether the unit has Remote Dial Out capability.')
mfrapSysETHSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysETHSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysETHSupported.setDescription('Shows whether the unit has Ethernet capability.')
mfrapSysTKRSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysTKRSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysTKRSupported.setDescription('Shows whether the unit has Token Ring capability.')
mfrapSysExtTimSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysExtTimSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysExtTimSupported.setDescription('Shows whether the unit has External Timing capability.')
mfrapSysBRISupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysBRISupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysBRISupported.setDescription('Shows whether the unit has BRI (ISDN Basic Rate) capability.')
mfrapSysSelDTESupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysSelDTESupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysSelDTESupported.setDescription('Shows whether the unit has a Selectable DTE interface.')
mfrapSysMLSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysMLSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysMLSupported.setDescription('Shows whether the unit supports MLs (out-of-band management links).')
mfrapSysNumDlcisSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumDlcisSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumDlcisSupported.setDescription('Shows how many DLCIs can be monitored for Short Term Statistics.')
mfrapSysLTFNumDlcis = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysLTFNumDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysLTFNumDlcis.setDescription('Shows how many DLCIs can be specified in the Long Term Statistics Filter.')
mfrapSysLTFNumProtocols = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysLTFNumProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysLTFNumProtocols.setDescription('Shows how many protocols can be specified in the Long Term Statistics Filter.')
mfrapSysNumUserProtocols = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumUserProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumUserProtocols.setDescription('Shows how many protocols can be defined by the user. The user configures TCP/UDP ports which can be monitored as protocols. They are available for short term or long term statistics monitoring.')
mfrapSysNumSnmpMgrs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumSnmpMgrs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumSnmpMgrs.setDescription('Shows how many SNMP managers can be programmed in the table mfrapCfgSnmpMngrTable. These managers are sent TRAPs if configured to do so.')
mfrapSysNumDlciNames = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 1, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapSysNumDlciNames.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapSysNumDlciNames.setDescription('Shows how many DLCI names can be defined by the user in the table mfrapCfgFrPerfDlciNamesTable.')
mfrapConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2))
mfrapCfgMgmtTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1))
mfrapCfgIpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1))
mfrapCfgIpMyIP = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpMyIP.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpMyIP.setDescription('The IP address for this node. This address will be unique to the IP network and is required for in-band or out-of-band ip and SNMP management.')
mfrapCfgIpPeerIP = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpPeerIP.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpPeerIP.setDescription('This parameter is not used internally by the unit. It is intended to identify either the device directly connected to the SLIP port or, in Frame Relay applications, the address of the primary network management station. This should always be non-zero.')
mfrapCfgIpMask = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpMask.setDescription('The IP Network Mask (eg 255.255.255.0).')
mfrapCfgIpMaxMTU = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpMaxMTU.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpMaxMTU.setDescription('The Maximum Transmission Unit is the size of the largest IP packet supported. This value should be set to the lowest value supported by any equipment in the transmission path. A size of 1006 (including header) is suggested.')
mfrapCfgIpChannel = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("slip-port", 2), ("in-band-dlci", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgIpChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpChannel.setDescription('This is the method by which IP traffic is being carried. Either via the SLIP port or a DLCI. This is how your InBand Managenent scheme is set up.')
mfrapCfgIpTelnetEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-telnet", 1), ("disable-telnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpTelnetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpTelnetEnable.setDescription('Enables/Disables the telnet feature. Valid values are enable-telnet (1) and disable-telnet (2).')
mfrapCfgIpTelnetAutoLogOut = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 10, 30, 60))).clone(namedValues=NamedValues(("autologout-at-15-minutes", 1), ("disable-autologout", 2), ("autologout-at-3-minutes", 3), ("autologout-at-5-minutes", 5), ("autologout-at-10-minutes", 10), ("autologout-at-30-minutes", 30), ("autologout-at-60-minutes", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgIpTelnetAutoLogOut.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgIpTelnetAutoLogOut.setDescription('Enables/Disables the telnet auto-logout, logging out the user after a certain length of idle time. Valid values are disable-autologout (2), and a number of timeout intervals including autologout-at-15-minutes (1), autologout-at-3-minutes (3), and the default autologout-at-5-minutes (5).')
mfrapCfgTftpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2))
mfrapCfgTftpInitiate = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgTftpInitiate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpInitiate.setDescription('After setting the other TFTP parameters, start the TFTP Flash ROM upgrade by entering the TFTP password.')
mfrapCfgTftpIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpIpAddress.setDescription('The IP address of the TFTP host from which to retrieve the Flash ROM image.')
mfrapCfgTftpFilename = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpFilename.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpFilename.setDescription('The filename of the new ROM Image on the TFTP host.')
mfrapCfgTftpInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2), ("slip-interface", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpInterface.setDescription("The interface on which TFTP data passes. This is only used for in-band management modes. When a unit is in SLIP mode, this object is not applicable. A 'get'will return a value of '3' and set is ignored. (1) dte-interface (2) t1-interface (3) Not applicable")
mfrapCfgTftpDlci = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63487))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpDlci.setDescription('The DLCI on which the TFTP host can be found. A value of -1 signifies not-applicable.')
mfrapCfgTftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("inactive", 1), ("requested", 2), ("transferring", 3), ("programming", 4), ("transfer-aborted", 5), ("host-no-reply", 6), ("file-not-found", 7), ("invalid-file", 8), ("corrupt-file", 9), ("successful", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpStatus.setDescription('The status of current or most recent TFTP operation. Download can be canceled by a Set to inactive.')
mfrapCfgTftpNumBytes = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgTftpNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpNumBytes.setDescription("The number of Bytes from the ROM image that have been TFTP'd to the unit")
mfrapCfgSnmpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3))
mfrapCfgSnmpFrTrap = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpFrTrap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpFrTrap.setDescription('Controls whether or not the Frame Relay DLCI status change traps are issued. These traps are dfrapDLCIActiveTrap and dfrapDLCIInactiveTrap. (1) FR Trap enabled - a trap will be sent each time an individual DLCI changes status between active and inactive. (2) FR Trap disabled - DLCI state change traps are not sent.')
mfrapCfgSnmpTrapMuting = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10080))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpTrapMuting.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpTrapMuting.setDescription('Controls whether TRAPs are sent or muted. A value of 0 allows TRAPs to be sent. If not 0, the value represents the interval (minutes) at which to send the MutingActive trap. It is the only trap sent during muting. The valid range for the interval is 30 to 10080 (a week).')
mfrapCfgSnmpNestAlarmTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpNestAlarmTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpNestAlarmTrapEnable.setDescription("Enables or disables the sending of traps for fan and/or power supply alarms. Note an MFRAP standalone unit will not allow this to be 'set' and will return the 'disable'.")
mfrapCfgSnmpDandIPortTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpDandIPortTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpDandIPortTrapEnable.setDescription('Enables or disables the sending of traps for the Drop and Insert port. (1) enable the sending of traps (2) disable the sending of traps')
mfrapCfgSnmpUtilTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpUtilTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpUtilTrapEnable.setDescription('Enables or disables the sending of per-DLCI utilization traps. (1) enable utilization traps (2) disable utilization traps ')
mfrapCfgSnmpMgrClearN = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 7), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgSnmpMgrClearN.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrClearN.setDescription(' Deletes the number of entries in the mfrapCfgSnmpMgrTable indicated by the value. If the value is a positive number the entries will be deleted starting from the first entry. If the value is negative the entries will be deleted starting from the last entry. ')
mfrapCfgSnmpMgrTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2), )
if mibBuilder.loadTexts: mfrapCfgSnmpMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrTable.setDescription("The table of IP addresses of SNMP managers to receive this node's TRAPs.")
mfrapCfgSnmpMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgSnmpMgrIndex"))
if mibBuilder.loadTexts: mfrapCfgSnmpMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrEntry.setDescription("The IP address of a SNMP manager to receive this node's TRAPs.")
mfrapCfgSnmpMgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgSnmpMgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrIndex.setDescription('The index to the list of SNMP managers receiving TRAPs.')
mfrapCfgSnmpMgrIP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpMgrIP.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrIP.setDescription("The IP address of a SNMP manager to receive this node's TRAPs. Setting this value to 0.0.0.0 will disable the issuance of traps to the indexed manager.")
mfrapCfgSnmpMgrInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2), ("slip-interface", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpMgrInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrInterface.setDescription('The interface out which the indexed trap manager can be reached. This entry is required in Piggyback and Bi-directional in-band managed applications. In Local, Remote and SLIP-based applications, the interface is known and this parameter is ignored. (1) Traps sent out DTE interface for this manager (2) Traps sent out T1 interface for this manager (3) Traps sent out SLIP interface (async maint port) When the node is configured for SLIP, a GET on this MIB object will return slip-interface(3) and a SET of this MIB object to slip-interface(3) is allowed but unnecessary. When the node is not configured for SLIP, this MIB object can be SET to dte-interface(1) or t1-interface(2); slip-interface(3) would be rejected.')
mfrapCfgSnmpMgrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSnmpMgrDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSnmpMgrDlci.setDescription('The DLCI to use to send TRAPs to this SNMP manager.')
mfrapCfgCommTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4))
mfrapCfgCommMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vt100", 1), ("slip", 2), ("modem", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommMode.setDescription('The protocol running on the Maintenance port. VT100 (1), for the User Interface, SLIP (2) for the SNMP support, MODEM(3) for remote VT100 support.')
mfrapCfgCommBaud = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5, 6))).clone(namedValues=NamedValues(("baud-2400", 2), ("baud-9600", 4), ("baud-19200", 5), ("baud-38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommBaud.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommBaud.setDescription('Asynchronous baud rate for the Maintenance/Comm port (Console). This must be configured to match either the VT100 compatible terminal, MODEM support or the SLIP Terminal Server depending upon the Comm port mode. (2) baud-2400 (4) baud-9600 (5) baud-19200 (6) baud-38400')
mfrapCfgCommDataBits = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("databits-7", 1), ("databits-8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommDataBits.setDescription('Databits for this Communication port. Values are databits-7 (1) and databits-8 (2).')
mfrapCfgCommStopBits = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopbits-1", 1), ("stopbits-1-5", 2), ("stopbits-2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommStopBits.setDescription('Number of Stopbits for this Communication port. Values are stopbits-1 (1), stopbits-1-5 (2), and stopbits-2 (3).')
mfrapCfgCommParity = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-parity", 1), ("odd-parity", 2), ("even-parity", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommParity.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommParity.setDescription('Parity for this Communication port. Values are no-parity (1), odd-parity (2), even-parity (3).')
mfrapCfgCommFlowCtrl = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("no-flow-control", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommFlowCtrl.setDescription('Flow Control for this Communication port. Values are no-flow-control (1).')
mfrapCfgCommModeAutoDetect = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCommModeAutoDetect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCommModeAutoDetect.setDescription('Enables or disables the auto detection of RS-232 data on the front MAINT port. When enabled, and data detected, the unit will temporarily convert to VT100 mode to allow a local user access when the unit is in SLIP or MODEM mode. (1) enable COMM-MAINT port auto detect (2) disable COMM-MAINT port auto detect ')
mfrapCfgFrDLCITable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 5))
mfrapCfgFrDLCIMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inactive", 1), ("local", 2), ("remote", 3), ("bidirectional", 4), ("piggyback", 5), ("fixedDCE", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrDLCIMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrDLCIMode.setDescription('Shows the mode that DLCI In-band Management is set up for - inactive (1) - Inband management is not enabled; local (2) - Inband managed using a dedicated private PVC with access exclusively through the DTE interface; remote (3) - Inband managed using a dedicated private PVC with access exclusively through the WAN interface; bidirectional (4) - Inband managed using a dedicated private PVC with access supported through either interface; piggyback (5) - Inband managed using any provisioned PVC, statistically multiplexed with user data; fixedDCE (6) - Inband managed mode similar to piggyback mode except for LMI behavior; The unit will always source LMI Responses separately on each interface (emulating a Frame Relay DCE device). A single PVC will be provisioned and is used for both user data and management traffic. This mode of operation is useful in an environment that does not include a Frame Relay switch but does include a pair of interconnected Frame Relay FRADs or Routers which can only be configured as a Frame Relay DTE device.')
mfrapCfgFrDLCIValue = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 63487))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrDLCIValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrDLCIValue.setDescription('The DLCI identifier, the value of the DLCI field in the frame.')
mfrapCfgFrDLCIEncap = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rfc1490", 1), ("rfc1490snap", 2), ("auto", 3), ("cisco", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrDLCIEncap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrDLCIEncap.setDescription('This is the protocol used for enacapsulating and formatting ip data for Frame Relay transmission. This setting is specific to management data to and from the unit. (1) RFC1490 - per IETF standard with Network Level Protocol ID (NLPID) set for IP encapsulation. (2) RFC1490 SNAP/IP - per IETF standard with NLPID set for Sub-Network Access Protocol (SNAP). (3) auto - adjusts to either of these encapsulation techniques as required. (4) Cisco - proprietary encapsulation (4-byte header).')
mfrapCfgFrDLCIMgmtDE = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-DE-bit-0", 1), ("yes-DE-bit-1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrDLCIMgmtDE.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrDLCIMgmtDE.setDescription('Provides user control over the state of the Frame Relay Discard Eligibility bit of all management frames generated by the unit. Frames marked DE=1 are more likely to be dropped in a congested Frame Relay network than those that are DE=0. Heavily congested circumstances can cause both to be dropped. Additionally, frames marked DE=0 may get re-marked to DE=1 by intervening equipment. (1) DE bit cleared to 0: frame is not discard eligible (2) DE bit set to 1: frame is discard eligible')
mfrapCfgAppTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 2))
mfrapCfgAppClockSource = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("internal", 1), ("network", 2), ("dte", 3), ("drop-and-insert", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppClockSource.setDescription('Default timing, or clock, source. There must be only one source on a T1 line. Node should always be network (2) timed on a point-to-network application. Line Driver applications need one node as internal (1), one as network (2). Options are given to source the clock from the DTE port or the D&I port. ')
mfrapCfgAppCircuitId = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppCircuitId.setDescription('Circuit identifier provided by the service provider.')
mfrapCfgAppType = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dedicated", 1), ("frame-relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppType.setDescription('Indicates type of service purchased on the attached network line T1. Valid selections are dedicated (1) and Frame Relay (2).')
mfrapCfgAppFormat = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cbo", 1), ("hdlc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppFormat.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppFormat.setDescription('Refer to Application Type. Frame Relay is based upon HDLC framing. To operate in a Frame Relay application the Format must be set for HDLC. To operate in a protocol-independent application the Format must be set for Constant Bit Operation (CBO). Note - changing this value will automatically change the Application Type setting and vice versa (1) CBO: protocol-independent transparent DSU/CSU (2) HDLC: Frame and protocol aware DSU/CSU')
mfrapCfgAppLpbkTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppLpbkTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppLpbkTimeout.setDescription('The amount of time a loopback may run before timing out and automatically terminating. The timeout is in minutes and a value of 0 means no timeout.')
mfrapCfgAppPerfBuffLimit = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgAppPerfBuffLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgAppPerfBuffLimit.setDescription('This value represents the throttling mechanism used to determine the optimum level of statistical processing versus managability of the unit. The lower the value (1 - 128), the unit becomes more responsive to management commands during very heavy utilization at the possible expense of statistical accuracy. The larger the value (129 - 512), the more accurate the MFRAP performs statistical analysis of the frames but management may seem slow or unresponsive during periods of very heavy link utilization. NOTE: A value of 0 disables statistical processing entirely.')
mfrapCfgT1Table = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 3))
mfrapCfgT1Framing = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("d4", 1), ("esf-54016", 2), ("esf-ansi", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgT1Framing.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgT1Framing.setDescription('Type of Framing on this T1 Line. Check with your service provider to determine value. (1) D4 - also known as Superframe or SF. (2) ESF 54016 - Extended Superframe supporting the Facility Data Link per AT&T pub 54016. ESF provides enhanced performance monitoring capabilities over the FDL. (3) ESF ANSI - Extended SuperFrame supporting the Facility Data Link per ANSI T1.403 standard. ESF provides enhanced performance monitoring capabilities over the FDL.')
mfrapCfgT1LineEncoding = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ami", 1), ("b8zs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgT1LineEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgT1LineEncoding.setDescription("T1 interface bipolar encoding scheme. Check with your service provider to determine value. B8ZS, which inherently provides ample 'ones-density', is recommended. AMI users must pay special attention to the 'ones-density' requirements of the service provider. (1) B8ZS - intercepts and encodes streams of 8 consecutive zeros and transmits them as a special pattern including Bipolar or Line Code Violations. Function not supported on certain networks. (2) AMI - Alternate Mark Inversion - sends the user data without introducing controlled BPVs.")
mfrapCfgT1Density = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-density", 1), ("twelve-half-percent", 2), ("one-in-16", 3), ("one-in-64", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgT1Density.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgT1Density.setDescription("CSU 'ones density' monitor. Defines the maximum number of consecutive zeros that can be transmitted to the WAN. If density monitoring is enabled, the composite signal is guaranteed to meet the selected density threshhold at the expense of user data. (1) No Density Monitoring - unit will transparently transmit user data without regard for ones density. Recommended for use in B8ZS applications, in nx56K applications where bit-7 stuffing is configured for DTE Channel Density, and when an external CSU is used. (2) 12.5% - unit will maintain a sliding window and will assure a minumum of 12.5% or an average of 1 in 8 ones. (3) 1 in 16 - unit will guarantee that no more than 15 consecutive zeros will be transmit to the WAN. (4) 1 in 64 - unit will guarantee that no more than 63 consecutive zeros will be transmit to the WAN.")
mfrapCfgT1Interface = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dsx-1", 1), ("csu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgT1Interface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgT1Interface.setDescription("Enables the unit's internal CSU functionality. Typical network access requires a CSU to condition the WAN signal, guard against network hazards, and provide access to service personnel for network maintenance. (1) Disables internal CSU and unit operates as a DSX-1 cross connect device. This should be the setting if the unit is cabled to an external CSU device providing network access. CSU. (2) Enables internal CSU and corresponding feature set which includes density monitoring, line build-out pulse shaping, ESF facility data link, and certain diagnostic functions. This should be the seting if the unit is directly cabled to the service provider's equipment (such as a smart jack). ")
mfrapCfgT1LboSetting = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zero-db", 1), ("n7-5-db", 2), ("n15-db", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgT1LboSetting.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgT1LboSetting.setDescription('CSU Line Build Out (LBO). This feature provides selectable output signal strength. Consult service provider for proper setting. Signal may require attenuation to equalize it with neighboring equipment or under certain cabled access conditions. Not applicable if CSU functions are diabled (interface type = dsx-1) (1) 0dB - standard output signal (2) -7.5dB - standard output signal attenuated by 7.5dB (3) -15dB - standard output signal attenuated by 15 dB.')
mfrapCfgDteTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 4))
mfrapCfgDteIntfType = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("intf-v35", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteIntfType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteIntfType.setDescription('Sets the electrical interface for the DTE port. (3) V.35 interface (4) RS-449 interface (not supported)')
mfrapCfgDteDataMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data-normal", 1), ("data-invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteDataMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteDataMode.setDescription('Inverts the DTE data for transfer across the WAN. Can make some applications, particularly HDLC-based protocols, meet density requirements even across clear channel DS0s in AMI mode.')
mfrapCfgDteClockMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clock-normal", 1), ("clock-invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteClockMode.setDescription('This selection controls how the unit internally latches the transmit data from the DTE. Normal will sample data with the rising edge of the selected TX Clock, Invert will sample data with the falling edge of the selected TX Clock. The TX Clock is selected using CfgDteTiming. This clock invertion is most useful when loop-2 timing is used - particularly at higher rates and with long cable runs. Only in rare circumstances will clock-invert be used with loop-1 timing. If the DTE Interface TX statistics are indicating excessive crc errors or aborts then changing this setting may have some benefit. (1) normal (2) invert')
mfrapCfgDteTiming = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loop-1", 1), ("loop-2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteTiming.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteTiming.setDescription('Serial DTE Transmit Timing mode. Loop-1 (1) uses the clock returned from the DTE (TT/TCE) to sample tx data, Loop-2 (2) uses the clock (ST/TC) generated by the node to sample tx data.')
mfrapCfgDteLineRate = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1536000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteLineRate.setDescription('Serial DTE Data Rate in bits per second. Valid rates depend upon channel density selection: nX56K for bit-7-stuffing, and nX64K for clear-channel (n is an integer 1-24 inclusive). This read-only value is the value which was most recently set through CfgDteConnRate; in the event of a connection failure, this field should be examined along with CfgDteChannelDensity and CfgDteStartDso to determine the parameter mismatch that caused the connection failure.')
mfrapCfgDteChannelDensity = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(56, 64))).clone(namedValues=NamedValues(("bit-7-stuff", 56), ("clear-channel", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteChannelDensity.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteChannelDensity.setDescription("Packing of serial data into T1 DS0's. Bit-7-stuff supports DTE rates of nX56Kb/s (from 56K to 1344K) and provides sufficient ones-density on any circuit. Clear-channel allows DTE rates of nX64Kb/s (from 64K to 1.536M) and may require an additional means of density enforcement (eg, B8ZS). This read-only value is the value which was most recently set through CfgDteConnDensity; in the event of a connection failure, this field should be examined along with CfgDteLineRate and CfgDteStartDso to determine the parameter mismatch that caused the connection failure.")
mfrapCfgDteStartDs0 = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 40, 41))).clone(namedValues=NamedValues(("ds0-01", 1), ("ds0-02", 2), ("ds0-03", 3), ("ds0-04", 4), ("ds0-05", 5), ("ds0-06", 6), ("ds0-07", 7), ("ds0-08", 8), ("ds0-09", 9), ("ds0-10", 10), ("ds0-11", 11), ("ds0-12", 12), ("ds0-13", 13), ("ds0-14", 14), ("ds0-15", 15), ("ds0-16", 16), ("ds0-17", 17), ("ds0-18", 18), ("ds0-19", 19), ("ds0-20", 20), ("ds0-21", 21), ("ds0-22", 22), ("ds0-23", 23), ("ds0-24", 24), ("no-current-connections", 40), ("non-continuous-ds0s", 41)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteStartDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteStartDs0.setDescription("T1 WAN includes 24 DS0's available for user data. Each DS0 carries either 56Kbit/sec (bit-7-stuffing) or 64KBit/sec (clear-channel). This value is the starting DS0 used by the node to allocate DS0s to match the DTE's data rate. Sequential, contiguous DS0s are assigned as required. The number of DS0s required is based upon the DTE Data Rate and DTE Channel Mapping. This read-only value is the value which was most recently set through DteCfgConnStartDs0; in the event of a connection failure, this field should be examined along with CfgDteLineRate and CfgDteChanelDensity to determine the parameter mismatch that caused the connection failure.")
mfrapCfgDteConnStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("connections-valid", 1), ("no-current-connections", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnStatus.setDescription('The current status of the WAN to DTE mappings. (1) connections valid and DS0s allocated to DTE data. (4) no connections configured between WAN and DTE.')
mfrapCfgDteConnStartDs0 = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 40, 41))).clone(namedValues=NamedValues(("ds0-01", 1), ("ds0-02", 2), ("ds0-03", 3), ("ds0-04", 4), ("ds0-05", 5), ("ds0-06", 6), ("ds0-07", 7), ("ds0-08", 8), ("ds0-09", 9), ("ds0-10", 10), ("ds0-11", 11), ("ds0-12", 12), ("ds0-13", 13), ("ds0-14", 14), ("ds0-15", 15), ("ds0-16", 16), ("ds0-17", 17), ("ds0-18", 18), ("ds0-19", 19), ("ds0-20", 20), ("ds0-21", 21), ("ds0-22", 22), ("ds0-23", 23), ("ds0-24", 24), ("no-current-connections", 40), ("non-continuous-ds0s", 41)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteConnStartDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnStartDs0.setDescription("T1 WAN includes 24 DS0's available for user data. Each DS0 carries either 56Kbit/sec (bit-7-stuffing) or 64KBit/sec (clear-channel). This value is the starting DS0 used by the node to allocate DS0s to match the DTE's data rate. Sequential, contiguous DS0s are assigned as required. The number of DS0s required is based upon the DTE Data Rate and DTE Channel Mapping. Consult WAN service provider for the appropriate setting here in a fractional T1 application.")
mfrapCfgDteConnRate = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1536000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteConnRate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnRate.setDescription('Serial DTE Data Rate in bits per second. Valid rates depend upon channel density selection: nX56K for bit-7-stuffing, and nX64K for clear-channel (n is an integer 1-24 inclusive). Rates are entered in bits/sec, for example, 128000 for a 128Kbit/sec DTE data rate.')
mfrapCfgDteConnDensity = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(56, 64))).clone(namedValues=NamedValues(("bit-7-stuff", 56), ("clear-channel", 64)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteConnDensity.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnDensity.setDescription("Packing of serial data into T1 DS0's. Bit-7-stuff supports DTE rates of nX56Kb/s (from 56K to 1344K) and provides sufficient ones-density on any circuit. Clear-channel supports DTE rates of nX64Kb/s (from 64K to 1.536M) and may require an additional means of density enforcement (eg, B8ZS). (56) Bit 7 Stuffing (nx56K data rate, n=1-24) (64) Clear Channel (nx64K data rate, n=1-24)")
mfrapCfgDteConnDs0Required = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteConnDs0Required.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnDs0Required.setDescription("The number of DS0s required by the node's DTE port. This is based upon the DTE data rate and channel density selections.")
mfrapCfgDteConnAutoStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("configuration-valid", 1), ("configuration-invalid", 2), ("valid-config-updated", 3), ("invalid-cfg-no-update", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgDteConnAutoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnAutoStatus.setDescription("There's a tight correlation among DTE data rate, starting DS0, and channel density. This read-only parameter reports the status of the most recent change to any of these connection parameters. If the connection request is not valid a mismatch among DteLineRate, DteStartDs0, and DteChannelDensity must be resolved (1) and (3) configuration valid - the previous connections profile is accepted and activated (2) and (4) connections profile invalid, previous configuration remains.")
mfrapCfgDteConnAutoUpdate = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("config-and-connect", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgDteConnAutoUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteConnAutoUpdate.setDescription('Updates the connection-critical parameters: line rate, channel density and starting ds0; drops the currect connection; and initiate the new connection. Following the issuance of this command, DteAutoStatus should be queried to verify the update was successful. The setting of this object updates the mfrapCfgEditTable. In order for the changes to take effect in the system, the mfrapCfgConnUpdateCmd must subsequently be set.')
mfrapCfgDteRts = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal-held-active", 1), ("external-from-dte", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteRts.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteRts.setDescription('Selects whether the RTS signal is external-from-dte (2) or internal-held-active (1).')
mfrapCfgDteDtr = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal-held-active", 1), ("external-from-dte", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteDtr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteDtr.setDescription('Selects whether the DTR signal is external-from-dte (2) or internal-held-active (1).')
mfrapCfgDteDcdOutput = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("signal-off", 1), ("signal-on", 2), ("follow-carrier", 3), ("follow-test", 4), ("follow-rts", 5), ("follow-carrier-rts", 6), ("follow-sync-rts", 7), ("follow-lmi-carr-rts", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteDcdOutput.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteDcdOutput.setDescription('Specifies the behavior of this control signal generated by the M-FRAP towards the DTE. inactive-always (1) - signal is permanently INACTIVE. active-always (2) - signal is permanently ACTIVE. reflect-carrier (3) - signal echoes the carrier signal status from the WAN. inactive-with-test-mode (4) - signal is ACTIVE during normal data transfer and INACTIVE during diagnostic conditions that interfere with data transfer from the DTE to the WAN. follow-RTS (5) - signal echoes the status of RTS as processed from the DTE. reflect-carrier-and-RTS (6) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN. No signal from the WAN or RTS INACTIVE will cause this control signal to be asserted INACTIVE. reflect-sync-and-RTS (7) - signal is a logical AND between RTS processed from the DTE and the frame synchronization with the WAN. Red Alarm defines the threshold for declaring synchronization. reflect-LMI-and-carrier-and-RTS (8) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN and LMI. If the unit is in an LMI passthrough state then LMI is considered Active. LMI Inactivity timer must be non-zero for LMI to be declared Inactive. Note that there is a separate parameter for how the unit processes RTS that is related to this function if options (4), (5), (6), or (7) is selected, see CfgDteRts. ')
mfrapCfgDteDsrOutput = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("signal-off", 1), ("signal-on", 2), ("follow-carrier", 3), ("follow-test", 4), ("follow-rts", 5), ("follow-carrier-rts", 6), ("follow-sync-rts", 7), ("follow-lmi-carr-rts", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteDsrOutput.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteDsrOutput.setDescription('Specifies the behavior of this control signal generated by the M-FRAP towards the DTE. inactive-always (1) - signal is permanently INACTIVE. active-always (2) - signal is permanently ACTIVE. reflect-carrier (3) - signal echoes the carrier signal status from the WAN. inactive-with-test-mode (4) - signal is ACTIVE during normal data transfer and INACTIVE during diagnostic conditions that interfere with data transfer from the DTE to the WAN. follow-RTS (5) - signal echoes the status of RTS as processed from the DTE. reflect-carrier-and-RTS (6) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN. No signal from the WAN or RTS INACTIVE will cause this control signal to be asserted INACTIVE. reflect-sync-and-RTS (7) - signal is a logical AND between RTS processed from the DTE and the frame synchronization with the WAN. Red Alarm defines the threshold for declaring synchronization. reflect-LMI-and-carrier-and-RTS (8) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN and LMI. If the unit is in an LMI passthrough state then LMI is considered Active. LMI Inactivity timer must be non-zero for LMI to be declared Inactive. Note that there is a separate parameter for how the unit processes RTS that is related to this function if options (4), (5), (6), or (7) is selected, see CfgDteRts. ')
mfrapCfgDteCtsOutput = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("signal-off", 1), ("signal-on", 2), ("follow-carrier", 3), ("follow-test", 4), ("follow-rts", 5), ("follow-carrier-rts", 6), ("follow-sync-rts", 7), ("follow-lmi-carr-rts", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDteCtsOutput.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDteCtsOutput.setDescription('Specifies the behavior of this control signal generated by the M-FRAP towards the DTE. inactive-always (1) - signal is permanently INACTIVE. active-always (2) - signal is permanently ACTIVE. reflect-carrier (3) - signal echoes the carrier signal status from the WAN. inactive-with-test-mode (4) - signal is ACTIVE during normal data transfer and INACTIVE during diagnostic conditions that interfere with data transfer from the DTE to the WAN. follow-RTS (5) - signal echoes the status of RTS as processed from the DTE. reflect-carrier-and-RTS (6) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN. No signal from the WAN or RTS INACTIVE will cause this control signal to be asserted INACTIVE. reflect-sync-and-RTS (7) - signal is a logical AND between RTS processed from the DTE and the frame synchronization with the WAN. Red Alarm defines the threshold for declaring synchronization. reflect-LMI-and-carrier-and-RTS (8) - signal is a logical AND between RTS processed from the DTE and the carrier signal status from the WAN and LMI. If the unit is in an LMI passthrough state then LMI is considered Active. LMI Inactivity timer must be non-zero for LMI to be declared Inactive. Note that there is a separate parameter for how the unit processes RTS that is related to this function if options (4), (5), (6), or (7) is selected, see CfgDteRts. ')
mfrapCfgFrTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 5))
mfrapCfgFrAddrLen = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("twobytes", 1), ("threebytes", 2), ("fourbytes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrAddrLen.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrAddrLen.setDescription('Defines the size of the DLCI address field of the Frame Relay header. This setting must correspond to the Frame Relay transmission format; typically Two bytes. (1) two byte DLCI address field (2) three byte DLCI address field (3) four byte DLCI address field')
mfrapCfgFrCrcMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("passthru", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrCrcMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrCrcMode.setDescription('This defines the manner in which the unit handles HDLC protocol errors (crc errors) in a Frame Relay application. If Discard is selected the unit will respond to an errored frame by aborting the frame if transmission has begun; or simply discarding it if transmission has not begun. If Passthru is selected the unit will transmit the entire frame but will place an incorrect crc in it to preserve the error indication. (1) discard (2) passthru')
mfrapCfgFrLmiType = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("annexd", 1), ("annexa", 2), ("type1", 3), ("autosense", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrLmiType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrLmiType.setDescription('The LMI type used in a Frame Relay application. This setting must match the attached Frame Relay device configuration. Annex-A and Annex-D use DLCI 0, and Type 1 uses DLCI 1023. Type 1 is alternatively referred to as Cisco, Group of four, or simply LMI. Annex-D may be referred to as ANSI T1.617. Annex-A may be referred to as ITU or CCITT Q.933. Auto-sense will either use the most recently detected LMI type or, in the absence of any LMI, will attempt to instigate LMI communications using each protocol. (1) Annnex-A: conforms to ITU (CCITT) Q.933 annex A (2) Annnex-D: conforms to ANSI T1.617 annex D (3) Type 1: conforms to the original LMI as developed by the Group of Four (4) Auto-sense: unit will attempt to detect and synchronize to the LMI type of the attached equipment.')
mfrapCfgFrLmiInactivityTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrLmiInactivityTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrLmiInactivityTimeout.setDescription('Timer used by the unit to determine that an attached device is not participating in the LMI protocol and that the unit should attempt to source LMI. This timer also controls the length of time that the LMI sourcing state machine remains in a particular state as it attempts to locate an LMI peer. (0) LMI Sourcing disabled (2-255) LMI Inactivity timeout')
mfrapCfgFrLmiKeepaliveTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrLmiKeepaliveTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrLmiKeepaliveTimeout.setDescription('Timer used by the unit to determine the frequency at which Status Enquiries are issued during LMI sourcing states where the unit is emulating a Frame Relay DTE device. (2-255) length of time between sending enquiries (in seconds)')
mfrapCfgFrAddrResMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("arp", 2), ("inarp", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrAddrResMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrAddrResMode.setDescription('Enable ARP (2), INARP (3), both (4), or neither (1).')
mfrapCfgFrAddrResDlcis = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("single", 1), ("multiple", 2), ("t1multi", 3), ("dtemulti", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrAddrResDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrAddrResDlcis.setDescription('Address Resolution Dlcis determines which dlcis are used for address resolution. Multiple DLCI support only applies to piggyback mode; in other management modes, only the configured default dlci is used (1) Support the configured Address Resolution protocol(s) out both ports on the single configured default DLCI only (CfgFrDLCIValue). (2) Support the configured Address Resolution protocol(s) out both ports on all active DLCIs (per LMI). (3) Support the configured Address Resolution protocol(s) out the WAN on all active DLCIs (per LMI) and out the DTE on only the single default DLCI (CfgFrDLCIValue). (4) Support the configured Address Resolution protocol(s) out the DTE on all active DLCIs (per LMI) and out the WAN on only the single default DLCI (CfgFrDLCIValue).')
mfrapCfgFrAddrResInarpTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrAddrResInarpTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrAddrResInarpTimer.setDescription('The frequency at which the unit issues INARP requests (in seconds) from 5 to 86400 (24 hours).')
mfrapCfgFrLmiFullStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrLmiFullStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrLmiFullStatus.setDescription("Timer used by the unit to determine if an LMI Full Status Report is missing. In the absence of a Full Status report for the duration defined by this timer, the unit will declare all DLCI's status INACTIVE and begin logging down time. Data passage is not interfered with. (0) Full Status Timer is disabled (20-3600) Full Status Report Timeout in seconds.")
mfrapCfgVnipTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 6))
mfrapCfgVnipMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("dte", 2), ("t1", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgVnipMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgVnipMode.setDescription("This setting configures the unit for VNIP topology support on a per-interface basis. Establishing a VNIP topology is a fundamental prerequisite to applying the VNIP feature set which includes PVC-based delay measurement, diagnostics, and congestion monitoring. With VNIP enabled on an interface the unit will attempt to locate VNIP peers out that port. As peers are discovered and logged the unit will report the topology it has learned on its opposite interface. If VNIP is inactive on one interface it will not engage in any VNIP dialog; however it will continue to listen for topology messages on the inactive interface and will reflect these messages out the opposite interface if VNIP is enabled. With VNIP inactive on both interfaces the unit will transparently pass all VNIP messages. The topology database includes ip addresses, DLCI values, and the number of VNIP hops in between. (1) Topology Inactive: VNIP messages pass through unit (2) Topology Enabled on DTE only: unit logs VNIP peers seen out the DTE interface. Unit listens for topology reports from the WAN but doesn't generate any towards the WAN. Will report learned WAN topology towards the DTE. (3) Topology Enabled on WAN only: unit logs VNIP peers seen out the WAN interface. Unit listens for topology reports from the DTE but doesn't generate any towards the DTE. Will report learned DTE topology towards the WAN. (4) Topolgy Enabled on Both DTE and WAN: Unit logs VNIP peers seen out both interfaces and generates DTE topolgy reports towards the WAN and vice versa.")
mfrapCfgVnipInitTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgVnipInitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgVnipInitTimer.setDescription('The frequency of hello messages sent during initialization in seconds from 5 seconds to 86400 seconds (24 hours).')
mfrapCfgVnipKeepAliveTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgVnipKeepAliveTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgVnipKeepAliveTimer.setDescription("This is the frequency that topology reports are issued out any interface that has VNIP enabled. Once a Hello exchange occurs, the unit will periodically issue a VNIP message which reflects the topology it has learned on the opposite interface. This Keep Alive timer must be less than any peer unit's Inactivity timer. (5-86400) VNIP Topology Update frequency (in seconds)")
mfrapCfgVnipInactivityTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgVnipInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgVnipInactivityTimer.setDescription('The length of time to wait before dropping a VNIP peer from the database and attempting tp reestablish communications by issuing the VNIP Hello message. If this timer expires then the entire topology database is reset. The Inactivity timers of any unit participating in a VNIP topology must be greater than the highest Keep Alive timer in the topology. (5- 86400) VNIP Hello frequency (in seconds)')
mfrapCfgVnipTransitDelayFrequency = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgVnipTransitDelayFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgVnipTransitDelayFrequency.setDescription('Transit Delay measurements may be enabled between any DLCI peers that have been logged through the topology protocol. Delay messages are issued at this frequency and results are recorded. Transit delay measures the round-trip network delay between two VNIP peers (internal unit latencies are not part of the measurement). Traps may be optionally generated if a delay threshold is exceeded. (15-86400): Transit Delay message frequency (in seconds)')
mfrapCfgTransitDelayTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20), )
if mibBuilder.loadTexts: mfrapCfgTransitDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayTable.setDescription("The table defining the transit delay measurement profile for each of the learned VNIP peers. As peers are located and logged into the topology database, a default transit delay profile is assumed. The default is to enable transit delay to all hops located out the interface. A DLCI's transit delay profile cannot be modified unless the DLCI has been discovered through the VNIP topology protocol.")
mfrapCfgTransitDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgTransitDelayInterface"), (0, "MFRAP-MIB", "mfrapCfgTransitDelayDlciValue"))
if mibBuilder.loadTexts: mfrapCfgTransitDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayEntry.setDescription("A VNIP Transit Delay configuration entry for a particular DLCI on a particular interface. A DLCI's transit delay profile cannot be modified unless the DLCI has been discovered through the VNIP topology protocol")
mfrapCfgTransitDelayInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTransitDelayInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayInterface.setDescription('This is the interface being configured for VNIP Transit Delay. If topology is enabled, each interface will contain a database of VNIP peers organized by DLCI value and Number of Hops. (1) DTE Interface (2) DDS Interface')
mfrapCfgTransitDelayDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTransitDelayDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayDlciValue.setDescription('This is the DLCI being configured for VNIP Transit Delay. If topology is enabled, each interface will contain a database of VNIP peers organized by DLCI value and Number of Hops.')
mfrapCfgTransitDelayNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTransitDelayNumHops.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayNumHops.setDescription('VNIP topolgy may include multiple units on a given DLCI/interface. The topology logs the number of intermediate VNIP peers between units (Hops). This setting determines which peers on a DLCI are participating in delay measurements. (0) All hops (1-254) individually addressable delay measurement between any two peers. (255) Furthest hop only')
mfrapCfgTransitDelayRcvSummaryCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-rsc", 1), ("disable-rsc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTransitDelayRcvSummaryCancel.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayRcvSummaryCancel.setDescription("Controls the Receive Summary Cancellation feature of VNIP Transit Delay on this interface/DLCI. Every Transit Delay measurement exchange includes a follow-up message from the initiator with the delay results. If RSC is enabled, a unit will log results based upon this summary message and will not issue its next scheduled delay measurement. With RSC disabled, the unit will not use the summary message and will always issue its regularly scheduled message based on the delay frequency timer. The purpose of this feature is to reduce traffic introduced by VNIP. In a typical peer-to-peer transit delay measurement where both ends are concurrently conducting transit delay measurements it's recommended that one end have RSC enabled and one end disabled.")
mfrapCfgTransitDelayThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 20, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTransitDelayThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayThreshold.setDescription('Specifies a transit delay threshold for this DLCI/interface. When the transit delay exceeds the threshold, a TRAP is sent. The threshold may be set from one millisecond to 24 hours. A value of 0 will prevent a TRAP from being sent. (0): Transit delay threshold trap disabled for this DLCI/interface (1-86400000): delay threshhold. Any delay measurements exceeding this result will generate a trap.')
mfrapCfgTDDeleteTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 21), )
if mibBuilder.loadTexts: mfrapCfgTDDeleteTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTDDeleteTable.setDescription('The table allows the user to disable transit delay measurements for a specific DLCI on a particular interface.')
mfrapCfgTDDeleteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 21, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgTDDeleteInterface"))
if mibBuilder.loadTexts: mfrapCfgTDDeleteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTDDeleteEntry.setDescription('Disables VNIP Transit Delay for a particular interface and DLCI.')
mfrapCfgTDDeleteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2))))
if mibBuilder.loadTexts: mfrapCfgTDDeleteInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTDDeleteInterface.setDescription('Transit delay can be disabled for a given DLCI on either interface. This indexes the interface. Setting this index and the associated DLCI index will disable transit delay on that combination.')
mfrapCfgTDDeleteDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 21, 1, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgTDDeleteDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTDDeleteDlciValue.setDescription('Transit delay can be disabled for a given DLCI on either interface. This indexes the DLCI. Setting this index and the associated interface index will disable transit delay on that combination.')
mfrapCfgTransitDelayTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 6, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgTransitDelayTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTransitDelayTableClear.setDescription(' The mfrapCfgTransitDelayTable is cleared. (1) clear the table ')
mfrapCfgFrPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 7))
mfrapCfgFrPerfDlciNamesTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1), )
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesTable.setDescription('This table allows the user to configure DLCI specific parameters such as Names, CIR, and EIR. Additionally, any DLCIs configured with these parameters will be added into the Short Term statistics database next time its cleared.')
mfrapCfgFrPerfDlciNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgFrPerfDlciNamesDlciValue"))
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesEntry.setDescription('A table entry indexed by DLCI, containing a DLCI, a DLCI name, a CIR, and how the CIR value was obtained.')
mfrapCfgFrPerfDlciNamesDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDlciValue.setDescription("A DLCI selected for customized configuration and to be added to short term statistics collection (if it wasn't already there).")
mfrapCfgFrPerfDlciNamesDlciName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDlciName.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDlciName.setDescription('A user-specifiable name for an individual DLCI.')
mfrapCfgFrPerfDlciNamesCirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesCirValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesCirValue.setDescription('The CIR value for an individual DLCI. This value is used in the calculation utilization as a percentage of CIR. If the CIR is reported in the LMI message then the reported value will override this configured entry. In the absence of LMI CIR and a configured CIR, the unit will assume that the CIR is the DTE Line Rate.')
mfrapCfgFrPerfDlciNamesCirType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cir-acquired-from-lmi", 1), ("cir-configured-by-user", 2), ("cir-is-datarate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesCirType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesCirType.setDescription('The source of the CIR value for this DLCI. If CIR for a DLCI is part of the LMI message then this LMI supplied CIR will override any defined CIR. If CIR is not part of LMI and has not been explicitly defined by the user it will default to the DTE Line Rate. (1) CIR reported in LMI Full Status message (2) CIR configured by user (3) CIR defaulted to DTE Line Rate')
mfrapCfgFrPerfDlciNamesUtilThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesUtilThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesUtilThreshold.setDescription("The threshold for generating a utilization threshold trap as a percentage of the CIR. If the utilization percentage is above this threshold for more than mfrapCfgFrPerfDlciUtilThreshold number of mfrapCfgFrPerfTimersSTInterval's a mfrapPvc(Rx/Tx)UtilizationExceeded trap will be issued. If the If the utilization percentage falls below this threshold for more than mfrapCfgFrPerfDlciUtilThreshold number of mfrapCfgFrPerfTimersSTInterval's a mfrapPvc(Rx/Tx)UtilizationExceeded trap will be issued.")
mfrapCfgFrPerfDlciNamesEirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesEirValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesEirValue.setDescription('The EIR value for an individual DLCI. In the absence of a configured EIR, the unit will assume that the EIR is the DTE Line Rate.')
mfrapCfgFrPerfDlciNamesDelete = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDelete.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesDelete.setDescription('Setting this object with a specific DLCI value will remove the DLCI from the DLCI-specific parameters database.')
mfrapCfgFrPerfTimers = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 3))
mfrapCfgFrPerfTimersSTInterval = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfTimersSTInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfTimersSTInterval.setDescription('Short term statistics maintain cumulative counts, and counts for the current and previous short term windows. This value is the window size for the short term statistics intervals. (3-60): short term statistics collection interval')
mfrapCfgFrPerfTimersLTInterval = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfTimersLTInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfTimersLTInterval.setDescription('Long term statistics maintain 96 contiguous intervals of configurable protocol per DLCI statistics. This value is the window size of each interval. Adjusting this value will change the overall length of time that the 96 intervals will span. (4-3600): long term statsistics collection interval')
mfrapCfgFrPerfUserProtocolsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 4), )
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsTable.setDescription('This table allows the user to select TCP/UDP ports for statistics collection. Tx and Rx byte counts will collected on the specified ports. These ports are selectable as protocols in the long term statistics filter and are displayed with the other protocols in the short term statistics.')
mfrapCfgFrPerfUserProtocolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 4, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgFrPerfUserProtocolsIndex"))
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsEntry.setDescription('An index and TCP/UDP port number pair.')
mfrapCfgFrPerfUserProtocolsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsIndex.setDescription('An index. Beginning with index 1, the range is defined in SysNumUserProtocols')
mfrapCfgFrPerfUserProtocolsPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsPortNum.setDescription('Tx and Rx byte counts will be collected on the user-specifiable TCP/UDP port number. (0) port not defined (1-65535): IP TCP/UDP protocol port number.')
mfrapCfgFrPerfLTDlciFilterTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 5), )
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterTable.setDescription('Long term statistics can only be collected on a limited number of DLCIs. The value of SysLTFNumDlcis defines the maximum number of DLCIs that can be included in the Long Term Statistics. Once one or more DLCIs are added to Long Term Stats, the user may assign a set of protocols that will be monitored across all of the Long Term DLCIs.')
mfrapCfgFrPerfLTDlciFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 5, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgFrPerfLTDlciFilterIndex"))
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterEntry.setDescription('An index and DLCI number pair.')
mfrapCfgFrPerfLTDlciFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterIndex.setDescription('An index. Beginning with index 1, the maximum is defined by the value of SysLTFNumDlcis.')
mfrapCfgFrPerfLTDlciFilterDlciNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterDlciNum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterDlciNum.setDescription('Setting a DLCI value here will add that DLCI into the Long term statistics database (associated with its index) and it will be monitored for the protocol activity defined in the Long Term Protocol filter.')
mfrapCfgFrPerfLTProtocolFilterTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 6), )
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterTable.setDescription('Long term statistics can only be collected on a limited number of protocols. The maximum number of Long Term Protoocls are defined by SysLTFNumProtocols. This table allows the user to configure those protocols.')
mfrapCfgFrPerfLTProtocolFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 6, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgFrPerfLTProtocolFilterIndex"))
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterEntry.setDescription('An index and protocol pair.')
mfrapCfgFrPerfLTProtocolFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterIndex.setDescription('An index. Beginning with index 1, the maximum is defined by the value of SysLTFNumProtocols.')
mfrapCfgFrPerfLTProtocolFilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, -1))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-bc", 129), ("thru-frame-rx-bc", 130), ("thru-fecn-tx-bc", 131), ("thru-fecn-rx-bc", 132), ("thru-becn-tx-bc", 133), ("thru-becn-rx-bc", 134), ("thru-de-tx-bc", 135), ("thru-de-rx-bc", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172), ("delete-entry", -1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterProtocol.setDescription('Long term statistics will be collected on the user-specifiable protocol. Setting a -1 remove the indexed protocol from the filter.')
mfrapCfgFrPerfDlciDefaultUtilThreshold = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciDefaultUtilThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciDefaultUtilThreshold.setDescription('The default threshold for generating a utilization threshold trap as a percentage of the CIR. This value is used for mfrapCfgFrPerfDlciNamesUtilThreshold when a DLCI is first discovered. ')
mfrapCfgFrPerfDlciUtilDuration = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciUtilDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciUtilDuration.setDescription("The number of Short Term Intervals that a DLCI's utilization as a percentage of CIR must be above or below the value of mfrapCfgFrPerfDlciUtilThreshold before a mfrapPvc(Rx/Tx)UtilizationExceededTrap or mfrapPvc(Rx/Tx)UtilizationClearedTrap is issued. ")
mfrapCfgFrPerfDlciNamesTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear-table", 1), ("clear-table-keep-stats", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfDlciNamesTableClear.setDescription("Clears the smperCfgFrPerfDlciNamesTable (1) clear the table or (2) clear the table but don't remove the dlcis from the short term statistics.")
mfrapCfgFrPerfUserProtocolsTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUserProtocolsTableClear.setDescription(' Clears the mfrapCfgFrPerfUserProtocolsTable (1) clear the table ')
mfrapCfgFrPerfLTDlciFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTDlciFilterTableClear.setDescription(' Clears the mfrapCfgFrPerfLTDlciFilterTable (1) clear the table ')
mfrapCfgFrPerfLTProtocolFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfLTProtocolFilterTableClear.setDescription(' Clears the mfrapCfgFrPerfLTProtocolFilterTable (1) clear the table ')
mfrapCfgFrPerfUnprovDlcisDelete = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete-unprov", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgFrPerfUnprovDlcisDelete.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgFrPerfUnprovDlcisDelete.setDescription('Delete all unprovisioned and Not-In-LMI dlcis (1) delete all unprovisioned ')
mfrapCfgSecurityTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 8))
mfrapCfgTelnetCliLcdPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTelnetCliLcdPassword.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTelnetCliLcdPassword.setDescription('The password needed to start a CLI (Command Line Interface), Telnet or LCD session.')
mfrapCfgTftpPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgTftpPassword.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgTftpPassword.setDescription('The password needed to initiate a TFTP download.')
mfrapCfgCliPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgCliPassword.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCliPassword.setDescription('OBSOLETE: The Telnet, CLI and LCD passwords are one and the same. Use the above mfrapCfgTelnetCliLcdPassword to log into the CLI (Command Line Interface).')
mfrapCfgLcdPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgLcdPassword.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLcdPassword.setDescription('OBSOLETE: The Telnet, CLI and LCD passwords are one and the same. Use the above mfrapCfgTelnetCliLcdPassword to log into the LCD Interface.')
mfrapCfgGetCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgGetCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgGetCommunityString.setDescription('The community string for doing SNMP GETs. The unit will respond to GETs that use either this string or the SET community string. All others will be rejected and a trap will be generated. String is case sensitive.')
mfrapCfgSetCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgSetCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgSetCommunityString.setDescription('The community string for doing SNMP SETs. The unit will reject SETs with any other coimmunity string and will generate a trap. String is case sensitive.')
mfrapCfgLcdPswdEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-lcd-pswd", 1), ("disable-lcd-pswd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgLcdPswdEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLcdPswdEnable.setDescription('This selection controls whether a password is necessary to use the LCD interface.')
mfrapCfgLcdPswdTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 8, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgLcdPswdTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLcdPswdTimeout.setDescription('OBSOLETE.')
mfrapCfgConnectionTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 10))
mfrapCfgCurrentConnTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1), )
if mibBuilder.loadTexts: mfrapCfgCurrentConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnTable.setDescription("Retrieves node's active connections assignments for display only. To edit connections, use the mfrapCfgDteTable and/or mfrapCfgEditConnTable.")
mfrapCfgCurrentConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgCurrentConnDestPort"), (0, "MFRAP-MIB", "mfrapCfgCurrentConnDestDs0"))
if mibBuilder.loadTexts: mfrapCfgCurrentConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnEntry.setDescription('An entry in the Current Connections Table.')
mfrapCfgCurrentConnDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("port1-t1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgCurrentConnDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnDestPort.setDescription('Index to Destination port of interest. M-FRAP currently only supports the Network port (1) as the destination')
mfrapCfgCurrentConnDestDs0 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgCurrentConnDestDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnDestDs0.setDescription('DS0 number 1 through 24 corresponding to the destination port index ')
mfrapCfgCurrentConnSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 33))).clone(namedValues=NamedValues(("port2-dandi", 2), ("port3-dte", 3), ("not-connected", 33)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgCurrentConnSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnSrcPort.setDescription('DS0 assignment for Destination port. After making any adjustments to the connections, the mfrapCfgConnUpdateCmd must be sent. Node software does not permit a port connection to itself.')
mfrapCfgCurrentConnSrcDs0 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 40))).clone(namedValues=NamedValues(("ds0-01", 1), ("ds0-02", 2), ("ds0-03", 3), ("ds0-04", 4), ("ds0-05", 5), ("ds0-06", 6), ("ds0-07", 7), ("ds0-08", 8), ("ds0-09", 9), ("ds0-10", 10), ("ds0-11", 11), ("ds0-12", 12), ("ds0-13", 13), ("ds0-14", 14), ("ds0-15", 15), ("ds0-16", 16), ("ds0-17", 17), ("ds0-18", 18), ("ds0-19", 19), ("ds0-20", 20), ("ds0-21", 21), ("ds0-22", 22), ("ds0-23", 23), ("ds0-24", 24), ("no-connection", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgCurrentConnSrcDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnSrcDs0.setDescription('DS0 number 1 through 24 corresponding to the sourced port')
mfrapCfgCurrentConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 33))).clone(namedValues=NamedValues(("voice", 1), ("transparent", 2), ("frame-relay", 3), ("not-connected", 33)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgCurrentConnType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgCurrentConnType.setDescription('Defines the type of traffic being transported.')
mfrapCfgEditConnections = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2))
mfrapCfgEditConnCopyCurrtoEdit = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("copy-current", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgEditConnCopyCurrtoEdit.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnCopyCurrtoEdit.setDescription("Fill the edit buffer with the node's current active connections.")
mfrapCfgEditClearEdit = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-edit", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgEditClearEdit.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditClearEdit.setDescription('Clear all connections from the edit buffer. ')
mfrapCfgEditConnTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3), )
if mibBuilder.loadTexts: mfrapCfgEditConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnTable.setDescription('Edits current DS0 assignment. This table is also updated by the mfrapCfgDteTable. After making any adjustments to the connections, the mfrapCfgConnUpdateCmd must be sent.')
mfrapCfgEditConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapCfgEditConnDestPort"), (0, "MFRAP-MIB", "mfrapCfgEditConnDestDs0"))
if mibBuilder.loadTexts: mfrapCfgEditConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnEntry.setDescription('An entry in the Edit Connections table.')
mfrapCfgEditConnDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("port1-t1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgEditConnDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnDestPort.setDescription('Index to destination port of interest. M-FRAP currently only supports the Network port (1) as the destination. ')
mfrapCfgEditConnDestDs0 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgEditConnDestDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnDestDs0.setDescription('DS0 number 1 through 24 corresponding to the Destination port index')
mfrapCfgEditConnSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 33))).clone(namedValues=NamedValues(("port2-dandi", 2), ("port3-dte", 3), ("not-connected", 33)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgEditConnSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnSrcPort.setDescription('DS0 assignment for indexed destination port. The value not-connected may not be written; to clear a connection, use the mfrapCfgEditDisconnect table element. Setting mfrapCfgEditDisconnect to disconnect will cause this element to return not-connected for a get. Currently, M-FRAP will not allow setting this value to 3. Connections defined by the mfrapCfgDteTable will be reflected in reads of this object. After making any adjustments to the connections, the mfrapCfgConnUpdateCmd must be sent. Node software does not permit connections between a port and itself.')
mfrapCfgEditConnSrcDs0 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 40))).clone(namedValues=NamedValues(("ds0-01", 1), ("ds0-02", 2), ("ds0-03", 3), ("ds0-04", 4), ("ds0-05", 5), ("ds0-06", 6), ("ds0-07", 7), ("ds0-08", 8), ("ds0-09", 9), ("ds0-10", 10), ("ds0-11", 11), ("ds0-12", 12), ("ds0-13", 13), ("ds0-14", 14), ("ds0-15", 15), ("ds0-16", 16), ("ds0-17", 17), ("ds0-18", 18), ("ds0-19", 19), ("ds0-20", 20), ("ds0-21", 21), ("ds0-22", 22), ("ds0-23", 23), ("ds0-24", 24), ("no-connection", 40)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgEditConnSrcDs0.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnSrcDs0.setDescription('DS0 number 1 through 24 corresponding to the sourced port index. The value no-connection may not be written. To clear a connection use the mfrapCfgEditDisconnect table element. Setting mfrapCfgEditDisconnect to disconnect will cause this element to return no-connection for a get.')
mfrapCfgEditConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 33))).clone(namedValues=NamedValues(("voice", 1), ("transparent", 2), ("frame-relay", 3), ("not-connected", 33)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgEditConnType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnType.setDescription('Defines the type of traffic being transported. The value not-connected may not be written. To clear a connection use the mfrapCfgEditDisconnect table element. Setting mfrapCfgEditDisconnect to disconnect will cause this element to return not-connected for a get. ')
mfrapCfgEditDisconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("disconnect", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgEditDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditDisconnect.setDescription('Setting this object to disconnect will cause the state of the Src and Type objects for this destination port and ds0 to be set to not-connected. When connections are updated, the connection between the source and destination will be terminated. ')
mfrapCfgEditLastSetStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8))).clone(namedValues=NamedValues(("set-valid", 1), ("invalid-dte-bandwidth", 2), ("bandwidth-conflict", 3), ("ds0s-not-ascending", 4), ("illegal-value", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgEditLastSetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditLastSetStatus.setDescription("The status of the last set of an mfrapCfgEditConnTable object. Invalid-dte-bandwidth is returned if the set reduces the number of ds0's assigned to a DTE port to less than the number required for the port's bandwidth and density. Bandwidth-conflict is returned if an attempt is made to change the source port without first disconnecting the existing connection. Ds0s-not-ascending is returned if the source ds0 being set is not in ascending order with the other ds0's for that source port. ")
mfrapCfgEditConnStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("connections-valid", 1), ("invalid-dte-bandwidth", 2), ("ds0s-not-ascending", 4), ("incomplete-entry", 5), ("inconsistent-edit-buff", 6), ("bad-connection-type", 7), ("no-current-connections", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgEditConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgEditConnStatus.setDescription("Displays the status of the connections in the edit buffer. This object should be read before setting the mfrapCfgConnUpdateCmd. Incorrect-dte-bandwidth is returned if there are not enough DS0's starting with the mfrapCfgDteConnStartDs0 to accommodate the mfrapCfgDteConnDs0Required. Incomplete-entry is returned if the source port, source ds0 and/or connection type has not been set for a connection (and at least one of them has been set for that connection). Inconsistent-edit-buffer is returned if there is an internal inconsistency in the edit buffer; in this case, an mfrapCfgEditConnCopyCurrtoEdit or mfrapCfgEditClearEdit set should be performed before proceeding. Bad-connection-type is returned if the connection type is not consistent with the source and destination ports. ")
mfrapCfgConnUpdateCmd = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 10, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("config-and-connect", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgConnUpdateCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgConnUpdateCmd.setDescription('Updates the connections with the edit buffer if the connections are all valid. The edit buffer is comprised of any changes sent (set) from the mfrapCfgEditConnTable or the mfrapCfgDteTable. Note that if changes are made to the mfrapCfgDteTable, the mfrapCfgConnAutoUpdate object must be set before the mfrapCfgConnUpdateCmd in order for the changes to take effect.')
mfrapCfgDandiTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 2, 11))
mfrapCfgDandiFraming = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("d4", 1), ("esf", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDandiFraming.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDandiFraming.setDescription("Type of Framing on this D&I Line. Check with your service provider to determine value. D4 is also known as 'SuperFrame', ESF is 'Extended SuperFrame'. ESF provides enhanced performance monitoring capabilities. ")
mfrapCfgDandiLineEncoding = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ami", 1), ("b8zs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgDandiLineEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgDandiLineEncoding.setDescription("D&I interface bipolar encoding scheme. Check with your service provider to determine value. B8ZS, which inherently provides ample 'ones-density', is recommended. AMI users must pay special attention to the 'ones-density' requirements of the service provider.")
mfrapCfgLock = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgLock.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLock.setDescription(' Request to start configuration download and lock out any other means of configuring the unit. The integer passed in represents the time out period in seconds between sets. A set to this object will fail if the unit is already in a configuration locked state.')
mfrapCfgLockID = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgLockID.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLockID.setDescription(' Returns the IP Address of the management station currently in control of configuration. A unit that is not in a configuration locked state will return 0.0.0.0')
mfrapCfgID = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapCfgID.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgID.setDescription(' A read of this object returns the Current Configuration ID string. A write sets the Configuration ID string. The string contains a starting character to indicate the last configuration source C = Envisage N = CLI/TELNET L = LCD S= other SNMP management station and a unique 7 integer value to differentiate configurations between common sources. A value of *STARTUP indicates the configuration has been defaulted. A write will only be accepted from the management station that has successfully obtained the configuration lock')
mfrapCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("in-progress", 1), ("success", 2), ("datarate-density-conflict", 3), ("bandwidth-allocation-error", 4), ("general-error", 5), ("timeout", 6), ("aborted-by-user", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgStatus.setDescription(' The status of a configuration install is reported here. On startup, a status of success will be reported. (1) The configuration has been locked and an update or unlock command has not been received. (2) An update command has been received and the configuration has been validated as consistent; . (3) An update command has been received but the DTE port datarate is not compatible with the density. (4) An update command has been received but the number of channels to be allocated will not fit in the available channels. (5) An update command has been received but there is an error in the configuration that is not a datarate-density-conflict or bandwidth-allocation-error. (6) The time between consecutive set requests exceeded the timeout sent with the tfrapCfgLock command. (7) The user sent a tfrapCfgUnlock command before a tfrapCfgUpdate command. This usually means that one of the sets in the configuration failed. ')
mfrapCfgUnlock = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("un-lock", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgUnlock.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgUnlock.setDescription(' The management station sets this variable to complete the configuration install process. Un-lock (1) notifies the agent to remove the lock on configuring the unit without updating the configuration.')
mfrapCfgUpdate = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("update", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapCfgUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgUpdate.setDescription(' The management station sets this variable to complete the configuration install process. Update (1) notifies the agent to start the update process within the unit.')
mfrapDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3))
mfrapDiagUnitTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3, 1))
mfrapDiagUnitLocLoop = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-loopback-mode", 1), ("disable-loopback-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagUnitLocLoop.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagUnitLocLoop.setDescription('Controls a bi-directional unit loopback. Data is received from either the DTE or Network interface, processed, and transmitted back towards the same interface. When configured for Frame Relay operation the unit will preserve the LMI path and maintain managed access during this loopback. In Frame Relay mode, only valid HDLC frames are looped back (pseudorandom test patterns will be dropped). Data received on the Drop & Insert is not affected by this loopback mode. (1) enable unit loopback (2) disable unit loopback')
mfrapDiagUnitReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset-unit", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagUnitReset.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagUnitReset.setDescription('Enables the operator to remotely cause a software reset on the unit. Using this command will cause the unit to terminate all its connections and drop data. (1) Reset Unit.')
mfrapDiagUnitTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagUnitTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagUnitTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out and disables itself. The time is in hundredths of seconds (TimeTicks).')
mfrapDiagT1Table = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3, 2))
mfrapDiagT1LocLineLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("line-lpbk-disable", 1), ("line-lpbk-enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagT1LocLineLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1LocLineLpbk.setDescription('Controls local network loopback. All data (including framing and line errors) received from the WAN, regardless of format or content, is transmitted back out to the WAN (line interface loopback) while still being passed through to the DTE. In Frame Relay applications the unit will not preserve the LMI path during this diagnostic and in-band management may not operate. (1) disable line loopback (2) enable line loopback ')
mfrapDiagT1LocPylLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pyl-lpbk-disable", 1), ("pyl-lpbk-enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagT1LocPylLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1LocPylLpbk.setDescription('Controls network payload loopback. All data received from the WAN is terminated, reframed and sent back towards the WAN. Framing errors and Line Code Violations are corrected. Network contact via ESF Facility Data Link is preserved during this loopback state. All user data regardless of format or content, is transmitted back out while all Ones are sent to the DTE. In Frame Relay applications the unit will not preserve the LMI path during this diagnostic and in-band management may not operate. (1) disable payload loopback (2) enable payload loopback ')
mfrapDiagT1LocAggrLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aggr-lpbk-disable", 1), ("aggr-lpbk-enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagT1LocAggrLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1LocAggrLpbk.setDescription('Controls Local Aggregate Loopback. All data received from the DTE and Drop & Insert ports is framed, formatted and transmitted towards the WAN while being looped back towards the respective port (DTE or Drop & Insert). The loopback path covers the entire digital data path within the device. In Frame Relay mode, only error-free HDLC frames will pass through the loopback path. Additionally, in Frame Relay applications the unit will not preserve the LMI path during this loopback and in-band management may not operate. (1) disable local aggregate (digital) loopback (2) enable local aggregate (digital) loopback ')
mfrapDiagT1RmtLpbkStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("no-remote-lpbks", 1), ("csu-lpbk-from-remote", 2), ("dsu-lpbk-from-remote", 3), ("pyl-lpbk-from-remote", 4), ("csu-lpbk-sent-to-remote", 5), ("dsu-lpbk-sent-to-remote", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagT1RmtLpbkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1RmtLpbkStatus.setDescription("Status of Remote Loopback commands sent or received on the WAN. (1) no remote loopbacks are active. (2) csu loopback from remote - indicates the node is in a Network Line Loopback state due to the reception of the standard CSU Loop-up pattern from the WAN. (3) dsu loopback from remote - indicates the node is in a Network Line Loopback state due to the reception of the Sync Research proprietary Loop-up pattern from a remote node. (4) payload loopback from remote - indicates the node is in a Payload Loopback state due to the reception of the ESF Facility Data Link's Loop-up pattern from the network. (5) csu loopback sent to remote - indicates the node has sent a csu loop up pattern towards the WAN. A device terminating the WAN's physical link is expected to enter a Line Loopback. The initating unit doesn't know if the loopback was accepted by the remote unit. (6) dsu loopback sent to remote - indicates the node has sent a dsu loop up pattern to a remote Sync unit out the WAN. A compatible device detecting this pattern is expected to enter a Line Loopback. The initating unit doesn't know if the loopback was accepted by the remote unit.")
mfrapDiagT1RmtLpbkCmd = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rmt-csu-lpbk-loopup", 1), ("rmt-csu-lpbk-loopdown", 2), ("rmt-dsu-lpbk-loopup", 3), ("rmt-dsu-lpbk-loopdown", 4)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagT1RmtLpbkCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1RmtLpbkCmd.setDescription("Remote loopback commands are intended to place compatible external equipment into a loopback state. The initiating unit will maintain normal data flows during these tests. (1) csu loop up - commands the node to send a standard in-band csu loop up pattern towards the WAN. This is a repetetive framed T1 signal consisting of four 'zeros' followed by one 'one' persisting for a few seconds in place of all T1 data. A device terminating the WAN's physical link is expected to enter a Line Loopback condition upon recognition of this pattern. The initating unit doesn't know if the command was accepted by the remote unit. (2) csu loop down - commands the node to send a standard in-band csu loop down pattern towards the WAN. This is a repetetive framed T1 signal consisting of two 'zeros' followed by one 'one' persisting for a few seconds in place of all T1 data. A device terminating the WAN's physical link is expected to clear any Line Loopback condition upon recognition of this pattern. The initating unit doesn't know if the commad was accepted by the remote unit. (3) dsu loop up - commands the node to send a proprietary in-band dsu loop up pattern towards the WAN. This is a repetetive framed T1 signal consisting of a pseudorandom pattern persisting for a few seconds in place of all T1 data. A compatible device terminating the WAN's physical link is expected to enter a Line Loopback condition upon recognition of this pattern. The initating unit doesn't know if the command was accepted by the remote unit. (4) dsu loop down - commands the node to send a proprietary in-band dsu loop down pattern towards the WAN. This is a repetetive framed T1 signal consisting of a pseudorandom pattern persisting for a few seconds in place of all T1 data. A compatible device terminating the WAN's physical link is expected to clear any Line Loopback condition upon recognition of this pattern. The initating unit doesn't know if the command was accepted by the remote unit.")
mfrapDiagT1TimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 2, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagT1TimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagT1TimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out and automatically clears itself to restore the unit to normal operation. The time is in hundredths of seconds (TimeTicks).')
mfrapDiagDteTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3, 3))
mfrapDiagDteSigRTS = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rts-signal-on", 1), ("rts-signal-off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagDteSigRTS.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteSigRTS.setDescription('Status of the Request to Send (RTS) signal from the DTE port. (1) RTS Active (2) RTS Inactive')
mfrapDiagDteSigDTR = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtr-signal-on", 1), ("dtr-signal-off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagDteSigDTR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteSigDTR.setDescription('Status of the Data Terminal Ready (DTR) signal from the DTE port. (1) DTR Active (2) DTR Inactive')
mfrapDiagDteLclLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-loopback-mode", 1), ("disable-loopback-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagDteLclLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteLclLpbk.setDescription('Controls the DTE loopback state. This is a bi-directional loopback state where both the DTE and WAN ports are placed in line loopback. All data received on each interface is sent back out the respective interface regardless of format or content. In Frame Relay applications the unit will not preserve the LMI path during this diagnostic and in-band management will not operate. (1) enable payload loopback (2) disable payload loopback')
mfrapDiagDteV54Lpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopback-enable", 1), ("loopback-disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagDteV54Lpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteV54Lpbk.setDescription('This reports the status of any local V54 testing initiated by a remote unit. Remote V54 loopback commands are intended to place this unit into a loopback state. The initiating unit will maintain normal data flows during these tests. (1) V54 loop up received - indicates the node has received a standard in-band loop up pattern from the WAN per ITU V.54. This is a framed T1 signal consisting of a pseudorandom signal in place of all user data (that is only in the DS0s assigned to the DTE). This unit has entered a bi-directional DTE Loopback condition. (2) V54 loop down received - indicates the node has received a standard in-band loop down pattern from the WAN per ITU V.54. This is a framed T1 signal consisting of a pseudorandom signal in place of all user data (that is only in the DS0s assigned to the DTE). This unit has cleared the bi-directional DTE Loopback condition.')
mfrapDiagDteRmtV54Lpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("transmit-code-enable", 3), ("transmit-code-disable", 4)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagDteRmtV54Lpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteRmtV54Lpbk.setDescription("Remote V54 loopback commands are intended to place compatible external equipment into a loopback state. The initiating unit will maintain normal data flows during these tests. (3) Transmit V54 loop up - commands the node to send a standard in-band loop up pattern towards the WAN per ITU V.54. This is a framed T1 signal consisting of a pseudorandom signal in place of all user data (that is only in the DS0s assigned to the DTE). A device terminating the fractional T1 data is expected to enter a bi-directional DTE Loopback condition upon recognition of this pattern. The initating unit doesn't know if the command was accepted by the remote unit. This pattern will not traverse a typical frame relay network and is designed for circuit-switched diagnostics. (4) Transmit V54 loop down - commands the node to send a standard in-band loop down pattern towards the WAN per ITU V.54. This is a framed T1 signal consisting of a pseudorandom signal in place of all user data (that is only in the DS0s assigned to the DTE). A device terminating the fractional T1 data is expected to clear a bi-directional DTE Loopback condition upon recognition of this pattern. The initating unit doesn't know if the command was accepted by the remote unit.")
mfrapDiagDteTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 3, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagDteTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDteTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out. The time is in hundredths of seconds (TimeTicks).')
mfrapDiagBertTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3, 5))
mfrapDiagBertState = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("start-bert-test-t1", 1), ("start-bert-test-dte", 2), ("stop-bert-test", 3), ("inject-error-bert-test", 4), ("clear-error-bert-test", 5), ("start-bert-test-dandi", 6), ("start-bert-test-fractional-t1", 7)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagBertState.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertState.setDescription("The unit is capable of sending a pseudorandom test pattern (511 or QRSS) out the WAN and monitoring the WAN received data for the same pattern. The BERT pattern may be selected to occupy the full T1 payload, only the bandwidth allocated to the DTE, only the bandwidth allocated to the Drop & Insert or only the bandwidth allocated to the DTE and the Drop & Insert (fractional T1). When a unit is sending this BERT, the receiver will monitor and characterize the incoming signal for the same BERT pattern. In Frame Relay applications the unit will not preserve the LMI path during this diagnostic and in-band management may not operate. This test may be ineffective in certain frame relay environments as pseudorandom data lacks appropriate framing. Refer to VLOOP and VBERT for PVC-based error-rate testing in a live frame relay network. (1) Start a BERT test on full T1 - replaces entire T1 payload with the configured BERT pattern while monitoring the full T1 bandwidth (1.536M) for the presence of the BERT pattern. (2) Start a BERT test on the DTE bandwidth - replaces only the portion of the T1 payload that has been allocated to the DTE with the configured BERT pattern while monitoring the same T1 bandwidth (DTE Data Rate) for the presence of the BERT pattern. (3) Stop a BERT test. (4) Inject a single bit error into the outgoing pattern. (5) Clear current BERT results. (6) Starts a BERT test on the Drop & Insert bandwidth - replaces only the portion of the T1 payload that has been allocated to the Drop & Insert with the configured BERT pattern while monitoring the same T1 bandwidth (D&I DS0's) for the presence of the BERT pattern. (7) Starts a BERT test on the DTE & D&I bandwidth (fractional T1) - replaces only the portion of the T1 payload that has been allocated to the DTE or the Drop & Insert with the configured BERT pattern while monitoring the same T1 bandwidth for the presence of the BERT pattern.")
mfrapDiagBertStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bert-off", 1), ("bert-out-of-sync", 2), ("bert-in-sync", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagBertStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertStatus.setDescription('Displays the current BERT test sync status. (1) BERT is not running (2) BERT is running but is not in sync (3) BERT is running and has detected a received BERT')
mfrapDiagBertErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagBertErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertErrors.setDescription('Displays the number of errors detected in Bert Test.')
mfrapDiagBertErrSec = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagBertErrSec.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertErrSec.setDescription('Displays the number of seconds containing 1 or more errors in BERT Test.')
mfrapDiagBertTimeElaps = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagBertTimeElaps.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertTimeElaps.setDescription('Elapsed time since BERT test was started or cleared.')
mfrapDiagBertResyncs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagBertResyncs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertResyncs.setDescription('Displays the number of times BERT test has synched up on the pattern. The BERT will attempt to resynchronize in response to excessive errors. A running count here indicates that a clean BERT is not being received.')
mfrapDiagBertPattern = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("five11-pattern", 1), ("qrss", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagBertPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagBertPattern.setDescription('The type of pseudorandom BERT pattern used. (1) 511: 9-bit pseudorandom pattern (2) QRSS: 20-bit pseudorandom pattern with no more than 14 consecutive zeros')
mfrapDiagVnipTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 3, 6), )
if mibBuilder.loadTexts: mfrapDiagVnipTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipTable.setDescription(' Table of Diagnostics performed with the VNIP protocol')
mfrapDiagVnipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapDiagVnipInterface"), (0, "MFRAP-MIB", "mfrapDiagVnipIndex"))
if mibBuilder.loadTexts: mfrapDiagVnipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipEntry.setDescription('VNIP VLOOP and VBERT diagnostic profile. Initiating these tests require an established and stable VNIP topology on an interface. Once the topology is in place, the user can execute a PVC-based diagnostic between this unit and any indexed entry in the topology table. The index into the topology table for a particular interface is required.')
mfrapDiagVnipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVnipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipInterface.setDescription('The interface out which a PVC-based VNIP diagnostic will be run. This must be an interface with a valid and stable VNIP topology for a VNIP Diagnostic.')
mfrapDiagVnipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVnipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipIndex.setDescription('The index to the external VNIP peer as presented by the VNIP topology database for the given interface. Refer to VnipTopologyTable to determine the index of the remote peer.')
mfrapDiagVnipDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagVnipDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipDlci.setDescription('This is the DLCI value for the given interface/index combination. This comes from the VniptTopologyTable.')
mfrapDiagVnipIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagVnipIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVnipIpAddr.setDescription('This is the ip address for the given interface/index combination. This comes from the VniptTopologyTable.')
mfrapDiagVLOOP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start-test", 1), ("stop-test", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagVLOOP.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVLOOP.setDescription('Controls execution of the Vnip Logical Loopback (VLOOP) test. VLOOP is designed as an intrusive test and customer data on the DLCI-under-test will be discarded. The VLOOP test includes a timed VBERT test and is run using the profile configured within this table. (1) start VLOOP test (2) stop VLOOP test (override VBERT test duration)')
mfrapDiagVBERT = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDiagVBERT.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVBERT.setDescription('Controls execution of the Vnip Virtual Bit Eror Rate (VBERT) test. VBERT is designed to be a non-intrusive test and will attempt to statistically multiplex VBERT test data and customer data on the DLCI-under-test. However, VBERT data is given priority over customer data when the selected VBERT volume causes internal congestion. The test is run using the profile configured within this table. (1) start test (2) stop test (override VBERT test duration)')
mfrapDiagVBERTRate = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8000, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVBERTRate.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVBERTRate.setDescription('Specifies the throughput bit rate applied by VBERT or VLOOP to the DLCI-under-test. For DTE Rates or configured CIR up to 64K the maximum VBERT rate is either the DTE data rate or 110% of CIR (which ever is less). For DTE Rates or configured CIR greater than 64K, the maximum VBERT rate is 75% of the DTE data rate or 110% of CIR (which ever is less). Note that selecting rates that approach line rate will impact neighboring PVCs. (8000-1152000): VBERT/VLOOP data rate (in bits per second).')
mfrapDiagVBERTSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVBERTSize.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVBERTSize.setDescription('Specifies the size of framed data that will be used during the VBERT test, measured in Bytes. (64) 64-byte frames (128) 128-byte frames (256) 256-byte frames (512) 512-byte frames (1024) 1024-byte frames (2048) 2048-byte frames')
mfrapDiagVBERTPktPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("zero-percent", 0), ("twentyFive-percent", 1), ("fifty-percent", 2), ("seventyFive-percent", 3), ("oneHundred-percent", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVBERTPktPercent.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVBERTPktPercent.setDescription('Specifies percentage of VBERT packets that will have the Frame Relay Discard Eligibility bit set. Frames with this bit set may be more likley to get dropped in a congested network. (0) 0% of the test frames are marked discard eligible (25) 25% of the test frames are marked discard eligible (50) 50% of the test frames are marked discard eligible (75) 75% of the test frames are marked discard eligible (100) 100% of the test frames are marked discard eligible')
mfrapDiagVBERTTestPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 3, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagVBERTTestPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagVBERTTestPeriod.setDescription("Specifies the duration of a VBERT test. Note that VBERT is subjected to the unit's Loopback Timer and will be terminated by whichever timer expires first. (10-1440): VBERT time duration in seconds")
mfrapDiagDandiTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 3, 8))
mfrapDiagDandiLocLineLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("line-lpbk-disable", 1), ("line-lpbk-enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagDandiLocLineLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDandiLocLineLpbk.setDescription('Local Line Loopback on the Drop & Insert port. Data and framing received at the D & I port is transmitted back out the D & I port (1) disable line loopback (2) enable line loopback')
mfrapDiagDandiLocPylLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pyl-lpbk-disable", 1), ("pyl-lpbk-enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDiagDandiLocPylLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDandiLocPylLpbk.setDescription('Local Payload Loopback on the Drop & Insert port. Data (NOT framing) received at the T1 port is looped back at the D&I port and reframed and transmitted back out the T1 port. (1) disable line loopback (2) enable line loopback')
mfrapDiagDandiTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 3, 8, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDiagDandiTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDiagDandiTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out. The time is in hundredths of seconds (TimeTicks).')
mfrapStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4))
mfrapStatusT1Table = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 1))
mfrapStatusT1Mode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-connections", 1), ("active", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusT1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusT1Mode.setDescription('Status of allocation of T1 bandwidth to the DTE port data. (1) no connections - indicates the DTE port has no connections to the WAN. (2) Active - indicates DTE data rate has been assigned T1 DS0s and is in a normal data mode. (3) Test - indicates DTE data rate has been assigned T1 DS0s but is in a diagnostic condition.')
mfrapStatusT1Status = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("t1-frame-sync-okay", 1), ("t1-frame-sync-with-errors", 2), ("signal-present-without-frame-sync", 3), ("signal-not-present", 4), ("not-applicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusT1Status.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusT1Status.setDescription('Status of the signal received from the WAN (1) In Sync - unit has detected a properly framed T1 signal and is not experiencing any error conditions. (2) In Sync with Errors - unit has detected a properly framed T1 signal but is experiencing some error conditions. Refer to T1 current performance results for details. (3) Signal Detected without Frame Sync - while a signal is present from the WAN it does not contain the framing pattern defined for this unit. This could be either incorrectly configured T1 Frame type or the presence of an alarm condition on the WAN. (4) No Carrier - there is no signal detected from the WAN. (5) Not Applicable.')
mfrapStatusT1Alarms = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-alarms", 1), ("red-alarm-declared", 2), ("yellow-alarm-detected", 3), ("unframed-all-ones-detected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusT1Alarms.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusT1Alarms.setDescription('Alarms present at the T1 port. (1) No alarm conditions present. (2) Red Alarm Declared - Unit has experienced loss of frame synchronization with the signal received from the WAN for an extended time and is reporting an alarm condition that severely impairs normal operation. During this Red Alarm condition the unit will transmit Yellow alarm back to the WAN. If this condition persists consult your service provider. (3) Yellow ALarm Detected - Unit is receiving a yellow alarm indication from the wide area network. Detection of yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal. If this condition persists consult your service provider. (4) Unframe All Ones Detected - Unit is receiving unframed all ones from the wide area network (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device. If this condition persists consult your service provider.')
mfrapStatusDteTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 7))
mfrapStatusDteMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-connections", 1), ("active", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteMode.setDescription('Status of allocation of T1 bandwidth to the DTE port data. (1) no connections - indicates the DTE port has no connections to the WAN. (2) Active - indicates DTE data rate has been assigned T1 DS0s and is in a normal data mode. (3) Test - indicates DTE data rate has been assigned T1 DS0s but is in a diagnostic condition.')
mfrapStatusDteRts = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteRts.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteRts.setDescription('Status of the Request to Send (RTS) signal from the DTE port. (1) RTS Active (2) RTS Inactive')
mfrapStatusDteDtr = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteDtr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteDtr.setDescription('Status of the Data Terminal Ready (DTR) signal from the DTE port. (1) DTR Active (2) DTR Inactive')
mfrapStatusDteDcd = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteDcd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteDcd.setDescription('Status of the Data Carrier Detect (DCD) signal driven by this unit towards the DTE port (1) DCD Active (2) DCD Inactive')
mfrapStatusDteDsr = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteDsr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteDsr.setDescription('Status of the Data Set Ready (DSR) signal driven by this unit towards the DTE port. (1) DSR Active (2) DSR Inactive')
mfrapStatusDteCts = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteCts.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteCts.setDescription('Status of the Clear to Send (CTS) signal driven by this unit towards the DTE port (1) CTS Active (2) CTS Inactive')
mfrapStatusDandiTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 15))
mfrapStatusDandiMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 15, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-connections", 1), ("active", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDandiMode.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDandiMode.setDescription('Status of allocation of T1 DS0s to the Drop & Insert port DS0s. (1) no connections - indicates the Drop & Insert port has no connections to the WAN. (2) Active - indicates that at least one Drop & Insert DS0 has been assigned to a T1 DS0. (3) Test - indicates that at least one Drop & Insert DS0 has been assigned to a T1 DS0 but is in a diagnostic condition.')
mfrapStatusDandiStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("t1-frame-sync-okay", 1), ("t1-frame-sync-with-errors", 2), ("signal-present-without-frame-sync", 3), ("signal-not-present", 4), ("not-applicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDandiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDandiStatus.setDescription('Status of the signal received from the Drop & Insert port. (1) In Sync - unit has detected a properly framed T1 signal and is not experiencing any error conditions. (2) In Sync with Errors - unit has detected a properly framed T1 signal but is experiencing some error conditions. Refer to T1 current performance results for details. (3) Signal Detected without Frame Sync - while a signal is present from the Drop & Insert port, it does not contain the framing pattern defined for this unit. This could be either incorrectly configured T1 Frame type or the presence of an alarm condition on the network. (4) No Carrier - there is no signal detected from the WAN. (5) Not Applicable.')
mfrapStatusDandiAlarms = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 15, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-alarms", 1), ("red-alarm-declared", 2), ("yellow-alarm-detected", 3), ("unframed-all-ones-detected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDandiAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDandiAlarms.setDescription('Alarms present at the T1 port. (1) No alarm conditions present. (2) Red Alarm Declared - Unit has experienced loss of frame synchronization with the signal received from the Drop & Insert port for an extended time and is reporting an alarm condition that severely impairs normal operation. During this Red Alarm condition the unit will transmit Yellow alarm back to the Drop & Insert port. If this condition persists consult your service provider. (3) Yellow ALarm Detected - Unit is receiving a yellow alarm indication from the Drop & Insert port. Detection of yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal. If this condition persists consult your service provider. (4) Unframe All Ones Detected - Unit is receiving unframed all ones from the Drop & Insert port (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device. If this condition persists consult your service provider.')
mfrapStatusLedTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 4))
mfrapStatusDteModeLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("offLED-DTE-inactive", 1), ("greenLED-normal", 2), ("yellowLED-test-mode", 3), ("redLED-no-active-WAN-connection", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteModeLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteModeLED.setDescription('Status of the DTE Mode LED. (1) DTE Mode LED off: Missing control signals (2) DTE Mode LED green: Normal (3) DTE Mode LED yellow: Test Mode')
mfrapStatusDteStatusLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteStatusLED.setDescription('Status of the DTE Status LED. (1) DTE Status LED off: no connections to WAN (2) DTE Status LED green: normal')
mfrapStatusDteTxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-tx-data-transmitting", 2), ("yellowLED-disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteTxLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteTxLED.setDescription('Status of the DTE Tx Data LED. In Frame Relay mode, this LED is ON (green) when the DTE is not sending HDLC Flags and is OFF when HDLC flags are being transmit. In CBO mode, the LED is ON (green) for a SPACE and OFF for a MARK. (1) DTE Transmit LED OFF: inactive (HDLC flags or CBO marks) (2) DTE Transmit LED ON: active (HDLC frames or CBO spaces)')
mfrapStatusDteRxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-rx-data-receiving", 2), ("yellowLED-disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDteRxLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDteRxLED.setDescription('Status of the DTE Rx Data LED. In Frame Relay mode, this LED is ON (green) when the WAN is receiving HDLC Flags and is OFF when HDLC flags are being received. In CBO mode, the LED is ON (green) for a SPACE and OFF for a MARK. (1) DTE Receive LED OFF: inactive (HDLC flags or CBO marks) (2) DTE Receive LED ON: active (HDLC frames or CBO spaces)')
mfrapStatusT1ModeLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("greenLED-normal", 2), ("yellowLED-test-mode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusT1ModeLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusT1ModeLED.setDescription('Status of the WAN Mode LED. (1) WAN Mode LED is green: normal data mode (2) WAN Mode LED is yellow: test mode')
mfrapStatusT1StatusLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("offLED-T1-no-signal", 1), ("greenLED-normal", 2), ("yellowLED-remote-alarm", 3), ("redLED-red-alarm", 4), ("blinking-redLED-no-carrier-red-alarm", 5), ("blinking-red-greenLED-transient-error", 6), ("blinking-red-yellowLED-AIS", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusT1StatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusT1StatusLED.setDescription('Status of the WAN Status LED. (1) Off - no signal detected from WAN. (2) Green - framed signal detected with no errors (normal operation) (3) Yellow - remote alarm condition detected (yellow or AIS alarms) (4) Red - unit has declared Red Alarm due to the presence of an improperly framed signal from the WAN. (5) Blinking Red and Off - unit has declared Red Alarm due to the absence of a signal from the WAN. (6) Blinking Green and Red - unit is receiving a properly framed signal from the WAN but has detected a transient error condition. Possible Line Code Violations or ESF CRC errors indicating errored data bits. (7) Blinking Red and Yellow - unit is receiving an unframed all ones (AIS) from the WAN. This is indicative of an upstream alarm condition on the WAN.')
mfrapStatusAllLEDs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusAllLEDs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusAllLEDs.setDescription("Status of all six MFRAP LEDs, encoded in a string. 'F' off '5' green '0' yellow 'A' red '7' blinking green and off '3' blinking yellow and off 'B' blinking red and off '4' blinking green and yellow '6' blinking green and red '8' blinking yellow and red Positionally, the 8 letters are DTE Mode, DTE status, Dte Tx, Dte Rx, PBX Mode, PBX Status, T1 Mode, and T1 Status. For example, '55555556' would mean: DTE in normal mode, active status, transmitting and receiving PBX in normal mode with normal status and T1 normal with transient errors.")
mfrapStatusDandiModeLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("greenLED-normal", 2), ("yellowLED-test-mode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDandiModeLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDandiModeLED.setDescription('Status of the Drop & Insert Mode LED. (1) Drop & Insert Mode LED is green: normal data mode (2) Drop & Insert Mode LED is yellow: test mode')
mfrapStatusDandiStatusLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("offLED-Dandi-no-signal", 1), ("greenLED-normal", 2), ("yellowLED-remote-alarm", 3), ("redLED-red-alarm", 4), ("blinking-redLED-no-carrier-red-alarm", 5), ("blinking-red-greenLED-transient-error", 6), ("blinking-red-yellowLED-AIS", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusDandiStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusDandiStatusLED.setDescription('Status of the Drop & Insert Status LED. (1) Off - no signal detected from Drop & Insert port. (2) Green - framed signal detected with no errors (normal operation) (3) Yellow - remote alarm condition detected (yellow or AIS alarms) (4) Red - unit has declared Red Alarm due to the presence of an improperly framed signal from the Drop & Insert port. (5) Blinking Red and Off - unit has declared Red Alarm due to the absence of a signal from the Drop & Insert port. (6) Blinking Green and Red - unit is receiving a properly framed signal from the Drop & Insert port but has detected a transient error condition. Possible Line Code Violations or ESF CRC errors indicating errored data bits. (7) Blinking Red and Yellow - unit is receiving an unframed all ones (AIS) from the Drop & Insert port. This is indicative of an upstream alarm condition on the Drop & Insert port.')
mfrapVnipTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 4, 2), )
if mibBuilder.loadTexts: mfrapVnipTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyTable.setDescription('VNIP topology is a feature that, for each interface, maps all compatible VNIP peers, their DLCI value, ip address and relative location. The topology is a fundamental prerequisite to applying the VNIP feature set which includes PVC-based delay measurement, diagnostics, and congestion monitoring. With VNIP enabled on an interface the unit will attempt to locate VNIP peers out that port. As peers are discovered and logged the unit will report the topology it has learned on its opposite interface. If VNIP is inactive on one interface it will not engage in any VNIP dialog; however it will continue to listen for topology messages on the inactive interface and will reflect these messages out the opposite interface if VNIP is enabled. With VNIP inactive on both interfaces the unit will transparently pass all VNIP messages. The topology database includes the interface, local DLCI value, remote peer DLCI value, remote peer ip address, and the number of VNIP hops in between. This table also reports the status of other VNIP features as well.')
mfrapVnipTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapVnipTopologyInterface"), (0, "MFRAP-MIB", "mfrapVnipTopologyIndex"))
if mibBuilder.loadTexts: mfrapVnipTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyEntry.setDescription('The DLCI, IP address, and number of hops for a particular peer, discovered off of an interface (DTE or T1).')
mfrapVnipTopologyInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyInterface.setDescription('The interface off of which the peer was discovered. Topology is discovered by sending VNIP messages out each interface. Units discovered via a particular interface are kept in a list associated with that interface. (1) VNIP peers and status out DTE interface (2) VNIP peers and status out WAN interface')
mfrapVnipTopologyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyIndex.setDescription('The number of this discovered peer in the list of nodes for this interface. For each interface, the nodes are numbered 1 through n. This index is required when disabling or enabling VBERT/VLOOP to a particular peer.')
mfrapVnipTopologyDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyDlci.setDescription('The DLCI of the discovered neighboring peer. This may be different from the local DLCI.')
mfrapVnipTopologyIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyIpAddr.setDescription('The IP address for the discovered peer.')
mfrapVnipTopologyNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyNumHops.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyNumHops.setDescription('The discovered peer is this number of hops away. Each hop is a VNIP peer.')
mfrapVnipTopologyLocalDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopologyLocalDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopologyLocalDlci.setDescription('The DLCI of this node over which the neighboring peer was discovered.')
mfrapVnipTopoTDNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoTDNumSamples.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoTDNumSamples.setDescription('The number of transit delay samples collected.')
mfrapVnipTopoTDAvgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoTDAvgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoTDAvgDelay.setDescription('The average transit delay between this unit and the remote peer (in milliseconds).')
mfrapVnipTopoTDMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoTDMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoTDMaxDelay.setDescription('The maximum transit delay between this node and the remote peer (in milliseconds).')
mfrapVnipTopoTDMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoTDMinDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoTDMinDelay.setDescription('The minimum transit delay between this node and the remote peer (in milliseconds).')
mfrapVnipTopoTDLastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoTDLastDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoTDLastDelay.setDescription('The most recent transit delay measured between this node and the remote peer (in milliseconds).')
mfrapVnipTopoVLOOPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopback-enable", 1), ("loopback-disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVLOOPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVLOOPStatus.setDescription('This selection displays the status of the VNIP PVC Loopback for this entry. This loopback is initiated by the remote node through the VLOOP utility, causing this node to loop data back to the remote node. (1) Virtual Loopback path present on this PVC due to command received from remote unit. All data received on this DLCI will be looped back out the same interface. (2) No active VLOOP test on this')
mfrapVnipTopoVBERTStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("testing", 2), ("test-failed", 3), ("test-completed", 4), ("in-test", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBERTStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBERTStatus.setDescription('Displays the current status of the VBERT/VLOOP test. (1) Off: no test has run or the entry has been cleared (2) Testing: the entry is generating VBERT test frames (3) Test Failed: the request for a test on this entry failed (4) Test Completed: a test has run and is finished results are complete (5) In Test: the entry is on the receiving end of VBERT packets')
mfrapVnipTopoVBertTxDESetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertTxDESetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertTxDESetFrames.setDescription('Displays the number of Frames transmitted during VBERT Test that had the Discard Eligibility indicator bit set.')
mfrapVnipTopoVBertRxDESetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertRxDESetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertRxDESetFrames.setDescription('Displays the number of Frames received during VBERT Test that had the Discard Eligibility indicator bit set.')
mfrapVnipTopoVBertTxDEClrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertTxDEClrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertTxDEClrFrames.setDescription('Displays the number of Frames transmitted during VBERT Test that had the Discard Eligibility indicator bit cleared.')
mfrapVnipTopoVBertRxDEClrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertRxDEClrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertRxDEClrFrames.setDescription('Displays the number of Frames received during VBERT Test that had the Discard Eligibility indicator bit cleared.')
mfrapVnipTopoVBertTransitDelayMax = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertTransitDelayMax.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertTransitDelayMax.setDescription('The maximum transit delay between this node and the remote peer during the VBERT test. This delay measurement will include internal device latencies. This result may differ from the VNIP transit delay measurement which accounts for internal latencies.')
mfrapVnipTopoVBertTransitDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertTransitDelayAvg.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertTransitDelayAvg.setDescription('The average transit delay between this node and the remote peer during the VBERT test. This delay measurement will include internal device latencies. This result may differ from the VNIP transit delay measurement which accounts for internal latencies')
mfrapVnipTopoVBertTimeElapse = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertTimeElapse.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertTimeElapse.setDescription('Elapsed time since VBERT/VLOOP test was started or cleared (in seconds).')
mfrapVnipTopoVBertPerUtilCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertPerUtilCIR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertPerUtilCIR.setDescription(' The calculated percent of CIR utilization during a VBERT test, this value is only valid after a test is complete not during.')
mfrapVnipTopoVBertPerUtilEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 4, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapVnipTopoVBertPerUtilEIR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTopoVBertPerUtilEIR.setDescription(' The calculated percent of EIR utilization during a VBERT test, this value is only valid after a test is complete not during.')
mfrapVnipTransitDelayClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-transit-delay", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapVnipTransitDelayClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapVnipTransitDelayClear.setDescription('Allows the user to clear all the VNIP Transit Delay data collected in the VNIP topology database. (1) Clear entire Transit Delay results database')
mfrapLmiSourcing = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("initializing", 1), ("passthrough", 2), ("user-dte", 3), ("user-t1", 4), ("network-dte", 5), ("network-t1", 6), ("disabled", 7), ("both-ports", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapLmiSourcing.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapLmiSourcing.setDescription('If configured for Frame Relay with a non-zero LMI inactivity timer the unit will monitor the status of LMI and, if proper messaging is not detected, will attempt to emulate either Frame Relay DTE or DCE devices in attempt to restore LMI to any attached equipment and provide managed access for diagnostic purposes. Typically frads/routers are Frame Relay DTE while switches are Frame Relay DCE but this model may vary. In the absence of full-duplex LMI, the unit will cycle through various states in attempt to adapt to an LMI partner. The unit will try each state for the duration of the LMI Inactivity timer and then advance to the next one if satisfactory handshaking is not established. While in any of these states if full-duplex LMI handshaking does appear, the unit will immediately revert to the passthrough state. (1) initializing (2) Passthrough: not sourcing any LMI messages. (3) Status Enquiries out DTE interface: unit is emulating a Frame Relay DTE device out the its (physical) DTE interface. (4) Status Enquiries out WAN interface: unit is emulating a Frame Relay DTE device out the its WAN interface. (5) Status Responses out the DTE interface: unit is emulating a Frame Relay DCE device out the its (physical) DTE interface (provisioning the single default management DLCI). (6) Status Responses out the WAN interface: unit is emulating a Frame Relay DCE device out the its WAN interface (provisioning the single default management DLCI). (7) Disabled - LMI Inactivity timer is zero or unit not configured for a Frame Relay application. (8) Status Responses out both DTE and WAN interfaces: unit is configured for Fixed DCE mode of management and emulates a Frame Relay DCE independently on both ports (provisioning the single default management DLCI).')
mfrapStatusMgmtTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 3))
mfrapStatusMgmtChannel = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("slip", 2), ("private-dlci", 3), ("piggyback-dlci", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusMgmtChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusMgmtChannel.setDescription("This is the method in which the unit is configured for SNMP management access. (1) None: SNMP management disabled (2) SLIP: out-of-band management via asynchronous Serial Line IP (3) Private DLCI: in-band management using a private DLCI that is dedicated solely to this unit's management. (4) Piggyback DLCI: in-band management using any DLCI optionally multiplexing both management and user data.")
mfrapStatusMgmtInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("comm", 1), ("dte", 2), ("t1", 3), ("dte-and-t1", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusMgmtInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusMgmtInterface.setDescription('This is the port(s) on which the management traffic will appear. (1) Async Maintenance(Comm)/Console port - SLIP mode (2) Local DTE interface: unit is configured for Private Local DLCI mode (3) Remote WAN Interface: unit is confiogured for Private Remote DLCI mode (4) DTE and WAN Interfaces: unit is configured for either Piggyback Bidirectional mode.')
mfrapStatusMgmtInterfaceStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusMgmtInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusMgmtInterfaceStatus.setDescription('This is the status of the port(s) on which the management traffic will appear. (1) Active: port or DLCI is configured and status is okay (2) Inactive: port or DLCI is declared out of service (3) Alarm: port or DLCI is experiencing an alarm condition that may interefere with management access ')
mfrapStatusMgmtDefaultDLCINo = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusMgmtDefaultDLCINo.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusMgmtDefaultDLCINo.setDescription('This is the DLCI for the PVC that is defined for the Management port. All traffic using this DLCI in the Frame Replay packet will be destined for the InBand Management task.')
mfrapStatusMgmtDefaultDLCIStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("na", 1), ("dlci-active", 2), ("dlci-inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusMgmtDefaultDLCIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusMgmtDefaultDLCIStatus.setDescription('This is the status of the default management DLCI. (1) not applicable: SLIP mode or management is disabled (2) DLCI Active: default DLCI is active in the LMI full status response. (3) DLCI Inactive: default DLCI is not active in the LMI full status response.')
mfrapStatusLmiAutosense = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("searching", 2), ("learned-annex-d", 3), ("learned-annex-a", 4), ("learned-type1", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusLmiAutosense.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusLmiAutosense.setDescription("This indicates the current status of LMI Auto Sensing if it's enabled. (1) Disabled: LMI is configured as Type 1, Annex-D, or Annex-A (2) Searching: unit is attempting to determine the LMI type of the attached equipment by issuing LMI messages of each LMI type and searching for responses. (3) Learned Annex-D: unit has successfully detected Annex-D LMI (ANSI T1.617 Annex D) (4) Learned Annex-A: unit has successfully detected Annex-A LMI (ITU/CCITT Q.933 Annex A) (5) Learned Type 1: unit has successfully detected Type 1 LMI (Cisco, Group of four, LMI)")
mfrapStatusNestTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 4, 14))
mfrapStatusNestFanOne = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fan-ok", 1), ("fan-alarm", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusNestFanOne.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusNestFanOne.setDescription('The status of the chasis fan 1. (1) Fan is operating normally (2) Fan is in alarm state (3) Fan alarm is not applicable')
mfrapStatusNestFanTwo = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fan-ok", 1), ("fan-alarm", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusNestFanTwo.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusNestFanTwo.setDescription('The status of the chasis fan 2. (1) Fan is operating normally (2) Fan is in alarm state (3) Fan alarm is not applicable')
mfrapStatusNestPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("power-supply-ok", 1), ("power-supply-alarm", 2), ("power-supply-na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusNestPowerSupply.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusNestPowerSupply.setDescription("The status of the chasis power supply. (1) The nest power supply is operating normally (2) The nest power supply is in alarm state (3) A standalone unit will return 'na' ")
mfrapStatusNestSlotId = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 4, 14, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapStatusNestSlotId.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapStatusNestSlotId.setDescription("The chassis slot number (1-16) occupied by the MFRAP nest card. A standalone unit will return a '0'. ")
mfrapPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5))
mfrapPerfPhysicalIntf = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 1))
mfrapPerfT1CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1), )
if mibBuilder.loadTexts: mfrapPerfT1CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfT1CurrentTable.setDescription('The T1 physical layer performance numbers for the current 15 minute interval. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel.')
mfrapT1CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapT1CurrentIndex"))
if mibBuilder.loadTexts: mfrapT1CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentEntry.setDescription('An entry in the T1 Current Perf table.')
mfrapT1CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentIndex.setDescription('The index value which uniquely identifies the T1 interface to which this entry is applicable. The Drop & Index port has its own Current Performance Table, so the index will always be 1.')
mfrapT1CurrentCrc6Events = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentCrc6Events.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentCrc6Events.setDescription('Count of CRC errors detected on an ESF framed circuit. In ESF framing a CRC is generated at the source, based upon the composite data. A CRC error indicates the presence of at least one bit error in an ESF superframe. This field is a free-running accumulation of CRC errors and IS NOT reset when the current 15 minute interval expires. It can be reset with the performance command mfrapT1PerfClearEvents. Not applicable if D4/SF framing is selcted.')
mfrapT1CurrentOofEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentOofEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentOofEvents.setDescription('Count of Out-of-Frame events on a T1 circuit. An out-of- frame event occurs when the frame synchronization criteria is lost and a resynchronization must occur. Data is interrupted during frame resynchronization. This field is a free-running accumulation of OOF transitions and IS NOT reset when the current 15 minute interval expires. It can be reset with the performance command mfrapT1PerfClearEvents.')
mfrapT1CurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentESs.setDescription('The number of Errored Seconds, encountered by a T1 interface in the current 15 minute inter- val. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapT1CurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentSESs.setDescription('The number of Severely Errored Seconds encountered by a t1 interface in the current 15 minute interval. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapT1CurrentSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentSEFSs.setDescription('The number of Severely Errored Framing Seconds encountered by a t1 interface in the current 15 minute interval. A SEFS is a one second interval with one or more frame sync losses.')
mfrapT1CurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentUASs.setDescription("The number of Unavailable Seconds encountered by a t1 interface in the current 15 minute in- terval. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapT1CurrentCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a t1 interface in the current 15 minute interval. A controlled slip is the replication or deletion of a T1 frame at the receiver. These events often indicate a T1 network timing problem.')
mfrapT1CurrentBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the current 15 minute interval. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapT1CurrentLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1CurrentLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1CurrentLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a DS1 interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the T1 network.')
mfrapPerfT1IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2), )
if mibBuilder.loadTexts: mfrapPerfT1IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfT1IntervalTable.setDescription('The DS1 Interval table. A history of physical layer performance results are maintained and represented as 96 15-minute intervals. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel')
mfrapT1IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapT1IntervalIndex"), (0, "MFRAP-MIB", "mfrapT1IntervalNumber"))
if mibBuilder.loadTexts: mfrapT1IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalEntry.setDescription('An entry in the DS1 Interval table.')
mfrapT1IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalIndex.setDescription('The index value which uniquely identifies the t1 interface to which this entry is applicable. Since there is a separate Drop & Insert Performance Intervals Table, the value of this index will always be 1, referring to the WAN port.')
mfrapT1IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalNumber.setDescription('A number between 1 and 96, where 96 is the most recently completed 15 minute interval and 1 is the least recently completed 15 minutes inter- val which occured 24 hours ago (assuming that all 96 intervals are valid).')
mfrapT1IntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalESs.setDescription('The number of Errored Seconds encountered by a t1 interface in one of the previous 96, indi- vidual 15 minute, intervals. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapT1IntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a t1 interface in one of the previous 96, individual 15 minute, intervals. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapT1IntervalSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalSEFSs.setDescription('The number of Severely Errored Framing Seconds encountered by a t1 interface in one of the previous 96, individual 15 minute, intervals. A SEFS is a one second interval with one or more frame sync losses.')
mfrapT1IntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalUASs.setDescription("The number of Unavailable Seconds encountered by a t1 interface in one of the previous 96, individual 15 minute, intervals. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapT1IntervalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a t1 interface in one of the previous 96, individual 15 minute, intervals. A controlled slip is the replication or deletion of a T1 frame at the receiver. These events often indicate a T1 network timing problem.')
mfrapT1IntervalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a t1 interface in one of the previous 96, individual 15 minute, intervals. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapT1IntervalLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1IntervalLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1IntervalLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a DS1 interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the T1 network.')
mfrapPerfT1TotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3), )
if mibBuilder.loadTexts: mfrapPerfT1TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfT1TotalTable.setDescription('The T1 Total table cumulative physical layer performance results from the past 24 hours. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel.')
mfrapT1TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapT1TotalIndex"))
if mibBuilder.loadTexts: mfrapT1TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalEntry.setDescription('An entry in the T1 Physical Layer Measurement Totals table.')
mfrapT1TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalIndex.setDescription('The index value which uniquely identifies the t1 interface to which this entry is applica- ble. Since there is a separate Drop & Insert Performance 24 Hour Table, the value of this index will always be 1, referring to the WAN port. ')
mfrapT1TotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalESs.setDescription('The number of Errored Seconds encountered by a t1 interface in the previous 24 hour interval. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapT1TotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a t1 interface in the previous 24 hour interval. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapT1TotalSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalSEFSs.setDescription('The number of Severely Errored Framing Seconds 24 hour interval. A SEFS is a one second interval with one or more frame sync losses.')
mfrapT1TotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalUASs.setDescription("The number of Unavailable Seconds encountered by a t1 interface in the previous 24 hour in- terval. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapT1TotalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a t1 interface in the previous 24 hour interval. A controlled slip is the replication or deletion of a T1 frame at the receiver. These events often indicate a T1 network timing problem.')
mfrapT1TotalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a t1 interface in the previous 24 hour interval. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapT1TotalLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapT1TotalLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1TotalLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a t1 interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the T1 network.')
mfrapT1PerfCmdTypeTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 4))
mfrapT1PerfFreezeState = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("freeze-reg", 1), ("unfreeze-reg", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapT1PerfFreezeState.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1PerfFreezeState.setDescription("This command halts the node's performance monitoring and freezes the current, interval, and total performance register values.")
mfrapT1PerfClearEvents = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-events", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapT1PerfClearEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1PerfClearEvents.setDescription("This command resets all of the (user's) error event registers. This includes the CRC6 and Out-of-Frame counts. It does not affect the interval or 24 hour performance totals.")
mfrapT1PerfClearAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-all", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapT1PerfClearAll.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapT1PerfClearAll.setDescription("This command resets all of the (user's) performance registers.")
mfrapPerfDandiCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5), )
if mibBuilder.loadTexts: mfrapPerfDandiCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfDandiCurrentTable.setDescription('The T1 physical layer performance numbers for the current 15 minute interval. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel.')
mfrapDandiCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapDandiCurrentIndex"))
if mibBuilder.loadTexts: mfrapDandiCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentEntry.setDescription('An entry in the D&I Current Perf table.')
mfrapDandiCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("dandi-port1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentIndex.setDescription('The index value which uniquely identifies the D&I interface to which this entry is applica- ble. ')
mfrapDandiCurrentCrc6Events = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentCrc6Events.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentCrc6Events.setDescription('Count of CRC errors detected on an ESF framed circuit. In ESF framing a CRC is generated at the source, based upon the composite data. A CRC error indicates the presence of at least one bit error in an ESF superframe. This field is a free-running accumulation of CRC errors and IS NOT reset when the current 15 minute interval expires. It can be reset with the performance command mfrapDandiPerfClearEvents. Not applicable if D4/SF framing is selcted.')
mfrapDandiCurrentOofEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentOofEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentOofEvents.setDescription('Count of Out-of-Frame events on a D&I circuit. An out-of- frame event occurs when the frame synchronization criteria is lost and a resynchronization must occur. Data is interrupted during frame resynchronization. This field is a free-running accumulation of OOF transitions and IS NOT reset when the current 15 minute interval expires. It can be reset with the performance command mfrapDandiPerfClearEvents.')
mfrapDandiCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentESs.setDescription('The number of Errored Seconds, encountered by a D&I interface in the current 15 minute inter- val. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapDandiCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentSESs.setDescription('The number of Severely Errored Seconds encountered by a D&I interface in the current 15 minute interval. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapDandiCurrentSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentSEFSs.setDescription('The number of Severely Errored Framing Seconds encountered by a D&I interface in the current 15 minute interval. A SEFS is a one second interval with one or more frame sync losses.')
mfrapDandiCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentUASs.setDescription("The number of Unavailable Seconds encountered by a D&I interface in the current 15 minute in- terval. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapDandiCurrentCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a D&I interface in the current 15 minute interval. A controlled slip is the replication or deletion of a D&I frame at the receiver. These events often indicate a D&I network timing problem.')
mfrapDandiCurrentBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the current 15 minute interval. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapDandiCurrentLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiCurrentLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiCurrentLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a DS1 interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the D&I network.')
mfrapPerfDandiIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6), )
if mibBuilder.loadTexts: mfrapPerfDandiIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfDandiIntervalTable.setDescription('The DS1 Interval table. A history of physical layer performance results are maintained and represented as 96 15-minute intervals. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel')
mfrapDandiIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapDandiIntervalIndex"), (0, "MFRAP-MIB", "mfrapDandiIntervalNumber"))
if mibBuilder.loadTexts: mfrapDandiIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalEntry.setDescription('An entry in the DS1 Interval table.')
mfrapDandiIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("dandi-port1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalIndex.setDescription('The index value which uniquely identifies the D&I interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value as a NetwLineIndex object instance.')
mfrapDandiIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes inter- val (assuming that all 96 intervals are valid).')
mfrapDandiIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalESs.setDescription('The number of Errored Seconds encountered by a D&I interface in one of the previous 96, indi- vidual 15 minute, intervals. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapDandiIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a D&I interface in one of the previous 96, individual 15 minute, intervals. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapDandiIntervalSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalSEFSs.setDescription('The number of Severely Errored Framing Seconds encountered by a D&I interface in one of the previous 96, individual 15 minute, intervals. A SEFS is a one second interval with one or more frame sync losses.')
mfrapDandiIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalUASs.setDescription("The number of Unavailable Seconds encountered by a D&I interface in one of the previous 96, individual 15 minute, intervals. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapDandiIntervalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a D&I interface in one of the previous 96, individual 15 minute, intervals. A controlled slip is the replication or deletion of a D&I frame at the receiver. These events often indicate a D&I network timing problem.')
mfrapDandiIntervalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a D&I interface in one of the previous 96, individual 15 minute, intervals. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapDandiIntervalLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 6, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiIntervalLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiIntervalLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a DS1 interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the D&I network.')
mfrapPerfDandiTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7), )
if mibBuilder.loadTexts: mfrapPerfDandiTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfDandiTotalTable.setDescription('The T1 Total table cumulative physical layer performance results from the past 24 hours. These are defined and accumulated per ANSI specification T1.403 and AT&T publication 54016. Depending upon the configured T1 Framing mode, these results may be retrieved via ESF facility data link by service personnel.')
mfrapDandiTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapDandiTotalIndex"))
if mibBuilder.loadTexts: mfrapDandiTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalEntry.setDescription('An entry in the D&I Total table.')
mfrapDandiTotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("dandi-port1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalIndex.setDescription('The index value which uniquely identifies the D&I interface to which this entry is applica- ble. The interface identified by a particular value of this index is the same interface as identified by the same value as a NetwLineIndex object instance.')
mfrapDandiTotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalESs.setDescription('The number of Errored Seconds encountered by a D&I interface in the previous 24 hour interval. An errored second is a one-second interval with CRC errors or a loss of frame sync occurred.')
mfrapDandiTotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a D&I interface in the previous 24 hour interval. A severely errored second is a one second interval with more than 320 CRC errors or one or more frame sync losses.')
mfrapDandiTotalSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalSEFSs.setDescription('The number of Severely Errored Framing Seconds 24 hour interval. A SEFS is a one second interval with one or more frame sync losses.')
mfrapDandiTotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalUASs.setDescription("The number of Unavailable Seconds encountered by a D&I interface in the previous 24 hour in- terval. A UAS is a one second interval during which the received signal is classified as 'unavailable due to excessive errors'. A signal is unavailable after receiving ten consective severely errored seconds and stays unavailable until ten seconds without a severely errored second occur.")
mfrapDandiTotalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a D&I interface in the previous 24 hour interval. A controlled slip is the replication or deletion of a D&I frame at the receiver. These events often indicate a D&I network timing problem.')
mfrapDandiTotalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a D&I interface in the previous 24 hour interval. A BES is a one second interval with more than one and less than 320 CRC errors.')
mfrapDandiTotalLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 7, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDandiTotalLCVs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiTotalLCVs.setDescription('The number of Line Code Violations (LCVs) en- countered by a D&I interface in the current 15 minute interval. LCVs are non-B8ZS related violations of the alternate mark inversion protocol. An excessive count usually indicates a B8ZS/AMI configuration mismatch in the D&I network.')
mfrapDandiPerfCmdTypeTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 8))
mfrapDandiPerfFreezeState = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("freeze-reg", 1), ("unfreeze-reg", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mfrapDandiPerfFreezeState.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiPerfFreezeState.setDescription("This command halts the node's performance monitoring and freezes the current, interval, and total performance register values.")
mfrapDandiPerfClearEvents = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-events", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDandiPerfClearEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiPerfClearEvents.setDescription("This command resets all of the (user's) error event registers. This includes the CRC6 and Out-of-Frame counts. It does not affect the interval or 24 hour performance totals.")
mfrapDandiPerfClearAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-all", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapDandiPerfClearAll.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDandiPerfClearAll.setDescription("This command resets all of the (user's) performance registers.")
mfrapPerfMgmtIp = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2))
mfrapPerfMgmtIpIFStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 1))
mfrapPerfMgmtIpIFInOctets = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFInOctets.setDescription('The count of all octets associated with received frames that are specifically addressed as management packets for this unit. Same as ifInOctets in mib-2.')
mfrapPerfMgmtIpIFInErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFInErrors.setDescription('The count of packets associated with received frames that are specifically addressed as management packets for this unit which could not be handled because of errors. Same as ifInErrors in mib-2.')
mfrapPerfMgmtIpIFOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFOutOctets.setDescription('The count of all octets associated with generated frames that are specifically addressed as management packets from this unit. Same as ifOutOctets in mib-2. Same as ifOutOctets in mib-2.')
mfrapPerfMgmtIpIFOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIFOperStatus.setDescription('The current operational state of the management interface. Same as ifOperStatus in mib-2. (1) Interface Up (2) Interface Down (3) Interface in Test')
mfrapPerfMgmtIpIPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2))
mfrapPerfMgmtIpIPInRcv = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInRcv.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInRcv.setDescription('The count of all ip datagrams received which are specifically addressed as management frames for this unit. Same as ipInReceives in mib-2.')
mfrapPerfMgmtIpIPInHdrErr = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInHdrErr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInHdrErr.setDescription('The count of ip datagrams received which are specifically addressed as management frames for this unit that were discarded because of errors in their IP headers. Same as ipInHdrErrors in mib-2.')
mfrapPerfMgmtIpIPInAddrErr = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInAddrErr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInAddrErr.setDescription('The count of ip datagrams received which are specifically addressed as management frames for this unit that were discarded because unexpected or invalid IP addresses in their IP headers. Same as ipInAddrErrors in mib-2.')
mfrapPerfMgmtIpIPInProtUnk = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInProtUnk.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInProtUnk.setDescription('The count of ip datagrams received which are specifically addressed as management frames for this unit that were discarded because of unsupported protocols. Same as ipInUnknownProtos in mib-2.')
mfrapPerfMgmtIpIPInDscrd = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInDscrd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInDscrd.setDescription('The count of datagrams received which are specifically addressed as management frames for this unit that were discarded for reasons other than a problem with the datagram. Same as ipInDiscards in mib-2.')
mfrapPerfMgmtIpIPInDlvrs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInDlvrs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPInDlvrs.setDescription('The count ofip datagrams received which are specifically addressed as management frames for this unit that were delivered to IP client protocols. Same as ipInDelivers in mib-2.')
mfrapPerfMgmtIpIPOutRqst = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutRqst.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutRqst.setDescription('The count of all outgoing datagrams generated by this unit which are specifically addressed as management frames. Same as ipOutRequests in mib-2.')
mfrapPerfMgmtIpIPOutDscrd = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutDscrd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutDscrd.setDescription('The count of outgoing datagrams generated by this unit which are specifically addressed as management frames that were discarded for reasons other than a problem with the datagram. Same as ipOutDiscards in mib-2.')
mfrapPerfMgmtIpIPOutNoRt = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutNoRt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpIPOutNoRt.setDescription('The count of outgoing datagrams generated by this unit which are specifically addressed as management frames that were discarded because no route could be found for transmission. Same as ipOutNoRoutes in mib-2.')
mfrapPerfMgmtIpICMPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3))
mfrapPerfMgmtIpICMPInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInMsgs.setDescription('The count of all ICMP messages received which are addressed to this unit. Same as icmpInMsgs in mib-2.')
mfrapPerfMgmtIpICMPInErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInErrors.setDescription('The count of ICMP messages received which are addressed to this unit but contain errors. Same as icmpInErrors in mib-2.')
mfrapPerfMgmtIpICMPInDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInDestUnreachs.setDescription('The count of ICMP Destination Unreachable messages received which are addressed to this unit. Same as icmpInDestUnreachs in mib-2.')
mfrapPerfMgmtIpICMPInTimeExcds = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInTimeExcds.setDescription('The count of ICMP Time Exceeded messages received which are addressed to this unit. Same as icmpInTimeExcds in mib-2.')
mfrapPerfMgmtIpICMPInParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInParmProbs.setDescription('The count of ICMP Parameter Problem messages received which are addressed to this unit. Same as icmpInParmProbs in mib-2.')
mfrapPerfMgmtIpICMPInRedirects = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInRedirects.setDescription('The count of ICMP Redirect messages received which are addressed to this unit. Same as icmpInRedirects in mib-2.')
mfrapPerfMgmtIpICMPInEchos = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInEchos.setDescription('The count of ICMP Echo messages received which are addressed to this unit. Same as icmpInEchos in mib-2.')
mfrapPerfMgmtIpICMPInEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPInEchoReps.setDescription('The count of ICMP Echo Reply messages received which are addressed to this unit. Same as icmpInEchoReps in mib-2.')
mfrapPerfMgmtIpICMPOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutMsgs.setDescription('The count of all outgoing ICMP messages originating from this node. Same as icmpOutMsgs in mib-2.')
mfrapPerfMgmtIpICMPOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutErrors.setDescription('The count of outgoing ICMP messages generated by this unit which are not transmitted due problems found by the ICMP layer. Same as icmpOutErrors in mib-2.')
mfrapPerfMgmtIpICMPOutDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutDestUnreachs.setDescription('The count of outgoing ICMP Destination Unreachable messages generated by this unit. Same as icmpOutDestUnreachs in mib-2.')
mfrapPerfMgmtIpICMPOutParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutParmProbs.setDescription('The count of outgoing ICMP Parameter Problem messages generated by this unit. Same as icmpOutParmProbs in mib-2.')
mfrapPerfMgmtIpICMPOutRedirects = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutRedirects.setDescription('The count of outgoing ICMP Redirect messages generated by this unit. Same as icmpOutRedirects in mib-2.')
mfrapPerfMgmtIpICMPOutEchos = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutEchos.setDescription('The count of outgoing ICMP Echo messages generated by this unit. Same as icmpOutEchos in mib-2.')
mfrapPerfMgmtIpICMPOutEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 3, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpICMPOutEchoReps.setDescription('The count of outgoing ICMP Echo Reply messages generated by this unit. Same as icmpOutEchoReps in mib-2.')
mfrapPerfMgmtIpUDPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 4))
mfrapPerfMgmtIpUDPInDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPInDatagrams.setDescription('The count of all UDP datagrams received that are addressed as management frames for this unit. Same as udpInDatagrams in mib-2.')
mfrapPerfMgmtIpUDPOutDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPOutDatagrams.setDescription('The count of all UDP datagrams generated by this unit. Same as udpOutDatagrams in mib-2.')
mfrapPerfMgmtIpUDPNoPorts = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpUDPNoPorts.setDescription('The count of all UDP datagrams received that are addressed as management frames for this unit with no application at the destination port. Same as udpNoPorts in mib-2.')
mfrapPerfMgmtIpTCPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5))
mfrapPerfMgmtIpTCPActiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPActiveOpens.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from CLOSED to SYN-SENT. Same as tcpActiveOpens in mib-2.')
mfrapPerfMgmtIpTCPPassiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPPassiveOpens.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from CLOSED to SYN-RCVD. Same as tcpPassiveOpens in mib-2.')
mfrapPerfMgmtIpTCPAttemptFails = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPAttemptFails.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from SYN-SENT or SYN-RCVD to CLOSED state, plus the count of the times TCP connections have made a direct state transition from SYN-RCVD to LISTEN. Same as tcpAttemptFails in mib-2.')
mfrapPerfMgmtIpTCPCurrEstab = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPCurrEstab.setDescription('The count of the TCP connections specific to this unit in state ESTABLISHED or CLOSE-WAIT. Same as tcpCurrEstab in mib-2.')
mfrapPerfMgmtIpTCPInSegs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPInSegs.setDescription('The count of all the segments received that are addressed as management frames for this unit. Same as tcpInSegs in mib-2.')
mfrapPerfMgmtIpTCPOutSegs = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 2, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfMgmtIpTCPOutSegs.setDescription('The count of all the segments generated from this unit. Same as tcpOutSegs in mib-2.')
mfrapPerfThruput = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 3))
mfrapPerfThruputPerIntfTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1), )
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTable.setDescription('The throughput per interface table. These values are accumulated across all DLCIs.')
mfrapPerfThruputPerIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfThruputPerIntfIndex"))
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfEntry.setDescription('An entry in the throughput per interface table.')
mfrapPerfThruputPerIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("t1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfIndex.setDescription('Interface for which the statistics apply. (1) DTE interface (2) T1 interface')
mfrapPerfThruputPerIntfRxByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxByteCnt.setDescription('The number of bytes that have been counted on this interface.')
mfrapPerfThruputPerIntfTxByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTxByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTxByteCnt.setDescription('The number of bytes that have been counted on this interface.')
mfrapPerfThruputPerIntfRxFrameCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxFrameCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxFrameCnt.setDescription('The number of frames that have been counted on this interface.')
mfrapPerfThruputPerIntfTxFrameCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTxFrameCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfTxFrameCnt.setDescription('The number of frames that have been counted on this interface.')
mfrapPerfThruputPerIntfRxCrcErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxCrcErrCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxCrcErrCnt.setDescription('The number of frames with CRC errors received on this interface.')
mfrapPerfThruputPerIntfRxAbortCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxAbortCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerIntfRxAbortCnt.setDescription('The number of aborted frames received on this interface.')
class Index(Integer32):
    pass

mfrapPerfThruputPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2), )
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTable.setDescription('Layer 2 statistics on a per-DLCI basis. Transmit direction is from DTE to WAN and receive direction is from the WAN towards the DTE.')
mfrapPerfThruputPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfThruputPerDlciIndex"), (0, "MFRAP-MIB", "mfrapPerfThruputPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEntry.setDescription('The Statistics for a particular Data Link Connection Management Interface (DLCI).')
mfrapPerfThruputPerDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 1), Index()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciIndex.setDescription('This value must be in the range 1-3. Other than that, this value is ignored as all three will return the same result.')
mfrapPerfThruputPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
mfrapPerfThruputPerDlciCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCreateTime.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCreateTime.setDescription('The amount of time elapsed since this DLCI was first detected through traffic sensing or in an LMI message (in seconds).')
mfrapPerfThruputPerDlciChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciChangeTime.setDescription('The amount of elapsed time since this DLCI last changed state from active to inactive or vice versa (in seconds).')
mfrapPerfThruputPerDlciRxByte = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxByte.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxByte.setDescription('The number of bytes that have been received from the WAN towards the DTE on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciTxByte = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxByte.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxByte.setDescription('The number of bytes that have been transmit from the DTE towards the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciRxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxFrame.setDescription('The number of frames that have been received from the WAN towards to the DTE on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciTxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxFrame.setDescription('The number of frames that have been transmit from the DTE towards the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciRxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxFecn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxFecn.setDescription('The number frames received from the WAN towards the DTE that have had the Forward Explict Congestion Notification (FECN) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciRxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxBecn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxBecn.setDescription('The number frames received from the WAN towards the DTE that have had the Backward Explict Congestion Notification (BECN) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciRxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxDe.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxDe.setDescription('The number frames received from the WAN towards the DTE that have had the Discard Eligibility (DE) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciTxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxDe.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxDe.setDescription('The number frames transmit towards the WAN from the DTE that have had the Discard Eligibility (DE) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciRxThruput = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxThruput.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxThruput.setDescription('The number of bits/sec received from the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciTxThruput = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxThruput.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxThruput.setDescription('The number of bits/sec transmit to the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
mfrapPerfThruputPerDlciCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCIR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCIR.setDescription('The Committed Information Rate (CIR) for this DLCI. This can come form one of three sources: From the LMI Full Status Response, configured by the user, or the DTE line rate (default).')
mfrapPerfThruputPerDlciCirType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cir-acquired-from-lmi", 1), ("cir-configured-by-user", 2), ("cir-is-dte-datarate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCirType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciCirType.setDescription('The source of the CIR value for this DLCI. (1) CIR acquired from LMI message. Will override user configured CIR. This feature is not supported by all Frame Relay DCE (switches). (2) CIR configured by user. (3) CIR is DTE Line Rate. Default if CIR is not set by one of the other methods.')
mfrapPerfThruputPerDlciUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciUptime.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciUptime.setDescription('The total amount of time that the DLCI has been up as reproted by the LMI Full Status Response (in seconds).')
mfrapPerfThruputPerDlciDowntime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciDowntime.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciDowntime.setDescription("The total amount of time that the DLCI has been declared down (in seconds). A DLCI is Down if it's explicitly declared Inactive through LMI or if it's missing from the LMI Full Status message or if there is no Full Status message at all.")
mfrapPerfThruputPerDlciPvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("pvc-active", 1), ("pvc-inactive", 2), ("pvc-unprovisioned", 3), ("pvc-not-in-lmi", 4), ("pvc-lmi-timeout", 5), ("pvc-undetermined", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciPvcState.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciPvcState.setDescription('The current state of the DLCI: (1) DLCI marked active in last full status LMI (2) DLCI in last full status LMI but not marked active (3) DLCI has never been seen in a full status LMI (4) DLCI was seen at least once in a full status LMI but was not in the last full status LMI (5) the full status LMI has timed out; all previously active or inactive DLCIs are changed to this state (6) DLCI was detected in the traffic stream and a full status LMI has not been received so the state cannot be determined yet. ')
mfrapPerfThruputPerDlciOutageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciOutageCount.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciOutageCount.setDescription('The number of times the smperPerfThruputPerDlciPvcState transitions from pvc-active or pvc-undetermined to one of the other (inactive) states. ')
mfrapPerfThruputPerDlciAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciAvailability.setDescription('The measure of the percentage time the DLCI is available: UpTime/CreateTime or zero if CreateTime = 0. (in 1/1000 per cent; i.e. availability = 1000 converts to 1%). ')
mfrapPerfThruputPerDlciMTBSO = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciMTBSO.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciMTBSO.setDescription('Mean Time Between Service Outages: UpTime/OutageCount or zero if OutageCount = 0 (in seconds). ')
mfrapPerfThruputPerDlciMTTSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciMTTSR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciMTTSR.setDescription('Mean Time to ServiceRestoral: DownTime/OutageCount or zero if OutageCount = 0 (in seconds). ')
mfrapPerfThruputPerDlciEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("encap-na", 1), ("encap-1490", 2), ("encap-cisco", 3), ("encap-annex-g", 4), ("encap-other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEncapType.setDescription('The encapsulation protocol seen in the last frame analyzed on this DLCI: (1) DLCI is the LMI DLCI or no frames have been analyzed (2) The encapsulation is per rfc1490 (3) The encapsulation is per Cisco proprietary (4) The encapsulation is per Annex-G (X.25 over frame relay) (5) The encapsulation is not one of the above. ')
mfrapPerfThruputPerDlciRxUtilizationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("over-threshold", 2), ("alarm", 3), ("alarm-under-threshold", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxUtilizationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciRxUtilizationStatus.setDescription(' The status of the per-DLCI utilization alarm in the receive direction. (1) there is no alarm condition; utilization is under the configured CIR percentage threshold; if traps are enabled and the alarm had been previously triggered, a utilization alarm clear trap will be sent. (2) the utilization has been over the configured CIR percentage threshold for less than the configured duration. (3) the utilization has been over the configured CIR percentage threshold for more than the configured duration; if traps are enabled a utilization exceeded trap will be sent. (4) the utilization has been under the configured CIR percentage threshold for less than the configured duration. ')
mfrapPerfThruputPerDlciTxUtilizationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("over-threshold", 2), ("alarm", 3), ("alarm-under-threshold", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxUtilizationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciTxUtilizationStatus.setDescription(' The status of the per-DLCI utilization alarm in the transmit direction. (1) there is no alarm condition; utilization is under the configured CIR percentage threshold; if traps are enabled and the alarm had been previously triggered, a utilization alarm clear trap will be sent. (2) the utilization has been over the configured CIR percentage threshold for less than the configured duration. (3) the utilization has been over the configured CIR percentage threshold for more than the configured duration; if traps are enabled a utilization exceeded trap will be sent. (4) the utilization has been under the configured CIR percentage threshold for less than the configured duration. ')
mfrapPerfThruputPerDlciEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEIR.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputPerDlciEIR.setDescription('The Excess Information Rate. This is defined to be the maximum rate traffic is (supposed to be) allowed to burst to.')
mfrapPerfThruputCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3))
mfrapPerfThruputCmdClearDteStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearDteStats.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearDteStats.setDescription('Allows the user to zero out all the interface statistics in the DTE portion of the ThruputPerIntf statistics table. (1) Clear DTE interface statistics command.')
mfrapPerfThruputCmdClearT1Stats = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearT1Stats.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearT1Stats.setDescription('Allows the user to zero out all the interface statistics in the WAN portion of the ThruputPerIntf statistics table. (1) Clear WAN interface statistics command.')
mfrapPerfThruputCmdClearAllIntfStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearAllIntfStats.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearAllIntfStats.setDescription('Allows the user to zero out all the statistics in the ThruputPerIntf statistics table. (1) Clear all interface statistics command.')
mfrapPerfThruputCmdClearDlciStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearDlciStats.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearDlciStats.setDescription('Allows the user to zero out all the per-DLCI statistics in the ThruputPerDlci statistics table and the the short term statistics tables. (1) Clear layer 2 per-DLCI statistics command.')
mfrapPerfThruputCmdClearAllStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearAllStats.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdClearAllStats.setDescription('Allows the user to zero out all the statistics in the ThruputPerIntf and ThruputPerDlci statistics tables and in the short term statistics tables. (1) Clear all interface and layer 2 per-DLCI statistics.')
mfrapPerfThruputCmdRemoveStsDlci = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdRemoveStsDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdRemoveStsDlci.setDescription('Allows the user to remove a Dlci from the short term statistics tables.')
mfrapPerfThruputCmdReplaceDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 7), )
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciTable.setDescription('Allows the user to replace one DLCI in the short-term statistics table with another one.')
mfrapPerfThruputCmdReplaceDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 7, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfThruputCmdReplaceDlciValue"))
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciEntry.setDescription('Allows the user to replace one DLCI in the short-term statistics table with another one.')
mfrapPerfThruputCmdReplaceDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciValue.setDescription('A Dlci that is in the short-term stats table. Index by this Dlci value to identify the statistics entry to be replaced.')
mfrapPerfThruputCmdReplaceDlciNewValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 7, 1, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciNewValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdReplaceDlciNewValue.setDescription('A Dlci that is to replace another in the short-term stats table. Index by this Dlci value to identify the statistics entry to do the replacing.')
mfrapPerfThruputCmdAvailabilityStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 8), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdAvailabilityStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdAvailabilityStsDlciReset.setDescription('Allows the user to reset the availability statistics of an individual Dlci within the short-term stats table.')
mfrapPerfThruputCmdAvailabilityStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 9), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdAvailabilityStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdAvailabilityStsDlciResetAll.setDescription("Allows the user to reset the availability statistics of all Dlci's within the short-term stats table.")
mfrapPerfThruputCmdCountsStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 10), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdCountsStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdCountsStsDlciReset.setDescription('Allows the user to reset the count statistics of an individual Dlci within the short-term stats table.')
mfrapPerfThruputCmdCountsStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 11), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdCountsStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdCountsStsDlciResetAll.setDescription("Allows the user to reset the count statistics of all Dlci's within the short-term stats table.")
mfrapPerfThruputCmdAllStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 12), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdAllStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdAllStsDlciReset.setDescription('Allows the user to reset both the count and availability statistics of an individual Dlci within the short-term stats table.')
mfrapPerfThruputCmdAllStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 3, 3, 13), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfThruputCmdAllStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfThruputCmdAllStsDlciResetAll.setDescription("Allows the user to reset both the count and the availability statistics of all Dlci's within the short-term stats table.")
mfrapPerfNetworkShortTerm = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 4))
mfrapPerfNetwProtoPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1), )
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTable.setDescription('The Short Term Statistics on the Network Layer protocol for each DLCI. These are protocol-based per-DLCI statistics. The Short Term model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval).')
mfrapPerfNetwProtoPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfNetwProtoPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfNetwProtoPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciEntry.setDescription('The Network Layer Short Term Statistics for a particular DLCI. This table organizes statistics by high-layer network protocol.')
mfrapPerfNetwProtoPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfNetwProtoPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfNetwProtoPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxTotal.setDescription('The total number of received Network Layer bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxTotal.setDescription('The total number of transmitted Network Layer bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxIp.setDescription('The number of received IP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxIp.setDescription('The number of transmitted IP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxIpx.setDescription('The number of received IPX bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxIpx.setDescription('The number of transmitted IPX bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxSna.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxSna.setDescription('The number of received SNA bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxSna.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxSna.setDescription('The number of transmitted SNA bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxArp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxArp.setDescription('The number of received ARP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxArp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxArp.setDescription('The number of transmitted ARP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxCisco.setDescription('The number of received Cisco protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxCisco.setDescription('The number of transmitted Cisco protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols that are not counted elsewhere in this table.')
mfrapPerfNetwProtoPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols that are not counted elsewhere in this table.')
mfrapPerfNetwProtoPerDlciRxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxVnip.setDescription('The number of received VNIP protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxVnip.setDescription('The number of transmitted VNIP protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciRxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciRxAnnexG.setDescription('The number of received Annex G protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoPerDlciTxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoPerDlciTxAnnexG.setDescription('The number of transmitted Annex G protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2), )
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTable.setDescription('The Short Term Statistics on Network Layer protocols summed across all DLCIs.')
mfrapPerfNetwProtoTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfNetwProtoTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalEntry.setDescription('The Network Layer Short Term Statistics for a particular DLCI.')
mfrapPerfNetwProtoTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfNetwProtoTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxTotal.setDescription('The total number of received Network Layer bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxTotal.setDescription('The total number of transmitted Network Layer bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxIp.setDescription('The number of received IP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxIp.setDescription('The number of transmitted IP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxIpx.setDescription('The number of received IPX bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxIpx.setDescription('The number of transmitted IPX bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxSna.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxSna.setDescription('The number of received SNA bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxSna.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxSna.setDescription('The number of transmitted SNA bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxArp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxArp.setDescription('The number of received ARP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxArp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxArp.setDescription('The number of transmitted ARP bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxCisco.setDescription('The number of received Cisco protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxCisco.setDescription('The number of transmitted Cisco protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxOther.setDescription('The number of received bytes on this DLCI from protocols that are not counted elsewhere in this table.')
mfrapPerfNetwProtoTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols that are not counted elsewhere in this table.')
mfrapPerfNetwProtoTotalRxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxVnip.setDescription('The number of received VNIP protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxVnip.setDescription('The number of transmitted VNIP protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalRxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalRxAnnexG.setDescription('The number of received Annex G protocol bytes that have been counted on this DLCI.')
mfrapPerfNetwProtoTotalTxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwProtoTotalTxAnnexG.setDescription('The number of transmitted Annex G protocol bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3), )
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTable.setDescription('The Short Term Statistics on the IP protocol for each DLCI.')
mfrapPerfIpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIpPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfIpPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfIpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciEntry.setDescription('The IP Short Term Statistics for a particular DLCI.')
mfrapPerfIpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfIpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxTotal.setDescription('The total number of received IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxTotal.setDescription('The total number of transmitted IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciRxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxTcp.setDescription('The number of received TCP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxTcp.setDescription('The number of transmitted TCP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciRxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxUdp.setDescription('The number of received UDP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxUdp.setDescription('The number of transmitted UDP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciRxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxIcmp.setDescription('The number of received ICMP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxIcmp.setDescription('The number of transmitted ICMP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
mfrapPerfIpPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
mfrapPerfIpPerDlciRxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciRxIgrp.setDescription('The number of received IGRP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpPerDlciTxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpPerDlciTxIgrp.setDescription('The number of transmitted IGRP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4), )
if mibBuilder.loadTexts: mfrapPerfIpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTable.setDescription('The Short Term Statistics on the IP protocol for each DLCI.')
mfrapPerfIpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIpTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfIpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalEntry.setDescription('The IP Short Term Statistics for a particular DLCI.')
mfrapPerfIpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxTotal.setDescription('The total number of received IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxTotal.setDescription('The total number of transmitted IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalRxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxTcp.setDescription('The number of received TCP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxTcp.setDescription('The number of transmitted TCP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalRxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxUdp.setDescription('The number of received UDP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxUdp.setDescription('The number of transmitted UDP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalRxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxIcmp.setDescription('The number of received ICMP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxIcmp.setDescription('The number of transmitted ICMP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxOther.setDescription('The number of received bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
mfrapPerfIpTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
mfrapPerfIpTotalRxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalRxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalRxIgrp.setDescription('The number of received IGRP over IP bytes that have been counted on this DLCI.')
mfrapPerfIpTotalTxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpTotalTxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpTotalTxIgrp.setDescription('The number of transmitted IGRP over IP bytes that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5), )
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTable.setDescription('Short Term Statistics on the ICMP protocol for each DLCI.')
mfrapPerfIcmpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIcmpPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfIcmpPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciEntry.setDescription('The ICMP Short Term Statistics for a particular DLCI.')
mfrapPerfIcmpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIcmpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
mfrapPerfIcmpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciRxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciRxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
mfrapPerfIcmpPerDlciTxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpPerDlciTxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
mfrapPerfIcmpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6), )
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTable.setDescription('Short Term Statistics on the ICMP protocol for each DLCI.')
mfrapPerfIcmpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIcmpTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfIcmpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalEntry.setDescription('The ICMP Short Term Statistics for a particular DLCI.')
mfrapPerfIcmpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIcmpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
mfrapPerfIcmpTotalRxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalRxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
mfrapPerfIcmpTotalTxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 6, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIcmpTotalTxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7), )
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTable.setDescription('The Short Term Statistics on the Application protocol for each DLCI.')
mfrapPerfApplicationPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfApplicationPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfApplicationPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciEntry.setDescription('The Application Short Term Statistics for a particular DLCI.')
mfrapPerfApplicationPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfApplicationPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfApplicationPerDlciRxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSnmp.setDescription('The number of received SNMP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSnmp.setDescription('The number of transmitted SNMP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSnmpTrap.setDescription('The number of received SNMP TRAP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSnmpTrap.setDescription('The number of transmitted SNMP TRAP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxHttp.setDescription('The number of received HTTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxHttp.setDescription('The number of transmitted HTTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxTelnet.setDescription('The number of received Telnet bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxTelnet.setDescription('The number of transmitted Telnet bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxSmtp.setDescription('The number of received SMTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxSmtp.setDescription('The number of transmitted SMTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxFtp.setDescription('The number of received FTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxFtp.setDescription('The number of transmitted FTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxTftp.setDescription('The number of received TFTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxTftp.setDescription('The number of transmitted TFTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom1.setDescription('The number of received bytes of User Defined Protocol #1 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom1.setDescription('The number of transmitted bytes of User Defined Protocol #1 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom2.setDescription('The number of received bytes of User Defined Protocol #2 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom2.setDescription('The number of transmitted bytes of User Defined Protocol #2 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom3.setDescription('The number of received bytes of User Defined Protocol #3 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom3.setDescription('The number of transmitted bytes of User Defined Protocol #3 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciRxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciRxCustom4.setDescription('The number of received bytes of User Defined Protocol #4 that have been counted on this DLCI.')
mfrapPerfApplicationPerDlciTxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 7, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationPerDlciTxCustom4.setDescription('The number of transmitted bytes of User Defined Protocol #4 that have been counted on this DLCI.')
mfrapPerfApplicationTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8), )
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTable.setDescription('The Short Term Statistics on the Application protocol for each DLCI.')
mfrapPerfApplicationTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfApplicationTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfApplicationTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalEntry.setDescription('The Application Short Term Statistics for a particular DLCI.')
mfrapPerfApplicationTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfApplicationTotalRxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSnmp.setDescription('The number of received SNMP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSnmp.setDescription('The number of transmitted SNMP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSnmpTrap.setDescription('The number of received SNMP TRAP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSnmpTrap.setDescription('The number of transmitted SNMP TRAP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxHttp.setDescription('The number of received HTTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxHttp.setDescription('The number of transmitted HTTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxTelnet.setDescription('The number of received Telnet bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxTelnet.setDescription('The number of transmitted Telnet bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxSmtp.setDescription('The number of received SMTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxSmtp.setDescription('The number of transmitted SMTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxFtp.setDescription('The number of received FTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxFtp.setDescription('The number of transmitted FTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxTftp.setDescription('The number of received TFTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxTftp.setDescription('The number of transmitted TFTP bytes that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom1.setDescription('The number of received bytes of User Defined Protocol #1 that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom1.setDescription('The number of transmitted bytes of User Defined Protocol #1 that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom2.setDescription('The number of received bytes of User Defined Protocol #2 that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom2.setDescription('The number of transmitted bytes of User Defined Protocol #2 that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom3.setDescription('The number of received bytes of User Defined Protocol #3 that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom3.setDescription('The number of transmitted bytes of User Defined Protocol #3 that have been counted on this DLCI.')
mfrapPerfApplicationTotalRxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalRxCustom4.setDescription('The number of received bytes of User Defined Protocol #4 that have been counted on this DLCI.')
mfrapPerfApplicationTotalTxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 8, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfApplicationTotalTxCustom4.setDescription('The number of transmitted bytes of User Defined Protocol #4 that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9), )
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTable.setDescription('The Short Term Statistics on the Routing protocol for each DLCI.')
mfrapPerfRoutingPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfRoutingPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfRoutingPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciEntry.setDescription('The Routing Short Term Statistics for a particular DLCI.')
mfrapPerfRoutingPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfRoutingPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfRoutingPerDlciRxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxOspf.setDescription('The number of received OSPF bytes that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciTxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxOspf.setDescription('The number of transmitted OSPF bytes that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxRip.setDescription('The number of received RIP bytes that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxRip.setDescription('The number of transmitted RIP bytes that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciRxNetbios.setDescription('The number of received Netbios bytes that have been counted on this DLCI.')
mfrapPerfRoutingPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingPerDlciTxNetbios.setDescription('The number of transmitted Netbios bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10), )
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTable.setDescription('The Short Term Statistics on the Routing protocol for each DLCI.')
mfrapPerfRoutingTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfRoutingTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfRoutingTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalEntry.setDescription('The Routing Short Term Statistics for a particular DLCI.')
mfrapPerfRoutingTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfRoutingTotalRxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxOspf.setDescription('The number of received OSPF bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalTxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxOspf.setDescription('The number of transmitted OSPF bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxRip.setDescription('The number of received RIP bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxRip.setDescription('The number of transmitted RIP bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalRxNetbios.setDescription('The number of received Netbios bytes that have been counted on this DLCI.')
mfrapPerfRoutingTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfRoutingTotalTxNetbios.setDescription('The number of transmitted Netbios bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11), )
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTable.setDescription('Short Term Statistics on the IPX protocol for each DLCI.')
mfrapPerfIpxPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIpxPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfIpxPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciEntry.setDescription('The IPX Short Term Statistics for a particular DLCI.')
mfrapPerfIpxPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIpxPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
mfrapPerfIpxPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxSap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxSap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
mfrapPerfIpxPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
mfrapPerfIpxTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12), )
if mibBuilder.loadTexts: mfrapPerfIpxTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTable.setDescription('Short Term Statistics on the IPX protocol for each DLCI.')
mfrapPerfIpxTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfIpxTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfIpxTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalEntry.setDescription('The IPX Short Term Statistics for a particular DLCI.')
mfrapPerfIpxTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfIpxTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxSap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxSap.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
mfrapPerfIpxTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalRxOther.setDescription('The number of received bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
mfrapPerfIpxTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 12, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfIpxTotalTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
mfrapPerfSnaPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13), )
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTable.setDescription('Short Term Statistics on the SNA protocol for each DLCI.')
mfrapPerfSnaPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfSnaPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfSnaPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciEntry.setDescription('The SNA Short Term Statistics for a particular DLCI.')
mfrapPerfSnaPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfSnaPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
mfrapPerfSnaPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciRxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciTxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciRxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciTxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciRxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciTxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
mfrapPerfSnaPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
mfrapPerfSnaPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
mfrapPerfSnaTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14), )
if mibBuilder.loadTexts: mfrapPerfSnaTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTable.setDescription('Short Term Statistics on the SNA protocol for each DLCI.')
mfrapPerfSnaTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfSnaTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfSnaTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalEntry.setDescription('The SNA Short Term Statistics for a particular DLCI.')
mfrapPerfSnaTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfSnaTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalRxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalTxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalRxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalTxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalRxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalTxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
mfrapPerfSnaTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalRxOther.setDescription('The number of received bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
mfrapPerfSnaTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 14, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfSnaTotalTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
mfrapPerfArpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15), )
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTable.setDescription('Short Term Statistics on the ARP protocol for each DLCI.')
mfrapPerfArpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfArpPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfArpPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfArpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciEntry.setDescription('The ARP Short Term Statistics for a particular DLCI.')
mfrapPerfArpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfArpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
mfrapPerfArpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciTxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciRxOther.setDescription('The number of received bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
mfrapPerfArpPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 15, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
mfrapPerfArpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16), )
if mibBuilder.loadTexts: mfrapPerfArpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTable.setDescription('Short Term Statistics on the ARP protocol across all DLCIs.')
mfrapPerfArpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfArpTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfArpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalEntry.setDescription('The ARP Short Term Statistics for a particular DLCI.')
mfrapPerfArpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfArpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalTxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
mfrapPerfArpTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalRxOther.setDescription('The number of received bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
mfrapPerfArpTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 16, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfArpTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfArpTotalTxOther.setDescription('The number of transmitted bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
mfrapPerfLmiPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17), )
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTable.setDescription('Short Term Statistics on LMI protocol for each DLCI.')
mfrapPerfLmiPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfLmiPerDlciInterval"), (0, "MFRAP-MIB", "mfrapPerfLmiPerDlciValue"))
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciEntry.setDescription('The LMI Short Term Statistics for a particular DLCI.')
mfrapPerfLmiPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfLmiPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfLmiPerDlciRxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxTotalByteCnt.setDescription('The total number of received LMI bytes counted on this DLCI.')
mfrapPerfLmiPerDlciTxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxTotalByteCnt.setDescription('The total number of transmitted LMI bytes counted on this DLCI.')
mfrapPerfLmiPerDlciRxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxLivoEnqByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
mfrapPerfLmiPerDlciTxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxLivoEnqByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
mfrapPerfLmiPerDlciRxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxLivoStatByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
mfrapPerfLmiPerDlciTxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxLivoStatByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
mfrapPerfLmiPerDlciRxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxFullEnqByteCnt.setDescription('The number of bytes received in Full Status enquiries on this DLCI.')
mfrapPerfLmiPerDlciTxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxFullEnqByteCnt.setDescription('The number of bytes transmitted in Full Status enquiries on this DLCI.')
mfrapPerfLmiPerDlciRxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxFullStatByteCnt.setDescription('The number of bytes received in Full Status messages on this DLCI.')
mfrapPerfLmiPerDlciTxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxFullStatByteCnt.setDescription('The number of bytes transmitted in Full Status messages on this DLCI.')
mfrapPerfLmiPerDlciRxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciRxOtherByteCnt.setDescription('The number of received bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
mfrapPerfLmiPerDlciTxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiPerDlciTxOtherByteCnt.setDescription('The number of transmitted bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
mfrapPerfLmiTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18), )
if mibBuilder.loadTexts: mfrapPerfLmiTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTable.setDescription('Short Term Statistics on LMI protocol across all DLCIs.')
mfrapPerfLmiTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfLmiTotalInterval"))
if mibBuilder.loadTexts: mfrapPerfLmiTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalEntry.setDescription('The LMI Short Term Statistics across all DLCIs.')
mfrapPerfLmiTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfLmiTotalDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalDlciValue.setDescription('OBSOLETE.')
mfrapPerfLmiTotalRxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxTotalByteCnt.setDescription('The total number of received LMI bytes counted on this DLCI.')
mfrapPerfLmiTotalTxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxTotalByteCnt.setDescription('The total number of transmitted LMI bytes counted on this DLCI.')
mfrapPerfLmiTotalRxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxLivoEnqByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
mfrapPerfLmiTotalTxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxLivoEnqByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
mfrapPerfLmiTotalRxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxLivoStatByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
mfrapPerfLmiTotalTxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxLivoStatByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
mfrapPerfLmiTotalRxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxFullEnqByteCnt.setDescription('The number of bytes received in Full Status enquiries on this DLCI.')
mfrapPerfLmiTotalTxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxFullEnqByteCnt.setDescription('The number of bytes transmitted in Full Status enquiries on this DLCI.')
mfrapPerfLmiTotalRxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxFullStatByteCnt.setDescription('The number of bytes received in Full Status messages on this DLCI.')
mfrapPerfLmiTotalTxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxFullStatByteCnt.setDescription('The number of bytes transmitted in Full Status messages on this DLCI.')
mfrapPerfLmiTotalRxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalRxOtherByteCnt.setDescription('The number of received bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
mfrapPerfLmiTotalTxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 4, 18, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfLmiTotalTxOtherByteCnt.setDescription('The number of transmitted bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
mfrapPerfNetworkLongTerm = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 5))
mfrapPerfNetwLongTermTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1), )
if mibBuilder.loadTexts: mfrapPerfNetwLongTermTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermTable.setDescription('Long Term Statistics by DLCI, protocol, and interval. LT statistics are collected on a configurable set of DLCIs and protocols. There are 96 intervals maintained each with a duration defined by the Long Term Timer. Interval 96 is the current window and Interval 1 is furthest back in time (96xLT Timer seconds ago).')
mfrapPerfNetwLongTermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfNetwLongTermDlci"), (0, "MFRAP-MIB", "mfrapPerfNetwLongTermProtocol"), (0, "MFRAP-MIB", "mfrapPerfNetwLongTermInterval"))
if mibBuilder.loadTexts: mfrapPerfNetwLongTermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermEntry.setDescription('The Long Term Statistic for a particular DLCI, protocol and interval.')
mfrapPerfNetwLongTermDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermDlci.setDescription('The DLCI monitored for the statistics. The Long Term DLCI filter must first be configured.')
mfrapPerfNetwLongTermProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-bc", 129), ("thru-frame-rx-bc", 130), ("thru-fecn-tx-bc", 131), ("thru-fecn-rx-bc", 132), ("thru-becn-tx-bc", 133), ("thru-becn-rx-bc", 134), ("thru-de-tx-bc", 135), ("thru-de-rx-bc", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermProtocol.setDescription('The type of protocol monitored for the statistics.')
mfrapPerfNetwLongTermInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermInterval.setDescription('The time interval in which the value was collected. Long Term statistis are maintained for 96 intervals with the interval duration defined by (CfgFrPerfTimersLTInterval).')
mfrapPerfNetwLongTermValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermValue.setDescription('The statistic collected for the given DLCI and protocol and within the given time interval.')
mfrapPerfNetwLongTermAltTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 2), )
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltTable.setDescription('This is an alternative method to access the database of long term statistics. The statistics are indexed by DLCI and protocol and are returned in an OCTETSTRING.')
mfrapPerfNetwLongTermAltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfNetwLongTermAltDlci"), (0, "MFRAP-MIB", "mfrapPerfNetwLongTermAltProtocol"))
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltEntry.setDescription('The Long Term Statistic for a particular DLCI and protocol.')
mfrapPerfNetwLongTermAltDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltDlci.setDescription('The DLCI monitored for the statistics.')
mfrapPerfNetwLongTermAltProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-bc", 129), ("thru-frame-rx-bc", 130), ("thru-fecn-tx-bc", 131), ("thru-fecn-rx-bc", 132), ("thru-becn-tx-bc", 133), ("thru-becn-rx-bc", 134), ("thru-de-tx-bc", 135), ("thru-de-rx-bc", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltProtocol.setDescription('The protocol monitored for the statistics.')
mfrapPerfNetwLongTermAltArray = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltArray.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetwLongTermAltArray.setDescription('The statistic collected for the given DLCI and protocol.')
mfrapPerfNetworkLongTermCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 3))
mfrapPerfNetworkLongTermCmdClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 5, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapPerfNetworkLongTermCmdClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfNetworkLongTermCmdClear.setDescription('Allows the user to zero out all the statistics in the long term statistics tables. (1) Clear all Long Term statistics')
mfrapPerfCirPercentUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 6))
mfrapPerfCirPercentUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1), )
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationTable.setDescription('Short Term Statistics on the percentage of CIR used on each DLCI. Each short term statistics interval, the count of bytes transmitted and received is used to calculate the percentage of CIR used. The byte count is then added to the appropriate bucket for the CIR percentage range.')
mfrapPerfCirPercentUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfCirPercentUtilizationInterval"), (0, "MFRAP-MIB", "mfrapPerfCirPercentUtilizationDlciValue"))
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationEntry.setDescription('The CIR Percentage Statistics for a particular DLCI.')
mfrapPerfCirPercentUtilizationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
mfrapPerfCirPercentUtilizationDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirPercentUtilizationDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfCirRxPercentUtilizationRange1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange1.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 1 (0% of CIR).')
mfrapPerfCirRxPercentUtilizationRange2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange2.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 2 (1-10% of CIR).')
mfrapPerfCirRxPercentUtilizationRange3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange3.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 3 (11-20% of CIR).')
mfrapPerfCirRxPercentUtilizationRange4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange4.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 4 (21-50% of CIR).')
mfrapPerfCirRxPercentUtilizationRange5 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange5.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange5.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 5 (51-80% of CIR).')
mfrapPerfCirRxPercentUtilizationRange6 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange6.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange6.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 6 (81-100% of CIR).')
mfrapPerfCirRxPercentUtilizationRange7 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange7.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange7.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 7 (101-150% of CIR).')
mfrapPerfCirRxPercentUtilizationRange8 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange8.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirRxPercentUtilizationRange8.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 8 (> 150% of CIR).')
mfrapPerfCirTxPercentUtilizationRange1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange1.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 1 (0% of CIR).')
mfrapPerfCirTxPercentUtilizationRange2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange2.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 2 (1-10% of CIR).')
mfrapPerfCirTxPercentUtilizationRange3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange3.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 3 (11-20% of CIR).')
mfrapPerfCirTxPercentUtilizationRange4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange4.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange4.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 4 (21-50% of CIR).')
mfrapPerfCirTxPercentUtilizationRange5 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange5.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange5.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 5 (51-80% of CIR).')
mfrapPerfCirTxPercentUtilizationRange6 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange6.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange6.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 6 (81-100% o0f CIR).')
mfrapPerfCirTxPercentUtilizationRange7 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange7.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange7.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 7 (101-150% of CIR).')
mfrapPerfCirTxPercentUtilizationRange8 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange8.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCirTxPercentUtilizationRange8.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 8 (> 150% of CIR).')
mfrapPerfCurrentPerDlciUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2), )
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationTable.setDescription('The current measurement of utilization as a percentage of CIR on each DLCI. Each short term statistics interval, the count of bytes transmitted and received is used to calculate the percentage of CIR used.')
mfrapPerfCurrentPerDlciUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapPerfCurrentPerDlciUtilizationDlciValue"))
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationEntry.setDescription('The utilization statistics for a particular DLCI.')
mfrapPerfCurrentPerDlciUtilizationDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciUtilizationDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
mfrapPerfCurrentPerDlciRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciRxUtilization.setDescription('The receive direction utilization as a percentage of CIR.')
mfrapPerfCurrentPerDlciTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciTxUtilization.setDescription('The transmit direction utilization as a percentage of CIR.')
mfrapPerfCurrentPerDlciAggregateUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciAggregateUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentPerDlciAggregateUtilization.setDescription('The aggregate utilization, the average of the receive and transmit utilization as a percentage of CIR.')
mfrapPerfCurrentUnitUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 3))
mfrapPerfCurrentDteUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentDteUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentDteUtilization.setDescription('The DTE interface utilization as a percentage of line rate.')
mfrapPerfCurrentWanUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentWanUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentWanUtilization.setDescription('The WAN interface utilization as a percentage of line rate.')
mfrapPerfCurrentAggregateUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 5, 6, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPerfCurrentAggregateUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPerfCurrentAggregateUtilization.setDescription('The aggregate utilization of the unit, the average of the DTE and WAN interface utilizations as a percentage of line rate.')
mfrapEventTrapLog = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 8, 10))
mfrapEventTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 10, 1), )
if mibBuilder.loadTexts: mfrapEventTrapLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogTable.setDescription('This table contains the Event/Trap log. The entries are indexed by sequence number.')
mfrapEventTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapEventTrapLogSeqNum"))
if mibBuilder.loadTexts: mfrapEventTrapLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogEntry.setDescription('The event record for a particular event.')
mfrapEventTrapLogSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogSeqNum.setDescription('The sequence number associated with an event record.')
mfrapEventTrapLogGenericEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogGenericEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogGenericEvent.setDescription('The SNMP generic trap or event number.')
mfrapEventTrapLogSpecificEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogSpecificEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogSpecificEvent.setDescription('The SNMP specific trap or event sub-identifier number.')
mfrapEventTrapLogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogTimeStamp.setDescription('The SNMP trap timestamp.')
mfrapEventTrapLogVarBind1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind1.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind1.setDescription('Variable Binding 1 for this SNMP Trap event.')
mfrapEventTrapLogVarBind2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind2.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind2.setDescription('Variable Binding 2 for this SNMP Trap event.')
mfrapEventTrapLogVarBind3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind3.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventTrapLogVarBind3.setDescription('Variable Binding 3 for this SNMP Trap event.')
mfrapEventLogAltTable = MibTable((1, 3, 6, 1, 4, 1, 485, 8, 10, 2), )
if mibBuilder.loadTexts: mfrapEventLogAltTable.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogAltTable.setDescription("This is an alternative method to access the database of the Event/Trap Log. The database is indexed by Sequence Number and Event/Trap log's are returned in an OCTETSTRING.")
mfrapEventLogAltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 8, 10, 2, 1), ).setIndexNames((0, "MFRAP-MIB", "mfrapEventLogAltSeqNum"))
if mibBuilder.loadTexts: mfrapEventLogAltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogAltEntry.setDescription('The Event/Trap Log for a particular sequence number.')
mfrapEventLogAltSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventLogAltSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogAltSeqNum.setDescription('The Sequence Number monitored for the Event Log')
mfrapEventLogAltArray = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 8, 10, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventLogAltArray.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogAltArray.setDescription('The Event / Trap log for the given sequence number.')
mfrapEventLogCurrentSeqNum = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapEventLogCurrentSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogCurrentSeqNum.setDescription('The current index into the Event Log Table.')
mfrapEventLogFreeze = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("freeze", 1), ("un-freeze", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapEventLogFreeze.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogFreeze.setDescription('This freezes the Event/Trap Log. freeze(1) will prevent Events / Traps from being entered into the database, un-freeze(2) will allow Events / Traps to be logged into the database. An event will be logged indicating a set of this entry')
mfrapEventLogClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mfrapEventLogClear.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapEventLogClear.setDescription('This clears the Event/Trap Log.')
mfrapAlarmType = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 75, 76, 90, 91, 92, 93, 94, 95, 96, 97, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 257, 258, 259, 260, 261, 262, 263, 264, 265))).clone(namedValues=NamedValues(("bad-config-in-set", 1), ("config-local-update", 2), ("t1-netw-carrier-loss", 3), ("t1-netw-carrier-detect", 4), ("t1-netw-sync-loss-declare", 5), ("t1-netw-sync-acquire", 6), ("t1-netw-red-alarm-declare", 7), ("t1-netw-red-alarm-clear", 8), ("t1-netw-yellow-alarm-detect", 9), ("t1-netw-yellow-alarm-clear", 10), ("t1-netw-ais-detect", 11), ("t1-netw-ais-clear", 12), ("t1-controlled-slip", 13), ("local-unit-loopback-enabled", 14), ("local-unit-loopback-disabled", 15), ("local-unit-loopback-failure", 16), ("local-dte-loopback-enabled", 17), ("local-dte-loopback-disabled", 18), ("local-dte-loopback-failure", 19), ("local-aggregate-loopback-enabled", 20), ("local-aggregate-loopback-disabled", 21), ("local-aggregate-loopback-failure", 22), ("local-payload-loopback-enabled", 23), ("local-payload-loopback-disabled", 24), ("local-payload-loopback-failure", 25), ("local-network-loopback-enabled", 26), ("local-network-loopback-disabled", 27), ("local-network-loopback-failure", 28), ("v54-loop-up-initiated", 29), ("v54-loop-down-completed", 30), ("v54-loopback-enabled-by-remote", 31), ("v54-loopback-disabled-by-remote", 32), ("v54-loopback-failure", 33), ("csu-loop-up-initiated", 34), ("csu-loop-down-completed", 35), ("csu-loopback-enabled-by-remote", 36), ("csu-loopback-disabled-by-remote", 37), ("csu-loopback-failure", 38), ("dsu-loop-up-initiated", 39), ("dsu-loop-down-completed", 40), ("dsu-loopback-enabled-by-remote", 41), ("dsu-loopback-disabled-by-remote", 42), ("dsu-loopback-failure", 43), ("bert-test-pattern-initiated", 44), ("bert-test-pattern-completed", 45), ("bert-test-pattern-failure", 46), ("dlci-active", 47), ("dlci-inactive", 48), ("dlci-td-threshold", 49), ("lmi-sourcing-change-passthru", 50), ("lmi-sourcing-change-user-dte", 51), ("lmi-sourcing-change-net-dte", 52), ("lmi-sourcing-change-user-net", 53), ("lmi-sourcing-change-net-net", 54), ("dte-signal-rts-on", 55), ("dte-signal-rts-off", 56), ("dte-signal-dtr-on", 57), ("dte-signal-dtr-off", 58), ("lmi-non-incr-seq-num-dte", 59), ("lmi-non-incr-seq-num-net", 60), ("lmi-seq-num-mismatch-dte", 61), ("lmi-seq-num-mismatch-net", 62), ("trap-muting-active", 75), ("trap-muting-inactive", 76), ("vloop-loop-up", 90), ("vloop-loop-down", 91), ("vloop-up-via-remote", 92), ("vloop-down-via-remote", 93), ("vloop-failed", 94), ("vbert-started", 95), ("vbert-stopped", 96), ("vbert-request-failed", 97), ("dandi-carrier-loss", 110), ("dandi-carrier-detect", 111), ("dandi-sync-loss-declare", 112), ("dandi-sync-acquire", 113), ("dandi-red-alarm-declare", 114), ("dandi-red-alarm-clear", 115), ("dandi-yellow-alarm-detect", 116), ("dandi-yellow-alarm-clear", 117), ("dandi-ais-detect", 118), ("dandi-ais-clear", 119), ("dandi-controlled-slip", 120), ("local-dandi-payload-loopback-enabled", 121), ("local-dandi-payload-loopback-disabled", 122), ("local-dandi-payload-loopback-failure", 123), ("local-dandi-line-loopback-enabled", 124), ("local-dandi-line-loopback-disabled", 125), ("local-dandi-line-loopback-failure", 126), ("nest-fan-one-alarm", 130), ("nest-fan-one-alarm-clear", 131), ("nest-fan-two-alarm", 132), ("nest-fan-two-alarm-clear", 133), ("nest-power-supply-alarm", 134), ("nest-power-supply-alarm-clear", 135), ("local-payload-loopback-via-rmt-enabled", 136), ("local-payload-loopback-via-rmt-disabled", 137), ("pvc-rx-utilization-exceeded", 138), ("pvc-tx-utilization-exceeded", 139), ("pvc-rx-utilization-cleared", 140), ("pvc-tx-utilization-cleared", 141), ("config-install-success", 142), ("tftp-requested", 257), ("tftp-transferring", 258), ("tftp-programming", 259), ("tftp-aborted", 260), ("tftp-success", 261), ("tftp-host-unreachable", 262), ("tftp-no-file", 263), ("tftp-invalid-file", 264), ("tftp-corrupt-file", 265)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapAlarmType.setDescription('The type of alarms that are generated on the node')
mfrapDLCINum = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapDLCINum.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapDLCINum.setDescription('The DLCI number for the DLCI active or inactive trap')
mfrapInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("t1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapInterface.setDescription('The interface most recently reported in a TRAP.')
mfrapIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapIpAddress.setDescription('The IP address most recently reported in a TRAP.')
mfrapPercentUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapPercentUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapPercentUtilization.setDescription('The percent utilization for a DLCI most recently reported in a TRAP.')
mfrapUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapUtilizationThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapUtilizationThreshold.setDescription('The percent utilization threshold for a DLCI most recently reported in a TRAP.')
mfrapCfgLockIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 8, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mfrapCfgLockIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mfrapCfgLockIpAddress.setDescription('The IP address of the management station locking the configuration most recently reported in a TRAP.')
mfrapTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,0)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTrap.setDescription('An mfrapTrap trap signifies that the sending node had its `mfrapAlarmType` variable modified.')
mfrapBadConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,1)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapBadConfigTrap.setDescription('Unit has received a configuration update request through SNMP but the request was rejected to due an incorrect or inappropriate parameter.')
mfrapLocalConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,2)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalConfigTrap.setDescription('Unit configuration has been updated locally (console port or front panel keypad) or remotely (telnet).')
mfrapt1netwcarrierloss = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,3)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwcarrierloss.setDescription('Unit is not detecting a signal from the wide area network.')
mfrapt1netwcarrierdetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,4)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwcarrierdetect.setDescription('Unit is detecting a signal from the wide area network.')
mfrapt1netwsynclossdeclare = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,5)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwsynclossdeclare.setDescription('Unit is not properly synchronized to the signal received from the wide area network. Frame synchronization is required for normal operation.')
mfrapt1netwsyncacquire = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,6)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwsyncacquire.setDescription('Unit is now synchronized with the signal received from the wide area network.')
mfrapt1netwredalarmdeclare = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,7)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwredalarmdeclare.setDescription('Unit has experienced loss of frame synchronization for an extended time and is reporting an alarm condition that severely impairs normal operation. During this Red Alarm condition the unit will transmit Yellow alarm back to the network. If this condition persists consult your service provider.')
mfrapt1netwredalarmclear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,8)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwredalarmclear.setDescription('Unit has achieved frame synchronization for a length of time necessary to declare the interface stable and operational.')
mfrapt1netwyellowalarmdetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,9)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwyellowalarmdetect.setDescription('Unit is receiving a yellow alarm indication from the wide area network. Detection of yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal. If this condition persists consult your service provider.')
mfrapt1netwyellowalarmclear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,10)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwyellowalarmclear.setDescription('Unit is no longer receiving a yellow alarm indication from the wide area network. Yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal.')
mfrapt1netwaisdetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,11)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwaisdetect.setDescription('Unit is receiving unframed all ones from the wide area network (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device. If this condition persists consult your service provider.')
mfrapt1netwaisclear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,12)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1netwaisclear.setDescription('Unit is no longer receiving unframed all ones from the wide area network (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device.')
mfrapt1controlledslip = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,13)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapt1controlledslip.setDescription('Unit is reporting an occurrence of a timing slip causing either the deletion or repetition of a block of data. This is indicative of a timing problem within the application. Check for multiple clock sources or the absence of a stable clock source.')
mfrapLocalUnitLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,14)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalUnitLoopbackEnabledTrap.setDescription('Unit is in a bidirectional unit loopback. Data is received from either interface, processed, and transmitted back towards the same interface. When configured for Frame Relay operation the unit will preserve the LMI path during this loopback. In Frame Relay mode, only valid frames are looped back (pseudorandom test patterns will be dropped).')
mfrapLocalUnitLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,15)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalUnitLoopbackDisabledTrap.setDescription('Bidirectional unit loopback path is removed.')
mfrapLocalUnitLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,16)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalUnitLoopbackFailedTrap.setDescription('Bidirectional unit loopback request has been rejected by the unit. Typically, this is due to the presence of another loopback condition.')
mfrapLocalDteLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,17)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDteLoopbackEnabledTrap.setDescription('Unit is in a bidirectional DTE loopback. All data received at the DTE interface is looped back regardless of format or content (line loopback). When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback. Data received from the WAN is processed and transmitted back out the WAN. In Frame Relay mode, on the WAN interface, only valid frames are looped back (pseudorandom test patterns will be dropped).')
mfrapLocalDteLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,18)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDteLoopbackDisabledTrap.setDescription('Bidirectional DTE loopback path is removed.')
mfrapLocalDteLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,19)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDteLoopbackFailedTrap.setDescription('Bidirectional DTE loopback request has been rejected by the unit. Typically, this is due to the presence of another loopback condition.')
mfrapLocalAggregateLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,20)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalAggregateLoopbackEnabledTrap.setDescription('Unit is in local aggregate loopback. All data received from the DTE is transmit to the WAN and also looped back towards the DTE at a point just prior to WAN transmission (digital loopback). When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback. In Frame Relay mode only valid frames are looped back (pseudorandom test patterns will be dropped).')
mfrapLocalAggregateLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,21)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalAggregateLoopbackDisabledTrap.setDescription('Local aggregate loopback path is removed.')
mfrapLocalAggregateLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,22)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalAggregateLoopbackFailedTrap.setDescription('Local aggregate loopback request has been rejected by the unit. Typically, this is due to the presence of another loopback condition.')
mfrapLocalPayloadLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,23)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalPayloadLoopbackEnabledTrap.setDescription('Unit is in payload loopback. All data received from the WAN, regardless of format or content, is processed at the physical layer before being reframed and transmit back out the WAN. All ones are sent to the DTE during this diagnostic state. When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback.')
mfrapLocalPayloadLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,24)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalPayloadLoopbackDisabledTrap.setDescription('Local payload loopback path is removed.')
mfrapLocalPayloadLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,25)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalPayloadLoopbackFailedTrap.setDescription('Local payload loopback request has been rejected. Typically, this is due to the presence of another loopback condition.')
mfrapLocalNetLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,26)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalNetLoopbackEnabledTrap.setDescription('Unit is in local network loopback. All data received from the WAN, regardless of format or content, is transmitted back out (line interface loopback) while still being sent to the DTE. When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback.')
mfrapLocalNetLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,27)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalNetLoopbackDisabledTrap.setDescription('Local network loopback path is removed.')
mfrapLocalNetLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,28)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalNetLoopbackFailedTrap.setDescription('Local network loopback request is rejected. Typically, this is due to the presence of another loopback condition.')
mfrapV54LoopUpInitiatedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,29)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapV54LoopUpInitiatedTrap.setDescription('Unit has sent the standard V54 loop up pattern out the WAN at the DTE rate. A compatible piece of equipment can sense this pattern and enter a loopback state - typically putting up a bidirectional DTE loopback path. After sending the V54 loop up pattern, the (local) unit returns to normal operation, expecting a loopback condition at the remote device.')
mfrapV54LoopDownCompletedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,30)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapV54LoopDownCompletedTrap.setDescription('Unit has sent the standard V54 loop down pattern out the WAN at the DTE rate. A compatible piece of equipment can sense this pattern remove the loopback state that is entered after receiving a loop up pattern - typically a bidirectional DTE loopback path. After sending the V54 loop down pattern, the unit returns to normal operation.')
mfrapV54LoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,31)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapV54LoopbackEnabledTrap.setDescription('Unit has received a V54 loop up pattern from a compatible piece of equipment. A bidirectional DTE loopback is activated. All data received at the DTE interface is looped back regardless of format or content. When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback. Data received from the WAN is processed and transmitted back out the WAN. In Frame Relay mode, on the WAN interface, only valid frames are looped back (pseudorandom test patterns will be dropped).')
mfrapV54LoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,32)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapV54LoopbackDisabledTrap.setDescription('Unit has received a V54 loop down pattern from a compatible piece of equipment. The bidirectional local DTE loopback is removed.')
mfrapV54LoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,33)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapV54LoopbackFailedTrap.setDescription('Unit has rejected the request to send a V54 loop up. Typically, this is due to the presence of another loopback condition.')
mfrapCsuLoopUpInitiatedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,34)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapCsuLoopUpInitiatedTrap.setDescription('Unit has sent a standard CSU loop up pattern at the full WAN rate. A compatible piece of equipment can sense this pattern and enter a loopback state - typically putting up a network line loopback. After sending the CSU loop up pattern, the (local) unit returns to normal operation, expecting a loopback condition at the attached device.')
mfrapCsuLoopDownCompletedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,35)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapCsuLoopDownCompletedTrap.setDescription('Unit has sent the standard CSU loop down pattern out the WAN at the full WAN rate. A compatible piece of equipment can sense this pattern and remove the loopback state that is entered after receiving a loop up pattern - typically a network line loopback. After sending the CSU loop down pattern, the unit returns to normal operation.')
mfrapCsuLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,36)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapCsuLoopbackEnabledTrap.setDescription('Unit has received a standard CSU loop up pattern and will enter a local network loopback state. All data received from the WAN, regardless of format or content, is transmitted back out (line interface loopback) while still being sent to the DTE. When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback.')
mfrapCsuLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,37)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapCsuLoopbackDisabledTrap.setDescription('Unit has received a standard CSU loop down pattern and will remove the local network loopback path.')
mfrapCsuLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,38)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapCsuLoopbackFailedTrap.setDescription('Unit has rejected the request to send a CSU loop up. Typically, this is due to the presence of another loopback condition.')
mfrapDsuLoopUpInitiatedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,39)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDsuLoopUpInitiatedTrap.setDescription('Unit has sent a proprietary DSU loop up pattern at the full WAN rate. A compatible piece of equipment can sense this pattern and enter a network line loopback state. After sending the DSU loop up pattern, the (local) unit returns to normal operation, expecting a loopback condition at the remote device.')
mfrapDsuLoopDownCompletedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,40)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDsuLoopDownCompletedTrap.setDescription('Unit has sent the proprietary DSU loop down pattern out the WAN at the full WAN rate. A compatible piece of equipment can sense this pattern and remove a network line loopback condition. After sending the DSU loop down pattern, the unit returns to normal operation.')
mfrapDsuLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,41)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDsuLoopbackEnabledTrap.setDescription('Unit has received a proprietary DSU loop up pattern and will enter a local network loopback state. All data received from the WAN, regardless of format or content, is transmitted back out (line interface loopback) while still being sent to the DTE. When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback.')
mfrapDsuLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,42)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDsuLoopbackDisabledTrap.setDescription('Unit has received a proprietary DSU loop down pattern and will remove the local network loopback path.')
mfrapDsuLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,43)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDsuLoopbackFailedTrap.setDescription('Unit has rejected the request to send a DSU loop up. Typically, this is due to the presence of another loopback condition.')
mfrapBertInitiatedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,44)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapBertInitiatedTrap.setDescription('Unit is sending a pseudorandom test pattern (511 or QRSS) out the WAN and monitoring the WAN received data for the same pattern. This test may be ineffective in certain frame relay applications as pseudorandom data lacks appropriate framing.')
mfrapBertCompletedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,45)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapBertCompletedTrap.setDescription('Unit has stopped sending a pseudorandom test pattern out the WAN.')
mfrapBertFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,46)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapBertFailedTrap.setDescription('Unit has rejected the request to enter a BERT test state. Typically, this is due to the presence of another diagnostic condition.')
mfrapDLCIActiveTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,47)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"))
if mibBuilder.loadTexts: mfrapDLCIActiveTrap.setDescription('Unit is reporting this DLCI as active and provisioned. An active DLCI is one that is explictly declared ACTIVE in an LMI Full Status Response (typically coming from a frame relay switch).')
mfrapDLCIInactiveTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,48)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"))
if mibBuilder.loadTexts: mfrapDLCIInactiveTrap.setDescription("Unit is reporting this DLCI as inactive. An inactive DLCI is determined inactive one of two ways: it is either explictly declared inactive in an LMI Full Status Response (typically coming from a frame relay switch) or a Full Status Response is not seen causing a Full Status Timer expiry. Having the unit's full status timer too low could result in the unit falsely declaring DLCIs inactive (then active again). This does not interfere with any data activity on the DLCI but could result in excessive traps.")
mfrapDLCITDThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,49)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapIpAddress"))
if mibBuilder.loadTexts: mfrapDLCITDThresholdTrap.setDescription('VNIP has measured a round-trip transit delay on this PVC to this peer which exceeds the user-defined threshold.')
mfrapLmiSourcingChangePassthruTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,50)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSourcingChangePassthruTrap.setDescription('Unit is not sourcing any LMI messages. If this state persists then LMI is up and the proper handshaking is occurring independent of the unit. This may also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
mfrapLmiSourcingChangeUserDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,51)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSourcingChangeUserDteTrap.setDescription('Unit is acting as a source of LMI Status Requests (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the DTE interface is configured as a Frame Relay DCE but a companion Frame Relay DTE device is not seen out the WAN. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
mfrapLmiSourcingChangeNetDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,52)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSourcingChangeNetDteTrap.setDescription('Unit is acting as a source of LMI Status Responses (Link Intergrity Verification, Keep Alive). If this state persists then the equpiment attached to the DTE interface is configured as a Frame Relay DTE but a companion Frame Relay DCE device is not seen out the WAN. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of external equipment.')
mfrapLmiSourcingChangeUserT1Trap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,53)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSourcingChangeUserT1Trap.setDescription('Unit is acting as a source of LMI Status Requests (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the WAN interface is configured as a Frame Relay DCE but a companion Frame Relay DTE device is not seen out the DTE interface. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
mfrapLmiSourcingChangeNetT1Trap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,54)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSourcingChangeNetT1Trap.setDescription('Unit is acting as a source of LMI Status Responses (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the WAN interface is configured as a Frame Relay DTE but a companion Frame Relay DCE device is not seen out the DTE interface. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
mfrapDteSignalRtsOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,55)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDteSignalRtsOnTrap.setDescription("Unit's DTE Request to Send (RTS) interface control signal is now active (on). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
mfrapDteSignalRtsOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,56)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDteSignalRtsOffTrap.setDescription("Unit's DTE Request to Send (RTS) interface control signal is now inactive (off). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
mfrapDteSignalDtrOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,57)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDteSignalDtrOnTrap.setDescription("Unit's DTE Data Terminal Ready (DTR) interface control signal is now active (on). This signal is presented by the external DTE device. The unit may be configured to ignore the state of this signal or to require it for data transmission.")
mfrapDteSignalDtrOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,58)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDteSignalDtrOffTrap.setDescription("Unit's DTE Data Terminal Ready (DTR) interface control signal is now inactive (off). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
mfrapNonIncrLmiSeqNumDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,59)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNonIncrLmiSeqNumDteTrap.setDescription("Unit has detected a non-incrementing LMI sequence number from the DTE. A Status Enquiry or Status Response message has been seen at the DTE interface. The Link Integrity information element's Send Sequence Number was not incremented or was incremented more than once since the last Send Sequence Number seen from the DTE interface.")
mfrapNonIncrLmiSeqNumT1Trap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,60)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNonIncrLmiSeqNumT1Trap.setDescription("Unit has detected a non-incrementing LMI sequence number from the WAN. A Status Enquiry or Status Response message has been seen at the WAN interface. The Link Integrity information element's Send Sequence Number was not incremented or was incremented more than once since the last Send Sequence Number seen from the WAN interface.")
mfrapLmiSeqNumMismatchDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,61)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSeqNumMismatchDteTrap.setDescription("Unit has detetcted an LMI sequence number mismatch from the DTE. A Status Enquiry or Status Response message has been seen at the DTE interface. The Link Inetgrity information element's Receive Sequence Number was not the most recent Send Sequence number sent from the WAN interface. ")
mfrapLmiSeqNumMismatchT1Trap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,62)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLmiSeqNumMismatchT1Trap.setDescription("Unit has detetcted an LMI sequence number mismatch from the WAN. A Status Enquiry or Status Response message has been seen at the WAN interface. The Link Inetgrity information element's Receive Sequence Number was not the most recent Send Sequence number sent from the DTE interface.")
mfrapTrapMutingActive = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,75)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTrapMutingActive.setDescription('Trap generation is muted.')
mfrapTrapMutingInactive = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,76)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTrapMutingInactive.setDescription('Trap generation is re-enabled (muting disabled).')
mfrapVloopUp = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,90)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVloopUp.setDescription('A Vnip PVC loopback (VLOOP) request has been sent to a remote device on this DLCI out this interface. The remote unit should respond by looping all data received on this PVC back towards the unit that initiated this request. A PVC running VLOOP will not be running any user data.')
mfrapVloopDown = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,91)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVloopDown.setDescription('A Vnip PVC loopback (VLOOP) disable request has been sent to a remote device on this DLCI out this interface. The remote unit should respond by tearing down the logical loop on this DLCI.')
mfrapVloopUpViaRemote = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,92)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVloopUpViaRemote.setDescription('A Vnip PVC loopback (VLOOP) request has been received from a remote device on this DLCI on this interface. The unit will respond by looping all data received on this PVC back out the interface towards the unit that initiated the request.')
mfrapVloopDownViaRemote = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,93)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVloopDownViaRemote.setDescription('A request to disable a Vnip PVC loopback (VLOOP) on this unit with the indicated DLCI and Interface has been received. Usually this disable request is from the remote device that requested the VLOOP, however the request may also be due to a local event such as expiration of a locally configured loopback timeout. The unit will respond by tearing down the logical loop on this DLCI.')
mfrapVloopRequestFailed = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,94)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVloopRequestFailed.setDescription('The request for a PVC loopback (VLOOP) has been rejected or did not complete.')
mfrapVbertStarted = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,95)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVbertStarted.setDescription('A Vnip PVC error rate test (VBERT) has been started on this DLCI out this interface to a remote device. The VBERT test data will be statistically multiplexed in with user data, management data, and networking data. The destination peer will echo this test data back to the source producing a full-duplex volume-based timed test.')
mfrapVbertStopped = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,96)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVbertStopped.setDescription('A Vnip PVC BERT (VBERT) has been stopped on this DLCI on this interface to a remote device.')
mfrapVbertRequestFailed = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,97)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapInterface"))
if mibBuilder.loadTexts: mfrapVbertRequestFailed.setDescription('The request for a PVC BERT (VBERT) on this DLCI on this interface has been rejected.')
mfrapDandiCarrierLoss = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,110)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiCarrierLoss.setDescription('Unit is not detecting a signal from the Drop & Insert port.')
mfrapDandiCarrierDetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,111)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiCarrierDetect.setDescription('Unit is not detecting a signal from the Drop & Insert port.')
mfrapDandiSyncLossDeclare = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,112)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiSyncLossDeclare.setDescription('Unit is not properly synchronized to the signal received from the Drop & Insert port. Frame synchronization is required for normal operation.')
mfrapDandiSyncAcquire = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,113)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiSyncAcquire.setDescription('Unit is now synchronized with the signal received from the Drop & Insert port.')
mfrapDandiRedAlarmDeclare = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,114)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiRedAlarmDeclare.setDescription('Unit has experienced loss of frame synchronization for an extended time and is reporting an alarm condition that severely impairs normal operation. During this Red Alarm condition the unit will transmit Yellow alarm back to the network. If this condition persists consult your service provider.')
mfrapDandiRedalArmclear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,115)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiRedalArmclear.setDescription('Unit has achieved frame synchronization for a length of time necessary to declare the interface stable and operational.')
mfrapDandiYellowAlarmDetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,116)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiYellowAlarmDetect.setDescription('Unit is receiving a yellow alarm indication from the Drop & Insert port. Detection of yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal. If this condition persists consult your service provider.')
mfrapDandiYellowAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,117)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiYellowAlarmClear.setDescription('Unit is no longer receiving a yellow alarm indication from the Drop & Insert port. Yellow alarm implies that the attached device is in a red alarm conditon. Red alarm is declared due to the extended absence of a properly framed signal.')
mfrapDandIaisDetect = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,118)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandIaisDetect.setDescription('Unit is receiving unframed all ones from the Drop & Insert port (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device. If this condition persists consult your service provider.')
mfrapDandiAisClear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,119)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiAisClear.setDescription('Unit is no longer receiving unframed all ones from the Drop & Insert port (AIS, blue alarm). Detection of AIS implies that the attached device is reporting an alarm condition from an upstream device.')
mfrapDandiControlledSlip = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,120)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapDandiControlledSlip.setDescription('Unit is reporting an occurrence of a timing slip causing either the deletion or repetition of a block of data. This is indicative of a timing problem within the application. Check for multiple clock sources or the absence of a stable clock source.')
mfrapLocalDandiPayloadLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,121)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiPayloadLoopbackEnabledTrap.setDescription('Unit is in local Drop & Insert payload loopback. All Drop & Insert data received from the WAN, regardless of format or content, is processed at the Drop & Insert line interface before being reframed and transmited back out the WAN. DTE data are unaffected.')
mfrapLocalDandiPayloadLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,122)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiPayloadLoopbackDisabledTrap.setDescription('Local Drop & Insert payload loopback path is removed.')
mfrapLocalDandiPayloadLoopbackFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,123)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiPayloadLoopbackFailureTrap.setDescription('Local Drop & Insert payload loopback request has been rejected. Typically, this is due to the presence of another loopback condition.')
mfrapLocalDandiLineLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,124)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiLineLoopbackEnabledTrap.setDescription('Unit is in local Drop & Insert line loopback. All data received from the Drop & Insert port, regardless of format or content, is transmitted back out (line interface loopback) while still being sent to the WAN. DTE data are unaffected.')
mfrapLocalDandiLineLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,125)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiLineLoopbackDisabledTrap.setDescription('Local Drop & Insert line loopback path is removed.')
mfrapLocalDandiLineLoopbackFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,126)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalDandiLineLoopbackFailureTrap.setDescription('Local Drop & Insert line loopback request is rejected. Typically, this is due to the presence of another loopback condition.')
mfrapNestFanOneAlarm = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,130)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestFanOneAlarm.setDescription('Unit has received an alarm signal from the nest that Fan 1 has malfunctioned.')
mfrapNestFanOneAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,131)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestFanOneAlarmClear.setDescription('The Fan 1 alarm signal from the nest has been cleared.')
mfrapNestFanTwoAlarm = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,132)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestFanTwoAlarm.setDescription('Unit has received an alarm signal from the nest that Fan 2 has malfunctioned.')
mfrapNestFanTwoAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,133)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestFanTwoAlarmClear.setDescription('The Fan 2 alarm signal from the nest has been cleared.')
mfrapNestPowerSupplyAlarm = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,134)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestPowerSupplyAlarm.setDescription('Unit has received an alarm signal from the nest that the power supply has malfunctioned.')
mfrapNestPowerSupplyAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,135)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapNestPowerSupplyAlarmClear.setDescription('The power supply alarm signal from the nest has been cleared.')
mfrapLocalPayloadLoopbackEnabledViaRemoteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,136)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalPayloadLoopbackEnabledViaRemoteTrap.setDescription('Local Payload loopback enabled Via Remote unit.')
mfrapLocalPayloadLoopbackDisabledViaRemoteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,137)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapLocalPayloadLoopbackDisabledViaRemoteTrap.setDescription('Local Payload loopback disabled Via Remote unit.')
mfrapPvcRxUtilizationExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,138)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapPercentUtilization"), ("MFRAP-MIB", "mfrapUtilizationThreshold"))
if mibBuilder.loadTexts: mfrapPvcRxUtilizationExceededTrap.setDescription('Percent utilization threshold was exceeded for the defined number of Short Term Intervals in the reception direction on this DLCI. ')
mfrapPvcTxUtilizationExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,139)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapPercentUtilization"), ("MFRAP-MIB", "mfrapUtilizationThreshold"))
if mibBuilder.loadTexts: mfrapPvcTxUtilizationExceededTrap.setDescription('Percent utilization threshold was exceeded for the defined number of Short Term Intervals in the transmission direction on this DLCI. ')
mfrapPvcRxUtilizationClearedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,140)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapPercentUtilization"), ("MFRAP-MIB", "mfrapUtilizationThreshold"))
if mibBuilder.loadTexts: mfrapPvcRxUtilizationClearedTrap.setDescription('Percent utilization was below the threshold for the defined number of Short Term Intervals in the reception direction on this DLCI. ')
mfrapPvcTxUtilizationClearedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,141)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapDLCINum"), ("MFRAP-MIB", "mfrapPercentUtilization"), ("MFRAP-MIB", "mfrapUtilizationThreshold"))
if mibBuilder.loadTexts: mfrapPvcTxUtilizationClearedTrap.setDescription('Percent utilization was below the threshold for the defined number of Short Term Intervals in the transmission direction on this DLCI. ')
mfrapConfigInstallSuccess = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,142)).setObjects(("MFRAP-MIB", "mfrapAlarmType"), ("MFRAP-MIB", "mfrapCfgLockIpAddress"))
if mibBuilder.loadTexts: mfrapConfigInstallSuccess.setDescription(' The configuration install process has successfully completed. ')
mfrapTftpRequestedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,257)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpRequestedTrap.setDescription("Unit has received a TFTP download request. TFTP is the preferred method for upgrading a unit's software image.")
mfrapTftpTransferringTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,258)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpTransferringTrap.setDescription('Unit has established a TFTP session, found the file, and begun the transfer. The file must still be qualified as appropriate for this unit.')
mfrapTftpProgrammingTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,259)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpProgrammingTrap.setDescription('Unit has completed the TFTP transfer of a new software image which will next be programmed into non-volatile flash memory.')
mfrapTftpAbortedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,260)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpAbortedTrap.setDescription("Unit's TFTP session was established but the transfer was aborted by user intervention or an unrecoverable TFTP protocol error.")
mfrapTftpSuccessTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,261)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpSuccessTrap.setDescription("Unit's TFTP download completed successfully. Flash devices will be programmed with a new image. Unit will stop passing data during the programming phase (less than a minute) and, upon completion, will reset and return to full operation using the new image.")
mfrapTftpHostUnreachableTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,262)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpHostUnreachableTrap.setDescription('Unit could not establish a TFTP session with the designated server. Verify that the correct TFTP ip address, TFTP DLCI and TFTP interface are configured on the unit and also verify the TFTP server confguration.')
mfrapTftpNoFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,263)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpNoFileTrap.setDescription('Unit could not locate the designated file on the TFTP server. Verify the correct TFTP filename is configured on the unit and verify the location of this file on the server (file name may be case sensitive).')
mfrapTftpInvalidFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,264)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpInvalidFileTrap.setDescription('Unit had established a TFTP session and began transfer of the designated file. The unit aborted the transfer after determining that the specified file is not appropriate for this product (failed header verification).')
mfrapTftpCorruptFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 8) + (0,265)).setObjects(("MFRAP-MIB", "mfrapAlarmType"))
if mibBuilder.loadTexts: mfrapTftpCorruptFileTrap.setDescription('Unit transferred the designated file but aborted the operation due to a checksum error within the downloaded s-record file.')
mibBuilder.exportSymbols("MFRAP-MIB", mfrapLocalDteLoopbackFailedTrap=mfrapLocalDteLoopbackFailedTrap, mfrapVnipTopoTDMaxDelay=mfrapVnipTopoTDMaxDelay, mfrapPerfArpTotalTxInarpRep=mfrapPerfArpTotalTxInarpRep, mfrapCfgFrPerfUserProtocolsTable=mfrapCfgFrPerfUserProtocolsTable, mfrapPerfApplicationPerDlciRxHttp=mfrapPerfApplicationPerDlciRxHttp, mfrapDandiCurrentEntry=mfrapDandiCurrentEntry, mfrapPerfIpPerDlciTxTcp=mfrapPerfIpPerDlciTxTcp, mfrapLocalPayloadLoopbackEnabledTrap=mfrapLocalPayloadLoopbackEnabledTrap, mfrapPerfPhysicalIntf=mfrapPerfPhysicalIntf, mfrapPerfLmiPerDlciRxLivoStatByteCnt=mfrapPerfLmiPerDlciRxLivoStatByteCnt, mfrapPerfThruputPerDlciCreateTime=mfrapPerfThruputPerDlciCreateTime, mfrapPerfNetwProtoPerDlciTxSna=mfrapPerfNetwProtoPerDlciTxSna, mfrapPerfIpxPerDlciRxTotal=mfrapPerfIpxPerDlciRxTotal, mfrapPerfNetwProtoPerDlciRxSna=mfrapPerfNetwProtoPerDlciRxSna, mfrapPerfLmiTotalTxLivoEnqByteCnt=mfrapPerfLmiTotalTxLivoEnqByteCnt, mfrapSysSelDTESupported=mfrapSysSelDTESupported, mfrapDandiCurrentSEFSs=mfrapDandiCurrentSEFSs, mfrapPerfThruputCmdClearDteStats=mfrapPerfThruputCmdClearDteStats, mfrapDiagDteTimeRemaining=mfrapDiagDteTimeRemaining, mfrapDandiIntervalNumber=mfrapDandiIntervalNumber, mfrapCfgFrPerfLTProtocolFilterTable=mfrapCfgFrPerfLTProtocolFilterTable, mfrapCfgFrPerfDlciUtilDuration=mfrapCfgFrPerfDlciUtilDuration, mfrapCfgEditConnDestDs0=mfrapCfgEditConnDestDs0, mfrapPerfIcmpPerDlciTxGmQuery=mfrapPerfIcmpPerDlciTxGmQuery, mfrapVnipTopologyNumHops=mfrapVnipTopologyNumHops, mfrapPerfIcmpPerDlciTable=mfrapPerfIcmpPerDlciTable, mfrapPerfIpPerDlciRxUdp=mfrapPerfIpPerDlciRxUdp, mfrapPerfArpPerDlciRxInarpReq=mfrapPerfArpPerDlciRxInarpReq, mfrapCfgCommModeAutoDetect=mfrapCfgCommModeAutoDetect, mfrapCfgEditLastSetStatus=mfrapCfgEditLastSetStatus, mfrapNestPowerSupplyAlarmClear=mfrapNestPowerSupplyAlarmClear, mfrapPerfIcmpPerDlciRxRedirect=mfrapPerfIcmpPerDlciRxRedirect, mfrapPerfThruputPerDlciRxDe=mfrapPerfThruputPerDlciRxDe, mfrapPerfIcmpTotalTxTimestpRep=mfrapPerfIcmpTotalTxTimestpRep, mfrapPerfArpPerDlciTxArpRep=mfrapPerfArpPerDlciTxArpRep, mfrapPerfIcmpPerDlciRxDestUnr=mfrapPerfIcmpPerDlciRxDestUnr, mfrapPerfArpTotalRxArpReq=mfrapPerfArpTotalRxArpReq, mfrapSysNumSnmpMgrs=mfrapSysNumSnmpMgrs, mfrapPerfNetwProtoPerDlciTxArp=mfrapPerfNetwProtoPerDlciTxArp, mfrapPerfIpxPerDlciTxNcp=mfrapPerfIpxPerDlciTxNcp, mfrapStatusNestFanTwo=mfrapStatusNestFanTwo, mfrapStatusMgmtDefaultDLCIStatus=mfrapStatusMgmtDefaultDLCIStatus, mfrapPerfApplicationTotalInterval=mfrapPerfApplicationTotalInterval, mfrapSysBootRev=mfrapSysBootRev, mfrapPerfT1TotalTable=mfrapPerfT1TotalTable, mfrapPerfLmiTotalDlciValue=mfrapPerfLmiTotalDlciValue, mfrapSysType=mfrapSysType, mfrapPerfIpTotalTxTcp=mfrapPerfIpTotalTxTcp, mfrapPerfCirPercentUtilizationTable=mfrapPerfCirPercentUtilizationTable, mfrapPerfRoutingTotalEntry=mfrapPerfRoutingTotalEntry, mfrapDsuLoopDownCompletedTrap=mfrapDsuLoopDownCompletedTrap, mfrapPerfNetwProtoPerDlciValue=mfrapPerfNetwProtoPerDlciValue, mfrapPerfThruputPerDlciValue=mfrapPerfThruputPerDlciValue, mfrapPerfMgmtIpIPInAddrErr=mfrapPerfMgmtIpIPInAddrErr, mfrapCfgTransitDelayDlciValue=mfrapCfgTransitDelayDlciValue, mfrapPerfIcmpTotalRxPktTooBig=mfrapPerfIcmpTotalRxPktTooBig, mfrapEventLogCurrentSeqNum=mfrapEventLogCurrentSeqNum, mfrapVnipTopoVBertTxDESetFrames=mfrapVnipTopoVBertTxDESetFrames, mfrapPerfRoutingTotalTable=mfrapPerfRoutingTotalTable, mfrapPerfSnaPerDlciRxSubarea=mfrapPerfSnaPerDlciRxSubarea, mfrapCfgIpMask=mfrapCfgIpMask, mfrapPerfApplicationPerDlciRxCustom2=mfrapPerfApplicationPerDlciRxCustom2, mfrapPerfIcmpPerDlciTxGmReduct=mfrapPerfIcmpPerDlciTxGmReduct, mfrapDandiTotalESs=mfrapDandiTotalESs, mfrapNestPowerSupplyAlarm=mfrapNestPowerSupplyAlarm, mfrapCfgTDDeleteDlciValue=mfrapCfgTDDeleteDlciValue, mfrapPerfNetwProtoTotalTxArp=mfrapPerfNetwProtoTotalTxArp, mfrapVnipTopologyInterface=mfrapVnipTopologyInterface, mfrapPerfIcmpTotalRxTimestpReq=mfrapPerfIcmpTotalRxTimestpReq, mfrapCfgCurrentConnSrcDs0=mfrapCfgCurrentConnSrcDs0, mfrapCfgTransitDelayThreshold=mfrapCfgTransitDelayThreshold, mfrapCfgDteConnDensity=mfrapCfgDteConnDensity, mfrapStatusDandiTable=mfrapStatusDandiTable, mfrapAlarmType=mfrapAlarmType, mfrapPerfApplicationTotalRxCustom2=mfrapPerfApplicationTotalRxCustom2, mfrapPvcTxUtilizationExceededTrap=mfrapPvcTxUtilizationExceededTrap, mfrapCfgFrPerfDlciNamesCirType=mfrapCfgFrPerfDlciNamesCirType, mfrapCfgFrPerfDlciNamesCirValue=mfrapCfgFrPerfDlciNamesCirValue, mfrapLmiSourcing=mfrapLmiSourcing, mfrapPerfIcmpPerDlciTxTimeExcd=mfrapPerfIcmpPerDlciTxTimeExcd, mfrapPerfArpPerDlciTxOther=mfrapPerfArpPerDlciTxOther, mfrapStatusLmiAutosense=mfrapStatusLmiAutosense, mfrapPerfThruputPerDlciEncapType=mfrapPerfThruputPerDlciEncapType, mfrapDandiIntervalESs=mfrapDandiIntervalESs, mfrapPerfSnaTotalInterval=mfrapPerfSnaTotalInterval, mfrapVnipTopoVBertTransitDelayAvg=mfrapVnipTopoVBertTransitDelayAvg, mfrapEventLogFreeze=mfrapEventLogFreeze, mfrapCfgDteClockMode=mfrapCfgDteClockMode, mfrapPerfIcmpPerDlciTxEchoReq=mfrapPerfIcmpPerDlciTxEchoReq, mfrapSysTable=mfrapSysTable, mfrapPerfMgmtIpICMPOutParmProbs=mfrapPerfMgmtIpICMPOutParmProbs, mfrapPerfNetwProtoTotalTxAnnexG=mfrapPerfNetwProtoTotalTxAnnexG, mfrapPerfCurrentUnitUtilization=mfrapPerfCurrentUnitUtilization, mfrapSysBRISupported=mfrapSysBRISupported, mfrapPerfApplicationTotalTxCustom2=mfrapPerfApplicationTotalTxCustom2, mfrapVnipTopoVLOOPStatus=mfrapVnipTopoVLOOPStatus, mfrapCfgConnectionTable=mfrapCfgConnectionTable, mfrapCfgVnipTransitDelayFrequency=mfrapCfgVnipTransitDelayFrequency, mfrapLmiSourcingChangeUserDteTrap=mfrapLmiSourcingChangeUserDteTrap, mfrapLocalDteLoopbackDisabledTrap=mfrapLocalDteLoopbackDisabledTrap, mfrapCfgFrPerfLTDlciFilterTable=mfrapCfgFrPerfLTDlciFilterTable, mfrapT1CurrentCrc6Events=mfrapT1CurrentCrc6Events, mfrapPerfApplicationPerDlciRxTftp=mfrapPerfApplicationPerDlciRxTftp, mfrapPerfRoutingPerDlciTxNetbios=mfrapPerfRoutingPerDlciTxNetbios, mfrapDiagVnipInterface=mfrapDiagVnipInterface, mfrapLmiSeqNumMismatchT1Trap=mfrapLmiSeqNumMismatchT1Trap, mfrapCfgEditConnStatus=mfrapCfgEditConnStatus, mfrapCfgCommStopBits=mfrapCfgCommStopBits, mfrapPerfThruputPerDlciRxUtilizationStatus=mfrapPerfThruputPerDlciRxUtilizationStatus, mfrapCfgFrDLCIValue=mfrapCfgFrDLCIValue, mfrapPerfSnaTotalEntry=mfrapPerfSnaTotalEntry, mfrapSysContact=mfrapSysContact, mfrapCfgDteChannelDensity=mfrapCfgDteChannelDensity, mfrapCfgCurrentConnSrcPort=mfrapCfgCurrentConnSrcPort, mfrapPerfIpxPerDlciInterval=mfrapPerfIpxPerDlciInterval, mfrapConfiguration=mfrapConfiguration, mfrapCfgFrPerfLTProtocolFilterTableClear=mfrapCfgFrPerfLTProtocolFilterTableClear, mfrapCfgAppTable=mfrapCfgAppTable, mfrapPerfArpPerDlciTable=mfrapPerfArpPerDlciTable, mfrapPerfIcmpPerDlciTxParamProb=mfrapPerfIcmpPerDlciTxParamProb, mfrapDiagVBERTTestPeriod=mfrapDiagVBERTTestPeriod, mfrapTftpTransferringTrap=mfrapTftpTransferringTrap, mfrapStatusDteTxLED=mfrapStatusDteTxLED, mfrapPerfIcmpPerDlciRxGmReduct=mfrapPerfIcmpPerDlciRxGmReduct, mfrapCfgFrDLCIMgmtDE=mfrapCfgFrDLCIMgmtDE, mfrapPerfMgmtIpICMPOutRedirects=mfrapPerfMgmtIpICMPOutRedirects, mfrapPerfNetwProtoTotalRxIpx=mfrapPerfNetwProtoTotalRxIpx, mfrapStatusDandiStatus=mfrapStatusDandiStatus, mfrapPerfIcmpTotalRxRedirect=mfrapPerfIcmpTotalRxRedirect, mfrapDLCIActiveTrap=mfrapDLCIActiveTrap, mfrapDLCINum=mfrapDLCINum, mfrapPerfThruput=mfrapPerfThruput, mfrapCfgFrPerfDlciNamesTableClear=mfrapCfgFrPerfDlciNamesTableClear, mfrapPerfThruputPerIntfEntry=mfrapPerfThruputPerIntfEntry, mfrapPerfThruputPerIntfTxFrameCnt=mfrapPerfThruputPerIntfTxFrameCnt, mfrapPerfIcmpTotalRxGmQuery=mfrapPerfIcmpTotalRxGmQuery, mfrapPerfMgmtIpICMPInParmProbs=mfrapPerfMgmtIpICMPInParmProbs, mfrapDsuLoopbackDisabledTrap=mfrapDsuLoopbackDisabledTrap, mfrapVnipTopologyIpAddr=mfrapVnipTopologyIpAddr, mfrapPerfArpTotalRxInarpReq=mfrapPerfArpTotalRxInarpReq, mfrapPerfNetwProtoPerDlciEntry=mfrapPerfNetwProtoPerDlciEntry, mfrapPerfNetwProtoTotalTxSna=mfrapPerfNetwProtoTotalTxSna, mfrapV54LoopUpInitiatedTrap=mfrapV54LoopUpInitiatedTrap, mfrapCfgDandiLineEncoding=mfrapCfgDandiLineEncoding, mfrapPerfThruputPerDlciRxByte=mfrapPerfThruputPerDlciRxByte, mfrapCfgVnipKeepAliveTimer=mfrapCfgVnipKeepAliveTimer, mfrapPerfArpTotalRxTotal=mfrapPerfArpTotalRxTotal, mfrapDiagDandiLocPylLpbk=mfrapDiagDandiLocPylLpbk, mfrapStatusNestFanOne=mfrapStatusNestFanOne, mfrapPerfIpPerDlciTxUdp=mfrapPerfIpPerDlciTxUdp, mfrapPerfIcmpPerDlciRxGmReport=mfrapPerfIcmpPerDlciRxGmReport, mfrapCfgTDDeleteTable=mfrapCfgTDDeleteTable, mfrapDiagVBERTRate=mfrapDiagVBERTRate, mfrapDandiTotalBESs=mfrapDandiTotalBESs, mfrapLocalPayloadLoopbackEnabledViaRemoteTrap=mfrapLocalPayloadLoopbackEnabledViaRemoteTrap, mfrapPerfIcmpTotalRxEchoRep=mfrapPerfIcmpTotalRxEchoRep, mfrapPerfApplicationPerDlciRxCustom4=mfrapPerfApplicationPerDlciRxCustom4, mfrapPerfIcmpTotalRxParamProb=mfrapPerfIcmpTotalRxParamProb, mfrapPerfSnaTotalTable=mfrapPerfSnaTotalTable, mfrapDandiTotalSEFSs=mfrapDandiTotalSEFSs, mfrapCfgSnmpMgrIP=mfrapCfgSnmpMgrIP, mfrapCfgCommTable=mfrapCfgCommTable, mfrapPerfApplicationPerDlciTxCustom2=mfrapPerfApplicationPerDlciTxCustom2, mfrapPerfIpPerDlciRxIgrp=mfrapPerfIpPerDlciRxIgrp, mfrapCfgIpTelnetEnable=mfrapCfgIpTelnetEnable, mfrapPerfThruputCmdClearAllIntfStats=mfrapPerfThruputCmdClearAllIntfStats, mfrapPerfArpPerDlciRxTotal=mfrapPerfArpPerDlciRxTotal, mfrapPerfApplicationPerDlciTxCustom1=mfrapPerfApplicationPerDlciTxCustom1, mfrapSysNumMaintInstalled=mfrapSysNumMaintInstalled, mfrapPerfApplicationTotalRxTftp=mfrapPerfApplicationTotalRxTftp, mfrapPerfMgmtIpIFInErrors=mfrapPerfMgmtIpIFInErrors, mfrapT1TotalLCVs=mfrapT1TotalLCVs, mfrapPerfNetwProtoPerDlciRxOther=mfrapPerfNetwProtoPerDlciRxOther, mfrapCfgFrDLCIMode=mfrapCfgFrDLCIMode, mfrapPerfApplicationPerDlciTxSnmp=mfrapPerfApplicationPerDlciTxSnmp, mfrapCfgTftpStatus=mfrapCfgTftpStatus, mfrapPerfArpPerDlciRxInarpRep=mfrapPerfArpPerDlciRxInarpRep, mfrapPerfCirRxPercentUtilizationRange5=mfrapPerfCirRxPercentUtilizationRange5, mfrapt1netwaisclear=mfrapt1netwaisclear, mfrapPerfSnaPerDlciInterval=mfrapPerfSnaPerDlciInterval, mfrapStatusDteModeLED=mfrapStatusDteModeLED, mfrapDandiIntervalEntry=mfrapDandiIntervalEntry, mfrapDiagT1TimeRemaining=mfrapDiagT1TimeRemaining, mfrapPerfThruputPerDlciEIR=mfrapPerfThruputPerDlciEIR, mfrapDiagVLOOP=mfrapDiagVLOOP, mfrapDandiCurrentIndex=mfrapDandiCurrentIndex, mfrapCfgFrPerfTimersLTInterval=mfrapCfgFrPerfTimersLTInterval, mfrapPerfIpPerDlciRxTcp=mfrapPerfIpPerDlciRxTcp, mfrapPerfLmiTotalInterval=mfrapPerfLmiTotalInterval, mfrapPerfLmiTotalTxFullEnqByteCnt=mfrapPerfLmiTotalTxFullEnqByteCnt, mfrapCfgDteDtr=mfrapCfgDteDtr, mfrapStatusDandiStatusLED=mfrapStatusDandiStatusLED, mfrapDsuLoopUpInitiatedTrap=mfrapDsuLoopUpInitiatedTrap, mfrapCfgAppClockSource=mfrapCfgAppClockSource, mfrapPerfArpTotalTxOther=mfrapPerfArpTotalTxOther, mfrapPerfIpxTotalRxTotal=mfrapPerfIpxTotalRxTotal, mfrapCfgDteLineRate=mfrapCfgDteLineRate, mfrapCfgVnipInactivityTimer=mfrapCfgVnipInactivityTimer, mfrapPerfSnaPerDlciTxTotal=mfrapPerfSnaPerDlciTxTotal, mfrapUtilizationThreshold=mfrapUtilizationThreshold, mfrapDandiPerfCmdTypeTable=mfrapDandiPerfCmdTypeTable, mfrapPerfThruputCmdClearDlciStats=mfrapPerfThruputCmdClearDlciStats, mfrapPerfLmiTotalRxFullStatByteCnt=mfrapPerfLmiTotalRxFullStatByteCnt, mfrapVnipTopologyEntry=mfrapVnipTopologyEntry, mfrapCfgSnmpTrapMuting=mfrapCfgSnmpTrapMuting, mfrapPerfNetwProtoTotalInterval=mfrapPerfNetwProtoTotalInterval, mfrapPerfThruputPerDlciEntry=mfrapPerfThruputPerDlciEntry, mfrapSysName=mfrapSysName, mfrapCfgEditConnType=mfrapCfgEditConnType, mfrapPerfNetwProtoPerDlciTable=mfrapPerfNetwProtoPerDlciTable, mfrapCfgDteDataMode=mfrapCfgDteDataMode, mfrapPerfCirPercentUtilizationDlciValue=mfrapPerfCirPercentUtilizationDlciValue, mfrapCfgSnmpDandIPortTrapEnable=mfrapCfgSnmpDandIPortTrapEnable, mfrapPerfMgmtIpICMPInTimeExcds=mfrapPerfMgmtIpICMPInTimeExcds, mfrapInterface=mfrapInterface, mfrapEventTrapLogSeqNum=mfrapEventTrapLogSeqNum, mfrapPerfNetwProtoTotalTxVnip=mfrapPerfNetwProtoTotalTxVnip, mfrapPerfIpxPerDlciRxRip=mfrapPerfIpxPerDlciRxRip, mfrapPerfArpPerDlciTxRarpReq=mfrapPerfArpPerDlciTxRarpReq, mfrapLocalUnitLoopbackEnabledTrap=mfrapLocalUnitLoopbackEnabledTrap, mfrapCfgCurrentConnTable=mfrapCfgCurrentConnTable, mfrapCfgSnmpMgrEntry=mfrapCfgSnmpMgrEntry, mfrapPerfNetwProtoTotalTxIp=mfrapPerfNetwProtoTotalTxIp, mfrapVloopUp=mfrapVloopUp, mfrapPerfLmiTotalTable=mfrapPerfLmiTotalTable, mfrapCfgDteConnStatus=mfrapCfgDteConnStatus, mfrapDiagBertErrors=mfrapDiagBertErrors, mfrapPerfMgmtIpICMPStatsTable=mfrapPerfMgmtIpICMPStatsTable, mfrapPerfIcmpPerDlciRxTimestpRep=mfrapPerfIcmpPerDlciRxTimestpRep, mfrapDiagBertPattern=mfrapDiagBertPattern, mfrapPerfRoutingTotalTxRip=mfrapPerfRoutingTotalTxRip, mfrapCfgSnmpTable=mfrapCfgSnmpTable, mfrapPerfCurrentWanUtilization=mfrapPerfCurrentWanUtilization, mfrapPerfArpPerDlciValue=mfrapPerfArpPerDlciValue, mfrapCfgTDDeleteInterface=mfrapCfgTDDeleteInterface, mfrapPerfThruputPerDlciMTTSR=mfrapPerfThruputPerDlciMTTSR, mfrapPerfSnaPerDlciRxOther=mfrapPerfSnaPerDlciRxOther, mfrapCsuLoopbackDisabledTrap=mfrapCsuLoopbackDisabledTrap, mfrapCfgAppLpbkTimeout=mfrapCfgAppLpbkTimeout, mfrapPerfSnaPerDlciTxOther=mfrapPerfSnaPerDlciTxOther, mfrapTftpHostUnreachableTrap=mfrapTftpHostUnreachableTrap, mfrapCsuLoopDownCompletedTrap=mfrapCsuLoopDownCompletedTrap, mfrapPerfIcmpTotalTxParamProb=mfrapPerfIcmpTotalTxParamProb, mfrapPerfApplicationPerDlciRxFtp=mfrapPerfApplicationPerDlciRxFtp, mfrapPerfMgmtIpICMPInRedirects=mfrapPerfMgmtIpICMPInRedirects, mfrapT1TotalCSSs=mfrapT1TotalCSSs, mfrapPerfMgmtIpICMPInErrors=mfrapPerfMgmtIpICMPInErrors, mfrapStatusDteDtr=mfrapStatusDteDtr, mfrapT1TotalIndex=mfrapT1TotalIndex, mfrapPerfMgmtIpTCPAttemptFails=mfrapPerfMgmtIpTCPAttemptFails, mfrapDiagVnipIpAddr=mfrapDiagVnipIpAddr, mfrapCfgSnmpFrTrap=mfrapCfgSnmpFrTrap, mfrapCfgFrPerfUserProtocolsIndex=mfrapCfgFrPerfUserProtocolsIndex, mfrapPerfMgmtIpICMPOutEchoReps=mfrapPerfMgmtIpICMPOutEchoReps)
mibBuilder.exportSymbols("MFRAP-MIB", mfrapPerfThruputPerIntfTxByteCnt=mfrapPerfThruputPerIntfTxByteCnt, mfrapPerfSnaPerDlciRxTotal=mfrapPerfSnaPerDlciRxTotal, mfrap=mfrap, mfrapPerfIpxTotalRxNcp=mfrapPerfIpxTotalRxNcp, mfrapPerfIpxTotalTxSap=mfrapPerfIpxTotalTxSap, mfrapEventTrapLogSpecificEvent=mfrapEventTrapLogSpecificEvent, mfrapPerfLmiTotalTxOtherByteCnt=mfrapPerfLmiTotalTxOtherByteCnt, mfrapPerfT1IntervalTable=mfrapPerfT1IntervalTable, mfrapPerfIpxPerDlciRxSpx=mfrapPerfIpxPerDlciRxSpx, mfrapVnipTopoVBertTxDEClrFrames=mfrapVnipTopoVBertTxDEClrFrames, mfrapPerfNetwProtoPerDlciTxIpx=mfrapPerfNetwProtoPerDlciTxIpx, mfrapDandiTotalEntry=mfrapDandiTotalEntry, mfrapCfgVnipInitTimer=mfrapCfgVnipInitTimer, mfrapPerfMgmtIpIFStatsTable=mfrapPerfMgmtIpIFStatsTable, mfrapPerfIpTotalRxIgrp=mfrapPerfIpTotalRxIgrp, mfrapDiagVBERTSize=mfrapDiagVBERTSize, mfrapPerfNetwProtoTotalTxIpx=mfrapPerfNetwProtoTotalTxIpx, mfrapPerfThruputPerIntfIndex=mfrapPerfThruputPerIntfIndex, mfrapPerfSnaPerDlciTxPeriph=mfrapPerfSnaPerDlciTxPeriph, mfrapPercentUtilization=mfrapPercentUtilization, mfrapCfgFrPerfDlciNamesDlciName=mfrapCfgFrPerfDlciNamesDlciName, mfrapPerfRoutingPerDlciTable=mfrapPerfRoutingPerDlciTable, mfrapPerfMgmtIpIPInRcv=mfrapPerfMgmtIpIPInRcv, mfrapPerfIcmpPerDlciValue=mfrapPerfIcmpPerDlciValue, mfrapPerfSnaTotalTxNetbios=mfrapPerfSnaTotalTxNetbios, mfrapPerfApplicationTotalRxFtp=mfrapPerfApplicationTotalRxFtp, mfrapDandiControlledSlip=mfrapDandiControlledSlip, mfrapCfgSnmpMgrClearN=mfrapCfgSnmpMgrClearN, mfrapCfgFrPerfUserProtocolsEntry=mfrapCfgFrPerfUserProtocolsEntry, mfrapPerfApplicationTotalRxCustom4=mfrapPerfApplicationTotalRxCustom4, mfrapPerfLmiPerDlciTxOtherByteCnt=mfrapPerfLmiPerDlciTxOtherByteCnt, mfrapDiagBertStatus=mfrapDiagBertStatus, mfrapPerfIcmpPerDlciInterval=mfrapPerfIcmpPerDlciInterval, mfrapStatusDteCts=mfrapStatusDteCts, mfrapPerfMgmtIpTCPPassiveOpens=mfrapPerfMgmtIpTCPPassiveOpens, Index=Index, mfrapCfgFrLmiInactivityTimeout=mfrapCfgFrLmiInactivityTimeout, mfrapPerfThruputPerDlciTxDe=mfrapPerfThruputPerDlciTxDe, mfrapDandiCurrentOofEvents=mfrapDandiCurrentOofEvents, mfrapSysNumDteInstalled=mfrapSysNumDteInstalled, mfrapPerfNetwProtoPerDlciRxArp=mfrapPerfNetwProtoPerDlciRxArp, mfrapPerfIcmpPerDlciRxAddrMaskReq=mfrapPerfIcmpPerDlciRxAddrMaskReq, mfrapPerfLmiTotalTxFullStatByteCnt=mfrapPerfLmiTotalTxFullStatByteCnt, mfrapTftpCorruptFileTrap=mfrapTftpCorruptFileTrap, mfrapDLCITDThresholdTrap=mfrapDLCITDThresholdTrap, mfrapLocalAggregateLoopbackEnabledTrap=mfrapLocalAggregateLoopbackEnabledTrap, mfrapNestFanOneAlarm=mfrapNestFanOneAlarm, mfrapVloopDown=mfrapVloopDown, mfrapVnipTopoVBertTimeElapse=mfrapVnipTopoVBertTimeElapse, mfrapPerfThruputCmdAllStsDlciResetAll=mfrapPerfThruputCmdAllStsDlciResetAll, mfrapBadConfigTrap=mfrapBadConfigTrap, mfrapCfgTftpPassword=mfrapCfgTftpPassword, mfrapPerfThruputCmdReplaceDlciValue=mfrapPerfThruputCmdReplaceDlciValue, mfrapDandiIntervalCSSs=mfrapDandiIntervalCSSs, mfrapPerfSnaPerDlciRxPeriph=mfrapPerfSnaPerDlciRxPeriph, mfrapSysLocation=mfrapSysLocation, mfrapCfgUpdate=mfrapCfgUpdate, mfrapCfgFrAddrResMode=mfrapCfgFrAddrResMode, mfrapPerfDandiTotalTable=mfrapPerfDandiTotalTable, mfrapPerfMgmtIpICMPInEchoReps=mfrapPerfMgmtIpICMPInEchoReps, mfrapCfgLockID=mfrapCfgLockID, private=private, mfrapStatusMgmtTable=mfrapStatusMgmtTable, mfrapPerfApplicationPerDlciInterval=mfrapPerfApplicationPerDlciInterval, mfrapPerfLmiPerDlciRxFullEnqByteCnt=mfrapPerfLmiPerDlciRxFullEnqByteCnt, mfrapPerfApplicationTotalTxCustom1=mfrapPerfApplicationTotalTxCustom1, mfrapPerfCurrentPerDlciUtilizationDlciValue=mfrapPerfCurrentPerDlciUtilizationDlciValue, mfrapLocalPayloadLoopbackFailedTrap=mfrapLocalPayloadLoopbackFailedTrap, mfrapCfgEditConnEntry=mfrapCfgEditConnEntry, mfrapPerfMgmtIpUDPNoPorts=mfrapPerfMgmtIpUDPNoPorts, mfrapCfgFrPerfLTProtocolFilterProtocol=mfrapCfgFrPerfLTProtocolFilterProtocol, mfrapPerfLmiTotalTxTotalByteCnt=mfrapPerfLmiTotalTxTotalByteCnt, mfrapCfgSnmpUtilTrapEnable=mfrapCfgSnmpUtilTrapEnable, mfrapT1CurrentLCVs=mfrapT1CurrentLCVs, mfrapT1IntervalIndex=mfrapT1IntervalIndex, mfrapCfgLcdPswdTimeout=mfrapCfgLcdPswdTimeout, mfrapPerfIcmpTotalTxGmReduct=mfrapPerfIcmpTotalTxGmReduct, mfrapV54LoopDownCompletedTrap=mfrapV54LoopDownCompletedTrap, mfrapPerfIpxTotalRxOther=mfrapPerfIpxTotalRxOther, mfrapPerfLmiPerDlciTxTotalByteCnt=mfrapPerfLmiPerDlciTxTotalByteCnt, mfrapPerfMgmtIpICMPInEchos=mfrapPerfMgmtIpICMPInEchos, mfrapPerfApplicationTotalTxSnmp=mfrapPerfApplicationTotalTxSnmp, mfrapDandiPerfClearAll=mfrapDandiPerfClearAll, mfrapPerfNetwProtoTotalTable=mfrapPerfNetwProtoTotalTable, mfrapCfgGetCommunityString=mfrapCfgGetCommunityString, mfrapPerfIcmpPerDlciRxPktTooBig=mfrapPerfIcmpPerDlciRxPktTooBig, mfrapPerfIcmpTotalTxGmReport=mfrapPerfIcmpTotalTxGmReport, mfrapPerfThruputPerIntfRxByteCnt=mfrapPerfThruputPerIntfRxByteCnt, mfrapPerfIpxTotalTxTotal=mfrapPerfIpxTotalTxTotal, mfrapPerfArpPerDlciRxRarpRep=mfrapPerfArpPerDlciRxRarpRep, mfrapPerfThruputPerDlciTxByte=mfrapPerfThruputPerDlciTxByte, mfrapSysNumDlcisSupported=mfrapSysNumDlcisSupported, mfrapTftpSuccessTrap=mfrapTftpSuccessTrap, mfrapPerfIpxTotalRxRip=mfrapPerfIpxTotalRxRip, mfrapDandiTotalLCVs=mfrapDandiTotalLCVs, mfrapLocalDandiPayloadLoopbackFailureTrap=mfrapLocalDandiPayloadLoopbackFailureTrap, mfrapDandiIntervalUASs=mfrapDandiIntervalUASs, mfrapStatusT1Table=mfrapStatusT1Table, mfrapDiagUnitReset=mfrapDiagUnitReset, mfrapEventLogAltTable=mfrapEventLogAltTable, mfrapPerfIpPerDlciValue=mfrapPerfIpPerDlciValue, mfrapSysNumDlciNames=mfrapSysNumDlciNames, mfrapPerfIcmpTotalTable=mfrapPerfIcmpTotalTable, mfrapPerfIpxTotalEntry=mfrapPerfIpxTotalEntry, mfrapPerfArpTotalTxArpRep=mfrapPerfArpTotalTxArpRep, mfrapDandiCurrentCrc6Events=mfrapDandiCurrentCrc6Events, mfrapPerfLmiTotalRxFullEnqByteCnt=mfrapPerfLmiTotalRxFullEnqByteCnt, mfrapDandiCurrentCSSs=mfrapDandiCurrentCSSs, mfrapLocalDteLoopbackEnabledTrap=mfrapLocalDteLoopbackEnabledTrap, mfrapCfgTransitDelayEntry=mfrapCfgTransitDelayEntry, mfrapEventTrapLogVarBind3=mfrapEventTrapLogVarBind3, mfrapCfgFrPerfLTDlciFilterIndex=mfrapCfgFrPerfLTDlciFilterIndex, mfrapStatusMgmtInterfaceStatus=mfrapStatusMgmtInterfaceStatus, mfrapDandiIntervalSEFSs=mfrapDandiIntervalSEFSs, mfrapCfgFrPerfLTDlciFilterTableClear=mfrapCfgFrPerfLTDlciFilterTableClear, mfrapCfgTftpFilename=mfrapCfgTftpFilename, mfrapPerfMgmtIpUDPInDatagrams=mfrapPerfMgmtIpUDPInDatagrams, mfrapLocalAggregateLoopbackFailedTrap=mfrapLocalAggregateLoopbackFailedTrap, mfrapCfgSecurityTable=mfrapCfgSecurityTable, mfrapPerfArpTotalTxRarpReq=mfrapPerfArpTotalTxRarpReq, mfrapPerfApplicationPerDlciEntry=mfrapPerfApplicationPerDlciEntry, mfrapT1IntervalESs=mfrapT1IntervalESs, mfrapPerfNetwLongTermAltTable=mfrapPerfNetwLongTermAltTable, mfrapNestFanOneAlarmClear=mfrapNestFanOneAlarmClear, mfrapPerfCirPercentUtilization=mfrapPerfCirPercentUtilization, mfrapVnipTopoTDAvgDelay=mfrapVnipTopoTDAvgDelay, mfrapCfgIpChannel=mfrapCfgIpChannel, mfrapDiagUnitLocLoop=mfrapDiagUnitLocLoop, mfrapPerfApplicationPerDlciTxCustom3=mfrapPerfApplicationPerDlciTxCustom3, mfrapT1PerfClearEvents=mfrapT1PerfClearEvents, mfrapCfgTelnetCliLcdPassword=mfrapCfgTelnetCliLcdPassword, mfrapDandiCarrierLoss=mfrapDandiCarrierLoss, mfrapPerfRoutingPerDlciRxOspf=mfrapPerfRoutingPerDlciRxOspf, mfrapCfgCommMode=mfrapCfgCommMode, mfrapPerfNetwProtoPerDlciTxIp=mfrapPerfNetwProtoPerDlciTxIp, mfrapPerfArpPerDlciRxOther=mfrapPerfArpPerDlciRxOther, mfrapT1IntervalLCVs=mfrapT1IntervalLCVs, mfrapPerfIpxTotalTxOther=mfrapPerfIpxTotalTxOther, mfrapPerfArpPerDlciRxArpReq=mfrapPerfArpPerDlciRxArpReq, mfrapStatusDteRxLED=mfrapStatusDteRxLED, mfrapPerfRoutingTotalRxNetbios=mfrapPerfRoutingTotalRxNetbios, mfrapDiagDteV54Lpbk=mfrapDiagDteV54Lpbk, mfrapDiagUnitTable=mfrapDiagUnitTable, mfrapPerfIcmpTotalRxTotal=mfrapPerfIcmpTotalRxTotal, mfrapPerfIpxPerDlciRxOther=mfrapPerfIpxPerDlciRxOther, mfrapPerfIpxTotalTxRip=mfrapPerfIpxTotalTxRip, mfrapT1PerfFreezeState=mfrapT1PerfFreezeState, mfrapPerfIpPerDlciInterval=mfrapPerfIpPerDlciInterval, mfrapCfgDteTable=mfrapCfgDteTable, mfrapLocalAggregateLoopbackDisabledTrap=mfrapLocalAggregateLoopbackDisabledTrap, mfrapPerfThruputCmdRemoveStsDlci=mfrapPerfThruputCmdRemoveStsDlci, mfrapStatusT1StatusLED=mfrapStatusT1StatusLED, mfrapPerfNetwProtoTotalTxTotal=mfrapPerfNetwProtoTotalTxTotal, mfrapPerfIcmpPerDlciTxTotal=mfrapPerfIcmpPerDlciTxTotal, mfrapPerfLmiPerDlciRxTotalByteCnt=mfrapPerfLmiPerDlciRxTotalByteCnt, mfrapt1netwsyncacquire=mfrapt1netwsyncacquire, mfrapCfgDteDsrOutput=mfrapCfgDteDsrOutput, mfrapPerfIpxTotalTxNcp=mfrapPerfIpxTotalTxNcp, mfrapCfgEditConnCopyCurrtoEdit=mfrapCfgEditConnCopyCurrtoEdit, mfrapCfgSetCommunityString=mfrapCfgSetCommunityString, mfrapCfgTftpNumBytes=mfrapCfgTftpNumBytes, mfrapDiagVnipEntry=mfrapDiagVnipEntry, mfrapPerfLmiPerDlciInterval=mfrapPerfLmiPerDlciInterval, mfrapCfgFrDLCITable=mfrapCfgFrDLCITable, mfrapT1TotalBESs=mfrapT1TotalBESs, mfrapPerfThruputPerDlciOutageCount=mfrapPerfThruputPerDlciOutageCount, mfrapPerfLmiPerDlciRxOtherByteCnt=mfrapPerfLmiPerDlciRxOtherByteCnt, mfrapCfgCommFlowCtrl=mfrapCfgCommFlowCtrl, mfrapPerfMgmtIpTCPActiveOpens=mfrapPerfMgmtIpTCPActiveOpens, mfrapPerfNetwProtoTotalRxOther=mfrapPerfNetwProtoTotalRxOther, mfrapVloopDownViaRemote=mfrapVloopDownViaRemote, mfrapT1IntervalUASs=mfrapT1IntervalUASs, mfrapPerfNetwProtoTotalRxArp=mfrapPerfNetwProtoTotalRxArp, mfrapDiagT1RmtLpbkCmd=mfrapDiagT1RmtLpbkCmd, mfrapPerfApplicationTotalEntry=mfrapPerfApplicationTotalEntry, mfrapCfgEditConnections=mfrapCfgEditConnections, mfrapPerfIcmpPerDlciRxTimeExcd=mfrapPerfIcmpPerDlciRxTimeExcd, mfrapCfgEditConnTable=mfrapCfgEditConnTable, mfrapLocalConfigTrap=mfrapLocalConfigTrap, mfrapPerfIpxPerDlciTxRip=mfrapPerfIpxPerDlciTxRip, mfrapPerfArpPerDlciInterval=mfrapPerfArpPerDlciInterval, mfrapPerfNetwProtoPerDlciRxTotal=mfrapPerfNetwProtoPerDlciRxTotal, mfrapEventTrapLog=mfrapEventTrapLog, mfrapVbertRequestFailed=mfrapVbertRequestFailed, mfrapPerfThruputPerDlciIndex=mfrapPerfThruputPerDlciIndex, mfrapLocalUnitLoopbackFailedTrap=mfrapLocalUnitLoopbackFailedTrap, mfrapPerfIpxTotalRxNetbios=mfrapPerfIpxTotalRxNetbios, mfrapPerfMgmtIpICMPInDestUnreachs=mfrapPerfMgmtIpICMPInDestUnreachs, mfrapPerfArpTotalRxOther=mfrapPerfArpTotalRxOther, mfrapPerfNetwProtoPerDlciRxIpx=mfrapPerfNetwProtoPerDlciRxIpx, mfrapCfgIpTable=mfrapCfgIpTable, mfrapCfgDteIntfType=mfrapCfgDteIntfType, mfrapStatusMgmtInterface=mfrapStatusMgmtInterface, mfrapTrapMutingInactive=mfrapTrapMutingInactive, mfrapStatusDandiAlarms=mfrapStatusDandiAlarms, mfrapCfgIpPeerIP=mfrapCfgIpPeerIP, mfrapDiagDandiTable=mfrapDiagDandiTable, mfrapPerfThruputPerDlciTxFrame=mfrapPerfThruputPerDlciTxFrame, mfrapPerfIcmpTotalRxTimestpRep=mfrapPerfIcmpTotalRxTimestpRep, mfrapPerfIcmpTotalRxAddrMaskReq=mfrapPerfIcmpTotalRxAddrMaskReq, mfrapPerfApplicationPerDlciTxFtp=mfrapPerfApplicationPerDlciTxFtp, mfrapPerfRoutingPerDlciRxRip=mfrapPerfRoutingPerDlciRxRip, mfrapPerfArpTotalRxInarpRep=mfrapPerfArpTotalRxInarpRep, mfrapPerfCirTxPercentUtilizationRange5=mfrapPerfCirTxPercentUtilizationRange5, mfrapPerfIcmpPerDlciRxGmQuery=mfrapPerfIcmpPerDlciRxGmQuery, mfrapPerfApplicationTotalRxSmtp=mfrapPerfApplicationTotalRxSmtp, mfrapCfgAppFormat=mfrapCfgAppFormat, mfrapPerfNetwLongTermInterval=mfrapPerfNetwLongTermInterval, mfrapCfgEditConnDestPort=mfrapCfgEditConnDestPort, mfrapPerfLmiTotalRxLivoStatByteCnt=mfrapPerfLmiTotalRxLivoStatByteCnt, mfrapPerfMgmtIpUDPStatsTable=mfrapPerfMgmtIpUDPStatsTable, mfrapPerfIcmpTotalTxRedirect=mfrapPerfIcmpTotalTxRedirect, mfrapPerfIpTotalInterval=mfrapPerfIpTotalInterval, mfrapPerfRoutingTotalRxOspf=mfrapPerfRoutingTotalRxOspf, mfrapPerfMgmtIpIFOutOctets=mfrapPerfMgmtIpIFOutOctets, mfrapPerfMgmtIpIPOutRqst=mfrapPerfMgmtIpIPOutRqst, mfrapCfgEditClearEdit=mfrapCfgEditClearEdit, mfrapPerfIpxTotalInterval=mfrapPerfIpxTotalInterval, mfrapPerfApplicationTotalTxSnmpTrap=mfrapPerfApplicationTotalTxSnmpTrap, mfrapCfgConnUpdateCmd=mfrapCfgConnUpdateCmd, mfrapVbertStarted=mfrapVbertStarted, mfrapCfgLock=mfrapCfgLock, mfrapPerfThruputCmdReplaceDlciEntry=mfrapPerfThruputCmdReplaceDlciEntry, mfrapPerfArpPerDlciTxArpReq=mfrapPerfArpPerDlciTxArpReq, mfrapLocalNetLoopbackFailedTrap=mfrapLocalNetLoopbackFailedTrap, mfrapPerfSnaTotalRxSubarea=mfrapPerfSnaTotalRxSubarea, mfrapPerfLmiTotalRxLivoEnqByteCnt=mfrapPerfLmiTotalRxLivoEnqByteCnt, mfrapPerfIpTotalTable=mfrapPerfIpTotalTable, mfrapStatusMgmtChannel=mfrapStatusMgmtChannel, mfrapPerfRoutingPerDlciTxOspf=mfrapPerfRoutingPerDlciTxOspf, mfrapPerfLmiTotalRxOtherByteCnt=mfrapPerfLmiTotalRxOtherByteCnt, mfrapNonIncrLmiSeqNumDteTrap=mfrapNonIncrLmiSeqNumDteTrap, mfrapPerfMgmtIpUDPOutDatagrams=mfrapPerfMgmtIpUDPOutDatagrams, mfrapPerfArpTotalRxArpRep=mfrapPerfArpTotalRxArpRep, mfrapPerfThruputPerIntfRxFrameCnt=mfrapPerfThruputPerIntfRxFrameCnt, mfrapCfgCommParity=mfrapCfgCommParity, mfrapPerfIpxPerDlciEntry=mfrapPerfIpxPerDlciEntry, mfrapPerfMgmtIpTCPOutSegs=mfrapPerfMgmtIpTCPOutSegs, mfrapDsuLoopbackEnabledTrap=mfrapDsuLoopbackEnabledTrap, mfrapDteSignalDtrOffTrap=mfrapDteSignalDtrOffTrap, mfrapStatusT1ModeLED=mfrapStatusT1ModeLED, mfrapPerfApplicationTotalRxCustom1=mfrapPerfApplicationTotalRxCustom1, mfrapPerfThruputPerDlciRxFrame=mfrapPerfThruputPerDlciRxFrame, enterprises=enterprises, mfrapCfgDteConnDs0Required=mfrapCfgDteConnDs0Required, mfrapLmiSourcingChangeUserT1Trap=mfrapLmiSourcingChangeUserT1Trap, mfrapCfgLcdPassword=mfrapCfgLcdPassword, mfrapCfgFrPerfUserProtocolsTableClear=mfrapCfgFrPerfUserProtocolsTableClear, mfrapCfgDteConnRate=mfrapCfgDteConnRate, mfrapT1IntervalSEFSs=mfrapT1IntervalSEFSs, mfrapPerfNetworkShortTerm=mfrapPerfNetworkShortTerm, mfrapPerfSnaTotalRxOther=mfrapPerfSnaTotalRxOther, mfrapPerfIcmpPerDlciRxTotal=mfrapPerfIcmpPerDlciRxTotal, mfrapPerfMgmtIpICMPOutEchos=mfrapPerfMgmtIpICMPOutEchos)
mibBuilder.exportSymbols("MFRAP-MIB", mfrapt1netwcarrierdetect=mfrapt1netwcarrierdetect, mfrapDiagUnitTimeRemaining=mfrapDiagUnitTimeRemaining, mfrapPerfMgmtIpTCPInSegs=mfrapPerfMgmtIpTCPInSegs, mfrapT1IntervalCSSs=mfrapT1IntervalCSSs, mfrapStatusDteTable=mfrapStatusDteTable, mfrapLocalPayloadLoopbackDisabledViaRemoteTrap=mfrapLocalPayloadLoopbackDisabledViaRemoteTrap, mfrapCfgDteConnAutoStatus=mfrapCfgDteConnAutoStatus, mfrapPerfSnaTotalTxOther=mfrapPerfSnaTotalTxOther, mfrapt1netwsynclossdeclare=mfrapt1netwsynclossdeclare, mfrapCfgTDDeleteEntry=mfrapCfgTDDeleteEntry, mfrapt1controlledslip=mfrapt1controlledslip, mfrapPerfMgmtIpTCPCurrEstab=mfrapPerfMgmtIpTCPCurrEstab, mfrapPerfThruputPerIntfRxCrcErrCnt=mfrapPerfThruputPerIntfRxCrcErrCnt, mfrapCfgT1Interface=mfrapCfgT1Interface, mfrapPerfThruputCmdClearAllStats=mfrapPerfThruputCmdClearAllStats, mfrapPerfNetwProtoTotalRxVnip=mfrapPerfNetwProtoTotalRxVnip, mfrapPerfIpxPerDlciTxOther=mfrapPerfIpxPerDlciTxOther, mfrapStatusAllLEDs=mfrapStatusAllLEDs, mfrapPerfThruputPerDlciMTBSO=mfrapPerfThruputPerDlciMTBSO, mfrapT1CurrentIndex=mfrapT1CurrentIndex, mfrapDandiCurrentESs=mfrapDandiCurrentESs, mfrapPerfArpPerDlciTxTotal=mfrapPerfArpPerDlciTxTotal, mfrapPerfIpTotalRxTotal=mfrapPerfIpTotalRxTotal, mfrapTftpAbortedTrap=mfrapTftpAbortedTrap, mfrapCfgAppPerfBuffLimit=mfrapCfgAppPerfBuffLimit, mfrapPerfSnaPerDlciTxSubarea=mfrapPerfSnaPerDlciTxSubarea, mfrapPerfApplicationPerDlciTxSmtp=mfrapPerfApplicationPerDlciTxSmtp, mfrapEventLogClear=mfrapEventLogClear, mfrapPerfIpxPerDlciTxSap=mfrapPerfIpxPerDlciTxSap, mfrapPerfIcmpPerDlciTxDestUnr=mfrapPerfIcmpPerDlciTxDestUnr, mfrapStatusDteStatusLED=mfrapStatusDteStatusLED, mfrapPerfArpPerDlciTxRarpRep=mfrapPerfArpPerDlciTxRarpRep, mfrapt1netwaisdetect=mfrapt1netwaisdetect, mfrapPerfIcmpPerDlciTxTimestpRep=mfrapPerfIcmpPerDlciTxTimestpRep, mfrapPerfIpPerDlciTable=mfrapPerfIpPerDlciTable, mfrapT1PerfClearAll=mfrapT1PerfClearAll, mfrapPerfNetwLongTermAltArray=mfrapPerfNetwLongTermAltArray, mfrapPerfThruputCmdAvailabilityStsDlciReset=mfrapPerfThruputCmdAvailabilityStsDlciReset, mfrapPerfNetwLongTermDlci=mfrapPerfNetwLongTermDlci, mfrapCfgID=mfrapCfgID, mfrapSysETHSupported=mfrapSysETHSupported, mfrapCfgFrAddrResDlcis=mfrapCfgFrAddrResDlcis, mfrapPerfSnaPerDlciEntry=mfrapPerfSnaPerDlciEntry, mfrapEventLogAltEntry=mfrapEventLogAltEntry, mfrapSysSoftRev=mfrapSysSoftRev, mfrapDiagT1LocAggrLpbk=mfrapDiagT1LocAggrLpbk, mfrapPerfThruputCmdCountsStsDlciReset=mfrapPerfThruputCmdCountsStsDlciReset, mfrapCfgFrPerf=mfrapCfgFrPerf, mfrapPerfSnaTotalTxSubarea=mfrapPerfSnaTotalTxSubarea, mfrapCfgDandiFraming=mfrapCfgDandiFraming, mfrapPerfIcmpPerDlciTxEchoRep=mfrapPerfIcmpPerDlciTxEchoRep, mfrapCfgDteRts=mfrapCfgDteRts, mfrapDiagDteSigDTR=mfrapDiagDteSigDTR, mfrapCfgFrAddrResInarpTimer=mfrapCfgFrAddrResInarpTimer, mfrapCfgFrPerfLTProtocolFilterIndex=mfrapCfgFrPerfLTProtocolFilterIndex, mfrapPerfIpTotalTxUdp=mfrapPerfIpTotalTxUdp, mfrapT1TotalEntry=mfrapT1TotalEntry, mfrapPerfMgmtIpIPInDlvrs=mfrapPerfMgmtIpIPInDlvrs, mfrapT1TotalSEFSs=mfrapT1TotalSEFSs, mfrapPerfIpTotalTxIcmp=mfrapPerfIpTotalTxIcmp, mfrapSysHardRev=mfrapSysHardRev, mfrapDandiPerfFreezeState=mfrapDandiPerfFreezeState, mfrapPerfThruputPerDlciRxThruput=mfrapPerfThruputPerDlciRxThruput, mfrapPerfIcmpTotalEntry=mfrapPerfIcmpTotalEntry, mfrapPerfMgmtIpIPOutDscrd=mfrapPerfMgmtIpIPOutDscrd, mfrapPerfSnaPerDlciTxAppn=mfrapPerfSnaPerDlciTxAppn, mfrapPerfIcmpPerDlciRxEchoReq=mfrapPerfIcmpPerDlciRxEchoReq, mfrapLocalNetLoopbackEnabledTrap=mfrapLocalNetLoopbackEnabledTrap, mfrapPerfArpTotalRxRarpRep=mfrapPerfArpTotalRxRarpRep, mfrapCfgDteConnAutoUpdate=mfrapCfgDteConnAutoUpdate, mfrapDiagDandiLocLineLpbk=mfrapDiagDandiLocLineLpbk, mfrapPerfThruputCmdAvailabilityStsDlciResetAll=mfrapPerfThruputCmdAvailabilityStsDlciResetAll, mfrapPerfNetwProtoPerDlciTxAnnexG=mfrapPerfNetwProtoPerDlciTxAnnexG, mfrapPerfIpxPerDlciRxNetbios=mfrapPerfIpxPerDlciRxNetbios, mfrapPerfIpxTotalTable=mfrapPerfIpxTotalTable, mfrapPerfNetworkLongTermCommands=mfrapPerfNetworkLongTermCommands, mfrapPerfIcmpTotalRxSrcQuench=mfrapPerfIcmpTotalRxSrcQuench, mfrapCfgAppType=mfrapCfgAppType, mfrapStatusLedTable=mfrapStatusLedTable, mfrapDandiAisClear=mfrapDandiAisClear, mfrapCfgSnmpMgrDlci=mfrapCfgSnmpMgrDlci, mfrapT1PerfCmdTypeTable=mfrapT1PerfCmdTypeTable, mfrapPerfArpPerDlciRxArpRep=mfrapPerfArpPerDlciRxArpRep, mfrapDiagDteTable=mfrapDiagDteTable, mfrapPerfCirRxPercentUtilizationRange1=mfrapPerfCirRxPercentUtilizationRange1, mfrapStatusT1Mode=mfrapStatusT1Mode, mfrapIpAddress=mfrapIpAddress, mfrapPerfThruputPerDlciChangeTime=mfrapPerfThruputPerDlciChangeTime, mfrapPerfIcmpPerDlciRxParamProb=mfrapPerfIcmpPerDlciRxParamProb, mfrapPerfIcmpPerDlciTxAddrMaskRep=mfrapPerfIcmpPerDlciTxAddrMaskRep, mfrapDandiSyncLossDeclare=mfrapDandiSyncLossDeclare, mfrapPerfThruputCmdAllStsDlciReset=mfrapPerfThruputCmdAllStsDlciReset, mfrapDiagVnipDlci=mfrapDiagVnipDlci, mfrapSysNumT1Installed=mfrapSysNumT1Installed, mfrapLocalPayloadLoopbackDisabledTrap=mfrapLocalPayloadLoopbackDisabledTrap, mfrapPerfCurrentDteUtilization=mfrapPerfCurrentDteUtilization, mfrapPerformance=mfrapPerformance, mfrapCfgTftpTable=mfrapCfgTftpTable, mfrapPerfNetwProtoPerDlciTxOther=mfrapPerfNetwProtoPerDlciTxOther, mfrapPerfNetwProtoPerDlciTxCisco=mfrapPerfNetwProtoPerDlciTxCisco, mfrapVloopUpViaRemote=mfrapVloopUpViaRemote, mfrapLocalDandiPayloadLoopbackDisabledTrap=mfrapLocalDandiPayloadLoopbackDisabledTrap, mfrapPerfCurrentPerDlciRxUtilization=mfrapPerfCurrentPerDlciRxUtilization, mfrapDiagT1Table=mfrapDiagT1Table, mfrapPerfIcmpPerDlciRxAddrMaskRep=mfrapPerfIcmpPerDlciRxAddrMaskRep, mfrapPerfIcmpPerDlciTxPktTooBig=mfrapPerfIcmpPerDlciTxPktTooBig, mfrapVnipTopologyLocalDlci=mfrapVnipTopologyLocalDlci, mfrapStatusNestSlotId=mfrapStatusNestSlotId, mfrapPerfIcmpPerDlciTxRedirect=mfrapPerfIcmpPerDlciTxRedirect, mfrapDiagVnipIndex=mfrapDiagVnipIndex, mfrapPerfIcmpTotalTxAddrMaskReq=mfrapPerfIcmpTotalTxAddrMaskReq, mfrapPerfApplicationPerDlciTxSnmpTrap=mfrapPerfApplicationPerDlciTxSnmpTrap, mfrapPerfIpPerDlciTxOther=mfrapPerfIpPerDlciTxOther, mfrapPerfSnaTotalRxAppn=mfrapPerfSnaTotalRxAppn, mfrapPerfNetwProtoPerDlciRxCisco=mfrapPerfNetwProtoPerDlciRxCisco, mfrapPerfIcmpPerDlciRxEchoRep=mfrapPerfIcmpPerDlciRxEchoRep, mfrapCfgCommBaud=mfrapCfgCommBaud, mfrapPerfT1CurrentTable=mfrapPerfT1CurrentTable, mfrapPerfThruputPerDlciPvcState=mfrapPerfThruputPerDlciPvcState, mfrapPerfCirTxPercentUtilizationRange8=mfrapPerfCirTxPercentUtilizationRange8, mfrapPvcRxUtilizationExceededTrap=mfrapPvcRxUtilizationExceededTrap, mfrapLocalDandiLineLoopbackDisabledTrap=mfrapLocalDandiLineLoopbackDisabledTrap, mfrapPerfApplicationTotalTxFtp=mfrapPerfApplicationTotalTxFtp, sync=sync, mfrapCfgFrPerfUnprovDlcisDelete=mfrapCfgFrPerfUnprovDlcisDelete, mfrapDandiCurrentLCVs=mfrapDandiCurrentLCVs, mfrapV54LoopbackEnabledTrap=mfrapV54LoopbackEnabledTrap, mfrapPerfSnaTotalTxAppn=mfrapPerfSnaTotalTxAppn, mfrapPerfThruputCmdReplaceDlciTable=mfrapPerfThruputCmdReplaceDlciTable, mfrapStatusT1Alarms=mfrapStatusT1Alarms, mfrapCfgDteDcdOutput=mfrapCfgDteDcdOutput, mfrapPerfApplicationTotalTxTelnet=mfrapPerfApplicationTotalTxTelnet, mfrapVnipTopoVBertRxDESetFrames=mfrapVnipTopoVBertRxDESetFrames, mfrapT1CurrentCSSs=mfrapT1CurrentCSSs, mfrapPerfIpTotalRxOther=mfrapPerfIpTotalRxOther, mfrapDteSignalRtsOnTrap=mfrapDteSignalRtsOnTrap, mfrapCfgT1LboSetting=mfrapCfgT1LboSetting, mfrapSysTKRSupported=mfrapSysTKRSupported, mfrapDiagBertTimeElaps=mfrapDiagBertTimeElaps, mfrapVnipTopoVBertRxDEClrFrames=mfrapVnipTopoVBertRxDEClrFrames, mfrapDiagDandiTimeRemaining=mfrapDiagDandiTimeRemaining, mfrapTftpProgrammingTrap=mfrapTftpProgrammingTrap, mfrapCfgFrPerfDlciNamesEirValue=mfrapCfgFrPerfDlciNamesEirValue, mfrapPerfCirTxPercentUtilizationRange7=mfrapPerfCirTxPercentUtilizationRange7, mfrapBertInitiatedTrap=mfrapBertInitiatedTrap, mfrapPerfIcmpTotalRxDestUnr=mfrapPerfIcmpTotalRxDestUnr, mfrapPerfApplicationTotalTable=mfrapPerfApplicationTotalTable, mfrapDiagBertErrSec=mfrapDiagBertErrSec, mfrapPerfIcmpTotalTxAddrMaskRep=mfrapPerfIcmpTotalTxAddrMaskRep, mfrapPerfThruputPerDlciUptime=mfrapPerfThruputPerDlciUptime, mfrapPerfCirTxPercentUtilizationRange3=mfrapPerfCirTxPercentUtilizationRange3, mfrapDiagnostics=mfrapDiagnostics, mfrapDteSignalDtrOnTrap=mfrapDteSignalDtrOnTrap, mfrapPerfRoutingTotalInterval=mfrapPerfRoutingTotalInterval, mfrapPerfCirTxPercentUtilizationRange2=mfrapPerfCirTxPercentUtilizationRange2, mfrapVnipTransitDelayClear=mfrapVnipTransitDelayClear, mfrapCfgTftpIpAddress=mfrapCfgTftpIpAddress, mfrapPerfRoutingPerDlciValue=mfrapPerfRoutingPerDlciValue, mfrapConfigInstallSuccess=mfrapConfigInstallSuccess, mfrapPerfArpTotalEntry=mfrapPerfArpTotalEntry, mfrapPerfRoutingPerDlciRxNetbios=mfrapPerfRoutingPerDlciRxNetbios, mfrapSysMLSupported=mfrapSysMLSupported, mfrapEventTrapLogVarBind1=mfrapEventTrapLogVarBind1, mfrapPerfIpxTotalRxSap=mfrapPerfIpxTotalRxSap, mfrapLocalDandiLineLoopbackEnabledTrap=mfrapLocalDandiLineLoopbackEnabledTrap, mfrapVloopRequestFailed=mfrapVloopRequestFailed, mfrapt1netwyellowalarmdetect=mfrapt1netwyellowalarmdetect, mfrapPerfApplicationPerDlciTxHttp=mfrapPerfApplicationPerDlciTxHttp, mfrapPerfArpTotalTxRarpRep=mfrapPerfArpTotalTxRarpRep, mfrapPerfIpTotalEntry=mfrapPerfIpTotalEntry, mfrapDandiPerfClearEvents=mfrapDandiPerfClearEvents, mfrapSysAmtMemoryInstalled=mfrapSysAmtMemoryInstalled, mfrapCfgFrPerfLTProtocolFilterEntry=mfrapCfgFrPerfLTProtocolFilterEntry, mfrapVnipTopologyTable=mfrapVnipTopologyTable, mfrapPerfIcmpTotalTxGmQuery=mfrapPerfIcmpTotalTxGmQuery, mfrapPerfSnaTotalRxPeriph=mfrapPerfSnaTotalRxPeriph, mfrapPerfNetwProtoPerDlciTxTotal=mfrapPerfNetwProtoPerDlciTxTotal, mfrapDiagT1RmtLpbkStatus=mfrapDiagT1RmtLpbkStatus, mfrapStatusMgmtDefaultDLCINo=mfrapStatusMgmtDefaultDLCINo, mfrapCfgSnmpMgrIndex=mfrapCfgSnmpMgrIndex, mfrapT1CurrentBESs=mfrapT1CurrentBESs, mfrapCfgEditConnSrcPort=mfrapCfgEditConnSrcPort, mfrapPerfIcmpTotalRxGmReduct=mfrapPerfIcmpTotalRxGmReduct, mfrapPerfIcmpTotalTxTimestpReq=mfrapPerfIcmpTotalTxTimestpReq, mfrapPerfArpTotalTable=mfrapPerfArpTotalTable, mfrapPerfIpPerDlciTxIgrp=mfrapPerfIpPerDlciTxIgrp, mfrapPerfCirRxPercentUtilizationRange8=mfrapPerfCirRxPercentUtilizationRange8, mfrapCfgMgmtTable=mfrapCfgMgmtTable, mfrapDandiRedAlarmDeclare=mfrapDandiRedAlarmDeclare, mfrapPerfNetwLongTermValue=mfrapPerfNetwLongTermValue, mfrapDteSignalRtsOffTrap=mfrapDteSignalRtsOffTrap, mfrapBertCompletedTrap=mfrapBertCompletedTrap, mfrapPerfNetwProtoTotalTxOther=mfrapPerfNetwProtoTotalTxOther, mfrapCfgFrPerfDlciNamesEntry=mfrapCfgFrPerfDlciNamesEntry, mfrapTftpRequestedTrap=mfrapTftpRequestedTrap, mfrapCfgDteTiming=mfrapCfgDteTiming, mfrapDiagVnipTable=mfrapDiagVnipTable, mfrapCfgLockIpAddress=mfrapCfgLockIpAddress, mfrapPerfMgmtIpICMPOutDestUnreachs=mfrapPerfMgmtIpICMPOutDestUnreachs, mfrapPerfThruputPerDlciCirType=mfrapPerfThruputPerDlciCirType, mfrapVnipTopologyIndex=mfrapVnipTopologyIndex, mfrapCfgFrPerfLTDlciFilterEntry=mfrapCfgFrPerfLTDlciFilterEntry, mfrapPerfIpxTotalTxNetbios=mfrapPerfIpxTotalTxNetbios, mfrapPerfIpPerDlciEntry=mfrapPerfIpPerDlciEntry, mfrapPerfApplicationPerDlciTxTftp=mfrapPerfApplicationPerDlciTxTftp, mfrapPerfThruputCmdReplaceDlciNewValue=mfrapPerfThruputCmdReplaceDlciNewValue, mfrapCfgUnlock=mfrapCfgUnlock, mfrapDsuLoopbackFailedTrap=mfrapDsuLoopbackFailedTrap, mfrapCfgStatus=mfrapCfgStatus, mfrapPerfApplicationTotalRxHttp=mfrapPerfApplicationTotalRxHttp, mfrapPerfMgmtIpIPInProtUnk=mfrapPerfMgmtIpIPInProtUnk, mfrapCfgIpTelnetAutoLogOut=mfrapCfgIpTelnetAutoLogOut, mfrapPerfIcmpPerDlciTxAddrMaskReq=mfrapPerfIcmpPerDlciTxAddrMaskReq, mfrapPerfApplicationTotalRxSnmp=mfrapPerfApplicationTotalRxSnmp, mfrapPerfNetwProtoTotalTxCisco=mfrapPerfNetwProtoTotalTxCisco, mfrapDandIaisDetect=mfrapDandIaisDetect, mfrapPerfIpxPerDlciRxNcp=mfrapPerfIpxPerDlciRxNcp, mfrapPerfArpTotalTxTotal=mfrapPerfArpTotalTxTotal, mfrapDiagVBERT=mfrapDiagVBERT, mfrapPerfApplicationTotalRxTelnet=mfrapPerfApplicationTotalRxTelnet, mfrapEventTrapLogGenericEvent=mfrapEventTrapLogGenericEvent, mfrapTftpInvalidFileTrap=mfrapTftpInvalidFileTrap, mfrapCfgTransitDelayInterface=mfrapCfgTransitDelayInterface, mfrapStatusDteDsr=mfrapStatusDteDsr, mfrapCfgDandiTable=mfrapCfgDandiTable, mfrapPerfApplicationPerDlciTable=mfrapPerfApplicationPerDlciTable, mfrapPerfApplicationPerDlciRxSmtp=mfrapPerfApplicationPerDlciRxSmtp, mfrapPerfThruputPerDlciTable=mfrapPerfThruputPerDlciTable, mfrapPerfIpTotalTxTotal=mfrapPerfIpTotalTxTotal, mfrapPerfIcmpPerDlciTxGmReport=mfrapPerfIcmpPerDlciTxGmReport, mfrapPerfCirRxPercentUtilizationRange3=mfrapPerfCirRxPercentUtilizationRange3, mfrapPerfMgmtIpIFInOctets=mfrapPerfMgmtIpIFInOctets, mfrapPerfLmiTotalTxLivoStatByteCnt=mfrapPerfLmiTotalTxLivoStatByteCnt, mfrapCfgFrLmiKeepaliveTimeout=mfrapCfgFrLmiKeepaliveTimeout, mfrapCfgFrPerfDlciNamesDlciValue=mfrapCfgFrPerfDlciNamesDlciValue, mfrapPerfMgmtIpIFOperStatus=mfrapPerfMgmtIpIFOperStatus, mfrapSysFeatureTable=mfrapSysFeatureTable, mfrapPerfCirRxPercentUtilizationRange2=mfrapPerfCirRxPercentUtilizationRange2, mfrapPerfApplicationPerDlciRxTelnet=mfrapPerfApplicationPerDlciRxTelnet, mfrapPvcRxUtilizationClearedTrap=mfrapPvcRxUtilizationClearedTrap, mfrapPerfIcmpPerDlciRxSrcQuench=mfrapPerfIcmpPerDlciRxSrcQuench, mfrapCfgDteConnStartDs0=mfrapCfgDteConnStartDs0, mfrapPerfSnaTotalTxTotal=mfrapPerfSnaTotalTxTotal, mfrapPvcTxUtilizationClearedTrap=mfrapPvcTxUtilizationClearedTrap, mfrapPerfMgmtIpTCPStatsTable=mfrapPerfMgmtIpTCPStatsTable, mfrapCfgTftpInitiate=mfrapCfgTftpInitiate, mfrapDandiCurrentSESs=mfrapDandiCurrentSESs, mfrapPerfCirPercentUtilizationEntry=mfrapPerfCirPercentUtilizationEntry, mfrapDandiTotalUASs=mfrapDandiTotalUASs, mfrapPerfSnaPerDlciValue=mfrapPerfSnaPerDlciValue, mfrapPerfCirRxPercentUtilizationRange6=mfrapPerfCirRxPercentUtilizationRange6, mfrapPerfApplicationPerDlciRxSnmpTrap=mfrapPerfApplicationPerDlciRxSnmpTrap, mfrapPerfApplicationPerDlciRxSnmp=mfrapPerfApplicationPerDlciRxSnmp, mfrapPerfLmiPerDlciRxFullStatByteCnt=mfrapPerfLmiPerDlciRxFullStatByteCnt)
mibBuilder.exportSymbols("MFRAP-MIB", mfrapPerfCirTxPercentUtilizationRange4=mfrapPerfCirTxPercentUtilizationRange4, mfrapLmiSourcingChangeNetDteTrap=mfrapLmiSourcingChangeNetDteTrap, mfrapNonIncrLmiSeqNumT1Trap=mfrapNonIncrLmiSeqNumT1Trap, mfrapLocalDandiPayloadLoopbackEnabledTrap=mfrapLocalDandiPayloadLoopbackEnabledTrap, mfrapT1CurrentEntry=mfrapT1CurrentEntry, mfrapPerfIpTotalRxUdp=mfrapPerfIpTotalRxUdp, mfrapCfgTftpInterface=mfrapCfgTftpInterface, mfrapCfgFrPerfTimers=mfrapCfgFrPerfTimers, mfrapPerfIcmpPerDlciRxTimestpReq=mfrapPerfIcmpPerDlciRxTimestpReq, mfrapPerfThruputCmdClearT1Stats=mfrapPerfThruputCmdClearT1Stats, mfrapStatusT1Status=mfrapStatusT1Status, mfrapDandiCarrierDetect=mfrapDandiCarrierDetect, mfrapDiagBertResyncs=mfrapDiagBertResyncs, mfrapPerfLmiPerDlciTable=mfrapPerfLmiPerDlciTable, mfrapPerfThruputCommands=mfrapPerfThruputCommands, mfrapPerfMgmtIpIPInHdrErr=mfrapPerfMgmtIpIPInHdrErr, mfrapPerfLmiPerDlciTxLivoEnqByteCnt=mfrapPerfLmiPerDlciTxLivoEnqByteCnt, mfrapEventTrapLogVarBind2=mfrapEventTrapLogVarBind2, mfrapCfgCurrentConnType=mfrapCfgCurrentConnType, mfrapPerfSnaPerDlciTable=mfrapPerfSnaPerDlciTable, mfrapPerfLmiPerDlciTxFullEnqByteCnt=mfrapPerfLmiPerDlciTxFullEnqByteCnt, mfrapPerfMgmtIpICMPOutErrors=mfrapPerfMgmtIpICMPOutErrors, mfrapCfgSnmpMgrTable=mfrapCfgSnmpMgrTable, mfrapLocalNetLoopbackDisabledTrap=mfrapLocalNetLoopbackDisabledTrap, mfrapSysExtTimSupported=mfrapSysExtTimSupported, mfrapDiagDteLclLpbk=mfrapDiagDteLclLpbk, mfrapPerfArpPerDlciRxRarpReq=mfrapPerfArpPerDlciRxRarpReq, mfrapCfgFrPerfDlciNamesUtilThreshold=mfrapCfgFrPerfDlciNamesUtilThreshold, mfrapPerfSnaPerDlciRxNetbios=mfrapPerfSnaPerDlciRxNetbios, mfrapPerfCirPercentUtilizationInterval=mfrapPerfCirPercentUtilizationInterval, mfrapDandiTotalSESs=mfrapDandiTotalSESs, mfrapPerfIcmpTotalTxTimeExcd=mfrapPerfIcmpTotalTxTimeExcd, mfrapPerfNetwLongTermProtocol=mfrapPerfNetwLongTermProtocol, mfrapPerfSnaTotalRxNetbios=mfrapPerfSnaTotalRxNetbios, mfrapT1TotalUASs=mfrapT1TotalUASs, mfrapDiagBertState=mfrapDiagBertState, mfrapPerfIpPerDlciTxIcmp=mfrapPerfIpPerDlciTxIcmp, mfrapCfgEditConnSrcDs0=mfrapCfgEditConnSrcDs0, mfrapPerfSnaPerDlciTxNetbios=mfrapPerfSnaPerDlciTxNetbios, mfrapPerfCirTxPercentUtilizationRange6=mfrapPerfCirTxPercentUtilizationRange6, mfrapPerfApplicationTotalTxCustom4=mfrapPerfApplicationTotalTxCustom4, mfrapPerfRoutingTotalTxNetbios=mfrapPerfRoutingTotalTxNetbios, mfrapDiagVBERTPktPercent=mfrapDiagVBERTPktPercent, mfrapCfgTransitDelayTableClear=mfrapCfgTransitDelayTableClear, mfrapPerfNetwLongTermTable=mfrapPerfNetwLongTermTable, mfrapBertFailedTrap=mfrapBertFailedTrap, mfrapPerfNetwProtoTotalRxIp=mfrapPerfNetwProtoTotalRxIp, mfrapCsuLoopUpInitiatedTrap=mfrapCsuLoopUpInitiatedTrap, mfrapPerfApplicationTotalTxCustom3=mfrapPerfApplicationTotalTxCustom3, mfrapStatusNestPowerSupply=mfrapStatusNestPowerSupply, mfrapVnipTopologyDlci=mfrapVnipTopologyDlci, mfrapDandiRedalArmclear=mfrapDandiRedalArmclear, mfrapPerfArpPerDlciEntry=mfrapPerfArpPerDlciEntry, mfrapPerfApplicationPerDlciValue=mfrapPerfApplicationPerDlciValue, mfrapPerfLmiPerDlciEntry=mfrapPerfLmiPerDlciEntry, mfrapPerfThruputPerDlciDowntime=mfrapPerfThruputPerDlciDowntime, mfrapSysLTFNumProtocols=mfrapSysLTFNumProtocols, mfrapPerfIpTotalTxIgrp=mfrapPerfIpTotalTxIgrp, mfrapPerfLmiPerDlciRxLivoEnqByteCnt=mfrapPerfLmiPerDlciRxLivoEnqByteCnt, mfrapV54LoopbackDisabledTrap=mfrapV54LoopbackDisabledTrap, mfrapPerfMgmtIpIPOutNoRt=mfrapPerfMgmtIpIPOutNoRt, mfrapCfgFrLmiFullStatus=mfrapCfgFrLmiFullStatus, mfrapT1CurrentSESs=mfrapT1CurrentSESs, mfrapCfgDteCtsOutput=mfrapCfgDteCtsOutput, mfrapDandiTotalCSSs=mfrapDandiTotalCSSs, mfrapPerfApplicationTotalTxSmtp=mfrapPerfApplicationTotalTxSmtp, mfrapPerfIcmpPerDlciTxSrcQuench=mfrapPerfIcmpPerDlciTxSrcQuench, mfrapVnipTopoVBertTransitDelayMax=mfrapVnipTopoVBertTransitDelayMax, mfrapCfgCommDataBits=mfrapCfgCommDataBits, mfrapPerfIcmpTotalRxGmReport=mfrapPerfIcmpTotalRxGmReport, mfrapCfgVnipTable=mfrapCfgVnipTable, mfrapPerfIcmpPerDlciTxTimestpReq=mfrapPerfIcmpPerDlciTxTimestpReq, mfrapVnipTopoVBertPerUtilCIR=mfrapVnipTopoVBertPerUtilCIR, mfrapPerfIpxPerDlciTxSpx=mfrapPerfIpxPerDlciTxSpx, mfrapSysNestId=mfrapSysNestId, mfrapDandiIntervalBESs=mfrapDandiIntervalBESs, mfrapPerfArpPerDlciTxInarpReq=mfrapPerfArpPerDlciTxInarpReq, mfrapLocalUnitLoopbackDisabledTrap=mfrapLocalUnitLoopbackDisabledTrap, mfrapPerfArpTotalInterval=mfrapPerfArpTotalInterval, mfrapPerfIcmpPerDlciEntry=mfrapPerfIcmpPerDlciEntry, mfrapSysPrompt=mfrapSysPrompt, mfrapCfgIpMyIP=mfrapCfgIpMyIP, mfrapCfgFrPerfDlciNamesTable=mfrapCfgFrPerfDlciNamesTable, mfrapSysResetNode=mfrapSysResetNode, mfrapCfgVnipMode=mfrapCfgVnipMode, mfrapCfgTftpDlci=mfrapCfgTftpDlci, mfrapPerfNetwProtoTotalRxSna=mfrapPerfNetwProtoTotalRxSna, mfrapPerfThruputPerDlciRxBecn=mfrapPerfThruputPerDlciRxBecn, mfrapPerfIcmpTotalTxDestUnr=mfrapPerfIcmpTotalTxDestUnr, mfrapPerfNetworkLongTermCmdClear=mfrapPerfNetworkLongTermCmdClear, mfrapStatusDandiMode=mfrapStatusDandiMode, mfrapPerfIpxPerDlciTxNetbios=mfrapPerfIpxPerDlciTxNetbios, mfrapPerfLmiTotalEntry=mfrapPerfLmiTotalEntry, mfrapPerfIcmpTotalTxEchoReq=mfrapPerfIcmpTotalTxEchoReq, mfrapPerfCirRxPercentUtilizationRange4=mfrapPerfCirRxPercentUtilizationRange4, mfrapTrap=mfrapTrap, mfrapPerfRoutingPerDlciInterval=mfrapPerfRoutingPerDlciInterval, mfrapPerfCurrentPerDlciAggregateUtilization=mfrapPerfCurrentPerDlciAggregateUtilization, mfrapLmiSeqNumMismatchDteTrap=mfrapLmiSeqNumMismatchDteTrap, mfrapCsuLoopbackFailedTrap=mfrapCsuLoopbackFailedTrap, mfrapCfgAppCircuitId=mfrapCfgAppCircuitId, mfrapCfgCurrentConnEntry=mfrapCfgCurrentConnEntry, mfrapCfgEditDisconnect=mfrapCfgEditDisconnect, mfrapCfgFrPerfDlciDefaultUtilThreshold=mfrapCfgFrPerfDlciDefaultUtilThreshold, mfrapT1CurrentUASs=mfrapT1CurrentUASs, mfrapNestFanTwoAlarm=mfrapNestFanTwoAlarm, mfrapCfgCurrentConnDestDs0=mfrapCfgCurrentConnDestDs0, mfrapCfgSnmpNestAlarmTrapEnable=mfrapCfgSnmpNestAlarmTrapEnable, mfrapPerfNetwProtoTotalEntry=mfrapPerfNetwProtoTotalEntry, mfrapDandiCurrentUASs=mfrapDandiCurrentUASs, mfrapCfgTransitDelayTable=mfrapCfgTransitDelayTable, mfrapPerfNetwProtoPerDlciRxIp=mfrapPerfNetwProtoPerDlciRxIp, mfrapPerfNetwProtoPerDlciRxVnip=mfrapPerfNetwProtoPerDlciRxVnip, mfrapEventTrapLogTable=mfrapEventTrapLogTable, mfrapCfgFrPerfTimersSTInterval=mfrapCfgFrPerfTimersSTInterval, mfrapPerfIcmpTotalTxTotal=mfrapPerfIcmpTotalTxTotal, mfrapCfgT1LineEncoding=mfrapCfgT1LineEncoding, mfrapCfgFrTable=mfrapCfgFrTable, mfrapCfgSnmpMgrInterface=mfrapCfgSnmpMgrInterface, mfrapDandiYellowAlarmClear=mfrapDandiYellowAlarmClear, mfrapEventLogAltArray=mfrapEventLogAltArray, mfrapPerfIcmpTotalRxAddrMaskRep=mfrapPerfIcmpTotalRxAddrMaskRep, mfrapPerfIpTotalTxOther=mfrapPerfIpTotalTxOther, mfrapDiagT1LocLineLpbk=mfrapDiagT1LocLineLpbk, mfrapPerfRoutingPerDlciEntry=mfrapPerfRoutingPerDlciEntry, mfrapLmiSourcingChangeNetT1Trap=mfrapLmiSourcingChangeNetT1Trap, mfrapPerfThruputPerIntfRxAbortCnt=mfrapPerfThruputPerIntfRxAbortCnt, mfrapPerfThruputPerDlciCIR=mfrapPerfThruputPerDlciCIR, mfrapPerfMgmtIpICMPOutMsgs=mfrapPerfMgmtIpICMPOutMsgs, mfrapPerfNetwProtoTotalRxCisco=mfrapPerfNetwProtoTotalRxCisco, mfrapPerfApplicationPerDlciRxCustom3=mfrapPerfApplicationPerDlciRxCustom3, mfrapPerfLmiPerDlciTxLivoStatByteCnt=mfrapPerfLmiPerDlciTxLivoStatByteCnt, mfrapt1netwredalarmclear=mfrapt1netwredalarmclear, mfrapDiagT1LocPylLpbk=mfrapDiagT1LocPylLpbk, mfrapVnipTopoVBertPerUtilEIR=mfrapVnipTopoVBertPerUtilEIR, mfrapPerfIpxTotalRxSpx=mfrapPerfIpxTotalRxSpx, mfrapPerfIpPerDlciRxTotal=mfrapPerfIpPerDlciRxTotal, mfrapPerfApplicationPerDlciTxCustom4=mfrapPerfApplicationPerDlciTxCustom4, mfrapCfgIpMaxMTU=mfrapCfgIpMaxMTU, mfrapPerfDandiCurrentTable=mfrapPerfDandiCurrentTable, mfrapPerfLmiPerDlciValue=mfrapPerfLmiPerDlciValue, mfrapCfgFrPerfUserProtocolsPortNum=mfrapCfgFrPerfUserProtocolsPortNum, mfrapt1netwredalarmdeclare=mfrapt1netwredalarmdeclare, mfrapCfgLcdPswdEnable=mfrapCfgLcdPswdEnable, mfrapSysLTFNumDlcis=mfrapSysLTFNumDlcis, mfrapLocalDandiLineLoopbackFailureTrap=mfrapLocalDandiLineLoopbackFailureTrap, mfrapPerfIpxPerDlciTxTotal=mfrapPerfIpxPerDlciTxTotal, mfrapPerfArpTotalTxArpReq=mfrapPerfArpTotalTxArpReq, mfrapStatusDteDcd=mfrapStatusDteDcd, mfrapT1IntervalNumber=mfrapT1IntervalNumber, mfrapCfgTransitDelayNumHops=mfrapCfgTransitDelayNumHops, mfrapPerfCirTxPercentUtilizationRange1=mfrapPerfCirTxPercentUtilizationRange1, mfrapCfgTransitDelayRcvSummaryCancel=mfrapCfgTransitDelayRcvSummaryCancel, mfrapStatus=mfrapStatus, mfrapPerfIcmpTotalTxEchoRep=mfrapPerfIcmpTotalTxEchoRep, mfrapCfgT1Density=mfrapCfgT1Density, mfrapT1IntervalSESs=mfrapT1IntervalSESs, mfrapPerfCurrentPerDlciUtilizationEntry=mfrapPerfCurrentPerDlciUtilizationEntry, mfrapPerfIpxPerDlciRxSap=mfrapPerfIpxPerDlciRxSap, mfrapPerfSnaTotalRxTotal=mfrapPerfSnaTotalRxTotal, mfrapDandiSyncAcquire=mfrapDandiSyncAcquire, mfrapDiagBertTable=mfrapDiagBertTable, mfrapPerfIcmpTotalTxPktTooBig=mfrapPerfIcmpTotalTxPktTooBig, mfrapPerfIpPerDlciRxIcmp=mfrapPerfIpPerDlciRxIcmp, mfrapPerfNetwLongTermAltDlci=mfrapPerfNetwLongTermAltDlci, mfrapCfgFrAddrLen=mfrapCfgFrAddrLen, mfrapT1CurrentOofEvents=mfrapT1CurrentOofEvents, mfrapt1netwyellowalarmclear=mfrapt1netwyellowalarmclear, mfrapPerfMgmtIpIPInDscrd=mfrapPerfMgmtIpIPInDscrd, mfrapPerfThruputCmdCountsStsDlciResetAll=mfrapPerfThruputCmdCountsStsDlciResetAll, mfrapT1TotalESs=mfrapT1TotalESs, mfrapEventTrapLogTimeStamp=mfrapEventTrapLogTimeStamp, mfrapLmiSourcingChangePassthruTrap=mfrapLmiSourcingChangePassthruTrap, mfrapPerfThruputPerDlciTxUtilizationStatus=mfrapPerfThruputPerDlciTxUtilizationStatus, mfrapSysRDOSupported=mfrapSysRDOSupported, mfrapCfgFrLmiType=mfrapCfgFrLmiType, mfrapPerfRoutingTotalRxRip=mfrapPerfRoutingTotalRxRip, mfrapPerfNetwLongTermAltProtocol=mfrapPerfNetwLongTermAltProtocol, mfrapPerfArpTotalRxRarpReq=mfrapPerfArpTotalRxRarpReq, mfrapPerfRoutingPerDlciTxRip=mfrapPerfRoutingPerDlciTxRip, mfrapDandiCurrentBESs=mfrapDandiCurrentBESs, mfrapTrapMutingActive=mfrapTrapMutingActive, mfrapPerfIpTotalRxIcmp=mfrapPerfIpTotalRxIcmp, mfrapDLCIInactiveTrap=mfrapDLCIInactiveTrap, mfrapPerfNetwProtoPerDlciRxAnnexG=mfrapPerfNetwProtoPerDlciRxAnnexG, mfrapStatusDandiModeLED=mfrapStatusDandiModeLED, mfrapPerfIcmpTotalRxEchoReq=mfrapPerfIcmpTotalRxEchoReq, mfrapPerfCirRxPercentUtilizationRange7=mfrapPerfCirRxPercentUtilizationRange7, mfrapPerfIpxPerDlciValue=mfrapPerfIpxPerDlciValue, mfrapCfgFrPerfLTDlciFilterDlciNum=mfrapCfgFrPerfLTDlciFilterDlciNum, mfrapCfgFrDLCIEncap=mfrapCfgFrDLCIEncap, mfrapPerfIcmpTotalInterval=mfrapPerfIcmpTotalInterval, mfrapPerfIcmpTotalTxSrcQuench=mfrapPerfIcmpTotalTxSrcQuench, mfrapTftpNoFileTrap=mfrapTftpNoFileTrap, mfrapSysSerialNo=mfrapSysSerialNo, mfrapCfgFrCrcMode=mfrapCfgFrCrcMode, mfrapCfgCliPassword=mfrapCfgCliPassword, mfrapPerfThruputPerIntfTable=mfrapPerfThruputPerIntfTable, mfrapStatusDteMode=mfrapStatusDteMode, mfrapT1CurrentSEFSs=mfrapT1CurrentSEFSs, mfrapDandiIntervalSESs=mfrapDandiIntervalSESs, mfrapPerfMgmtIp=mfrapPerfMgmtIp, mfrapPerfApplicationTotalRxCustom3=mfrapPerfApplicationTotalRxCustom3, mfrapVnipTopoTDNumSamples=mfrapVnipTopoTDNumSamples, mfrapPerfMgmtIpIPStatsTable=mfrapPerfMgmtIpIPStatsTable, mfrapPerfCurrentAggregateUtilization=mfrapPerfCurrentAggregateUtilization, mfrapDiagDteSigRTS=mfrapDiagDteSigRTS, mfrapT1TotalSESs=mfrapT1TotalSESs, mfrapDandiIntervalLCVs=mfrapDandiIntervalLCVs, mfrapPerfNetwLongTermEntry=mfrapPerfNetwLongTermEntry, mfrapNestFanTwoAlarmClear=mfrapNestFanTwoAlarmClear, mfrapDiagDteRmtV54Lpbk=mfrapDiagDteRmtV54Lpbk, mfrapCsuLoopbackEnabledTrap=mfrapCsuLoopbackEnabledTrap, mfrapPerfRoutingTotalTxOspf=mfrapPerfRoutingTotalTxOspf, mfrapPerfNetwProtoPerDlciInterval=mfrapPerfNetwProtoPerDlciInterval, mfrapVbertStopped=mfrapVbertStopped, mfrapV54LoopbackFailedTrap=mfrapV54LoopbackFailedTrap, mfrapPerfDandiIntervalTable=mfrapPerfDandiIntervalTable, mfrapt1netwcarrierloss=mfrapt1netwcarrierloss, mfrapPerfApplicationTotalTxTftp=mfrapPerfApplicationTotalTxTftp, mfrapPerfNetwLongTermAltEntry=mfrapPerfNetwLongTermAltEntry, mfrapDandiIntervalIndex=mfrapDandiIntervalIndex, mfrapSystem=mfrapSystem, mfrapPerfApplicationPerDlciRxCustom1=mfrapPerfApplicationPerDlciRxCustom1, mfrapDandiYellowAlarmDetect=mfrapDandiYellowAlarmDetect, mfrapPerfNetwProtoTotalRxAnnexG=mfrapPerfNetwProtoTotalRxAnnexG, mfrapDandiTotalIndex=mfrapDandiTotalIndex, mfrapPerfSnaTotalTxPeriph=mfrapPerfSnaTotalTxPeriph, mfrapPerfIpPerDlciTxTotal=mfrapPerfIpPerDlciTxTotal, mfrapVnipTopoVBERTStatus=mfrapVnipTopoVBERTStatus, mfrapStatusNestTable=mfrapStatusNestTable, mfrapPerfSnaPerDlciRxAppn=mfrapPerfSnaPerDlciRxAppn, mfrapCfgT1Table=mfrapCfgT1Table, mfrapPerfCurrentPerDlciUtilizationTable=mfrapPerfCurrentPerDlciUtilizationTable, mfrapPerfIpxTotalTxSpx=mfrapPerfIpxTotalTxSpx, mfrapPerfMgmtIpICMPInMsgs=mfrapPerfMgmtIpICMPInMsgs, mfrapEventTrapLogEntry=mfrapEventTrapLogEntry, mfrapPerfThruputPerDlciRxFecn=mfrapPerfThruputPerDlciRxFecn, mfrapT1IntervalEntry=mfrapT1IntervalEntry, mfrapSysPPPSupported=mfrapSysPPPSupported, mfrapPerfThruputPerDlciAvailability=mfrapPerfThruputPerDlciAvailability, mfrapPerfApplicationTotalTxHttp=mfrapPerfApplicationTotalTxHttp, mfrapPerfApplicationPerDlciTxTelnet=mfrapPerfApplicationPerDlciTxTelnet, mfrapPerfApplicationTotalRxSnmpTrap=mfrapPerfApplicationTotalRxSnmpTrap, mfrapPerfIpxPerDlciTable=mfrapPerfIpxPerDlciTable, mfrapPerfThruputPerDlciTxThruput=mfrapPerfThruputPerDlciTxThruput, mfrapT1IntervalBESs=mfrapT1IntervalBESs, mfrapCfgDteStartDs0=mfrapCfgDteStartDs0, mfrapPerfLmiPerDlciTxFullStatByteCnt=mfrapPerfLmiPerDlciTxFullStatByteCnt, mfrapPerfNetwProtoTotalRxTotal=mfrapPerfNetwProtoTotalRxTotal, mfrapCfgT1Framing=mfrapCfgT1Framing, mfrapPerfArpPerDlciTxInarpRep=mfrapPerfArpPerDlciTxInarpRep, mfrapPerfIpTotalRxTcp=mfrapPerfIpTotalRxTcp, mfrapPerfArpTotalTxInarpReq=mfrapPerfArpTotalTxInarpReq)
mibBuilder.exportSymbols("MFRAP-MIB", mfrapStatusDteRts=mfrapStatusDteRts, mfrapT1CurrentESs=mfrapT1CurrentESs, mfrapPerfIpPerDlciRxOther=mfrapPerfIpPerDlciRxOther, mfrapPerfNetwProtoPerDlciTxVnip=mfrapPerfNetwProtoPerDlciTxVnip, mfrapPerfCurrentPerDlciTxUtilization=mfrapPerfCurrentPerDlciTxUtilization, mfrapSysNumUserProtocols=mfrapSysNumUserProtocols, mfrapVnipTopoTDMinDelay=mfrapVnipTopoTDMinDelay, mfrapPerfIcmpTotalRxTimeExcd=mfrapPerfIcmpTotalRxTimeExcd, mfrapPerfLmiTotalRxTotalByteCnt=mfrapPerfLmiTotalRxTotalByteCnt, mfrapCfgCurrentConnDestPort=mfrapCfgCurrentConnDestPort, mfrapEventLogAltSeqNum=mfrapEventLogAltSeqNum, mfrapVnipTopoTDLastDelay=mfrapVnipTopoTDLastDelay, mfrapCfgFrPerfDlciNamesDelete=mfrapCfgFrPerfDlciNamesDelete, mfrapSysSLIPSupported=mfrapSysSLIPSupported, mfrapPerfNetworkLongTerm=mfrapPerfNetworkLongTerm)

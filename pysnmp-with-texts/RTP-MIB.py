#
# PySNMP MIB module RTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:58:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, TimeTicks, Bits, iso, Counter32, IpAddress, MibIdentifier, Integer32, NotificationType, Gauge32, mib_2, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "TimeTicks", "Bits", "iso", "Counter32", "IpAddress", "MibIdentifier", "Integer32", "NotificationType", "Gauge32", "mib-2", "Unsigned32")
TAddress, DisplayString, RowStatus, TDomain, TimeStamp, TestAndIncr, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TAddress", "DisplayString", "RowStatus", "TDomain", "TimeStamp", "TestAndIncr", "TruthValue", "TextualConvention")
Utf8String, = mibBuilder.importSymbols("SYSAPPL-MIB", "Utf8String")
rtpMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 87))
rtpMIB.setRevisions(('2000-10-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rtpMIB.setRevisionsDescriptions(('Initial version of this MIB. Published as RFC 2959.',))
if mibBuilder.loadTexts: rtpMIB.setLastUpdated('200010020000Z')
if mibBuilder.loadTexts: rtpMIB.setOrganization('IETF AVT Working Group Email: rem-conf@es.net')
if mibBuilder.loadTexts: rtpMIB.setContactInfo('Mark Baugher Postal: Intel Corporation 2111 NE 25th Avenue Hillsboro, OR 97124 United States Tel: +1 503 466 8406 Email: mbaugher@passedge.com Bill Strahm Postal: Intel Corporation 2111 NE 25th Avenue Hillsboro, OR 97124 United States Tel: +1 503 264 4632 Email: bill.strahm@intel.com Irina Suconick Postal: Ennovate Networks 60 Codman Hill Rd., Boxboro, Ma 01719 Tel: +1 781-505-2155 Email: irina@ennovatenetworks.com')
if mibBuilder.loadTexts: rtpMIB.setDescription("The managed objects of RTP systems. The MIB is structured around three types of information. 1. General information about RTP sessions such as the session address. 2. Information about RTP streams being sent to an RTP session by a particular sender. 3. Information about RTP streams received on an RTP session by a particular receiver from a particular sender. There are two types of RTP Systems, RTP hosts and RTP monitors. As described below, certain objects are unique to a particular type of RTP System. An RTP host may also function as an RTP monitor. Refer to RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' section 3.0, for definitions.")
rtpMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 87, 1))
rtpConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 87, 2))
rtpSessionNewIndex = MibScalar((1, 3, 6, 1, 2, 1, 87, 1, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtpSessionNewIndex.setStatus('current')
if mibBuilder.loadTexts: rtpSessionNewIndex.setDescription("This object is used to assign values to rtpSessionIndex as described in 'Textual Conventions for SMIv2'. For an RTP system that supports the creation of rows, the network manager would read the object, and then write the value back in the Set that creates a new instance of rtpSessionEntry. If the Set fails with the code 'inconsistentValue,' then the process must be repeated; If the Set succeeds, then the object is incremented, and the new instance is created according to the manager's directions. However, if the RTP agent is not acting as a monitor, only the RTP agent may create conceptual rows in the RTP session table.")
rtpSessionInverseTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 2), )
if mibBuilder.loadTexts: rtpSessionInverseTable.setStatus('current')
if mibBuilder.loadTexts: rtpSessionInverseTable.setDescription('Maps rtpSessionDomain, rtpSessionRemAddr, and rtpSessionLocAddr TAddress pairs to one or more rtpSessionIndex values, each describing a row in the rtpSessionTable. This makes it possible to retrieve the row(s) in the rtpSessionTable corresponding to a given session without having to walk the entire (potentially large) table.')
rtpSessionInverseEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 2, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionDomain"), (0, "RTP-MIB", "rtpSessionRemAddr"), (0, "RTP-MIB", "rtpSessionLocAddr"), (0, "RTP-MIB", "rtpSessionIndex"))
if mibBuilder.loadTexts: rtpSessionInverseEntry.setStatus('current')
if mibBuilder.loadTexts: rtpSessionInverseEntry.setDescription('Each entry corresponds to exactly one entry in the rtpSessionTable - the entry containing the tuple, rtpSessionDomain, rtpSessionRemAddr, rtpSessionLocAddr and rtpSessionIndex.')
rtpSessionInverseStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 2, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionInverseStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpSessionInverseStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpSessionTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 3), )
if mibBuilder.loadTexts: rtpSessionTable.setStatus('current')
if mibBuilder.loadTexts: rtpSessionTable.setDescription("There's one entry in rtpSessionTable for each RTP session on which packets are being sent, received, and/or monitored.")
rtpSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 3, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionIndex"))
if mibBuilder.loadTexts: rtpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: rtpSessionEntry.setDescription("Data in rtpSessionTable uniquely identify an RTP session. A host RTP agent MUST create a read-only row for each session to which packets are being sent or received. Rows MUST be created by the RTP Agent at the start of a session when one or more senders or receivers are observed. Rows created by an RTP agent MUST be deleted when the session is over and there are no rtpRcvrEntry and no rtpSenderEntry for this session. An RTP session SHOULD be monitored to create management information on all RTP streams being sent or received when the rtpSessionMonitor has the TruthValue of 'true(1)'. An RTP monitor SHOULD permit row creation with the side effect of causing the RTP System to join the multicast session for the purposes of gathering management information (additional conceptual rows are created in the rtpRcvrTable and rtpSenderTable). Thus, rtpSessionTable rows SHOULD be created for RTP session monitoring purposes. Rows created by a management application SHOULD be deleted via SNMP operations by management applications. Rows created by management operations are deleted by management operations by setting rtpSessionRowStatus to 'destroy(6)'.")
rtpSessionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rtpSessionIndex.setStatus('current')
if mibBuilder.loadTexts: rtpSessionIndex.setDescription('The index of the conceptual row which is for SNMP purposes only and has no relation to any protocol value. There is no requirement that these rows are created or maintained sequentially.')
rtpSessionDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 2), TDomain()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtpSessionDomain.setStatus('current')
if mibBuilder.loadTexts: rtpSessionDomain.setDescription("The transport-layer protocol used for sending or receiving the stream of RTP data packets on this session. Cannot be changed if rtpSessionRowStatus is 'active'.")
rtpSessionRemAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 3), TAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtpSessionRemAddr.setStatus('current')
if mibBuilder.loadTexts: rtpSessionRemAddr.setDescription("The address to which RTP packets are sent by the RTP system. In an IP multicast RTP session, this is the single address used by all senders and receivers of RTP session data. In a unicast RTP session this is the unicast address of the remote RTP system. 'The destination address pair may be common for all participants, as in the case of IP multicast, or may be different for each, as in the case of individual unicast network address pairs.' See RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' sec. 3. The transport service is identified by rtpSessionDomain. For snmpUDPDomain, this is an IP address and even-numbered UDP Port with the RTCP being sent on the next higher odd-numbered port, see RFC 1889, sec. 5.")
rtpSessionLocAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 4), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionLocAddr.setStatus('current')
if mibBuilder.loadTexts: rtpSessionLocAddr.setDescription("The local address used by the RTP system. In an IP multicast RTP session, rtpSessionRemAddr will be the same IP multicast address as rtpSessionLocAddr. In a unicast RTP session, rtpSessionRemAddr and rtpSessionLocAddr will have different unicast addresses. See RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' sec. 3. The transport service is identified by rtpSessionDomain. For snmpUDPDomain, this is an IP address and even-numbered UDP Port with the RTCP being sent on the next higher odd-numbered port, see RFC 1889, sec. 5.")
rtpSessionIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 5), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtpSessionIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtpSessionIfIndex.setDescription("The ifIndex value is set to the corresponding value from IF-MIB (See RFC 2233, 'The Interfaces Group MIB using SMIv2'). This is the interface that the RTP stream is being sent to or received from, or in the case of an RTP Monitor the interface that RTCP packets will be received on. Cannot be changed if rtpSessionRowStatus is 'active'.")
rtpSessionSenderJoins = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionSenderJoins.setStatus('current')
if mibBuilder.loadTexts: rtpSessionSenderJoins.setDescription("The number of senders that have been observed to have joined the session since this conceptual row was created (rtpSessionStartTime). A sender 'joins' an RTP session by sending to it. Senders that leave and then re-join following an RTCP BYE (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' sec. 6.6) or session timeout may be counted twice. Every time a new RTP sender is detected either using RTP or RTCP, this counter is incremented.")
rtpSessionReceiverJoins = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionReceiverJoins.setStatus('current')
if mibBuilder.loadTexts: rtpSessionReceiverJoins.setDescription("The number of receivers that have been been observed to have joined this session since this conceptual row was created (rtpSessionStartTime). A receiver 'joins' an RTP session by sending RTCP Receiver Reports to the session. Receivers that leave and then re-join following an RTCP BYE (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' sec. 6.6) or session timeout may be counted twice.")
rtpSessionByes = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionByes.setStatus('current')
if mibBuilder.loadTexts: rtpSessionByes.setDescription("A count of RTCP BYE (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications,' sec. 6.6) messages received by this entity.")
rtpSessionStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpSessionStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpSessionMonitor = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSessionMonitor.setStatus('current')
if mibBuilder.loadTexts: rtpSessionMonitor.setDescription("Boolean, Set to 'true(1)' if remote senders or receivers in addition to the local RTP System are to be monitored using RTCP. RTP Monitors MUST initialize to 'true(1)' and RTP Hosts SHOULD initialize this 'false(2)'. Note that because 'host monitor' systems are receiving RTCP from their remote participants they MUST set this value to 'true(1)'.")
rtpSessionRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtpSessionRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtpSessionRowStatus.setDescription("Value of 'active' when RTP or RTCP messages are being sent or received by an RTP System. A newly-created conceptual row must have the all read-create objects initialized before becoming 'active'. A conceptual row that is in the 'notReady' or 'notInService' state MAY be removed after 5 minutes.")
rtpSenderInverseTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 4), )
if mibBuilder.loadTexts: rtpSenderInverseTable.setStatus('current')
if mibBuilder.loadTexts: rtpSenderInverseTable.setDescription('Maps rtpSenderAddr, rtpSessionIndex, to the rtpSenderSSRC index of the rtpSenderTable. This table allows management applications to find entries sorted by rtpSenderAddr rather than sorted by rtpSessionIndex. Given the rtpSessionDomain and rtpSenderAddr, a set of rtpSessionIndex and rtpSenderSSRC values can be returned from a tree walk. When rtpSessionIndex is specified in the SNMP Get-Next operations, one or more rtpSenderSSRC values may be returned.')
rtpSenderInverseEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 4, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionDomain"), (0, "RTP-MIB", "rtpSenderAddr"), (0, "RTP-MIB", "rtpSessionIndex"), (0, "RTP-MIB", "rtpSenderSSRC"))
if mibBuilder.loadTexts: rtpSenderInverseEntry.setStatus('current')
if mibBuilder.loadTexts: rtpSenderInverseEntry.setDescription('Each entry corresponds to exactly one entry in the rtpSenderTable - the entry containing the index pair, rtpSessionIndex, rtpSenderSSRC.')
rtpSenderInverseStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 4, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderInverseStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpSenderInverseStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpSenderTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 5), )
if mibBuilder.loadTexts: rtpSenderTable.setStatus('current')
if mibBuilder.loadTexts: rtpSenderTable.setDescription("Table of information about a sender or senders to an RTP Session. RTP sending hosts MUST have an entry in this table for each stream being sent. RTP receiving hosts MAY have an entry in this table for each sending stream being received by this host. RTP monitors MUST create an entry for each observed sender to a multicast RTP Session as a side-effect when a conceptual row in the rtpSessionTable is made 'active' by a manager.")
rtpSenderEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 5, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionIndex"), (0, "RTP-MIB", "rtpSenderSSRC"))
if mibBuilder.loadTexts: rtpSenderEntry.setStatus('current')
if mibBuilder.loadTexts: rtpSenderEntry.setDescription("Each entry contains information from a single RTP Sender Synchronization Source (SSRC, see RFC 1889 'RTP: A Transport Protocol for Real-Time Applications' sec.6). The session is identified to the the SNMP entity by rtpSessionIndex. Rows are removed by the RTP agent when a BYE is received from the sender or when the sender times out (see RFC 1889, Sec. 6.2.1) or when the rtpSessionEntry is deleted.")
rtpSenderSSRC = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: rtpSenderSSRC.setStatus('current')
if mibBuilder.loadTexts: rtpSenderSSRC.setDescription("The RTP SSRC, or synchronization source identifier of the sender. The RTP session address plus an SSRC uniquely identify a sender to an RTP session (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec.3).")
rtpSenderCNAME = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 2), Utf8String()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderCNAME.setStatus('current')
if mibBuilder.loadTexts: rtpSenderCNAME.setDescription('The RTP canonical name of the sender.')
rtpSenderAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 3), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderAddr.setStatus('current')
if mibBuilder.loadTexts: rtpSenderAddr.setDescription('The unicast transport source address of the sender. In the case of an RTP Monitor this address is the address that the sender is using to send its RTCP Sender Reports.')
rtpSenderPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderPackets.setStatus('current')
if mibBuilder.loadTexts: rtpSenderPackets.setDescription('Count of RTP packets sent by this sender, or observed by an RTP monitor, since rtpSenderStartTime.')
rtpSenderOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderOctets.setStatus('current')
if mibBuilder.loadTexts: rtpSenderOctets.setDescription('Count of non-header RTP octets sent by this sender, or observed by an RTP monitor, since rtpSenderStartTime.')
rtpSenderTool = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 6), Utf8String().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderTool.setStatus('current')
if mibBuilder.loadTexts: rtpSenderTool.setDescription('Name of the application program source of the stream.')
rtpSenderSRs = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderSRs.setStatus('current')
if mibBuilder.loadTexts: rtpSenderSRs.setDescription('A count of the number of RTCP Sender Reports that have been sent from this sender, or observed if the RTP entity is a monitor, since rtpSenderStartTime.')
rtpSenderSRTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderSRTime.setStatus('current')
if mibBuilder.loadTexts: rtpSenderSRTime.setDescription('rtpSenderSRTime is the value of SysUpTime at the time that the last SR was received from this sender, in the case of a monitor or receiving host. Or sent by this sender, in the case of a sending host.')
rtpSenderPT = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderPT.setStatus('current')
if mibBuilder.loadTexts: rtpSenderPT.setDescription("Payload type from the RTP header of the most recently received RTP Packet (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec. 5).")
rtpSenderStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 5, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpSenderStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpSenderStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpRcvrInverseTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 6), )
if mibBuilder.loadTexts: rtpRcvrInverseTable.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrInverseTable.setDescription('Maps rtpRcvrAddr and rtpSessionIndex to the rtpRcvrSRCSSRC and rtpRcvrSSRC indexes of the rtpRcvrTable. This table allows management applications to find entries sorted by rtpRcvrAddr rather than by rtpSessionIndex. Given rtpSessionDomain and rtpRcvrAddr, a set of rtpSessionIndex, rtpRcvrSRCSSRC, and rtpRcvrSSRC values can be returned from a tree walk. When rtpSessionIndex is specified in SNMP Get-Next operations, one or more rtpRcvrSRCSSRC and rtpRcvrSSRC pairs may be returned.')
rtpRcvrInverseEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 6, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionDomain"), (0, "RTP-MIB", "rtpRcvrAddr"), (0, "RTP-MIB", "rtpSessionIndex"), (0, "RTP-MIB", "rtpRcvrSRCSSRC"), (0, "RTP-MIB", "rtpRcvrSSRC"))
if mibBuilder.loadTexts: rtpRcvrInverseEntry.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrInverseEntry.setDescription('Each entry corresponds to exactly one entry in the rtpRcvrTable - the entry containing the index pair, rtpSessionIndex, rtpRcvrSSRC.')
rtpRcvrInverseStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 6, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrInverseStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrInverseStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpRcvrTable = MibTable((1, 3, 6, 1, 2, 1, 87, 1, 7), )
if mibBuilder.loadTexts: rtpRcvrTable.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrTable.setDescription("Table of information about a receiver or receivers of RTP session data. RTP hosts that receive RTP session packets MUST create an entry in this table for that receiver/sender pair. RTP hosts that send RTP session packets MAY create an entry in this table for each receiver to their stream using RTCP feedback from the RTP group. RTP monitors create an entry for each observed RTP session receiver as a side effect when a conceptual row in the rtpSessionTable is made 'active' by a manager.")
rtpRcvrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 87, 1, 7, 1), ).setIndexNames((0, "RTP-MIB", "rtpSessionIndex"), (0, "RTP-MIB", "rtpRcvrSRCSSRC"), (0, "RTP-MIB", "rtpRcvrSSRC"))
if mibBuilder.loadTexts: rtpRcvrEntry.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrEntry.setDescription("Each entry contains information from a single RTP Synchronization Source that is receiving packets from the sender identified by rtpRcvrSRCSSRC (SSRC, see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec.6). The session is identified to the the RTP Agent entity by rtpSessionIndex. Rows are removed by the RTP agent when a BYE is received from the sender or when the sender times out (see RFC 1889, Sec. 6.2.1) or when the rtpSessionEntry is deleted.")
rtpRcvrSRCSSRC = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: rtpRcvrSRCSSRC.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrSRCSSRC.setDescription("The RTP SSRC, or synchronization source identifier of the sender. The RTP session address plus an SSRC uniquely identify a sender or receiver of an RTP stream (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec.3).")
rtpRcvrSSRC = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 2), Unsigned32())
if mibBuilder.loadTexts: rtpRcvrSSRC.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrSSRC.setDescription("The RTP SSRC, or synchronization source identifier of the receiver. The RTP session address plus an SSRC uniquely identify a receiver of an RTP stream (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec.3).")
rtpRcvrCNAME = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 3), Utf8String()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrCNAME.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrCNAME.setDescription('The RTP canonical name of the receiver.')
rtpRcvrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 4), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrAddr.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrAddr.setDescription('The unicast transport address on which the receiver is receiving RTP packets and/or RTCP Receiver Reports.')
rtpRcvrRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrRTT.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrRTT.setDescription("The round trip time measurement taken by the source of the RTP stream based on the algorithm described on sec. 6 of RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications.' This algorithm can produce meaningful results when the RTP agent has the same clock as the stream sender (when the RTP monitor is also the sending host for the particular receiver). Otherwise, the entity should return 'noSuchInstance' in response to queries against rtpRcvrRTT.")
rtpRcvrLostPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrLostPackets.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrLostPackets.setDescription('A count of RTP packets lost as observed by this receiver since rtpRcvrStartTime.')
rtpRcvrJitter = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrJitter.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrJitter.setDescription("An estimate of delay variation as observed by this receiver. (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec.6.3.1 and A.8).")
rtpRcvrTool = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 8), Utf8String().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrTool.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrTool.setDescription('Name of the application program source of the stream.')
rtpRcvrRRs = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrRRs.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrRRs.setDescription('A count of the number of RTCP Receiver Reports that have been sent from this receiver, or observed if the RTP entity is a monitor, since rtpRcvrStartTime.')
rtpRcvrRRTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrRRTime.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrRRTime.setDescription('rtpRcvrRRTime is the value of SysUpTime at the time that the last RTCP Receiver Report was received from this receiver, in the case of a monitor or RR receiver (the RTP Sender). It is the value of SysUpTime at the time that the last RR was sent by this receiver in the case of an RTP receiver sending the RR.')
rtpRcvrPT = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrPT.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrPT.setDescription("Static or dynamic payload type from the RTP header (see RFC 1889, 'RTP: A Transport Protocol for Real-Time Applications' sec. 5).")
rtpRcvrPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrPackets.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrPackets.setDescription('Count of RTP packets received by this RTP host receiver since rtpRcvrStartTime.')
rtpRcvrOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrOctets.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrOctets.setDescription('Count of non-header RTP octets received by this receiving RTP host since rtpRcvrStartTime.')
rtpRcvrStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 87, 1, 7, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpRcvrStartTime.setStatus('current')
if mibBuilder.loadTexts: rtpRcvrStartTime.setDescription('The value of SysUpTime at the time that this row was created.')
rtpGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 87, 2, 1))
rtpSystemGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 87, 2, 1, 1)).setObjects(("RTP-MIB", "rtpSessionDomain"), ("RTP-MIB", "rtpSessionRemAddr"), ("RTP-MIB", "rtpSessionIfIndex"), ("RTP-MIB", "rtpSessionSenderJoins"), ("RTP-MIB", "rtpSessionReceiverJoins"), ("RTP-MIB", "rtpSessionStartTime"), ("RTP-MIB", "rtpSessionByes"), ("RTP-MIB", "rtpSessionMonitor"), ("RTP-MIB", "rtpSenderCNAME"), ("RTP-MIB", "rtpSenderAddr"), ("RTP-MIB", "rtpSenderPackets"), ("RTP-MIB", "rtpSenderOctets"), ("RTP-MIB", "rtpSenderTool"), ("RTP-MIB", "rtpSenderSRs"), ("RTP-MIB", "rtpSenderSRTime"), ("RTP-MIB", "rtpSenderStartTime"), ("RTP-MIB", "rtpRcvrCNAME"), ("RTP-MIB", "rtpRcvrAddr"), ("RTP-MIB", "rtpRcvrLostPackets"), ("RTP-MIB", "rtpRcvrJitter"), ("RTP-MIB", "rtpRcvrTool"), ("RTP-MIB", "rtpRcvrRRs"), ("RTP-MIB", "rtpRcvrRRTime"), ("RTP-MIB", "rtpRcvrStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpSystemGroup = rtpSystemGroup.setStatus('current')
if mibBuilder.loadTexts: rtpSystemGroup.setDescription('Objects available to all RTP Systems.')
rtpHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 87, 2, 1, 2)).setObjects(("RTP-MIB", "rtpSessionLocAddr"), ("RTP-MIB", "rtpSenderPT"), ("RTP-MIB", "rtpRcvrPT"), ("RTP-MIB", "rtpRcvrRTT"), ("RTP-MIB", "rtpRcvrOctets"), ("RTP-MIB", "rtpRcvrPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpHostGroup = rtpHostGroup.setStatus('current')
if mibBuilder.loadTexts: rtpHostGroup.setDescription('Objects that are available to RTP Host systems, but may not be available to RTP Monitor systems.')
rtpMonitorGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 87, 2, 1, 3)).setObjects(("RTP-MIB", "rtpSessionNewIndex"), ("RTP-MIB", "rtpSessionRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpMonitorGroup = rtpMonitorGroup.setStatus('current')
if mibBuilder.loadTexts: rtpMonitorGroup.setDescription('Objects used to create rows in the RTP Session Table. These objects are not needed if the system does not create rows.')
rtpInverseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 87, 2, 1, 4)).setObjects(("RTP-MIB", "rtpSessionInverseStartTime"), ("RTP-MIB", "rtpSenderInverseStartTime"), ("RTP-MIB", "rtpRcvrInverseStartTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpInverseGroup = rtpInverseGroup.setStatus('current')
if mibBuilder.loadTexts: rtpInverseGroup.setDescription('Objects used in the Inverse Lookup Tables.')
rtpCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 87, 2, 2))
rtpHostCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 87, 2, 2, 1)).setObjects(("RTP-MIB", "rtpSystemGroup"), ("RTP-MIB", "rtpHostGroup"), ("RTP-MIB", "rtpMonitorGroup"), ("RTP-MIB", "rtpInverseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpHostCompliance = rtpHostCompliance.setStatus('current')
if mibBuilder.loadTexts: rtpHostCompliance.setDescription('Host implementations MUST comply.')
rtpMonitorCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 87, 2, 2, 2)).setObjects(("RTP-MIB", "rtpSystemGroup"), ("RTP-MIB", "rtpMonitorGroup"), ("RTP-MIB", "rtpHostGroup"), ("RTP-MIB", "rtpInverseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtpMonitorCompliance = rtpMonitorCompliance.setStatus('current')
if mibBuilder.loadTexts: rtpMonitorCompliance.setDescription('Monitor implementations must comply. RTP Monitors are not required to support creation or deletion.')
mibBuilder.exportSymbols("RTP-MIB", rtpSessionInverseTable=rtpSessionInverseTable, rtpSessionReceiverJoins=rtpSessionReceiverJoins, rtpSenderOctets=rtpSenderOctets, rtpRcvrSRCSSRC=rtpRcvrSRCSSRC, rtpRcvrJitter=rtpRcvrJitter, rtpSystemGroup=rtpSystemGroup, PYSNMP_MODULE_ID=rtpMIB, rtpSessionTable=rtpSessionTable, rtpSenderSSRC=rtpSenderSSRC, rtpRcvrPT=rtpRcvrPT, rtpSessionDomain=rtpSessionDomain, rtpHostGroup=rtpHostGroup, rtpGroups=rtpGroups, rtpMonitorCompliance=rtpMonitorCompliance, rtpRcvrRRTime=rtpRcvrRRTime, rtpRcvrSSRC=rtpRcvrSSRC, rtpSessionSenderJoins=rtpSessionSenderJoins, rtpSessionIfIndex=rtpSessionIfIndex, rtpMIBObjects=rtpMIBObjects, rtpRcvrCNAME=rtpRcvrCNAME, rtpSessionInverseEntry=rtpSessionInverseEntry, rtpInverseGroup=rtpInverseGroup, rtpHostCompliance=rtpHostCompliance, rtpSessionIndex=rtpSessionIndex, rtpRcvrInverseTable=rtpRcvrInverseTable, rtpSenderSRTime=rtpSenderSRTime, rtpRcvrRTT=rtpRcvrRTT, rtpRcvrAddr=rtpRcvrAddr, rtpSessionRowStatus=rtpSessionRowStatus, rtpSenderInverseTable=rtpSenderInverseTable, rtpCompliances=rtpCompliances, rtpSenderSRs=rtpSenderSRs, rtpRcvrLostPackets=rtpRcvrLostPackets, rtpMonitorGroup=rtpMonitorGroup, rtpSessionMonitor=rtpSessionMonitor, rtpSenderPackets=rtpSenderPackets, rtpSenderInverseStartTime=rtpSenderInverseStartTime, rtpSessionLocAddr=rtpSessionLocAddr, rtpSessionNewIndex=rtpSessionNewIndex, rtpSessionRemAddr=rtpSessionRemAddr, rtpMIB=rtpMIB, rtpSenderTool=rtpSenderTool, rtpRcvrRRs=rtpRcvrRRs, rtpSenderStartTime=rtpSenderStartTime, rtpSessionInverseStartTime=rtpSessionInverseStartTime, rtpSessionEntry=rtpSessionEntry, rtpSenderTable=rtpSenderTable, rtpSenderInverseEntry=rtpSenderInverseEntry, rtpRcvrTable=rtpRcvrTable, rtpRcvrTool=rtpRcvrTool, rtpRcvrPackets=rtpRcvrPackets, rtpSenderPT=rtpSenderPT, rtpRcvrStartTime=rtpRcvrStartTime, rtpRcvrInverseStartTime=rtpRcvrInverseStartTime, rtpSessionStartTime=rtpSessionStartTime, rtpRcvrEntry=rtpRcvrEntry, rtpRcvrInverseEntry=rtpRcvrInverseEntry, rtpSenderEntry=rtpSenderEntry, rtpRcvrOctets=rtpRcvrOctets, rtpConformance=rtpConformance, rtpSenderAddr=rtpSenderAddr, rtpSenderCNAME=rtpSenderCNAME, rtpSessionByes=rtpSessionByes)

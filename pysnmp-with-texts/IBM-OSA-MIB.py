#
# PySNMP MIB module IBM-OSA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-OSA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Integer32, Gauge32, NotificationType, iso, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, TimeTicks, ModuleIdentity, MibIdentifier, enterprises, Counter64, Unsigned32, IpAddress, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Gauge32", "NotificationType", "iso", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "TimeTicks", "ModuleIdentity", "MibIdentifier", "enterprises", "Counter64", "Unsigned32", "IpAddress", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ibmOSAMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2, 6, 188))
ibmOSAMib.setRevisions(('2002-05-23 00:00', '2002-03-26 08:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ibmOSAMib.setRevisionsDescriptions(('Editorial revisions', 'Initial release',))
if mibBuilder.loadTexts: ibmOSAMib.setLastUpdated('200205230000Z')
if mibBuilder.loadTexts: ibmOSAMib.setOrganization('IBM eServer Development')
if mibBuilder.loadTexts: ibmOSAMib.setContactInfo(' Joel Goldman Postal: International Business Machines Corporation 2455 South Road Dept. B44G/Bldg. 706 Poughkeepsie, NY 12601 USA Tel: +1 845 435 5501 Internet: jgoldman@us.ibm.com')
if mibBuilder.loadTexts: ibmOSAMib.setDescription('The IBM Enterprise Specific MIB definitions for enabling management of an IBM OSA-Express feature. Licensed Materials - Property of IBM Restricted Materials of IBM 5694-A01 (C) Copyright IBM Corp. 2002 US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.')
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibmOSAMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 188, 1))
ibmOSAMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 188, 2))
ibmOSAExpChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1), )
if mibBuilder.loadTexts: ibmOSAExpChannelTable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelTable.setDescription('Indexed by ifIndex. One entry in this table will exist per OSA Device Interface.')
ibmOSAExpChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpChannelEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelEntry.setDescription('Definition of a single entry in the ibmOSAExpChannelTable. Indexed by the ifIndex of the corresponding Device interface.')
ibmOSAExpChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelNumber.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelNumber.setDescription('The CHPID corresponding to this ifIndex.')
ibmOSAExpChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(17))).clone(namedValues=NamedValues(("osaDirectExpress", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelType.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelType.setDescription('The type of channel for this interface. OSA Direct Express has a value of 17.')
ibmOSAExpChannelHdwLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("osaExp150", 2), ("osaExp175", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelHdwLevel.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelHdwLevel.setDescription('Hardware model of the channel. The value oasExp150(2) indicates a hardware level of 1.50. The value oasExp175(3) indicates a hardware level of 1.75.')
ibmOSAExpChannelSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 65, 81, 82, 2304))).clone(namedValues=NamedValues(("unknown", 1), ("gigabitEthernet", 65), ("fastEthernet", 81), ("tokenRing", 82), ("atmEmulatedEthernet", 2304)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelSubType.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelSubType.setDescription('Indicates the type of OSA feature present.')
ibmOSAExpChannelShared = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notShared", 0), ("shared", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelShared.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelShared.setDescription('An OSA-Express feature can be shared across multiple LPs. This object indicates if this feature is currently being shared between LPs')
ibmOSAExpChannelNodeDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelNodeDesc.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelNodeDesc.setDescription("This is the Node Descriptor of the OSA feature. It represents the ND obtained from the Channel Subsystem. Bits Name Flag is first byte char(1) Validity Valid - always '20'x char(1) Reserved Reserved by architecture char(1) Class Class for subsystem node char(1) CHPID CHP ID for specified int char(6) TypeNum Type number of the SDC char(3) ModelNum Model number in the form of 3 EBCDIC OCTETS char(3) Manufacturer Manufacturer in the form of 3 EBCDIC OCTETS char(2) Mfr Plant Plant of manufacture-2 digit code char(12)SeqNum Sequence number (12 EBCDIC OCTETS) char(2) Tag Tag")
ibmOSAExpChannelProcCodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelProcCodeLevel.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelProcCodeLevel.setDescription('This is the firmware (or micro code level) of the OSA feature. For example, OSA code level 05.6A would be represented as 0x056A.')
ibmOSAExpChannelPCIBusUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtil1Min.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtil1Min.setDescription('The average, over a 1 minute interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%.')
ibmOSAExpChannelProcUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtil1Min.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtil1Min.setDescription('The average, over a 1 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%.')
ibmOSAExpChannelPCIBusUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtil5Min.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtil5Min.setDescription('The average, over a 5 minute interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%.')
ibmOSAExpChannelProcUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtil5Min.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtil5Min.setDescription('The average, over a 5 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%.')
ibmOSAExpChannelPCIBusUtilHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtilHour.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelPCIBusUtilHour.setDescription('The average, over an hour interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks.')
ibmOSAExpChannelProcUtilHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtilHour.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelProcUtilHour.setDescription('The average, over an hour interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%.')
ibmOSAExpPerfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2), )
if mibBuilder.loadTexts: ibmOSAExpPerfTable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfTable.setDescription('This table provides performance information for each Logical Partition (LP) the OSA can connect to.')
ibmOSAExpPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpPerfEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfEntry.setDescription('Definition of a single entry for a single LP in the ibmOSAExpPerfTable. Indexed by the ifIndex of the corresponding Device interface.')
ibmOSAExpPerfDataLP0 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP0.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP0.setDescription('The performance data on this OSA for partition 0. The 40 bytes of hex data that are returned are decoded as follows: Offset Bytes Field Meaning 0 4 LP Number 4 4 Processor Util 1 Minute 8 4 In Kbytes Rate 1 Minute 12 4 Out Kbytes Rate 1 Minute 16 4 Processor Util 5 Minutes 20 4 In Kbytes Rate 5 Minutes 24 4 Out Kbytes Rate 5 Minutes 28 4 Processor Util 60 Minutes 32 4 In Kbytes Rate 60 Minutes 36 4 Out Kbytes Rate 60 Minutes The Processor Util 1 Minute is defined as follows: The average, over a 1 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data for a specific LP. It does not include idle time or time used by routine maintenance tasks. The range for this value is from 0 to 100%. The In Kbytes Rate 1 Minute is defined as follows: The average, over a 1 minute interval, of the number of inbound kilobytes processed for a specific LP. The Out Kbytes Rate 1 Minute is defined as follows: The average, over a 1 minute interval, of the number of outbound kilobytes processed for a specific LP. The 5 and 60 minute fields are defined similar to the 1 minute fields, but pertain to intervals of 5 and 60 minutes.')
ibmOSAExpPerfDataLP1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP1.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP1.setDescription('The performance data on this OSA for partition 1. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP2.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP2.setDescription('The performance data on this OSA for partition 2. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP3.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP3.setDescription('The performance data on this OSA for partition 3. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP4 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP4.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP4.setDescription('The performance data on this OSA for partition 4. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP5 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP5.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP5.setDescription('The performance data on this OSA for partition 5. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP6.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP6.setDescription('The performance data on this OSA for partition 6. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP7 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP7.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP7.setDescription('The performance data on this OSA for partition 7. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP8 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP8.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP8.setDescription('The performance data on this OSA for partition 8. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP9 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP9.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP9.setDescription('The performance data on this OSA for partition 9. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP10 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP10.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP10.setDescription('The performance data on this OSA for partition 10. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP11 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP11.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP11.setDescription('The performance data on this OSA for partition 11. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP12 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP12.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP12.setDescription('The performance data on this OSA for partition 12. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP13 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP13.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP13.setDescription('The performance data on this OSA for partition 13. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP14 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP14.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP14.setDescription('The performance data on this OSA for partition 14. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPerfDataLP15 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP15.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfDataLP15.setDescription('The performance data on this OSA for partition 15. The 40 bytes of hex data that are returned are decoded the same as for partition 0.')
ibmOSAExpPETable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3), )
if mibBuilder.loadTexts: ibmOSAExpPETable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPETable.setDescription('This table provides PE information to help IBM diagnose any OSA problems.')
ibmOSAExpPEEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpPEEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEEntry.setDescription('Definition of a single entry in the ibmOSAExpPETable. Indexed by the ifIndex of the corresponding Device interface')
ibmOSAExpPEMaxSizeArpCache = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEMaxSizeArpCache.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEMaxSizeArpCache.setDescription('The maximum size of the OSA ARP Cache')
ibmOSAExpPEArpPendingEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEArpPendingEntries.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEArpPendingEntries.setDescription('This is the number of Pending entries in the ARP cache.')
ibmOSAExpPEArpActiveEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEArpActiveEntries.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEArpActiveEntries.setDescription('This the number of active ARP entries.')
ibmOSAExpPEIPEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEIPEntries.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEIPEntries.setDescription('The number of IP addresses known to the OSA For OSD chpids, this is the maximum # of IP addresses that are: - home ip addresses (Version 4 and Version 6) - remote ip addresses in the arp cache (Version 4 only) - multicast ip addresses that the OSA must accept inbound data packets for (Version 4 and Version 6)')
ibmOSAExpPEMulticastEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEMulticastEntries.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEMulticastEntries.setDescription('This is the number of IP multicast addresses currently on the OSA')
ibmOSAExpPEMulticastData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3360, 3360)).setFixedLength(3360)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOSAExpPEMulticastData.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEMulticastData.setDescription('This contains information on the multicast entries that are currently on the OSA. These are in a format that is for IBM use only')
ibmOSAExpEthPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4), )
if mibBuilder.loadTexts: ibmOSAExpEthPortTable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpEthPortTable.setDescription('This table represents the data associated with a port on an OSA-Express Gigabit or Fast Ethernet OSA.')
ibmOSAExpEthPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpEthPortEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpEthPortEntry.setDescription('Definition of a single entry in the ibmOSAExpEthPortTable. Indexed by the ifIndex of the corresponding Device interface.')
ibmOsaExpEthPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthPortNumber.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthPortNumber.setDescription('The physical port number for this port.')
ibmOsaExpEthPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(65, 81))).clone(namedValues=NamedValues(("gigabitEthernet", 65), ("fastEthernet", 81)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthPortType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthPortType.setDescription('The physical port type.')
ibmOsaExpEthLanTrafficState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("undefined", 0), ("unavailable", 1), ("enabling", 2), ("disabling", 3), ("enabled", 4), ("disabled", 5), ("linkMonitor", 6), ("definitionError", 7), ("configuredOffline", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthLanTrafficState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthLanTrafficState.setDescription('The LAN state value ranges from 0 to 8. A value of 5, disabled is further explained in object ibmOsaExpEthDisabledStatus.')
ibmOsaExpEthServiceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notInServiceMode", 0), ("inServiceMode", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthServiceMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthServiceMode.setDescription('This object indicates if the processor is in service mode or not.')
ibmOsaExpEthDisabledStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 5), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("internalPortFailure", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("reserved5", 5), ("portTemporarilyDisabled", 6), ("reserved7", 7), ("reserved8", 8), ("serviceProcessorRequest", 9), ("networkRequest", 10), ("osasfRequest", 11), ("configurationChange", 12), ("linkFailureThresholdExceeded", 13), ("reserved14", 14), ("reserved15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthDisabledStatus.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthDisabledStatus.setDescription('When the value of ibmOsaExpEthLanTrafficState is NOT disabled, the value of this object will be zero. When the value of ibmOsaExpEthLanTrafficState is disabled(5), this object explains the reason for the disabled state. The value for this object may be a combination of the bits shown.')
ibmOsaExpEthConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 34))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthConfigName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthConfigName.setDescription('This is the name of the configuration that is on the OSA. It is set using OSA/SF. It is not used by OSA')
ibmOsaExpEthConfigSpeedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("notValidGigabit", -1), ("autoNegotiate", 0), ("tenMbHalfDuplex", 1), ("tenMbFullDuplex", 2), ("oneHundredMbHalfDuplex", 3), ("oneHundredMbFullDuplex", 4), ("oneThousandMbFullDuplex", 6)))).setUnits('Megabits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthConfigSpeedMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthConfigSpeedMode.setDescription('The configured port speed. This field shows the speed that was configured by the user for the OSA-Express Fast Ethernet feature. It is not used by OSA-Express Gigabit features and will return -1 (FFFF)')
ibmOsaExpEthActiveSpeedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("unknown", 0), ("tenMbHalfDuplex", 1), ("tenMbFullDuplex", 2), ("oneHundredMbHalfDuplex", 3), ("oneHundredMbFullDuplex", 4), ("oneThousandMbFullDuplex", 6)))).setUnits('Megabits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthActiveSpeedMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthActiveSpeedMode.setDescription('The actual speed and mode the OSA is running in')
ibmOsaExpEthMacAddrActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthMacAddrActive.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthMacAddrActive.setDescription('A 6 byte OCTET STRING which contains the current MAC address in use on the adapter. The values are in canonical format.')
ibmOsaExpEthMacAddrBurntIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthMacAddrBurntIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthMacAddrBurntIn.setDescription('A 6 byte OCTET STRING which contains the burned in MAC address on the OSA. The values are in canonical format.')
ibmOsaExpEthUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthUserData.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthUserData.setDescription('Data set by the user. It is ignored by the OSA.')
ibmOsaExpEthOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthOutPackets.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthOutPackets.setDescription('This is the number of packets that have been transmitted by the OSA since the last time the OSA port was reset')
ibmOsaExpEthInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthInPackets.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthInPackets.setDescription('This is the number of packets that have been received by the OSA since the last time the OSA port was reset')
ibmOsaExpEthInGroupFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthInGroupFrames.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthInGroupFrames.setDescription('This is the number of multicast frames that have been received by the OSA.')
ibmOsaExpEthInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthInBroadcastFrames.setDescription('This is the number of broadcast frames that have been received by the OSA.')
ibmOsaExpEthPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthPortName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthPortName.setDescription('Name of the port as used by TCP/IP')
ibmOsaExpEthInUnknownIPFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthInUnknownIPFrames.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthInUnknownIPFrames.setDescription('This is the number of non-IP received frames')
ibmOsaExpEthGroupAddrTable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 4, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpEthGroupAddrTable.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpEthGroupAddrTable.setDescription('This field contains the active Group Addresses. An individual Group Address is 6 bytes long with an additional 2 bytes of padding. There are 32 group addresses.')
ibmOSAExpTRPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5), )
if mibBuilder.loadTexts: ibmOSAExpTRPortTable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpTRPortTable.setDescription('This table represents the data associated with a port on an OSA-Express token ring feature.')
ibmOSAExpTRPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpTRPortEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpTRPortEntry.setDescription('Definition of a single entry in the ibmOSAExpTRPortTable. Indexed by the ifIndex of the corresponding Device interface.')
ibmOsaExpTRPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRPortNumber.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRPortNumber.setDescription('The physical port number for this port.')
ibmOsaExpTRPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(82))).clone(namedValues=NamedValues(("tokenring", 82)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRPortType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRPortType.setDescription('The physical port type.')
ibmOsaExpTRLanTrafficState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("undefined", 0), ("unavailable", 1), ("enabling", 2), ("disabling", 3), ("enabled", 4), ("disabled", 5), ("linkMonitor", 6), ("definitionError", 7), ("configuredOffline", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRLanTrafficState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRLanTrafficState.setDescription('The LAN state value ranges from 0 to 8. A value of 5, disabled is further explained in object ibmOsaExpTRDisabledStatus')
ibmOsaExpTRServiceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notInServiceMode", 0), ("inServiceMode", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRServiceMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRServiceMode.setDescription('This object indicates if the processor is in service mode or not.')
ibmOsaExpTRDisabledStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 5), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("internalPortFailure", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("reserved5", 5), ("portTemporarilyDisabled", 6), ("reserved7", 7), ("reserved8", 8), ("serviceProcessorRequest", 9), ("networkRequest", 10), ("osasfRequest", 11), ("configurationChange", 12), ("linkFailureThresholdExceeded", 13), ("reserved14", 14), ("reserved15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRDisabledStatus.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRDisabledStatus.setDescription('When the value of ibmOsaExpTRLanTrafficState is NOT disabled, the value of this object will be zero. When the value of ibmOsaExpTRLanTrafficState is disabled(5), this object explains the reason for the disabled state. The value for this object may be a combination of the bits shown.')
ibmOsaExpTRConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 34))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRConfigName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRConfigName.setDescription('This is the name of the configuration that is on the OSA. It is set using OSA/SF. It is not used by OSA')
ibmOsaExpTRMacAddrActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRMacAddrActive.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRMacAddrActive.setDescription('A 6 byte OCTET STRING which contains the current MAC address in use on the OSA.')
ibmOsaExpTRMacAddrBurntIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRMacAddrBurntIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRMacAddrBurntIn.setDescription('A 6 byte OCTET STRING which contains the burned in MAC address on the OSA')
ibmOsaExpTRConfigSpeedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("autoNegotiate", 0), ("fourMbHalfDuplex", 1), ("fourMbFullDuplex", 2), ("sixteenMbHalfDuplex", 3), ("sixteenMbFullDuplex", 4), ("oneHundredMbFullDuplex", 6)))).setUnits('Megabits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRConfigSpeedMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRConfigSpeedMode.setDescription('The configured port speed. This field shows the speed that was configured by the user for the OSA-Express Token Ring feature.')
ibmOsaExpTRActiveSpeedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("unknown", 0), ("fourMbHalfDuplex", 1), ("fourMbFullDuplex", 2), ("sixteenMbHalfDuplex", 3), ("sixteenMbFullDuplex", 4), ("oneHundredMbFullDuplex", 6)))).setUnits('Megabits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRActiveSpeedMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRActiveSpeedMode.setDescription('The actual speed and mode the OSA is running in')
ibmOsaExpTRUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRUserData.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRUserData.setDescription('Data set by the user. It is ignored by the OSA.')
ibmOsaExpTRPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRPortName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRPortName.setDescription('Name of the port as used by TCP/IP')
ibmOsaExpTRGroupAddrTable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRGroupAddrTable.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRGroupAddrTable.setDescription('This field contains the active Group Addresses. An individual Group Address is 6 bytes long with an additional 2 bytes of padding.')
ibmOsaExpTRFunctionalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRFunctionalAddr.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRFunctionalAddr.setDescription("A 4 byte OCTET STRING which contains the OSA-Express's functional address.")
ibmOsaExpTRRingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 15), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("reserved1", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8), ("reserved9", 9), ("reserved10", 10), ("reserved11", 11), ("reserved12", 12), ("reserved13", 13), ("noStatusOpenNotCompleted", 14), ("reserved15", 15), ("signalLoss", 16), ("hardError", 17), ("softError", 18), ("reserved19", 19), ("lobeWireFault", 20), ("autoRemovalError", 21), ("fdxProtocol", 22), ("removeReceived", 23), ("counterOverflow", 24), ("singleStation", 25), ("ringRecovery", 26), ("sRCounterOverflow", 27), ("reserved29", 28), ("openInFDXmode", 29), ("fourMbFullDuplex", 30), ("fourMbHalfDuplex", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRingStatus.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRingStatus.setDescription("The current interface status which can be used to diagnose fluctuating problems that can occur on token rings after a station has successfully been added to the ring. Before an open is completed, this object has the value for the 'noStatusOpenNotCompleted' condition. The ibmOsaExpTRRingState and ibmOsaExpTRRingOpenStatus objects provide for debugging problems when the station can not even enter the ring. The object's value is a sum of values, one for each currently applicable condition. This information is essentially from RFC 1231.")
ibmOsaExpTRAllowAccessPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRAllowAccessPriority.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRAllowAccessPriority.setDescription('This field contains the maximum token priority the ring station defined by this entry in the table is permitted to transmit.')
ibmOsaExpTREarlyTokenRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTREarlyTokenRelease.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTREarlyTokenRelease.setDescription('Indicates if the ring station supports early token release. Only valid when port is running in 16Mb half duplex mode. Otherwise it is always set to false (1)')
ibmOsaExpTRBeaconingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRBeaconingAddress.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRBeaconingAddress.setDescription('This field contains the node address of the NAUN as reported in the most recently received Beacon MAC frame. This field is valid when ibmOsaExpTRRingOpenStatus is set to beaconing. Otherwise it is ignored')
ibmOsaExpTRUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRUpstreamNeighbor.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRUpstreamNeighbor.setDescription('The MAC-address of the up stream neighbor station in the ring (NAUN).')
ibmOsaExpTRRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("opened", 1), ("closed", 2), ("opening", 3), ("closing", 4), ("openFailure", 5), ("ringFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRingState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRingState.setDescription('The current interface state with respect to entering or leaving the ring.')
ibmOsaExpTRRingOpenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26))).clone(namedValues=NamedValues(("noOpen", 1), ("badParameter", 2), ("lobeFailed", 3), ("signalLoss", 4), ("insertionTimeout", 5), ("ringFailed", 6), ("beaconing", 7), ("duplicateMAC", 8), ("requestFailed", 9), ("removeReceived", 10), ("open", 11), ("sARecFrameNotEqualNAUNs", 12), ("claimTokenRec", 13), ("ringPurgeFramRec", 14), ("activeMonPresRec", 15), ("standbyMonPresRec", 16), ("accessProtocolDenied", 17), ("fDXInsDeniedDACfailOnOpen", 18), ("fDXInsDeniedDACfailOnBeaconTest", 19), ("beaconBeforeOpen", 20), ("insertTimerExpDuringDAC", 21), ("insertTimerExpDuringBeaconTest", 22), ("lobeMedizTestFailure", 23), ("heartbeatFailBeforeOpenCompleted", 24), ("heartbeatFailDuringBeaconTest", 25), ("recBeaconFrameWithInvalidSA", 26)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRingOpenStatus.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRingOpenStatus.setDescription("This object indicates the success, or the reason for failure of the station's most recent attempt to enter the ring.")
ibmOsaExpTRPacketsTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 22), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRPacketsTransmitted.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRPacketsTransmitted.setDescription('This field contains the count of the total number of packets transmitted from this port since the OSA port was reset')
ibmOsaExpTRPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 23), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRPacketsReceived.setDescription('This field contains the count of the total number of packets received by this port since the OSA port was reset')
ibmOsaExpTRLineErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRLineErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRLineErrorCount.setDescription('This counter is incremented when a frame or token is copied or repeated by a station, the E bit is zero in the frame or token and one of the following conditions exists: 1) there is a non-data bit (J or K bit) between the SD and the ED of the frame or token, or 2) there is an FCS error in the frame.')
ibmOsaExpTRBurstErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRBurstErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRBurstErrorCount.setDescription('This counter is incremented when a station detects the absence of transitions for five half-bit timers (burst-five error).')
ibmOsaExpTRACErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRACErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRACErrorCount.setDescription('This counter is incremented when a station receives an AMP or SMP frame in which A is equal to C is equal to 0, and then receives another SMP frame with A is equal to C is equal to 0 without first receiving an AMP frame. It denotes a station that cannot set the AC bits properly.')
ibmOsaExpTRAbortTransErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRAbortTransErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRAbortTransErrorCount.setDescription('This counter is incremented when a station transmits an abort delimiter while transmitting.')
ibmOsaExpTRInternalErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRInternalErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRInternalErrorCount.setDescription('This counter is incremented when a station recognizes an internal error.')
ibmOsaExpTRLostFrameErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRLostFrameErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRLostFrameErrorCount.setDescription('This counter is incremented when a station is transmitting and its TRR timer expires. This condition denotes a condition transmitting station in strip mode does not receive the trailer of the frame TRR timer goes off.')
ibmOsaExpTRRcvCongestionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRcvCongestionCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRcvCongestionCount.setDescription('This counter is incremented when a station recognizes a frame addressed to its specific address, but has no available buffer space indicating that the station is congested.')
ibmOsaExpTRFrameCopyErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRFrameCopyErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRFrameCopyErrorCount.setDescription('This counter is incremented when a station recognizes a frame addressed to its specific address and detects that the FS field A bits are set to 1 indicating a possible line hit or duplicate address.')
ibmOsaExpTRTokenErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRTokenErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRTokenErrorCount.setDescription('This counter is incremented when a station acting as the active monitor recognizes an error condition that needs a token transmitted.')
ibmOsaExpTRFullDuplexErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRFullDuplexErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRFullDuplexErrorCount.setDescription('An error has been detected by the FDX protocol')
ibmOsaExpTRSoftErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRSoftErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRSoftErrorCount.setDescription('The number of Soft Errors the interface has detected. It directly corresponds to the number of Report Error MAC frames that this interface has transmitted. Soft Errors are those which are recoverable by the MAC layer protocols.')
ibmOsaExpTRHardErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRHardErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRHardErrorCount.setDescription('The number of times this interface has detected an immediately recoverable fatal error. It denotes the number of times this interface is either transmitting or receiving beacon MAC frames.')
ibmOsaExpTRSignalLossErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRSignalLossErrorCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRSignalLossErrorCount.setDescription('The number of times this interface has detected the loss of signal condition from the ring.')
ibmOsaExpTRTransmitBeaconCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRTransmitBeaconCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRTransmitBeaconCount.setDescription('The number of times this interface has transmitted a beacon frame.')
ibmOsaExpTRRecoveryCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRecoveryCounter.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRecoveryCounter.setDescription('The number of Claim Token MAC frames received or transmitted after the interface has received a frame Ring Ring Purge MAC counter signifies the number of times the ring has been purged and is being recovered back into a normal operating state.')
ibmOsaExpTRLobeWireFaultCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRLobeWireFaultCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRLobeWireFaultCount.setDescription('The number of times the interface has detected an open or short circuit in the lobe data path. The adapter will be closed and ibmOsaExpTRRingState will signify this condition.')
ibmOsaExpTRRemoveReceivedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRRemoveReceivedCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRRemoveReceivedCount.setDescription('The number of times the interface has received a Remove Ring Station MAC frame request. When this frame is received the interface will enter the closed state and ibmOsaExpTRRingState will signify this condition.')
ibmOsaExpTRSingleStationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpTRSingleStationCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpTRSingleStationCount.setDescription('The number of times the interface has sensed that it is the only station on the ring. This will happen if the interface is the first one up on a ring, or if there is a hardware problem.')
ibmOSAExpATMPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7), )
if mibBuilder.loadTexts: ibmOSAExpATMPortTable.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpATMPortTable.setDescription('This table represents the data associated with an emulated Ethernet port on an OSA-Express ATM feature. There are a maximum of 2 logical ports on each ATM feature, however, each port is shown as though it exists independently with each having an entry in the ibmOSAExpChannelTable.')
ibmOSAExpATMPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmOSAExpATMPortEntry.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpATMPortEntry.setDescription('Definition of a single entry in the ibmOSAExpATMPortTable. Indexed by the ifIndex of the corresponding Device interface.')
ibmOsaExpATMPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMPortNumber.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMPortNumber.setDescription('The logical port number of this port')
ibmOsaExpATMPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(17))).clone(namedValues=NamedValues(("emulatedEthernet", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMPortType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMPortType.setDescription('The logical port type.')
ibmOsaExpATMLanTrafficState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("undefined", 0), ("unavailable", 1), ("enabling", 2), ("disabling", 3), ("enabled", 4), ("disabled", 5), ("linkMonitor", 6), ("definitionError", 7), ("configuredOffline", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLanTrafficState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLanTrafficState.setDescription('The LAN state value ranges from 0 to 8. A value of 5, disabled is further explained in object ibmOsaExpATMDisabledStatus.')
ibmOsaExpATMServiceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notInServiceMode", 0), ("inServiceMode", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMServiceMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMServiceMode.setDescription('This object indicates if the processor is in service mode or not.')
ibmOsaExpATMDisabledStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 5), Bits().clone(namedValues=NamedValues(("reserved0", 0), ("internalPortFailure", 1), ("reserved2", 2), ("reserved3", 3), ("reserved4", 4), ("reserved5", 5), ("portTemporarilyDisabled", 6), ("reserved7", 7), ("reserved8", 8), ("serviceProcessorRequest", 9), ("networkRequest", 10), ("osasfRequest", 11), ("configurationChange", 12), ("linkFailureThresholdExceeded", 13), ("reserved14", 14), ("reserved15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMDisabledStatus.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMDisabledStatus.setDescription('When the value of ibmOsaExpATMLanTrafficState is NOT disabled, the value of this object will be zero. When the value of ibmOsaExpATMLanTrafficState is disabled(5), this object explains the reason for the disabled state. The value for this object may be a combination of the bits shown.')
ibmOsaExpATMConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 34))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigName.setDescription('This is the name of the configuration that is on the OSA. It is set using OSA/SF. It is not used by OSA')
ibmOsaExpATMMacAddrActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMacAddrActive.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMacAddrActive.setDescription('A 6 byte OCTET STRING which contains the current MAC address in use on the OSA. The values are in canonical format.')
ibmOsaExpATMMacAddrBurntIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMacAddrBurntIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMacAddrBurntIn.setDescription('A 6 byte OCTET STRING which contains the burned in MAC address on the OSA. The values are in canonical format.')
ibmOsaExpATMUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMUserData.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMUserData.setDescription('Data set by the user. It is ignored by the OSA.')
ibmOsaExpATMPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMPortName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMPortName.setDescription('Name of the port as used by TCP/IP')
ibmOsaExpATMGroupMacAddrTable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMGroupMacAddrTable.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMGroupMacAddrTable.setDescription('This field contains the active Group Addresses. An individual Group Address is 6 bytes long with an additional 2 bytes of padding.')
ibmOsaExpATMIBMEnhancedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMIBMEnhancedMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMIBMEnhancedMode.setDescription('When set to Yes, this keeps data connections active when the connection to the LES is lost.')
ibmOsaExpATMBestEffortPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 15), Integer32()).setUnits('Megabytes per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMBestEffortPeakRate.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMBestEffortPeakRate.setDescription('Values range from 10-1550 and must be divided by 10 to get the proper value. A value of 1550 indicates 155.0 Mbytes/sec')
ibmOsaExpATMConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigMode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigMode.setDescription('Indicates whether this LAN Emulation Client should auto-configure the next time it is (re)started. In automatic (1) mode, a client uses a LAN Emulation Configuration Server to learn the ATM address of its LAN Emulation Server, and to obtain other parameters. lecConfig (LanType, MaxDataFrameSize, LanName) are used in the configure request. ibmOsaExpATMConfigLESATMAddress is ignored. In manual (2) mode, management tells the client the ATM address of its LAN Emulation Server and the value of the other parmeters. lecConfig (LanType, MaxDataFrameSize, LanName) are used in the Join request. ibmOsaExpATMConfigLESATMAddress tells the client which LES to call.')
ibmOsaExpATMConfigLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(17))).clone(namedValues=NamedValues(("emulatedEthernet", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigLanType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigLanType.setDescription('The logical port type that the user configured the port for')
ibmOsaExpATMActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(17))).clone(namedValues=NamedValues(("emulatedEthernet", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMActualLanType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMActualLanType.setDescription('The actual logical port type the port is running in')
ibmOsaExpATMConfigMaxDataFrmSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("f1516", 2), ("f4544", 3), ("f9234", 4), ("f18190", 5)))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigMaxDataFrmSz.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigMaxDataFrmSz.setDescription('The maximum data frame size (in bytes) which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their join requests.')
ibmOsaExpATMActualMaxDataFrmSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("f1516", 2), ("f4544", 3), ("f9234", 4), ("f18190", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMActualMaxDataFrmSz.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMActualMaxDataFrmSz.setDescription('The maximum data frame size (in bytes) which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their join requests.')
ibmOsaExpATMConfigELANName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigELANName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigELANName.setDescription('The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their join requests.')
ibmOsaExpATMActualELANName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMActualELANName.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMActualELANName.setDescription('The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their join requests.')
ibmOsaExpATMConfigLESATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigLESATMAddress.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigLESATMAddress.setDescription("The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When ibmOsaExpATMConfigMode is 'automatic', there is no need to set this address, Address) and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in ibmOsaExpATMActualLESATMAddress while leaving ibmOsaExpATMConfigLESATMAddress alone. Corresponds to Initial State Parameter C9. In LAN Emulation MIB, the OCTET STRING has length 0 or 20. For OSA, the length shall be 20, with the value 0 defined to mean that ibmOsaExpATMConfigMode is 'automatic'.")
ibmOsaExpATMActualLESATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMActualLESATMAddress.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMActualLESATMAddress.setDescription("The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When lecConfigMode is 'automatic', there is no need to set this address, Address) and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in ibmOsaExpATMActualLESATMAddress while leaving ibmOsaExpATMConfigLESATMAddress alone. Corresponds to Initial State Parameter C9. In LAN Emulation MIB, the OCTET STRING has length 0 or 20. For OSA, the length shall be 20, with the value 0 defined to mean that ibmOsaExpATMConfigMode is 'automatic'.")
ibmOsaExpATMControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlTimeout.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlTimeout.setDescription('Control Time-out. Time out period used for timing out most request/response control frame interactions, as specified elsewhere in the LAN Emulation specification. This time value is expressed in seconds. Corresponds to Initial State Parameter C7.')
ibmOsaExpATMMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMaxUnknownFrameCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMaxUnknownFrameCount.setDescription('Maximum Unknown Frame Count. See the description of ibmOsaExpATMMaxUnknownFrameTime below. Corresponds to Initial State Parameter C10.')
ibmOsaExpATMMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMaxUnknownFrameTime.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMaxUnknownFrameTime.setDescription('Maximum Unknown Frame Time. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to the BUS for a given unicast LAN Destination, and it must also initiate the address resolution protocol to resolve that LAN Destination. This time value is expressed in seconds. Corresponds to Initial State Parameter C11.')
ibmOsaExpATMVCCTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 28), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMVCCTimeoutPeriod.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMVCCTimeoutPeriod.setDescription('VCC Time-out Period. A LE Client SHOULD release any Data Direct VCC that it has not used to transmit or receive any data frames for the length of the VCC Time-out Period. This parameter is only meaningful for SVC Data Direct VCCs. This time value is expressed in seconds. The default value is 20 minutes. A value of 0 seconds means that the timeout period is infinite. Negative values will be rejected by the agent. Corresponds to Initial State Parameter C12.')
ibmOsaExpATMMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMaxRetryCount.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMaxRetryCount.setDescription("Maximum Retry Count. A LE CLient MUST not retry a LE_ARP_REQUEST for a given frame's LAN destination more than Maximum Retry Count times, after the first LE_ARP_REQUEST for that same frame's LAN destination. Corresponds to Initial State Parameter C13.")
ibmOsaExpATMAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMAgingTime.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMAgingTime.setDescription('Aging Time. The maximum time that a LE Client will maintain an entry in its LE_ARP cache in the absence of a verification of that relationship. This time value is expressed in seconds. Corresponds to Initial State Parameter C17.')
ibmOsaExpATMForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMForwardDelayTime.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMForwardDelayTime.setDescription('Forward Delay Time. The maximum time that a LE Client will maintain an entry for a non-local MAC address in its LE_ARP cache in the absence of a verification of that relationship, as long as the Topology Change flag C19 is true. ibmOsaExpATMForwardDelayTime SHOULD BE less than ibmOsaExpATMAgingTIme. When it is not, ibmOsaExpATMAgingTime governs LE_ARP aging. This time value is expressed in seconds. Corresponds to Initial State Parameter C18.')
ibmOsaExpATMExpectedARPRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMExpectedARPRespTime.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMExpectedARPRespTime.setDescription('Expected LE_ARP Reponse Time. The maximum time that the LEC expects an LE_ARP_REQUEST/LE_ARP_RESPONSE cycle to take. Used for retries and verifies. This time value is expressed in seconds. Corresponds to Initial State Parameter C20.')
ibmOsaExpATMFlushTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMFlushTimeout.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMFlushTimeout.setDescription('Flush Time-out. Time limit to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action. This time value is expressed in seconds. Corresponds to Initial State Parameter C21.')
ibmOsaExpATMPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMPathSwitchingDelay.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMPathSwitchingDelay.setDescription('Path Switching Delay. The time since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol. This time value is expressed in seconds. Corresponds to Initial State Parameter C22.')
ibmOsaExpATMLocalSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLocalSegmentID.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLocalSegmentID.setDescription('Local Segment ID. The segment ID of the emulated LAN. This is only required for IEEE 802.5 clients that are Source Routing bridges. Corresponds to Initial State Parameter C23.')
ibmOsaExpATMMltcstSendVCCType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bestEffort", 1), ("variableBitRate", 2), ("constantBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMltcstSendVCCType.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMltcstSendVCCType.setDescription('Multicast Send VCC Type. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. This is the method to be used by the LE Client when specifying traffic parameters when it sets up the Multicast Send VCC for this emulated LAN. Corresponds to Initial State Parameter C24.')
ibmOsaExpATMMltcstSendVCCAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMltcstSendVCCAvgRate.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMltcstSendVCCAvgRate.setDescription('Multicast Send VCC AvgRate. Signalling parameter that SHOULD be used by the LE Client when estabishing the Multicast Send VCC. Forward and Backward Sustained Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. Corresponds to Initial State Parameter C25.')
ibmOsaExpATMMcastSendVCCPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMcastSendVCCPeakRate.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMcastSendVCCPeakRate.setDescription('Multicast Send VCC PeakRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Peak Cell Rate to be requested by LE Client when setting up the Multicast Send VCC when using either Variable or Constant bit rate codings. Corresponds to Initial State Parameter C26.')
ibmOsaExpATMConnectCompleteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConnectCompleteTimer.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConnectCompleteTimer.setDescription('Connection Complete Timer. Optional. In Connection Establish ment this is the time period in which data or a READY_IND message is expected from a Calling Party. This time value is expressed in seconds. Corresponds to Initial State Parameter C28.')
ibmOsaExpATMClientATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMClientATMAddress.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMClientATMAddress.setDescription("LE Client's ATM Addresses. The primary ATM address of this LAN Emulation Client. This address is used to establish the Control Direct and Multicast Send VCCs, and may also be used to set up Data Direct VCCs. A client may have additional ATM addresses for use with Data Direct VCCs. Corresponds to Initial State Parameter C1.")
ibmOsaExpATMClientIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMClientIdentifier.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMClientIdentifier.setDescription("LE Client Identifier. Each LE Client requires a LE Client Identifier (LECID) assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client. This value MUST NOT change without terminating the LE Client and returning to the Initial state. A valid LECID MUST be in the range X'0001' through X'FEFF'. The value of this object is only meaningful for a LEC that is connected to a LES. For a LEC which does not belong to an emulated LAN, the value of this object is defined to be 0. Corresponds to Initial State Parameter C14.")
ibmOsaExpATMClientCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMClientCurrentState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMClientCurrentState.setDescription("The current state of the LAN Emulation Client. Note that 'ifOperStatus' is defined to be 'up' when, and only when, this field is 'operational'.")
ibmOsaExpATMLastFailureRespCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("undefinedError", 3), ("versionNotSupported", 4), ("invalidRequestParameters", 5), ("duplicateLanDestination", 6), ("duplicateAtmAddress", 7), ("insufficientResources", 8), ("accessDenied", 9), ("invalidRequesterId", 10), ("invalidLanDestination", 11), ("invalidAtmAddress", 12), ("noConfiguration", 13), ("leConfigureError", 14), ("insufficientInformation", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLastFailureRespCode.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLastFailureRespCode.setDescription("Status code from the last failed Configure response or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a timeout period. If none of this client's requests have failed, this object has the value 'none'. If the failed response contained a STATUS code that is not defined in the LAN Emulation specification, this object has the value 'undefinedError'. The value 'timeout' is self explanatory. Other failure codes correspond to those defined in the specification, although they may have different numeric values.")
ibmOsaExpATMLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLastFailureState.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLastFailureState.setDescription("The state this client was in when it updated the 'ibmOsaExpATMLastFailureRespCode'. If 'ibmOsaExpATMLastFailureRespCode' is 'none', this object has the value initialState(1).")
ibmOsaExpATMProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMProtocol.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMProtocol.setDescription('The LAN Emulation protocol which this client supports, and specifies in its LE_JOIN_REQUESTs.')
ibmOsaExpATMLeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLeVersion.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLeVersion.setDescription('The LAN Emulation protocol version which this client supports, and specifies in its LE_JOIN_REQUESTs.')
ibmOsaExpATMTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMTopologyChange.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMTopologyChange.setDescription("Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Aging Time C17, to age non-local entries in its LE_ARP cache C16. For a client which is not connected to the LES, this object is defined to have the value 'false'. Corresponds to Initial State Parameter C19.")
ibmOsaExpATMConfigServerATMAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 48), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigServerATMAddr.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigServerATMAddr.setDescription('The ATM address of the LAN Emulation Configuration Server (if known) or 0 (otherwise). In LAN Emulation MIB, the OCTET STRING is either 0 length or 20 octets. For OSA-ATM, this Address has been changed to a constant 20 octets, with the value 0 equivalent to the 0 length OCTET STRING.')
ibmOsaExpATMConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gotAddressViaIlmi", 1), ("usedWellKnownAddress", 2), ("usedLecsPvc", 3), ("didNotUseLecs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigSource.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigSource.setDescription('Indicates whether this LAN Emulation Client used the LAN Emulation Configuration Server, and, if so, what method it used to establish the Configuration Direct VCC')
ibmOsaExpATMProxyClient = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMProxyClient.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMProxyClient.setDescription('Indicates whether this client is acting as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST frames for such addresses. Corresponds to Initial State Parameter C4.')
ibmOsaExpATMLePDUOctetsInbound = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 51), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLePDUOctetsInbound.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLePDUOctetsInbound.setDescription('The number of Le PDU Octets received')
ibmOsaExpATMNonErrLePDUDiscIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 52), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMNonErrLePDUDiscIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMNonErrLePDUDiscIn.setDescription('The number of Non Error Le PDU Octets received')
ibmOsaExpATMErrLePDUDiscIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMErrLePDUDiscIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMErrLePDUDiscIn.setDescription('The number of Errored Le PDU Discards received')
ibmOsaExpATMLePDUOctetsOutbound = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 54), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLePDUOctetsOutbound.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLePDUOctetsOutbound.setDescription('The number of Le PDU Discards sent')
ibmOsaExpATMNonErrLePDUDiscOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMNonErrLePDUDiscOut.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMNonErrLePDUDiscOut.setDescription('The number of Non Error Le PDU Discards sent')
ibmOsaExpATMErrLePDUDiscOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMErrLePDUDiscOut.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMErrLePDUDiscOut.setDescription('The number of Errored Le PDU Discards sent')
ibmOsaExpATMLeARPRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRequestsOut.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRequestsOut.setDescription('The number of LE ARP Requests sent')
ibmOsaExpATMLeARPRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRequestsIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRequestsIn.setDescription('The number of LE ARP Requests received over the LUNI by this LAN Emulation Client. Requests may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented and the chances it has had for learning. This counter covers both VCCs.')
ibmOsaExpATMLeARPRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRepliesOut.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRepliesOut.setDescription('The number of LE ARP Responses sent over the LUNI by this LAN Emulation Client.')
ibmOsaExpATMLeARPRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRepliesIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMLeARPRepliesIn.setDescription('The number of LE ARP Responses received over the LUNI by this LAN Emulation Client. This count includes all such replies, whether solicited or not. Replies may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented. This counter covers both VCCs.')
ibmOsaExpATMControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 61), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlFramesOut.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlFramesOut.setDescription('The total number of control packets sent by this LAN Emulation Client over the LUNI.')
ibmOsaExpATMControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 62), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlFramesIn.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlFramesIn.setDescription('The total number of control packets received by this LAN Emulation Client over the LUNI.')
ibmOsaExpATMSVCFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMSVCFailures.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMSVCFailures.setDescription('The total number of outgoing LAN Emulation SVCs which this client tried, but failed, to open; incoming LAN Emulation SVCs which this client tried, but failed to establish; and incoming LAN Emulation SVCs which this client rejected for protocol or security reasons.')
ibmOsaExpATMConfigDirectIntfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectIntfc.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectIntfc.setDescription('The interface associated with the Configuration Direct VCC. If no Configuration Direct VCC exists, this object has the value 0. Otherwise, the objects ( ibmOsaExpATMConfigDirectIntfc, ibmOsaExpATMConfigDirectVPI, ibmOsaExpATMConfigDirectVCI) identify the circuit.')
ibmOsaExpATMConfigDirectVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 65), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectVPI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectVPI.setDescription('If the Configuration Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMConfigDirectVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectVCI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMConfigDirectVCI.setDescription('If the Configuration Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMControlDirectIntfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectIntfc.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectIntfc.setDescription('The interface associated with the Control Direct VCC. If no Control Direct VCC exists, this object has the value 0. Otherwise, the objects ( ibmOsaExpATMConfigDirectIntfc, ibmOsaExpATMConfigDirectVPI, ibmOsaExpATMConfigDirectVCI) identify the circuit.')
ibmOsaExpATMControlDirectVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectVPI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectVPI.setDescription('If the Control Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMControlDirectVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectVCI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDirectVCI.setDescription('If the Control Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMControlDistIntfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDistIntfc.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDistIntfc.setDescription('The interface associated with the Control Distribute VCC. If no Control Distribute VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( ibmOsaExpATMControlDistIntfc, ibmOsaExpATMControlDistributeVPI. ibmOsaExpATMControlDistributeVCI) identify the circuit.')
ibmOsaExpATMControlDistributeVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDistributeVPI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDistributeVPI.setDescription('If the Control Distribute VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMControlDistributeVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMControlDistributeVCI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMControlDistributeVCI.setDescription('If the Control Distribute VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object contains the value 0.')
ibmOsaExpATMMulticastSendIntfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendIntfc.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendIntfc.setDescription('The interface associated with the Multicast Send VCC. If no Multicast Send VCC exists, this object has the value 0. Otherwise, the objects ( ibmOsaExpATMMulticastSendIntfc, ibmOsaExpATMMulticastSendVPI, ibmOsaExpATMMulticastSendVCI) identify the circuit.')
ibmOsaExpATMMulticastSendVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendVPI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendVPI.setDescription('If the Multicast Send VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMMulticastSendVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 75), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendVCI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastSendVCI.setDescription('If the Multicast Send VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMMulticastFwdIntfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastFwdIntfc.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastFwdIntfc.setDescription('The interface associated with the Multicast Forward VCC. If no Multicast Forward VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( ibmOsaExpATMMulticastFwdIntfc, ibmOsaExpATMMulticastForwardVPI, ibmOsaExpATMMulticastForwardVCI) identify the circuit.')
ibmOsaExpATMMulticastForwardVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 77), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastForwardVPI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastForwardVPI.setDescription('If the Multicast Forward VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOsaExpATMMulticastForwardVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 188, 1, 7, 1, 78), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmOsaExpATMMulticastForwardVCI.setStatus('current')
if mibBuilder.loadTexts: ibmOsaExpATMMulticastForwardVCI.setDescription('If the Multicast Forward VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmOSAMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 1))
ibmOSAMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2))
ibmOSAMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 1, 1)).setObjects(("IBM-OSA-MIB", "ibmOSAExpChannelGroup"), ("IBM-OSA-MIB", "ibmOSAExpPerfGroup"), ("IBM-OSA-MIB", "ibmOSAExpPEGroup"), ("IBM-OSA-MIB", "ibmOSAExpEthGroup"), ("IBM-OSA-MIB", "ibmOSAExpTRGroup"), ("IBM-OSA-MIB", "ibmOSAExpATMGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAMibCompliance = ibmOSAMibCompliance.setStatus('current')
if mibBuilder.loadTexts: ibmOSAMibCompliance.setDescription('The compliance statement for the OSA DIrect SNMP product.')
ibmOSAExpChannelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 1)).setObjects(("IBM-OSA-MIB", "ibmOSAExpChannelNumber"), ("IBM-OSA-MIB", "ibmOSAExpChannelType"), ("IBM-OSA-MIB", "ibmOSAExpChannelHdwLevel"), ("IBM-OSA-MIB", "ibmOSAExpChannelSubType"), ("IBM-OSA-MIB", "ibmOSAExpChannelShared"), ("IBM-OSA-MIB", "ibmOSAExpChannelNodeDesc"), ("IBM-OSA-MIB", "ibmOSAExpChannelProcCodeLevel"), ("IBM-OSA-MIB", "ibmOSAExpChannelPCIBusUtil1Min"), ("IBM-OSA-MIB", "ibmOSAExpChannelProcUtil1Min"), ("IBM-OSA-MIB", "ibmOSAExpChannelPCIBusUtil5Min"), ("IBM-OSA-MIB", "ibmOSAExpChannelProcUtil5Min"), ("IBM-OSA-MIB", "ibmOSAExpChannelPCIBusUtilHour"), ("IBM-OSA-MIB", "ibmOSAExpChannelProcUtilHour"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpChannelGroup = ibmOSAExpChannelGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpChannelGroup.setDescription('This group comprises those objects that are related to OSA-Express Channel support.')
ibmOSAExpPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 2)).setObjects(("IBM-OSA-MIB", "ibmOSAExpPerfDataLP0"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP1"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP2"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP3"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP4"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP5"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP6"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP7"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP8"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP9"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP10"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP11"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP12"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP13"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP14"), ("IBM-OSA-MIB", "ibmOSAExpPerfDataLP15"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpPerfGroup = ibmOSAExpPerfGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPerfGroup.setDescription('This group comprises those objects that are related to OSA-Express Performance data support.')
ibmOSAExpPEGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 3)).setObjects(("IBM-OSA-MIB", "ibmOSAExpPEMaxSizeArpCache"), ("IBM-OSA-MIB", "ibmOSAExpPEArpPendingEntries"), ("IBM-OSA-MIB", "ibmOSAExpPEArpActiveEntries"), ("IBM-OSA-MIB", "ibmOSAExpPEIPEntries"), ("IBM-OSA-MIB", "ibmOSAExpPEMulticastEntries"), ("IBM-OSA-MIB", "ibmOSAExpPEMulticastData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpPEGroup = ibmOSAExpPEGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpPEGroup.setDescription('This group comprises those objects that are related to OSA-Express PE data support.')
ibmOSAExpEthGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 4)).setObjects(("IBM-OSA-MIB", "ibmOsaExpEthPortNumber"), ("IBM-OSA-MIB", "ibmOsaExpEthPortType"), ("IBM-OSA-MIB", "ibmOsaExpEthLanTrafficState"), ("IBM-OSA-MIB", "ibmOsaExpEthServiceMode"), ("IBM-OSA-MIB", "ibmOsaExpEthDisabledStatus"), ("IBM-OSA-MIB", "ibmOsaExpEthConfigName"), ("IBM-OSA-MIB", "ibmOsaExpEthConfigSpeedMode"), ("IBM-OSA-MIB", "ibmOsaExpEthActiveSpeedMode"), ("IBM-OSA-MIB", "ibmOsaExpEthMacAddrActive"), ("IBM-OSA-MIB", "ibmOsaExpEthMacAddrBurntIn"), ("IBM-OSA-MIB", "ibmOsaExpEthUserData"), ("IBM-OSA-MIB", "ibmOsaExpEthOutPackets"), ("IBM-OSA-MIB", "ibmOsaExpEthInPackets"), ("IBM-OSA-MIB", "ibmOsaExpEthInGroupFrames"), ("IBM-OSA-MIB", "ibmOsaExpEthInBroadcastFrames"), ("IBM-OSA-MIB", "ibmOsaExpEthPortName"), ("IBM-OSA-MIB", "ibmOsaExpEthInUnknownIPFrames"), ("IBM-OSA-MIB", "ibmOsaExpEthGroupAddrTable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpEthGroup = ibmOSAExpEthGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpEthGroup.setDescription('This group comprises those objects that are related to OSA-Express Fast Ethernet and Gigabit features only')
ibmOSAExpTRGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 5)).setObjects(("IBM-OSA-MIB", "ibmOsaExpTRPortNumber"), ("IBM-OSA-MIB", "ibmOsaExpTRPortType"), ("IBM-OSA-MIB", "ibmOsaExpTRLanTrafficState"), ("IBM-OSA-MIB", "ibmOsaExpTRServiceMode"), ("IBM-OSA-MIB", "ibmOsaExpTRDisabledStatus"), ("IBM-OSA-MIB", "ibmOsaExpTRConfigName"), ("IBM-OSA-MIB", "ibmOsaExpTRMacAddrActive"), ("IBM-OSA-MIB", "ibmOsaExpTRMacAddrBurntIn"), ("IBM-OSA-MIB", "ibmOsaExpTRConfigSpeedMode"), ("IBM-OSA-MIB", "ibmOsaExpTRActiveSpeedMode"), ("IBM-OSA-MIB", "ibmOsaExpTRUserData"), ("IBM-OSA-MIB", "ibmOsaExpTRPortName"), ("IBM-OSA-MIB", "ibmOsaExpTRGroupAddrTable"), ("IBM-OSA-MIB", "ibmOsaExpTRFunctionalAddr"), ("IBM-OSA-MIB", "ibmOsaExpTRRingStatus"), ("IBM-OSA-MIB", "ibmOsaExpTRAllowAccessPriority"), ("IBM-OSA-MIB", "ibmOsaExpTREarlyTokenRelease"), ("IBM-OSA-MIB", "ibmOsaExpTRBeaconingAddress"), ("IBM-OSA-MIB", "ibmOsaExpTRUpstreamNeighbor"), ("IBM-OSA-MIB", "ibmOsaExpTRRingState"), ("IBM-OSA-MIB", "ibmOsaExpTRRingOpenStatus"), ("IBM-OSA-MIB", "ibmOsaExpTRPacketsTransmitted"), ("IBM-OSA-MIB", "ibmOsaExpTRPacketsReceived"), ("IBM-OSA-MIB", "ibmOsaExpTRLineErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRBurstErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRACErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRAbortTransErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRInternalErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRLostFrameErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRRcvCongestionCount"), ("IBM-OSA-MIB", "ibmOsaExpTRFrameCopyErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRTokenErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRFullDuplexErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRSoftErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRHardErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRSignalLossErrorCount"), ("IBM-OSA-MIB", "ibmOsaExpTRTransmitBeaconCount"), ("IBM-OSA-MIB", "ibmOsaExpTRRecoveryCounter"), ("IBM-OSA-MIB", "ibmOsaExpTRLobeWireFaultCount"), ("IBM-OSA-MIB", "ibmOsaExpTRRemoveReceivedCount"), ("IBM-OSA-MIB", "ibmOsaExpTRSingleStationCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpTRGroup = ibmOSAExpTRGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpTRGroup.setDescription('This group comprises those objects that are related to OSA-Express Token Ring feature only')
ibmOSAExpATMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 188, 2, 2, 7)).setObjects(("IBM-OSA-MIB", "ibmOsaExpATMPortNumber"), ("IBM-OSA-MIB", "ibmOsaExpATMPortType"), ("IBM-OSA-MIB", "ibmOsaExpATMLanTrafficState"), ("IBM-OSA-MIB", "ibmOsaExpATMServiceMode"), ("IBM-OSA-MIB", "ibmOsaExpATMDisabledStatus"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigName"), ("IBM-OSA-MIB", "ibmOsaExpATMMacAddrActive"), ("IBM-OSA-MIB", "ibmOsaExpATMMacAddrBurntIn"), ("IBM-OSA-MIB", "ibmOsaExpATMUserData"), ("IBM-OSA-MIB", "ibmOsaExpATMPortName"), ("IBM-OSA-MIB", "ibmOsaExpATMGroupMacAddrTable"), ("IBM-OSA-MIB", "ibmOsaExpATMIBMEnhancedMode"), ("IBM-OSA-MIB", "ibmOsaExpATMBestEffortPeakRate"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigMode"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigLanType"), ("IBM-OSA-MIB", "ibmOsaExpATMActualLanType"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigMaxDataFrmSz"), ("IBM-OSA-MIB", "ibmOsaExpATMActualMaxDataFrmSz"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigELANName"), ("IBM-OSA-MIB", "ibmOsaExpATMActualELANName"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigLESATMAddress"), ("IBM-OSA-MIB", "ibmOsaExpATMActualLESATMAddress"), ("IBM-OSA-MIB", "ibmOsaExpATMControlTimeout"), ("IBM-OSA-MIB", "ibmOsaExpATMMaxUnknownFrameCount"), ("IBM-OSA-MIB", "ibmOsaExpATMMaxUnknownFrameTime"), ("IBM-OSA-MIB", "ibmOsaExpATMVCCTimeoutPeriod"), ("IBM-OSA-MIB", "ibmOsaExpATMMaxRetryCount"), ("IBM-OSA-MIB", "ibmOsaExpATMAgingTime"), ("IBM-OSA-MIB", "ibmOsaExpATMForwardDelayTime"), ("IBM-OSA-MIB", "ibmOsaExpATMExpectedARPRespTime"), ("IBM-OSA-MIB", "ibmOsaExpATMFlushTimeout"), ("IBM-OSA-MIB", "ibmOsaExpATMPathSwitchingDelay"), ("IBM-OSA-MIB", "ibmOsaExpATMLocalSegmentID"), ("IBM-OSA-MIB", "ibmOsaExpATMMltcstSendVCCType"), ("IBM-OSA-MIB", "ibmOsaExpATMMltcstSendVCCAvgRate"), ("IBM-OSA-MIB", "ibmOsaExpATMMcastSendVCCPeakRate"), ("IBM-OSA-MIB", "ibmOsaExpATMConnectCompleteTimer"), ("IBM-OSA-MIB", "ibmOsaExpATMClientATMAddress"), ("IBM-OSA-MIB", "ibmOsaExpATMClientIdentifier"), ("IBM-OSA-MIB", "ibmOsaExpATMClientCurrentState"), ("IBM-OSA-MIB", "ibmOsaExpATMLastFailureRespCode"), ("IBM-OSA-MIB", "ibmOsaExpATMLastFailureState"), ("IBM-OSA-MIB", "ibmOsaExpATMProtocol"), ("IBM-OSA-MIB", "ibmOsaExpATMLeVersion"), ("IBM-OSA-MIB", "ibmOsaExpATMTopologyChange"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigServerATMAddr"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigSource"), ("IBM-OSA-MIB", "ibmOsaExpATMProxyClient"), ("IBM-OSA-MIB", "ibmOsaExpATMLePDUOctetsInbound"), ("IBM-OSA-MIB", "ibmOsaExpATMNonErrLePDUDiscIn"), ("IBM-OSA-MIB", "ibmOsaExpATMErrLePDUDiscIn"), ("IBM-OSA-MIB", "ibmOsaExpATMLePDUOctetsOutbound"), ("IBM-OSA-MIB", "ibmOsaExpATMNonErrLePDUDiscOut"), ("IBM-OSA-MIB", "ibmOsaExpATMErrLePDUDiscOut"), ("IBM-OSA-MIB", "ibmOsaExpATMLeARPRequestsOut"), ("IBM-OSA-MIB", "ibmOsaExpATMLeARPRequestsIn"), ("IBM-OSA-MIB", "ibmOsaExpATMLeARPRepliesOut"), ("IBM-OSA-MIB", "ibmOsaExpATMLeARPRepliesIn"), ("IBM-OSA-MIB", "ibmOsaExpATMControlFramesOut"), ("IBM-OSA-MIB", "ibmOsaExpATMControlFramesIn"), ("IBM-OSA-MIB", "ibmOsaExpATMSVCFailures"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigDirectIntfc"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigDirectVPI"), ("IBM-OSA-MIB", "ibmOsaExpATMConfigDirectVCI"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDirectIntfc"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDirectVPI"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDirectVCI"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDistIntfc"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDistributeVPI"), ("IBM-OSA-MIB", "ibmOsaExpATMControlDistributeVCI"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastSendIntfc"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastSendVPI"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastSendVCI"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastFwdIntfc"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastForwardVPI"), ("IBM-OSA-MIB", "ibmOsaExpATMMulticastForwardVCI"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmOSAExpATMGroup = ibmOSAExpATMGroup.setStatus('current')
if mibBuilder.loadTexts: ibmOSAExpATMGroup.setDescription('This group comprises those objects that are related to OSA-Express ATM LAN Emulation feature only')
mibBuilder.exportSymbols("IBM-OSA-MIB", ibmOsaExpATMControlFramesIn=ibmOsaExpATMControlFramesIn, ibmOSAExpChannelGroup=ibmOSAExpChannelGroup, ibmOsaExpTRConfigName=ibmOsaExpTRConfigName, ibmOsaExpATMNonErrLePDUDiscOut=ibmOsaExpATMNonErrLePDUDiscOut, ibmOsaExpTRSingleStationCount=ibmOsaExpTRSingleStationCount, ibmOSAExpPerfDataLP7=ibmOSAExpPerfDataLP7, ibmOsaExpTRTransmitBeaconCount=ibmOsaExpTRTransmitBeaconCount, ibmOsaExpTRUpstreamNeighbor=ibmOsaExpTRUpstreamNeighbor, ibmOsaExpATMControlTimeout=ibmOsaExpATMControlTimeout, ibmOSAMibConformance=ibmOSAMibConformance, ibmOsaExpEthOutPackets=ibmOsaExpEthOutPackets, ibmOsaExpEthConfigName=ibmOsaExpEthConfigName, ibmOsaExpTRInternalErrorCount=ibmOsaExpTRInternalErrorCount, ibmOsaExpATMMulticastSendVCI=ibmOsaExpATMMulticastSendVCI, ibmOsaExpATMControlDirectIntfc=ibmOsaExpATMControlDirectIntfc, ibm=ibm, ibmOsaExpEthUserData=ibmOsaExpEthUserData, ibmOsaExpATMGroupMacAddrTable=ibmOsaExpATMGroupMacAddrTable, ibmOSAExpPEArpPendingEntries=ibmOSAExpPEArpPendingEntries, ibmOsaExpTRUserData=ibmOsaExpTRUserData, ibmOSAExpPETable=ibmOSAExpPETable, ibmOsaExpATMMacAddrBurntIn=ibmOsaExpATMMacAddrBurntIn, ibmOsaExpATMPortName=ibmOsaExpATMPortName, ibmOsaExpATMMulticastForwardVCI=ibmOsaExpATMMulticastForwardVCI, ibmOsaExpTRPortName=ibmOsaExpTRPortName, ibmOsaExpTRPortNumber=ibmOsaExpTRPortNumber, ibmOsaExpTRTokenErrorCount=ibmOsaExpTRTokenErrorCount, ibmOsaExpATMControlDistributeVPI=ibmOsaExpATMControlDistributeVPI, ibmOSAExpPerfDataLP15=ibmOSAExpPerfDataLP15, ibmOsaExpATMMulticastFwdIntfc=ibmOsaExpATMMulticastFwdIntfc, ibmOsaExpTRGroupAddrTable=ibmOsaExpTRGroupAddrTable, ibmOsaExpATMProxyClient=ibmOsaExpATMProxyClient, ibmOSAExpPerfTable=ibmOSAExpPerfTable, ibmOSAExpChannelEntry=ibmOSAExpChannelEntry, ibmOSAExpTRGroup=ibmOSAExpTRGroup, ibmOsaExpEthMacAddrBurntIn=ibmOsaExpEthMacAddrBurntIn, ibmOSAExpChannelSubType=ibmOSAExpChannelSubType, ibmOsaExpATMControlDistIntfc=ibmOsaExpATMControlDistIntfc, ibmOsaExpATMAgingTime=ibmOsaExpATMAgingTime, ibmOsaExpTRHardErrorCount=ibmOsaExpTRHardErrorCount, ibmOsaExpTRAbortTransErrorCount=ibmOsaExpTRAbortTransErrorCount, ibmOsaExpTRActiveSpeedMode=ibmOsaExpTRActiveSpeedMode, ibmOSAExpChannelTable=ibmOSAExpChannelTable, ibmOsaExpATMConfigServerATMAddr=ibmOsaExpATMConfigServerATMAddr, ibmOSAExpTRPortEntry=ibmOSAExpTRPortEntry, ibmOsaExpTREarlyTokenRelease=ibmOsaExpTREarlyTokenRelease, ibmOSAExpPerfDataLP13=ibmOSAExpPerfDataLP13, ibmOsaExpATMTopologyChange=ibmOsaExpATMTopologyChange, ibmOsaExpEthLanTrafficState=ibmOsaExpEthLanTrafficState, ibmOSAExpPEMulticastEntries=ibmOSAExpPEMulticastEntries, ibmOsaExpEthPortNumber=ibmOsaExpEthPortNumber, ibmOsaExpTRMacAddrActive=ibmOsaExpTRMacAddrActive, ibmOSAExpPerfGroup=ibmOSAExpPerfGroup, ibmOsaExpTRSignalLossErrorCount=ibmOsaExpTRSignalLossErrorCount, ibmOSAExpPerfDataLP11=ibmOSAExpPerfDataLP11, ibmOsaExpATMVCCTimeoutPeriod=ibmOsaExpATMVCCTimeoutPeriod, ibmOSAExpPEMaxSizeArpCache=ibmOSAExpPEMaxSizeArpCache, ibmOsaExpTRRecoveryCounter=ibmOsaExpTRRecoveryCounter, ibmOsaExpTRPacketsTransmitted=ibmOsaExpTRPacketsTransmitted, ibmOsaExpATMLePDUOctetsOutbound=ibmOsaExpATMLePDUOctetsOutbound, ibmOsaExpATMConfigLanType=ibmOsaExpATMConfigLanType, ibmOsaExpTRConfigSpeedMode=ibmOsaExpTRConfigSpeedMode, ibmOSAExpPerfDataLP4=ibmOSAExpPerfDataLP4, ibmOSAMib=ibmOSAMib, ibmOsaExpEthInGroupFrames=ibmOsaExpEthInGroupFrames, ibmOSAExpPerfDataLP6=ibmOSAExpPerfDataLP6, ibmOSAExpChannelProcUtilHour=ibmOSAExpChannelProcUtilHour, ibmOsaExpATMPortNumber=ibmOsaExpATMPortNumber, ibmOSAExpChannelHdwLevel=ibmOSAExpChannelHdwLevel, ibmOsaExpEthInUnknownIPFrames=ibmOsaExpEthInUnknownIPFrames, ibmOSAExpChannelType=ibmOSAExpChannelType, ibmOsaExpATMUserData=ibmOsaExpATMUserData, ibmOsaExpATMForwardDelayTime=ibmOsaExpATMForwardDelayTime, ibmOsaExpEthActiveSpeedMode=ibmOsaExpEthActiveSpeedMode, ibmOSAExpPEGroup=ibmOSAExpPEGroup, ibmOSAExpPEEntry=ibmOSAExpPEEntry, ibmOSAExpTRPortTable=ibmOSAExpTRPortTable, ibmOsaExpATMActualELANName=ibmOsaExpATMActualELANName, ibmOsaExpATMMacAddrActive=ibmOsaExpATMMacAddrActive, ibmOsaExpEthConfigSpeedMode=ibmOsaExpEthConfigSpeedMode, ibmOsaExpTRBeaconingAddress=ibmOsaExpTRBeaconingAddress, ibmOsaExpTRRemoveReceivedCount=ibmOsaExpTRRemoveReceivedCount, ibmOsaExpATMProtocol=ibmOsaExpATMProtocol, ibmOsaExpATMNonErrLePDUDiscIn=ibmOsaExpATMNonErrLePDUDiscIn, ibmOsaExpATMErrLePDUDiscOut=ibmOsaExpATMErrLePDUDiscOut, ibmOsaExpATMControlFramesOut=ibmOsaExpATMControlFramesOut, ibmOsaExpTRACErrorCount=ibmOsaExpTRACErrorCount, ibmOsaExpTRMacAddrBurntIn=ibmOsaExpTRMacAddrBurntIn, ibmOsaExpATMMaxUnknownFrameTime=ibmOsaExpATMMaxUnknownFrameTime, ibmOsaExpTRDisabledStatus=ibmOsaExpTRDisabledStatus, ibmOSAExpChannelShared=ibmOSAExpChannelShared, ibmOsaExpEthDisabledStatus=ibmOsaExpEthDisabledStatus, ibmOsaExpEthMacAddrActive=ibmOsaExpEthMacAddrActive, ibmOSAExpEthPortTable=ibmOSAExpEthPortTable, ibmOsaExpTRLineErrorCount=ibmOsaExpTRLineErrorCount, ibmOSAExpEthPortEntry=ibmOSAExpEthPortEntry, ibmOsaExpEthInPackets=ibmOsaExpEthInPackets, ibmOSAExpPerfDataLP8=ibmOSAExpPerfDataLP8, ibmOsaExpTRRingOpenStatus=ibmOsaExpTRRingOpenStatus, ibmOsaExpEthPortName=ibmOsaExpEthPortName, ibmOsaExpATMExpectedARPRespTime=ibmOsaExpATMExpectedARPRespTime, ibmOsaExpTRFunctionalAddr=ibmOsaExpTRFunctionalAddr, ibmOsaExpATMLeARPRequestsIn=ibmOsaExpATMLeARPRequestsIn, ibmOsaExpATMConfigDirectIntfc=ibmOsaExpATMConfigDirectIntfc, ibmOSAExpPerfDataLP1=ibmOSAExpPerfDataLP1, ibmOsaExpATMConfigMaxDataFrmSz=ibmOsaExpATMConfigMaxDataFrmSz, ibmOsaExpATMConfigName=ibmOsaExpATMConfigName, ibmOsaExpATMLeARPRequestsOut=ibmOsaExpATMLeARPRequestsOut, ibmOsaExpATMMulticastForwardVPI=ibmOsaExpATMMulticastForwardVPI, ibmOSAExpChannelPCIBusUtilHour=ibmOSAExpChannelPCIBusUtilHour, ibmOsaExpATMConfigDirectVPI=ibmOsaExpATMConfigDirectVPI, ibmOsaExpTRLostFrameErrorCount=ibmOsaExpTRLostFrameErrorCount, ibmOsaExpTRRingState=ibmOsaExpTRRingState, ibmProd=ibmProd, ibmOsaExpTRLobeWireFaultCount=ibmOsaExpTRLobeWireFaultCount, ibmOSAExpPerfDataLP2=ibmOSAExpPerfDataLP2, ibmOSAExpPEMulticastData=ibmOSAExpPEMulticastData, ibmOsaExpATMLocalSegmentID=ibmOsaExpATMLocalSegmentID, ibmOsaExpATMMulticastSendVPI=ibmOsaExpATMMulticastSendVPI, ibmOSAExpATMGroup=ibmOSAExpATMGroup, ibmOsaExpEthInBroadcastFrames=ibmOsaExpEthInBroadcastFrames, ibmOsaExpATMConfigMode=ibmOsaExpATMConfigMode, ibmOsaExpATMMltcstSendVCCType=ibmOsaExpATMMltcstSendVCCType, ibmOSAExpEthGroup=ibmOSAExpEthGroup, ibmOsaExpATMConfigLESATMAddress=ibmOsaExpATMConfigLESATMAddress, ibmOsaExpTRRcvCongestionCount=ibmOsaExpTRRcvCongestionCount, ibmOsaExpTRPortType=ibmOsaExpTRPortType, ibmOsaExpTRSoftErrorCount=ibmOsaExpTRSoftErrorCount, PYSNMP_MODULE_ID=ibmOSAMib, ibmOsaExpTRRingStatus=ibmOsaExpTRRingStatus, ibmOsaExpATMControlDirectVPI=ibmOsaExpATMControlDirectVPI, ibmOsaExpATMSVCFailures=ibmOsaExpATMSVCFailures, ibmOsaExpATMPortType=ibmOsaExpATMPortType, ibmOsaExpATMMulticastSendIntfc=ibmOsaExpATMMulticastSendIntfc, ibmOsaExpTRBurstErrorCount=ibmOsaExpTRBurstErrorCount, ibmOsaExpATMClientCurrentState=ibmOsaExpATMClientCurrentState, ibmOSAExpPEArpActiveEntries=ibmOSAExpPEArpActiveEntries, ibmOSAExpPerfDataLP9=ibmOSAExpPerfDataLP9, ibmOSAExpATMPortTable=ibmOSAExpATMPortTable, ibmOsaExpATMMltcstSendVCCAvgRate=ibmOsaExpATMMltcstSendVCCAvgRate, ibmOsaExpATMLeARPRepliesOut=ibmOsaExpATMLeARPRepliesOut, ibmOsaExpATMServiceMode=ibmOsaExpATMServiceMode, ibmOSAExpChannelProcCodeLevel=ibmOSAExpChannelProcCodeLevel, ibmOsaExpTRLanTrafficState=ibmOsaExpTRLanTrafficState, ibmOsaExpATMMaxUnknownFrameCount=ibmOsaExpATMMaxUnknownFrameCount, ibmOSAExpChannelProcUtil5Min=ibmOSAExpChannelProcUtil5Min, ibmOsaExpATMBestEffortPeakRate=ibmOsaExpATMBestEffortPeakRate, ibmOSAExpPerfDataLP5=ibmOSAExpPerfDataLP5, ibmOSAExpPEIPEntries=ibmOSAExpPEIPEntries, ibmOsaExpATMLanTrafficState=ibmOsaExpATMLanTrafficState, ibmOsaExpTRFullDuplexErrorCount=ibmOsaExpTRFullDuplexErrorCount, ibmOSAExpChannelNumber=ibmOSAExpChannelNumber, ibmOsaExpATMLastFailureState=ibmOsaExpATMLastFailureState, ibmOsaExpATMClientIdentifier=ibmOsaExpATMClientIdentifier, ibmOsaExpTRServiceMode=ibmOsaExpTRServiceMode, ibmOsaExpEthPortType=ibmOsaExpEthPortType, ibmOsaExpATMIBMEnhancedMode=ibmOsaExpATMIBMEnhancedMode, ibmOSAExpPerfDataLP0=ibmOSAExpPerfDataLP0, ibmOsaExpTRFrameCopyErrorCount=ibmOsaExpTRFrameCopyErrorCount, ibmOsaExpATMControlDirectVCI=ibmOsaExpATMControlDirectVCI, ibmOsaExpTRAllowAccessPriority=ibmOsaExpTRAllowAccessPriority, ibmOsaExpATMFlushTimeout=ibmOsaExpATMFlushTimeout, ibmOsaExpATMConfigELANName=ibmOsaExpATMConfigELANName, ibmOSAExpPerfDataLP10=ibmOSAExpPerfDataLP10, ibmOsaExpEthServiceMode=ibmOsaExpEthServiceMode, ibmOSAMibCompliance=ibmOSAMibCompliance, ibmOSAExpChannelNodeDesc=ibmOSAExpChannelNodeDesc, ibmOSAExpPerfDataLP12=ibmOSAExpPerfDataLP12, ibmOsaExpTRPacketsReceived=ibmOsaExpTRPacketsReceived, ibmOsaExpATMMaxRetryCount=ibmOsaExpATMMaxRetryCount, ibmOsaExpATMActualLESATMAddress=ibmOsaExpATMActualLESATMAddress, ibmOSAMibCompliances=ibmOSAMibCompliances, ibmOSAExpChannelProcUtil1Min=ibmOSAExpChannelProcUtil1Min, ibmOsaExpATMActualMaxDataFrmSz=ibmOsaExpATMActualMaxDataFrmSz, ibmOsaExpEthGroupAddrTable=ibmOsaExpEthGroupAddrTable, ibmOsaExpATMLeVersion=ibmOsaExpATMLeVersion, ibmOsaExpATMConfigDirectVCI=ibmOsaExpATMConfigDirectVCI, ibmOSAExpATMPortEntry=ibmOSAExpATMPortEntry, ibmOsaExpATMControlDistributeVCI=ibmOsaExpATMControlDistributeVCI, ibmOsaExpATMConnectCompleteTimer=ibmOsaExpATMConnectCompleteTimer, ibmOsaExpATMDisabledStatus=ibmOsaExpATMDisabledStatus, ibmOSAExpChannelPCIBusUtil5Min=ibmOSAExpChannelPCIBusUtil5Min, ibmOsaExpATMClientATMAddress=ibmOsaExpATMClientATMAddress, ibmOsaExpATMLePDUOctetsInbound=ibmOsaExpATMLePDUOctetsInbound, ibmOsaExpATMConfigSource=ibmOsaExpATMConfigSource, ibmOsaExpATMMcastSendVCCPeakRate=ibmOsaExpATMMcastSendVCCPeakRate, ibmOsaExpATMErrLePDUDiscIn=ibmOsaExpATMErrLePDUDiscIn, ibmOsaExpATMLastFailureRespCode=ibmOsaExpATMLastFailureRespCode, ibmOSAExpPerfDataLP3=ibmOSAExpPerfDataLP3, ibmOSAExpChannelPCIBusUtil1Min=ibmOSAExpChannelPCIBusUtil1Min, ibmOSAExpPerfEntry=ibmOSAExpPerfEntry, ibmOsaExpATMLeARPRepliesIn=ibmOsaExpATMLeARPRepliesIn, ibmOsaExpATMActualLanType=ibmOsaExpATMActualLanType, ibmOsaExpATMPathSwitchingDelay=ibmOsaExpATMPathSwitchingDelay, ibmOSAMibObjects=ibmOSAMibObjects, ibmOSAExpPerfDataLP14=ibmOSAExpPerfDataLP14, ibmOSAMibGroups=ibmOSAMibGroups)

#
# PySNMP MIB module CISCO-IPSLA-AUTOMEASURE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IPSLA-AUTOMEASURE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
IpSlaOperType, IpSlaReactVar = mibBuilder.importSymbols("CISCO-IPSLA-TC-MIB", "IpSlaOperType", "IpSlaReactVar")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InetAddress, InetPortNumber, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, ModuleIdentity, ObjectIdentity, Counter64, iso, Bits, TimeTicks, Integer32, NotificationType, IpAddress, Counter32, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "ObjectIdentity", "Counter64", "iso", "Bits", "TimeTicks", "Integer32", "NotificationType", "IpAddress", "Counter32", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
StorageType, DisplayString, TruthValue, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "DisplayString", "TruthValue", "TextualConvention", "RowStatus")
ciscoIpSlaAutoMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 633))
ciscoIpSlaAutoMIB.setRevisions(('2007-06-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIpSlaAutoMIB.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoIpSlaAutoMIB.setLastUpdated('200706130000Z')
if mibBuilder.loadTexts: ciscoIpSlaAutoMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIpSlaAutoMIB.setContactInfo('Cisco Systems, Inc. Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553 NETS Email: cs-ipsla@cisco.com')
if mibBuilder.loadTexts: ciscoIpSlaAutoMIB.setDescription('This module defines the MIB for IP SLA Automation. IP SLA Automation consists of the following: 1. Use of grouping - Group is an aggregation of operations sharing the same type, for example UDP jitter type, with common characteristics like frequency, interval etc. Groups are formed by policies dictated either per customer, or by service level or any other requirements. So, for example, there could be separate groups for customers named Customer A, Customer B etc, or service levels named Gold-service, Silver-service etc. A single group will contain one and only one IP SLA operation definition or reference a single template. 2. Use of templates - It has been observed that operations can be configured quickly if the variants such as IP address and ports can be configured separately and then combined with a template consisting of invariants. This allows for re-use of the invariant template with various combinations of destination addresses and ports, the benefits for which are multiplied when considering groupings. 3. Auto operations - With this feature the software will try to automatically kickstart operations by making intelligent assumptions. For example, if no specific operation is referenced by the group configuration then an ICMP jitter operation is assumed by default.')
ciscoIpSlaAutoMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 633, 0))
ciscoIpSlaAutoMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 633, 1))
cipslaAutoGroupTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1), )
if mibBuilder.loadTexts: cipslaAutoGroupTable.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupTable.setDescription('A table that contains IP SLA auto measure group definitions.')
cipslaAutoGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1), ).setIndexNames((0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupName"))
if mibBuilder.loadTexts: cipslaAutoGroupEntry.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupEntry.setDescription('An entry containing the configurations for a particular auto measure group.')
cipslaAutoGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cipslaAutoGroupName.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupName.setDescription('A group name which is used by a management application to identify the group.')
cipslaAutoGroupDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupDescription.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDescription.setDescription('This field is used to provide description for the group.')
cipslaAutoGroupDestinationName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupDestinationName.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestinationName.setDescription('This object refers to the cipslaAutoGroupDestName in cipslaAutoGroupDestTable. If the name entered is not present in cipslaAutoGroupDestTable, then when group is scheduled, no ip sla operations will be created.')
cipslaAutoGroupADDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 4), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupADDestPort.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupADDestPort.setDescription('This object represents the destination port number for auto discovery use.')
cipslaAutoGroupOperTemplateName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupOperTemplateName.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupOperTemplateName.setDescription('A string which is used by a management application to identify the template which is associated with the group. Depends on cipslaAutoGroupOperType, this object refers to cipslaIcmpEchoTmplName in cipslaIcmpEchoTmplTable, or cipslaUdpEchoTmplName in cipslaUdpEchoTmplTable, or cipslaTcpConnTmplName in cipslaTcpConnTmplTable, or cipslaIcmpJitterTmplName in cipslaIcmpJitterTmplTable, or ciscoIpSlaUdpJitterTmplName in ciscoIpSlaUdpJitterTmplTable.')
cipslaAutoGroupSchedulerId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedulerId.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedulerId.setDescription('This object refers to the cipslaAutoGroupSchedId in cipslaAutoGroupSchedTable, and is used to schedule this group.')
cipslaAutoGroupQoSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupQoSEnable.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupQoSEnable.setDescription('When this object is set to true, QoS is enabled for this group and this group is linked to policy map. The restriction is that after QoS is enabled, it can not be disabled for this group.')
cipslaAutoGroupOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 8), IpSlaOperType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupOperType.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupOperType.setDescription('This object specifies the type of IP SLA operation. When operation type is not ICMP jitter, then cipslaAutoGroupOperTemplateName must be specified.')
cipslaAutoGroupDestIPADEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupDestIPADEnable.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestIPADEnable.setDescription('When this object is set to true, destination IP address is populated through auto-discovery.')
cipslaAutoGroupADMeasureRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupADMeasureRetry.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupADMeasureRetry.setDescription("This object specifies number of measurement retries to be attempted for the discovered end point after the connection to the end point is broken. If there is no re-registration message received, the end point will be in inactive state. When the value of cipslaAutoGroupDestIPADEnable is 'false', the value of this object has no effect.")
cipslaAutoGroupADDestIPAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupADDestIPAgeout.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupADDestIPAgeout.setDescription("This object represents the ageout time for the discovered end point. If the end point becomes inactive for the period of ageout time, the end point will be removed from the discovered end point list. When the value of cipslaAutoGroupDestIPADEnable is 'false', the value of this object has no effect.")
cipslaAutoGroupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 12), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupStorageType.setDescription('The storage type of this conceptual row.')
cipslaAutoGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 1, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupRowStatus.setDescription('The status of the conceptual group control row. When the status is active, the other writable objects may be modified unless the scheduler with name specified by cipslaAutoGroupSchedulerId is scheduled.')
cipslaAutoGroupDestTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2), )
if mibBuilder.loadTexts: cipslaAutoGroupDestTable.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestTable.setDescription('A table contains the list of destination IP addresses and ports associated to the auto measure group destination name.')
cipslaAutoGroupDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1), ).setIndexNames((0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestName"), (0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestIpAddrType"), (0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestIpAddr"), (0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestPort"))
if mibBuilder.loadTexts: cipslaAutoGroupDestEntry.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestEntry.setDescription('An entry containing the destination IP addresses and port configurations associated to auto measure group destination name.')
cipslaAutoGroupDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cipslaAutoGroupDestName.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestName.setDescription('This is the name for an auto measure group destination.')
cipslaAutoGroupDestIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 2), InetAddressType())
if mibBuilder.loadTexts: cipslaAutoGroupDestIpAddrType.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestIpAddrType.setDescription('The type of the internet address of a destination for an auto measure group.')
cipslaAutoGroupDestIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 3), InetAddress())
if mibBuilder.loadTexts: cipslaAutoGroupDestIpAddr.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestIpAddr.setDescription('The internet address of a destination for an auto measure group. The type of this address is determined by the value of cipslaAutoGroupDestIpAddrType.')
cipslaAutoGroupDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 4), InetPortNumber())
if mibBuilder.loadTexts: cipslaAutoGroupDestPort.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestPort.setDescription("This object represents the destination port number. For ICMP echo and ICMP jitter, the suggested value is '0'.")
cipslaAutoGroupDestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupDestStorageType.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestStorageType.setDescription('The storage type of this conceptual row. By default the entry will be saved into non-volatile memory.')
cipslaAutoGroupDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupDestRowStatus.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupDestRowStatus.setDescription("The status of the conceptual destination table control row. No other objects in this row need to be set before this object can become active. During 'destroy', when cipslaAutoGroupDestIpAddr is specified as '0.0.0.0' and cipslaAutoGroupDestPort is specified as '0', then all the rows with same cipslaAutoGroupDestName will be deleted.")
cipslaReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3), )
if mibBuilder.loadTexts: cipslaReactTable.setStatus('current')
if mibBuilder.loadTexts: cipslaReactTable.setDescription('A table that contains reaction configurations for templates. Each conceptual row in cipslaReactTable corresponds to a reaction configured for one template. Each template can have multiple reactions and hence there can be multiple rows for a particular template. Different template types can have different reactions. The reaction type is specified as cipslaReactVar based upon template type as some reaction types are applicable just for specific template types.')
cipslaReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1), ).setIndexNames((0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupOperType"), (0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactConfigIndex"), (0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupOperTemplateName"))
if mibBuilder.loadTexts: cipslaReactEntry.setStatus('current')
if mibBuilder.loadTexts: cipslaReactEntry.setDescription('A base list of objects that define a conceptual reaction configuration control row.')
cipslaReactConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cipslaReactConfigIndex.setStatus('current')
if mibBuilder.loadTexts: cipslaReactConfigIndex.setDescription('This object along with cipslaAutoGroupOperType and cipslaAutoGroupOperTemplateName identifies a particular reaction-configuration for one IP SLA template. This number is persistent across reboots.')
cipslaReactVar = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 2), IpSlaReactVar()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactVar.setStatus('current')
if mibBuilder.loadTexts: cipslaReactVar.setDescription("This object specifies the type of reaction configured for an IP SLA template. Default value is 'rtt' for ICMP echo, UDP echo and TCP connect. Default value is 'jitterAvg' for UDP jitter and ICMP jitter. The reaction types 'rtt', 'timeout', 'connectionLoss' and 'verifyError' can be configured for all template types. The reaction types 'jitterSDAvg', 'jitterDSAvg', 'jitterAvg', 'packetLateArrival', 'packetOutOfSequence', 'maxOfPositiveSD', 'maxOfNegativeSD', 'maxOfPositiveDS' 'maxOfNegativeDS', 'mos' and 'icpif' can be configured for UDP jitter and ICMP jitter types only. The reaction types 'packetLossDS', 'packetLossSD' and 'packetMIA' can be configured for UDP jitter type only. The reaction types 'successivePacketLoss', 'maxOfLatencyDS', 'maxOfLatencySD', 'latencyDSAvg', 'latencySDAvg' and 'packetLoss' can be configured for ICMP jitter type only.")
cipslaReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactThresholdType.setStatus('current')
if mibBuilder.loadTexts: cipslaReactThresholdType.setDescription("This object specifies the conditions under which a notification ( trap ) is sent. The rttMonReactOccurred object defined in rttMonReactTable in CISCO-RTTMON-MIB will change accordingly: never(1) - rttMonReactOccurred is never set immediate(2) - rttMonReactOccurred is set to 'true' when the value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold. Conversely, rttMonReactOccurred is set to 'false' when the parameter ( e.g rtt, jitterAvg, packetLossSD, mos etc ) is below the threshold limits. consecutive(3) - rttMonReactOccurred is set to true when the value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold for configured consecutive times. Conversely, rttMonReactOccurred is set to false when the value of parameter ( e.g rtt, jitterAvg packetLossSD, mos etc ) is below the threshold limits for the same number of consecutive operations. xOfy(4) - rttMonReactOccurred is set to true when x ( as specified by cipslaReactThresholdCountX ) out of the last y ( as specified by cipslaReacthresholdCountY ) times the value of parameter for which the reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold. Conversely, it is set to false when x, out of the last y times the value of parameter ( e.g rtt, jitterAvg, packetLossSD, mos ) is below the threshold limits. NOTE: If x > y, this will never generate a reaction. average(5) - rttMonReactOccurred is set to true when the average ( cipslaReactThresholdCountX times ) value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold condition. Conversely, it is set to false when the average value of parameter ( e.g rtt, jitterAvg, packetLossSD, mos etc ) is below the threshold limits. If this value is changed by a management station, rttMonReactOccurred is set to false, but no reaction is generated if the prior value of rttMonReactOccurred was true.")
cipslaReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("notificationOnly", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactActionType.setStatus('current')
if mibBuilder.loadTexts: cipslaReactActionType.setDescription('Specifies what type, if any, of reaction to generate if one of the watched (reaction-configuration ) conditions is satisfied: none(1) - no reaction is generated notificationOnly(2) - a notification is generated')
cipslaReactThresholdRising = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactThresholdRising.setStatus('current')
if mibBuilder.loadTexts: cipslaReactThresholdRising.setDescription("This object defines the higher threshold limit. If the value ( e.g rtt, jitterAvg, packetLossSD etc ) rises above this limit and if the condition specified in cipslaReactThresholdType is satisfied, a notification is generated. Default value of cipslaReactThresholdRising for 'rtt' is 5000 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' 100. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'mos' is 500. 'icpif' is 93. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'successivePacketLoss' is 1000. 'maxOfLatencyDS' is 5000. 'maxOfLatencySD' is 5000. 'latencyDSAvg' is 5000. 'latencySDAvg' is 5000. 'packetLoss' is 10000. This object is not applicable if the cipslaReactVar is 'timeout', 'connectionLoss' or 'verifyError'. For 'timeout', 'connectionLoss' and 'verifyError' default value of cipslaReactThresholdRising will be 0.")
cipslaReactThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactThresholdFalling.setStatus('current')
if mibBuilder.loadTexts: cipslaReactThresholdFalling.setDescription("This object defines a lower threshold limit. If the value ( e.g rtt, jitterAvg, packetLossSD etc ) falls below this limit and if the condition specified in cipslaReactThresholdType is satisfied, a notification is generated. This object value can not bigger than cipslaReactThresholdRising value. Default value of cipslaReactThresholdFalling 'rtt' is 3000 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' 100. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'mos' is 500. 'icpif' is 93. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'successivePacketLoss' is 1000. 'maxOfLatencyDS' is 3000. 'maxOfLatencySD' is 3000. 'latencyDSAvg' is 3000. 'latencySDAvg' is 3000. 'packetLoss' is 10000. This object is not applicable if the cipslaReactVar is 'timeout', 'connectionLoss' or 'verifyError'. For 'timeout', 'connectionLoss' and 'verifyError', default value of cipslaReactThresholdFalling will be 0.")
cipslaReactThresholdCountX = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactThresholdCountX.setStatus('current')
if mibBuilder.loadTexts: cipslaReactThresholdCountX.setDescription("If cipslaReactThresholdType value is 'xOfy', this object defines the 'x' value. If cipslaReactThresholdType value is 'consecutive' this object defines the number of consecutive occurrences that needs threshold violation before setting cipslaReactOccurred as true. If cipslaReactThresholdType value is 'average' this object defines the number of samples that needs be considered for calculating average. This object has no meaning if cipslaReactThresholdType has value of 'never' and 'immediate'.")
cipslaReactThresholdCountY = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactThresholdCountY.setStatus('current')
if mibBuilder.loadTexts: cipslaReactThresholdCountY.setDescription("This object defines the 'y' value of the xOfy condition if cipslaReactThresholdType is 'xOfy'. The default for the 'y' value is 5. For other values of cipslaReactThresholdType, this object is not applicable.")
cipslaReactStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactStorageType.setStatus('current')
if mibBuilder.loadTexts: cipslaReactStorageType.setDescription('The storage type of this conceptual row. By default the entry will be saved into non-volatile memory.')
cipslaReactRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 3, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaReactRowStatus.setStatus('current')
if mibBuilder.loadTexts: cipslaReactRowStatus.setDescription("This objects indicates the status of the conceptual Reaction Control Row. When this object moves to active state, the conceptual row is monitored and notifications are generated when threshold violation takes place. In order for this object to become active cipslaReactVar must be defined. All other objects assume default values. When the status is active, the following objects in that row can be modified. cipslaReactThresholdType, cipslaReactActionType, cipslaReactThresholdRising, cipslaReactThresholdFalling, cipslaReactThresholdCountX, cipslaReactThresholdCountY, cipslaReactStorageType This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' no reaction configuration would exist. The reaction configuration for the template is removed.")
cipslaAutoGroupSchedTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4), )
if mibBuilder.loadTexts: cipslaAutoGroupSchedTable.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedTable.setDescription('A table of group scheduling definitions.')
cipslaAutoGroupSchedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1), ).setIndexNames((0, "CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedId"))
if mibBuilder.loadTexts: cipslaAutoGroupSchedEntry.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedEntry.setDescription('A list of objects that define specific configuration for group scheduling.')
cipslaAutoGroupSchedId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cipslaAutoGroupSchedId.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedId.setDescription('This string uniquely identifies a row in the cipslaAutoGroupSchedTable.')
cipslaAutoGroupSchedPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 99000)).clone(1000)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedPeriod.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedPeriod.setDescription('Specifies the time duration between initiating two IP SLA operations generated via the auto measure group.')
cipslaAutoGroupSchedInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedInterval.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedInterval.setDescription('Specifies the duration between initiating each RTT operation for one IP SLA operation generated via the auto measure group. The value of this object is only effective when both cipslaAutoGroupSchedMaxInterval and cipslaAutoGroupSchedMinInterval have zero values.')
cipslaAutoGroupSchedLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedLife.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedLife.setDescription("This object specifies the life of all the operations that are getting group scheduled. This value will be placed into cipslaAutoGroupSchedRttLife object when this conceptual control row becomes 'active'. The value 2147483647 has a special meaning. When this object is set to 2147483647, the rttMonCtrlOperRttLife object for all the operations will not decrement, and thus the life time of the operation will never end.")
cipslaAutoGroupSchedAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedAgeout.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedAgeout.setDescription("This object specifies the ageout value of the operations that are getting group scheduled. This value will be placed into rttMonSchedAdminConceptRowAgeout object for each of the operations in the group when this conceptual control row becomes 'active'. When this value is set to zero, the operations will never ageout.")
cipslaAutoGroupSchedMaxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedMaxInterval.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedMaxInterval.setDescription('Specifies the max duration between initiating each RTT operation for one IP SLA operation in the group.')
cipslaAutoGroupSchedMinInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedMinInterval.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedMinInterval.setDescription('Specifies the min duration between initiating each RTT operation for one IP SLA operation in the group. The value of this object should be lower than the value of cipslaAutoGroupSchedMaxInterval.')
cipslaAutoGroupSchedStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedStartTime.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedStartTime.setDescription("This is the time in seconds after which the operations of the associated groups will take transition to active state. When set to the value other than '1' (pending), then all objects in this row cannot be modified.")
cipslaAutoGroupSchedStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedStorageType.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedStorageType.setDescription('The storage type of this conceptual row. By default the entry will be saved into non-volatile memory.')
cipslaAutoGroupSchedRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 633, 1, 4, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cipslaAutoGroupSchedRowStatus.setStatus('current')
if mibBuilder.loadTexts: cipslaAutoGroupSchedRowStatus.setDescription("The status of the conceptual group schedule control row. When the status is active and the value of cipslaAutoGroupSchedStartTime is '1', the other writable objects may be modified. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' it will stop all the operations which had been group scheduled by it earlier, before destroying the group schedule control row.")
ciscoIpSlaAutoMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 633, 2))
ciscoIpSlaAutoMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 1))
ciscoIpSlaAutoMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 2))
ciscoIpSlaAutoMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 1, 1)).setObjects(("CISCO-IPSLA-AUTOMEASURE-MIB", "ciscoIpSlaAutoGroupConfGroup"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "ciscoIpSlaAutoGroupDestGroup"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "ciscoIpSlaAutoGroupReactGroup"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "ciscoIpSlaAutoGroupSchedGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaAutoMIBCompliance = ciscoIpSlaAutoMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaAutoMIBCompliance.setDescription('The compliance statement for IP SLA (1) Auto Measure Group Table (2) Destination Table (3) Reaction Table (4) Group Schedule Table')
ciscoIpSlaAutoGroupConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 2, 1)).setObjects(("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDescription"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestinationName"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupADDestPort"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupOperTemplateName"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedulerId"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupQoSEnable"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupOperType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestIPADEnable"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupADMeasureRetry"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupADDestIPAgeout"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupStorageType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaAutoGroupConfGroup = ciscoIpSlaAutoGroupConfGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaAutoGroupConfGroup.setDescription('A collection of objects related to IP SLA auto meaure group configuration.')
ciscoIpSlaAutoGroupDestGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 2, 2)).setObjects(("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestStorageType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupDestRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaAutoGroupDestGroup = ciscoIpSlaAutoGroupDestGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaAutoGroupDestGroup.setDescription('A collection of objects related to IP SLA auto measure group destination configuration.')
ciscoIpSlaAutoGroupReactGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 2, 3)).setObjects(("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactVar"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactThresholdType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactActionType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactThresholdRising"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactThresholdFalling"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactThresholdCountX"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactThresholdCountY"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactStorageType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaReactRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaAutoGroupReactGroup = ciscoIpSlaAutoGroupReactGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaAutoGroupReactGroup.setDescription('A collection of objects related to IP SLA auto measure reaction configuration.')
ciscoIpSlaAutoGroupSchedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 633, 2, 2, 4)).setObjects(("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedPeriod"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedInterval"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedLife"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedAgeout"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedMaxInterval"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedMinInterval"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedStartTime"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedStorageType"), ("CISCO-IPSLA-AUTOMEASURE-MIB", "cipslaAutoGroupSchedRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaAutoGroupSchedGroup = ciscoIpSlaAutoGroupSchedGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaAutoGroupSchedGroup.setDescription('A collection of objects related to IP SLA auto measure group schedule configuration.')
mibBuilder.exportSymbols("CISCO-IPSLA-AUTOMEASURE-MIB", cipslaReactThresholdFalling=cipslaReactThresholdFalling, cipslaAutoGroupSchedRowStatus=cipslaAutoGroupSchedRowStatus, ciscoIpSlaAutoGroupDestGroup=ciscoIpSlaAutoGroupDestGroup, cipslaAutoGroupDestIpAddrType=cipslaAutoGroupDestIpAddrType, ciscoIpSlaAutoMIB=ciscoIpSlaAutoMIB, cipslaReactStorageType=cipslaReactStorageType, cipslaAutoGroupSchedEntry=cipslaAutoGroupSchedEntry, cipslaAutoGroupDestStorageType=cipslaAutoGroupDestStorageType, cipslaAutoGroupSchedInterval=cipslaAutoGroupSchedInterval, cipslaAutoGroupSchedulerId=cipslaAutoGroupSchedulerId, cipslaReactThresholdType=cipslaReactThresholdType, ciscoIpSlaAutoGroupReactGroup=ciscoIpSlaAutoGroupReactGroup, cipslaReactThresholdRising=cipslaReactThresholdRising, ciscoIpSlaAutoMIBConform=ciscoIpSlaAutoMIBConform, cipslaAutoGroupRowStatus=cipslaAutoGroupRowStatus, PYSNMP_MODULE_ID=ciscoIpSlaAutoMIB, ciscoIpSlaAutoMIBCompliance=ciscoIpSlaAutoMIBCompliance, cipslaAutoGroupDestEntry=cipslaAutoGroupDestEntry, cipslaAutoGroupQoSEnable=cipslaAutoGroupQoSEnable, cipslaAutoGroupSchedStartTime=cipslaAutoGroupSchedStartTime, cipslaAutoGroupADDestIPAgeout=cipslaAutoGroupADDestIPAgeout, cipslaAutoGroupDestIpAddr=cipslaAutoGroupDestIpAddr, cipslaAutoGroupDestIPADEnable=cipslaAutoGroupDestIPADEnable, cipslaAutoGroupSchedAgeout=cipslaAutoGroupSchedAgeout, cipslaReactEntry=cipslaReactEntry, cipslaAutoGroupSchedId=cipslaAutoGroupSchedId, ciscoIpSlaAutoMIBObjects=ciscoIpSlaAutoMIBObjects, cipslaReactConfigIndex=cipslaReactConfigIndex, cipslaAutoGroupSchedLife=cipslaAutoGroupSchedLife, cipslaAutoGroupDestPort=cipslaAutoGroupDestPort, ciscoIpSlaAutoMIBGroups=ciscoIpSlaAutoMIBGroups, cipslaAutoGroupTable=cipslaAutoGroupTable, cipslaReactVar=cipslaReactVar, ciscoIpSlaAutoMIBNotifs=ciscoIpSlaAutoMIBNotifs, cipslaAutoGroupSchedMinInterval=cipslaAutoGroupSchedMinInterval, cipslaReactThresholdCountX=cipslaReactThresholdCountX, cipslaAutoGroupSchedStorageType=cipslaAutoGroupSchedStorageType, cipslaAutoGroupOperTemplateName=cipslaAutoGroupOperTemplateName, cipslaAutoGroupDescription=cipslaAutoGroupDescription, cipslaAutoGroupEntry=cipslaAutoGroupEntry, cipslaAutoGroupADDestPort=cipslaAutoGroupADDestPort, cipslaAutoGroupADMeasureRetry=cipslaAutoGroupADMeasureRetry, cipslaAutoGroupDestTable=cipslaAutoGroupDestTable, cipslaReactActionType=cipslaReactActionType, cipslaReactThresholdCountY=cipslaReactThresholdCountY, cipslaAutoGroupSchedPeriod=cipslaAutoGroupSchedPeriod, cipslaAutoGroupStorageType=cipslaAutoGroupStorageType, cipslaReactTable=cipslaReactTable, ciscoIpSlaAutoGroupSchedGroup=ciscoIpSlaAutoGroupSchedGroup, cipslaAutoGroupName=cipslaAutoGroupName, cipslaAutoGroupDestRowStatus=cipslaAutoGroupDestRowStatus, cipslaAutoGroupOperType=cipslaAutoGroupOperType, cipslaReactRowStatus=cipslaReactRowStatus, ciscoIpSlaAutoGroupConfGroup=ciscoIpSlaAutoGroupConfGroup, cipslaAutoGroupDestinationName=cipslaAutoGroupDestinationName, cipslaAutoGroupSchedMaxInterval=cipslaAutoGroupSchedMaxInterval, ciscoIpSlaAutoMIBCompliances=ciscoIpSlaAutoMIBCompliances, cipslaAutoGroupSchedTable=cipslaAutoGroupSchedTable, cipslaAutoGroupDestName=cipslaAutoGroupDestName)

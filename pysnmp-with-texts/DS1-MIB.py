#
# PySNMP MIB module DS1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DS1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:13:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
PerfTotalCount, PerfCurrentCount, PerfIntervalCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfTotalCount", "PerfCurrentCount", "PerfIntervalCount")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter64, iso, MibIdentifier, ModuleIdentity, transmission, Unsigned32, Integer32, Gauge32, IpAddress, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Bits, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "MibIdentifier", "ModuleIdentity", "transmission", "Unsigned32", "Integer32", "Gauge32", "IpAddress", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Bits", "TimeTicks")
TextualConvention, DisplayString, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TimeStamp", "TruthValue")
ds1 = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 18))
ds1.setRevisions(('2007-03-05 00:00', '2004-09-09 00:00', '1998-08-01 18:30', '1993-01-25 20:28',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ds1.setRevisionsDescriptions(('The following changes were made: (1) Values were added to dsx1LineType to support J1 types. (2) The object dsx1LineImpedance was added. (3) All DM-related objects were deprecated following their removal from ITU performance standards. The RFC 4805 version of this MIB module.', 'The RFC 3895 version of this MIB module. The key changes made to this MIB module since its publication in RFC 2495 are as follows: (1) The dsx1FracIfIndex SYNTAX matches the description range. (2) A value was added to dsx1TransmitClockSource. (3) Values were added to dsx1LineType. (4) Two objects were added, dsx1LineMode and dsx1LineBuildOut, to better express transceiver mode and LineBuildOut for T1. (5) Reference was added to Circuit Identifier object. (6) Align the DESCRIPTION clauses of few statistic objects with the near-end definition, with the far-end definition, and with RFC 3593. (7) Changes in Compliance Statements to include new objects. (8) A typographical error in dsx2E2 was fixed; the new name is dsx1E2.', 'The RFC 2495 version of this MIB module. The key changes made to this MIB module since its publication in RFC 1406 are as follows: (1) The Fractional table has been deprecated. (2) This document uses SMIv2. (3) Usage is given for ifTable and ifXTable. (4) Example usage of ifStackTable is included. (5) dsx1IfIndex has been deprecated. (6) Support for DS2 and E2 has been added. (7) Additional lineTypes for DS2, E2, and unframed E1 were added. (8) The definition of valid intervals has been clarified for the case where the agent proxied for other devices. In particular, the treatment of missing intervals has been clarified. (9) An inward loopback has been added. (10) Additional lineStatus bits have been added for Near End in Unavailable Signal State, Carrier Equipment Out of Service, DS2 Payload AIS, and DS2 Performance Threshold. (11) A read-write line Length object has been added. (12) Signal mode of other has been added. (13) Added a lineStatus last change, trap and enabler. (14) The e1(19) ifType has been obsoleted, so this MIB does not list it as a supported ifType. (15) Textual Conventions for statistics objects have been used. (16) A new object, dsx1LoopbackStatus, has been introduced to reflect the loopbacks established on a DS1 interface and the source to the requests. dsx1LoopbackConfig continues to be the desired loopback state while dsx1LoopbackStatus reflects the actual state. (17) A dual loopback has been added to allow the setting of an inward loopback and a line loopback at the same time. (18) An object indicating which channel to use within a parent object (i.e., DS3) has been added. (19) An object has been added to indicate whether or not this DS1/E1 is channelized. (20) Line coding type of B6ZS has been added for DS2.', 'Initial version, published as RFC 1406.',))
if mibBuilder.loadTexts: ds1.setLastUpdated('200703050000Z')
if mibBuilder.loadTexts: ds1.setOrganization('IETF AToM MIB Working Group')
if mibBuilder.loadTexts: ds1.setContactInfo('WG charter: http://www.ietf.org/html.charters/atommib-charter.html Mailing Lists: General Discussion: atommib@research.telcordia.com To Subscribe: atommib-request@research.telcordia.com Editor: Orly Nicklass Postal: RAD Data Communications, Ltd. Ziv Tower, 24 Roul Walenberg Tel Aviv, Israel, 69719 Tel: +9723 765 9969 E-mail: orly_n@rad.com')
if mibBuilder.loadTexts: ds1.setDescription('The MIB module to describe DS1, J1, E1, DS2, and E2 interfaces objects. Copyright (c) The IETF Trust (2007). This version of this MIB module is part of RFC 4805; see the RFC itself for full legal notices.')
dsx1ConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 6), )
if mibBuilder.loadTexts: dsx1ConfigTable.setStatus('current')
if mibBuilder.loadTexts: dsx1ConfigTable.setDescription('The DS1 Configuration table.')
dsx1ConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 6, 1), ).setIndexNames((0, "DS1-MIB", "dsx1LineIndex"))
if mibBuilder.loadTexts: dsx1ConfigEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1ConfigEntry.setDescription('An entry in the DS1 Configuration table.')
dsx1LineIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1LineIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1LineIndex.setDescription('This object should be made equal to ifIndex. The next paragraph describes its previous usage. Making the object equal to ifIndex allows proper use of the ifStackTable and ds0/ds0bundle MIBs. Previously, this object was the identifier of a DS1 interface on a managed device. If there is an ifEntry that is directly associated with this and only this DS1 interface, it should have the same value as ifIndex. Otherwise, number the dsx1LineIndices with a unique identifier following the rules of choosing a number that is greater than ifNumber and numbering the inside interfaces (e.g., equipment side) with even numbers and outside interfaces (e.g., network side) with odd numbers.')
dsx1IfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1IfIndex.setDescription('This value for this object is equal to the value of ifIndex from the Interfaces table (RFC 2863).')
dsx1TimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TimeElapsed.setStatus('current')
if mibBuilder.loadTexts: dsx1TimeElapsed.setDescription("The number of seconds that have elapsed since the beginning of the near-end current error- measurement period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
dsx1ValidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1ValidIntervals.setStatus('current')
if mibBuilder.loadTexts: dsx1ValidIntervals.setDescription('The number of previous near-end intervals for which data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15-minute near-end intervals since the interface has been online. In the case where the agent is a proxy, it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available.')
dsx1LineType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16))).clone(namedValues=NamedValues(("other", 1), ("dsx1ESF", 2), ("dsx1D4", 3), ("dsx1E1", 4), ("dsx1E1CRC", 5), ("dsx1E1MF", 6), ("dsx1E1CRCMF", 7), ("dsx1Unframed", 8), ("dsx1E1Unframed", 9), ("dsx1DS2M12", 10), ("dsx1E2", 11), ("dsx1E1Q50", 12), ("dsx1E1Q50CRC", 13), ("dsx1J1ESF", 14), ("dsx1J1Unframed", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineType.setReference('American National Standard for telecommunications - digital hierarchy - formats specification, ANSI T1.107- 1988. ITU-T G.703: Physical/Electrical Characteristics of Hierarchical Digital Interfaces, November 2001. ITU-T G.704: Synchronous frame structures used at 1544, 6312, 2048, 8488 and 44 736 kbit/s Hierarchical Levels, July 1995. JT-G704: Synchronous frame structures used at Primary and Secondary Hierarchical Levels,2002. JT-G706. Frame Alignment and Cyclic Redundancy Check (CRC) Procedures. JT-I431. ISDN Primary Rate User-Network Interface, Layer 1 Specifications, 2002 ')
if mibBuilder.loadTexts: dsx1LineType.setStatus('current')
if mibBuilder.loadTexts: dsx1LineType.setDescription('This variable indicates the variety of DS1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. The values, in sequence, describe: TITLE: SPECIFICATION: dsx1ESF Extended SuperFrame DS1 (T1.107) dsx1D4 AT&T D4 format DS1 (T1.107) dsx1E1 ITU-T G.704, (Table 5A) dsx1E1-CRC ITU-T G.704, (Table 5B) dsxE1-MF G.704 (Table 5A) with TS16 multiframing enabled dsx1E1-CRC-MF G.704 (Table 5B) with TS16 multiframing enabled dsx1Unframed DS1 with No Framing dsx1E1Unframed E1 with No Framing (G.703) dsx1DS2M12 DS2 frame format (T1.107) dsx1E2 E2 frame format (G.704) dsx1E1Q50 TS16 bits 5,7,8 set to 101, [in all other cases it is set to 111.] (G.704, table 14) dsx1E1Q50CRC E1Q50 with CRC dsx1J1ESF J1 according to (JT-G704, JT-G706, and JT-I431) dsx1J1Unframed J1 with No Framing For clarification, the capacity for each E1 type is as listed below: dsx1E1Unframed - E1, no framing = 32 x 64k = 2048k dsx1E1 or dsx1E1CRC - E1, with framing, no signalling = 31 x 64k = 1984k dsx1E1MF or dsx1E1CRCMF - E1, with framing, signalling = 30 x 64k = 1920k')
dsx1LineCoding = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("dsx1JBZS", 1), ("dsx1B8ZS", 2), ("dsx1HDB3", 3), ("dsx1ZBTSI", 4), ("dsx1AMI", 5), ("other", 6), ("dsx1B6ZS", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineCoding.setStatus('current')
if mibBuilder.loadTexts: dsx1LineCoding.setDescription('This variable describes the variety of Zero Code Suppression used on this interface, which in turn affects a number of its characteristics. dsx1JBZS refers the Jammed Bit Zero Suppression, in which the AT&T specification of at least one pulse every 8-bit period is literally implemented by forcing a pulse in bit 8 of each channel. Thus, only 7 bits per channel, or 1.344 Mbps, are available for data. dsx1B8ZS refers to the use of a specified pattern of normal bits and bipolar violations that are used to replace a sequence of 8 zero bits. ANSI Clear Channels may use dsx1ZBTSI, or Zero Byte Time Slot Interchange. E1 links, with or without CRC, use dsx1HDB3 or dsx1AMI. dsx1AMI refers to a mode wherein no Zero Code Suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data that meets or exceeds the pulse density requirements, such as inverting HDLC data. dsx1B6ZS refers to the user of a specified pattern of normal bits and bipolar violations that are used to replace a sequence of 6 zero bits. Used for DS2. For more information about line coding see [ANSI-T1.102]')
dsx1SendCode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("dsx1SendNoCode", 1), ("dsx1SendLineCode", 2), ("dsx1SendPayloadCode", 3), ("dsx1SendResetCode", 4), ("dsx1SendQRS", 5), ("dsx1Send511Pattern", 6), ("dsx1Send3in24Pattern", 7), ("dsx1SendOtherTestPattern", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1SendCode.setStatus('current')
if mibBuilder.loadTexts: dsx1SendCode.setDescription('This variable indicates what type of code is being sent across the DS1 interface by the device. Setting this variable causes the interface to send the code requested. The values mean the following: dsx1SendNoCode sending looped or normal data dsx1SendLineCode sending a request for a line loopback dsx1SendPayloadCode sending a request for a payload loopback dsx1SendResetCode sending a loopback termination request dsx1SendQRS sending a Quasi-Random Signal (QRS) test pattern dsx1Send511Pattern sending a 511-bit fixed test pattern dsx1Send3in24Pattern sending a fixed test pattern of 3 bits set in 24 dsx1SendOtherTestPattern sending a test pattern other than those described by this object')
dsx1CircuitIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1CircuitIdentifier.setReference('ITU-T M.1400')
if mibBuilder.loadTexts: dsx1CircuitIdentifier.setStatus('current')
if mibBuilder.loadTexts: dsx1CircuitIdentifier.setDescription("This variable contains the transmission vendor's circuit identifier, for the purpose of facilitating troubleshooting.")
dsx1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("dsx1NoLoop", 1), ("dsx1PayloadLoop", 2), ("dsx1LineLoop", 3), ("dsx1OtherLoop", 4), ("dsx1InwardLoop", 5), ("dsx1DualLoop", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LoopbackConfig.setStatus('current')
if mibBuilder.loadTexts: dsx1LoopbackConfig.setDescription("This variable represents the desired loopback configuration of the DS1 interface. Agents supporting read/write access should return inconsistentValue in response to a requested loopback state that the interface does not support. The values mean: dsx1NoLoop not in the loopback state. A device that is not capable of performing a loopback on the interface shall always return this as its value. dsx1PayloadLoop the received signal at this interface is looped through the device. Typically, the received signal is looped back for retransmission after it has passed through the device's framing function. dsx1LineLoop the received signal at this interface does not go through the device (minimum penetration) but is looped back out. dsx1OtherLoop loopbacks that are not defined here. dsx1InwardLoop the transmitted signal at this interface is looped back and received by the same interface. What is transmitted onto the line is product dependent. dsx1DualLoop both dsx1LineLoop and dsx1InwardLoop will be active simultaneously.")
dsx1LineStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 131071))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1LineStatus.setStatus('current')
if mibBuilder.loadTexts: dsx1LineStatus.setDescription('This variable indicates the line status of the interface. It contains loopback, failure, received alarm and transmitted alarms information. The dsx1LineStatus is a bitmap represented as a sum; therefore, it can represent multiple failures (alarms) and a LoopbackState simultaneously. dsx1NoAlarm must be set if and only if no other flag is set. If the dsx1loopbackState bit is set, the loopback in effect can be determined from the dsx1loopbackConfig object. The various bit positions are as follows: 1 dsx1NoAlarm No alarm present 2 dsx1RcvFarEndLOF Far end LOF (a.k.a. Yellow Alarm) 4 dsx1XmtFarEndLOF Near end sending LOF indication 8 dsx1RcvAIS Far end sending AIS 16 dsx1XmtAIS Near end sending AIS 32 dsx1LossOfFrame Near end LOF (a.k.a. Red Alarm) 64 dsx1LossOfSignal Near end Loss of Signal 128 dsx1LoopbackState Near end is looped 256 dsx1T16AIS E1 TS16 AIS 512 dsx1RcvFarEndLOMF Far end sending TS16 LOMF 1024 dsx1XmtFarEndLOMF Near end sending TS16 LOMF 2048 dsx1RcvTestCode Near end detects a test code 4096 dsx1OtherFailure Any line status not defined here 8192 dsx1UnavailSigState Near end in unavailable signal state 16384 dsx1NetEquipOOS Carrier equipment out of service 32768 dsx1RcvPayloadAIS DS2 payload AIS 65536 dsx1Ds2PerfThreshold DS2 performance threshold exceeded')
dsx1SignalMode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("robbedBit", 2), ("bitOriented", 3), ("messageOriented", 4), ("other", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1SignalMode.setStatus('current')
if mibBuilder.loadTexts: dsx1SignalMode.setDescription("'none' indicates that no bits are reserved for signaling on this channel. 'robbedBit' indicates that DS1 Robbed Bit Signaling is in use. 'bitOriented' indicates that E1 Channel Associated Signaling is in use. 'messageOriented' indicates that Common Channel Signaling is in use on either channel 16 of an E1 link or channel 24 of a DS1.")
dsx1TransmitClockSource = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2), ("throughTiming", 3), ("adaptive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TransmitClockSource.setStatus('current')
if mibBuilder.loadTexts: dsx1TransmitClockSource.setDescription("The source of transmit clock. 'loopTiming' indicates that the recovered receive clock is used as the transmit clock. 'localTiming' indicates that a local clock source is used or when an external clock is attached to the box containing the interface. 'throughTiming' indicates that recovered receive clock from another interface is used as the transmit clock. 'adaptive' indicates that the clock is recovered based on the data flow and not based on the physical layer")
dsx1Fdl = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1Fdl.setStatus('current')
if mibBuilder.loadTexts: dsx1Fdl.setDescription("This bitmap describes the use of the facilities data link and is the sum of the capabilities. Set any bits that are appropriate: other(1), dsx1AnsiT1403(2), dsx1Att54016(4), dsx1FdlNone(8) 'other' indicates that a protocol other than one of the following is used. 'dsx1AnsiT1403' refers to the FDL exchange recommended by ANSI. 'dsx1Att54016' refers to ESF FDL exchanges. 'dsx1FdlNone' indicates that the device does not use the FDL.")
dsx1InvalidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1InvalidIntervals.setStatus('current')
if mibBuilder.loadTexts: dsx1InvalidIntervals.setDescription('The number of intervals in the range from 0 to dsx1ValidIntervals for which no data is available. This object will typically be zero except in cases where the data for some intervals is not available (e.g., in proxy situations).')
dsx1LineLength = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64000))).setUnits('meters').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineLength.setStatus('current')
if mibBuilder.loadTexts: dsx1LineLength.setDescription('The length of the DS1 line in meters. This object provides information for line build-out circuitry. This object is only useful if the interface has configurable line build-out circuitry.')
dsx1LineStatusLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1LineStatusLastChange.setStatus('current')
if mibBuilder.loadTexts: dsx1LineStatusLastChange.setDescription("The value of MIB II's sysUpTime object at the time this DS1 entered its current line status state. If the current state was entered prior to the last re-initialization of the proxy-agent, then this object contains a zero value.")
dsx1LineStatusChangeTrapEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineStatusChangeTrapEnable.setStatus('current')
if mibBuilder.loadTexts: dsx1LineStatusChangeTrapEnable.setDescription('Indicates whether dsx1LineStatusChange traps should be generated for this interface.')
dsx1LoopbackStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1LoopbackStatus.setStatus('current')
if mibBuilder.loadTexts: dsx1LoopbackStatus.setDescription('This variable represents the current state of the loopback on the DS1 interface. It contains information about loopbacks established by a manager and remotely from the far end. The dsx1LoopbackStatus is a bitmap represented as a sum; therefore, it can represent multiple loopbacks simultaneously. The various bit positions are as follows: 1 dsx1NoLoopback 2 dsx1NearEndPayloadLoopback 4 dsx1NearEndLineLoopback 8 dsx1NearEndOtherLoopback 16 dsx1NearEndInwardLoopback 32 dsx1FarEndPayloadLoopback 64 dsx1FarEndLineLoopback')
dsx1Ds1ChannelNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1Ds1ChannelNumber.setStatus('current')
if mibBuilder.loadTexts: dsx1Ds1ChannelNumber.setDescription('This variable represents the channel number of the DS1/E1 on its parent DS2/E2 or DS3/E3. A value of 0 indicates that this DS1/E1 does not have a parent DS3/E3.')
dsx1Channelization = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledDs0", 2), ("enabledDs1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1Channelization.setStatus('current')
if mibBuilder.loadTexts: dsx1Channelization.setDescription('Indicates whether this DS1/E1 or DS2 is channelized or unchannelized. The value of enabledDs0(2) indicates that this is a DS1 channelized into DS0s. Setting this value will cause the creation, and resetting it to disabled(1) will cause the deletion of entries in the ifTable for the DS0s that are within the DS1. The value of enabledDs1(3) indicates that this is a DS2 channelized into DS1s. Setting this value will cause the creation, and resetting it to disabled(1) will cause the deletion of entries in the ifTable for the DS1s that are within the DS2.')
dsx1LineMode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("csu", 1), ("dsu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineMode.setStatus('current')
if mibBuilder.loadTexts: dsx1LineMode.setDescription('This setting puts the T1 framer into either long-haul (CSU) mode or short-haul (DSU) mode.')
dsx1LineBuildOut = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("neg75dB", 2), ("neg15dB", 3), ("neg225dB", 4), ("zerodB", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineBuildOut.setStatus('current')
if mibBuilder.loadTexts: dsx1LineBuildOut.setDescription('Attenuation setting for T1 framer in long haul (CSU) mode. The optional values are -7.5dB, -15dB, -22.5dB, and 0dB.')
dsx1LineImpedance = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("unbalanced75ohms", 2), ("balanced100ohms", 3), ("balanced120ohms", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineImpedance.setStatus('current')
if mibBuilder.loadTexts: dsx1LineImpedance.setDescription('Nominal line impedance. For T1 and J1 lines, the value is typically balanced100ohms(3). For E1 lines, the value is typically unbalanced75ohms(2) and balanced120ohms(4). When this object does not apply, or when the appropriate value is not known, the value should be set to notApplicable(1).')
dsx1CurrentTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 7), )
if mibBuilder.loadTexts: dsx1CurrentTable.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentTable.setDescription('The DS1 Current table contains various statistics being collected for the current 15-minute interval.')
dsx1CurrentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 7, 1), ).setIndexNames((0, "DS1-MIB", "dsx1CurrentIndex"))
if mibBuilder.loadTexts: dsx1CurrentEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentEntry.setDescription('An entry in the DS1 Current table.')
dsx1CurrentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value as a dsx1LineIndex object instance.')
dsx1CurrentESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentESs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentESs.setDescription('The number of Errored Seconds.')
dsx1CurrentSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentSESs.setDescription('The number of Severely Errored Seconds.')
dsx1CurrentSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentSEFSs.setDescription('The number of Severely Errored Framing Seconds.')
dsx1CurrentUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentUASs.setDescription('The number of Unavailable Seconds.')
dsx1CurrentCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentCSSs.setDescription('The number of Controlled Slip Seconds.')
dsx1CurrentPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentPCVs.setDescription('The number of Path Coding Violations.')
dsx1CurrentLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLESs.setDescription('The number of Line Errored Seconds.')
dsx1CurrentBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentBESs.setDescription('The number of Bursty Errored Seconds.')
dsx1CurrentDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 10), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1CurrentDMs.setDescription('The number of Degraded Minutes.')
dsx1CurrentLCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 7, 1, 11), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLCVs.setDescription('The number of Line Coding Violations (LCVs).')
dsx1IntervalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 8), )
if mibBuilder.loadTexts: dsx1IntervalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalTable.setDescription('The DS1 Interval table contains various statistics collected by each DS1 interface over the previous 24 hours of operation. The past 24 hours are broken into 96 completed 15-minute intervals. Each row in this table represents one such interval (identified by dsx1IntervalNumber) for one specific instance (identified by dsx1IntervalIndex).')
dsx1IntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 8, 1), ).setIndexNames((0, "DS1-MIB", "dsx1IntervalIndex"), (0, "DS1-MIB", "dsx1IntervalNumber"))
if mibBuilder.loadTexts: dsx1IntervalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalEntry.setDescription('An entry in the DS1 Interval table.')
dsx1IntervalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value as a dsx1LineIndex object instance.')
dsx1IntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalNumber.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15-minute interval and 96 is the 15-minute interval completed 23 hours and 45 minutes prior to interval 1.')
dsx1IntervalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 3), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalESs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalESs.setDescription('The number of Errored Seconds.')
dsx1IntervalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalSESs.setDescription('The number of Severely Errored Seconds.')
dsx1IntervalSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalSEFSs.setDescription('The number of Severely Errored Framing Seconds.')
dsx1IntervalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalUASs.setDescription('The number of Unavailable Seconds. This object may decrease if the occurrence of unavailable seconds occurs across an interval boundary.')
dsx1IntervalCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalCSSs.setDescription('The number of Controlled Slip Seconds.')
dsx1IntervalPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalPCVs.setDescription('The number of Path Coding Violations.')
dsx1IntervalLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLESs.setDescription('The number of Line Errored Seconds.')
dsx1IntervalBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalBESs.setDescription('The number of Bursty Errored Seconds.')
dsx1IntervalDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1IntervalDMs.setDescription('The number of Degraded Minutes.')
dsx1IntervalLCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 12), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLCVs.setDescription('The number of Line Coding Violations.')
dsx1IntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 8, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalValidData.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalValidData.setDescription('This variable indicates whether the data for this interval is valid.')
dsx1TotalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 9), )
if mibBuilder.loadTexts: dsx1TotalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalTable.setDescription('The DS1 Total table contains the cumulative sum of the various statistics for the 24-hour period preceding the current interval.')
dsx1TotalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 9, 1), ).setIndexNames((0, "DS1-MIB", "dsx1TotalIndex"))
if mibBuilder.loadTexts: dsx1TotalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalEntry.setDescription('An entry in the DS1 Total table.')
dsx1TotalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value as a dsx1LineIndex object instance.')
dsx1TotalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 2), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalESs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalESs.setDescription('The number of Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 3), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalSESs.setDescription('The number of Severely Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 4), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalSEFSs.setDescription('The number of Severely Errored Framing Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 5), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalUASs.setDescription('The number of Unavailable Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 6), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalCSSs.setDescription('The number of Controlled Slip Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 7), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalPCVs.setDescription('The number of Path Coding Violations encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 8), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalLESs.setDescription('The number of Line Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 9), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 10), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1TotalDMs.setDescription('The number of Degraded Minutes (DMs) encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1TotalLCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 9, 1, 11), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalLCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalLCVs.setDescription('The number of Line Coding Violations (LCVs) encountered by a DS1 interface in the current 15-minute interval. Invalid 15-minute intervals count as 0.')
dsx1ChanMappingTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 16), )
if mibBuilder.loadTexts: dsx1ChanMappingTable.setStatus('current')
if mibBuilder.loadTexts: dsx1ChanMappingTable.setDescription('The DS1 Channel Mapping table. This table maps a DS1 channel number on a particular DS3 into an ifIndex. In the presence of DS2s, this table can be used to map a DS2 channel number on a DS3 into an ifIndex, or used to map a DS1 channel number on a DS2 into an ifIndex.')
dsx1ChanMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DS1-MIB", "dsx1Ds1ChannelNumber"))
if mibBuilder.loadTexts: dsx1ChanMappingEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1ChanMappingEntry.setDescription('An entry in the DS1 Channel Mapping table. There is an entry in this table corresponding to each DS1 ifEntry within any interface that is channelized to the individual DS1 ifEntry level. This table is intended to facilitate mapping from channelized interface / channel number to DS1 ifEntry (e.g., mapping (DS3 ifIndex, DS1 channel number) -> ifIndex). While this table provides information that can also be found in the ifStackTable and dsx1ConfigTable, it provides this same information with a single table lookup, rather than by walking the ifStackTable to find the various constituent DS1 ifTable entries, and testing various dsx1ConfigTable entries to check for the entry with the applicable DS1 channel number.')
dsx1ChanMappedIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 16, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1ChanMappedIfIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1ChanMappedIfIndex.setDescription('This object indicates the ifIndex value assigned by the agent for the individual DS1 ifEntry that corresponds to the given DS1 channel number (specified by the INDEX element dsx1Ds1ChannelNumber) of the given channelized interface (specified by INDEX element ifIndex).')
dsx1FarEndCurrentTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 10), )
if mibBuilder.loadTexts: dsx1FarEndCurrentTable.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentTable.setDescription('The DS1 Far End Current table contains various statistics being collected for the current 15-minute interval. The statistics are collected from the far-end messages on the Facilities Data Link. The definitions are the same as described for the near-end information.')
dsx1FarEndCurrentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 10, 1), ).setIndexNames((0, "DS1-MIB", "dsx1FarEndCurrentIndex"))
if mibBuilder.loadTexts: dsx1FarEndCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentEntry.setDescription('An entry in the DS1 Far End Current table.')
dsx1FarEndCurrentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is identical to the interface identified by the same value of dsx1LineIndex.')
dsx1FarEndTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTimeElapsed.setDescription("The number of seconds that have elapsed since the beginning of the far-end current error-measurement period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
dsx1FarEndValidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndValidIntervals.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndValidIntervals.setDescription('The number of previous far-end intervals for which data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15-minute far-end intervals since the interface has been online. In the case where the agent is a proxy, it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available.')
dsx1FarEndCurrentESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentESs.setDescription('The number of Far End Errored Seconds.')
dsx1FarEndCurrentSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentSESs.setDescription('The number of Far End Severely Errored Seconds.')
dsx1FarEndCurrentSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentSEFSs.setDescription('The number of Far End Severely Errored Framing Seconds.')
dsx1FarEndCurrentUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentUASs.setDescription('The number of Unavailable Seconds.')
dsx1FarEndCurrentCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentCSSs.setDescription('The number of Far End Controlled Slip Seconds.')
dsx1FarEndCurrentLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentLESs.setDescription('The number of Far End Line Errored Seconds.')
dsx1FarEndCurrentPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 10), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentPCVs.setDescription('The number of Far End Path Coding Violations.')
dsx1FarEndCurrentBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 11), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndCurrentBESs.setDescription('The number of Far End Bursty Errored Seconds.')
dsx1FarEndCurrentDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 12), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndCurrentDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FarEndCurrentDMs.setDescription('The number of Far End Degraded Minutes.')
dsx1FarEndInvalidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndInvalidIntervals.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndInvalidIntervals.setDescription('The number of intervals in the range from 0 to dsx1FarEndValidIntervals for which no data is available. This object will typically be zero except in cases where the data for some intervals is not available (e.g., in proxy situations).')
dsx1FarEndIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 11), )
if mibBuilder.loadTexts: dsx1FarEndIntervalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalTable.setDescription('The DS1 Far End Interval table contains various statistics collected by each DS1 interface over the previous 24 hours of operation. The past 24 hours are broken into 96 completed 15-minute intervals. Each row in this table represents one such interval (identified by dsx1FarEndIntervalNumber) for one specific instance (identified by dsx1FarEndIntervalIndex).')
dsx1FarEndIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 11, 1), ).setIndexNames((0, "DS1-MIB", "dsx1FarEndIntervalIndex"), (0, "DS1-MIB", "dsx1FarEndIntervalNumber"))
if mibBuilder.loadTexts: dsx1FarEndIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalEntry.setDescription('An entry in the DS1 Far End Interval table.')
dsx1FarEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is identical to the interface identified by the same value of dsx1LineIndex.')
dsx1FarEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15-minute interval and 96 is the 15 minutes interval completed 23 hours and 45 minutes prior to interval 1.')
dsx1FarEndIntervalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 3), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalESs.setDescription('The number of Far End Errored Seconds.')
dsx1FarEndIntervalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalSESs.setDescription('The number of Far End Severely Errored Seconds.')
dsx1FarEndIntervalSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalSEFSs.setDescription('The number of Far End Severely Errored Framing Seconds.')
dsx1FarEndIntervalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalUASs.setDescription('The number of Unavailable Seconds.')
dsx1FarEndIntervalCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalCSSs.setDescription('The number of Far End Controlled Slip Seconds.')
dsx1FarEndIntervalLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalLESs.setDescription('The number of Far End Line Errored Seconds.')
dsx1FarEndIntervalPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalPCVs.setDescription('The number of Far End Path Coding Violations.')
dsx1FarEndIntervalBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalBESs.setDescription('The number of Far End Bursty Errored Seconds.')
dsx1FarEndIntervalDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FarEndIntervalDMs.setDescription('The number of Far End Degraded Minutes.')
dsx1FarEndIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 11, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndIntervalValidData.setDescription(' This variable indicates if the data for this interval is valid.')
dsx1FarEndTotalTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 12), )
if mibBuilder.loadTexts: dsx1FarEndTotalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalTable.setDescription('The DS1 Far End Total table contains the cumulative sum of the various statistics for the 24-hour period preceding the current interval.')
dsx1FarEndTotalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 12, 1), ).setIndexNames((0, "DS1-MIB", "dsx1FarEndTotalIndex"))
if mibBuilder.loadTexts: dsx1FarEndTotalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalEntry.setDescription('An entry in the DS1 Far End Total table.')
dsx1FarEndTotalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is identical to the interface identified by the same value of dsx1LineIndex.')
dsx1FarEndTotalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 2), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalESs.setDescription('The number of Far End Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 3), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalSESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalSESs.setDescription('The number of Far End Severely Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 4), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalSEFSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalSEFSs.setDescription('The number of Far End Severely Errored Framing Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 5), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalUASs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalUASs.setDescription('The number of Unavailable Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalCSSs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 6), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalCSSs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalCSSs.setDescription('The number of Far End Controlled Slip Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15 minute intervals count as 0.')
dsx1FarEndTotalLESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 7), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalLESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalLESs.setDescription('The number of Far End Line Errored Seconds encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalPCVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 8), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalPCVs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalPCVs.setDescription('The number of Far End Path Coding Violations reported via the far end block error count encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalBESs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 9), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalBESs.setStatus('current')
if mibBuilder.loadTexts: dsx1FarEndTotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FarEndTotalDMs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 12, 1, 10), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FarEndTotalDMs.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FarEndTotalDMs.setDescription('The number of Degraded Minutes (DMs) encountered by a DS1 interface in the previous 24-hour interval. Invalid 15-minute intervals count as 0.')
dsx1FracTable = MibTable((1, 3, 6, 1, 2, 1, 10, 18, 13), )
if mibBuilder.loadTexts: dsx1FracTable.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FracTable.setDescription('This table is deprecated in favor of using ifStackTable. The table was mandatory for systems dividing a DS1 into channels containing different data streams that are of local interest. Systems that are indifferent to data content, such as CSUs, need not implement it. The DS1 Fractional table identifies which DS1 channels associated with a CSU are being used to support a logical interface, i.e., an entry in the interfaces table from the Internet-standard MIB. For example, consider an application managing a North American ISDN Primary Rate link whose division is a 384-kbit/s H1 _B_ Channel for video, a second H1 for data to a primary routing peer, and 12 64-kbit/s H0 _B_ Channels. Consider that some subset of the H0 channels is used for voice and the remainder are available for dynamic data calls. We count a total of 14 interfaces multiplexed onto the DS1 interface. Six DS1 channels (for the sake of the example, channels 1..6) are used for video, six more (7..11 and 13) are used for data, and the remaining 12 are in channels 12 and 14..24. Let us further imagine that ifIndex 2 is of type DS1 and refers to the DS1 interface and that the interfaces layered onto it are numbered 3..16. We might describe the allocation of channels, in the dsx1FracTable, as follows: dsx1FracIfIndex.2. 1 = 3 dsx1FracIfIndex.2.13 = 4 dsx1FracIfIndex.2. 2 = 3 dsx1FracIfIndex.2.14 = 6 dsx1FracIfIndex.2. 3 = 3 dsx1FracIfIndex.2.15 = 7 dsx1FracIfIndex.2. 4 = 3 dsx1FracIfIndex.2.16 = 8 dsx1FracIfIndex.2. 5 = 3 dsx1FracIfIndex.2.17 = 9 dsx1FracIfIndex.2. 6 = 3 dsx1FracIfIndex.2.18 = 10 dsx1FracIfIndex.2. 7 = 4 dsx1FracIfIndex.2.19 = 11 dsx1FracIfIndex.2. 8 = 4 dsx1FracIfIndex.2.20 = 12 dsx1FracIfIndex.2. 9 = 4 dsx1FracIfIndex.2.21 = 13 dsx1FracIfIndex.2.10 = 4 dsx1FracIfIndex.2.22 = 14 dsx1FracIfIndex.2.11 = 4 dsx1FracIfIndex.2.23 = 15 dsx1FracIfIndex.2.12 = 5 dsx1FracIfIndex.2.24 = 16 For North American (DS1) interfaces, there are 24 legal channels, numbered 1 through 24. For G.704 interfaces, there are 31 legal channels, numbered 1 through 31. The channels (1..31) correspond directly to the equivalently numbered time-slots.')
dsx1FracEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 18, 13, 1), ).setIndexNames((0, "DS1-MIB", "dsx1FracIndex"), (0, "DS1-MIB", "dsx1FracNumber"))
if mibBuilder.loadTexts: dsx1FracEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FracEntry.setDescription('An entry in the DS1 Fractional table.')
dsx1FracIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FracIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FracIndex.setDescription('The index value that uniquely identifies the DS1 interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value as a dsx1LineIndex object instance.')
dsx1FracNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1FracNumber.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FracNumber.setDescription('The channel number for this entry.')
dsx1FracIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 18, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1FracIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dsx1FracIfIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value as an ifIndex object instance. If no interface is currently using a channel, the value should be zero. If a single interface occupies more than one time-slot, that ifIndex value will be found in multiple time-slots.')
ds1Traps = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 18, 15))
dsx1LineStatusChange = NotificationType((1, 3, 6, 1, 2, 1, 10, 18, 15, 0, 1)).setObjects(("DS1-MIB", "dsx1LineStatus"), ("DS1-MIB", "dsx1LineStatusLastChange"))
if mibBuilder.loadTexts: dsx1LineStatusChange.setStatus('current')
if mibBuilder.loadTexts: dsx1LineStatusChange.setDescription('A dsx1LineStatusChange trap is sent when the value of an instance dsx1LineStatus changes. It can be utilized by an Network Management Station (NMS) to trigger polls. When the line status change results from a higher-level line status change (i.e., DS3), then no traps for the DS1 are sent.')
ds1Conformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 18, 14))
ds1Groups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 18, 14, 1))
ds1Compliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 18, 14, 2))
ds1Compliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 1)).setObjects(("DS1-MIB", "ds1NearEndConfigGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"), ("DS1-MIB", "ds1FarEndGroup"), ("DS1-MIB", "ds1NearEndOptionalConfigGroup"), ("DS1-MIB", "ds1DS2Group"), ("DS1-MIB", "ds1TransStatsGroup"), ("DS1-MIB", "ds1ChanMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1Compliance = ds1Compliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1Compliance.setDescription('The compliance statement for T1 and E1 interfaces.')
ds1MibT1PriCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 2)).setObjects(("DS1-MIB", "ds1NearEndConfigGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1MibT1PriCompliance = ds1MibT1PriCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1MibT1PriCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on T1 lines.')
ds1MibE1PriCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 3)).setObjects(("DS1-MIB", "ds1NearEndConfigGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1MibE1PriCompliance = ds1MibE1PriCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1MibE1PriCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on E1 lines.')
ds1Ds2Compliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 4)).setObjects(("DS1-MIB", "ds1DS2Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1Ds2Compliance = ds1Ds2Compliance.setStatus('current')
if mibBuilder.loadTexts: ds1Ds2Compliance.setDescription('Compliance statement for using this MIB for DS2 interfaces.')
ds1NCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 5)).setObjects(("DS1-MIB", "ds1NearEndConfigurationGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"), ("DS1-MIB", "ds1FarEndGroup"), ("DS1-MIB", "ds1NearEndOptionalTrapGroup"), ("DS1-MIB", "ds1NearEndOptionalConfigGroup"), ("DS1-MIB", "ds1DS2Group"), ("DS1-MIB", "ds1TransStatsGroup"), ("DS1-MIB", "ds1ChanMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NCompliance = ds1NCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1NCompliance.setDescription('The compliance statement for T1 and E1 interfaces.')
ds1MibT1PriNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 6)).setObjects(("DS1-MIB", "ds1NearEndConfigurationGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1MibT1PriNCompliance = ds1MibT1PriNCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1MibT1PriNCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on T1 lines.')
ds1MibE1PriNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 7)).setObjects(("DS1-MIB", "ds1NearEndConfigurationGroup"), ("DS1-MIB", "ds1NearEndStatisticsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1MibE1PriNCompliance = ds1MibE1PriNCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ds1MibE1PriNCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on E1 lines.')
ds1J1Compliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 8)).setObjects(("DS1-MIB", "ds1NearEndCfgGroup"), ("DS1-MIB", "ds1NearEndStatGroup"), ("DS1-MIB", "ds1FarEndNGroup"), ("DS1-MIB", "ds1NearEndOptionalTrapGroup"), ("DS1-MIB", "ds1NearEndOptionalConfigGroup"), ("DS1-MIB", "ds1DS2Group"), ("DS1-MIB", "ds1TransStatsGroup"), ("DS1-MIB", "ds1ChanMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1J1Compliance = ds1J1Compliance.setStatus('current')
if mibBuilder.loadTexts: ds1J1Compliance.setDescription('The compliance statement for T1, J1, and E1 interfaces.')
ds1NMibT1PriNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 9)).setObjects(("DS1-MIB", "ds1NearEndCfgGroup"), ("DS1-MIB", "ds1NearEndStatGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NMibT1PriNCompliance = ds1NMibT1PriNCompliance.setStatus('current')
if mibBuilder.loadTexts: ds1NMibT1PriNCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on T1 lines.')
ds1NMibE1PriNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 18, 14, 2, 10)).setObjects(("DS1-MIB", "ds1NearEndCfgGroup"), ("DS1-MIB", "ds1NearEndStatGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NMibE1PriNCompliance = ds1NMibE1PriNCompliance.setStatus('current')
if mibBuilder.loadTexts: ds1NMibE1PriNCompliance.setDescription('Compliance statement for using this MIB for ISDN Primary Rate interfaces on E1 lines.')
ds1NearEndConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 1)).setObjects(("DS1-MIB", "dsx1LineIndex"), ("DS1-MIB", "dsx1TimeElapsed"), ("DS1-MIB", "dsx1ValidIntervals"), ("DS1-MIB", "dsx1LineType"), ("DS1-MIB", "dsx1LineCoding"), ("DS1-MIB", "dsx1SendCode"), ("DS1-MIB", "dsx1CircuitIdentifier"), ("DS1-MIB", "dsx1LoopbackConfig"), ("DS1-MIB", "dsx1LineStatus"), ("DS1-MIB", "dsx1SignalMode"), ("DS1-MIB", "dsx1TransmitClockSource"), ("DS1-MIB", "dsx1Fdl"), ("DS1-MIB", "dsx1InvalidIntervals"), ("DS1-MIB", "dsx1LineLength"), ("DS1-MIB", "dsx1LoopbackStatus"), ("DS1-MIB", "dsx1Ds1ChannelNumber"), ("DS1-MIB", "dsx1Channelization"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndConfigGroup = ds1NearEndConfigGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ds1NearEndConfigGroup.setDescription('A collection of objects providing configuration information applicable to all DS1 interfaces.')
ds1NearEndStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 2)).setObjects(("DS1-MIB", "dsx1CurrentIndex"), ("DS1-MIB", "dsx1CurrentESs"), ("DS1-MIB", "dsx1CurrentSESs"), ("DS1-MIB", "dsx1CurrentSEFSs"), ("DS1-MIB", "dsx1CurrentUASs"), ("DS1-MIB", "dsx1CurrentCSSs"), ("DS1-MIB", "dsx1CurrentPCVs"), ("DS1-MIB", "dsx1CurrentLESs"), ("DS1-MIB", "dsx1CurrentBESs"), ("DS1-MIB", "dsx1CurrentDMs"), ("DS1-MIB", "dsx1CurrentLCVs"), ("DS1-MIB", "dsx1IntervalIndex"), ("DS1-MIB", "dsx1IntervalNumber"), ("DS1-MIB", "dsx1IntervalESs"), ("DS1-MIB", "dsx1IntervalSESs"), ("DS1-MIB", "dsx1IntervalSEFSs"), ("DS1-MIB", "dsx1IntervalUASs"), ("DS1-MIB", "dsx1IntervalCSSs"), ("DS1-MIB", "dsx1IntervalPCVs"), ("DS1-MIB", "dsx1IntervalLESs"), ("DS1-MIB", "dsx1IntervalBESs"), ("DS1-MIB", "dsx1IntervalDMs"), ("DS1-MIB", "dsx1IntervalLCVs"), ("DS1-MIB", "dsx1IntervalValidData"), ("DS1-MIB", "dsx1TotalIndex"), ("DS1-MIB", "dsx1TotalESs"), ("DS1-MIB", "dsx1TotalSESs"), ("DS1-MIB", "dsx1TotalSEFSs"), ("DS1-MIB", "dsx1TotalUASs"), ("DS1-MIB", "dsx1TotalCSSs"), ("DS1-MIB", "dsx1TotalPCVs"), ("DS1-MIB", "dsx1TotalLESs"), ("DS1-MIB", "dsx1TotalBESs"), ("DS1-MIB", "dsx1TotalDMs"), ("DS1-MIB", "dsx1TotalLCVs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndStatisticsGroup = ds1NearEndStatisticsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ds1NearEndStatisticsGroup.setDescription('A collection of objects providing statistics information applicable to all DS1 interfaces.')
ds1FarEndGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 3)).setObjects(("DS1-MIB", "dsx1FarEndCurrentIndex"), ("DS1-MIB", "dsx1FarEndTimeElapsed"), ("DS1-MIB", "dsx1FarEndValidIntervals"), ("DS1-MIB", "dsx1FarEndCurrentESs"), ("DS1-MIB", "dsx1FarEndCurrentSESs"), ("DS1-MIB", "dsx1FarEndCurrentSEFSs"), ("DS1-MIB", "dsx1FarEndCurrentUASs"), ("DS1-MIB", "dsx1FarEndCurrentCSSs"), ("DS1-MIB", "dsx1FarEndCurrentLESs"), ("DS1-MIB", "dsx1FarEndCurrentPCVs"), ("DS1-MIB", "dsx1FarEndCurrentBESs"), ("DS1-MIB", "dsx1FarEndCurrentDMs"), ("DS1-MIB", "dsx1FarEndInvalidIntervals"), ("DS1-MIB", "dsx1FarEndIntervalIndex"), ("DS1-MIB", "dsx1FarEndIntervalNumber"), ("DS1-MIB", "dsx1FarEndIntervalESs"), ("DS1-MIB", "dsx1FarEndIntervalSESs"), ("DS1-MIB", "dsx1FarEndIntervalSEFSs"), ("DS1-MIB", "dsx1FarEndIntervalUASs"), ("DS1-MIB", "dsx1FarEndIntervalCSSs"), ("DS1-MIB", "dsx1FarEndIntervalLESs"), ("DS1-MIB", "dsx1FarEndIntervalPCVs"), ("DS1-MIB", "dsx1FarEndIntervalBESs"), ("DS1-MIB", "dsx1FarEndIntervalDMs"), ("DS1-MIB", "dsx1FarEndIntervalValidData"), ("DS1-MIB", "dsx1FarEndTotalIndex"), ("DS1-MIB", "dsx1FarEndTotalESs"), ("DS1-MIB", "dsx1FarEndTotalSESs"), ("DS1-MIB", "dsx1FarEndTotalSEFSs"), ("DS1-MIB", "dsx1FarEndTotalUASs"), ("DS1-MIB", "dsx1FarEndTotalCSSs"), ("DS1-MIB", "dsx1FarEndTotalLESs"), ("DS1-MIB", "dsx1FarEndTotalPCVs"), ("DS1-MIB", "dsx1FarEndTotalBESs"), ("DS1-MIB", "dsx1FarEndTotalDMs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1FarEndGroup = ds1FarEndGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ds1FarEndGroup.setDescription('A collection of objects providing remote configuration and statistics information.')
ds1DeprecatedGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 4)).setObjects(("DS1-MIB", "dsx1IfIndex"), ("DS1-MIB", "dsx1FracIndex"), ("DS1-MIB", "dsx1FracNumber"), ("DS1-MIB", "dsx1FracIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1DeprecatedGroup = ds1DeprecatedGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ds1DeprecatedGroup.setDescription('A collection of obsolete objects that may be implemented for backwards compatibility.')
ds1NearEndOptionalConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 5)).setObjects(("DS1-MIB", "dsx1LineStatusLastChange"), ("DS1-MIB", "dsx1LineStatusChangeTrapEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndOptionalConfigGroup = ds1NearEndOptionalConfigGroup.setStatus('current')
if mibBuilder.loadTexts: ds1NearEndOptionalConfigGroup.setDescription('A collection of objects that may be implemented on DS1 and DS2 interfaces.')
ds1DS2Group = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 6)).setObjects(("DS1-MIB", "dsx1LineIndex"), ("DS1-MIB", "dsx1LineType"), ("DS1-MIB", "dsx1LineCoding"), ("DS1-MIB", "dsx1SendCode"), ("DS1-MIB", "dsx1LineStatus"), ("DS1-MIB", "dsx1SignalMode"), ("DS1-MIB", "dsx1TransmitClockSource"), ("DS1-MIB", "dsx1Channelization"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1DS2Group = ds1DS2Group.setStatus('current')
if mibBuilder.loadTexts: ds1DS2Group.setDescription('A collection of objects providing information about DS2 (6,312 kbps) and E2 (8,448 kbps) systems.')
ds1TransStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 7)).setObjects(("DS1-MIB", "dsx1CurrentESs"), ("DS1-MIB", "dsx1CurrentSESs"), ("DS1-MIB", "dsx1CurrentUASs"), ("DS1-MIB", "dsx1IntervalESs"), ("DS1-MIB", "dsx1IntervalSESs"), ("DS1-MIB", "dsx1IntervalUASs"), ("DS1-MIB", "dsx1TotalESs"), ("DS1-MIB", "dsx1TotalSESs"), ("DS1-MIB", "dsx1TotalUASs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1TransStatsGroup = ds1TransStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ds1TransStatsGroup.setDescription('A collection of objects that are the statistics that can be collected from a DS1 interface that is running transparent or unframed lineType. Statistics not in this list should return noSuchInstance.')
ds1NearEndOptionalTrapGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 8)).setObjects(("DS1-MIB", "dsx1LineStatusChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndOptionalTrapGroup = ds1NearEndOptionalTrapGroup.setStatus('current')
if mibBuilder.loadTexts: ds1NearEndOptionalTrapGroup.setDescription('A collection of notifications that may be implemented on DS1 and DS2 interfaces.')
ds1ChanMappingGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 9)).setObjects(("DS1-MIB", "dsx1ChanMappedIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1ChanMappingGroup = ds1ChanMappingGroup.setStatus('current')
if mibBuilder.loadTexts: ds1ChanMappingGroup.setDescription('A collection of objects that give a mapping of DS3 Channel (dsx1Ds1ChannelNumber) to ifIndex.')
ds1NearEndConfigurationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 10)).setObjects(("DS1-MIB", "dsx1LineIndex"), ("DS1-MIB", "dsx1TimeElapsed"), ("DS1-MIB", "dsx1ValidIntervals"), ("DS1-MIB", "dsx1LineType"), ("DS1-MIB", "dsx1LineCoding"), ("DS1-MIB", "dsx1SendCode"), ("DS1-MIB", "dsx1CircuitIdentifier"), ("DS1-MIB", "dsx1LoopbackConfig"), ("DS1-MIB", "dsx1LineStatus"), ("DS1-MIB", "dsx1SignalMode"), ("DS1-MIB", "dsx1TransmitClockSource"), ("DS1-MIB", "dsx1Fdl"), ("DS1-MIB", "dsx1InvalidIntervals"), ("DS1-MIB", "dsx1LineLength"), ("DS1-MIB", "dsx1LoopbackStatus"), ("DS1-MIB", "dsx1Ds1ChannelNumber"), ("DS1-MIB", "dsx1Channelization"), ("DS1-MIB", "dsx1LineMode"), ("DS1-MIB", "dsx1LineBuildOut"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndConfigurationGroup = ds1NearEndConfigurationGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ds1NearEndConfigurationGroup.setDescription('A collection of objects providing configuration information applicable to all DS1 interfaces.')
ds1NearEndCfgGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 11)).setObjects(("DS1-MIB", "dsx1LineIndex"), ("DS1-MIB", "dsx1TimeElapsed"), ("DS1-MIB", "dsx1ValidIntervals"), ("DS1-MIB", "dsx1LineType"), ("DS1-MIB", "dsx1LineCoding"), ("DS1-MIB", "dsx1SendCode"), ("DS1-MIB", "dsx1CircuitIdentifier"), ("DS1-MIB", "dsx1LoopbackConfig"), ("DS1-MIB", "dsx1LineStatus"), ("DS1-MIB", "dsx1SignalMode"), ("DS1-MIB", "dsx1TransmitClockSource"), ("DS1-MIB", "dsx1Fdl"), ("DS1-MIB", "dsx1InvalidIntervals"), ("DS1-MIB", "dsx1LineLength"), ("DS1-MIB", "dsx1LoopbackStatus"), ("DS1-MIB", "dsx1Ds1ChannelNumber"), ("DS1-MIB", "dsx1Channelization"), ("DS1-MIB", "dsx1LineMode"), ("DS1-MIB", "dsx1LineBuildOut"), ("DS1-MIB", "dsx1LineImpedance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndCfgGroup = ds1NearEndCfgGroup.setStatus('current')
if mibBuilder.loadTexts: ds1NearEndCfgGroup.setDescription('A collection of objects providing configuration information applicable to all DS1 interfaces.')
ds1NearEndStatGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 12)).setObjects(("DS1-MIB", "dsx1CurrentIndex"), ("DS1-MIB", "dsx1CurrentESs"), ("DS1-MIB", "dsx1CurrentSESs"), ("DS1-MIB", "dsx1CurrentSEFSs"), ("DS1-MIB", "dsx1CurrentUASs"), ("DS1-MIB", "dsx1CurrentCSSs"), ("DS1-MIB", "dsx1CurrentPCVs"), ("DS1-MIB", "dsx1CurrentLESs"), ("DS1-MIB", "dsx1CurrentBESs"), ("DS1-MIB", "dsx1CurrentLCVs"), ("DS1-MIB", "dsx1IntervalIndex"), ("DS1-MIB", "dsx1IntervalNumber"), ("DS1-MIB", "dsx1IntervalESs"), ("DS1-MIB", "dsx1IntervalSESs"), ("DS1-MIB", "dsx1IntervalSEFSs"), ("DS1-MIB", "dsx1IntervalUASs"), ("DS1-MIB", "dsx1IntervalCSSs"), ("DS1-MIB", "dsx1IntervalPCVs"), ("DS1-MIB", "dsx1IntervalLESs"), ("DS1-MIB", "dsx1IntervalBESs"), ("DS1-MIB", "dsx1IntervalLCVs"), ("DS1-MIB", "dsx1IntervalValidData"), ("DS1-MIB", "dsx1TotalIndex"), ("DS1-MIB", "dsx1TotalESs"), ("DS1-MIB", "dsx1TotalSESs"), ("DS1-MIB", "dsx1TotalSEFSs"), ("DS1-MIB", "dsx1TotalUASs"), ("DS1-MIB", "dsx1TotalCSSs"), ("DS1-MIB", "dsx1TotalPCVs"), ("DS1-MIB", "dsx1TotalLESs"), ("DS1-MIB", "dsx1TotalBESs"), ("DS1-MIB", "dsx1TotalLCVs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1NearEndStatGroup = ds1NearEndStatGroup.setStatus('current')
if mibBuilder.loadTexts: ds1NearEndStatGroup.setDescription('A collection of objects providing statistics information applicable to all DS1 interfaces.')
ds1FarEndNGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 18, 14, 1, 13)).setObjects(("DS1-MIB", "dsx1FarEndCurrentIndex"), ("DS1-MIB", "dsx1FarEndTimeElapsed"), ("DS1-MIB", "dsx1FarEndValidIntervals"), ("DS1-MIB", "dsx1FarEndCurrentESs"), ("DS1-MIB", "dsx1FarEndCurrentSESs"), ("DS1-MIB", "dsx1FarEndCurrentSEFSs"), ("DS1-MIB", "dsx1FarEndCurrentUASs"), ("DS1-MIB", "dsx1FarEndCurrentCSSs"), ("DS1-MIB", "dsx1FarEndCurrentLESs"), ("DS1-MIB", "dsx1FarEndCurrentPCVs"), ("DS1-MIB", "dsx1FarEndCurrentBESs"), ("DS1-MIB", "dsx1FarEndInvalidIntervals"), ("DS1-MIB", "dsx1FarEndIntervalIndex"), ("DS1-MIB", "dsx1FarEndIntervalNumber"), ("DS1-MIB", "dsx1FarEndIntervalESs"), ("DS1-MIB", "dsx1FarEndIntervalSESs"), ("DS1-MIB", "dsx1FarEndIntervalSEFSs"), ("DS1-MIB", "dsx1FarEndIntervalUASs"), ("DS1-MIB", "dsx1FarEndIntervalCSSs"), ("DS1-MIB", "dsx1FarEndIntervalLESs"), ("DS1-MIB", "dsx1FarEndIntervalPCVs"), ("DS1-MIB", "dsx1FarEndIntervalBESs"), ("DS1-MIB", "dsx1FarEndIntervalValidData"), ("DS1-MIB", "dsx1FarEndTotalIndex"), ("DS1-MIB", "dsx1FarEndTotalESs"), ("DS1-MIB", "dsx1FarEndTotalSESs"), ("DS1-MIB", "dsx1FarEndTotalSEFSs"), ("DS1-MIB", "dsx1FarEndTotalUASs"), ("DS1-MIB", "dsx1FarEndTotalCSSs"), ("DS1-MIB", "dsx1FarEndTotalLESs"), ("DS1-MIB", "dsx1FarEndTotalPCVs"), ("DS1-MIB", "dsx1FarEndTotalBESs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ds1FarEndNGroup = ds1FarEndNGroup.setStatus('current')
if mibBuilder.loadTexts: ds1FarEndNGroup.setDescription('A collection of objects providing remote configuration and statistics information.')
mibBuilder.exportSymbols("DS1-MIB", dsx1TotalSEFSs=dsx1TotalSEFSs, dsx1TimeElapsed=dsx1TimeElapsed, ds1NearEndCfgGroup=ds1NearEndCfgGroup, dsx1LineStatusChange=dsx1LineStatusChange, dsx1FarEndCurrentCSSs=dsx1FarEndCurrentCSSs, ds1NearEndStatisticsGroup=ds1NearEndStatisticsGroup, dsx1FarEndCurrentBESs=dsx1FarEndCurrentBESs, dsx1TotalLCVs=dsx1TotalLCVs, dsx1FarEndCurrentUASs=dsx1FarEndCurrentUASs, dsx1FarEndTotalSEFSs=dsx1FarEndTotalSEFSs, dsx1FarEndCurrentDMs=dsx1FarEndCurrentDMs, dsx1FarEndIntervalLESs=dsx1FarEndIntervalLESs, dsx1CurrentESs=dsx1CurrentESs, dsx1FarEndTotalIndex=dsx1FarEndTotalIndex, dsx1IntervalIndex=dsx1IntervalIndex, dsx1FarEndIntervalESs=dsx1FarEndIntervalESs, dsx1LineType=dsx1LineType, dsx1TransmitClockSource=dsx1TransmitClockSource, dsx1ConfigTable=dsx1ConfigTable, dsx1FarEndTotalTable=dsx1FarEndTotalTable, dsx1TotalESs=dsx1TotalESs, dsx1CurrentUASs=dsx1CurrentUASs, dsx1IntervalNumber=dsx1IntervalNumber, dsx1FracIfIndex=dsx1FracIfIndex, dsx1TotalEntry=dsx1TotalEntry, ds1NearEndOptionalConfigGroup=ds1NearEndOptionalConfigGroup, dsx1FarEndTotalESs=dsx1FarEndTotalESs, ds1Compliance=ds1Compliance, dsx1FarEndIntervalDMs=dsx1FarEndIntervalDMs, dsx1FarEndIntervalNumber=dsx1FarEndIntervalNumber, dsx1CurrentPCVs=dsx1CurrentPCVs, dsx1Ds1ChannelNumber=dsx1Ds1ChannelNumber, dsx1CurrentSESs=dsx1CurrentSESs, dsx1FarEndCurrentLESs=dsx1FarEndCurrentLESs, dsx1LineCoding=dsx1LineCoding, dsx1FarEndInvalidIntervals=dsx1FarEndInvalidIntervals, dsx1CurrentEntry=dsx1CurrentEntry, dsx1LineMode=dsx1LineMode, ds1Traps=ds1Traps, dsx1IntervalCSSs=dsx1IntervalCSSs, dsx1FarEndIntervalSEFSs=dsx1FarEndIntervalSEFSs, dsx1IntervalEntry=dsx1IntervalEntry, dsx1CurrentLESs=dsx1CurrentLESs, ds1MibT1PriNCompliance=ds1MibT1PriNCompliance, dsx1FarEndCurrentEntry=dsx1FarEndCurrentEntry, dsx1FarEndIntervalPCVs=dsx1FarEndIntervalPCVs, dsx1ValidIntervals=dsx1ValidIntervals, dsx1ChanMappingTable=dsx1ChanMappingTable, dsx1FracTable=dsx1FracTable, dsx1LineImpedance=dsx1LineImpedance, ds1=ds1, dsx1FarEndCurrentPCVs=dsx1FarEndCurrentPCVs, ds1MibT1PriCompliance=ds1MibT1PriCompliance, dsx1ConfigEntry=dsx1ConfigEntry, ds1Compliances=ds1Compliances, dsx1TotalIndex=dsx1TotalIndex, dsx1IfIndex=dsx1IfIndex, dsx1LineLength=dsx1LineLength, dsx1CurrentCSSs=dsx1CurrentCSSs, ds1MibE1PriCompliance=ds1MibE1PriCompliance, dsx1LineStatusLastChange=dsx1LineStatusLastChange, dsx1FarEndCurrentIndex=dsx1FarEndCurrentIndex, dsx1FarEndIntervalIndex=dsx1FarEndIntervalIndex, dsx1FracEntry=dsx1FracEntry, dsx1FarEndIntervalEntry=dsx1FarEndIntervalEntry, ds1J1Compliance=ds1J1Compliance, dsx1LineStatusChangeTrapEnable=dsx1LineStatusChangeTrapEnable, dsx1Fdl=dsx1Fdl, dsx1FracIndex=dsx1FracIndex, ds1DeprecatedGroup=ds1DeprecatedGroup, dsx1FarEndIntervalSESs=dsx1FarEndIntervalSESs, dsx1FarEndCurrentSEFSs=dsx1FarEndCurrentSEFSs, dsx1FarEndCurrentESs=dsx1FarEndCurrentESs, dsx1FarEndTotalLESs=dsx1FarEndTotalLESs, ds1NearEndConfigGroup=ds1NearEndConfigGroup, dsx1TotalUASs=dsx1TotalUASs, dsx1IntervalSESs=dsx1IntervalSESs, dsx1FarEndTimeElapsed=dsx1FarEndTimeElapsed, ds1TransStatsGroup=ds1TransStatsGroup, dsx1CurrentBESs=dsx1CurrentBESs, dsx1IntervalDMs=dsx1IntervalDMs, dsx1FarEndTotalCSSs=dsx1FarEndTotalCSSs, ds1NMibE1PriNCompliance=ds1NMibE1PriNCompliance, dsx1ChanMappingEntry=dsx1ChanMappingEntry, dsx1TotalBESs=dsx1TotalBESs, dsx1InvalidIntervals=dsx1InvalidIntervals, dsx1FracNumber=dsx1FracNumber, dsx1IntervalLESs=dsx1IntervalLESs, dsx1LoopbackConfig=dsx1LoopbackConfig, dsx1IntervalValidData=dsx1IntervalValidData, dsx1FarEndTotalPCVs=dsx1FarEndTotalPCVs, dsx1SendCode=dsx1SendCode, dsx1FarEndIntervalCSSs=dsx1FarEndIntervalCSSs, dsx1FarEndTotalUASs=dsx1FarEndTotalUASs, ds1NearEndConfigurationGroup=ds1NearEndConfigurationGroup, dsx1FarEndTotalDMs=dsx1FarEndTotalDMs, dsx1FarEndIntervalTable=dsx1FarEndIntervalTable, PYSNMP_MODULE_ID=ds1, ds1NearEndStatGroup=ds1NearEndStatGroup, dsx1FarEndIntervalBESs=dsx1FarEndIntervalBESs, dsx1IntervalLCVs=dsx1IntervalLCVs, dsx1CurrentDMs=dsx1CurrentDMs, dsx1IntervalTable=dsx1IntervalTable, ds1Conformance=ds1Conformance, dsx1TotalLESs=dsx1TotalLESs, ds1MibE1PriNCompliance=ds1MibE1PriNCompliance, dsx1IntervalBESs=dsx1IntervalBESs, ds1Groups=ds1Groups, dsx1FarEndTotalSESs=dsx1FarEndTotalSESs, dsx1TotalSESs=dsx1TotalSESs, ds1NCompliance=ds1NCompliance, dsx1FarEndCurrentSESs=dsx1FarEndCurrentSESs, dsx1TotalTable=dsx1TotalTable, ds1FarEndNGroup=ds1FarEndNGroup, dsx1Channelization=dsx1Channelization, dsx1TotalPCVs=dsx1TotalPCVs, dsx1CurrentSEFSs=dsx1CurrentSEFSs, dsx1FarEndTotalBESs=dsx1FarEndTotalBESs, dsx1CurrentTable=dsx1CurrentTable, dsx1IntervalSEFSs=dsx1IntervalSEFSs, dsx1FarEndIntervalUASs=dsx1FarEndIntervalUASs, dsx1CurrentLCVs=dsx1CurrentLCVs, dsx1CurrentIndex=dsx1CurrentIndex, dsx1LoopbackStatus=dsx1LoopbackStatus, dsx1TotalDMs=dsx1TotalDMs, dsx1SignalMode=dsx1SignalMode, dsx1CircuitIdentifier=dsx1CircuitIdentifier, dsx1TotalCSSs=dsx1TotalCSSs, dsx1LineIndex=dsx1LineIndex, ds1NMibT1PriNCompliance=ds1NMibT1PriNCompliance, dsx1FarEndIntervalValidData=dsx1FarEndIntervalValidData, ds1DS2Group=ds1DS2Group, ds1Ds2Compliance=ds1Ds2Compliance, ds1ChanMappingGroup=ds1ChanMappingGroup, ds1NearEndOptionalTrapGroup=ds1NearEndOptionalTrapGroup, dsx1FarEndTotalEntry=dsx1FarEndTotalEntry, dsx1FarEndCurrentTable=dsx1FarEndCurrentTable, dsx1IntervalUASs=dsx1IntervalUASs, dsx1LineStatus=dsx1LineStatus, dsx1IntervalESs=dsx1IntervalESs, dsx1ChanMappedIfIndex=dsx1ChanMappedIfIndex, dsx1FarEndValidIntervals=dsx1FarEndValidIntervals, dsx1LineBuildOut=dsx1LineBuildOut, ds1FarEndGroup=ds1FarEndGroup, dsx1IntervalPCVs=dsx1IntervalPCVs)

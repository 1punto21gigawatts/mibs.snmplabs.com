#
# PySNMP MIB module APPIAN-LPORT-HDLC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPIAN-LPORT-HDLC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:23:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
AcNodeId, AcSlotNumber, acLport = mibBuilder.importSymbols("APPIAN-SMI-MIB", "AcNodeId", "AcSlotNumber", "acLport")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, ModuleIdentity, NotificationType, Gauge32, Counter32, MibIdentifier, iso, Unsigned32, IpAddress, Bits, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "ModuleIdentity", "NotificationType", "Gauge32", "Counter32", "MibIdentifier", "iso", "Unsigned32", "IpAddress", "Bits", "Counter64")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
acLogicalHdlc = ModuleIdentity((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4))
acLogicalHdlc.setRevisions(('1900-02-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: acLogicalHdlc.setRevisionsDescriptions(('Initial release',))
if mibBuilder.loadTexts: acLogicalHdlc.setLastUpdated('0003190000Z')
if mibBuilder.loadTexts: acLogicalHdlc.setOrganization('Appian Communications, Inc.')
if mibBuilder.loadTexts: acLogicalHdlc.setContactInfo('Brian Johnson')
if mibBuilder.loadTexts: acLogicalHdlc.setDescription('Appian Communications HDLC Configuration and Statistics MIB.')
acLogicalHdlcTable = MibTable((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1), )
if mibBuilder.loadTexts: acLogicalHdlcTable.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcTable.setDescription('A table containing the statistics parameters for HDLC data streams on the SONET board. The index key used is type.channel.')
acLogicalHdlcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1), ).setIndexNames((0, "APPIAN-LPORT-HDLC-MIB", "acLogicalHdlcNodeId"), (0, "APPIAN-LPORT-HDLC-MIB", "acLogicalHdlcSlot"), (0, "APPIAN-LPORT-HDLC-MIB", "acLogicalHdlcType"), (0, "APPIAN-LPORT-HDLC-MIB", "acLogicalHdlcIndex"))
if mibBuilder.loadTexts: acLogicalHdlcEntry.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcEntry.setDescription('A row in the HDLC table containing all HDLC level statistics and configuration for a specific HDLC data stream on the SONET board.')
acLogicalHdlcNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 1), AcNodeId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acLogicalHdlcNodeId.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcNodeId.setDescription('The node id is the id for this specific node in the OSAP ring.')
acLogicalHdlcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 2), AcSlotNumber()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acLogicalHdlcSlot.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcSlot.setDescription('The slot number within the chassis where the stats reside.')
acLogicalHdlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds1", 1), ("ds3", 2), ("dcc", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acLogicalHdlcType.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcType.setDescription('The type of data stream that this hdlc channel is framing. The current options are DS1, DS3, or DCC.')
acLogicalHdlcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 4), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acLogicalHdlcIndex.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcIndex.setDescription('The acLogicalHdlcIndex is the index for this table for the specified type. For DS1 and DS3, the index is the same as the index in the timeslot table that this entity corresponds. For the case of Appian DCC, the index simply a number from 1-4.')
acLogicalHdlcStatsReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acLogicalHdlcStatsReset.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcStatsReset.setDescription('Setting this attribute to True(1) will force all statistics for this row to be cleared and set to zero (0) values. Used for debugging, clearing statistics can trouble with trending and long term statistics collection by AppianVista or 3rd party trending tools.')
acLogicalHdlcRxFifoOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxFifoOverrun.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxFifoOverrun.setDescription('The total number of receive FIFO overruns that occurred in the hdlc controller for this specified channel number. This error occurs when attemps are made to write data to a channel which is already full.')
acLogicalHdlcRxMaxPktLenViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxMaxPktLenViolation.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxMaxPktLenViolation.setDescription('The total number of receive max packet packet length violations that occurred in the hdcl controller for the specified channel number. This error occurs when an hdlc packet is received that is greater than the maximum packet length which is programmed to be 2048 bytes. ')
acLogicalHdlcRxFCSError = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxFCSError.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxFCSError.setDescription('The total number of receive FCS errors that occurred in the hdlc controller for this specified channel number. The FCS error is generated when the FCS from HDLC packet receieved differs from the FCS that is computed by the HDLC controller.')
acLogicalHdlcRxNonOctetAligned = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxNonOctetAligned.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxNonOctetAligned.setDescription('The total number of receive non-octet aligned errors that occurred in the hdlc controller for this specified channel number. This error occurs when the receieved data stream is not octet aligned.')
acLogicalHdlcRxHdlcPktAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxHdlcPktAbort.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxHdlcPktAbort.setDescription("The total number of receive hdlc abort errors that occurred in the hdlc controller for this specified channel number. This error occurs when and abort code (at least 7 contiguous 1's) is received.")
acLogicalHdlcRxBufferStarvation = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxBufferStarvation.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxBufferStarvation.setDescription('The total number of receive buffer starvation errors that occurred in the hdlc controller for this specified channel number. ')
acLogicalHdlcTxFifoUnderrun = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcTxFifoUnderrun.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcTxFifoUnderrun.setDescription('The total number of transmit FIFO underrun errors that occurred in the hdlc controller for this specified channel number. This error occurs when attempts are made to read data from a channel that does not have any data ready to send.')
acLogicalHdlcRxBundleDiscardDupSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardDupSeq.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardDupSeq.setDescription('The total number of receive bundle discard duplicate sequence errors that occurred in the hdlc controller for this specified channel number. ')
acLogicalHdlcRxBundleDiscardMissSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardMissSeq.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardMissSeq.setDescription('The total number of receive bundle discard missed sequence errors that occurred in the hdlc controller for this specified channel number. ')
acLogicalHdlcRxBundleDiscardQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardQDepth.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcRxBundleDiscardQDepth.setDescription('The total number of receive bundle discard queue depth errors that occurred in the hdlc controller for this specified channel number. ')
acLogicalHdlcIngressRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcIngressRxFrames.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcIngressRxFrames.setDescription('The total number of ingress receive frames that the MLC has received from the hdlc controller for this specified channel number. ')
acLogicalHdlcEgressTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 4, 4, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLogicalHdlcEgressTxFrames.setStatus('current')
if mibBuilder.loadTexts: acLogicalHdlcEgressTxFrames.setDescription('The total number of egress transmit frames that the MLC has transmitted to the hdlc controller for this specified channel number. ')
mibBuilder.exportSymbols("APPIAN-LPORT-HDLC-MIB", acLogicalHdlcIngressRxFrames=acLogicalHdlcIngressRxFrames, acLogicalHdlcIndex=acLogicalHdlcIndex, acLogicalHdlcRxFifoOverrun=acLogicalHdlcRxFifoOverrun, acLogicalHdlcStatsReset=acLogicalHdlcStatsReset, acLogicalHdlcTable=acLogicalHdlcTable, acLogicalHdlcEntry=acLogicalHdlcEntry, acLogicalHdlcRxBundleDiscardQDepth=acLogicalHdlcRxBundleDiscardQDepth, acLogicalHdlcRxMaxPktLenViolation=acLogicalHdlcRxMaxPktLenViolation, acLogicalHdlcTxFifoUnderrun=acLogicalHdlcTxFifoUnderrun, acLogicalHdlcRxBundleDiscardMissSeq=acLogicalHdlcRxBundleDiscardMissSeq, PYSNMP_MODULE_ID=acLogicalHdlc, acLogicalHdlcType=acLogicalHdlcType, acLogicalHdlcNodeId=acLogicalHdlcNodeId, acLogicalHdlcRxBufferStarvation=acLogicalHdlcRxBufferStarvation, acLogicalHdlcSlot=acLogicalHdlcSlot, acLogicalHdlcRxBundleDiscardDupSeq=acLogicalHdlcRxBundleDiscardDupSeq, acLogicalHdlc=acLogicalHdlc, acLogicalHdlcRxNonOctetAligned=acLogicalHdlcRxNonOctetAligned, acLogicalHdlcRxFCSError=acLogicalHdlcRxFCSError, acLogicalHdlcEgressTxFrames=acLogicalHdlcEgressTxFrames, acLogicalHdlcRxHdlcPktAbort=acLogicalHdlcRxHdlcPktAbort)

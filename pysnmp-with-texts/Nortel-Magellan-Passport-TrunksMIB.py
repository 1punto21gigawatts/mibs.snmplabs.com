#
# PySNMP MIB module Nortel-Magellan-Passport-TrunksMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-TrunksMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
RowStatus, Gauge32, StorageType, Unsigned32, InterfaceIndex, DisplayString, PassportCounter64, Counter32, Integer32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "Gauge32", "StorageType", "Unsigned32", "InterfaceIndex", "DisplayString", "PassportCounter64", "Counter32", "Integer32")
AsciiString, NonReplicated, FixedPoint1 = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "AsciiString", "NonReplicated", "FixedPoint1")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, iso, TimeTicks, Gauge32, ModuleIdentity, Bits, Unsigned32, MibIdentifier, IpAddress, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "TimeTicks", "Gauge32", "ModuleIdentity", "Bits", "Unsigned32", "MibIdentifier", "IpAddress", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
trunksMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43))
trk = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60))
trkRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1), )
if mibBuilder.loadTexts: trkRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkRowStatusTable.setDescription('This entry controls the addition and deletion of trk components.')
trkRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkRowStatusEntry.setDescription('A single entry in the table represents a single trk component.')
trkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkRowStatus.setDescription('This variable is used as the basis for SNMP naming of trk components. These components can be added and deleted.')
trkComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkStorageType.setDescription('This variable represents the storage type value for the trk tables.')
trkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: trkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkIndex.setDescription('This variable represents the index for the trk tables.')
trkIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 100), )
if mibBuilder.loadTexts: trkIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
trkIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkIfEntryEntry.setDescription('An entry in the trkIfEntryTable.')
trkIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
trkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 100, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
trkProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101), )
if mibBuilder.loadTexts: trkProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkProvTable.setDescription('This group of attributes provides the parameters used by the layer 3 Trunk to Trunk staging protocol.')
trkProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkProvEntry.setDescription('An entry in the trkProvTable.')
trkExpectedRemoteNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkExpectedRemoteNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: trkExpectedRemoteNodeName.setDescription('This attribute specifies the expected node name of the module to which this Trunk is connected. Once entered, the node name must correspond to the Mod nodeName attribute of the remote node. The Trunk end points exchange their node name through the Trunk staging protocol. The staged value is validated and the remoteValidationAction will be executed for those values not matching the value supplied for this attribute. If this attribute is an empty string, then the comparison is always successful.')
trkRemoteValidationAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("continue", 0), ("disable", 1))).clone('continue')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkRemoteValidationAction.setStatus('mandatory')
if mibBuilder.loadTexts: trkRemoteValidationAction.setDescription('This attribute specifies the action to be taken if there is a mismatch between the expectedRemoteNodeName attribute and the value received from the remote end. The remoteValidationAction determines the action when a value is supplied to the expectedRemoteNodeName attribute. If this attribute is provisioned to continue then upon an unsuccessful validation staging continues, otherwise, if disable is set then the Trunk does not continue to stage but, attempts to stage again after a one minute time out. All unsuccessful validation when the expectedRemoteNodeName has been set result in the generation of an alarm.')
trkMaximumExpectedRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1500)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkMaximumExpectedRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: trkMaximumExpectedRoundTripDelay.setDescription('This is the maximum round trip delay value used by the Trunk staging protocol, in conjunction with measuredSpeedToIf, to determine if it has taken too long to successfully stage with a remote Trunk. The value specified must be larger than the measuredRoundTripDelay or the Trunk may not successfully stage.')
trkIdleTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 101, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 30)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkIdleTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: trkIdleTimeOut.setDescription('This attribute specifies the Trunk protocol idle time out duration in units of seconds. If the local Trunk does not receive any packets from the link for the period specified by this attribute, the Trunk enters Are You There (AYT) mode for up to two seconds. If the Trunk does not receive any packets from the remote during the AYT mode it will restage; otherwise, it exits AYT mode and continues to provide service.')
trkOverridesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 102), )
if mibBuilder.loadTexts: trkOverridesTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkOverridesTable.setDescription('Theses attribute comprise the set of provisionable override parameters supported by both the Trunk and DpnGateway components. The attributes are used when reporting operational attributes (used for metric calculations) to the routing system.')
trkOverridesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 102, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkOverridesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkOverridesEntry.setDescription('An entry in the trkOverridesTable.')
trkOverrideTransmitSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 102, 1, 1), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1000, 4294967295), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkOverrideTransmitSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: trkOverrideTransmitSpeed.setDescription('This is the overridden value of link speed (bit/s) that, if staged successfully with the remote, is reported to the routing system for metric calculations. A zero indicates that an override value has not been provided and that only the measured value will be reported to the routing system. If this value is changed on a Trunk or DpnGateway that is enabled, the LOCK and UNLOCK commands must be issued to the component to restage the override with the remote.')
trkOldOverrideRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 102, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkOldOverrideRoundTripDelay.setStatus('obsolete')
if mibBuilder.loadTexts: trkOldOverrideRoundTripDelay.setDescription('This is the overridden value of link delay (ms) that, if staged successfully with the remote, is reported to the routing system for metric calculations. A zero indicates that an override value has not been provided and that only the measured value will be reported to the routing system. If this value is changed on a Trunk or DpnGateway that is enabled, the LOCK and UNLOCK commands must be issued to the component to restage the override with the remote.')
trkOverrideRoundTripUsec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 102, 1, 3), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(0, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkOverrideRoundTripUsec.setStatus('mandatory')
if mibBuilder.loadTexts: trkOverrideRoundTripUsec.setDescription('This is the overridden value of link delay (ms) that, if staged successfully with the remote, is reported to the routing system for metric calculations. A zero indicates that an override value has not been provided and that only the measured value will be reported to the routing system. If this value is changed on a Trunk or DpnGateway that is enabled, the LOCK and UNLOCK commands must be issued to the component to restage the override with the remote.')
trkStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103), )
if mibBuilder.loadTexts: trkStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
trkStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkStateEntry.setDescription('An entry in the trkStateTable.')
trkAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: trkAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
trkOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: trkOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
trkUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: trkUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
trkAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
trkProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
trkControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
trkAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
trkStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
trkUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 103, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
trkOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 104), )
if mibBuilder.loadTexts: trkOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
trkOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkOperStatusEntry.setDescription('An entry in the trkOperStatusTable.')
trkSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
trkOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 105), )
if mibBuilder.loadTexts: trkOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkOperTable.setDescription('This is the group of operational attributes supported by the Trunk.')
trkOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 105, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkOperEntry.setDescription('An entry in the trkOperTable.')
trkRemoteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 105, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 27))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkRemoteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkRemoteComponentName.setDescription('This attribute is the component name of the remote end which it has supplied through the Trunk staging protocol.')
trkTransportTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106), )
if mibBuilder.loadTexts: trkTransportTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkTransportTable.setDescription('This group of attributes contains the set of operational parameters measured and maintained by both the Trunk and DpnGateway components.')
trkTransportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkTransportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkTransportEntry.setDescription('An entry in the trkTransportTable.')
trkMeasuredSpeedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkMeasuredSpeedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkMeasuredSpeedToIf.setDescription("This attribute indicates the current 'transmittable' bandwidth of the underlying facility. For a Trunk with a Unack subcomponent, and a DpnGateway with a Utp subcomponent, if a serial port is used, the value is the measured transmit speed of the port; if a channelized port (E1/DS1) is used, the value is the measured transmit speed of the Channel. For a Trunk with an AtmAccess subcomponent, the value is calculated by converting the VCC transmit cell rate to an equivalent bit rate. The VCC transmit cell rate is determined based on the vccReportingBw attribute of the Trunk AtmAccess component. If vccReportingBw has a value of pcr and attribute bwElastic of AtmAccess has a value of no, the peak cell rate (PCR) of the VCC, defined in txTrafficDescParm of AtmIf Vcc Vcd, is used. If vccReportingBw has a value of pcr and attribute bwElastic of AtmAccess has a value of yes, the minimum of the PCR, defined in txTrafficDescParm of AtmIf Vcc Vcd, and the current cell rate (CCR) of the VCC is used. If vccReportingBw has a value of acr, the best measurement of the actual cell rate (ACR) of the VCC is used, which is the minimum of the PCR, the CCR and the actual shaping rate (ASR). For a DpnGateway with a FrAccess subcomponent, the value indicates the committedInformationRate of FrAccess FrMuxSetup. A value of zero is displayed when the underlying facility is disabled or the current 'transmittable' bandwidth is unknown.")
trkMeasuredRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkMeasuredRoundTripDelay.setStatus('obsolete')
if mibBuilder.loadTexts: trkMeasuredRoundTripDelay.setDescription('This attribute indicates the measured Round Trip Delay (msec) discovered with the remote through the Trunk and DpnGateway staging protocols. The value includes emission, propagation, and queuing delays. A 512 byte data packet is used to perform the measurement. A value of zero is displayed when the link is disabled or the measured Round Trip Delay is unknown.')
trkMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: trkMaxTxUnit.setDescription('This is the maximum transmission unit (byte size) that is supported by the Trunk or DpnGateway component. This size includes the data and routing headers. A value of zero indicates the MTU has not yet been determined.')
trkMeasuredRoundTripDelayUsec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 106, 1, 4), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(0, 15000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkMeasuredRoundTripDelayUsec.setStatus('mandatory')
if mibBuilder.loadTexts: trkMeasuredRoundTripDelayUsec.setDescription('This attribute indicates the measured Round Trip Delay (msec) discovered with the remote through the Trunk and DpnGateway staging protocols. The value includes emission, propagation, and queuing delays. A 512 byte data packet is used to perform the measurement. A value of zero is displayed when the link is disabled or the measured Round Trip Delay is unknown.')
trkStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107), )
if mibBuilder.loadTexts: trkStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkStatsTable.setDescription('These attributes comprise the statistics collected by the Trunk component.')
trkStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkStatsEntry.setDescription('An entry in the trkStatsTable.')
trkAreYouThereModeEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkAreYouThereModeEntries.setStatus('mandatory')
if mibBuilder.loadTexts: trkAreYouThereModeEntries.setDescription('This attribute counts the number of times that the component has entered Are You There mode. This counter wraps around to zero when the maximum value is exceeded.')
trkPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPktFromIf.setDescription('This attribute counts the number of packets received from the remote module. It does not include the packets received from the interrupting queue. This counter wraps around to zero when the maximum value is exceeded.')
trkTrunkPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkTrunkPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkTrunkPktFromIf.setDescription('This attribute counts the number of internal trunk protocol packets (including those from the interrupting queue) received from the remote module. These packets are forwarded to the Trunk component. This counter wraps around to zero when the maximum value is exceeded.')
trkTrunkPktToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkTrunkPktToIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkTrunkPktToIf.setDescription('This attribute counts the number of internal trunk protocol packets (including those through the interrupting queue) transmitted to the remote module. This counter wraps around to zero when the maximum value is exceeded.')
trkDiscardUnforward = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDiscardUnforward.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscardUnforward.setDescription('This attribute counts the number of packets received from the remote module that have been discarded. It does not include the packets received from the interrupting queue that have been discarded. This counter wraps around to zero when the maximum value is exceeded. Two main reasons that cause this counter to increase are: (1) the remote protocol is not compatible with the local protocol stack or, (2) the packet cannot be forwarded due to a recent loss of connectivity or due to congestion.')
trkDiscardTrunkPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDiscardTrunkPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscardTrunkPktFromIf.setDescription('This attribute counts the number of internal trunk protocol packets (including those on the interrupting queue) received from the remote module that have been discarded. This counter wraps around to zero when the maximum value is exceeded. The three main reasons that cause this counter to increase are: (1) the two Trunks are not synchronized, (2) the remote trunk protocol is not the same version as the local protocol, and (3) the remote trunk has restaged.')
trkIntPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkIntPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkIntPktFromIf.setDescription('This attribute counts the number of packets received on the interrupting queue from the remote module. This counter wraps around to zero when the maximum value is exceeded.')
trkDiscardIntUnforward = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDiscardIntUnforward.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscardIntUnforward.setDescription('This attribute counts the number of packets received on the interrupting queue from the remote module that have been discarded. This counter wraps around to zero when the maximum value is exceeded. Two main reasons that cause this counter to increment are: (1) the remote protocol is not compatible to the local protocol stack and, (2) the packet cannot be forwarded due to either a recent loss of connectivity or due to congestion.')
trkStagingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkStagingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: trkStagingAttempts.setDescription('This attribute counts the number of times that the staging protocol has attempted to stage with the remote module. This counter wraps around to zero when the maximum value is exceeded. The main reason that causes this counter to increment is that the local hardware is up but, the local protocol cannot stage with the remote protocol due to a faulty connection. If the value is zero, then the local hardware has never enabled successfully.')
trkDiscardTrunkPktToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDiscardTrunkPktToIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscardTrunkPktToIf.setDescription('This attribute counts the number of internal trunk protocol packets (including those through the interrupting queue) that have been discarded before being transmitted to the remote module. This counter wraps around to zero when the maximum value is exceeded. The main reason that causes this counter to increment is that the trunk can not get sufficient resources to create an internal trunk protocol packet.')
trkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 107, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: trkUtilization.setDescription('This attribute indicates the average trunk utilization. For a Trunk/n with an Unack subcomponent, the value is the link receive utilization. It is calculated every minute by comparing the number of octets received from the remote module against the value of the Trunk/n measuredSpeedToIf. Since the trunk application solely owns the physical link, the maximum link utilization is 100%. For a Trunk/n with an AtmAccess subcomponent, the value is the VCC(s) transmit utilization. It is calculated every 30 seconds by comparing the number of cells transmitted by AtmIf Vcc(s) against the value of the Trunk/n measuredSpeedToIf. The VCCs include the trunk VCC indicated by atmConnection of Trunk/n AtmAccess and the PORS SPO (Short Path Oriented) multiplexing VCC if applicable. The PORS SPO multiplexing VCC only applies to a Trunk/n with subcomponents Pa AtmAccess, where the mode of AtmAccess is multiplexing, and the AtmAccess is linked to a second VCC indicated by atmConnection of Pa AtmAccess. Since the trunk application shares a physical link with other applications, the VCCs utilization can exceed 100%, and the value 200% is chosen as the maximum calculated utilization.')
trkSpeedReportingTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 109), )
if mibBuilder.loadTexts: trkSpeedReportingTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpeedReportingTable.setDescription('This group of provisionable attributes provides the ability to disable or enable the generation of speed change alarms by the Trunk component. It also provides the ability to disable or enable the Dynamic Speed Reporting mechanism.')
trkSpeedReportingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 109, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"))
if mibBuilder.loadTexts: trkSpeedReportingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpeedReportingEntry.setDescription('An entry in the trkSpeedReportingTable.')
trkSpeedReportingHoldOff = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 109, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkSpeedReportingHoldOff.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpeedReportingHoldOff.setDescription('This attribute specifies the hold off time for reporting speed increases. When the measuredSpeedToIf reaches a level specified by the speedReportingThresholds attribute, the value specifies the duration (in units of seconds) for which the measuredSpeedToIf must maintain that level before it will be reported.')
trkLowSpeedAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 109, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkLowSpeedAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trkLowSpeedAlarmThreshold.setDescription('This attribute specifies the lower end of the range of normal speeds for this Trunk. If the measuredSpeedToIf drops below this value the Trunk component generates a SET alarm. When the measuredSpeedToIf reaches or exceeds the value of this attribute, the Trunk component will generate a CLEAR alarm.')
trkHighSpeedAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 109, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkHighSpeedAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: trkHighSpeedAlarmThreshold.setDescription('This attribute specifies the upper end of the range of normal speeds for this Trunk. If the measuredSpeedToIf exceeds this value the Trunk component generates a SET alarm. When the measuredSpeedToIf returns to or falls below the value of this attribute, the Trunk component will generate a CLEAR alarm.')
trkSpdThTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 318), )
if mibBuilder.loadTexts: trkSpdThTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpdThTable.setDescription('This attribute controls the behavior of the Dynamic Speed Reporting mechanism. If its value is empty then the mechanism is disabled and neither increases nor decreases are reported. Otherwise, the attribute may contain up to seven threshold levels which are used to control the reporting of speed increases. Speed decreases are always reported immediately. If the measuredSpeedToIf increases such that it reaches one of the threshold levels which is greater than the last reported speed, the Trunk starts the speedReportingHoldOff timer. If the speed remains above this threshold until the timer expires, the Trunk component then reports the measuredSpeedToIf; otherwise the increase is not reported.')
trkSpdThEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 318, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkSpdThValue"))
if mibBuilder.loadTexts: trkSpdThEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpdThEntry.setDescription('An entry in the trkSpdThTable.')
trkSpdThValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 318, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkSpdThValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpdThValue.setDescription('This variable represents both the value and the index for the trkSpdThTable.')
trkSpdThRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 318, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: trkSpdThRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkSpdThRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the trkSpdThTable.')
trkPktBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 368), )
if mibBuilder.loadTexts: trkPktBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPktBpTable.setDescription('This attribute counts the number of packets received by the Trunk. It is a vector indexed by the emission priorities (ep0, ep1, and ep2) of the packets. The highest emission priority is ep0. These counters wrap around to zero when the maximum value is exceeded.')
trkPktBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 368, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPktBpIndex"))
if mibBuilder.loadTexts: trkPktBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPktBpEntry.setDescription('An entry in the trkPktBpTable.')
trkPktBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 368, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkPktBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPktBpIndex.setDescription('This variable represents the trkPktBpTable specific index for the trkPktBpTable.')
trkPktBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 368, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPktBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPktBpValue.setDescription('This variable represents an individual value for the trkPktBpTable.')
trkDiscBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 369), )
if mibBuilder.loadTexts: trkDiscBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscBpTable.setDescription('This attribute counts the number of packets received from the remote module that have been discarded. It is a vector indexed by the emission priorities (ep0, ep1 and ep2) of the packets. The highest emission priority is ep0. These counters wrap around to zero when the maximum value is exceeded. Two main reasons that cause this counter to increment are: (1) the remote protocol is not compatible to the local protocol stack and, (2) the packet cannot be forwarded due to either a recent loss of connectivity or due to congestion. DESCRIPTION')
trkDiscBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 369, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDiscBpIndex"))
if mibBuilder.loadTexts: trkDiscBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscBpEntry.setDescription('An entry in the trkDiscBpTable.')
trkDiscBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 369, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkDiscBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscBpIndex.setDescription('This variable represents the trkDiscBpTable specific index for the trkDiscBpTable.')
trkDiscBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 369, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDiscBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkDiscBpValue.setDescription('This variable represents an individual value for the trkDiscBpTable.')
trkOctBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 370), )
if mibBuilder.loadTexts: trkOctBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkOctBpTable.setDescription('This attribute counts the octets coming from the remote module which are received by the Trunk. It is a vector indexed by the emission priorities (ep0, ep1 and ep2) of the packets. The highest emission priority is ep0. These counters wrap around to zero when the maximum value is exceeded.')
trkOctBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 370, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkOctBpIndex"))
if mibBuilder.loadTexts: trkOctBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkOctBpEntry.setDescription('An entry in the trkOctBpTable.')
trkOctBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 370, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkOctBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkOctBpIndex.setDescription('This variable represents the trkOctBpTable specific index for the trkOctBpTable.')
trkOctBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 370, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkOctBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkOctBpValue.setDescription('This variable represents an individual value for the trkOctBpTable.')
trkPorsStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6))
trkPorsStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1), )
if mibBuilder.loadTexts: trkPorsStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsRowStatusTable.setDescription('This entry controls the addition and deletion of trkPorsStats components.')
trkPorsStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsIndex"))
if mibBuilder.loadTexts: trkPorsStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsRowStatusEntry.setDescription('A single entry in the table represents a single trkPorsStats component.')
trkPorsStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkPorsStats components. These components cannot be added nor deleted.')
trkPorsStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkPorsStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsStorageType.setDescription('This variable represents the storage type value for the trkPorsStats tables.')
trkPorsStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: trkPorsStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsIndex.setDescription('This variable represents the index for the trkPorsStats tables.')
trkPorsStatsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10), )
if mibBuilder.loadTexts: trkPorsStatsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOperTable.setDescription('This operational group provides the PORS Trunks interrupting and normal traffic statistics for operator console display.')
trkPorsStatsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsIndex"))
if mibBuilder.loadTexts: trkPorsStatsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOperEntry.setDescription('An entry in the trkPorsStatsOperTable.')
trkPorsStatsPorsNormPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsNormPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsNormPktFromIf.setDescription('This attribute counts the number of normal priority packets received on the PORS Trunk normal priority queue. This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPorsNormDiscUnforwardFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsNormDiscUnforwardFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsNormDiscUnforwardFromIf.setDescription('This attribute counts the number of normal priority packets discarded from the PORS Trunk normal priority queue. This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPorsNormOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsNormOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsNormOctetFromIf.setDescription('This attribute counts the number of normal priority bytes received on the PORS Trunk normal priority queue.This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPorsIntPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsIntPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsIntPktFromIf.setDescription('This attribute counts the number of interrupting priority packets received on the PORS Trunk interrupting priority queue. This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPorsIntDiscUnforwardFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsIntDiscUnforwardFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsIntDiscUnforwardFromIf.setDescription('This attribute counts the number of interrupting priority packets discarded from the PORS Trunk interrupting priority queue. This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPorsIntOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 10, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPorsIntOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPorsIntOctetFromIf.setDescription('This attribute counts the number of interrupting priority bytes received on the PORS Trunk interrupting priority queue. This counter wraps around to zero when the maximum value is exceeded.')
trkPorsStatsPktBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 371), )
if mibBuilder.loadTexts: trkPorsStatsPktBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPktBpTable.setDescription('This attribute counts the number of PORS packets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkPorsStatsPktBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 371, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsPktBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsPktBpDpIndex"))
if mibBuilder.loadTexts: trkPorsStatsPktBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPktBpEntry.setDescription('An entry in the trkPorsStatsPktBpTable.')
trkPorsStatsPktBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 371, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkPorsStatsPktBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPktBpEpIndex.setDescription('This variable represents the next to last index for the trkPorsStatsPktBpTable.')
trkPorsStatsPktBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 371, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkPorsStatsPktBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPktBpDpIndex.setDescription('This variable represents the final index for the trkPorsStatsPktBpTable.')
trkPorsStatsPktBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 371, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsPktBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsPktBpValue.setDescription('This variable represents an individual value for the trkPorsStatsPktBpTable.')
trkPorsStatsDiscBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 372), )
if mibBuilder.loadTexts: trkPorsStatsDiscBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsDiscBpTable.setDescription('This attribute counts the number of PORS packets received from the remote module that have been discarded. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkPorsStatsDiscBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 372, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsDiscBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsDiscBpDpIndex"))
if mibBuilder.loadTexts: trkPorsStatsDiscBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsDiscBpEntry.setDescription('An entry in the trkPorsStatsDiscBpTable.')
trkPorsStatsDiscBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 372, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkPorsStatsDiscBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsDiscBpEpIndex.setDescription('This variable represents the next to last index for the trkPorsStatsDiscBpTable.')
trkPorsStatsDiscBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 372, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkPorsStatsDiscBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsDiscBpDpIndex.setDescription('This variable represents the final index for the trkPorsStatsDiscBpTable.')
trkPorsStatsDiscBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 372, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsDiscBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsDiscBpValue.setDescription('This variable represents an individual value for the trkPorsStatsDiscBpTable.')
trkPorsStatsOctBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 373), )
if mibBuilder.loadTexts: trkPorsStatsOctBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOctBpTable.setDescription('This attribute counts the number of PORS octets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkPorsStatsOctBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 373, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsOctBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkPorsStatsOctBpDpIndex"))
if mibBuilder.loadTexts: trkPorsStatsOctBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOctBpEntry.setDescription('An entry in the trkPorsStatsOctBpTable.')
trkPorsStatsOctBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 373, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkPorsStatsOctBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOctBpEpIndex.setDescription('This variable represents the next to last index for the trkPorsStatsOctBpTable.')
trkPorsStatsOctBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 373, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkPorsStatsOctBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOctBpDpIndex.setDescription('This variable represents the final index for the trkPorsStatsOctBpTable.')
trkPorsStatsOctBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 6, 373, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkPorsStatsOctBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkPorsStatsOctBpValue.setDescription('This variable represents an individual value for the trkPorsStatsOctBpTable.')
trkFwdStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7))
trkFwdStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1), )
if mibBuilder.loadTexts: trkFwdStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsRowStatusTable.setDescription('This entry controls the addition and deletion of trkFwdStats components.')
trkFwdStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkFwdStatsIndex"))
if mibBuilder.loadTexts: trkFwdStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsRowStatusEntry.setDescription('A single entry in the table represents a single trkFwdStats component.')
trkFwdStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkFwdStats components. These components cannot be added nor deleted.')
trkFwdStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkFwdStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsStorageType.setDescription('This variable represents the storage type value for the trkFwdStats tables.')
trkFwdStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: trkFwdStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsIndex.setDescription('This variable represents the index for the trkFwdStats tables.')
trkFwdStatsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 10), )
if mibBuilder.loadTexts: trkFwdStatsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsOperTable.setDescription('This operational group counts the Trunk or DpnGateway packet forwarding traffic statistics for operator console display.')
trkFwdStatsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkFwdStatsIndex"))
if mibBuilder.loadTexts: trkFwdStatsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsOperEntry.setDescription('An entry in the trkFwdStatsOperTable.')
trkFwdStatsFwdPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 10, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsFwdPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsFwdPktFromIf.setDescription('This attribute counts the number of forwarding packets received by the Trunk or DpnGateway. This counter wraps around to zero when the maximum value is exceeded.')
trkFwdStatsFwdDiscUnforwardFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsFwdDiscUnforwardFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsFwdDiscUnforwardFromIf.setDescription('This attribute counts the number of forwarding packets discarded by the Trunk or DpnGateway. This counter wraps around to zero when the maximum value is exceeded.')
trkFwdStatsFwdOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 7, 10, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkFwdStatsFwdOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkFwdStatsFwdOctetFromIf.setDescription('This attribute counts the number of forwarding bytes received by the Trunk or DpnGateway. This counter wraps around to zero when the maximum value is exceeded.')
trkVnsStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8))
trkVnsStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1), )
if mibBuilder.loadTexts: trkVnsStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsRowStatusTable.setDescription('This entry controls the addition and deletion of trkVnsStats components.')
trkVnsStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsIndex"))
if mibBuilder.loadTexts: trkVnsStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsRowStatusEntry.setDescription('A single entry in the table represents a single trkVnsStats component.')
trkVnsStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkVnsStats components. These components cannot be added nor deleted.')
trkVnsStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkVnsStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsStorageType.setDescription('This variable represents the storage type value for the trkVnsStats tables.')
trkVnsStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: trkVnsStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsIndex.setDescription('This variable represents the index for the trkVnsStats tables.')
trkVnsStatsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 10), )
if mibBuilder.loadTexts: trkVnsStatsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOperTable.setDescription('This operational group counts the Trunk virtual network traffic statistics for operator console display.')
trkVnsStatsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsIndex"))
if mibBuilder.loadTexts: trkVnsStatsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOperEntry.setDescription('An entry in the trkVnsStatsOperTable.')
trkVnsStatsVnsPktFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 10, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsVnsPktFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsVnsPktFromIf.setDescription('This attribute counts the number of virtual network packets received by a Trunk component handling virtual network traffic. This counter wraps around to zero when the maximum value is exceeded.')
trkVnsStatsVnsDiscUnforwardFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsVnsDiscUnforwardFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsVnsDiscUnforwardFromIf.setDescription('This attribute counts the number of virtual network packets discarded by a Trunk component handling virtual network traffic. This counter wraps around to zero when the maximum value is exceeded.')
trkVnsStatsVnsOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 10, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsVnsOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsVnsOctetFromIf.setDescription('This attribute counts the number of virtual network bytes received by a Trunk component handling virtual network traffic. This counter wraps around to zero when the maximum value is exceeded.')
trkVnsStatsPktBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 377), )
if mibBuilder.loadTexts: trkVnsStatsPktBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsPktBpTable.setDescription('This attribute counts the number of Virtual Network packets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkVnsStatsPktBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 377, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsPktBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsPktBpDpIndex"))
if mibBuilder.loadTexts: trkVnsStatsPktBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsPktBpEntry.setDescription('An entry in the trkVnsStatsPktBpTable.')
trkVnsStatsPktBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 377, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkVnsStatsPktBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsPktBpEpIndex.setDescription('This variable represents the next to last index for the trkVnsStatsPktBpTable.')
trkVnsStatsPktBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 377, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkVnsStatsPktBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsPktBpDpIndex.setDescription('This variable represents the final index for the trkVnsStatsPktBpTable.')
trkVnsStatsPktBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 377, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsPktBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsPktBpValue.setDescription('This variable represents an individual value for the trkVnsStatsPktBpTable.')
trkVnsStatsDiscBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 378), )
if mibBuilder.loadTexts: trkVnsStatsDiscBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsDiscBpTable.setDescription('This attribute counts the number of Virtual Network packets received from the remote module that have been discarded by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkVnsStatsDiscBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 378, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsDiscBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsDiscBpDpIndex"))
if mibBuilder.loadTexts: trkVnsStatsDiscBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsDiscBpEntry.setDescription('An entry in the trkVnsStatsDiscBpTable.')
trkVnsStatsDiscBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 378, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkVnsStatsDiscBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsDiscBpEpIndex.setDescription('This variable represents the next to last index for the trkVnsStatsDiscBpTable.')
trkVnsStatsDiscBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 378, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkVnsStatsDiscBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsDiscBpDpIndex.setDescription('This variable represents the final index for the trkVnsStatsDiscBpTable.')
trkVnsStatsDiscBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 378, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsDiscBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsDiscBpValue.setDescription('This variable represents an individual value for the trkVnsStatsDiscBpTable.')
trkVnsStatsOctBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 379), )
if mibBuilder.loadTexts: trkVnsStatsOctBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOctBpTable.setDescription('This attribute counts the number of Virtual Network octets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkVnsStatsOctBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 379, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsOctBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkVnsStatsOctBpDpIndex"))
if mibBuilder.loadTexts: trkVnsStatsOctBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOctBpEntry.setDescription('An entry in the trkVnsStatsOctBpTable.')
trkVnsStatsOctBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 379, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkVnsStatsOctBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOctBpEpIndex.setDescription('This variable represents the next to last index for the trkVnsStatsOctBpTable.')
trkVnsStatsOctBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 379, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkVnsStatsOctBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOctBpDpIndex.setDescription('This variable represents the final index for the trkVnsStatsOctBpTable.')
trkVnsStatsOctBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 8, 379, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkVnsStatsOctBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkVnsStatsOctBpValue.setDescription('This variable represents an individual value for the trkVnsStatsOctBpTable.')
trkDprsStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10))
trkDprsStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1), )
if mibBuilder.loadTexts: trkDprsStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsRowStatusTable.setDescription('This entry controls the addition and deletion of trkDprsStats components.')
trkDprsStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsIndex"))
if mibBuilder.loadTexts: trkDprsStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsRowStatusEntry.setDescription('A single entry in the table represents a single trkDprsStats component.')
trkDprsStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of trkDprsStats components. These components cannot be added nor deleted.')
trkDprsStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
trkDprsStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsStorageType.setDescription('This variable represents the storage type value for the trkDprsStats tables.')
trkDprsStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: trkDprsStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsIndex.setDescription('This variable represents the index for the trkDprsStats tables.')
trkDprsStatsPktBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 374), )
if mibBuilder.loadTexts: trkDprsStatsPktBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsPktBpTable.setDescription('This attribute counts the number of DPRS packets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkDprsStatsPktBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 374, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsPktBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsPktBpDpIndex"))
if mibBuilder.loadTexts: trkDprsStatsPktBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsPktBpEntry.setDescription('An entry in the trkDprsStatsPktBpTable.')
trkDprsStatsPktBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 374, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkDprsStatsPktBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsPktBpEpIndex.setDescription('This variable represents the next to last index for the trkDprsStatsPktBpTable.')
trkDprsStatsPktBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 374, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkDprsStatsPktBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsPktBpDpIndex.setDescription('This variable represents the final index for the trkDprsStatsPktBpTable.')
trkDprsStatsPktBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 374, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsPktBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsPktBpValue.setDescription('This variable represents an individual value for the trkDprsStatsPktBpTable.')
trkDprsStatsDiscBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 375), )
if mibBuilder.loadTexts: trkDprsStatsDiscBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsDiscBpTable.setDescription('This attribute counts the number of DPRS packets received from the remote module that have been discarded by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkDprsStatsDiscBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 375, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsDiscBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsDiscBpDpIndex"))
if mibBuilder.loadTexts: trkDprsStatsDiscBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsDiscBpEntry.setDescription('An entry in the trkDprsStatsDiscBpTable.')
trkDprsStatsDiscBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 375, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkDprsStatsDiscBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsDiscBpEpIndex.setDescription('This variable represents the next to last index for the trkDprsStatsDiscBpTable.')
trkDprsStatsDiscBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 375, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkDprsStatsDiscBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsDiscBpDpIndex.setDescription('This variable represents the final index for the trkDprsStatsDiscBpTable.')
trkDprsStatsDiscBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 375, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsDiscBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsDiscBpValue.setDescription('This variable represents an individual value for the trkDprsStatsDiscBpTable.')
trkDprsStatsOctBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 376), )
if mibBuilder.loadTexts: trkDprsStatsOctBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsOctBpTable.setDescription('This attribute counts the number of DPRS octets received by the Trunk. It is an array indexed by the emission priorities (ep0, ep1 and ep2) and discard priorities (dp0, dp1, dp2 and dp3) of the packets. The highest emission priority is ep0 and the least discardable priority is dp0. These counters wrap around to zero when the maximum value is exceeded.')
trkDprsStatsOctBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 376, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TrunksMIB", "trkIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsOctBpEpIndex"), (0, "Nortel-Magellan-Passport-TrunksMIB", "trkDprsStatsOctBpDpIndex"))
if mibBuilder.loadTexts: trkDprsStatsOctBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsOctBpEntry.setDescription('An entry in the trkDprsStatsOctBpTable.')
trkDprsStatsOctBpEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 376, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2))))
if mibBuilder.loadTexts: trkDprsStatsOctBpEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsOctBpEpIndex.setDescription('This variable represents the next to last index for the trkDprsStatsOctBpTable.')
trkDprsStatsOctBpDpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 376, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dp0", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))))
if mibBuilder.loadTexts: trkDprsStatsOctBpDpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsOctBpDpIndex.setDescription('This variable represents the final index for the trkDprsStatsOctBpTable.')
trkDprsStatsOctBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 60, 10, 376, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trkDprsStatsOctBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: trkDprsStatsOctBpValue.setDescription('This variable represents an individual value for the trkDprsStatsOctBpTable.')
trunksGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 1))
trunksGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 1, 5))
trunksGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 1, 5, 1))
trunksGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 1, 5, 1, 2))
trunksCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 3))
trunksCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 3, 5))
trunksCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 3, 5, 1))
trunksCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 43, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-TrunksMIB", trkDprsStatsOctBpEpIndex=trkDprsStatsOctBpEpIndex, trkRowStatusTable=trkRowStatusTable, trkAreYouThereModeEntries=trkAreYouThereModeEntries, trkVnsStatsVnsDiscUnforwardFromIf=trkVnsStatsVnsDiscUnforwardFromIf, trkDprsStatsPktBpValue=trkDprsStatsPktBpValue, trkVnsStatsRowStatusEntry=trkVnsStatsRowStatusEntry, trkRowStatusEntry=trkRowStatusEntry, trkIntPktFromIf=trkIntPktFromIf, trkFwdStatsComponentName=trkFwdStatsComponentName, trkProvEntry=trkProvEntry, trkDiscardTrunkPktToIf=trkDiscardTrunkPktToIf, trkPorsStatsComponentName=trkPorsStatsComponentName, trkDprsStatsPktBpTable=trkDprsStatsPktBpTable, trkTrunkPktToIf=trkTrunkPktToIf, trkUnknownStatus=trkUnknownStatus, trkAvailabilityStatus=trkAvailabilityStatus, trkOperTable=trkOperTable, trkSpdThEntry=trkSpdThEntry, trkVnsStatsDiscBpDpIndex=trkVnsStatsDiscBpDpIndex, trkSnmpOperStatus=trkSnmpOperStatus, trkControlStatus=trkControlStatus, trkSpdThValue=trkSpdThValue, trkPorsStatsOperEntry=trkPorsStatsOperEntry, trkFwdStatsFwdDiscUnforwardFromIf=trkFwdStatsFwdDiscUnforwardFromIf, trkStorageType=trkStorageType, trkPorsStatsStorageType=trkPorsStatsStorageType, trkVnsStatsPktBpEpIndex=trkVnsStatsPktBpEpIndex, trkSpeedReportingHoldOff=trkSpeedReportingHoldOff, trunksMIB=trunksMIB, trkDiscardIntUnforward=trkDiscardIntUnforward, trkOverrideTransmitSpeed=trkOverrideTransmitSpeed, trkPorsStatsOctBpEntry=trkPorsStatsOctBpEntry, trkPktBpIndex=trkPktBpIndex, trkFwdStatsRowStatusTable=trkFwdStatsRowStatusTable, trkVnsStatsDiscBpEntry=trkVnsStatsDiscBpEntry, trunksCapabilities=trunksCapabilities, trkStandbyStatus=trkStandbyStatus, trkPorsStats=trkPorsStats, trkSpdThTable=trkSpdThTable, trkOctBpValue=trkOctBpValue, trkVnsStatsStorageType=trkVnsStatsStorageType, trkRemoteValidationAction=trkRemoteValidationAction, trkIdleTimeOut=trkIdleTimeOut, trkDprsStatsOctBpEntry=trkDprsStatsOctBpEntry, trkOperStatusTable=trkOperStatusTable, trkPktBpValue=trkPktBpValue, trkDprsStatsStorageType=trkDprsStatsStorageType, trkDprsStatsOctBpValue=trkDprsStatsOctBpValue, trkFwdStatsRowStatusEntry=trkFwdStatsRowStatusEntry, trkIndex=trkIndex, trkPktBpTable=trkPktBpTable, trkVnsStatsRowStatus=trkVnsStatsRowStatus, trunksGroupBE=trunksGroupBE, trkSpdThRowStatus=trkSpdThRowStatus, trkPorsStatsRowStatusTable=trkPorsStatsRowStatusTable, trkOctBpIndex=trkOctBpIndex, trkPorsStatsOctBpTable=trkPorsStatsOctBpTable, trkDprsStatsPktBpEntry=trkDprsStatsPktBpEntry, trkVnsStatsOctBpEntry=trkVnsStatsOctBpEntry, trkStateTable=trkStateTable, trkDiscBpTable=trkDiscBpTable, trkPorsStatsPktBpDpIndex=trkPorsStatsPktBpDpIndex, trkStagingAttempts=trkStagingAttempts, trkVnsStatsOctBpValue=trkVnsStatsOctBpValue, trunksCapabilitiesBE00A=trunksCapabilitiesBE00A, trkDiscardTrunkPktFromIf=trkDiscardTrunkPktFromIf, trkVnsStatsDiscBpEpIndex=trkVnsStatsDiscBpEpIndex, trkPktFromIf=trkPktFromIf, trkVnsStatsPktBpValue=trkVnsStatsPktBpValue, trkStateEntry=trkStateEntry, trkPorsStatsDiscBpEntry=trkPorsStatsDiscBpEntry, trkPorsStatsPorsNormPktFromIf=trkPorsStatsPorsNormPktFromIf, trkFwdStats=trkFwdStats, trkUsageState=trkUsageState, trkVnsStatsPktBpEntry=trkVnsStatsPktBpEntry, trkPorsStatsDiscBpEpIndex=trkPorsStatsDiscBpEpIndex, trkIfIndex=trkIfIndex, trkDprsStatsDiscBpEpIndex=trkDprsStatsDiscBpEpIndex, trkPorsStatsPorsIntPktFromIf=trkPorsStatsPorsIntPktFromIf, trunksGroupBE00=trunksGroupBE00, trkPorsStatsOctBpValue=trkPorsStatsOctBpValue, trkDprsStatsRowStatusTable=trkDprsStatsRowStatusTable, trkOverridesEntry=trkOverridesEntry, trkPorsStatsPorsIntDiscUnforwardFromIf=trkPorsStatsPorsIntDiscUnforwardFromIf, trkDprsStatsPktBpDpIndex=trkDprsStatsPktBpDpIndex, trkDprsStatsRowStatus=trkDprsStatsRowStatus, trkFwdStatsIndex=trkFwdStatsIndex, trkVnsStatsOctBpDpIndex=trkVnsStatsOctBpDpIndex, trkExpectedRemoteNodeName=trkExpectedRemoteNodeName, trkFwdStatsRowStatus=trkFwdStatsRowStatus, trkDprsStatsIndex=trkDprsStatsIndex, trkPorsStatsPktBpTable=trkPorsStatsPktBpTable, trkVnsStatsComponentName=trkVnsStatsComponentName, trkTrunkPktFromIf=trkTrunkPktFromIf, trkVnsStatsDiscBpTable=trkVnsStatsDiscBpTable, trkAdminState=trkAdminState, trkStatsEntry=trkStatsEntry, trkVnsStatsVnsOctetFromIf=trkVnsStatsVnsOctetFromIf, trunksGroupBE00A=trunksGroupBE00A, trunksCapabilitiesBE00=trunksCapabilitiesBE00, trkMeasuredRoundTripDelay=trkMeasuredRoundTripDelay, trkPorsStatsPorsIntOctetFromIf=trkPorsStatsPorsIntOctetFromIf, trkPktBpEntry=trkPktBpEntry, trkVnsStatsVnsPktFromIf=trkVnsStatsVnsPktFromIf, trkDprsStats=trkDprsStats, trunksGroup=trunksGroup, trkVnsStats=trkVnsStats, trkVnsStatsOperTable=trkVnsStatsOperTable, trkIfAdminStatus=trkIfAdminStatus, trk=trk, trkSpeedReportingTable=trkSpeedReportingTable, trkPorsStatsDiscBpValue=trkPorsStatsDiscBpValue, trkPorsStatsDiscBpTable=trkPorsStatsDiscBpTable, trkPorsStatsOctBpDpIndex=trkPorsStatsOctBpDpIndex, trkFwdStatsFwdPktFromIf=trkFwdStatsFwdPktFromIf, trkHighSpeedAlarmThreshold=trkHighSpeedAlarmThreshold, trkPorsStatsRowStatus=trkPorsStatsRowStatus, trkPorsStatsOperTable=trkPorsStatsOperTable, trkLowSpeedAlarmThreshold=trkLowSpeedAlarmThreshold, trkPorsStatsPktBpEntry=trkPorsStatsPktBpEntry, trkRemoteComponentName=trkRemoteComponentName, trkAlarmStatus=trkAlarmStatus, trkDiscBpValue=trkDiscBpValue, trkMeasuredRoundTripDelayUsec=trkMeasuredRoundTripDelayUsec, trkOperStatusEntry=trkOperStatusEntry, trkUtilization=trkUtilization, trkDprsStatsRowStatusEntry=trkDprsStatsRowStatusEntry, trkPorsStatsPktBpEpIndex=trkPorsStatsPktBpEpIndex, trkTransportEntry=trkTransportEntry, trkFwdStatsOperEntry=trkFwdStatsOperEntry, trkVnsStatsOctBpTable=trkVnsStatsOctBpTable, trkDprsStatsOctBpTable=trkDprsStatsOctBpTable, trkMaximumExpectedRoundTripDelay=trkMaximumExpectedRoundTripDelay, trkDprsStatsComponentName=trkDprsStatsComponentName, trkVnsStatsPktBpDpIndex=trkVnsStatsPktBpDpIndex, trkIfEntryEntry=trkIfEntryEntry, trkPorsStatsDiscBpDpIndex=trkPorsStatsDiscBpDpIndex, trkVnsStatsIndex=trkVnsStatsIndex, trkComponentName=trkComponentName, trkDiscBpIndex=trkDiscBpIndex, trkPorsStatsPorsNormOctetFromIf=trkPorsStatsPorsNormOctetFromIf, trkDprsStatsOctBpDpIndex=trkDprsStatsOctBpDpIndex, trkOctBpTable=trkOctBpTable, trkOperationalState=trkOperationalState, trkTransportTable=trkTransportTable, trkDprsStatsDiscBpEntry=trkDprsStatsDiscBpEntry, trkDprsStatsDiscBpTable=trkDprsStatsDiscBpTable, trkVnsStatsRowStatusTable=trkVnsStatsRowStatusTable, trkIfEntryTable=trkIfEntryTable, trkOverrideRoundTripUsec=trkOverrideRoundTripUsec, trkOverridesTable=trkOverridesTable, trkPorsStatsIndex=trkPorsStatsIndex, trkMaxTxUnit=trkMaxTxUnit, trkOctBpEntry=trkOctBpEntry, trkStatsTable=trkStatsTable, trkPorsStatsRowStatusEntry=trkPorsStatsRowStatusEntry, trkPorsStatsPktBpValue=trkPorsStatsPktBpValue, trkProvTable=trkProvTable, trkDiscBpEntry=trkDiscBpEntry, trkFwdStatsStorageType=trkFwdStatsStorageType, trkVnsStatsOctBpEpIndex=trkVnsStatsOctBpEpIndex, trkVnsStatsDiscBpValue=trkVnsStatsDiscBpValue, trkProceduralStatus=trkProceduralStatus, trkPorsStatsPorsNormDiscUnforwardFromIf=trkPorsStatsPorsNormDiscUnforwardFromIf, trkDiscardUnforward=trkDiscardUnforward, trunksCapabilitiesBE=trunksCapabilitiesBE, trkVnsStatsOperEntry=trkVnsStatsOperEntry, trkRowStatus=trkRowStatus, trkVnsStatsPktBpTable=trkVnsStatsPktBpTable, trkDprsStatsPktBpEpIndex=trkDprsStatsPktBpEpIndex, trkOldOverrideRoundTripDelay=trkOldOverrideRoundTripDelay, trkOperEntry=trkOperEntry, trkPorsStatsOctBpEpIndex=trkPorsStatsOctBpEpIndex, trkSpeedReportingEntry=trkSpeedReportingEntry, trkFwdStatsOperTable=trkFwdStatsOperTable, trkDprsStatsDiscBpDpIndex=trkDprsStatsDiscBpDpIndex, trkDprsStatsDiscBpValue=trkDprsStatsDiscBpValue, trkMeasuredSpeedToIf=trkMeasuredSpeedToIf, trkFwdStatsFwdOctetFromIf=trkFwdStatsFwdOctetFromIf)

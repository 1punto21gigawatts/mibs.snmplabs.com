#
# PySNMP MIB module AIRESPACE-WIRELESS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AIRESPACE-WIRELESS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:16:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
airespace, = mibBuilder.importSymbols("AIRESPACE-REF-MIB", "airespace")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Gauge32, ObjectIdentity, Bits, Counter64, ModuleIdentity, Integer32, iso, NotificationType, MibIdentifier, TimeTicks, IpAddress, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Gauge32", "ObjectIdentity", "Bits", "Counter64", "ModuleIdentity", "Integer32", "iso", "NotificationType", "MibIdentifier", "TimeTicks", "IpAddress", "Counter32")
RowStatus, TimeInterval, DisplayString, TruthValue, TextualConvention, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeInterval", "DisplayString", "TruthValue", "TextualConvention", "MacAddress")
bsnWireless = ModuleIdentity((1, 3, 6, 1, 4, 1, 14179, 2))
bsnWireless.setRevisions(('2011-09-27 00:00', '2010-02-09 00:00', '2006-04-10 00:00', '2005-10-30 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bsnWireless.setRevisionsDescriptions(('Modified the following variables with additional enumeration values: bsnMobileStationReasonCode, bsnMobileStationProtocol, bsnMobileStationCcxVersion, bsnAPType. Modified the following notification variable: bsnStationReasonCode Deprecated the following variables: bsnDot11EssIPv6Bridging, bsnAPPortNumber, bsnAPAdminStatus, bsnAPIfAdminStatus, bsnRrmDot11aGlobalAutomaticGrouping, bsnRrmDot11aGroupLeaderMacAddr, bsnRrmIsDot11aGroupLeader, bsnRrmDot11aGroupLastUpdateTime, bsnRrmDot11aGlobalGroupInterval, bsnRrmDot11bGlobalAutomaticGrouping, bsnRrmDot11bGroupLeaderMacAddr, bsnRrmIsDot11bGroupLeader, bsnRrmDot11bGroupLastUpdateTime, bsnRrmDot11bGlobalGroupInterval. Deprecated following tables: bsnWrasDot11aGroupTable, bsnWrasDot11bGroupTable. Deprecated following notifications: bsnAPIfUp, bsnAPIfDown.', 'Updated:- bsnDot11EssStaticWEPEncryptionType, bsnDot11Ess8021xEncryptionType, bsnMobileStationReasonCode, bsnMobileStationProtocol, bsnRogueAPRadioType, bsnRogueAPAirespaceAPPreamble, bsnAPMonitorOnlyMode, bsnAPType, bsnAPIfPhyChannelNumber, bsnAPIfSniffChannel, bsnRogueLocationDiscoveryProtocol, bsnAPAuthCertificateType, bsnStationReasonCode, bsnAPAuthorizationFailureCause bsnAPIfUpDownCause Added:- bsnRogueAPDetectingAPRadioType, bsnRogueAPDetectingAPMacAddress, bsnRogueAPMaxRssiRadioType, bsnRogueAPClassType, bsnRogueAPChannel, bsnRogueAPDetectingAPName, bsnRogueAPChannelWidth, bsnAPIfRxNeighborChannel, bsnAPIfRxNeighborChannelWidth, bsnStandardSignatureInterval, bsnCustomSignatureInterval, bsnImpersonatingSourceMacAddr, bsnAPPreviousChannelNumberTrapVariable, bsnAPReasonCodeTrapVariable, bsnNoiseBeforeChannelUpdate, bsnNoiseAfterChannelUpdate, bsnInterferenceBeforeChannelUpdate, bsnInterferenceAfterChannelUpdate, bsnPingTestMaxTimeInterval, bsnPingTestMinTimeInterval, bsnPingTestAvgTimeInterval, bsnDot11StationDisassociate, bsnDot11StationDeauthenticate, bsnDot11StationAuthenticateFail, bsnDot11StationAssociateFail, bsnAPIfUp, bsnAPIfDown, bsnAPLoadProfileFailed, bsnAPNoiseProfileFailed, bsnAPInterferenceProfileFailed, bsnAPCoverageProfileFailed, bsnAPCurrentTxPowerChanged, bsnAPCurrentChannelChanged, bsnRogueAPDetected, bsnAPLoadProfileUpdatedToPass, bsnAPNoiseProfileUpdatedToPass, bsnAPInterferenceProfileUpdatedToPass, bsnAPCoverageProfileUpdatedToPass, bsnApMaxRogueCountExceeded, bsnApMaxRogueCountClear, bsnDot11StationBlacklisted, bsnDot11StationAssociate, bsnApBigNavDosAttack, bsnWpaMicErrorCounterActivated, bsnRogueAPDetectedOnWiredNetwork, bsnApHasNoRadioCards, bsnDuplicateIpAddressReported, bsnAPContainedAsARogue, bsnAPRadioCardTxFailure, bsnAPRadioCardTxFailureClear, bsnAPRadioCardRxFailure, bsnAPRadioCardRxFailureClear, bsnAPImpersonationDetected, bsnAPIPAddressFallback, bsnRadarChannelDetected, bsnRadarChannelCleared, radioCoreDumpTrap, invalidRadioTrap, bsnEssGroup1, bsnGlobalDot11Group1, bsnAAAGroup1, bsnTrapsGroupRev1, bsnWrasObsGroup1, bsnWrasTrapRev1, bsnApGroupRev1, bsnUtilityGroupRev1, bsnWrasComplianceRev1 Obsoleted:- bsnMobileStationExtStatsTable, bsnSystemTimezoneDaylightSavings, bsnAPUp, bsnAPDown, bsnWrasObsTrap, bsnWrasTrap, Deprecated:- bsnGlobalDot11CountryIndex, bsnGlobalDot11LoadBalancing, bsnGlobalDot11bMaximumTransmitPowerLevel, bsnGlobalDot11bFirstChannelNumber, bsnGlobalDot11bNumberofChannels, bsnGlobalDot11aMaximumTransmitPowerLevel, bsnGlobalDot11aFirstChannelNumber, bsnGlobalDot11aNumberofChannels, bsnRadiusAuthCacheCredentialsLocally, bsnAPGroupsVlanMappingTable, bsnAPAssociated, bsnAPRegulatoryDomainMismatch, countryChangeTrap, bsnEssGroup, bsnApGroup, bsnGlobalDot11Group, bsnAAAGroup, bsnTrapsGroup, bsnUtilityGroup, bsnWrasCompliance', 'Updated MIB with description and format', 'Airespace MIB',))
if mibBuilder.loadTexts: bsnWireless.setLastUpdated('201109270000Z')
if mibBuilder.loadTexts: bsnWireless.setOrganization('Airespace, Inc.')
if mibBuilder.loadTexts: bsnWireless.setContactInfo(' Cisco Systems, Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS Email: cs-wnbu-snmp@cisco.com')
if mibBuilder.loadTexts: bsnWireless.setDescription("This MIB is intended to be implemented on all those devices operating as Central Controllers (CC) that terminate the Light Weight Access Point Protocol tunnel from Light-weight LWAPP Access Points. This MIB provides configuration and status information for 802.11 Access Points, LAN configuration, AAA, Mobility, IpSec, Radio Rescouce Management and 802.11 global parameters. The relationship between controller and the LWAPP APs can be depicted as follows: +......+ +......+ +......+ +......+ + + + + + + + + + CC + + CC + + CC + + CC + + + + + + + + + +......+ +......+ +......+ +......+ .. . . . .. . . . . . . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ +......+ + + + + + + + + + + + AP + + AP + + AP + + AP + + AP + + + + + + + + + + + +......+ +......+ +......+ +......+ +......+ . . . . . . . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ +......+ + + + + + + + + + + + MN + + MN + + MN + + MN + + MN + + + + + + + + + + + +......+ +......+ +......+ +......+ +......+ The LWAPP tunnel exists between the controller and the APs. The MNs communicate with the APs through the protocol defined by the 802.11 standard. LWAPP APs, upon bootup, discover and join one of the controllers and the controller pushes the configuration, that includes the WLAN parameters, to the LWAPP APs. The APs then encapsulate all the 802.11 frames from wireless clients inside LWAPP frames and forward the LWAPP frames to the controller. GLOSSARY Access Point ( AP ) An entity that contains an 802.11 medium access control ( MAC ) and physical layer ( PHY ) interface and provides access to the distribution services via the wireless medium for associated clients. LWAPP APs encapsulate all the 802.11 frames in LWAPP frames and sends it to the controller to which it is logically connected. Basic Service Set Identifier (BSSID) The identifier for the service set comprising of all the 802.11 stations under the control of one coordinating Access Point. This identifier happens to be the MAC address of the dot11 radio interface of the Access Point. The wireless clients that associate with the Access Point get the wired uplink through this particular dot11 interface. Central Controller ( CC ) The central entity that terminates the LWAPP protocol tunnel from the LWAPP APs. Throughout this MIB, this entity also referred to as 'controller'. Light Weight Access Point Protocol ( LWAPP ) This is a generic protocol that defines the communication between the Access Points and the Central Controller. Mobile Node ( MN ) A roaming 802.11 wireless device in a wireless network associated with an access point. Station Management (SMT) This term refers to the internal management of the 802.11 protocol operations by the AP to work cooperatively with the other APs and 802.11 devices in the network. REFERENCE [1] Part 11 Wireless LAN Medium Access Control ( MAC ) and Physical Layer ( PHY ) Specifications. [2] Draft-obara-capwap-lwapp-00.txt, IETF Light Weight Access Point Protocol. ")
bsnEss = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 1))
bsnAP = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 2))
bsnGlobalDot11 = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3))
bsnRrm = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4))
bsnAAA = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 5))
bsnTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 6))
bsnUtility = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 7))
bsnMobility = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 8))
bsnIpsec = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 9))
bsnWrasGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 50))
bsnWrasCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 51))
class WEPKeytype(TextualConvention, OctetString):
    description = 'This object indicates the WEP Key type.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 32)

class ProfileState(TextualConvention, Integer32):
    description = 'This object indicates the profile state.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("fail", 0), ("pass", 1))

class BsnTxtSignatureMacInfo(TextualConvention, Integer32):
    description = "This textual convention defines the pattern followed by the LWAPP APs to perform signature analysis with the signature and report the results to the Controller. The semantics are described as follows. bsnSignatureMacAll - The Controller would set the 'Mac Info' parameter of the 'Signature Add LWAPP Message' to this value to indicate the LWAPP AP that the signature analysis and pattern matching should be tracked and reported on a per-signature and per-channel basis. bsnSignatureMacIndividual - The Controller would set the 'Mac Info' parameter of the 'Signature Add LWAPP Message' to this value to indicate the LWAPP AP that the signature analysis and pattern matching should be tracked and reported separately for individual MAC addresses, that are the sources of the received 802.11 data and/or management frames. bsnStandardSigMacBoth - The Controller would set the 'Mac Info' parameter of the 'Signature Add LWAPP Message' to this value to indicate the LWAPP AP that the signature analysis and pattern matching should be tracked on a per signature as well as per-MAC address basis. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("bsnSignatureMacAll", 0), ("bsnSignatureMacIndividual", 1), ("bsnSignatureMacBoth", 2))

class BsnSignaturePatternOffSetStart(TextualConvention, Integer32):
    description = 'This object indicates how an offset should be applied while doing signature analysis for QOS and non-QOS data frames. This is introduced since 802.11e QOS frames have an additional 2-byte QOS header which results in the current implementation not being able to find the start of the date frames for signature analysis. The semantics of the values are as follows. sigPattStartFrm - This indicates that the required offset should be applied to the start of the data frame, before performing pattern matching of the signature on the data frame. sigPattStartFrmBody - This value indicates that the required offset should be applied to the start of the frame body, after the header, before performing pattern matching of the signature on the data frame. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("sigPattStartFrm", 0), ("sigPattStartFrmBody", 1))

bsnDot11EssTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1), )
if mibBuilder.loadTexts: bsnDot11EssTable.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssTable.setDescription('Ess(WLAN) Configuration Table indexed by bsnDot11EssIndex. Maximum of 17 WLANs can be created on Airespace Switch. bsnDot11EssIndex of 17 is reserved for WLAN for Third Party APs(non-Airespace APs).')
bsnDot11EssEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"))
if mibBuilder.loadTexts: bsnDot11EssEntry.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssEntry.setDescription('An entry in bsnDot11EssTable')
bsnDot11EssIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 517))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssIndex.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssIndex.setDescription('Index of the Ess(WLAN) within Airespace Switch. Airespace Switch supports 517 ESS(Wlans) so index will be from 1 to 517. 517 is to be used for ESS(WLAN) created for support of Third Party APs(non-Airespace APs)')
bsnDot11EssSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssSsid.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssSsid.setDescription('SSID assigned to ESS(WLAN)')
bsnDot11EssSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssSessionTimeout.setDescription('Maximum time of a Mobile Station session. Value of 0 means infinite time(no timeout set).')
bsnDot11EssMacFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssMacFiltering.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssMacFiltering.setDescription('A type of security policy for Mobile Stations (Clients). Select to filter clients by MAC address. By selecting this Security, you need to create MacFilters in bsnUsersTable or have MacFilters configured on Radius Servers specified in bsnRadiusAuthenticationTable')
bsnDot11EssAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssAdminStatus.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssAdminStatus.setDescription('Administrative Status of ESS(WLAN). By disabling an ESS the corresponding SSID is no longer broadcasted in AP beacons.')
bsnDot11EssSecurityAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 128))).clone(namedValues=NamedValues(("authOpen", 0), ("authSharedKey", 1), ("authCiscoLeap", 128))).clone('authOpen')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnDot11EssSecurityAuthType.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssSecurityAuthType.setDescription('Type of 802.11 Authentication.')
bsnDot11EssStaticWEPSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssStaticWEPSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssStaticWEPSecurity.setDescription('Status of Static WEP Security policy. If enabled, WEP Encryption WEP Default Key, Key Index and Key Format should also be specified.')
bsnDot11EssStaticWEPEncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))).clone(namedValues=NamedValues(("wep104", 0), ("wep40", 2), ("wep128", 3), ("notset", 4))).clone('wep104')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssStaticWEPEncryptionType.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssStaticWEPEncryptionType.setDescription('Type of Static WEP Encryption. Length of key specified in Default Key depends on this attribute.')
bsnDot11EssStaticWEPDefaultKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 10), WEPKeytype()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssStaticWEPDefaultKey.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssStaticWEPDefaultKey.setDescription('Static WEP Default Key. For wep104 encryption either 26 bit hex key or 13 bit ascii key should be specified. For wep40 encryption 10 bit hex key or 5 bit ascii key should be specified. For wep128 encryption 32 bit hex key or 16 bit ascii key should be specified.')
bsnDot11EssStaticWEPKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssStaticWEPKeyIndex.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssStaticWEPKeyIndex.setDescription('According to 802.11 standard 4 keys are supported. So 802.11 Mobile Stations(Client) can have upto 4 keys. This index is for informing Mobile Station which key it should use for Static WEP Authentication')
bsnDot11EssStaticWEPKeyFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2), ("default", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssStaticWEPKeyFormat.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssStaticWEPKeyFormat.setDescription('This is not persistant.Reading this attribute will always return default. The format of the key specified in Airespace switch keeps record of the Index.')
bsnDot11Ess8021xSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11Ess8021xSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11Ess8021xSecurity.setDescription('Status of 802.1X security policy.')
bsnDot11Ess8021xEncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))).clone(namedValues=NamedValues(("wep104", 0), ("wep40", 2), ("wep128", 3), ("none", 4))).clone('wep104')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11Ess8021xEncryptionType.setStatus('current')
if mibBuilder.loadTexts: bsnDot11Ess8021xEncryptionType.setDescription('Type of 802.1X Encryption. This applies if bsnDot11Ess8021xSecurity is in enabled state.')
bsnDot11EssWPASecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWPASecurity.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssWPASecurity.setDescription('Status of WPA security policy. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssWPAEncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 5))).clone(namedValues=NamedValues(("wep104", 0), ("wep40", 2), ("wep128", 3), ("tkipmic", 5))).clone('tkipmic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWPAEncryptionType.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssWPAEncryptionType.setDescription('Type of WPA Encryption. This applies when bsnDot11EssWPASecurity is in enable state. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssIpsecSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssIpsecSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssIpsecSecurity.setDescription('Status of IpSec (VPN) security policy. Note that this cannot be applied with Web security policy.')
bsnDot11EssVpnEncrTransform = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("tripleDes", 0), ("none", 1), ("des", 2), ("aesCbc", 3), ("aes256Cbc", 4))).clone('tripleDes')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnEncrTransform.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnEncrTransform.setDescription('The Encryption algorithm employed by this Vpn(IpSec) Encryption. This applies only when bsnDot11EssIpsecSecurity is in enable state.')
bsnDot11EssVpnAuthTransform = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("none", 1), ("hmacMd5", 2), ("hmacSha1", 0))).clone('hmacSha1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnAuthTransform.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnAuthTransform.setDescription('The Hash algorithm employed by the Vpn Encrpytion. This applies only when bsnDot11EssIpsecSecurity is in enable state.')
bsnDot11EssVpnIkeAuthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("xauthEnablePsk", 0), ("certificate", 2), ("presharedKey", 3))).clone('presharedKey')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnIkeAuthMode.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnIkeAuthMode.setDescription('The authentication type of the SA. It could be a certificate or a pre-shared key or xauthEnablePsk. This applies only when bsnDot11EssIpsecSecurity is in enable state.')
bsnDot11EssVpnSharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnSharedKey.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnSharedKey.setDescription('VPN Shared Key. This applies only when bsnDot11EssVpnSharedKey is in enable state and bsnDot11EssVpnIkeAuthMode is xauthEnablePsk or presharedKey.')
bsnDot11EssVpnSharedKeySize = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnDot11EssVpnSharedKeySize.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnSharedKeySize.setDescription('VPN Shared Key size. This applies only when bsnDot11EssVpnSharedKey is in enable state and bsnDot11EssVpnIkeAuthMode is xauthEnablePsk or presharedKey.')
bsnDot11EssVpnIkePhase1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("agressive", 0), ("main", 1))).clone('main')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnIkePhase1Mode.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnIkePhase1Mode.setDescription('VPN IKE Phase 1 Mode type as per the IpSec standards. This applies only when bsnDot11EssIpsecSecurity is in enable state.')
bsnDot11EssVpnIkeLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1800, 345600)).clone(57600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnIkeLifetime.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnIkeLifetime.setDescription("Vpn IKE's Lifetime. This applies only when bsnDot11EssIpsecSecurity is in enable state.")
bsnDot11EssVpnIkeDHGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 14))).clone(namedValues=NamedValues(("group2", 0), ("group1", 1), ("group5", 4), ("group14", 14))).clone('group2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnIkeDHGroup.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnIkeDHGroup.setDescription("IKE's Diffie-Hellman Group. This applies only when bsnDot11EssIpsecSecurity is in enable state.")
bsnDot11EssIpsecPassthruSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssIpsecPassthruSecurity.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssIpsecPassthruSecurity.setDescription('Status of IpSec Passthru security policy.')
bsnDot11EssVpnPassthruGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 28), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnPassthruGateway.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssVpnPassthruGateway.setDescription('Ip address of VpnPassthru Gateway. This applies only when bsnDot11EssIpsecPassthruSecurity is in enable state.')
bsnDot11EssWebSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWebSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssWebSecurity.setDescription('Status of Web security policy. Note this policy cannot be applied with IpSec security policy.')
bsnDot11EssRadioPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("all", 0), ("dot11aOnly", 2), ("dot11bOnly", 1), ("dot11gOnly", 3), ("dot11bgOnly", 4), ("dot11agOnly", 5), ("dot11abOnly", 6))).clone('all')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadioPolicy.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadioPolicy.setDescription('Radio Policy for a WLAN. It can either be All where it will be applicable to ALL types of protocols or it can be set to apply to combinations of 802.11a, 802.11b, 802.11g.')
bsnDot11EssQualityOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("bronze", 0), ("silver", 1), ("gold", 2), ("platinum", 3))).clone('bronze')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssQualityOfService.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssQualityOfService.setDescription('Quality of Service for a WLAN.Services such as VoIP should be set to Gold while non-discriminating services such as messaging can be set to Bronze.')
bsnDot11EssDhcpRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssDhcpRequired.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssDhcpRequired.setDescription('DHCP required for all clients on this WLAN')
bsnDot11EssDhcpServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 33), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssDhcpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssDhcpServerIpAddress.setDescription('IP Address of the DHCP Server. Make it 0.0.0.0 to disable DHCP Relay. Any value other than 0.0.0.0, it will be assumed that DHCP Relay is turned on.')
bsnDot11EssVpnContivityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnContivityMode.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssVpnContivityMode.setDescription("Specifies if contivity mode for the IpSec is enabled. If enabled, user needs to specify the Quote of the Day Server's IPAddress in bsnDot11EssVpnQotdServerAddress.")
bsnDot11EssVpnQotdServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 35), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssVpnQotdServerAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssVpnQotdServerAddress.setDescription('IP Address of the Quote of the Day Server.')
bsnDot11EssBlacklistTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssBlacklistTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssBlacklistTimeout.setDescription('Set the timeout for blacklisted Mobile Stations after which the mobile station will be automatically de-authenticated. Mobile Station are blacklisted by MAC address and their status can be obtained from bsnMobileStationStatus. A timeout setting of 0 indicates no blacklist timeout is set and administrative control (bsnMobileStationDeleteAction ) is required to deauthenticate the station.')
bsnDot11EssNumberOfMobileStations = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnDot11EssNumberOfMobileStations.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssNumberOfMobileStations.setDescription('No of Mobile Stations currently associated with the WLAN.')
bsnDot11EssWebPassthru = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWebPassthru.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssWebPassthru.setDescription("For switches with version before 2.0: This is applicable only when the Web Security Type is enabled. When this attribute is enabled, it allows a client's NetBIOS packets to go through the switch before web auth is completed. (This is obsolete for Switch versions 2.0 to 2.2). For switch verions 3.0 and above: This is reintroduced as the web policy where the client is connected through the web without authentication that is there is no username/password input required. Moreover, if the bsnDot11EssWebPassthroughEmail is enabled, the user will be asked to enter an email address.")
bsnDot11EssCraniteSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssCraniteSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssCraniteSecurity.setDescription('Status of Cranite Passthrough Security policy. If enabled, no other security can be enabled.')
bsnDot11EssBlacklistingCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssBlacklistingCapability.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssBlacklistingCapability.setDescription('This is the flag that can enable or disable the client backlisting feature for a WLAN. If enabled, the clients can be blacklisted by the Switch in case of repetitive auth failure and other reasons like it. If disabled, the clients cannot be blacklisted by the switch. The blacklist timeout value will only be effective if this feature is turned on.')
bsnDot11EssInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssInterfaceName.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssInterfaceName.setDescription('Name of the interface used by this WLAN. By default it is set to be the management interface.')
bsnDot11EssAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssAclName.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssAclName.setDescription('Name of ACL for the WLAN. This is applicable only when Web Authentication is enabled as a security. An empty string value indicates that no ACL has been set (which is a valid option)')
bsnDot11EssAAAOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssAAAOverride.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssAAAOverride.setDescription('Enable or Disable AAA override for the global WLAN parameters.')
bsnDot11EssWPAAuthKeyMgmtMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWPAAuthKeyMgmtMode.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssWPAAuthKeyMgmtMode.setDescription('Enable or Disable WPA Pre-shared Key Mode. If enabled, a preshared key should be set for WPA authentication. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssWPAAuthPresharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 46), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWPAAuthPresharedKey.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssWPAAuthPresharedKey.setDescription('WPA Authentication Preshared Key. This applies only when bsnDot11EssWPAAuthKeyMgmtMode is in enable state. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssWepAllowSharedKeyAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWepAllowSharedKeyAuth.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssWepAllowSharedKeyAuth.setDescription('Enable this flag to allow Shared Key Authentication when Static WEP is enabled.')
bsnDot11EssFortressSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssFortressSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssFortressSecurity.setDescription('Status of Fortress Passthrough Security policy. If enabled, no other security can be enabled.')
bsnDot11EssL2tpSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssL2tpSecurity.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssL2tpSecurity.setDescription('Status of L2TP security policy. Note that this cannot be applied with Web security policy, Cranite or Fortress policy.')
bsnDot11EssWPAAuthPresharedKeyHex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 50), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWPAAuthPresharedKeyHex.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssWPAAuthPresharedKeyHex.setDescription('WPA Authentication Preshared Key in the hex format. This applies only when bsnDot11EssWPAAuthKeyMgmtMode is in enable state. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssBroadcastSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssBroadcastSsid.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssBroadcastSsid.setDescription('This attribute when enabled allows the switch to broadcast this SSID.')
bsnDot11EssExternalPolicyValidation = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssExternalPolicyValidation.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssExternalPolicyValidation.setDescription('This attribute specifies if external policy servers will be used for validation. If no servers are configured in bsnExternalPolicyServerTable then it cannot be enabled.')
bsnDot11EssRSNSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNSecurity.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNSecurity.setDescription('This attribute specifies status of RSN Security Policy. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssRSNWPACompatibilityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNWPACompatibilityMode.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNWPACompatibilityMode.setDescription("This attribute specifies RSN security's compatibility mode with WPA. This has been deprecated for cLWSecDot11EssCckmTable.")
bsnDot11EssRSNAllowTKIPClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("yes", 1), ("no", 0))).clone('no')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNAllowTKIPClients.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNAllowTKIPClients.setDescription('This attribute specifies whether TKIP clients are allowed by RSN Policy. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssRSNAuthKeyMgmtMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNAuthKeyMgmtMode.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNAuthKeyMgmtMode.setDescription('This attribute specifies whether Preshared key is used or not. If used user should specify a key between 8 and 63 characters in bsnDot11EssRSNAuthPresharedKey attribute. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssRSNAuthPresharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 57), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNAuthPresharedKey.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNAuthPresharedKey.setDescription('RSN Authentication Preshared Key. This applies only when bsnDot11EssRSNAuthKeyMgmtMode is in enable state. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssRSNAuthPresharedKeyHex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 58), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRSNAuthPresharedKeyHex.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssRSNAuthPresharedKeyHex.setDescription('RSN Authentication Preshared Key in the hex format. This applies only when bsnDot11EssWPAAuthKeyMgmtMode is in enable state. This has been deprecated for cLWSecDot11EssCckmTable.')
bsnDot11EssIPv6Bridging = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssIPv6Bridging.setStatus('deprecated')
if mibBuilder.loadTexts: bsnDot11EssIPv6Bridging.setDescription('When enabled, IPv6 bridging is applied on the packets.')
bsnDot11EssRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 60), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRowStatus.setDescription('A row status type for the bsnDot11EssEntry')
bsnDot11EssWmePolicySetting = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("allowed", 1), ("required", 2), ("invalid", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWmePolicySetting.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssWmePolicySetting.setDescription('When enabled, WME Policy is applied on the packets.')
bsnDot11Ess80211ePolicySetting = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("allowed", 1), ("required", 2), ("invalid", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11Ess80211ePolicySetting.setStatus('current')
if mibBuilder.loadTexts: bsnDot11Ess80211ePolicySetting.setDescription('When enabled, 802.11e Policy is applied on the packets.')
bsnDot11EssWebPassthroughEmail = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssWebPassthroughEmail.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssWebPassthroughEmail.setDescription('When enabled, along with the bsnDot11EssWebPassthru attribute, the client is allowed to connect by entering his/her email address on the web connection page. There is no further authentication required.')
bsnDot11Ess7920PhoneSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("clientCacLimit", 1), ("apCacLimit", 2), ("both", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11Ess7920PhoneSupport.setStatus('current')
if mibBuilder.loadTexts: bsnDot11Ess7920PhoneSupport.setDescription('When client cac limit is enabled, the 7920 Phones with old software where the Call Admission Control (CAC) Limit is Specified on the client will be supported on the WLAN. The support for clientCacLimit (by setting to value 1 or 3) cannot be enabled when the bsnDot11EssWmePolicySetting is set to allowed or required. When ap cac limit is enabled, the 7920 Phones with new software where the Call Admission Control (CAC) Limit is advertised by the AP, will be supported on the WLAN.')
bsnDot11EssRadiusAuthPrimaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 95), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthPrimaryServer.setDescription('Primary Radius Authentication Server for this wlan.')
bsnDot11EssRadiusAuthSecondaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 96), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthSecondaryServer.setDescription('Secondary Radius Authentication Server for this wlan.')
bsnDot11EssRadiusAuthTertiaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 97), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthTertiaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAuthTertiaryServer.setDescription('Tertiary Radius Authentication Server for this wlan.')
bsnDot11EssRadiusAcctPrimaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 98), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctPrimaryServer.setDescription('Primary Radius Accounting Server for this wlan.')
bsnDot11EssRadiusAcctSecondaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 99), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctSecondaryServer.setDescription('Secondary Radius Accounting Server for this wlan.')
bsnDot11EssRadiusAcctTertiaryServer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 1, 1, 100), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctTertiaryServer.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssRadiusAcctTertiaryServer.setDescription('Tertiary Radius Accounting Server for this wlan.')
bsnDot11QosProfileTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17), )
if mibBuilder.loadTexts: bsnDot11QosProfileTable.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosProfileTable.setDescription('QOS Profiles specified in bsnDot11EssTable can be customized in this table. This is a lookup table for auto created profiles')
bsnDot11QosProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileName"))
if mibBuilder.loadTexts: bsnDot11QosProfileEntry.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosProfileEntry.setDescription('An entry in bsnDot11QosProfileTable.')
bsnDot11QosProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnDot11QosProfileName.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosProfileName.setDescription('QOS Profile Name. This will be one of bronze,gold, platinum,silver,uranium.')
bsnDot11QosProfileDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosProfileDesc.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosProfileDesc.setDescription('QOS Profile Description.')
bsnDot11QosAverageDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosAverageDataRate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosAverageDataRate.setDescription('This is one of the per user bandwidth contracts(k). Specifies Average Data Rate per user. Value of 0 indicates the feature is disabled.')
bsnDot11QosBurstDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosBurstDataRate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosBurstDataRate.setDescription('This is one of the per user bandwidth contracts(k). Specifies Average Burst Data Rate per user. Value of 0 indicates the feature is disabled.')
bsnDot11QosAvgRealTimeDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosAvgRealTimeDataRate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosAvgRealTimeDataRate.setDescription('This is one of the per user bandwidth contracts(k). Specifies Average Real Time Data Rate per user. Value of 0 indicates the feature is disabled.')
bsnDot11QosBurstRealTimeDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosBurstRealTimeDataRate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosBurstRealTimeDataRate.setDescription('This is one of the per user bandwidth contracts(k). Specifies Burst Real Time Data Rate per user. Value of 0 indicates the feature is disabled.')
bsnDot11QosMaxRFUsagePerAP = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosMaxRFUsagePerAP.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosMaxRFUsagePerAP.setDescription('This is one of the over the Air QOS parameter. Specifies maximum RF Usage per AP in percentage.')
bsnDot11QosProfileQueueDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11QosProfileQueueDepth.setStatus('current')
if mibBuilder.loadTexts: bsnDot11QosProfileQueueDepth.setDescription('This is one of the over the Air QOS parameter. Specifies Queue depth for the current profile.')
bsnDot11WiredQosProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("dot1p", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11WiredQosProtocol.setStatus('current')
if mibBuilder.loadTexts: bsnDot11WiredQosProtocol.setDescription('This is one of the over the Air QOS parameter. Specifies Queue depth for the current profile.')
bsnDot11802Dot1PTag = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11802Dot1PTag.setStatus('current')
if mibBuilder.loadTexts: bsnDot11802Dot1PTag.setDescription('Specifies the type of wired QOS protocol for the current profile. Value of 0 indicates the feature is disabled.')
bsnDot11ResetProfileToDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 17, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("reset", 1), ("default", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11ResetProfileToDefault.setStatus('current')
if mibBuilder.loadTexts: bsnDot11ResetProfileToDefault.setDescription('Set this attribute to reset to restore the factory default value for the profile.')
bsnMobileStationTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4), )
if mibBuilder.loadTexts: bsnMobileStationTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationTable.setDescription('Mobile Station Table indexed by bsnMobileStationMacAddress. (Mobile Station is better referred to as Client in the current releases.)')
bsnMobileStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"))
if mibBuilder.loadTexts: bsnMobileStationEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationEntry.setDescription('An entry in bsnMobileStationTable.')
bsnMobileStationMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationMacAddress.setDescription('802.11 MAC Address of the Mobile Station.')
bsnMobileStationIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationIpAddress.setDescription('IP Address of the Mobile Station')
bsnMobileStationUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationUserName.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationUserName.setDescription('User Name,if any, of the Mobile Station. This would be non empty in case of Web Authentication and IPSec.')
bsnMobileStationAPMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationAPMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationAPMacAddr.setDescription('802.11 Mac Address of the AP to which the Mobile Station is associated.')
bsnMobileStationAPIfSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationAPIfSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationAPIfSlotId.setDescription('Slot ID of AP Interface to which the mobile station is associated. The value 15 is used to indicate that the slot Id is invalid.')
bsnMobileStationEssIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationEssIndex.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationEssIndex.setDescription('Ess Index of the Wlan(SSID) that is being used by Mobile Station to connect to AP')
bsnMobileStationSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationSsid.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationSsid.setDescription(' The SSID Advertised by Mobile Station')
bsnMobileStationAID = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationAID.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationAID.setDescription('AID for the mobile station')
bsnMobileStationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("idle", 0), ("aaaPending", 1), ("authenticated", 2), ("associated", 3), ("powersave", 4), ("disassociated", 5), ("tobedeleted", 6), ("probing", 7), ("blacklisted", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationStatus.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationStatus.setDescription('Status of the mobile station')
bsnMobileStationReasonCode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 40, 41, 42, 43, 44, 45, 46, 99, 101, 105, 106, 200, 201, 202, 203))).clone(namedValues=NamedValues(("unspecified", 1), ("previousAuthNotValid", 2), ("deauthenticationLeaving", 3), ("disassociationDueToInactivity", 4), ("disassociationAPBusy", 5), ("class2FrameFromNonAuthStation", 6), ("class2FrameFromNonAssStation", 7), ("disassociationStaHasLeft", 8), ("staReqAssociationWithoutAuth", 9), ("invalidInformationElement", 40), ("groupCipherInvalid", 41), ("unicastCipherInvalid", 42), ("akmpInvalid", 43), ("unsupportedRsnVersion", 44), ("invalidRsnIeCapabilities", 45), ("cipherSuiteRejected", 46), ("missingReasonCode", 99), ("maxAssociatedClientsReached", 101), ("maxAssociatedClientsReachedOnRadio", 105), ("maxAssociatedClientsReachedOnWlan", 106), ("unSpecifiedQosFailure", 200), ("qosPolicyMismatch", 201), ("inSufficientBandwidth", 202), ("inValidQosParams", 203)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationReasonCode.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationReasonCode.setDescription(' Reason Code as defined by 802.11 standards')
bsnMobileStationMobilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unassociated", 0), ("local", 1), ("anchor", 2), ("foreign", 3), ("handoff", 4), ("unknown", 5), ("exportanchor", 6), ("exportforeign", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationMobilityStatus.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationMobilityStatus.setDescription('Mobility Role of the Mobile Station.')
bsnMobileStationAnchorAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationAnchorAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationAnchorAddress.setDescription('If the Mobility Status of the Mobile Station is Anchor then it will have Peer Ip Address and will have Anchor IP if the Role is Foreign')
bsnMobileStationCFPollable = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationCFPollable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationCFPollable.setDescription('When this attribute is true, it shall indicate that the Mobile Station is able to respond to a CF-Poll with a data frame within a SIFS time. This attribute shall be false if the Mobile Station is not able to respond to a CF-Poll with a data frame within a SIFS time.')
bsnMobileStationCFPollRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationCFPollRequest.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationCFPollRequest.setDescription('Specifies whether CFP is requested by Mobile Station or not')
bsnMobileStationChannelAgilityEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationChannelAgilityEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationChannelAgilityEnabled.setDescription('This attribute indicates that the PHY channel agility functionality is enabled.')
bsnMobileStationPBCCOptionImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPBCCOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPBCCOptionImplemented.setDescription('This attribute, when true, shall indicate that the PBCC modulation option as defined in subclause 18.4.6.6 is implemented. The default value of this attribute shall be false.')
bsnMobileStationShortPreambleOptionImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationShortPreambleOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationShortPreambleOptionImplemented.setDescription('This attribute, when true, shall indicate that the short preamble option as defined in subclause 18.2.2.2 is implemented. The default value of this attribute shall be false.')
bsnMobileStationSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationSessionTimeout.setDescription(' Session Timeout of Mobile station')
bsnMobileStationAuthenticationAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 128))).clone(namedValues=NamedValues(("openSystem", 0), ("sharedKey", 1), ("unknown", 2), ("openAndEap", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationAuthenticationAlgorithm.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationAuthenticationAlgorithm.setDescription('Authentication Algorithm of Mobile Station ')
bsnMobileStationWepState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationWepState.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationWepState.setDescription('WEP State of Mobile Station')
bsnMobileStationPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPortNumber.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPortNumber.setDescription('The Port Number of this Airespace Switch on which the traffic of the Mobile Station is coming through.')
bsnMobileStationDeleteAction = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMobileStationDeleteAction.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationDeleteAction.setDescription('Action to Deauthenticate the Mobile Station. Set the State to delete.')
bsnMobileStationPolicyManagerState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPolicyManagerState.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPolicyManagerState.setDescription('Policy Manager State of the mobile station.')
bsnMobileStationSecurityPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("completed", 0), ("notcompleted", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationSecurityPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationSecurityPolicyStatus.setDescription('When this attribute has value completed, it shall indicate that the Mobile Station has completed the security policy checks. Otherwise the checks are yet to be completed.')
bsnMobileStationProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("dot11a", 1), ("dot11b", 2), ("dot11g", 3), ("unknown", 4), ("mobile", 5), ("dot11n24", 6), ("dot11n5", 7), ("ethernet", 8), ("dot3", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationProtocol.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationProtocol.setDescription("The 802.11 protocol type of the client. The protocol is mobile when this client detail is seen on the anchor i.e it's mobility status is anchor.")
bsnMobileStationMirrorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMobileStationMirrorMode.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationMirrorMode.setDescription('If enabled, then mirroring for this client will be statically configured irrespective of the AP and the port this client is on.')
bsnMobileStationInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationInterface.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationInterface.setDescription('Name of the Interface of the mobile client to the switch.')
bsnMobileStationApMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("local", 0), ("monitor", 1), ("remote", 2), ("roguedetector", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationApMode.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationApMode.setDescription('Mode of the AP to which the Mobile Station is associated.')
bsnMobileStationVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationVlanId.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationVlanId.setDescription('Vlan ID of the Interface to which the client is associated.')
bsnMobileStationPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("dot1x", 0), ("wpa1", 1), ("wpa2", 2), ("wpa2vff", 3), ("notavailable", 4), ("unknown", 5), ("wapi", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPolicyType.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPolicyType.setDescription('Mode of the AP to which the Mobile Station is associated.')
bsnMobileStationEncryptionCypher = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ccmpAes", 0), ("tkipMic", 1), ("wep40", 2), ("wep104", 3), ("wep128", 4), ("none", 5), ("notavailable", 6), ("unknown", 7), ("wapiSMS4", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationEncryptionCypher.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationEncryptionCypher.setDescription('Mode of the AP to which the Mobile Station is associated.')
bsnMobileStationEapType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("eapTls", 0), ("ttls", 1), ("peap", 2), ("leap", 3), ("speke", 4), ("eapFast", 5), ("notavailable", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationEapType.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationEapType.setDescription('Mode of the AP to which the Mobile Station is associated.')
bsnMobileStationCcxVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 0), ("ccxv1", 1), ("ccxv2", 2), ("ccxv3", 3), ("ccxv4", 4), ("ccxv5", 5), ("ccxv6", 6))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationCcxVersion.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationCcxVersion.setDescription('Represents the Cisco Compatible Extensions (CCX) Version the client is using for communication with the AP.')
bsnMobileStationE2eVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notSupported", 0), ("e2ev1", 1), ("e2ev2", 2))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationE2eVersion.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationE2eVersion.setDescription('Represents the End-2-End Version the client is using for communication with the AP.')
bsnMobileStationStatusCode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 4, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationStatusCode.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationStatusCode.setDescription(' Status Code of the Mobile Station')
bsnMobileStationByIpTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 10), )
if mibBuilder.loadTexts: bsnMobileStationByIpTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByIpTable.setDescription("Mobile Station Table indexed by bsnMobileStationByIpAddress. NOTE: This is just to facilitate the search of mobile stations based on IP Address. Doing a get without the index doesn't return anything. (Mobile Station is better referred to as Client in the current releases.)")
bsnMobileStationByIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 10, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationByIpAddress"))
if mibBuilder.loadTexts: bsnMobileStationByIpEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByIpEntry.setDescription('An entry in bsnMobileStationByIpTable.')
bsnMobileStationByIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationByIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByIpAddress.setDescription('IP Address of the Mobile Station')
bsnMobileStationByIpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 10, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationByIpMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByIpMacAddress.setDescription('802.11 Mac Address of the Mobile Station.')
bsnMobileStationByUsernameTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 13), )
if mibBuilder.loadTexts: bsnMobileStationByUsernameTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByUsernameTable.setDescription("Mobile Station Table indexed by the Mobile Station Username and MAC Address. NOTE: This is just to facilitate the search of mobile stations based on User Name. Doing a get without the username doesn't return anything. (Mobile Station is better referred to as Client in the current releases.)")
bsnMobileStationByUsernameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 13, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserName"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserMacAddress"))
if mibBuilder.loadTexts: bsnMobileStationByUsernameEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByUsernameEntry.setDescription('An entry in bsnMobileStationByUsernameTable.')
bsnMobileStationByUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 13, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationByUserName.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByUserName.setDescription('Username of the Mobile Station')
bsnMobileStationByUserMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 13, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationByUserMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationByUserMacAddress.setDescription('802.11 Mac Address of the Mobile Station.')
bsnMobileStationPerRadioPerVapTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 5), )
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapTable.setDescription('Mobile Station Per Radio Per VAP(WLAN) Table. This table lists all Mobile Stations on a particular Airespace AP Interface for a particular ESS(Wlan). It only lists MAC Addresses. Further details for a Mobile Station can be found from bsnMobileStationTable once the MAC Address is knonwn. (Mobile Station is better referred to as Client in the current releases.)')
bsnMobileStationPerRadioPerVapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 5, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationPerRadioPerVapIndex"))
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapEntry.setDescription('An entry in MobileStationPerRadioPerVapTable.')
bsnMobileStationPerRadioPerVapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapIndex.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPerRadioPerVapIndex.setDescription(' The index of Mobile Station. The index starts from 1 and goes upto the total number of Mobile Stations on Airespace Radio Interface for a specific ESS (Wlan).')
bsnMobileStationMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 5, 1, 20), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationMacAddr.setDescription('The MAC Address of Mobile Station.')
bsnMobileStationStatsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6), )
if mibBuilder.loadTexts: bsnMobileStationStatsTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationStatsTable.setDescription('Mobile Station Statistics Table. (Mobile Station is better referred to as Client in the current releases.)')
bsnMobileStationStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"))
if mibBuilder.loadTexts: bsnMobileStationStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationStatsEntry.setDescription('An entry in bsnMobileStationStatsTable.')
bsnMobileStationRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRSSI.setDescription('Average packet RSSI for the Mobile Station.')
bsnMobileStationBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationBytesReceived.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationBytesReceived.setDescription('Bytes received from Mobile Station')
bsnMobileStationBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationBytesSent.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationBytesSent.setDescription('Bytes sent to Mobile Station')
bsnMobileStationPolicyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPolicyErrors.setDescription('Number of Policy Errors for Mobile Station')
bsnMobileStationPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPacketsReceived.setDescription('Packets received from Mobile Station')
bsnMobileStationPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationPacketsSent.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationPacketsSent.setDescription('Packets sent to Mobile Station')
bsnMobileStationSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 6, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationSnr.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationSnr.setDescription('Signal to noise Ratio of the Mobile Station.')
bsnMobileStationExtStatsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21), )
if mibBuilder.loadTexts: bsnMobileStationExtStatsTable.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationExtStatsTable.setDescription(' This table was supported only by indoor mesh AP -cisco 1000. As this AP is not supported after 4.2.x.x. This table has been marked obsolete. Mobile Station Extended Statistics Table. (Mobile Station is better referred to as Client in the current releases.)')
bsnMobileStationExtStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"))
if mibBuilder.loadTexts: bsnMobileStationExtStatsEntry.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationExtStatsEntry.setDescription('An entry in bsnMobileStationExtStatsTable. ')
bsnMobileStationSampleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationSampleTime.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationSampleTime.setDescription('Time stats were sampled as seconds since the epoch.')
bsnMobileStationTxExcessiveRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationTxExcessiveRetries.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationTxExcessiveRetries.setDescription('Tx packets dropped due to excessive retries.')
bsnMobileStationTxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationTxRetries.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationTxRetries.setDescription('Tx packets retransmitted.')
bsnMobileStationTxFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 21, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationTxFiltered.setStatus('obsolete')
if mibBuilder.loadTexts: bsnMobileStationTxFiltered.setDescription('Tx packets dropped by the built-in Tx filter')
bsnMobileStationRssiDataTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11), )
if mibBuilder.loadTexts: bsnMobileStationRssiDataTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataTable.setDescription('Mobile Station RSSI data Table indexed by bsnMobileStationMacAddress, bsnMobileStationRssiDataApMacAddress, bsnMobileStationRssiDataApIfSlotId. (Mobile Station is better referred to as Client in the current releases.)')
bsnMobileStationRssiDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApMacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaIndex"))
if mibBuilder.loadTexts: bsnMobileStationRssiDataEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataEntry.setDescription('An entry in bsnMobileStationRssiDataTable.')
bsnMobileStationRssiDataApMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiDataApMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataApMacAddress.setDescription('802.11 Mac Address of the AP on which Mobile Station is associated.')
bsnMobileStationRssiDataApIfSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiDataApIfSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataApIfSlotId.setDescription('SlotId of APIf on which mobile station is associated')
bsnMobileStationRssiDataApIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot11bg", 1), ("dot11a", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiDataApIfType.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataApIfType.setDescription(' The interface type of the radio that sensed the rssi data.')
bsnMobileStationRssiDataApName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiDataApName.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataApName.setDescription('The Name of the AP that sensed the rssi data.')
bsnMobileStationRssiData = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiData.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiData.setDescription(' RSSI seen by Airespace AP Interface for the Mobile Station')
bsnAPIfPhyAntennaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfPhyAntennaIndex.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyAntennaIndex.setDescription('Antenna which recived the probe request from client. The antenna which reported the RSSI value for the client. For now value will be 0 to 1, in future it may change.')
bsnMobileStationRssiDataLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 11, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMobileStationRssiDataLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnMobileStationRssiDataLastHeard.setDescription('No of seconds ago when this RSSI data was recorded.')
bsnTagTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18), )
if mibBuilder.loadTexts: bsnTagTable.setStatus('current')
if mibBuilder.loadTexts: bsnTagTable.setDescription('RF ID Tag Table indexed by bsnTagDot11MacAddress.')
bsnTagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnTagDot11MacAddress"))
if mibBuilder.loadTexts: bsnTagEntry.setStatus('current')
if mibBuilder.loadTexts: bsnTagEntry.setDescription('An entry in bsnTagTable.')
bsnTagDot11MacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagDot11MacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnTagDot11MacAddress.setDescription('802.11 MAC Address of the RF ID Tag.')
bsnTagType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("unknown", 0), ("type1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagType.setStatus('current')
if mibBuilder.loadTexts: bsnTagType.setDescription('Type of the RF ID Tag.')
bsnTagTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagTimeInterval.setStatus('current')
if mibBuilder.loadTexts: bsnTagTimeInterval.setDescription('Time Interval after which the tag transmits data.')
bsnTagBatteryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("low", 1), ("normal", 2), ("medium", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagBatteryStatus.setStatus('current')
if mibBuilder.loadTexts: bsnTagBatteryStatus.setDescription('Battery Status of the RF ID Tag.')
bsnTagLastReported = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 18, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagLastReported.setStatus('current')
if mibBuilder.loadTexts: bsnTagLastReported.setDescription('No of seconds ago when this tag was heard by any AP.')
bsnTagStatsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 20), )
if mibBuilder.loadTexts: bsnTagStatsTable.setStatus('current')
if mibBuilder.loadTexts: bsnTagStatsTable.setDescription('RF ID Tag Statistics Table.')
bsnTagStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 20, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnTagDot11MacAddress"))
if mibBuilder.loadTexts: bsnTagStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnTagStatsEntry.setDescription('An entry in bsnTagStatsTable.')
bsnTagBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 20, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagBytesReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTagBytesReceived.setDescription('Bytes received from an RF ID Tag')
bsnTagPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 20, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTagPacketsReceived.setDescription('Packets received from an RF ID Tag')
bsnTagRssiDataTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19), )
if mibBuilder.loadTexts: bsnTagRssiDataTable.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataTable.setDescription('RF ID Tag Detecting AP Table indexed by bsnTagDot11MacAddress, bsnTagRssiDataApMacAddress and bsnTagRssiDataApIfSlotId.')
bsnTagRssiDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnTagDot11MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApMacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApIfSlotId"))
if mibBuilder.loadTexts: bsnTagRssiDataEntry.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataEntry.setDescription('An entry in bsnTagRssiDataTable.')
bsnTagRssiDataApMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataApMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataApMacAddress.setDescription('802.11 MAC Address of the AP detecting the RF ID Tag.')
bsnTagRssiDataApIfSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataApIfSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataApIfSlotId.setDescription('Slot Id of the radio on AP detecting the RF ID Tag.')
bsnTagRssiDataApIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2), ("uwb", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataApIfType.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataApIfType.setDescription('Interface Type of the radio on AP detecting the RF ID Tag.')
bsnTagRssiDataApName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataApName.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataApName.setDescription('Name of the AP detecting the RF ID Tag.')
bsnTagRssiDataLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataLastHeard.setDescription('No of seconds ago when this tag was heard by this detecting AP.')
bsnTagRssiData = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiData.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiData.setDescription('RSSI of the RF ID Tag as seen by the radio on this detecting AP.')
bsnTagRssiDataSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 19, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTagRssiDataSnr.setStatus('current')
if mibBuilder.loadTexts: bsnTagRssiDataSnr.setDescription('SNR of the RF ID tag as seen by the radio on this detecting AP.')
bsnWatchListClientTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 12), )
if mibBuilder.loadTexts: bsnWatchListClientTable.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWatchListClientTable.setDescription('Table of watch listed clients. When clients are added to this table by username or MAC address, ACS collects data for them to show trend reports. The switch generates Client Association and Client Authentication traps for the watch listed clients.The watch list feature can be enbaled or diabled by the bsnWatchListFeatureEnable flag on the switch.')
bsnWatchListClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 12, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnWatchListClientKey"), (0, "AIRESPACE-WIRELESS-MIB", "bsnWatchListClientType"))
if mibBuilder.loadTexts: bsnWatchListClientEntry.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWatchListClientEntry.setDescription('An entry in bsnWatchListClientTable.')
bsnWatchListClientKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 12, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWatchListClientKey.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWatchListClientKey.setDescription(' MAC Address or User Name of Client that is to be added to the watch list.')
bsnWatchListClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("byMac", 1), ("byUserName", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWatchListClientType.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWatchListClientType.setDescription('The type of the watch list client entry. The entry can be created by Client MAC Address or by Username.')
bsnWatchListClientRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 12, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWatchListClientRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWatchListClientRowStatus.setDescription('A row status type for the bsnWatchListClientEntry')
bsnRogueAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7), )
if mibBuilder.loadTexts: bsnRogueAPTable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPTable.setDescription('Rogue Table. This table lists all the Rogue APs detected by Airespace APs.')
bsnRogueAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"))
if mibBuilder.loadTexts: bsnRogueAPEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPEntry.setDescription('An Entry in bsnRogueAPTable.')
bsnRogueAPDot11MacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 1), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPDot11MacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDot11MacAddress.setDescription('MAC Address of Rogue Station.')
bsnRogueAPTotalDetectingAPs = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPTotalDetectingAPs.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPTotalDetectingAPs.setDescription('Total number of Airespace APs that detected this rogue.')
bsnRogueAPFirstReported = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPFirstReported.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPFirstReported.setDescription('Time Stamp when this Rogue was First Detected.')
bsnRogueAPLastReported = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPLastReported.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPLastReported.setDescription('Time Stamp when this Rogue was Last Detected.')
bsnRogueAPContainmentLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unassigned", 0), ("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPContainmentLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPContainmentLevel.setDescription("If the state of the rogue is contained, this specifies the level of containment. Higher the level, more the number of detecting APs that are used to contain it. The value must be between 1 to 4 for 'contained' state.")
bsnRogueAPType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ap", 0), ("adhoc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPType.setDescription('This attribute specifies if the Rogue is of ad-hoc type or is an AP.')
bsnRogueAPOnNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPOnNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPOnNetwork.setDescription('This attribute specifies if the Rogue is on Wired Network or not.')
bsnRogueAPTotalClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPTotalClients.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPTotalClients.setDescription(' Total number of Clients detected on this rogue.')
bsnRogueAPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPRowStatus.setDescription('Row Status')
bsnRogueAPMaxDetectedRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPMaxDetectedRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPMaxDetectedRSSI.setDescription('This is the max RSSI value of all the detctecting APs, which have detected this rogue. ')
bsnRogueAPSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPSSID.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPSSID.setDescription('This is the SSID of the rogue detected by Access Point, which has max RSSI value of all the detectecting APs of this rogue.')
bsnRogueAPDetectingAPRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 12), Bits().clone(namedValues=NamedValues(("dot11b", 0), ("dot11a", 1), ("dot11g", 2), ("dot11n24", 3), ("dot11n5", 4), ("dot11abgn", 5), ("dot11ac", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPDetectingAPRadioType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDetectingAPRadioType.setDescription('Radio type of detecting APs. If the radio type is detected by dot11bg radio or dot11a radio or both.')
bsnRogueAPDetectingAPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPDetectingAPMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDetectingAPMacAddress.setDescription('MAC Address of of detecting AP which received max RSSI')
bsnRogueAPMaxRssiRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2), ("dot11abgn", 3), ("uwb", 4), ("dot11g", 5), ("dot11n24", 6), ("dot11n5", 7), ("dot11ac", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPMaxRssiRadioType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPMaxRssiRadioType.setDescription('The radio type of detecting AP which received max RSSI value.')
bsnRogueAPState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("initializing", 0), ("pending", 1), ("alert", 2), ("detectedLrad", 3), ("known", 4), ("acknowledge", 5), ("contained", 6), ("threat", 7), ("containedPending", 8), ("knownContained", 9), ("trustedMissing", 10)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPState.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPState.setDescription("This attribute is use to specify the state in which the Rogue AP is user can set the Rogue AP in alert, known or acknowledge state. Alert state means Rogue AP can be a potential threat. Trap will be sent out to trap recipients. Known state means its just internal AP which is not on the same Switch. Acknowledge state means an external AP whose existence is acceptable and not a threat (probably some other company's AP). Contained means containement is initiated and ongoing. Threat is usually the state when the rogue is found on wired network. known(4), knownContained(9) and trustedMissing(10) will appear in known rogue list. known rogues can be pre provisioned and known rogues state can be changed to alert(2)")
bsnRogueAPClassType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pending", 0), ("friendly", 1), ("malicious", 2), ("unclassified", 3), ("custom", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPClassType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPClassType.setDescription('The AP class type of the client detected.')
bsnRogueAPChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPChannel.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPChannel.setDescription('This is the channel number of the last detecting APs, which has detected this rogue. ')
bsnRogueAPDetectingAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 7, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRogueAPDetectingAPName.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDetectingAPName.setDescription('AP name of the detecting AP which received max RSSI')
bsnRogueAPAirespaceAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8), )
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPTable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPTable.setDescription('Rogue Station Table. This table lists all the Airespace AP Interfaces that detected a particular Rogue.')
bsnRogueAPAirespaceAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPMacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSlotId"))
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPEntry.setDescription('An entry in bsnRogueAPAirespaceAPEntry.')
bsnRogueAPAirespaceAPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPMacAddress.setDescription('MAC Address of Airespace AP Interface that Detected the Rogue.')
bsnRogueAPAirespaceAPSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPSlotId.setDescription('The slot ID of the Airespace AP Interface that detected the Rogue.')
bsnRogueAPRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2), ("dot11abgn", 3), ("uwb", 4), ("dot11g", 5), ("dot11n24", 6), ("dot11n5", 7), ("unknown", 8), ("dot11ac", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPRadioType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPRadioType.setDescription('The Airespace AP Interface type that detected the Rogue.')
bsnRogueAPAirespaceAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPName.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPName.setDescription('Name of Airespace AP Interface that detected the Rogue.')
bsnRogueAPChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPChannelNumber.setDescription(' The advertised Channel Number of the Airespace AP Interface picked up from the Rogue.')
bsnRogueAPSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPSsid.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPSsid.setDescription(' The SSID Advertised by Rogue Station.')
bsnRogueAPAirespaceAPRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPRSSI.setDescription('Rogue RSSI as seen by Airespace AP Interface.')
bsnRogueAPContainmentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 99))).clone(namedValues=NamedValues(("invalid", 0), ("deauthBroadcast", 1), ("cfp", 2), ("max", 3), ("unknown", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPContainmentMode.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPContainmentMode.setDescription("If the rogue is in 'contained' state, this attribute shows the containment mode used by the AP.")
bsnRogueAPContainmentChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPContainmentChannelCount.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPContainmentChannelCount.setDescription('The number of channels used for rogue containment.')
bsnRogueAPContainmentChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPContainmentChannels.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPContainmentChannels.setDescription('This is the comma separated string of channels used for rogue containment.')
bsnRogueAPAirespaceAPLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPLastHeard.setDescription('No of seconds ago when this Rogue was last heard by this AP. ')
bsnRogueAPAirespaceAPWepMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPWepMode.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPWepMode.setDescription('The WEP mode on this detecting AP.')
bsnRogueAPAirespaceAPPreamble = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("long", 0), ("short", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPPreamble.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPPreamble.setDescription('The Preamble on this detecting AP.')
bsnRogueAPAirespaceAPWpaMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPWpaMode.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPWpaMode.setDescription('The WPA mode on this detecting AP.')
bsnRogueAPAirespaceAPSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPSNR.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPAirespaceAPSNR.setDescription('SNR seen by Airespace AP Interface from Rogue')
bsnRogueAPChannelWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 8, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("five", 1), ("ten", 2), ("twenty", 3), ("aboveforty", 4), ("belowforty", 5), ("abovefortyAndEighty", 6), ("abovefortyBelowEighty", 7), ("aboveEightyBelowforty", 8), ("belowfortyBelowEighty", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPChannelWidth.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPChannelWidth.setDescription('This object represents the channel width of the rogue.')
bsnRogueClientPerRogueAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 16), )
if mibBuilder.loadTexts: bsnRogueClientPerRogueAPTable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientPerRogueAPTable.setDescription('Rogue Clients for each rogue. This table lists all Rogue Clients on a particular Rogue.')
bsnRogueClientPerRogueAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 16, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddr"), (0, "AIRESPACE-WIRELESS-MIB", "bsnRogueClientDot11MacAddr"))
if mibBuilder.loadTexts: bsnRogueClientPerRogueAPEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientPerRogueAPEntry.setDescription('An entry in RogueClientPerRogueAPTable.')
bsnRogueAPDot11MacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 16, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueAPDot11MacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDot11MacAddr.setDescription('The MAC Address of the Rogue AP.')
bsnRogueClientDot11MacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 16, 1, 20), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientDot11MacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientDot11MacAddr.setDescription('MAC Address of the Rogue Client.')
bsnRogueClientTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14), )
if mibBuilder.loadTexts: bsnRogueClientTable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientTable.setDescription('Rogue Client Table. This table lists all the Rogue Clients detected by Airespace APs.')
bsnRogueClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRogueClientDot11MacAddress"))
if mibBuilder.loadTexts: bsnRogueClientEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientEntry.setDescription('An Entry in bsnRogueClientTable.')
bsnRogueClientDot11MacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 1), MacAddress())
if mibBuilder.loadTexts: bsnRogueClientDot11MacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientDot11MacAddress.setDescription('Mac Address of Rogue Station.')
bsnRogueClientTotalDetectingAPs = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientTotalDetectingAPs.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientTotalDetectingAPs.setDescription('Total number of Airespace APs that detected this rogue.')
bsnRogueClientFirstReported = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientFirstReported.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientFirstReported.setDescription('Time Stamp when this Rogue was First Detected.')
bsnRogueClientLastReported = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientLastReported.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientLastReported.setDescription('Time Stamp when this Rogue was Last Detected.')
bsnRogueClientBSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientBSSID.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientBSSID.setDescription('This attribute specifies BSSID of the Rogue Client.')
bsnRogueClientContainmentLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unassigned", 0), ("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRogueClientContainmentLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientContainmentLevel.setDescription("If the state of the rogue is contained, this specifies the level of containment. Higher the level, more the number of detecting APs that are used to contain it. The value must be between 1 to 4 for 'contained' state.")
bsnRogueClientLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientLastHeard.setDescription('Number of seconds ago this rogue client was detected.')
bsnRogueClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 14, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 7, 8))).clone(namedValues=NamedValues(("initializing", 0), ("pending", 1), ("alert", 2), ("contained", 6), ("threat", 7), ("containedpending", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRogueClientState.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientState.setDescription("This attribute is use to specify the state in which the Rogue AP is. User can set the Rogue Client in alert,known or acknowledge state. Alert state means Rogue Client can be a potential i threat.Trap will be sent out to trap recipients. Known state means its just internal Client which is not on the same Switch. Acknowledge state means an external Client whose existence is acceptable and not a threat (probably some other company's AP). Contained means containement is initiated and ongoing")
bsnRogueClientAirespaceAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15), )
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPTable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPTable.setDescription('Rogue Station Table. This table lists all the Airespace AP Interface that detected a particular Rogue.')
bsnRogueClientAirespaceAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRogueClientDot11MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPMacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPSlotId"))
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPEntry.setDescription('An entry in bsnRogueClientAirespaceAPEntry.')
bsnRogueClientAirespaceAPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPMacAddress.setDescription('Mac Address of Airespace AP Interface that Detected the Rogue.')
bsnRogueClientAirespaceAPSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPSlotId.setDescription('The slotId of the Airespace AP Interface that detected the Rogue.')
bsnRogueClientRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientRadioType.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientRadioType.setDescription('The advertised SSID that the Airespace AP Interface picked up from the Rogue.')
bsnRogueClientAirespaceAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPName.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPName.setDescription('Name of Airespace AP Interface that detected the Rogue.')
bsnRogueClientChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientChannelNumber.setDescription('The advertised Channel Number of that the Airespace AP Interface picked up from the Rogue.')
bsnRogueClientAirespaceAPRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPRSSI.setDescription(' RSSI seen by Airespace AP Interface from the Rogue')
bsnRogueClientAirespaceAPLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPLastHeard.setDescription('No of seconds ago when this Rogue was last heard by this AP. ')
bsnRogueClientAirespaceAPSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 15, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPSNR.setStatus('current')
if mibBuilder.loadTexts: bsnRogueClientAirespaceAPSNR.setDescription('SNR seen by Airespace AP Interface from Rogue')
bsnThirdPartyAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9), )
if mibBuilder.loadTexts: bsnThirdPartyAPTable.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPTable.setDescription('Third Party Access Point Table. An entry needs to be configured in this table for a third party access point that needs to be supported by the Switch. Note: A third party ESS (Wlan) with ID 17 should be created in bsnDot11EssTable before adding entries here. Please also note that ACS currently supports only Aironet 350, 1200 and Orinoco 2000 Access Points as third party APs.')
bsnThirdPartyAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPMacAddress"))
if mibBuilder.loadTexts: bsnThirdPartyAPEntry.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPEntry.setDescription('An entry in bsnThirdPartyAPTable.')
bsnThirdPartyAPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 1), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAPMacAddress.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPMacAddress.setDescription('MAC Address of Third Party Access Point which is connected directly to this Airespace Switch.')
bsnThirdPartyAPInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAPInterface.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPInterface.setDescription('Interface(Port Number) to which the Third Party AP is connected.')
bsnThirdPartyAPIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAPIpAddress.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPIpAddress.setDescription('Static IP address of the 3rd Party AP, 0.0.0.0 indicating x its using DHCP')
bsnThirdPartyAP802Dot1XRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAP802Dot1XRequired.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAP802Dot1XRequired.setDescription('If 802.1X is required for the 3rd Party AP')
bsnThirdPartyAPMirrorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAPMirrorMode.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPMirrorMode.setDescription("If enabled, then data from all the foreign AP users and all the foreign APs on this APs port will be mirrored. These clients are dynamically added to the switch's mirrored MAC list.")
bsnThirdPartyAPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 1, 9, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnThirdPartyAPRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnThirdPartyAPRowStatus.setDescription('Row Status in the ThirdPartyAPEntry.')
bsnAPTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1), )
if mibBuilder.loadTexts: bsnAPTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPTable.setDescription('Table of Airespace APs managed by this Airespace Switch.')
bsnAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"))
if mibBuilder.loadTexts: bsnAPEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPEntry.setDescription('An entry in the bsnAPTable.')
bsnAPDot3MacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPDot3MacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPDot3MacAddress.setDescription('The MAC address of an AP.')
bsnAPNumOfSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPNumOfSlots.setStatus('current')
if mibBuilder.loadTexts: bsnAPNumOfSlots.setDescription('Number of Radio Interfaces on the Airespace AP. Currently maximum two interfaces are supported. One would be of type 802.11a and other of type 802.11b/g.')
bsnAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPName.setStatus('current')
if mibBuilder.loadTexts: bsnAPName.setDescription('Name assigned to this AP. If an AP is not configured its factory default name will be ap:<last three byte of MACAddress> eg. ap:af:12:be')
bsnAPLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPLocation.setStatus('current')
if mibBuilder.loadTexts: bsnAPLocation.setDescription('User specified location of this AP. While configuring AP, user should specify a location for the AP so that its easy to figure out for some one where the AP is located.')
bsnAPMonitorOnlyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("local", 0), ("monitor", 1), ("remote", 2), ("roguedetector", 3), ("sniffer", 4), ("bridge", 5), ("seConnect", 6), ("remoteBridge", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPMonitorOnlyMode.setStatus('current')
if mibBuilder.loadTexts: bsnAPMonitorOnlyMode.setDescription('Monitor Only Mode Setting.')
bsnAPOperationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("associated", 1), ("disassociating", 2), ("downloading", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPOperationStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPOperationStatus.setDescription('Operation State of the AP. When AP associates with the Airespace Switch its state will be associated. When Airespace AP is disassociated from the Switch, its state will be disassociating. The state is downloading when the AP is downloading its firmware.')
bsnAPSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: bsnAPSoftwareVersion.setDescription('Major Minor Software Version of AP')
bsnAPBootVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPBootVersion.setStatus('current')
if mibBuilder.loadTexts: bsnAPBootVersion.setDescription('Major Minor Boot Version of AP')
bsnAPPrimaryMwarName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPPrimaryMwarName.setStatus('current')
if mibBuilder.loadTexts: bsnAPPrimaryMwarName.setDescription('sysName of the Airespace Switch which is suppose to be the Primary MWAR(switch) of the AP with which AP should associate. This work when AP is not directly connected to Airespace Switch, it tries to find Primary Switch and associates with it. If this attribute is left empty or AP is not able to find the Airespace Switch with this name, then it will associate with Secondary Switch.')
bsnAPReset = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("reset", 1), ("default", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPReset.setStatus('current')
if mibBuilder.loadTexts: bsnAPReset.setDescription('Set this attribute to reset the AP. When it comes up it will try to associate with the Primary Switch if that is set, else it will associate with the Master Switch. Reading this attribute will always return 0')
bsnAPStatsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPStatsTimer.setStatus('current')
if mibBuilder.loadTexts: bsnAPStatsTimer.setDescription('Configures the time interval in secs after which bsnAPDot11Counters Stats is sent from AP to Switch. If not configured this value is 0 which means never send the stats.')
bsnAPPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPPortNumber.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPPortNumber.setDescription('Port on the Switch on which this APs traffic is coming through.')
bsnAPModel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPModel.setStatus('current')
if mibBuilder.loadTexts: bsnAPModel.setDescription('AP Model')
bsnAPSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPSerialNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPSerialNumber.setDescription('AP Serial Number.')
bsnAPClearConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 0))).clone(namedValues=NamedValues(("clearAll", 2), ("clear", 1), ("default", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPClearConfig.setStatus('current')
if mibBuilder.loadTexts: bsnAPClearConfig.setDescription('Set this attribute to clear AP configuration and reset it to factory defaults. A value of clearAll(2) resets all values to factory defaults. A value of clear(1) resets all values except static IP of the AP. Reading this attribute will always return 0')
bsnApIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnApIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnApIpAddress.setDescription('IP address of the AP. This will not be available when the switch is operating in the Layer2 mode. In this case, the attribute will return 0 as value.')
bsnAPMirrorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPMirrorMode.setStatus('current')
if mibBuilder.loadTexts: bsnAPMirrorMode.setDescription("If enabled, then this AP's Client's Data is mirrored and this AP's clients are dynamically added to the switch's mirrored MAC list.")
bsnAPRemoteModeSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPRemoteModeSupport.setStatus('current')
if mibBuilder.loadTexts: bsnAPRemoteModeSupport.setDescription('This specifies if the the Remote Mode is supported on this AP or not. If supported user can set bsnAPMonitorOnlyMode to remote. Otherwise not.')
bsnAPType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54))).clone(namedValues=NamedValues(("ap1000", 1), ("ap1030", 2), ("mimo", 3), ("unknown", 4), ("ap1100", 5), ("ap1130", 6), ("ap1240", 7), ("ap1200", 8), ("ap1310", 9), ("ap1500", 10), ("ap1250", 11), ("ap1505", 12), ("ap3201", 13), ("ap1520", 14), ("ap800", 15), ("ap1140", 16), ("ap800agn", 17), ("ap3500i", 18), ("ap3500e", 19), ("ap1260", 20), ("ap1040", 21), ("ap1550", 22), ("ap602i", 23), ("ap3500p", 24), ("ap802gn", 25), ("ap802agn", 26), ("ap3600i", 27), ("ap3600e", 28), ("ap2600i", 29), ("ap2600e", 30), ("ap802hagn", 31), ("ap1600i", 32), ("ap1600e", 33), ("ap702e", 34), ("ap702i", 35), ("ap3600p", 36), ("ap1530i", 37), ("ap1530e", 38), ("ap3700e", 39), ("ap3700i", 40), ("ap3700p", 41), ("ap2700e", 42), ("ap2700i", 43), ("ap702w", 44), ("wap2600i", 45), ("wap2600e", 46), ("wap1600i", 47), ("wap1600e", 48), ("wap702i", 49), ("wap702e", 50), ("ap1700i", 51), ("ap1700e", 52), ("ap1570e", 53), ("ap1570i", 54)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPType.setStatus('current')
if mibBuilder.loadTexts: bsnAPType.setDescription('This is the model of the AP in enumeration.')
bsnAPSecondaryMwarName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPSecondaryMwarName.setStatus('current')
if mibBuilder.loadTexts: bsnAPSecondaryMwarName.setDescription('sysName of the Airespace Switch which is suppose to be the Secondary MWAR(switch) of the AP with which AP should associate if Primary Switch(configured through bsnAPPrimaryMwarName) is not available. If primary and secondary switches are not available then AP will associate with the tertiary switch.')
bsnAPTertiaryMwarName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPTertiaryMwarName.setStatus('current')
if mibBuilder.loadTexts: bsnAPTertiaryMwarName.setDescription('sysName of the Airespace Switch which is suppose to be the Tertiary MWAR(switch) of the AP with which AP should associate. If primary,secondary and tertiary switch are not available then it will associate with Master Switch.')
bsnAPIsStaticIP = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIsStaticIP.setStatus('current')
if mibBuilder.loadTexts: bsnAPIsStaticIP.setDescription('This flag when disabled implies that AP will use DHCP to get the IP address. However, if it is enabled, then user should enter the IPAddress, Netmask and Gateway.')
bsnAPNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 26), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPNetmask.setStatus('current')
if mibBuilder.loadTexts: bsnAPNetmask.setDescription('The Netmask of the IP address of the AP.')
bsnAPGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPGateway.setStatus('current')
if mibBuilder.loadTexts: bsnAPGateway.setDescription('The Gateway for the AP.')
bsnAPStaticIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPStaticIPAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPStaticIPAddress.setDescription('The Static IP-Address configuration for the AP. This can only be changed when the LWAPP mode is in Layer-3.')
bsnAPBridgingSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPBridgingSupport.setStatus('current')
if mibBuilder.loadTexts: bsnAPBridgingSupport.setDescription('This specifies if this AP is a Bridging AP. Bridging APs can be used in Bridging or Mesh network configurations.')
bsnAPGroupVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPGroupVlanName.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupVlanName.setDescription('The AP Group to which this AP has been associated with. If it is empty, then no AP Group overriding has been set.')
bsnAPIOSVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 31), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIOSVersion.setStatus('current')
if mibBuilder.loadTexts: bsnAPIOSVersion.setDescription('IOS Version of IOS Cisco AP. Zero length string will be returned for other APs')
bsnAPCertificateType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("manufactureinstalled", 1), ("selfsigned", 2), ("localsignificance", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPCertificateType.setStatus('current')
if mibBuilder.loadTexts: bsnAPCertificateType.setDescription('Enum values denoting AP Certificate Type. 1 : manufactureinstalled : Manufacture Installed Certificate type (MIC). 2 : selfsigned : Self Signed Certificate type (SSC). 3 : localsignificance : Local Significance.')
bsnAPEthernetMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 33), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPEthernetMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPEthernetMacAddress.setDescription('The Ethernet MAC address of the AP.')
bsnAPAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPAdminStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPAdminStatus.setDescription('Admin State of the AP')
bsnAPIfTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2), )
if mibBuilder.loadTexts: bsnAPIfTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfTable.setDescription('Each entry represents an 802.11 interface in an Airespace AP.')
bsnAPIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfEntry.setDescription('An entry in bsnAPIfTable.')
bsnAPIfSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSlotId.setDescription('The slotId of this interface.')
bsnAPIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2), ("dot11abgn", 3), ("uwb", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfType.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfType.setDescription('The type of this interface. dot11b also implies 802.11b/g.')
bsnAPIfPhyChannelAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("customized", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyChannelAssignment.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyChannelAssignment.setDescription('If this value is true, then bsnAPDot11CurrentChannel in bsnAPIfDot11PhyDSSSTable is assigned by dynamic algorithm and is read-only.')
bsnAPIfPhyChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 25, 26, 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173))).clone(namedValues=NamedValues(("ch1", 1), ("ch2", 2), ("ch3", 3), ("ch4", 4), ("ch5", 5), ("ch6", 6), ("ch7", 7), ("ch8", 8), ("ch9", 9), ("ch10", 10), ("ch11", 11), ("ch12", 12), ("ch13", 13), ("ch14", 14), ("ch20", 20), ("ch21", 21), ("ch22", 22), ("ch23", 23), ("ch24", 24), ("ch25", 25), ("ch26", 26), ("ch34", 34), ("ch36", 36), ("ch38", 38), ("ch40", 40), ("ch42", 42), ("ch44", 44), ("ch46", 46), ("ch48", 48), ("ch52", 52), ("ch56", 56), ("ch60", 60), ("ch64", 64), ("ch100", 100), ("ch104", 104), ("ch108", 108), ("ch112", 112), ("ch116", 116), ("ch120", 120), ("ch124", 124), ("ch128", 128), ("ch132", 132), ("ch136", 136), ("ch140", 140), ("ch149", 149), ("ch153", 153), ("ch157", 157), ("ch161", 161), ("ch165", 165), ("ch169", 169), ("ch173", 173)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyChannelNumber.setDescription('Current channel number of the AP Interface. Channel numbers will be from 1 to 14 for 802.11b interface type. Channel numbers will be from 34 to 173 for 802.11a interface type. Allowed channel numbers also depends on the current Country Code set in the Switch. This attribute cannot be set unless bsnAPIfPhyChannelAssignment is set to customized else this attribute gets assigned by dynamic algorithm.')
bsnAPIfPhyTxPowerControl = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("customized", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyTxPowerControl.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyTxPowerControl.setDescription('If this value is true, then bsnAPIfPhyTxPowerLevel is assigned by dynamic algorithm and is read-only.')
bsnAPIfPhyTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyTxPowerLevel.setDescription('The TxPowerLevel currently being used to transmit data. Some PHYs also use this value to determine the receiver sensitivity requirements for CCA. Valid values are between 1 to 8,depnding on what radio, and this attribute can be set only if bsnAPIfPhyTxPowerControl is set to customized.')
bsnAPIfPhyAntennaMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("sectorA", 1), ("sectorB", 2), ("omni", 3), ("notapplicable", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyAntennaMode.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyAntennaMode.setDescription("Antenna Mode of the AP Interface. For 802.11a this attribute will always be omni for now. This attribute doesn't apply to interface of type 802.11b.")
bsnAPIfPhyAntennaType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyAntennaType.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyAntennaType.setDescription('This attribute specified if the Antenna currently used by AP Radio is internal or external. For 802.11a the antenna is always internal. For 802.11b you can set antenna type to be external or internal.')
bsnAPIfPhyAntennaDiversity = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 255))).clone(namedValues=NamedValues(("connectorA", 0), ("connectorB", 1), ("enabled", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPhyAntennaDiversity.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyAntennaDiversity.setDescription("Diversity doesn't apply to AP Radio of type 802.11a. For 802.11b you can set it to connectorA, connectorB or enabled.")
bsnAPIfCellSiteConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfCellSiteConfigId.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfCellSiteConfigId.setDescription('In a cell site configuration, this would be the cell Id of this AP Interface')
bsnAPIfNumberOfVaps = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfNumberOfVaps.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfNumberOfVaps.setDescription('Number of WLANs currently active on this AP Interface.')
bsnAPIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfOperStatus.setDescription('Operational status of the interface.')
bsnAPIfPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfPortNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPortNumber.setDescription('Port number on Airespace Switch on which the traffic from this AP interface is received.')
bsnAPIfPhyAntennaOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("internalAndExternal", 0), ("internal", 1), ("siacAp", 2), ("external", 3), ("ext11bInt11a", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfPhyAntennaOptions.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPhyAntennaOptions.setDescription('This attribute specifies the Antenna types supported by the AP Radio whether it is internal or external or both. internalAndExternal(0)- internal and external antenna for both 11a and 11b internal(1) - only internal antenna is allowed. siacAp- 11b internal and 11a external external - only external antenna is allowed for 11a and 11b ext11bInt11a - external antenna for 11b and internal antenna for 11a.')
bsnApIfNoOfUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnApIfNoOfUsers.setStatus('current')
if mibBuilder.loadTexts: bsnApIfNoOfUsers.setDescription('No of Users associated with this radio.')
bsnAPIfWlanOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfWlanOverride.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverride.setDescription('This flag when disabled implies that all WLANs are available from this radio. However, if this is enabled, then only those WLANs that appear in the bsnApIfWlanOverrideTable will be available from this radio.')
bsnAPIfPacketsSniffingFeature = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfPacketsSniffingFeature.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPacketsSniffingFeature.setDescription("This flag when enabled implies that AP will sniff the 802.11a/bg packets. However, if it is enabled, then user should enter the server-ip-address on which Airopeek is running and the 802.11a/bg-channel-number to be sniffed. The above feature will work only when AP is in 'Sniffer' mode.")
bsnAPIfSniffChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 25, 26, 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173))).clone(namedValues=NamedValues(("ch0", 0), ("ch1", 1), ("ch2", 2), ("ch3", 3), ("ch4", 4), ("ch5", 5), ("ch6", 6), ("ch7", 7), ("ch8", 8), ("ch9", 9), ("ch10", 10), ("ch11", 11), ("ch12", 12), ("ch13", 13), ("ch14", 14), ("ch20", 20), ("ch21", 21), ("ch22", 22), ("ch23", 23), ("ch24", 24), ("ch25", 25), ("ch26", 26), ("ch34", 34), ("ch36", 36), ("ch38", 38), ("ch40", 40), ("ch42", 42), ("ch44", 44), ("ch46", 46), ("ch48", 48), ("ch52", 52), ("ch56", 56), ("ch60", 60), ("ch64", 64), ("ch100", 100), ("ch104", 104), ("ch108", 108), ("ch112", 112), ("ch116", 116), ("ch120", 120), ("ch124", 124), ("ch128", 128), ("ch132", 132), ("ch136", 136), ("ch140", 140), ("ch149", 149), ("ch153", 153), ("ch157", 157), ("ch161", 161), ("ch165", 165), ("ch169", 169), ("ch173", 173)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfSniffChannel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSniffChannel.setDescription('This the 802.11a/bg-channel-number on which AP will sniff the packets.')
bsnAPIfSniffServerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfSniffServerIPAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSniffServerIPAddress.setDescription('The machine ip address on which Airopeek application is running.')
bsnAPIfAntennaGain = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfAntennaGain.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfAntennaGain.setDescription('Represents antenna gain in multiple of 0.5 dBi. An integer value 4 means 4 x 0.5 = 2 dBi of gain')
bsnAPIfChannelList = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 21), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfChannelList.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfChannelList.setDescription('List of comma separated channels supported by this radio.')
bsnAPIfAbsolutePowerList = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 22), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfAbsolutePowerList.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfAbsolutePowerList.setDescription('List of comma separated absolute power levels supported by this radio.')
bsnAPIfRegulatoryDomainSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notSupported", 0), ("supported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRegulatoryDomainSupport.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRegulatoryDomainSupport.setDescription('If the regulatory domain on radio is supported or notSupported on the controller')
bsnAPIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disable", 2), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfAdminStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfAdminStatus.setDescription('Admin status of the interface.')
bsnAPIfWlanOverrideTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 21), )
if mibBuilder.loadTexts: bsnAPIfWlanOverrideTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverrideTable.setDescription('Each entry represents an SSID added to the AP when the attribute bsnAPIfWlanOverride on the radio is enabled. This means only those WLANs on the switch that are added to this table will be available on such a radio.')
bsnAPIfWlanOverrideEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 21, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideId"))
if mibBuilder.loadTexts: bsnAPIfWlanOverrideEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverrideEntry.setDescription('An entry in bsnAPIfWlanOverrideTable')
bsnAPIfWlanOverrideId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 21, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPIfWlanOverrideId.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverrideId.setDescription('Index of the WLAN (bsnDot11EssIndex) added to the radio. Airespace Switch supports 16 Airespace WLANs so index will be from 1 to 16.')
bsnAPIfWlanOverrideSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 21, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfWlanOverrideSsid.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverrideSsid.setDescription('SSID assigned to the override WLAN.')
bsnAPIfWlanOverrideRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 21, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPIfWlanOverrideRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfWlanOverrideRowStatus.setDescription('A row status type for the bsnAPIfWlanOverrideEntry')
bsnAPIfSmtParamTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3), )
if mibBuilder.loadTexts: bsnAPIfSmtParamTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSmtParamTable.setDescription('Each entry represents SMT parameters on an 802.11 interface of an Airespace AP.')
bsnAPIfSmtParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfSmtParamEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSmtParamEntry.setDescription('An entry in bsnAPIfSmtParamTable')
bsnAPIfDot11BeaconPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11BeaconPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11BeaconPeriod.setDescription('This attribute shall specify the number of TU that a AP Interface shall use for scheduling Beacon tranmissions. This value is transmitted in Beacon and Probe Response frames.')
bsnAPIfDot11MediumOccupancyLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MediumOccupancyLimit.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MediumOccupancyLimit.setDescription('This attribute shall indicate the maximum amount of time, in TU, that a point coordinator may control the usage of the wireless medium without relinquishing control for long enough to allow at least one instance of DCF access to the medium. The default value of this attribute shall be 100, and the maximum value shall be 1000.')
bsnAPIfDot11CFPPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11CFPPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CFPPeriod.setDescription('The attribute shall describe the number of DTIM intervals between the start of CFPs. It is modified by MLME-START.request primitive.')
bsnAPIfDot11CFPMaxDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11CFPMaxDuration.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CFPMaxDuration.setDescription('The attribute shall describe the maximum duration of the CFP in TU that may be generated by the PCF. It is modified by MLME-START.request primitive.')
bsnAPIfDot11OperationalRateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11OperationalRateSet.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11OperationalRateSet.setDescription('This attribute shall specify the set of data rates at which the AP Interface may transmit data. Each octet contains a value representing a rate. Each rate shall be within the range from 2 to 127, corresponding to data rates in increments of 500 kb/s from 1 Mb/s to 63.5 Mb/s, and shall be supported (as indicated in the supported rates table) for receiving data. This value is reported in transmitted Beacon, Probe Request, Probe Response, Association Request, Association Response, Reassociation Request, and Reassociation Response frames, and is used to determine whether a BSS with which the AP Interface desires to synchronize is suitable. It is also used when starting a BSS, as specified in 10.3.')
bsnAPIfDot11DTIMPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11DTIMPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11DTIMPeriod.setDescription('This attribute shall specify the number of beacon intervals that shall elapse between transmission of Beacons frames containing a TIM element whose DTIM Count field is 0. This value is transmitted in the DTIM Period field of Beacon frames.')
bsnAPIfDot11MultiDomainCapabilityImplemented = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MultiDomainCapabilityImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MultiDomainCapabilityImplemented.setDescription('This attribute, when TRUE, indicates that the AP Interface implementation is capable of supporting multiple regulatory domains. The capability is disabled, otherwise. The default value of this attribute is FALSE.')
bsnAPIfDot11MultiDomainCapabilityEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MultiDomainCapabilityEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MultiDomainCapabilityEnabled.setDescription('This attribute, when TRUE, indicates that the capability of the AP Interface to operate in multiple regulatory domains is enabled. The capability is disabled, otherwise. The default value of this attribute is FALSE.')
bsnAPIfDot11CountryString = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11CountryString.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CountryString.setDescription("This attribute identifies the country in which the AP Interface is operating. The first two octets of this string is the two character country code as described in document ISO/IEC 3166-1. The third octet shall be one of the following: 1. an ASCII space character, if the regulations under which the AP Interface is operating encompass all environments in the country, 2. an ASCII 'O' character, if the regulations under which the AP Interface is operating are for an Outdoor environment only, or 3. an ASCII 'I' character, if the regulations under which the AP Interface is operating are for an Indoor environment only.")
bsnAPIfDot11SmtParamsConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("automatic", 0), ("customized", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11SmtParamsConfigType.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11SmtParamsConfigType.setDescription('This attribute suggests if the Station parameters for this radio are automatically set or have been customized.')
bsnAPIfDot11BSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 3, 1, 30), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11BSSID.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11BSSID.setDescription('BSSID of this AP config which would be the MAC Address of AP')
bsnAPIfMultiDomainCapabilityTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 4), )
if mibBuilder.loadTexts: bsnAPIfMultiDomainCapabilityTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMultiDomainCapabilityTable.setDescription('Each entry represents an 803.2 or an 802.11 interface in an Airespace AP.')
bsnAPIfMultiDomainCapabilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 4, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfMultiDomainCapabilityEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMultiDomainCapabilityEntry.setDescription('Each entry represents an 803.2 or an 802.11 interface in an Airespace AP.')
bsnAPIfDot11MaximumTransmitPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MaximumTransmitPowerLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MaximumTransmitPowerLevel.setDescription('This attribute shall indicate the maximum transmit power, in dBm, allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnAPIfDot11FirstChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11FirstChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11FirstChannelNumber.setDescription('This attribute shall indicate the value of the lowest channel number in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnAPIfDot11NumberofChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11NumberofChannels.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11NumberofChannels.setDescription('This attribute shall indicate the value of the total number of channels allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnAPIfMacOperationParamTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5), )
if mibBuilder.loadTexts: bsnAPIfMacOperationParamTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMacOperationParamTable.setDescription('Group contains MAC attributes pertaining to the operation of the MAC. These would be read only attributes as they would be updated by RRM Dynamic Algorithm. If user needs to configure them then they can only be configured globally')
bsnAPIfMacOperationParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfMacOperationParamEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMacOperationParamEntry.setDescription('An entry in the bsnAPIfMacOperationParamEntry Table. Interface tables in this MIB module are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId.')
bsnAPIfDot11MacRTSThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2347))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacRTSThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacRTSThreshold.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm')
bsnAPIfDot11MacShortRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacShortRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacShortRetryLimit.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm')
bsnAPIfDot11MacLongRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacLongRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacLongRetryLimit.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm')
bsnAPIfDot11MacFragmentationThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 2346))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacFragmentationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacFragmentationThreshold.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm ')
bsnAPIfDot11MacMaxTransmitMSDULifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacMaxTransmitMSDULifetime.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacMaxTransmitMSDULifetime.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm')
bsnAPIfDot11MacParamsConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("automatic", 0), ("customized", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacParamsConfigType.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacParamsConfigType.setDescription('This attribute suggests if the MAC parameters for this radio are automatically set or have been customized.')
bsnAPIfDot11MacMaxReceiveLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 5, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MacMaxReceiveLifetime.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MacMaxReceiveLifetime.setDescription('If bsnAPIfMacParamsAutomaticOn is true then this is read only parameter updated by RRM dynamic algorithm')
bsnAPIfDot11CountersTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6), )
if mibBuilder.loadTexts: bsnAPIfDot11CountersTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CountersTable.setDescription('Group containing attributes that are MAC counters. Each instance represents counters on a AP dot11 interface')
bsnAPIfDot11CountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfDot11CountersEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CountersEntry.setDescription('An entry in the dot11CountersEntry Table. Interface tables in this MIB module are indexed by bsnAPDot3MacAddress and bsnAPIfSlotId')
bsnAPIfDot11TransmittedFragmentCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TransmittedFragmentCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11TransmittedFragmentCount.setDescription('This counter shall be incremented for an acknowledged MPDU with an individual address in the address 1 field or an MPDU with a multicast address in the address 1 field of type Data or Management.')
bsnAPIfDot11MulticastTransmittedFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MulticastTransmittedFrameCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MulticastTransmittedFrameCount.setDescription('This counter shall increment only when the multicast bit is set in the destination MAC address of a successfully transmitted MSDU. When operating as a STA in an ESS, where these frames are directed to the AP, this implies having received an acknowledgment to all associated MPDUs.')
bsnAPIfDot11RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11RetryCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11RetryCount.setDescription('This counter shall increment when an MSDU is successfully transmitted after one or more retransmissions.')
bsnAPIfDot11MultipleRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MultipleRetryCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MultipleRetryCount.setDescription('This counter shall increment when an MSDU is successfully transmitted after more than one retransmission.')
bsnAPIfDot11FrameDuplicateCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11FrameDuplicateCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11FrameDuplicateCount.setDescription('This counter shall increment when a frame is received that the Sequence Control field indicates is a duplicate.')
bsnAPIfDot11RTSSuccessCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11RTSSuccessCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11RTSSuccessCount.setDescription('This counter shall increment when a CTS is received in response to an RTS.')
bsnAPIfDot11RTSFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11RTSFailureCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11RTSFailureCount.setDescription('This counter shall increment when a CTS is not received in response to an RTS.')
bsnAPIfDot11ACKFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11ACKFailureCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11ACKFailureCount.setDescription('This counter shall increment when an ACK is not received when expected.')
bsnAPIfDot11ReceivedFragmentCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11ReceivedFragmentCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11ReceivedFragmentCount.setDescription('This counter shall be incremented for each successfully received MPDU of type Data or Management.')
bsnAPIfDot11MulticastReceivedFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11MulticastReceivedFrameCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11MulticastReceivedFrameCount.setDescription('This counter shall increment when a MSDU is received with the multicast bit set in the destination MAC address.')
bsnAPIfDot11FCSErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11FCSErrorCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11FCSErrorCount.setDescription('This counter shall increment when an FCS error is detected in a received MPDU.')
bsnAPIfDot11TransmittedFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TransmittedFrameCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11TransmittedFrameCount.setDescription('This counter shall increment for each successfully transmitted MSDU.')
bsnAPIfDot11WEPUndecryptableCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11WEPUndecryptableCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11WEPUndecryptableCount.setDescription("This counter shall increment when a frame is received with the WEP subfield of the Frame Control field set to one and the WEPOn value for the key mapped to the TA's MAC address indicates that the frame should not have been encrypted or that frame is discarded due to the receiving STA not implementing the privacy option.")
bsnAPIfDot11FailedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 6, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11FailedCount.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11FailedCount.setDescription('This counter shall increment when an MSDU is not transmitted successfully due to the number of transmit attempts exceeding either the bsnAPIfDot11ShortRetryLimit or dot11LongRetryLimit.')
bsnAPIfDot11PhyTxPowerTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8), )
if mibBuilder.loadTexts: bsnAPIfDot11PhyTxPowerTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11PhyTxPowerTable.setDescription('Group of attributes for bsnAPIfDot11PhyTxPowerTable. Implemented as a table indexed on STA ID to allow for multiple instances on an Agent. This table has been deprecated. The level and power can be obtained from bsnAPIfTable(bsnAPIfAbsolutePowerList).')
bsnAPIfDot11PhyTxPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfDot11PhyTxPowerEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11PhyTxPowerEntry.setDescription('An entry in the bsnAPIfDot11PhyTxPower Table. Interface tables in this MIB module are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId.')
bsnAPIfDot11NumberSupportedPowerLevels = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11NumberSupportedPowerLevels.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11NumberSupportedPowerLevels.setDescription('The number of power levels supported by the PMD. This attribute can have a value of 1 to 8.')
bsnAPIfDot11TxPowerLevel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel1.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel1.setDescription('The transmit output power for LEVEL1 in mW. This is also the default power level. It is same as the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel2.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel2.setDescription('The transmit output power for LEVEL2 in mW. It is 1/2 of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel3.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel3.setDescription('The transmit output power for LEVEL3 in mW. It is 1/4th of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel4.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel4.setDescription('The transmit output power for LEVEL4 in mW. It is 1/8th of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel5.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel5.setDescription('The transmit output power for LEVEL5 in mW. It is 1/16th of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel6 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel6.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel6.setDescription('The transmit output power for LEVEL6 in mW. It is 1/32th of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel7 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel7.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel7.setDescription('The transmit output power for LEVEL7 in mW. It is 1/64th of the Maximum power level available on an AP interface.')
bsnAPIfDot11TxPowerLevel8 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 8, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel8.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDot11TxPowerLevel8.setDescription('The transmit output power for LEVEL8 in mW. It is 1/128th of the Maximum power level available on an AP interface.')
bsnAPIfDot11PhyChannelTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 9), )
if mibBuilder.loadTexts: bsnAPIfDot11PhyChannelTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11PhyChannelTable.setDescription('Entry of attributes for bsnAPIfDot11PhyChannelEntry. Implemented as a table indexed on bsnAPDot3MacAddress, bsnAPIfSlotId allow for multiple instances on an Agent')
bsnAPIfDot11PhyChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfDot11PhyChannelEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11PhyChannelEntry.setDescription('An entry in the bsnAPIfDot11PhyChannelEntry Table. Interface tables in this MIB module are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId.')
bsnAPIfDot11CurrentCCAMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("edonly", 1), ("csonly", 2), ("edandcs", 4), ("cswithtimer", 8), ("hrcsanded", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11CurrentCCAMode.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11CurrentCCAMode.setDescription('The current CCA method in operation.Valid values are: energy detect only (edonly) = 01, carrier sense only (csonly) = 02, carrier sense and energy detect (edandcs)= 04 carrier sense with timer (cswithtimer)= 08 high rate carrier sense and energy detect (hrcsanded)=16.')
bsnAPIfDot11EDThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11EDThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11EDThreshold.setDescription('The current Energy Detect Threshold being used by the Channel PHY.')
bsnAPIfDot11TIThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 9, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDot11TIThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDot11TIThreshold.setDescription('The Threshold being used to detect a busy medium (frequency). CCA shall report a busy medium upon detecting the RSSI above this threshold.')
bsnAPIfProfileThresholdConfigTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12), )
if mibBuilder.loadTexts: bsnAPIfProfileThresholdConfigTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfProfileThresholdConfigTable.setDescription('Table of attributes for various thresholds to be set on each Airespace AP Interface for Load performance profile , interference performance profile and Noise performance profile.')
bsnAPIfProfileThresholdConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfProfileThresholdConfigEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfProfileThresholdConfigEntry.setDescription('An entry (conceptual row) in the Phy Thresholds Table. Entries in this MIB are indexed by bsnAPDot3MacAddress and bsnAPIfSlotId')
bsnAPIfProfileParamAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("customized", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfProfileParamAssignment.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfProfileParamAssignment.setDescription('If this value is automatic then Profile Parameters in bsnRrmDot11aAPProfile at the global level will be used. If this value is customized then Profile Parameters in bsnAPIfProfileThresholdConfig Table will be used and user can customize them per AP.')
bsnAPIfForeignInterferenceThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfForeignInterferenceThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfForeignInterferenceThreshold.setDescription('foreign interference threshold between 0 and 100 percent.')
bsnAPIfForeignNoiseThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfForeignNoiseThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfForeignNoiseThreshold.setDescription('foreign noise threshold between -100 and -50 dBm.')
bsnAPIfRFUtilizationThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfRFUtilizationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRFUtilizationThreshold.setDescription('RF utlization threshold between 0 and 100 percent.')
bsnAPIfThroughputThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfThroughputThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfThroughputThreshold.setDescription(' Airespace AP data-rate threshold between 1000 and 100000')
bsnAPIfMobilesThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfMobilesThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMobilesThreshold.setDescription(' Airespace AP mobiles threshold between 1 and 75')
bsnAPIfCoverageThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfCoverageThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfCoverageThreshold.setDescription(' Airespace AP coverage threshold between 3 and 50')
bsnAPIfMobileMinExceptionLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfMobileMinExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfMobileMinExceptionLevel.setDescription(' Airespace AP mobile minimum exception level between 1 and 1000')
bsnAPIfCoverageExceptionLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 12, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPIfCoverageExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfCoverageExceptionLevel.setDescription('Airespace AP coverage exception level between 0 and 100 percent.')
bsnAPIfLoadParametersTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13), )
if mibBuilder.loadTexts: bsnAPIfLoadParametersTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadParametersTable.setDescription('These are RRM performance related read only parameters per Airespace AP')
bsnAPIfLoadParametersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfLoadParametersEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadParametersEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress and bsnAPIfSlotId')
bsnAPIfLoadRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfLoadRxUtilization.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadRxUtilization.setDescription('This is the percentage of time the Airespace AP receiver is busy operating on packets. It is a number from 0-100 representing a load from 0 to 1.')
bsnAPIfLoadTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfLoadTxUtilization.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadTxUtilization.setDescription('This is the percentage of time the Airespace AP transmitter is busy operating on packets. It is a number from 0-100 representing a load from 0 to 1.')
bsnAPIfLoadChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfLoadChannelUtilization.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadChannelUtilization.setDescription('Channel Utilization')
bsnAPIfLoadNumOfClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfLoadNumOfClients.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadNumOfClients.setDescription('This is the number of clients attached to this Airespace AP at the last measurement interval(This comes from APF)')
bsnAPIfPoorSNRClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 13, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfPoorSNRClients.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfPoorSNRClients.setDescription('This is the number of clients with poor SNR attached to this Airespace AP at the last measurement interval ( This comes from APF ).')
bsnAPIfChannelInterferenceInfoTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 14), )
if mibBuilder.loadTexts: bsnAPIfChannelInterferenceInfoTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfChannelInterferenceInfoTable.setDescription('This is a table of channel information like interference and noise from other 802.11 networks on each channel.')
bsnAPIfChannelInterferenceInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 14, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceChannelNo"))
if mibBuilder.loadTexts: bsnAPIfChannelInterferenceInfoEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfChannelInterferenceInfoEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfInterferenceChannelNo = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfInterferenceChannelNo.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfInterferenceChannelNo.setDescription('Channel Number on AP')
bsnAPIfInterferencePower = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfInterferencePower.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfInterferencePower.setDescription('Power of Interference from other 802.11 networks on this channel')
bsnAPIfInterferenceUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 14, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfInterferenceUtilization.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfInterferenceUtilization.setDescription('Interference from other 802.11 networks on this channel')
bsnAPIfRadarChannelStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 24), )
if mibBuilder.loadTexts: bsnAPIfRadarChannelStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRadarChannelStatisticsTable.setDescription('This is a table of channel information on which radar signal were detected. This will give the list of channels and last heard timestamp. Radar signals are detected only on 5Ghz range. So this will be detected for 802.11a interface.')
bsnAPIfRadarChannelStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 24, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfRadarDetectedChannelNumber"))
if mibBuilder.loadTexts: bsnAPIfRadarChannelStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRadarChannelStatisticsEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId, bsnAPIfRadarDetectedCannelNumber.')
bsnAPIfRadarDetectedChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 24, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRadarDetectedChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRadarDetectedChannelNumber.setDescription('Channel Number on which radar signals were detected.')
bsnAPIfRadarSignalLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 24, 1, 2), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRadarSignalLastHeard.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRadarSignalLastHeard.setDescription('This tells how many seconds ago radar signal was heard on the channel.')
bsnAPIfChannelNoiseInfoTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 15), )
if mibBuilder.loadTexts: bsnAPIfChannelNoiseInfoTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfChannelNoiseInfoTable.setDescription('This is a table of channel information like interference and noise from other 802.11 networks on each channel.')
bsnAPIfChannelNoiseInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 15, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfNoiseChannelNo"))
if mibBuilder.loadTexts: bsnAPIfChannelNoiseInfoEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfChannelNoiseInfoEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfNoiseChannelNo = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfNoiseChannelNo.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfNoiseChannelNo.setDescription('Channel Number on AP')
bsnAPIfDBNoisePower = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 15, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfDBNoisePower.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfDBNoisePower.setDescription('This is the average noise power in dBm on each channel that is available to Airespace AP')
bsnAPIfProfileStateTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16), )
if mibBuilder.loadTexts: bsnAPIfProfileStateTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfProfileStateTable.setDescription('This is a table of state of interference monitor on each Airespace AP')
bsnAPIfProfileStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfProfileStateEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfProfileStateEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfLoadProfileState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16, 1, 1), ProfileState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfLoadProfileState.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfLoadProfileState.setDescription('This field represents the current state of the LOAD monitor. This is a total measurement of the business of this Airespace AP. PASS indicates that this Airespace AP is performing adequately compared to the Airespace AP profile. FAIL indicates the Airespace AP is not performing adequately against the LOAD profile.')
bsnAPIfInterferenceProfileState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16, 1, 2), ProfileState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfInterferenceProfileState.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfInterferenceProfileState.setDescription('This field represents the current state of Interference monitor. This is a total measurement of the interference present at this Airespace AP. PASS indicates that this Airespace AP is performing adequately compared to the Interference profile. FAIL indicates the Airespace AP is not performing adequately against the Interference profile.')
bsnAPIfNoiseProfileState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16, 1, 3), ProfileState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfNoiseProfileState.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfNoiseProfileState.setDescription('This field represents the current state of Noise monitor. This is a total measurement of the noise present at this Airespace AP. PASS indicates that this Airespace AP is performing adequately compared to the noise profile. FAIL indicates the Airespace AP is not performing adequately against the noise profile.')
bsnAPIfCoverageProfileState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 16, 1, 24), ProfileState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfCoverageProfileState.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfCoverageProfileState.setDescription('This field represents the current state of coverage monitor. This is a total measurement of the client coverage at this Airespace AP. PASS indicates that this Airespace AP is performing adequately compared to the coverage profile. FAIL indicates the Airespace AP is not performing adequately against the coverage profile.')
bsnAPIfRxNeighborsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17), )
if mibBuilder.loadTexts: bsnAPIfRxNeighborsTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborsTable.setDescription('This is a table of Rx Neighbors for each Airespace AP with their RSSI value.')
bsnAPIfRxNeighborsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborMacAddress"))
if mibBuilder.loadTexts: bsnAPIfRxNeighborsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborsEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress bsnAPIfSlotId, bsnAPIfRxNeighborMacAddress')
bsnAPIfRxNeighborMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborMacAddress.setDescription('MAC Address of Rx Neighbor of the Airespace AP')
bsnAPIfRxNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborIpAddress.setDescription('IP Address of Rx Neighbor of the Airespace AP')
bsnAPIfRxNeighborRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborRSSI.setDescription('RSSI value of the Rx Neighbor')
bsnAPIfRxNeighborSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborSlot.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborSlot.setDescription('Slot value of the Rx Neighbor')
bsnAPIfRxNeighborChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborChannel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborChannel.setDescription('This object represents Channel information which neighboring Access point is using.')
bsnAPIfRxNeighborChannelWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 17, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("five", 1), ("ten", 2), ("twenty", 3), ("aboveforty", 4), ("belowforty", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRxNeighborChannelWidth.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRxNeighborChannelWidth.setDescription('This object represents Channel bandwidth information which neighboring Access point is using.')
bsnMeshNodeTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22), )
if mibBuilder.loadTexts: bsnMeshNodeTable.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeTable.setDescription('This is a table of mesh nodes.')
bsnMeshNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"))
if mibBuilder.loadTexts: bsnMeshNodeEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress')
bsnMeshNodeRole = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pap", 0), ("rap", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeRole.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeRole.setDescription('the role of this AP')
bsnMeshNodeGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeGroup.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeGroup.setDescription('the bridge group name of this AP')
bsnMeshNodeBackhaul = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("dot11a", 0), ("dot11b", 1), ("dot11g", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeBackhaul.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeBackhaul.setDescription('the backhaul radio device for this AP')
bsnMeshNodeBackhaulPAP = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("auto", 0), ("dot11a", 1), ("dot11b", 2), ("dot11g", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeBackhaulPAP.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeBackhaulPAP.setDescription('the backhaul ')
bsnMeshNodeBackhaulRAP = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("dot11a", 0), ("dot11b", 1), ("dot11g", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMeshNodeBackhaulRAP.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeBackhaulRAP.setDescription('the backhaul radio device for this AP')
bsnMeshNodeDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMeshNodeDataRate.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeDataRate.setDescription('this nodes backhaul data rate')
bsnMeshNodeChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeChannel.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeChannel.setDescription('this nodes backhaul channel')
bsnMeshNodeRoutingState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("start", 1), ("seek", 2), ("sync", 3), ("auth", 4), ("maint", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeRoutingState.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeRoutingState.setDescription('routing state')
bsnMeshNodeMalformedNeighPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeMalformedNeighPackets.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeMalformedNeighPackets.setDescription('the number of malformed neighbor packets.')
bsnMeshNodePoorNeighSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodePoorNeighSnr.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodePoorNeighSnr.setDescription('poor neighbor snr')
bsnMeshNodeBlacklistPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeBlacklistPackets.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeBlacklistPackets.setDescription('the number of blacklist packets received')
bsnMeshNodeInsufficientMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeInsufficientMemory.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeInsufficientMemory.setDescription('occurences of insufficient memory conditions')
bsnMeshNodeRxNeighReq = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeRxNeighReq.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeRxNeighReq.setDescription('Rx neighbor requests')
bsnMeshNodeRxNeighRsp = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeRxNeighRsp.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeRxNeighRsp.setDescription('Rx neighbor responses')
bsnMeshNodeTxNeighReq = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeTxNeighReq.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeTxNeighReq.setDescription('Tx neighbor requests')
bsnMeshNodeTxNeighRsp = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeTxNeighRsp.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeTxNeighRsp.setDescription('Tx neighbor responses')
bsnMeshNodeParentChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeParentChanges.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeParentChanges.setDescription('number of parent changes')
bsnMeshNodeNeighTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeNeighTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeNeighTimeout.setDescription('number of neighbor timeouts')
bsnMeshNodeParentMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 19), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeParentMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeParentMacAddress.setDescription('parents mac addressed')
bsnMeshNodeAPType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("indoorBridge", 5), ("outdoorBridge", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeAPType.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeAPType.setDescription('the type of AP')
bsnMeshNodeEthernetBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMeshNodeEthernetBridge.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeEthernetBridge.setDescription("enable : Enables ethernet bridging on the AP. disable : Disables ethernet bridging on the AP. Changes are only applicable when AP is in 'Bridge' mode. ")
bsnMeshNodeHops = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 22, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNodeHops.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNodeHops.setDescription('number of hops to rap')
bsnMeshNeighsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23), )
if mibBuilder.loadTexts: bsnMeshNeighsTable.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighsTable.setDescription('This is a table of mesh neighbors.')
bsnMeshNeighsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMeshNeighMacAddress"))
if mibBuilder.loadTexts: bsnMeshNeighsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighsEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress and bsnMeshNeighNeighMacAddress')
bsnMeshNeighMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighMacAddress.setDescription('MAC Address of neighbor')
bsnMeshNeighType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("parent", 0), ("tentparent", 1), ("neigh", 2), ("blacklisted", 3), ("child", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighType.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighType.setDescription('neighbor type')
bsnMeshNeighState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("updated", 0), ("needupdate", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighState.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighState.setDescription('neighbor state')
bsnMeshNeighSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighSnr.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighSnr.setDescription('explicitly set SNR')
bsnMeshNeighSnrUp = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighSnrUp.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighSnrUp.setDescription('snr up')
bsnMeshNeighSnrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighSnrDown.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighSnrDown.setDescription('snr down')
bsnMeshNeighLinkSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighLinkSnr.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighLinkSnr.setDescription('link snr')
bsnMeshNeighAdjustedEase = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighAdjustedEase.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighAdjustedEase.setDescription('hops adjusted ease')
bsnMeshNeighUnadjustedEase = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighUnadjustedEase.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighUnadjustedEase.setDescription('ease to root AP from this AP')
bsnMeshNeighRapEase = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighRapEase.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighRapEase.setDescription('unadjusted ease received in last hello')
bsnMeshNeighTxParent = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighTxParent.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighTxParent.setDescription('tx packets to this node while a parent')
bsnMeshNeighRxParent = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighRxParent.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighRxParent.setDescription('rx packets from this node while a parent')
bsnMeshNeighPoorSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighPoorSnr.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighPoorSnr.setDescription('packets with poor snr received from this node')
bsnMeshNeighLastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighLastUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighLastUpdate.setDescription('last received hello from this neighbor')
bsnMeshNeighParentChange = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 23, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMeshNeighParentChange.setStatus('current')
if mibBuilder.loadTexts: bsnMeshNeighParentChange.setDescription('when this node last became parent')
bsnAPIfStationRSSICoverageInfoTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 18), )
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageInfoTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageInfoTable.setDescription('This is a table of channel information like interference and noise from other 802.11 networks on each channel.')
bsnAPIfStationRSSICoverageInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 18, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfStationRSSICoverageIndex"))
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageInfoEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageInfoEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfStationRSSICoverageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageIndex.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationRSSICoverageIndex.setDescription('RSSI Coverage Index on AP')
bsnAPIfRSSILevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 18, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRSSILevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRSSILevel.setDescription('RSSI Level')
bsnAPIfStationCountOnRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 18, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfStationCountOnRSSI.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationCountOnRSSI.setDescription('Number of stations on this RSSI Level')
bsnAPIfStationSNRCoverageInfoTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 19), )
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageInfoTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageInfoTable.setDescription('This is a table of Signal to Noise ratio Coverage information on an AP Interface.')
bsnAPIfStationSNRCoverageInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 19, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfStationSNRCoverageIndex"))
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageInfoEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageInfoEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfStationSNRCoverageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 19, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageIndex.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationSNRCoverageIndex.setDescription('SNR Coverage Index on AP')
bsnAPIfSNRLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 19, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfSNRLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfSNRLevel.setDescription('SNR Level')
bsnAPIfStationCountOnSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 19, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfStationCountOnSNR.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfStationCountOnSNR.setDescription('Number of stations on this SNR Level')
bsnAPIfRecommendedRFParametersTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20), )
if mibBuilder.loadTexts: bsnAPIfRecommendedRFParametersTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedRFParametersTable.setDescription(' This table list Best Channel,Best TxPowerLevel, Best RTSThreshold,Best FragmentationThreshold etc for this AP Interface as determined by RRM.')
bsnAPIfRecommendedRFParametersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"))
if mibBuilder.loadTexts: bsnAPIfRecommendedRFParametersEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedRFParametersEntry.setDescription('An entry (conceptual row) in the Table. Entries in this MIB are indexed by bsnAPDot3MacAddress, bsnAPIfSlotId')
bsnAPIfRecommendedChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRecommendedChannelNumber.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedChannelNumber.setDescription('Recommended ChannelNumber by RRM for this APIf')
bsnAPIfRecommendedTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRecommendedTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedTxPowerLevel.setDescription('Recommended TxPowerLevel by RRM for this APIf')
bsnAPIfRecommendedRTSThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRecommendedRTSThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedRTSThreshold.setDescription('Recommended RTSThreshold by RRM for this APIf')
bsnAPIfRecommendedFragmentationThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 2, 20, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAPIfRecommendedFragmentationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfRecommendedFragmentationThreshold.setDescription('Recommended Fragmentation Threshold by RRM for this APIf')
bsnGlobalDot11Config = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1))
bsnGlobalDot11PrivacyOptionImplemented = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notimplemented", 0), ("implemented", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11PrivacyOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11PrivacyOptionImplemented.setDescription('This attribute, when true, shall indicate that the IEEE 802.11 WEP option is implemented. The default value of this attribute shall be false.')
bsnGlobalDot11AuthenticationResponseTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11AuthenticationResponseTimeOut.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11AuthenticationResponseTimeOut.setDescription('This attribute shall specify the number of TU that a responding STA should wait for the next frame in the authentication sequence.')
bsnGlobalDot11MultiDomainCapabilityImplemented = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11MultiDomainCapabilityImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11MultiDomainCapabilityImplemented.setDescription('This attribute, when TRUE, indicates that the station implementation is capable of supporting multiple regulatory domains. The capability is disabled, otherwise. The default value of this attribute is FALSE.')
bsnGlobalDot11MultiDomainCapabilityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11MultiDomainCapabilityEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11MultiDomainCapabilityEnabled.setDescription('This attribute, when TRUE, indicates that the capability of the station to operate in multiple regulatory domains is enabled. The capability is disabled, otherwise. The default value of this attribute is FALSE.')
bsnGlobalDot11CountryIndex = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68))).clone(namedValues=NamedValues(("usa", 1), ("canada", 2), ("france", 3), ("japan", 4), ("mexico", 5), ("spain", 6), ("usalegacy", 7), ("korearepublic", 8), ("australia", 9), ("austria", 10), ("belgium", 11), ("denmark", 12), ("finland", 13), ("germany", 14), ("greece", 15), ("ireland", 16), ("italy", 17), ("luxembourg", 18), ("netherlands", 19), ("portugal", 20), ("sweden", 21), ("unitedkingdom", 22), ("none", 23), ("india", 24), ("hongkong", 25), ("switzerland", 26), ("iceland", 27), ("norway", 28), ("singapore", 29), ("thailand", 30), ("taiwan", 31), ("cyprus", 33), ("czechrepublic", 34), ("estonia", 35), ("hungary", 36), ("lithuania", 37), ("latvia", 38), ("malaysia", 39), ("newzealand", 40), ("poland", 41), ("slovenia", 42), ("slovakrepublic", 43), ("southafrica", 44), ("usachan165", 45), ("israel", 46), ("israelOutdoor", 47), ("argentina", 48), ("brazil", 49), ("saudiArabia", 51), ("turkey", 52), ("indonesia", 53), ("china", 54), ("koreaExtended", 55), ("japan2", 56), ("gibraltar", 57), ("liechtenstein", 58), ("malta", 59), ("monaco", 60), ("romania", 61), ("russianfederation", 62), ("chile", 63), ("colombia", 64), ("panama", 65), ("peru", 66), ("venezuela", 67), ("philippines", 68)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11CountryIndex.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11CountryIndex.setDescription('This attribute identifies the country in which the station is operating.')
bsnGlobalDot11LoadBalancing = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11LoadBalancing.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11LoadBalancing.setDescription('This attribute specifies if load balancing of clients is enabled on disabled. Global configuration of Load Balancing is now removed. Use cLWlanLoadBalancingEnable to configure it per WLAN.')
bsnGlobalDot11RogueTimer = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(120, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11RogueTimer.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11RogueTimer.setDescription('This attribute specifies in seconds, the time interval after which a Rogue Entry in Rogue Table will expire if no beacon is heard from a Rogue.')
bsnPrimaryMwarForAPs = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnPrimaryMwarForAPs.setStatus('current')
if mibBuilder.loadTexts: bsnPrimaryMwarForAPs.setDescription("This attribute specifies if this Switch acts a Master Switch for the Airespace APs. So if an Airespace AP doesn't find its Primary Switch, it will associate with this Switch.")
bsnRtpProtocolPriority = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("nopriority", 0), ("highpriority", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRtpProtocolPriority.setStatus('current')
if mibBuilder.loadTexts: bsnRtpProtocolPriority.setDescription(' Real Time Protocol Priority.')
bsnSystemCurrentTime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnSystemCurrentTime.setStatus('current')
if mibBuilder.loadTexts: bsnSystemCurrentTime.setDescription('This attribute will display the Current System time on the Switch.')
bsnUpdateSystemTime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnUpdateSystemTime.setStatus('current')
if mibBuilder.loadTexts: bsnUpdateSystemTime.setDescription('Use this attribute to change the System time on the Switch. Specify the new time in this Format MM/DD/YYYY HH:MM:SS')
bsnOperatingTemperatureEnvironment = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("commercial", 1), ("industrial", 2), ("unknown", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnOperatingTemperatureEnvironment.setStatus('current')
if mibBuilder.loadTexts: bsnOperatingTemperatureEnvironment.setDescription('Operating Environment of the Airespace Switch. commercial is Commercial (0 to 40 C) and industrial is Industrial (-10 to 70 C)')
bsnSensorTemperature = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnSensorTemperature.setStatus('current')
if mibBuilder.loadTexts: bsnSensorTemperature.setDescription('Current Internal Temperature of the unit in Centigrade')
bsnTemperatureAlarmLowLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTemperatureAlarmLowLimit.setStatus('current')
if mibBuilder.loadTexts: bsnTemperatureAlarmLowLimit.setDescription('Internal Temperature Alarm Low Limit in Centigrade. If the bsnSensorTemperature goes below this limit bsnSensedTemperatureTooLow Alarm will be sent out')
bsnTemperatureAlarmHighLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTemperatureAlarmHighLimit.setStatus('current')
if mibBuilder.loadTexts: bsnTemperatureAlarmHighLimit.setDescription('Internal Temperature Alarm High Limit in Centigrade. If the bsnSensorTemperature goes above this limit bsnSensedTemperatureTooHigh Alarm will be sent out')
bsnVirtualGatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnVirtualGatewayAddress.setStatus('current')
if mibBuilder.loadTexts: bsnVirtualGatewayAddress.setDescription('Virtual Gateway Address of the Switch. This is used by web auth and Ipsec. If the virtual IP Address is changed, the Switch has to be rebooted for the new Address to take effect. This is now replaced by the Virtual Interface in bsnswitching MIB.')
bsnRFMobilityDomainName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRFMobilityDomainName.setStatus('current')
if mibBuilder.loadTexts: bsnRFMobilityDomainName.setDescription('RF Mobility Group Name to which this Airespace Switch belongs. Airespace Switches on a network form a RF Group as well as a Mobility Group. RF Groups does the channel and power management of AP while Mobility Group does load balancing and hand off for clients.')
bsnClientWatchListFeature = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnClientWatchListFeature.setStatus('current')
if mibBuilder.loadTexts: bsnClientWatchListFeature.setDescription('This flag should be turned on for the client watch lists to be enabled on the switch. When enabled, the switch generates Client Association and Authentication traps for the watchlisted clients.')
bsnRogueLocationDiscoveryProtocol = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("allAPs", 1), ("monitorAPOnly", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRogueLocationDiscoveryProtocol.setStatus('current')
if mibBuilder.loadTexts: bsnRogueLocationDiscoveryProtocol.setDescription('This flag should be turned on to enable the Rogue Location Discovery Protocol feature on the switch. We can either enable this feature for all the APs or only for APs in monitor mode.')
bsnRogueAutoContainFeature = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRogueAutoContainFeature.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAutoContainFeature.setDescription('This flag should be turned on to allow the switch to contain the rogues automatically if detected on the wired network.')
bsnOverAirProvisionApMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnOverAirProvisionApMode.setStatus('current')
if mibBuilder.loadTexts: bsnOverAirProvisionApMode.setDescription('Over the Air Provisioning Mode for APs')
bsnMaximumNumberOfConcurrentLogins = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMaximumNumberOfConcurrentLogins.setStatus('current')
if mibBuilder.loadTexts: bsnMaximumNumberOfConcurrentLogins.setDescription('This attribute specifies the maximum number of concurrent logins that the switch will allow for a single user. A value 0 implies that there is no restriction on the number of concurrent logins with a single username.')
bsnAutoContainRoguesAdvertisingSsid = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("alarmOnly", 0), ("contain", 1))).clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAutoContainRoguesAdvertisingSsid.setStatus('current')
if mibBuilder.loadTexts: bsnAutoContainRoguesAdvertisingSsid.setDescription('This flag should be set to 1 to allow the switch to contain automatically those rogues that are advertising our SSID. If value is 0, only an alarm will be generated when such a rogue is detected.')
bsnAutoContainAdhocNetworks = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("alarmOnly", 0), ("contain", 1))).clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAutoContainAdhocNetworks.setStatus('current')
if mibBuilder.loadTexts: bsnAutoContainAdhocNetworks.setDescription('This flag should be set to 1 to allow the switch to contain automatically the adhoc networks detected by the switch. If value is 0, only an alarm will be generated when such a network is detected.')
bsnAutoContainTrustedClientsOnRogueAps = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("alarmOnly", 0), ("contain", 1))).clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAutoContainTrustedClientsOnRogueAps.setStatus('current')
if mibBuilder.loadTexts: bsnAutoContainTrustedClientsOnRogueAps.setDescription('This flag should be set to 1 to allow the switch to contain automatically those trusted clients that are associated to rogue APs. If value is 0, only an alarm will be generated when such a client is detected.')
bsnValidateRogueClientsAgainstAAA = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnValidateRogueClientsAgainstAAA.setStatus('current')
if mibBuilder.loadTexts: bsnValidateRogueClientsAgainstAAA.setDescription("This flag should be turned on to allow the switch to validate 'valid' mobiles associating with rogue APs. For example, if a client's MAC Address is found in the local MAC filter table, that client can be validated.")
bsnSystemTimezoneDelta = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSystemTimezoneDelta.setStatus('current')
if mibBuilder.loadTexts: bsnSystemTimezoneDelta.setDescription('The delta (difference) between the local time and the Universal Coordinated Time in hours. For example, it is -8 for the PST and +1 for France. If the delta is -5.30 then this attribute will store -5 and bsnSystemTimezoneDeltaMinutes will store 30. This value i should be between -23 to +23 ')
bsnSystemTimezoneDeltaMinutes = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSystemTimezoneDeltaMinutes.setStatus('current')
if mibBuilder.loadTexts: bsnSystemTimezoneDeltaMinutes.setDescription('The minutes component of delta (difference) between the local time and the Universal Coordinated Time.')
bsnSystemTimezoneDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSystemTimezoneDaylightSavings.setStatus('obsolete')
if mibBuilder.loadTexts: bsnSystemTimezoneDaylightSavings.setDescription('This flag specifies if daylight savings are enabled for the current timezone.')
bsnAllowAuthorizeApAgainstAAA = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAllowAuthorizeApAgainstAAA.setStatus('current')
if mibBuilder.loadTexts: bsnAllowAuthorizeApAgainstAAA.setDescription('This flag specifies if LWAPP is allowed to get authorization via RADIUS or local database for an AP.')
bsnApFallbackEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnApFallbackEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnApFallbackEnabled.setDescription('This flag specifies if the APs should continue LWAPP discoveries to fallback to the primary switch in case they are not already associated with it i.e they are associated with their respective secondary or tertiary switch instead.')
bsnAppleTalkEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAppleTalkEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnAppleTalkEnabled.setDescription('This flag turns on the appletalk bridging in the switch such that the packets from Apple clients that use appletalk format can be processed by the switch. When this flag is off, these packets are dropped.')
bsnTrustedApPolicyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40))
bsnPolicyForMisconfiguredAps = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("alarmOnly", 0), ("contain", 1))).clone('alarmOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnPolicyForMisconfiguredAps.setStatus('current')
if mibBuilder.loadTexts: bsnPolicyForMisconfiguredAps.setDescription('This flag should be turned on to allow the switch to contain misconfigured APs.')
bsnEncryptionPolicyEnforced = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("open", 1), ("wep", 2), ("wpa", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnEncryptionPolicyEnforced.setStatus('current')
if mibBuilder.loadTexts: bsnEncryptionPolicyEnforced.setDescription('The encryption policy that is enforced on the trusted APs.')
bsnPreamblePolicyEnforced = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("short", 1), ("long", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnPreamblePolicyEnforced.setStatus('current')
if mibBuilder.loadTexts: bsnPreamblePolicyEnforced.setDescription('The preamble policy that is enforced on the trusted APs.')
bsnDot11ModePolicyEnforced = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("dcfOnly", 1), ("pcfOnly", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11ModePolicyEnforced.setStatus('current')
if mibBuilder.loadTexts: bsnDot11ModePolicyEnforced.setDescription('The 802.11 Mode policy that is enforced on the trusted APs.')
bsnRadioTypePolicyEnforced = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("aOnly", 1), ("bOnly", 2), ("bgOnly", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRadioTypePolicyEnforced.setStatus('current')
if mibBuilder.loadTexts: bsnRadioTypePolicyEnforced.setDescription('The radio type policy that is enforced on the trusted APs.')
bsnValidateSsidForTrustedAp = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnValidateSsidForTrustedAp.setStatus('current')
if mibBuilder.loadTexts: bsnValidateSsidForTrustedAp.setDescription('If enabled, the SSID of trusted APs will be validated by the switch.')
bsnAlertIfTrustedApMissing = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAlertIfTrustedApMissing.setStatus('current')
if mibBuilder.loadTexts: bsnAlertIfTrustedApMissing.setDescription('If enabled, an alert will be generated when a trusted AP is missing.')
bsnTrustedApEntryExpirationTimeout = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 40, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(120, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnTrustedApEntryExpirationTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApEntryExpirationTimeout.setDescription('This attribute specifies in seconds, the time interval after which a Trusted AP Entry will expire if no beacon is heard from that AP.')
bsnClientExclusionPolicyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41))
bsnExcessive80211AssocFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExcessive80211AssocFailures.setStatus('current')
if mibBuilder.loadTexts: bsnExcessive80211AssocFailures.setDescription('This flag specifies if client should be excluded (blacklisted) if repeated 802.11 Association Failures occurs with a client.')
bsnExcessive80211AuthFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExcessive80211AuthFailures.setStatus('current')
if mibBuilder.loadTexts: bsnExcessive80211AuthFailures.setDescription('This flag specifies if client should be excluded (blacklisted) if repeated 802.11 Authentication Failures occurs with a client.')
bsnExcessive8021xAuthFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExcessive8021xAuthFailures.setStatus('current')
if mibBuilder.loadTexts: bsnExcessive8021xAuthFailures.setDescription('This flag specifies if client should be excluded (blacklisted) if repeated 802.1x Authentication Failures occurs with a client.')
bsnExternalPolicyServerFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExternalPolicyServerFailures.setStatus('current')
if mibBuilder.loadTexts: bsnExternalPolicyServerFailures.setDescription('This flag specifies if client should be excluded (blacklisted) if repeated external policy server failures occurs with a client.')
bsnExcessiveWebAuthFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExcessiveWebAuthFailures.setStatus('current')
if mibBuilder.loadTexts: bsnExcessiveWebAuthFailures.setDescription('This flag specifies if client should be excluded (blacklisted) if repeated Web Authentication Failures occurs with a client.')
bsnIPTheftORReuse = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 41, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnIPTheftORReuse.setStatus('current')
if mibBuilder.loadTexts: bsnIPTheftORReuse.setDescription('This flag specifies if client should be excluded (blacklisted) if it appears to be reusing an IP Address.(Possible IP Theft)')
bsnSignatureConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42))
bsnStandardSignatureTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1), )
if mibBuilder.loadTexts: bsnStandardSignatureTable.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureTable.setDescription('The table listing Standard Signatures configured on the switch. The standard signatures are provided with the released product. The standard signatures can be updated via file download to the switch. The table is indexed by the precedence of the signatures.')
bsnStandardSignatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePrecedence"))
if mibBuilder.loadTexts: bsnStandardSignatureEntry.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureEntry.setDescription('....')
bsnStandardSignaturePrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePrecedence.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePrecedence.setDescription('Precedence of the signature. This specifies the order in which the signature is applied to a packet.')
bsnStandardSignatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureName.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureName.setDescription('This attribute is used to configure the name on a signature.')
bsnStandardSignatureDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureDescription.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureDescription.setDescription('This attribute is used to configure the description of a signature.')
bsnStandardSignatureFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("management", 0), ("data", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureFrameType.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureFrameType.setDescription('This attribute specifies the type of frame that needs to match a signature.')
bsnStandardSignatureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("report", 1), ("contain", 2), ("exclude", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureAction.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureAction.setDescription('This attribute specifies the action to be taken once a packet is found to match a signature.')
bsnStandardSignatureState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureState.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureState.setDescription('This attribute specifies the state of a signature. It is used to match packets only if the state is enabled.')
bsnStandardSignatureFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnStandardSignatureFrequency.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureFrequency.setDescription('This specifies the frequency of the matching packets after which the specified action is taken.')
bsnStandardSignatureQuietTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnStandardSignatureQuietTime.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureQuietTime.setDescription('This specifies the quiet time in seconds during which no matching packets are found after which the attack is considered stopped.')
bsnStandardSignatureVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureVersion.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureVersion.setDescription('This specifies the signature version.')
bsnStandardSignatureConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pattern", 0), ("protocol", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureConfigType.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureConfigType.setDescription("This attribute specifies the type of Signature configuration. It's protocol when the protocol format is used in the UI to configure this. Pattern is the config type for all signatures in the released signature file and when signatures are configured using pattern format. Note: the signatures will be allowed to be i configured in later releases.")
bsnStandardSignatureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnStandardSignatureEnable.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureEnable.setDescription("This object configures the status of a particular standard signature on LWAPP APs, for use in performing signature analysis on the received 802.11 data and/or management frames. A value of 'true' makes the Controller send the 'Signature Add LWAPP Message' to all the joined APs with the status field set to 'enable'. This makes the joined APs perform signature analysis on the received 802.11 data and/or management frames and report the discrepancies observed, if any, to the Controller. A value of 'false' makes the Controller send the 'Signature Add LWAPP Message' to all the joined APs with the status field set to 'disable'. The joined APs doesn't perform the signature analysis on the received 802.11 data and/or management frames for this particular signature, till the signature is enabled. ")
bsnStandardSignatureMacInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 12), BsnTxtSignatureMacInfo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureMacInfo.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureMacInfo.setDescription('This object defines the pattern followed by the LWAPP APs to perform signature analysis with this Standard signature and report the results to the Controller. ')
bsnStandardSignatureMacFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnStandardSignatureMacFreq.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureMacFreq.setDescription('This object specifies the frequency of matching packets from a particular source after which the specified action is taken. ')
bsnStandardSignatureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 20), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignatureRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureRowStatus.setDescription(' Row Status for creation/deletion. Signature will allowed to be created, deleted and edited in later releases.')
bsnStandardSignatureInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnStandardSignatureInterval.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignatureInterval.setDescription('Interval of the signature. This specifies the interval when the signature is applied to a packet.')
bsnStandardSignaturePatternTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2), )
if mibBuilder.loadTexts: bsnStandardSignaturePatternTable.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternTable.setDescription('The table listing the matching patterns specified for a i Standard Signature. These are instrumental in matching the signature with a packet. A maximum of 5 i patterns may be specifed for a signature. These are used for matching in the order of their index.')
bsnStandardSignaturePatternEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePrecedence"), (0, "AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternIndex"))
if mibBuilder.loadTexts: bsnStandardSignaturePatternEntry.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternEntry.setDescription('....')
bsnStandardSignaturePatternIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternIndex.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternIndex.setDescription('Index of the pattern. This specifies the order in which the pattern is checked against the packet contents.')
bsnStandardSignaturePatternOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternOffset.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternOffset.setDescription('Offset from the start of the packet where the AP looks for a match to the pattern.')
bsnStandardSignaturePatternString = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 62))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternString.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternString.setDescription('This is the pattern string that the AP uses to match at the offset. Example: 0x616c7068615f3178')
bsnStandardSignaturePatternMask = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 62))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternMask.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternMask.setDescription('This is the pattern mask. This is the bit mask that the AP uses to mask out the bits in the packet at the given offset. Example: 0xffffffffffffffff')
bsnStandardSignaturePatternOffSetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 5), BsnSignaturePatternOffSetStart()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternOffSetStart.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternOffSetStart.setDescription('This object indicates how an offset should be applied while doing signature analysis for QOS and non-QOS data frames with this standard signature. ')
bsnStandardSignaturePatternRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 2, 1, 15), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnStandardSignaturePatternRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnStandardSignaturePatternRowStatus.setDescription('Row Status for creation/deletion. Signature Pattern will allowed to be created, deleted and edited in later releases.')
bsnCustomSignatureTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3), )
if mibBuilder.loadTexts: bsnCustomSignatureTable.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureTable.setDescription('The table listing Standard Signatures configured on the switch. The standard signatures are provided with the released product. The standard signatures can be updated via file download to the switch. The table is indexed by the precedence of the signatures.')
bsnCustomSignatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePrecedence"))
if mibBuilder.loadTexts: bsnCustomSignatureEntry.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureEntry.setDescription('....')
bsnCustomSignaturePrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePrecedence.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePrecedence.setDescription('Precedence of the signature. This specifies the order in which the signature is applied to a packet.')
bsnCustomSignatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureName.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureName.setDescription('This attribute is used to configure the name on a signature.')
bsnCustomSignatureDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureDescription.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureDescription.setDescription('This attribute is used to configure the description of a signature.')
bsnCustomSignatureFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("management", 0), ("data", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureFrameType.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureFrameType.setDescription('This attribute specifies the type of frame that needs to match a signature.')
bsnCustomSignatureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("report", 1), ("contain", 2), ("exclude", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureAction.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureAction.setDescription('This attribute specifies the action to be taken once a packet is found to match a signature.')
bsnCustomSignatureState = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureState.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureState.setDescription('This attribute specifies the state of a signature. It is used to match packets only if the state is enabled.')
bsnCustomSignatureFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnCustomSignatureFrequency.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureFrequency.setDescription('This specifies the frequency of the matching packets after which the specified action is taken.')
bsnCustomSignatureQuietTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnCustomSignatureQuietTime.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureQuietTime.setDescription('This specifies the quiet time in seconds during which no matching packets are found after which the attack is considered stopped.')
bsnCustomSignatureVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureVersion.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureVersion.setDescription('This specifies the signature version.')
bsnCustomSignatureConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pattern", 0), ("protocol", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureConfigType.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureConfigType.setDescription("This attribute specifies the type of Signature configuration. It's protocol when the protocol format is used in the UI to configure this. Pattern is the config type for all signatures in the released signature file and when signatures are configured using pattern format. Note: the signatures will be allowed to be configured in later releases.")
bsnCustomSignatureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnCustomSignatureEnable.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureEnable.setDescription("This object configures the status of a particular Custom signature on LWAPP APs, for use in performing signature analysis on the received 802.11 data and/or management frames. A value of 'true' makes the Controller send the 'Signature Add LWAPP Message' to all the joined APs with the status field set to 'enable'. This makes the joined APs perform signature analysis on the received 802.11 data and/or management frames and report the discrepancies observed, if any, to the Controller. A value of 'false' makes the Controller send the 'Signature Add LWAPP Message' to all the joined APs with the status field set to 'disable'. The joined APs doesn't perform the signature analysis on the received 802.11 data and/or management frames for this particular signature, till the signature is enabled. ")
bsnCustomSignatureMacInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 12), BsnTxtSignatureMacInfo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureMacInfo.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureMacInfo.setDescription('This object defines the pattern followed by the LWAPP APs to perform signature analysis with this Custom signature and report the results to the Controller. ')
bsnCustomSignatureMacFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnCustomSignatureMacFreq.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureMacFreq.setDescription('This object specifies the frequency of matching packets from a particular source after which the specified action is taken. ')
bsnCustomSignatureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 20), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignatureRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureRowStatus.setDescription('Row Status for creation/deletion. Signature will allowed to be created, deleted and edited in later releases.')
bsnCustomSignatureInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 3, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnCustomSignatureInterval.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignatureInterval.setDescription('Interval of the signature. This specifies the interval when the signature is applied to a packet.')
bsnCustomSignaturePatternTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4), )
if mibBuilder.loadTexts: bsnCustomSignaturePatternTable.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternTable.setDescription('The table listing the matching patterns specified for a Standard Signature. These are instrumental in matching the signature with a packet. A maximum of 5 patterns may be specifed for a signature. These are used for matching in the order of their index.')
bsnCustomSignaturePatternEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePrecedence"), (0, "AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternIndex"))
if mibBuilder.loadTexts: bsnCustomSignaturePatternEntry.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternEntry.setDescription('....')
bsnCustomSignaturePatternIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternIndex.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternIndex.setDescription('Index of the pattern. This specifies the order in which the pattern is checked against the packet contents.')
bsnCustomSignaturePatternOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternOffset.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternOffset.setDescription('Offset from the start of the packet where the AP looks for a match to the pattern.')
bsnCustomSignaturePatternString = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 62))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternString.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternString.setDescription('This is the pattern string that the AP uses to match at the offset. Example: 0x616c7068615f3178')
bsnCustomSignaturePatternMask = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 62))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternMask.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternMask.setDescription('This is the pattern mask. This is the bit mask that the AP uses to mask out the bits in the packet at the given offset. Example: 0xffffffffffffffff')
bsnCustomSignaturePatternOffSetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 5), BsnSignaturePatternOffSetStart()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternOffSetStart.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternOffSetStart.setDescription('This object indicates how an offset should be applied while doing signature analysis for QOS and non-QOS data frames with this custom signature. ')
bsnCustomSignaturePatternRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 4, 1, 15), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCustomSignaturePatternRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnCustomSignaturePatternRowStatus.setDescription(' Row Status for creation/deletion. Signature Pattern will allowed to be created, deleted and edited in later releases.')
bsnSignatureCheckState = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 42, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSignatureCheckState.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureCheckState.setDescription('This flag should be enabled to enforce check of all standard and custom signatures. If disabled, there will be no check for signatures, both custom and standard, by the switch.')
bsnRfIdTagConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 43))
bsnRfIdTagStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 43, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRfIdTagStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRfIdTagStatus.setDescription('This flag should be turned on to allow the switch to collect data for tags.')
bsnRfIdTagDataTimeout = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 43, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 7200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRfIdTagDataTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnRfIdTagDataTimeout.setDescription("This is the number of seconds after which the tag data is deleted by the switch from its database if it didn't hear from the tag again.")
bsnRfIdTagAutoTimeoutStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 43, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRfIdTagAutoTimeoutStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRfIdTagAutoTimeoutStatus.setDescription('This flag should be turned on to allow auto deletion of tag data in the switch after expiration of Tag Data Timeout')
bsnAPNeighborAuthConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 44))
bsnAPNeighborAuthStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 44, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPNeighborAuthStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPNeighborAuthStatus.setDescription('This flag should be turned on to allow the AP-Neighbor Authentication feature.')
bsnAPNeighborAuthAlarmThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 44, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPNeighborAuthAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnAPNeighborAuthAlarmThreshold.setDescription('Authentication alarm trigger threshold.')
bsnRFNetworkName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 45), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRFNetworkName.setStatus('current')
if mibBuilder.loadTexts: bsnRFNetworkName.setDescription('RF Network Group Name to which this Airespace Switch belongs. Airespace Switches on a network form a RF Network Group as well as a Mobility Group. RF Network Groups does the channel and power management of AP while Mobility Group does load balancing and hand off for clients.')
bsnFastSSIDChangeFeature = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnFastSSIDChangeFeature.setStatus('current')
if mibBuilder.loadTexts: bsnFastSSIDChangeFeature.setDescription('Configures Fast SSID changing feature for mobile-stations. When enabled, permits mobile-stations to change SSIDs without having to block and wait for SSID-cleanup on the switch to occur.')
bsnBridgingPolicyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 47))
bsnBridgingZeroTouchConfig = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 47, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnBridgingZeroTouchConfig.setStatus('current')
if mibBuilder.loadTexts: bsnBridgingZeroTouchConfig.setDescription('If enabled, allows new bridging APs to negotiate with the switch to acquire the shared secret key.')
bsnBridgingSharedSecretKey = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 47, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnBridgingSharedSecretKey.setStatus('current')
if mibBuilder.loadTexts: bsnBridgingSharedSecretKey.setDescription('Key that is used to negotiate a secure LWAPP connection between a switch and a bridging or mesh AP.')
bsnGlobalDot11b = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2))
bsnGlobalDot11a = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3))
bsnGlobalDot11h = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 4))
bsnGlobalDot11bConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1))
bsnGlobalDot11bNetworkStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bNetworkStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bNetworkStatus.setDescription('802.11b Network Admin Status.')
bsnGlobalDot11bBeaconPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bBeaconPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bBeaconPeriod.setDescription('This attribute shall specify the number of TU that a AP Radio shall use for scheduling Beacon tranmissions. This value is transmitted in Beacon and Probe Response frames.')
bsnGlobalDot11bDynamicChannelAssignment = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("runOnce", 2), ("static", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicChannelAssignment.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicChannelAssignment.setDescription('Dynamic channel assignment(DCA) has three modes. When the mode is auto, the channel assignment will be periodically updated for all Airespace APs that permit this operation. When the DCA is runOnce, channel assignments are updated based on the UPDATE_CMD received from the management. When the DCA is static, no dynamic channel assignments occurs and value are set to their global default. Default is auto.')
bsnGlobalDot11bCurrentChannel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bCurrentChannel.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCurrentChannel.setDescription('The current operating frequency channel of the DSSS PHY. Valid channel numbers are as defined in 15.4.6.2. This attribute will be read-only if bsnAPIfPhyChannelAutomaticOn is true.')
bsnGlobalDot11bDynamicChannelUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 5), Unsigned32().clone(600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicChannelUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicChannelUpdateInterval.setDescription('When Channel dynamic alogirthm is running, this interval (in secs) specifies how often Channel assignement updates are attempted on an Airespace AP. NOTE: hysteresis is built into the algorithms so we will not have uproductive changes occuring. Default value is 600 secs')
bsnGlobalDot11bInputsForDCA = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 6), Unsigned32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bInputsForDCA.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bInputsForDCA.setDescription('This attribute is a bit mask specifying what to include in DCA optimization.Below is a list of parameters and their corresponding bits identifiers. options bit -------------------------------------- none 0 SIGNAL STRENGTH 1 NOISE 2 FOREIGN INTERFERENCE 4 LOAD 8 DEVICE INTERFERENCE 32 Default value is 63( all bits on).')
bsnGlobalDot11bChannelUpdateCmdInvoke = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bChannelUpdateCmdInvoke.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bChannelUpdateCmdInvoke.setDescription('When set to activate this starts a DCA calculation regardless of the dynamic update interval. This command should be invoke on Group Leader Airespace Switch.Invoking on a Airespace Switch which is not a Group leader has no effect.')
bsnGlobalDot11bChannelUpdateCmdStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bChannelUpdateCmdStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bChannelUpdateCmdStatus.setDescription('After setting bsnGlobalDot11bChannelUpdateCmdInvoke to activate, the result of action can be monitored from here. It takes 5 minutes for the command to complete.')
bsnGlobalDot11bDynamicTransmitPowerControl = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("runOnce", 2), ("static", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicTransmitPowerControl.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicTransmitPowerControl.setDescription('Dynamic transmit power (DTP) has three modes. When the mode is auto, the transmit power of each Airespace AP will be periodically updated for all Airespace APs that permit this operation. When the DTP is runOnce,transmit power update will occur based on the UPDATE_CMD received from the management. When the DTP is static, no dynamic transmit power updates occur and their global defaults are used. Default is auto.')
bsnGlobalDot11bDynamicTxPowerControlInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 10), Unsigned32().clone(600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicTxPowerControlInterval.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDynamicTxPowerControlInterval.setDescription('When Tx PowerControl dynamic alogirthm is running, this interval(in secs) specifies how often TxPower control updates are attempted on an Airespace AP. NOTE: hysteresis is build into the algorithms so we will not have uproductive changes occuring. Default value is 600 secs')
bsnGlobalDot11bCurrentTxPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bCurrentTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCurrentTxPowerLevel.setDescription('The TxPowerLevel N currently being used to transmit data. Some PHYs also use this value to determine the receiver sensitivity requirements for CCA.')
bsnGlobalDot11bInputsForDTP = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 12), Unsigned32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bInputsForDTP.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bInputsForDTP.setDescription('This attribute is a bit mask specifying what to include in DCA optimization.Below is a list of parameters and their corresponding bits identifiers. options bit -------------------------------------- none 0 LOAD 1 SIGNAL STRENGTH 2 FOREIGN INTERFERENCE 4 NOISE 8 Default value is 15( all bits on).')
bsnGlobalDot11bPowerUpdateCmdInvoke = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bPowerUpdateCmdInvoke.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bPowerUpdateCmdInvoke.setDescription('When set to activate this starts a DTP calculation regardless of the dynamic update interval. This command should be invoke on Group Leader Airespace Switch.Invoking on a Airespace Switch which is not a Group leader has no effect.')
bsnGlobalDot11bPowerUpdateCmdStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bPowerUpdateCmdStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bPowerUpdateCmdStatus.setDescription('After setting bsnGlobalDot11aChannelUpdateCmdInvoke to activate, the result of action can be monitored from here. It takes 5 minutes for the command to complete.')
bsnGlobalDot11bDataRate1Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate1Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate1Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11bDataRate2Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate2Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate2Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11bDataRate5AndHalfMhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate5AndHalfMhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate5AndHalfMhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11bDataRate11Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate11Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate11Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11bShortPreamble = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bShortPreamble.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bShortPreamble.setDescription('802.11b Short Preamble.')
bsnGlobalDot11bDot11gSupport = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDot11gSupport.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDot11gSupport.setDescription('This attribute is enabled to also support 802.11g protocol on the 802.11b network. Enabling 802.11g allows additional data rates: 6, 9, 12, 18, 24, 36, 48, 54 Mbps.')
bsnGlobalDot11bDataRate6Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate6Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate6Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate9Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate9Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate9Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate12Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate12Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate12Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate18Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate18Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate18Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate24Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate24Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate24Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate36Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate36Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate36Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate48Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate48Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate48Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bDataRate54Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate54Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDataRate54Mhz.setDescription('Specify if this rate is supported or mandatory or disabled. This is configurable only if 802.11g support is enabled.')
bsnGlobalDot11bPicoCellMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bPicoCellMode.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bPicoCellMode.setDescription('Configures the 802.11b pico-cell mode. This cannot be enabled when the Fast Roaming Mode is enabled.')
bsnGlobalDot11bFastRoamingMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingMode.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingMode.setDescription('Configures the 802.11b fast-roaming mode. This cannot be enabled when the Pico Cell Mode is enabled.')
bsnGlobalDot11bFastRoamingVoipMinRate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 0), ("rate1Mbps", 1), ("rate2Mbps", 2), ("rate5andHalfMbps", 3), ("rate11Mbps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingVoipMinRate.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingVoipMinRate.setDescription('Configures the minimum transmission rate allowed for VoIP on any 802.11b radio.')
bsnGlobalDot11bFastRoamingVoipPercentage = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("twentyfive", 2), ("fifty", 3), ("seventyfive", 4), ("hundred", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingVoipPercentage.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bFastRoamingVoipPercentage.setDescription('Configures the percentage of effective bandwidth for the minimum rate reserved for VoIP.')
bsnGlobalDot11b80211eMaxBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11b80211eMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11b80211eMaxBandwidth.setDescription('This represents the maximum bandwidth allocated to 802.11e clients. It is expressed as percentage of the total bandwidth of 802.11b network. The value of this attribute can vary from 0 to 100.')
bsnGlobalDot11bDTPCSupport = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDTPCSupport.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDTPCSupport.setDescription("This attribute may be used to enable the DTPC support on all 802.11b/g radios. DTPC or Dynamic Transmit Power Control support means that the radio's transmit power will be advertised in the beacons and probe responses.")
bsnGlobalDot11bRxSopThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("auto", 0), ("low", 1), ("medium", 2), ("high", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bRxSopThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bRxSopThreshold.setDescription('Configures the global 802.11b receiver start of packet threshold.')
bsnGlobalDot11bPhy = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2))
bsnGlobalDot11bMediumOccupancyLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bMediumOccupancyLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bMediumOccupancyLimit.setDescription('This attribute shall indicate the maximum amount of time, in TU, that a point coordinator may control the usage of the wireless medium without relinquishing control for long enough to allow at least one instance of DCF access to the medium. The default value of this attribute shall be 100, and the maximum value shall be 1000.')
bsnGlobalDot11bCFPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bCFPPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCFPPeriod.setDescription('The attribute shall describe the number of DTIM intervals between the start of CFPs. It is modified by MLME-START.request primitive.')
bsnGlobalDot11bCFPMaxDuration = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bCFPMaxDuration.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCFPMaxDuration.setDescription('The attribute shall describe the maximum duration of the CFP in TU that may be generated by the PCF. It is modified by MLME-START.request primitive.')
bsnGlobalDot11bCFPollable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bCFPollable.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCFPollable.setDescription('When this attribute is true, it shall indicate that the STA is able to respond to a CF-Poll with a data frame within a SIFS time. This attribute shall be false if the STA is not able to respond to a CF-Poll with a data frame within a SIFS time.')
bsnGlobalDot11bCFPollRequest = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bCFPollRequest.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bCFPollRequest.setDescription('Specifies wheather CFP')
bsnGlobalDot11bDTIMPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bDTIMPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bDTIMPeriod.setDescription('This attribute shall specify the number of beacon intervals that shall elapse between transmission of Beacons frames containing a TIM element whose DTIM Count field is 0. This value is transmitted in the DTIM Period field of Beacon frames.')
bsnGlobalDot11bMaximumTransmitPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bMaximumTransmitPowerLevel.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11bMaximumTransmitPowerLevel.setDescription('This attribute shall indicate the maximum transmit power, in dBm, allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11bFirstChannelNumber = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bFirstChannelNumber.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11bFirstChannelNumber.setDescription('This attribute shall indicate the value of the lowest channel number in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11bNumberofChannels = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bNumberofChannels.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11bNumberofChannels.setDescription('This attribute shall indicate the value of the total number of channels allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11bRTSThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2347))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bRTSThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bRTSThreshold.setDescription('This attribute shall indicate the number of octets in an MPDU, below which an RTS/CTS handshake shall not be performed. An RTS/CTS handshake shall be performed at the beginning of any frame exchange sequence where the MPDU is of type Data or Management, the MPDU has an individual address in the Address1 field, and the length of the MPDU is greater than this threshold. (For additional details, refer to Table 21 in 9.7.) Setting this attribute to be larger than the maximum MSDU size shall have the effect of turning off the RTS/CTS handshake for frames of Data or Management type transmitted by this STA. Setting this attribute to zero shall have the effect of turning on the RTS/CTS handshake for all frames of Data or Management type transmitted by this STA. The default value of this attribute shall be 2347.')
bsnGlobalDot11bShortRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bShortRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bShortRetryLimit.setDescription('This attribute shall indicate the maximum number of transmission attempts of a frame, the length of which is less than or equal to bsnGlobalDot11RTSThreshold, that shall be made before a failure condition is indicated. The default value of this attribute shall be 7.')
bsnGlobalDot11bLongRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bLongRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bLongRetryLimit.setDescription('This attribute shall indicate the maximum number of transmission attempts of a frame, the length of which is greater than bsnGlobalDot11RTSThreshold, that shall be made before a failure condition is indicated. The default value of this attribute shall be 4.')
bsnGlobalDot11bFragmentationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 2346))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11bFragmentationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bFragmentationThreshold.setDescription('This attribute shall specify the current maximum size, in octets, of the MPDU that may be delivered to the PHY. An MSDU shall be broken into fragments if its size exceeds the value of this attribute after adding MAC headers and trailers. An MSDU or MMPDU shall be fragmented when the resulting frame has individual address in the Address1 field, and the length of the frame is larger than this threshold. The default value for this attribute shall be the lesser of 2346 or the aMPDUMaxLength of the attached PHY and shall never exceed the lesser of 2346 or the aMPDUMaxLength of the attached PHY. The value of this attribute shall never be less than 256. ')
bsnGlobalDot11bMaxTransmitMSDULifetime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bMaxTransmitMSDULifetime.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bMaxTransmitMSDULifetime.setDescription('The MaxTransmitMSDULifetime shall be the elapsed time in TU, after the initial transmission of an MSDU, after which further attempts to transmit the MSDU shall be terminated. The default value of this attribute shall be 512.')
bsnGlobalDot11bMaxReceiveLifetime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bMaxReceiveLifetime.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bMaxReceiveLifetime.setDescription('The MaxReceiveLifetime shall be the elapsed time in TU, after the initial reception of a fragmented MMPDU or MSDU, after which further attempts to reassemble the MMPDU or MSDU shall be terminated. The default value shall be 512.')
bsnGlobalDot11bEDThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bEDThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bEDThreshold.setDescription('The current Energy Detect Threshold being used by the DSSS PHY.')
bsnGlobalDot11bChannelAgilityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bChannelAgilityEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bChannelAgilityEnabled.setDescription('This attribute indicates that the PHY channel agility functionality is enabled.')
bsnGlobalDot11bPBCCOptionImplemented = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bPBCCOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bPBCCOptionImplemented.setDescription('This attribute, when true, shall indicate that the PBCC modulation option as defined in subclause 18.4.6.6 is implemented. The default value of this attribute shall be false.')
bsnGlobalDot11bShortPreambleOptionImplemented = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 2, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11bShortPreambleOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11bShortPreambleOptionImplemented.setDescription('This attribute, when true, shall indicate that the short preamble option as defined in subclause 18.2.2.2 is implemented. The default value of this attribute shall be false.')
bsnGlobalDot11aConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1))
bsnGlobalDot11aNetworkStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aNetworkStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aNetworkStatus.setDescription('Dot11a Network Status')
bsnGlobalDot11aLowBandNetwork = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aLowBandNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aLowBandNetwork.setDescription('Dot11a Low Band Network Status')
bsnGlobalDot11aMediumBandNetwork = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aMediumBandNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aMediumBandNetwork.setDescription('Dot11a Mid Band Network Status')
bsnGlobalDot11aHighBandNetwork = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aHighBandNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aHighBandNetwork.setDescription('Dot11a High Band Network Status')
bsnGlobalDot11aBeaconPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aBeaconPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aBeaconPeriod.setDescription('This attribute shall specify the number of TU that a AP Radio shall use for scheduling Beacon tranmissions. This value is transmitted in Beacon and Probe Response frames.')
bsnGlobalDot11aDynamicChannelAssignment = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("runOnce", 2), ("static", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicChannelAssignment.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicChannelAssignment.setDescription('Dynamic channel assignment(DCA) has three modes. When the mode is auto, the channel assignment will be periodically updated for all Airespace APs that permit this operation. When the DCA is runOnce, channel assignments are updated based on the UPDATE_CMD received from the management. When the DCA is static, no dynamic channel assignments occurs and value are set to their global default. Default is auto.')
bsnGlobalDot11aCurrentChannel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aCurrentChannel.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCurrentChannel.setDescription('The number of the current operating frequency channel of the OFDM PHY.')
bsnGlobalDot11aDynamicChannelUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 8), Unsigned32().clone(600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicChannelUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicChannelUpdateInterval.setDescription('When Channel dynamic alogirthm is running, this interval(in secs) specifies how often Channel assignement updates are attempted on an Airespace AP. NOTE: hysteresis is build into the algorithms so we will not have uproductive changes occuring. Default value is 600 secs')
bsnGlobalDot11aInputsForDCA = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 9), Unsigned32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aInputsForDCA.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aInputsForDCA.setDescription('This attribute is a bit mask specifying what to include in DCA optimization.Below is a list of parameters and their corresponding bits identifiers. options bit -------------------------------------- none 0 SIGNAL STRENGTH 1 NOISE 2 FOREIGN INTERFERENCE 4 LOAD 8 DEVICE INTERFERENCE 32 Default value is 63( all bits on).')
bsnGlobalDot11aChannelUpdateCmdInvoke = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aChannelUpdateCmdInvoke.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aChannelUpdateCmdInvoke.setDescription('When set to activate this starts a DCA calculation regardless of the dynamic update interval. This command should be invoke on Group Leader Airespace Switch.Invoking on a Airespace Switch which is not a Group leader has no effect.')
bsnGlobalDot11aChannelUpdateCmdStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aChannelUpdateCmdStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aChannelUpdateCmdStatus.setDescription('After setting bsnGlobalDot11aChannelUpdateCmdInvoke to activate, the result of action can be monitored from here. It takes 5 minutes for the command to complete.')
bsnGlobalDot11aDynamicTransmitPowerControl = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("runOnce", 2), ("static", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicTransmitPowerControl.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicTransmitPowerControl.setDescription('Dynamic transmit power (DTP) has three modes. When the mode is auto, the transmit power of each Airespace AP will be periodically updated for all Airespace APs that permit this operation. When the DTP is runOnce,transmit power update will occur based on the UPDATE_CMD received from the management. When the DTP is static, no dynamic transmit power updates occur and their global defaults are used. Default is auto.')
bsnGlobalDot11aCurrentTxPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aCurrentTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCurrentTxPowerLevel.setDescription('The TxPowerLevel N currently being used to transmit data. Some PHYs also use this value to determine the receiver sensitivity requirements for CCA.')
bsnGlobalDot11aDynamicTxPowerControlInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 14), Unsigned32().clone(600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicTxPowerControlInterval.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDynamicTxPowerControlInterval.setDescription('When Tx PowerControl dynamic alogirthm is running, this interval(in secs) specifies how often TxPower control updates are attempted on an Airespace AP. NOTE: hysteresis is build into the algorithms so we will not have uproductive changes occuring. Default value is 600 secs')
bsnGlobalDot11aInputsForDTP = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 15), Unsigned32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aInputsForDTP.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aInputsForDTP.setDescription('This attribute is a bit mask specifying what to include in DCA optimization.Below is a list of parameters and their corresponding bits identifiers. options bit -------------------------------------- none 0 LOAD 1 SIGNAL STRENGTH 2 FOREIGN INTERFERENCE 4 NOISE 8 Default value is 15( all bits on).')
bsnGlobalDot11aPowerUpdateCmdInvoke = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aPowerUpdateCmdInvoke.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aPowerUpdateCmdInvoke.setDescription('When set to activate this starts a DTP calculation regardless of the dynamic update interval. This command should be invoke on Group Leader Airespace Switch.Invoking on a Airespace Switch which is not a Group leader has no effect.')
bsnGlobalDot11aPowerUpdateCmdStatus = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aPowerUpdateCmdStatus.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aPowerUpdateCmdStatus.setDescription('After setting bsnGlobalDot11aChannelUpdateCmdInvoke to activate, the result of action can be monitored from here. It takes 5 minutes for the command to complete.')
bsnGlobalDot11aDataRate6Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate6Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate6Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate9Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate9Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate9Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate12Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate12Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate12Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate18Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate18Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate18Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate24Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate24Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate24Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate36Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate36Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate36Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate48Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate48Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate48Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aDataRate54Mhz = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("supported", 1), ("mandatory", 2), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate54Mhz.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDataRate54Mhz.setDescription('Specify if this rate is supported or mandatory or disabled')
bsnGlobalDot11aPicoCellMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aPicoCellMode.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aPicoCellMode.setDescription('Configures the 802.11a pico-cell mode. This cannot be enabled when the Fast Roaming Mode is enabled.')
bsnGlobalDot11aFastRoamingMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingMode.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingMode.setDescription('Configures the 802.11a fast-roaming mode. This cannot be enabled when the Pico Cell Mode is enabled.')
bsnGlobalDot11aFastRoamingVoipMinRate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 0), ("rate1Mbps", 1), ("rate2Mbps", 2), ("rate5andHalfMbps", 3), ("rate11Mbps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingVoipMinRate.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingVoipMinRate.setDescription('Configures the minimum transmission rate allowed for VoIP on any 802.11a radio.')
bsnGlobalDot11aFastRoamingVoipPercentage = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("zero", 1), ("twentyfive", 2), ("fifty", 3), ("seventyfive", 4), ("hundred", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingVoipPercentage.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aFastRoamingVoipPercentage.setDescription('Configures the percentage of effective bandwidth for the minimum rate reserved for VoIP.')
bsnGlobalDot11a80211eMaxBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11a80211eMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11a80211eMaxBandwidth.setDescription('This represents the maximum bandwidth allocated to 802.11e clients. It is expressed as percentage of the total bandwidth of 802.11a network. The value of this attribute can vary from 0 to 100.')
bsnGlobalDot11aDTPCSupport = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDTPCSupport.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDTPCSupport.setDescription("This attribute may be used to enable the DTPC support on all 802.11a radios. DTPC or Dynamic Transmit Power Control support means that the radio's transmit power will be advertised in the beacons and probe responses.")
bsnGlobalDot11aRxSopThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("auto", 0), ("low", 1), ("medium", 2), ("high", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aRxSopThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aRxSopThreshold.setDescription('Configures the global 802.11a receiver start of packet threshold.')
bsnGlobalDot11aPhy = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2))
bsnGlobalDot11aMediumOccupancyLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aMediumOccupancyLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aMediumOccupancyLimit.setDescription('This attribute shall indicate the maximum amount of time, in TU, that a point coordinator may control the usage of the wireless medium without relinquishing control for long enough to allow at least one instance of DCF access to the medium. The default value of this attribute shall be 100, and the maximum value shall be 1000.')
bsnGlobalDot11aCFPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aCFPPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCFPPeriod.setDescription('The attribute shall describe the number of DTIM intervals between the start of CFPs. It is modified by MLME-START.request primitive.')
bsnGlobalDot11aCFPMaxDuration = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aCFPMaxDuration.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCFPMaxDuration.setDescription('The attribute shall describe the maximum duration of the CFP in TU that may be generated by the PCF. It is modified by MLME-START.request primitive.')
bsnGlobalDot11aCFPollable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aCFPollable.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCFPollable.setDescription('When this attribute is true, it shall indicate that the STA is able to respond to a CF-Poll with a data frame within a SIFS time. This attribute shall be false if the STA is not able to respond to a CF-Poll with a data frame within a SIFS time.')
bsnGlobalDot11aCFPollRequest = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aCFPollRequest.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aCFPollRequest.setDescription('Specifies whether CFP')
bsnGlobalDot11aDTIMPeriod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aDTIMPeriod.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aDTIMPeriod.setDescription('This attribute shall specify the number of beacon intervals that shall elapse between transmission of Beacons frames containing a TIM element whose DTIM Count field is 0. This value is transmitted in the DTIM Period field of Beacon frames.')
bsnGlobalDot11aMaximumTransmitPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aMaximumTransmitPowerLevel.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11aMaximumTransmitPowerLevel.setDescription('This attribute shall indicate the maximum transmit power, in dBm, allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11aFirstChannelNumber = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aFirstChannelNumber.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11aFirstChannelNumber.setDescription('This attribute shall indicate the value of the lowest channel number in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11aNumberofChannels = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aNumberofChannels.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11aNumberofChannels.setDescription('This attribute shall indicate the value of the total number of channels allowed in the subband for the associated domain country string. The default value of this attribute shall be zero.')
bsnGlobalDot11aRTSThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2347))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aRTSThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aRTSThreshold.setDescription('This attribute shall indicate the number of octets in an MPDU, below which an RTS/CTS handshake shall not be performed. An RTS/CTS handshake shall be performed at the beginning of any frame exchange sequence where the MPDU is of type Data or Management, the MPDU has an individual address in the Address1 field, and the length of the MPDU is greater than this threshold. (For additional details, refer to Table 21 in 9.7.) Setting this attribute to be larger than the maximum MSDU size shall have the effect of turning off the RTS/CTS handshake for frames of Data or Management type transmitted by this STA. Setting this attribute to zero shall have the effect of turning on the RTS/CTS handshake for all frames of Data or Management type transmitted by this STA. The default value of this attribute shall be 2347.')
bsnGlobalDot11aShortRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aShortRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aShortRetryLimit.setDescription('This attribute shall indicate the maximum number of transmission attempts of a frame, the length of which is less than or equal to bsnGlobalDot11RTSThreshold, that shall be made before a failure condition is indicated. The default value of this attribute shall be 7.')
bsnGlobalDot11aLongRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aLongRetryLimit.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aLongRetryLimit.setDescription('This attribute shall indicate the maximum number of transmission attempts of a frame, the length of which is greater than bsnGlobalDot11RTSThreshold, that shall be made before a failure condition is indicated. The default value of this attribute shall be 4.')
bsnGlobalDot11aFragmentationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 2346))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11aFragmentationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aFragmentationThreshold.setDescription('This attribute shall specify the current maximum size, in octets, of the MPDU that may be delivered to the PHY. An MSDU shall be broken into fragments if its size exceeds the value of this attribute after adding MAC headers and trailers. MSDU or MMPDU shall be fragmented when the resulting frame has an individual address in the Address1 field, and the length of the frame is larger than this threshold. The default value for this attribute shall be the lesser of 2346 or the aMPDUMaxLength of the attached PHY and shall never exceed the lesser of 2346 or the aMPDUMaxLength of the attached PHY. The value of this attribute shall never be less than 256. ')
bsnGlobalDot11aMaxTransmitMSDULifetime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aMaxTransmitMSDULifetime.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aMaxTransmitMSDULifetime.setDescription('The MaxTransmitMSDULifetime shall be the elapsed time in TU, after the initial transmission of an MSDU, after which further attempts to transmit the MSDU shall be terminated. The default value of this attribute shall be 512.')
bsnGlobalDot11aMaxReceiveLifetime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aMaxReceiveLifetime.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aMaxReceiveLifetime.setDescription('The MaxReceiveLifetime shall be the elapsed time in TU, after the initial reception of a fragmented MMPDU or MSDU, after which further attempts to reassemble the MMPDU or MSDU shall be terminated. The default value shall be 512.')
bsnGlobalDot11aTIThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aTIThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aTIThreshold.setDescription('The Threshold being used to detect a busy medium (frequency). CCA shall report a busy medium upon detecting the RSSI above this threshold.')
bsnGlobalDot11aChannelAgilityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 3, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGlobalDot11aChannelAgilityEnabled.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11aChannelAgilityEnabled.setDescription('This attribute indicates that the PHY channel agility functionality is enabled.')
bsnGlobalDot11hConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 3, 4, 1))
bsnGlobalDot11hPowerConstraint = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('decibels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11hPowerConstraint.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11hPowerConstraint.setDescription('Local maximum transmit power for a channel is defined as maximum transmit power level specified for the channel in the Country element minus the local power constraint specified for the channel in the Power Constraint element.The power constraint is coded as an unsigned integer in units of decibels. To disable power constraint set Power Constraint to 0.')
bsnGlobalDot11hChannelSwitchEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11hChannelSwitchEnable.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11hChannelSwitchEnable.setDescription('To enable or disable channel switch. When disabling Channel Switch no need to pass mode and count ')
bsnGlobalDot11hChannelSwitchMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("loud", 0), ("quiet", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnGlobalDot11hChannelSwitchMode.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11hChannelSwitchMode.setDescription(' The Channel Switch Mode indicates any restriction on transmission until a channel switch. An Channel mode set to 1 means that the STA in a BSS to which the frame containing the element is addressed shall tranmit no further frames with in the BSS until the scheduled channel switch. A Channel switch mode set to 0 does not impose any requirement on the receiving STA.')
bsnRrmDot11a = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1))
bsnRrmDot11b = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2))
bsnRrmDot11aGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1))
bsnRrmDot11aGlobalAutomaticGrouping = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("off", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aGlobalAutomaticGrouping.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11aGlobalAutomaticGrouping.setDescription("Dynamic grouping has two modes: on and off. When the grouping is off, no dynamic grouping occurs. Each Airespace Switch optimizes only its own Airespace APs' parameters. When grouping is on, the Airespace Switches form groups and elect leaders to perform better dynamic parameter optimization.")
bsnRrmDot11aGroupLeaderMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11aGroupLeaderMacAddr.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11aGroupLeaderMacAddr.setDescription('This is the MAC address of the group leader for the dot11a group containing this Airespace Switch.')
bsnRrmIsDot11aGroupLeader = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmIsDot11aGroupLeader.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmIsDot11aGroupLeader.setDescription('If this Airespace Switch is a Dot11a Group Leader then this attribute will be true else it will be false.')
bsnRrmDot11aGroupLastUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11aGroupLastUpdateTime.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11aGroupLastUpdateTime.setDescription('Last time the dot11a grouping was updated on this Airespace Switch. This is valid only if the Airespace Switch is a group leader.')
bsnRrmDot11aGlobalGroupInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 5), Unsigned32().clone(3600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11aGlobalGroupInterval.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11aGlobalGroupInterval.setDescription('When grouping is on, this interval(in secs) represents the period with which the grouping algorithm is run. Grouping algorithm will also run when the group contents changes and the automatic grouping is enabled. A dynamic grouping can be started upon request from the system administrator. Default value is 3600 secs.')
bsnWrasDot11aGroupTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 9), )
if mibBuilder.loadTexts: bsnWrasDot11aGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11aGroupTable.setDescription('This is a table of Airespace Switch addresses that identifies the members of the Dot11a RF group containing this Airespace Switch. Max size is 20 entries.This has been deprecated for clrRrmDot11BandGrpMemberTable.')
bsnWrasDot11aGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnWrasDot11aPeerMacAddress"))
if mibBuilder.loadTexts: bsnWrasDot11aGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11aGroupEntry.setDescription(' ... ')
bsnWrasDot11aPeerMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 9, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasDot11aPeerMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11aPeerMacAddress.setDescription('The MAC address of the member Switch.')
bsnWrasDot11aPeerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 1, 9, 1, 21), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasDot11aPeerIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11aPeerIpAddress.setDescription('The IP address of the Airespace Switch.')
bsnRrmDot11aAPDefault = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6))
bsnRrmDot11aForeignInterferenceThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aForeignInterferenceThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aForeignInterferenceThreshold.setDescription('foreign 802.11A interference threshold between 0 and 100 percent.')
bsnRrmDot11aForeignNoiseThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aForeignNoiseThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aForeignNoiseThreshold.setDescription('802.11A foreign noise threshold between -127 and 0 dBm.')
bsnRrmDot11aRFUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aRFUtilizationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aRFUtilizationThreshold.setDescription('802.11A RF utlization threshold between 0 and 100 percent.')
bsnRrmDot11aThroughputThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aThroughputThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aThroughputThreshold.setDescription('802.11A throughput threshold between 1000 and 100000')
bsnRrmDot11aMobilesThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aMobilesThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aMobilesThreshold.setDescription('802.11A mobiles threshold between 1 and 75')
bsnRrmDot11aCoverageThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aCoverageThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aCoverageThreshold.setDescription('802.11A coverage threshold between 3 and 50.')
bsnRrmDot11aMobileMinExceptionLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aMobileMinExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aMobileMinExceptionLevel.setDescription('802.11A mobile minimum exception level between 1 and 75')
bsnRrmDot11aCoverageExceptionLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aCoverageExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aCoverageExceptionLevel.setDescription('802.11A coverage exception level between 0 and 100 percent.')
bsnRrmDot11aSignalMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aSignalMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aSignalMeasurementInterval.setDescription('This interval (in secs) specifies how often do we get new signal strength measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11aNoiseMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aNoiseMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aNoiseMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new noise and interference measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11aLoadMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aLoadMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aLoadMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new load measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11aCoverageMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aCoverageMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aCoverageMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new coverage measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11aChannelMonitorList = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("country", 2), ("dca", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aChannelMonitorList.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aChannelMonitorList.setDescription('This attribute specifies the channels on which the switch monitors noise, interference and rogues. The first option allows monitoring on all channels while the second one on only those that are supported by the country of operation. the option dca implies that the monitor channel list will include those channels that are used by automatic channel assignment.')
bsnRrmDot11aSetFactoryDefault = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11aSetFactoryDefault.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aSetFactoryDefault.setDescription('When set to activate all rrm parameters are reset to factory defaults')
bsnRrmDot11bGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1))
bsnRrmDot11bGlobalAutomaticGrouping = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("off", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bGlobalAutomaticGrouping.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11bGlobalAutomaticGrouping.setDescription("Dynamic grouping has two modes: on and off. When the grouping is off, no dynamic grouping occurs. Each Airespace Switch optimizes only its own Airespace APs' parameters. When grouping is on, the Airespace Switchs form groups and elect leaders to perform better dynamic parameter optimization.This has been deprecated for clrRrmDot11BandGrpTable.")
bsnRrmDot11bGroupLeaderMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11bGroupLeaderMacAddr.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11bGroupLeaderMacAddr.setDescription('This is the MAC address of the group leader for the dot11b group containing this Airespace Switch.This has been deprecated for clrRrmDot11BandGrpTable.')
bsnRrmIsDot11bGroupLeader = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmIsDot11bGroupLeader.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmIsDot11bGroupLeader.setDescription('If this Airespace Switch is a Dot11b Group Leader then this attribute will be true else it will be false.This has been deprecated for clrRrmDot11BandGrpTable.')
bsnRrmDot11bGroupLastUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11bGroupLastUpdateTime.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11bGroupLastUpdateTime.setDescription('Last time the dot11b grouping was updated on this Airespace Switch. This is valid only if the Airespace Switch is a group leader.This has been deprecated for clrRrmDot11BandGrpTable.')
bsnRrmDot11bGlobalGroupInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 5), Unsigned32().clone(3600)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRrmDot11bGlobalGroupInterval.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRrmDot11bGlobalGroupInterval.setDescription('When grouping is on, this interval(in secs) represents the period with which the grouping algorithm is run. Grouping algorithm will also run when the group contents changes and the automatic grouping is enabled. A dynamic grouping can be started upon request from the system administrator. Default value is 3600 secs.This has been deprecated for clrRrmDot11BandGrpTable.')
bsnWrasDot11bGroupTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 9), )
if mibBuilder.loadTexts: bsnWrasDot11bGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11bGroupTable.setDescription('This is a table of Airespace Switch addresses that identifies the members of the Dot11b RF group containing this Airespace Switch. Max size is 20 entries.This has been deprecated for clrRrmDot11BandGrpMemberTable.')
bsnWrasDot11bGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnWrasDot11bPeerMacAddress"))
if mibBuilder.loadTexts: bsnWrasDot11bGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11bGroupEntry.setDescription(' ... ')
bsnWrasDot11bPeerMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 9, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasDot11bPeerMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11bPeerMacAddress.setDescription('The MAC address of the GIGE interface.')
bsnWrasDot11bPeerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 1, 9, 1, 21), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasDot11bPeerIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDot11bPeerIpAddress.setDescription('The IP address of the Airespace Switch.')
bsnRrmDot11bAPDefault = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6))
bsnRrmDot11bForeignInterferenceThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bForeignInterferenceThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bForeignInterferenceThreshold.setDescription('Foreign 802.11A interference threshold between 0 and 100 percent.')
bsnRrmDot11bForeignNoiseThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bForeignNoiseThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bForeignNoiseThreshold.setDescription('802.11A foreign noise threshold between -127 and 0 dBm.')
bsnRrmDot11bRFUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bRFUtilizationThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bRFUtilizationThreshold.setDescription('802.11A RF utlization threshold between 0 and 100 percent.')
bsnRrmDot11bThroughputThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bThroughputThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bThroughputThreshold.setDescription('802.11A Airespace AP data-rate threshold between 1000 and 100000')
bsnRrmDot11bMobilesThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bMobilesThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bMobilesThreshold.setDescription('802.11A Airespace AP mobiles threshold between 1 and 75')
bsnRrmDot11bCoverageThreshold = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bCoverageThreshold.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bCoverageThreshold.setDescription('802.11A Airespace AP coverage threshold between 3 and 50.')
bsnRrmDot11bMobileMinExceptionLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bMobileMinExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bMobileMinExceptionLevel.setDescription('802.11A Airespace AP mobile minimum exception level between 1 and 75')
bsnRrmDot11bCoverageExceptionLevel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bCoverageExceptionLevel.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bCoverageExceptionLevel.setDescription('802.11A Airespace AP coverage exception level between 0 and 100 percent.')
bsnRrmDot11bSignalMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bSignalMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bSignalMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new signal strength measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11bNoiseMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bNoiseMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bNoiseMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new noise and interference measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11bLoadMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bLoadMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bLoadMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new load measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11bCoverageMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bCoverageMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bCoverageMeasurementInterval.setDescription('This interval( in secs) specifies how often do we get new coverage measurements at each Airespace AP. Default is 300 secs')
bsnRrmDot11bChannelMonitorList = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("country", 2), ("dca", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bChannelMonitorList.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bChannelMonitorList.setDescription('This attribute specifies the channels on which the switch monitors noise, interference and rogues. The first option allows monitoring on all channels while the second one on only those that are supported by the country of operation. the option dca implies that the monitor channel list will include those channels that are used by automatic channel assignment.')
bsnRrmDot11bSetFactoryDefault = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 4, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRrmDot11bSetFactoryDefault.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bSetFactoryDefault.setDescription('When set to activate all rrm parameters are reset to factory defaults')
bsnRadiusAuthServerTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1), )
if mibBuilder.loadTexts: bsnRadiusAuthServerTable.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerTable.setDescription('The (conceptual) table listing the RADIUS authentication servers with which the client shares a secret.')
bsnRadiusAuthServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIndex"))
if mibBuilder.loadTexts: bsnRadiusAuthServerEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerEntry.setDescription('An entry (conceptual row) representing a RADIUS authentication server with which the client shares a secret.')
bsnRadiusAuthServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIndex.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIndex.setDescription('A number uniquely identifying each RADIUS Authentication server with which this client communicates.')
bsnRadiusAuthServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRadiusAuthServerAddress.setDescription('The IP address of the RADIUS authentication server referred to in this table entry.')
bsnRadiusAuthClientServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthClientServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientServerPortNumber.setDescription('The UDP port the client is using to send requests to this server.')
bsnRadiusAuthServerKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerKey.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerKey.setDescription('The authentication and encryption key shared between the Radius client and this Radius Server. When the bsnRadiusAuthServerKeyFormat is hex it can have max length of 128 bytes. If the bsnRadiusAuthServerKeyFormat is Ascii it can have max length of 64 bytes.')
bsnRadiusAuthServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerStatus.setDescription('Server enable or disable status.')
bsnRadiusAuthServerKeyFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyFormat.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyFormat.setDescription('Format of the server key. When hex, the number of characters in the key should be even.')
bsnRadiusAuthServerRFC3576 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerRFC3576.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerRFC3576.setDescription('Support for Dynamic Authorization Extensions to RADIUS.')
bsnRadiusAuthServerIPSec = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSec.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSec.setDescription('IPSec over RADIUS')
bsnRadiusAuthServerIPSecAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("hmacMd5", 1), ("hmacSha1", 2))).clone('hmacSha1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecAuth.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecAuth.setDescription('The Hash algorithm employed by the IPSec Encrpytion. This applies only when bsnRadiusAuthServerIPSec is in enable state.')
bsnRadiusAuthServerIPSecEncryption = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("des", 1), ("tripleDes", 2), ("aesCbc", 3), ("aes256Cbc", 4))).clone('tripleDes')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecEncryption.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecEncryption.setDescription('The Encryption algorithm employed by this IpSec Encryption. This applies only when bsnRadiusAuthServerIPSec is in enable state.')
bsnRadiusAuthServerIPSecIKEPhase1 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("agressive", 2))).clone('main')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecIKEPhase1.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecIKEPhase1.setDescription('VPN IKE Phase 1 Mode type as per the IpSec standards. This applies only when bsnRadiusAuthServerIPSec is in enable state.')
bsnRadiusAuthServerIPSecIKELifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1800, 345600)).clone(28800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecIKELifetime.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecIKELifetime.setDescription("IPSec IKE's Lifetime. This applies only when bsnRadiusAuthServerIPSec is in enable state.")
bsnRadiusAuthServerIPSecDHGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 14))).clone(namedValues=NamedValues(("group1", 1), ("group2", 2), ("group5", 5), ("group14", 14))).clone('group2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecDHGroup.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerIPSecDHGroup.setDescription("IKE's Diffie-Hellman Group. This applies only when bsnRadiusAuthServerIPSec is in enable state.")
bsnRadiusAuthServerNetworkUserConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerNetworkUserConfig.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerNetworkUserConfig.setDescription('When enabled, this entry is considered as network user radius authenticating server entry.')
bsnRadiusAuthServerMgmtUserConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerMgmtUserConfig.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerMgmtUserConfig.setDescription('When enabled, this entry is considered as management user radius authenticating server entry.')
bsnRadiusAuthServerRetransmitTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerRetransmitTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerRetransmitTimeout.setDescription('Time in seconds after which a radius authentication request will timeout and a retransmission will be taken up by the switch.')
bsnRadiusAuthServerKeyWrapKEKkey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 18), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapKEKkey.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapKEKkey.setDescription("Key-encryption-key (KEK) used as the key for the 128 bit AES Key Wrap algorithm to encrypt the PMK in the key attribute. If the key is present in request, it should be taken as a hint by the server that the sender prefers this method of encryption over others. To maintain security actual keys after configuration are never returned in get request. If keys are configured then '***' is returned. If keys are not configured then empty string is retunred. bsnRadiusAuthServerKeyFormat is used this key. if the format chosen is ascii then it should be 16 bytes in length. if the format chosen is hex then it should be 32 bytes in length.")
bsnRadiusAuthServerKeyWrapMACKkey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 19), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapMACKkey.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapMACKkey.setDescription("Message-authenticator-code-key ( MACK) - used as the key for the HMAC-SHA-1 algorithm to sign the RADIUS message to prevent spoofing. MACK must be configured when KEK is configured. To maintain security actual keys after configuration are never returned in get request. If keys are configured then '***' is returned. If keys are not configured then empty string is returned. bsnRadiusAuthServerKeyFormat is used this key. if the format chosen is ascii then it should be 20 bytes in length. If the format chosen is hex then it should be 40 bytes in length.")
bsnRadiusAuthServerKeyWrapFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapFormat.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerKeyWrapFormat.setDescription('Format for the Key Wrap keys. This object is mandatory for manager to send if the key Wrap keys are being configured. Get on this object will always return hex(1)')
bsnRadiusAuthServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerRowStatus.setDescription(' Row Status for creation/deletion')
bsnRadiusAuthServerInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 27), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerInetAddressType.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerInetAddressType.setDescription('The IP address of the RADIUS authentication server referred to in this table entry.')
bsnRadiusAuthServerInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 1, 1, 28), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAuthServerInetAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerInetAddress.setDescription('The IP address of the RADIUS authentication server referred to in this table entry.')
bsnRadiusAccServerTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2), )
if mibBuilder.loadTexts: bsnRadiusAccServerTable.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerTable.setDescription('The (conceptual) table listing the RADIUS accounting servers with which the client shares a secret.')
bsnRadiusAccServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIndex"))
if mibBuilder.loadTexts: bsnRadiusAccServerEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerEntry.setDescription('An entry (conceptual row) representing a RADIUS accounting server with which the client shares a secret.')
bsnRadiusAccServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIndex.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIndex.setDescription('A number uniquely identifying each RADIUS Accounting server with which this client communicates.')
bsnRadiusAccServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerAddress.setDescription('The IP address of the RADIUS accounting server referred to in this table entry.')
bsnRadiusAccClientServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccClientServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientServerPortNumber.setDescription('The UDP port the client is using to send requests to this server.')
bsnRadiusAccServerKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerKey.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerKey.setDescription('The authentication and encryption key shared between the Radius client and this Radius Server. When the bsnRadiusAccServerKeyFormat is hex it can have max length of 128 bytes. If the bsnRadiusAccServerKeyFormat is Ascii it can have max length of 64 bytes.')
bsnRadiusAccServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerStatus.setDescription('Server enable or disable status.')
bsnRadiusAccServerKeyFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerKeyFormat.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerKeyFormat.setDescription('Format of the server key. When hex, the number of characters in the key should be even.')
bsnRadiusAccServerIPSec = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSec.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSec.setDescription('IPSec over RADIUS')
bsnRadiusAccServerIPSecAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("hmacMd5", 1), ("hmacSha1", 2))).clone('hmacSha1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecAuth.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecAuth.setDescription('The Hash algorithm employed by the IPSec Encrpytion. This applies only when bsnRadiusAccServerIPSec is in enable state.')
bsnRadiusAccServerIPSecEncryption = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("des", 1), ("tripleDes", 2), ("aesCbc", 3), ("aes256Cbc", 4))).clone('tripleDes')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecEncryption.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecEncryption.setDescription('The Encryption algorithm employed by this IpSec Encryption. This applies only when bsnRadiusAccServerIPSec is in enable state.')
bsnRadiusAccServerIPSecIKEPhase1 = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("agressive", 2))).clone('main')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecIKEPhase1.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecIKEPhase1.setDescription('VPN IKE Phase 1 Mode type as per the IpSec standards. This applies only when bsnRadiusAccServerIPSec is in enable state.')
bsnRadiusAccServerIPSecIKELifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1800, 345600)).clone(28800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecIKELifetime.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecIKELifetime.setDescription("IPSec IKE's Lifetime. This applies only when bsnRadiusAccServerIPSec is in enable state.")
bsnRadiusAccServerIPSecDHGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 14))).clone(namedValues=NamedValues(("group1", 1), ("group2", 2), ("group5", 5), ("group14", 14))).clone('group2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecDHGroup.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerIPSecDHGroup.setDescription("IKE's Diffie-Hellman Group. This applies only when bsnRadiusAccServerIPSec is in enable state.")
bsnRadiusAccServerNetworkUserConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerNetworkUserConfig.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerNetworkUserConfig.setDescription('When enabled, this entry is considered as network user radius accounting server entry.')
bsnRadiusAccServerRetransmitTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerRetransmitTimeout.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerRetransmitTimeout.setDescription('Time in seconds after which a radius accounting request will timeout and a retransmission will be taken up by the switch.')
bsnRadiusAccServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerRowStatus.setDescription('Row Status for creation/deletion')
bsnRadiusAccServerInetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 27), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerInetAddressType.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerInetAddressType.setDescription('The IP address of the RADIUS accounting server referred to in this table entry.')
bsnRadiusAccServerInetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 2, 1, 28), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnRadiusAccServerInetAddress.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerInetAddress.setDescription('The IP address of the RADIUS accounting server referred to in this table entry.')
bsnRadiusAuthServerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3), )
if mibBuilder.loadTexts: bsnRadiusAuthServerStatsTable.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerStatsTable.setDescription('The listing the Statistics of RADIUS authentication servers.')
bsnRadiusAuthServerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIndex"))
if mibBuilder.loadTexts: bsnRadiusAuthServerStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthServerStatsEntry.setDescription('An entry representing statistics a RADIUS authentication server with which the client shares a secret.')
bsnRadiusAuthClientRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientRoundTripTime.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientRoundTripTime.setDescription('The time interval (in hundredths of a second) between the most recent Access-Reply/Access-Challenge and the Access-Request that matched it from this RADIUS authentication server.')
bsnRadiusAuthClientAccessRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRequests.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRequests.setDescription('The number of RADIUS Access-Request packets sent to this server. This does not include retransmissions.')
bsnRadiusAuthClientAccessRetransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRetransmissions.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRetransmissions.setDescription('The number of RADIUS Access-Request packets retransmitted to this RADIUS authentication server.')
bsnRadiusAuthClientAccessAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessAccepts.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessAccepts.setDescription('The number of RADIUS Access-Accept packets (valid or invalid) received from this server.')
bsnRadiusAuthClientAccessRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRejects.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessRejects.setDescription('The number of RADIUS Access-Reject packets (valid or invalid) received from this server.')
bsnRadiusAuthClientAccessChallenges = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessChallenges.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientAccessChallenges.setDescription('The number of RADIUS Access-Challenge packets (valid or invalid) received from this server.')
bsnRadiusAuthClientMalformedAccessResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientMalformedAccessResponses.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientMalformedAccessResponses.setDescription('The number of malformed RADIUS Access-Response packets received from this server. Malformed packets include packets with an invalid length. Bad authenticators or Signature attributes or unknown types are not included as malformed access responses.')
bsnRadiusAuthClientBadAuthenticators = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientBadAuthenticators.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientBadAuthenticators.setDescription('The number of RADIUS Access-Response packets containing invalid authenticators or Signature attributes received from this server.')
bsnRadiusAuthClientPendingRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientPendingRequests.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientPendingRequests.setDescription('The number of RADIUS Access-Request packets destined for this server that have not yet timed out or received a response. This variable is incremented when an Access-Request is sent and decremented due to receipt of an Acess-Accept, Access-Reject or Access-Challenge, a timeout or retransmission.')
bsnRadiusAuthClientTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientTimeouts.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientTimeouts.setDescription('The number of authentication timeouts to this server. After a timeout the client may retry to the same server, send to a different server, or give up. A retry to the same server is counted as a retransmit as well as a timeout. A send to a different server is counted as a Request as well as a timeout.')
bsnRadiusAuthClientUnknownTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientUnknownTypes.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientUnknownTypes.setDescription('The number of RADIUS packets of unknown type which were received from this server on the authentication port.')
bsnRadiusAuthClientPacketsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAuthClientPacketsDropped.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthClientPacketsDropped.setDescription('The number of RADIUS packets of which were received from this server on the authentication port and dropped for some other reason.')
bsnRadiusAccServerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4), )
if mibBuilder.loadTexts: bsnRadiusAccServerStatsTable.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerStatsTable.setDescription('The (conceptual) table listing the RADIUS accounting servers with which the client shares a secret.')
bsnRadiusAccServerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIndex"))
if mibBuilder.loadTexts: bsnRadiusAccServerStatsEntry.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccServerStatsEntry.setDescription('An entry (conceptual row) representing a RADIUS accounting server with which the client shares a secret.')
bsnRadiusAccClientRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientRoundTripTime.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientRoundTripTime.setDescription('The time interval between the most recent Accounting-Response and the Accounting-Request that matched it from this RADIUS accounting server.')
bsnRadiusAccClientRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientRequests.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientRequests.setDescription('The number of RADIUS Accounting-Request packets sent. This does not include retransmissions.')
bsnRadiusAccClientRetransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientRetransmissions.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientRetransmissions.setDescription('The number of RADIUS Accounting-Request packets retransmitted to this RADIUS accounting server. Retransmissions include retries where the Identifier and Acct-Delay have been updated, as well as those in which they remain the same.')
bsnRadiusAccClientResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientResponses.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientResponses.setDescription('The number of RADIUS packets received on the accounting port from this server.')
bsnRadiusAccClientMalformedResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientMalformedResponses.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientMalformedResponses.setDescription('The number of malformed RADIUS Accounting-Response packets received from this server. Malformed packets include packets with an invalid length. Bad authenticators and unknown types are not included as malformed accounting responses.')
bsnRadiusAccClientBadAuthenticators = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientBadAuthenticators.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientBadAuthenticators.setDescription('The number of RADIUS Accounting-Response packets which contained invalid authenticators received from this server.')
bsnRadiusAccClientPendingRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientPendingRequests.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientPendingRequests.setDescription('The number of RADIUS Accounting-Request packets sent to this server that have not yet timed out or received a response. This variable is incremented when an Accounting-Request is sent and decremented due to receipt of an Accounting-Response, a timeout or a retransmission.')
bsnRadiusAccClientTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientTimeouts.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientTimeouts.setDescription('The number of accounting timeouts to this server. After a timeout the client may retry to the same server, send to a different server, or give up. A retry to the same server is counted as a retransmit as well as a timeout. A send to a different server is counted as an Accounting-Request as well as a timeout.')
bsnRadiusAccClientUnknownTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientUnknownTypes.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientUnknownTypes.setDescription('The number of RADIUS packets of unknown type which were received from this server on the accounting port.')
bsnRadiusAccClientPacketsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 4, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnRadiusAccClientPacketsDropped.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAccClientPacketsDropped.setDescription('The number of RADIUS packets which were received from this server on the accounting port and dropped for some other reason.')
bsnUsersTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5), )
if mibBuilder.loadTexts: bsnUsersTable.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUsersTable.setDescription('The (conceptual) table listing Wlan Users')
bsnUsersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnUserName"))
if mibBuilder.loadTexts: bsnUsersEntry.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUsersEntry.setDescription('....')
bsnUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserName.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserName.setDescription('User Name')
bsnUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserPassword.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserPassword.setDescription('User Password')
bsnUserEssIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 517))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserEssIndex.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserEssIndex.setDescription('User WLAN ID. Value 0 implies that this applies to any WLAN ID.')
bsnUserAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserAccessMode.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserAccessMode.setDescription('User Access Mode.')
bsnUserType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("management", 1), ("wlan", 2), ("macFilter", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserType.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserType.setDescription('User Type.')
bsnUserInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserInterfaceName.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserInterfaceName.setDescription('Interface Name.')
bsnUserRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 5, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnUserRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnUserRowStatus.setDescription('Row Status')
bsnMacFilterTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9), )
if mibBuilder.loadTexts: bsnMacFilterTable.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterTable.setDescription('The table listing MAC Filter entries')
bsnMacFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMacFilterAddress"))
if mibBuilder.loadTexts: bsnMacFilterEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterEntry.setDescription('....')
bsnMacFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMacFilterAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterAddress.setDescription('MAC Address of the entry')
bsnMacFilterWlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 517))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMacFilterWlanId.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterWlanId.setDescription('WLAN ID of the WLAN that the user can connect to. 0 means any WLAN ID.')
bsnMacFilterInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMacFilterInterfaceName.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterInterfaceName.setDescription('Interface Name.')
bsnMacFilterDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMacFilterDescription.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterDescription.setDescription('Description of the MAC Filter entry.')
bsnMacFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 9, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMacFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnMacFilterRowStatus.setDescription('Row Status')
bsnLocalNetUserTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10), )
if mibBuilder.loadTexts: bsnLocalNetUserTable.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserTable.setDescription('The table listing Local Net User entries.')
bsnLocalNetUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserName"))
if mibBuilder.loadTexts: bsnLocalNetUserEntry.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserEntry.setDescription('....')
bsnLocalNetUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserName.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserName.setDescription('Name of the net user.')
bsnLocalNetUserWlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 517))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserWlanId.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserWlanId.setDescription('WLAN ID of the WLAN that the user can connect to. 0 means any WLAN ID.')
bsnLocalNetUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserPassword.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserPassword.setDescription('User Password.')
bsnLocalNetUserDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserDescription.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserDescription.setDescription('Description of the Net User entry.')
bsnLocalNetUserLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 5), TimeInterval().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(6000, 259200000), )).clone(8640000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserLifetime.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserLifetime.setDescription('This object indicates the lifetime of an user account expressed in hundredths of a second. Lifetime period other than 0 will make it a guest-user. Minimum value for guest user is 60 seconds (6000). Once configured as non-guest user can not be change to guest user and vice-versa. Default value is for a day and max lifetime is 259200000(30 days). WLANIds, which have webauth policy are valid for guest access user. ')
bsnLocalNetUserStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLocalNetUserStartTime.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserStartTime.setDescription('This object indicates the time when the guest user account was created and expressed as the number of seconds elapsed since 1st Jan, 1970. ')
bsnLocalNetUserRemainingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 7), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLocalNetUserRemainingTime.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserRemainingTime.setDescription('This object indicates the remaining session time for the guest user in hundredths of a second. ')
bsnLocalNetUserRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 10, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalNetUserRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnLocalNetUserRowStatus.setDescription('Row Status')
bsnLocalManagementUserTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11), )
if mibBuilder.loadTexts: bsnLocalManagementUserTable.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserTable.setDescription('The (conceptual) table listing Local Management Users')
bsnLocalManagementUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserName"))
if mibBuilder.loadTexts: bsnLocalManagementUserEntry.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserEntry.setDescription('....')
bsnLocalManagementUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalManagementUserName.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserName.setDescription('User Name')
bsnLocalManagementUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalManagementUserPassword.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserPassword.setDescription('User Password')
bsnLocalManagementUserAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalManagementUserAccessMode.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserAccessMode.setDescription('User Access Mode.')
bsnLocalManagementUserRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 11, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLocalManagementUserRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnLocalManagementUserRowStatus.setDescription('Row Status')
bsnAclTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 7), )
if mibBuilder.loadTexts: bsnAclTable.setStatus('current')
if mibBuilder.loadTexts: bsnAclTable.setDescription('The table listing ACLs (Access Control Lists) on the Switch.')
bsnAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 7, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAclName"))
if mibBuilder.loadTexts: bsnAclEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAclEntry.setDescription('....')
bsnAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclName.setStatus('current')
if mibBuilder.loadTexts: bsnAclName.setDescription('Name of the Access Control List.')
bsnAclApplyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notapplied", 0), ("applied", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAclApplyMode.setStatus('current')
if mibBuilder.loadTexts: bsnAclApplyMode.setDescription("The apply mode of the ACL on the switch. Mode value 'applied' means the ACL has been applied on the switch.")
bsnAclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 7, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAclRowStatus.setDescription('Row Status of the ACL.')
bsnAclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8), )
if mibBuilder.loadTexts: bsnAclRuleTable.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleTable.setDescription('The table listing Acl Rules(Access Control List Entries) on the ACL with name bsnAclName.')
bsnAclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAclName"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAclRuleIndex"))
if mibBuilder.loadTexts: bsnAclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleEntry.setDescription('....')
bsnAclRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleIndex.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleIndex.setDescription('Index of the ACL rule. This can be updated to reset the sequence of the rules of an ACL.')
bsnAclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("deny", 0), ("permit", 1))).clone('deny')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleAction.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleAction.setDescription('The permission mode of a rule.')
bsnAclRuleDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inbound", 0), ("outbound", 1), ("any", 2))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleDirection.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleDirection.setDescription('The direction of the packet to which the rule may be applied.')
bsnAclRuleSourceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleSourceIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleSourceIpAddress.setDescription('Source IP Address of the ACL rule. A value 0 implies any source address.')
bsnAclRuleSourceIpNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleSourceIpNetmask.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleSourceIpNetmask.setDescription('Source IP Netmask of the ACL rule. A value 0 implies any source mask.')
bsnAclRuleDestinationIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleDestinationIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleDestinationIpAddress.setDescription('Destination IP Address of the ACL rule. A value 0 implies any destination address.')
bsnAclRuleDestinationIpNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleDestinationIpNetmask.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleDestinationIpNetmask.setDescription('Destination Netmask of the ACL rule. A value 0 implies any destination mask.')
bsnAclRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleProtocol.setDescription("Protocol of the packet. It can be either of the pre specified protocols like TCP, UDP, ICMP, ESP, AH, GRE, IP, Ethernet Over IP, OSPF or any number between 0 and 255. A value 256 implies that this rule applies to 'Any' protocol.")
bsnAclRuleStartSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleStartSourcePort.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleStartSourcePort.setDescription("Source Port of the packet. It can be either of the pre specified ports like HTTP, HTTPS, Telnet, RADIUS etc or any number between 0 and 65535. A value 65536 implies that this rule applies to 'Any' source port. This value can be set only if the protocol is set to TCP or UDP. Otherwise the value is set to Any(65536)")
bsnAclRuleEndSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleEndSourcePort.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleEndSourcePort.setDescription("Source Port of the packet. It can be either of the pre specified ports like HTTP, HTTPS, Telnet, RADIUS etc or any number between 0 and 65535. A value 65536 implies that this rule applies to 'Any' source port. This value can be set only if the protocol is set to TCP or UDP. Otherwise the value is set to Any(65536)")
bsnAclRuleStartDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleStartDestinationPort.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleStartDestinationPort.setDescription("Destination Port of the packet. It can be either of the pre specified ports like HTTP, HTTPS, Telnet, RADIUS etc or any number between 0 and 65535. A value 65536 implies that this rule aplpies to 'Any' Destination port. This value can be set only if the protocol is set to TCP or UDP. Otherwise the value is set to Any(65536)")
bsnAclRuleEndDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleEndDestinationPort.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleEndDestinationPort.setDescription("Destination Port of the packet. It can be either of the pre specified ports like HTTP, HTTPS, Telnet, RADIUS etc or any number between 0 and 65535. A value 65536 implies that this rule aplpies to 'Any' Destination port. This value can be set only if the protocol is set to TCP or UDP. Otherwise the value is set to Any(65536)")
bsnAclRuleDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleDscp.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleDscp.setDescription('DSCP value of the rule. A value 256 implies Any')
bsnAclNewRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclNewRuleIndex.setStatus('current')
if mibBuilder.loadTexts: bsnAclNewRuleIndex.setDescription('New Index of the ACL rule. This attribute should be updated if the requirement is to reset the sequence of the rules of an ACL. A read on this will not yield anything.')
bsnAclRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 8, 1, 40), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAclRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAclRuleRowStatus.setDescription('Row Status of the ACL Rule.')
bsnRadiusAuthKeyWrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRadiusAuthKeyWrapEnable.setStatus('current')
if mibBuilder.loadTexts: bsnRadiusAuthKeyWrapEnable.setDescription(' When keyWrap is enable then for 801.1X and 802.11i client Authentication, request is sent to those radius servers which has KEK and MACK keys are configured. Radius servers are widely used for user authentications. In 802.11i and 802.1X type authentication, the controller recives Pairwise Master KEy(PMK) from RADIUS sever using vendor specific RADIUS attributes, which uses MPPE RFC3078. Since MPPE uses RC4 algorithm to provide data confidentiality, it is not FIPS approved. For this RADIUS key WRAP attributes, bsnRadiusAuthServerKeyWrap and bsnRadiusAuthServerKeyWrapMACKkey have been added, which are used to securely transfer encryption keys using non-proprietary techniques.')
bsnRadiusAuthCacheCredentialsLocally = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRadiusAuthCacheCredentialsLocally.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRadiusAuthCacheCredentialsLocally.setDescription('Enable or disable caching of credentials locally for RADIUS Auth servers. This is used when a client uses a one time password authentication scheme.')
bsnAAAMacDelimiter = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noDelimiter", 0), ("colon", 1), ("hyphen", 2), ("singleHyphen", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAAAMacDelimiter.setStatus('current')
if mibBuilder.loadTexts: bsnAAAMacDelimiter.setDescription('The delimiter to be used for mac filtering. It can be colon as in xx:xx:xx:xx:xx:xx or hyphen as in xx-xx-xx-xx-xx-xx or single hyphen as in xxxxxx-xxxxxx or no delimiter as in xxxxxxxxxxxx.')
bsnAAARadiusCompatibilityMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ciscoACS", 0), ("orinocoRadius", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAAARadiusCompatibilityMode.setStatus('current')
if mibBuilder.loadTexts: bsnAAARadiusCompatibilityMode.setDescription('The required compatibility mode for MAC filtering. For ciscoACS, the expected MAC delimiter setting is colon and for orinocoRadius, it is singleHyphen.')
bsnAAARadiusCallStationIdType = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("ipAddr", 0), ("macAddr", 1), ("apMacAddress", 2), ("apMacAddressSsid", 3), ("apNameSsid", 4), ("apName", 5), ("apGroupName", 6), ("flexGroupName", 7), ("apLocation", 8), ("apVlanId", 9), ("apMacEthAddress", 10), ("apMacEthAddressSsid", 11), ("apLabelAddress", 12), ("apLabelAddressSsid", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAAARadiusCallStationIdType.setStatus('current')
if mibBuilder.loadTexts: bsnAAARadiusCallStationIdType.setDescription('This attribute configures the call station ID information sent in RADIUS messages. The value undefined cannot be set during the write operation.')
bsnAAALocalDatabaseSize = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAAALocalDatabaseSize.setStatus('current')
if mibBuilder.loadTexts: bsnAAALocalDatabaseSize.setDescription('This attribute is the total number of entries permitted in the local users database. This is the combined total of entries for Local Management Users, Local Net Users, Disabled Clients (previously known as blacklistclients and the MAC Filters. If the database size limit is reached, no more entries in any of these user lists are allowed to be created. To continue creating more entries, one should increase the size of the database. This value is applied on reboot and then matches the bsnAACurrentLocalDatabaseSize.')
bsnAAACurrentLocalDatabaseSize = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnAAACurrentLocalDatabaseSize.setStatus('current')
if mibBuilder.loadTexts: bsnAAACurrentLocalDatabaseSize.setDescription('This attribute is the maximum number of entries in the local users database that is effective currently. This is the combined total of entries for Local Management Users, Local Net Users, Disabled Clients (previously known as blacklist clients) and the MAC Filters.')
bsnBlackListClientTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 6), )
if mibBuilder.loadTexts: bsnBlackListClientTable.setStatus('current')
if mibBuilder.loadTexts: bsnBlackListClientTable.setDescription('The table listing Wlan Black Listed Clients')
bsnBlackListClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 6, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnBlackListClientMacAddress"))
if mibBuilder.loadTexts: bsnBlackListClientEntry.setStatus('current')
if mibBuilder.loadTexts: bsnBlackListClientEntry.setDescription('....')
bsnBlackListClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnBlackListClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnBlackListClientMacAddress.setDescription('Black Listed Client MAC Address')
bsnBlackListClientDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnBlackListClientDescription.setStatus('current')
if mibBuilder.loadTexts: bsnBlackListClientDescription.setDescription('Black Listed Client Description ')
bsnBlackListClientRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 6, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnBlackListClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnBlackListClientRowStatus.setDescription('Row Status')
bsnExternalPolicyServerTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19), )
if mibBuilder.loadTexts: bsnExternalPolicyServerTable.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerTable.setDescription('The (conceptual) table listing the External Policy servers with which client share a secret.')
bsnExternalPolicyServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerIndex"))
if mibBuilder.loadTexts: bsnExternalPolicyServerEntry.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerEntry.setDescription('An entry (conceptual row) representing an External policy server with which the client shares a secret.')
bsnExternalPolicyServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerIndex.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerIndex.setDescription('A number uniquely identifying each External Policy server with which this client communicates.')
bsnExternalPolicyServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerAddress.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerAddress.setDescription('The IP address of the External Policy server referred to in this table entry.')
bsnExternalPolicyServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerPortNumber.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerPortNumber.setDescription('The UDP port the client is using to send requests to this server.')
bsnExternalPolicyServerKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerKey.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerKey.setDescription('The authentication and encryption key shared between the client and this External Policy Server.')
bsnExternalPolicyServerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerAdminStatus.setDescription('Server enable or disable status.')
bsnExternalPolicyServerConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnected", 0), ("connected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnExternalPolicyServerConnectionStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerConnectionStatus.setDescription('Server enable or disable status.')
bsnExternalPolicyServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 19, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnExternalPolicyServerRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: bsnExternalPolicyServerRowStatus.setDescription('Row Status for creation/deletion')
bsnExternalPolicyServerAclName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 5, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnExternalPolicyServerAclName.setStatus('current')
if mibBuilder.loadTexts: bsnExternalPolicyServerAclName.setDescription('This attribute configures the ACL Name for External Policy Servers')
bsnAcceptSelfSignedCertificate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAcceptSelfSignedCertificate.setStatus('current')
if mibBuilder.loadTexts: bsnAcceptSelfSignedCertificate.setDescription('This flag specifies if controller will accept Self Signed Certificate from AP as part of authorization.')
bsnSystemClockTime = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 3, 1, 49), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnSystemClockTime.setStatus('current')
if mibBuilder.loadTexts: bsnSystemClockTime.setDescription('This object represents the current clock time of the controller and expressed as the number of seconds elapsed since 00:00:00 on January 1, 1970, Coordinated Universal Time (UTC). ')
bsnAPAuthorizationTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22), )
if mibBuilder.loadTexts: bsnAPAuthorizationTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthorizationTable.setDescription('The table listing AP Authorization entries')
bsnAPAuthorizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPAuthMacAddress"))
if mibBuilder.loadTexts: bsnAPAuthorizationEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthorizationEntry.setDescription('BsnAPAuthorizationEntry')
bsnAPAuthMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPAuthMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthMacAddress.setDescription('MAC Address of the AP entry')
bsnAPAuthCertificateType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("mic", 1), ("ssc", 2), ("locMic", 3), ("locSsc", 4), ("none", 5), ("locSsc256", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPAuthCertificateType.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthCertificateType.setDescription('Supported certificate types are MIC, SSC (Self-Signed-Certificate) or no certificate.')
bsnAPAuthHashKey = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22, 1, 3), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPAuthHashKey.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthHashKey.setDescription('SHA1 hash key for SSC certificate validation. It has to be 40/64 hexa-decimal characters. This is considered when certificate type is SSC.')
bsnAPAuthRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 5, 22, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPAuthRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthRowStatus.setDescription('Row Status')
bsnWrasIpsecCACertificate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 9, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasIpsecCACertificate.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCACertificate.setDescription('')
bsnWrasIpsecCACertificateUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 9, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnWrasIpsecCACertificateUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCACertificateUpdate.setDescription('Note this attribute is for updating the certificate If you try to read it, it will always be ***')
bsnWrasIpsecCertTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3), )
if mibBuilder.loadTexts: bsnWrasIpsecCertTable.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertTable.setDescription('A table of Certificates.')
bsnWrasIpsecCertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertName"))
if mibBuilder.loadTexts: bsnWrasIpsecCertEntry.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertEntry.setDescription('Each entry contains a specific certificate.')
bsnWrasIpsecCertName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWrasIpsecCertName.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertName.setDescription('The name assigned to this set of IKE Certificates.')
bsnWrasIpsecCertificateUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWrasIpsecCertificateUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertificateUpdate.setDescription('If you try to read this it will always be ***')
bsnWrasIpsecCertificate = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnWrasIpsecCertificate.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertificate.setDescription('')
bsnWrasIpsecCertPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1500))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWrasIpsecCertPassword.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertPassword.setDescription('')
bsnWrasIpsecCertStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 9, 3, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnWrasIpsecCertStatus.setStatus('current')
if mibBuilder.loadTexts: bsnWrasIpsecCertStatus.setDescription('A row status type for the IKE Cert Entry.')
bsnTrapControl = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1))
bsnTrapVariable = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2))
bsnTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3))
bsnDot11StationTrapControlMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnDot11StationTrapControlMask.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationTrapControlMask.setDescription('This mask describes what events merit traps to network management. If the bit for a particular event is turned on then notification will be generated on event occurence. Event corresponding value ----- ----------------- bsnDot11StationDisassociate 1 bsnDot11StationDeauthenticate 2 bsnDot11StationAuthenticateFail 4 bsnDot11StationAssociateFail 8 bsnDot11StationBlacklisted 16 bsnDot11StationAssociate 32 ciscoLwappDot11ClientMovedToRunState 64 By Default all bits are off.')
bsnDot11StationDisassociate = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 1)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationDisassociate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationDisassociate.setDescription('The disassociate notification shall be sent when the Station sends a Disassociation frame. The value of the notification shall include the MAC address of the MAC to which the Disassociation frame was sent and the reason for the disassociation')
bsnDot11StationDeauthenticate = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 2)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationDeauthenticate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationDeauthenticate.setDescription('The deauthenticate notification shall be sent when the Station sends a Deauthentication frame. The value of the notification shall include the MAC address of the MAC to which the Deauthentication frame was sent and the reason for the deauthentication.')
bsnDot11StationAuthenticateFail = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 3)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationAuthenticateFail.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationAuthenticateFail.setDescription("The authenticate failure notification shall be sent when the Station sends an Authentication frame with a status code other than 'successful'. The value of the notification shall include the MAC address of the MAC to which the Authentication frame was sent and the reason for the authentication failure.")
bsnDot11StationAssociateFail = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 4)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationAssociateFail.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationAssociateFail.setDescription("The associate failure notification shall be sent when the Station sends an Association frame with a status code other than 'successful'. The value of the notification shall include the MAC address of the MAC to which the Authentication frame was sent and the reason for the authentication failure.")
bsnDot11StationBlacklisted = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 52)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnStationBlacklistingReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationBlacklisted.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationBlacklisted.setDescription('The station blacklisted notification shall be sent when the client is blacklisted. The reason could be repeated auth or association failures or IP Address theft. The value of the notification shall include the MAC address of the MAC to which the Authentication frame was sent, the MAC and Slot Id of AP that client was associated to and the reason for black listing.')
bsnDot11StationAssociate = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 53)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDot11StationAssociate.setStatus('current')
if mibBuilder.loadTexts: bsnDot11StationAssociate.setDescription('The associate notification shall be sent when any of the watchlisted clients(present on at least one watch list) associates with an AP. The value of the notification shall include the MAC address and the Slot ID of the radio to which the station Associated.')
bsnAPTrapControlMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 2), Unsigned32().clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPTrapControlMask.setStatus('current')
if mibBuilder.loadTexts: bsnAPTrapControlMask.setDescription('This mask describes what events merit traps to network management. If the bit for a particular event is turned on then notification will be generated on event occurance. Event corresponding bit ----- ----------------- bsnAPAssociate/Disassociate 1 bsnAPIfUp/Down 4 bsnAPAuthorizationFailureCause 16 bsnAPModeChanged 32 bsnAPTimeSyncFailure 64 By Default all bits are on.')
bsnAPUp = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 5)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"))
if mibBuilder.loadTexts: bsnAPUp.setStatus('obsolete')
if mibBuilder.loadTexts: bsnAPUp.setDescription('When Airespace AP operation status goes up this trap will be sent')
bsnAPDown = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 6)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"))
if mibBuilder.loadTexts: bsnAPDown.setStatus('obsolete')
if mibBuilder.loadTexts: bsnAPDown.setDescription('When Airespace AP operation status goes down this trap will be sent')
bsnAPAssociated = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 7)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPortNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPAssociated.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPAssociated.setDescription('When Airespace AP Associates to a Airespace Switch, AP associated notification will be sent with dot3 MAC address of Airespace AP.This will help management system to discover Airespace AP and add to system.')
bsnAPDisassociated = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 8)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPDisassociated.setStatus('current')
if mibBuilder.loadTexts: bsnAPDisassociated.setDescription('When Airespace AP disassociates from Airespace Switch, AP disassociated notification will be sent with dot3 MAC address of Airespace AP management system to remove Airespace AP from this Airespace Switch')
bsnAPIfUp = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 9)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfUpDownCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPIfUp.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfUp.setDescription("When Airespace AP's interface's operation status goes up this trap will be sent")
bsnAPIfDown = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 10)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfUpDownCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPIfDown.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPIfDown.setDescription("When Airespace AP's interface's operation status goes down this trap will be sent.")
bsnAPProfileTrapControlMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPProfileTrapControlMask.setStatus('current')
if mibBuilder.loadTexts: bsnAPProfileTrapControlMask.setDescription('This mask describes what events merit traps to network management. If the bit for a particular event is turned on then notification will be generated on event occurance. Event corresponding bit ----- ----------------- LoadProfileFail 1 NoiseProfileFail 2 InterferenceProfileFail 4 CoverageProfileFailed 8')
bsnAPLoadProfileFailed = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 11)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPLoadProfileFailed.setStatus('current')
if mibBuilder.loadTexts: bsnAPLoadProfileFailed.setDescription('When LOAD Profile state changes from PASS to FAIL, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPNoiseProfileFailed = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 12)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPNoiseProfileFailed.setStatus('current')
if mibBuilder.loadTexts: bsnAPNoiseProfileFailed.setDescription('When Noise Profile state changes from PASS to FAIL, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPInterferenceProfileFailed = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 13)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPInterferenceProfileFailed.setStatus('current')
if mibBuilder.loadTexts: bsnAPInterferenceProfileFailed.setDescription('When Interference Profile state changes from PASS to FAIL, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPMacAddrTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 20), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPMacAddrTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPMacAddrTrapVariable.setDescription('')
bsnAPNameTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 21), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPNameTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPNameTrapVariable.setDescription('')
bsnAPSlotIdTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 22), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPSlotIdTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPSlotIdTrapVariable.setDescription('Number of Radio Interfaces on the Airespace AP.')
bsnAPChannelNumberTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 23), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPChannelNumberTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPChannelNumberTrapVariable.setDescription('')
bsnAPCoverageThresholdTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 24), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPCoverageThresholdTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPCoverageThresholdTrapVariable.setDescription('')
bsnAPCoverageFailedClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 25), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPCoverageFailedClients.setStatus('current')
if mibBuilder.loadTexts: bsnAPCoverageFailedClients.setDescription('')
bsnAPCoverageTotalClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 26), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPCoverageTotalClients.setStatus('current')
if mibBuilder.loadTexts: bsnAPCoverageTotalClients.setDescription('')
bsnClientMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 27), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnClientMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnClientMacAddr.setDescription('')
bsnClientRssi = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 28), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnClientRssi.setStatus('current')
if mibBuilder.loadTexts: bsnClientRssi.setDescription('')
bsnClientSnr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 29), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnClientSnr.setStatus('current')
if mibBuilder.loadTexts: bsnClientSnr.setDescription('')
bsnInterferenceEnergyBeforeChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 30), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnInterferenceEnergyBeforeChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnInterferenceEnergyBeforeChannelUpdate.setDescription('')
bsnInterferenceEnergyAfterChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 31), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnInterferenceEnergyAfterChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnInterferenceEnergyAfterChannelUpdate.setDescription('')
bsnAPPortNumberTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 32), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPPortNumberTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPPortNumberTrapVariable.setDescription('')
bsnAPPreviousChannelNumberTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 83), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPPreviousChannelNumberTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPPreviousChannelNumberTrapVariable.setDescription('')
bsnAPReasonCodeTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 84), Bits().clone(namedValues=NamedValues(("noReason", 0), ("signal", 1), ("noise", 2), ("interference", 3), ("load", 4), ("radar", 5), ("deviceAware", 6), ("majorSIAQEvent", 7), ("radarClear", 8), ("userInput", 9)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPReasonCodeTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnAPReasonCodeTrapVariable.setDescription('')
bsnNoiseBeforeChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 85), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNoiseBeforeChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnNoiseBeforeChannelUpdate.setDescription('')
bsnNoiseAfterChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 86), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNoiseAfterChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnNoiseAfterChannelUpdate.setDescription('')
bsnInterferenceBeforeChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 87), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnInterferenceBeforeChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnInterferenceBeforeChannelUpdate.setDescription('')
bsnInterferenceAfterChannelUpdate = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 88), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnInterferenceAfterChannelUpdate.setStatus('current')
if mibBuilder.loadTexts: bsnInterferenceAfterChannelUpdate.setDescription('')
bsnAPCoverageProfileFailed = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 14)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNameTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSlotIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageThresholdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageFailedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageTotalClients"), ("AIRESPACE-WIRELESS-MIB", "bsnClientMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnClientRssi"), ("AIRESPACE-WIRELESS-MIB", "bsnClientSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPCoverageProfileFailed.setStatus('current')
if mibBuilder.loadTexts: bsnAPCoverageProfileFailed.setDescription('When Coverage Profile state changes from PASS to FAIL, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPLoadProfileUpdatedToPass = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 37)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPLoadProfileUpdatedToPass.setStatus('current')
if mibBuilder.loadTexts: bsnAPLoadProfileUpdatedToPass.setDescription('When LOAD Profile state changes from FAIL to PASSt this notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPNoiseProfileUpdatedToPass = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 38)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPNoiseProfileUpdatedToPass.setStatus('current')
if mibBuilder.loadTexts: bsnAPNoiseProfileUpdatedToPass.setDescription('When Noise Profile state changes from FAIL tp PASS, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPInterferenceProfileUpdatedToPass = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 39)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPInterferenceProfileUpdatedToPass.setStatus('current')
if mibBuilder.loadTexts: bsnAPInterferenceProfileUpdatedToPass.setDescription('When Interference Profile state changes from FAIL tp PASS, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable /disable using bsnRrmProfileTrapControlFlag ')
bsnAPCoverageProfileUpdatedToPass = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 40)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPCoverageProfileUpdatedToPass.setStatus('current')
if mibBuilder.loadTexts: bsnAPCoverageProfileUpdatedToPass.setDescription('When Coverage Profile state changes from FAIL tp PASS, notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF. This trap sending can be enable/disable using bsnRrmProfileTrapControlFlag ')
bsnAPParamUpdateTrapControlMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPParamUpdateTrapControlMask.setStatus('current')
if mibBuilder.loadTexts: bsnAPParamUpdateTrapControlMask.setDescription('Mac Parameters are updated for a Airespace AP interface whenever Dynamic Algorithm are run. This mask describes what update events merit traps to network management. If the bit for a particular event is turned on then notification will be generated on event occurance. Event corresponding bit ----- ----------------- TxPowerChange 1 ChannelChange 2 AntennaChange 4 RTSCTSThresholdChange 8 EDThresholdChange 16 FragmentationThresholdChange 32')
bsnAPCurrentTxPowerChanged = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 15)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPCurrentTxPowerChanged.setStatus('current')
if mibBuilder.loadTexts: bsnAPCurrentTxPowerChanged.setDescription("Whenever dynamic algorithms are running and bsnAPIfPhyPowerAutomaticOn is true, Airespace AP Interface's CurrentTxPower might get updated by algorithm. When this occurs notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF along with the currentTxPower for this Airespace AP IF")
bsnAPCurrentChannelChanged = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 16)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSlotIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPChannelNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPreviousChannelNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPReasonCodeTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnNoiseBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnNoiseAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPCurrentChannelChanged.setStatus('current')
if mibBuilder.loadTexts: bsnAPCurrentChannelChanged.setDescription("Whenever dynamic algorithms are running and bsnAPIfPhyChannelAutomaticOn is true, Airespace AP Interface's CurrentChannel might get updated by algorithm. When this occurs notification will be sent with Dot3 MAC address of Airespace AP and slot ID of Airespace AP IF along with the currentChannel for this Airespace AP IF")
bsnRrmDot11aGroupingDone = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 21)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aGroupLeaderMacAddr"))
if mibBuilder.loadTexts: bsnRrmDot11aGroupingDone.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11aGroupingDone.setDescription('When Grouping is done, this notification will be sent from the previous Group Leader where grouping algorithm was run. It has MAC address of the new Group Leader.')
bsnRrmDot11bGroupingDone = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 22)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bGroupLeaderMacAddr"))
if mibBuilder.loadTexts: bsnRrmDot11bGroupingDone.setStatus('current')
if mibBuilder.loadTexts: bsnRrmDot11bGroupingDone.setDescription('When Grouping is done, this notification will be sent from the previous Group Leader where grouping algorithm was run. It has MAC address of the new Group Leader.')
bsnConfigSaveTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnConfigSaveTrapEnable.setStatus('current')
if mibBuilder.loadTexts: bsnConfigSaveTrapEnable.setDescription('If Rogue AP Detection and Removed Traps need to be sent ')
bsnConfigSaved = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 23))
if mibBuilder.loadTexts: bsnConfigSaved.setStatus('current')
if mibBuilder.loadTexts: bsnConfigSaved.setDescription('When configuration is save either from CLI or web interface This trap will be sent to inform NMS to do refresh')
bsnDot11EssCreated = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 24)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"))
if mibBuilder.loadTexts: bsnDot11EssCreated.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssCreated.setDescription('Whenever a new Ess (WLAN) is created, this notification will be sent along with EssIndex')
bsnDot11EssDeleted = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 25)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"))
if mibBuilder.loadTexts: bsnDot11EssDeleted.setStatus('current')
if mibBuilder.loadTexts: bsnDot11EssDeleted.setDescription('Whenever a Ess (WLAN)is deleted, this notification will be sent along with EssIndex')
bsnAuthFailureUserName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAuthFailureUserName.setStatus('current')
if mibBuilder.loadTexts: bsnAuthFailureUserName.setDescription('')
bsnAuthFailureUserType = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mgmtUser", 1), ("wlanUser", 2), ("macFilter", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAuthFailureUserType.setStatus('current')
if mibBuilder.loadTexts: bsnAuthFailureUserType.setDescription('')
bsnRADIUSServerTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRADIUSServerTrapEnable.setStatus('current')
if mibBuilder.loadTexts: bsnRADIUSServerTrapEnable.setDescription('if RADIUS Server Traps need to be sent ')
bsnAuthenticationFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAuthenticationFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: bsnAuthenticationFailureTrapEnable.setDescription('If Authentication Failure Traps need to be sent ')
bsn80211SecurityTrapControlMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsn80211SecurityTrapControlMask.setStatus('current')
if mibBuilder.loadTexts: bsn80211SecurityTrapControlMask.setDescription('This mask is for Security related trap controls. Event corresponding bit ----- ----------------- bsnWepKeyDecryptError 1 bsnSignatureAttackDetected 2 By Default all bits are off.')
bsnWpsTrapControlEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnWpsTrapControlEnable.setStatus('current')
if mibBuilder.loadTexts: bsnWpsTrapControlEnable.setDescription('This control is for WPS(Wireless Intrusion Protection System) related traps.')
bsnRADIUSServerNotResponding = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 26))
if mibBuilder.loadTexts: bsnRADIUSServerNotResponding.setStatus('current')
if mibBuilder.loadTexts: bsnRADIUSServerNotResponding.setDescription('This trap is to indicate that no RADIUS server(s) are responding to authentication requests sent by the RADIUS client within the MWAR device(Switch).')
bsnAuthenticationFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 27)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserType"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserName"))
if mibBuilder.loadTexts: bsnAuthenticationFailure.setStatus('current')
if mibBuilder.loadTexts: bsnAuthenticationFailure.setDescription('This trap is to inform that client authentication failure has occured at MWAR(Switch). This could be cli/web user, wlan user, or Mac Authorized user. ServiceType will indicate which type of user it is and userName will be cli/web/wlan userName or MacAddress of Mac Authorized User')
bsnRemoteIPv4Address = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 3), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnRemoteIPv4Address.setStatus('current')
if mibBuilder.loadTexts: bsnRemoteIPv4Address.setDescription('')
bsnIpsecErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 4), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIpsecErrorCount.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecErrorCount.setDescription('')
bsnIpsecSPI = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 5), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIpsecSPI.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecSPI.setDescription('')
bsnRemoteUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnRemoteUdpPort.setStatus('current')
if mibBuilder.loadTexts: bsnRemoteUdpPort.setDescription('')
bsnIkeAuthMethod = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 7), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIkeAuthMethod.setStatus('current')
if mibBuilder.loadTexts: bsnIkeAuthMethod.setDescription('')
bsnIkeTotalInitFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 8), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIkeTotalInitFailures.setStatus('current')
if mibBuilder.loadTexts: bsnIkeTotalInitFailures.setDescription('')
bsnIkeTotalInitNoResponses = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 9), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIkeTotalInitNoResponses.setStatus('current')
if mibBuilder.loadTexts: bsnIkeTotalInitNoResponses.setDescription('')
bsnIkeTotalRespFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 10), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIkeTotalRespFailures.setStatus('current')
if mibBuilder.loadTexts: bsnIkeTotalRespFailures.setDescription('')
bsnNotifiesSent = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 11), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNotifiesSent.setStatus('current')
if mibBuilder.loadTexts: bsnNotifiesSent.setDescription('')
bsnNotifiesReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 12), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNotifiesReceived.setStatus('current')
if mibBuilder.loadTexts: bsnNotifiesReceived.setDescription('')
bsnSuiteInitFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 13), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSuiteInitFailures.setStatus('current')
if mibBuilder.loadTexts: bsnSuiteInitFailures.setDescription('')
bsnSuiteRespondFailures = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 14), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSuiteRespondFailures.setStatus('current')
if mibBuilder.loadTexts: bsnSuiteRespondFailures.setDescription('')
bsnInitiatorCookie = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnInitiatorCookie.setStatus('current')
if mibBuilder.loadTexts: bsnInitiatorCookie.setDescription('The initiator cookie used in an ISAKMP message, to be associated with a trap.')
bsnResponderCookie = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnResponderCookie.setStatus('current')
if mibBuilder.loadTexts: bsnResponderCookie.setDescription('The responder cookie used in an ISAKMP message, to be associated with a trap.')
bsnIsakmpInvalidCookies = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 17), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnIsakmpInvalidCookies.setStatus('current')
if mibBuilder.loadTexts: bsnIsakmpInvalidCookies.setDescription('')
bsnIpsecTrapsMask = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnIpsecTrapsMask.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecTrapsMask.setDescription('This mask describes what events merit traps to network management. If the bit for a particular event is turned on then notification will be generated on event occurance. Event corresponding bit ----- ----------------- bsnIpsecEspAuthFailureTrap 1 bsnIpsecEspReplayFailureTrap 2 bsnIpsecEspPolicyFailureTrap 4 bsnIpsecEspInvalidSpiTrap 8 bsnIpsecOtherPolicyFailureTrap 16 bsnIpsecIkeNegFailure 32 bsnIpsecSuiteNegFailure 64 bsnIpsecInvalidCookieTrap 128')
bsnIpsecEspAuthFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 28)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecErrorCount"))
if mibBuilder.loadTexts: bsnIpsecEspAuthFailureTrap.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecEspAuthFailureTrap.setDescription('IPsec packets with invalid hashes were found in an inbound ESP SA. The total number of authentication errors accumulated is sent for the specific row of the ipsecSaEspInTable table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.')
bsnIpsecEspReplayFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 29)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecErrorCount"))
if mibBuilder.loadTexts: bsnIpsecEspReplayFailureTrap.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecEspReplayFailureTrap.setDescription('IPsec packets with invalid sequence numbers were found in an inbound ESP SA. The total number of replay errors accumulated is sent for the specific row of the ipsecSaEspInTable table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.')
bsnIpsecEspInvalidSpiTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 31)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecSPI"))
if mibBuilder.loadTexts: bsnIpsecEspInvalidSpiTrap.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecEspInvalidSpiTrap.setDescription('A packet with an unknown SPI was detected from the specified peer with the specified SPI using the specified protocol. The destination address of the received packet is specified by ipsecLocalAddress. The value ifIndex may be 0 if this optional linkage is unsupported. If the object ipsecSecurityProtocol has the value for IPcomp, then the ipsecSPI object is the CPI of the packet. Implementations SHOULD send one trap per peer (within a reasonable time period), rather than sending one trap per packet.')
bsnIpsecIkeNegFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 33)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteUdpPort"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeAuthMethod"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitNoResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalRespFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesReceived"))
if mibBuilder.loadTexts: bsnIpsecIkeNegFailure.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecIkeNegFailure.setDescription('An attempt to negotiate a phase 1 IKE SA failed. The notification counts are also sent as part of the trap, along with the current value of the total negotiation error counters for ISAKMP.')
bsnIpsecSuiteNegFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 34)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteRespondFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesReceived"))
if mibBuilder.loadTexts: bsnIpsecSuiteNegFailure.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecSuiteNegFailure.setDescription('An attempt to negotiate a phase 2 SA suite for the specified selector failed. The current total failure counts are passed as well as the notification type counts for the notify involved in the failure.')
bsnIpsecInvalidCookieTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 35)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteUdpPort"), ("AIRESPACE-WIRELESS-MIB", "bsnInitiatorCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnResponderCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnIsakmpInvalidCookies"))
if mibBuilder.loadTexts: bsnIpsecInvalidCookieTrap.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecInvalidCookieTrap.setDescription('ISAKMP packets with invalid cookies were detected from the specified source, intended for the specified destination. The initiator and responder cookies are also sent with the trap. The current count is sent to allow the trap to accurately relfect dropped and throttled traps. Implementations SHOULD send one trap per peer (within a reasonable time period, rather than sending one trap per packet.')
bsnRogueAPTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnRogueAPTrapEnable.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPTrapEnable.setDescription('If Rogue AP Detection and Removed Traps need to be sent ')
bsnRogueAPDetected = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 36)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAdhocMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPClassType"))
if mibBuilder.loadTexts: bsnRogueAPDetected.setStatus('deprecated')
if mibBuilder.loadTexts: bsnRogueAPDetected.setDescription('When a Rogue AP is detected this Trap will be sent out along with APMacAddress on which its detected')
bsnRogueAPRemoved = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 41)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPName"))
if mibBuilder.loadTexts: bsnRogueAPRemoved.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPRemoved.setDescription('When a Rogue AP that was detected earlier no longer exists this Trap will be sent out along with APMacAddress on which its detected')
bsnRogueAPDetectedOnWiredNetwork = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 59)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnRogueAPDetectedOnWiredNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPDetectedOnWiredNetwork.setDescription('When a Rogue is detected on the wired network this trap will be sent out. The same trap with bsnRogueAPOnWiredNetwork set to no will clear the previous trap.')
bsnApHasNoRadioCards = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 60)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnApHasNoRadioCards.setStatus('current')
if mibBuilder.loadTexts: bsnApHasNoRadioCards.setDescription('When an AP has no radio cards present on it, the switch sends this trap.')
bsnDuplicateIpAddressReported = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 61)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpReportedByAP"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapClear"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnDuplicateIpAddressReported.setStatus('current')
if mibBuilder.loadTexts: bsnDuplicateIpAddressReported.setDescription('This trap is issued when the switch or an AP detects another machine using its IP Address. The first variable has value yes if the duplicate IP is reported by an AP. In that case, the second attribute will carry the AP MAC Address. The third variable is the duplicate IP address in question and the last attribute is the MAC Address of the machine that is found to be using the duplicate IP.')
bsnAPContainedAsARogue = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 62)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPContainedAsARogue.setStatus('current')
if mibBuilder.loadTexts: bsnAPContainedAsARogue.setDescription('When our AP detects that it is being contained by another AP, this trap is issued. The clear flag is true if the AP is no longer being contained.')
bsnNetworkStateChanged = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 69)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnNetworkType"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkState"))
if mibBuilder.loadTexts: bsnNetworkStateChanged.setStatus('current')
if mibBuilder.loadTexts: bsnNetworkStateChanged.setDescription('When the 802.11a or b/g network state is changed this trap is issued.')
bsnSignatureAttackDetected = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 70)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureType"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackPreced"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackerMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureMacInfo"))
if mibBuilder.loadTexts: bsnSignatureAttackDetected.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureAttackDetected.setDescription("This trap is sent out when a signature attack is detected by the switch. The standard and custom signatures are predefined on the switch (see bsnSignatureConfig group). The signatures also defines if its detection should be reported. The trap variables bsnSignatureName and bsnSignatureDescription are retrieved from the detected signature definition. Clear Trap Variable is turned on when the signature attack stops. The signature's quiet time configuration speicifes the time after which the clear trap would be sent. bsnSignatureMacInfo indicates whether the signature is used to track pattern matches for all source MAC addresses together or seperately for individual source MAC addresses. bsnSignatureAttackFrequency will carry the value for a specific MAC address or for all MAC addresses depending on bsnSignatureMacInfo. ")
bsnAPRadioCardTxFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 71)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPRadioCardTxFailure.setStatus('current')
if mibBuilder.loadTexts: bsnAPRadioCardTxFailure.setDescription('This trap is sent by the switch when a radio card on an AP stops transmitting.')
bsnAPRadioCardTxFailureClear = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 72)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPRadioCardTxFailureClear.setStatus('current')
if mibBuilder.loadTexts: bsnAPRadioCardTxFailureClear.setDescription('This trap is sent by the switch when a radio card on an AP starts transmitting again after a prior failure.')
bsnAPRadioCardRxFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 73)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPRadioCardRxFailure.setStatus('current')
if mibBuilder.loadTexts: bsnAPRadioCardRxFailure.setDescription('This trap is sent by the switch when a radio card on an AP stops receiving.')
bsnAPRadioCardRxFailureClear = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 74)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPRadioCardRxFailureClear.setStatus('current')
if mibBuilder.loadTexts: bsnAPRadioCardRxFailureClear.setDescription('This trap is sent by the switch when a radio card on an AP starts receiving again after a prior failure.')
bsnAPImpersonationDetected = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 75)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnImpersonatedAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnImpersonatingSourceMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPImpersonationDetected.setStatus('current')
if mibBuilder.loadTexts: bsnAPImpersonationDetected.setDescription("This trap is sent by the switch when a radio of an authenticated AP hears from another AP whose MAC Address neither matches that of a rogue's and nor is it an authenticated neighbor of the detecting AP.")
bsnAPRegulatoryDomainMismatch = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 79)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnApRegulatoryDomain"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11CountryIndex"))
if mibBuilder.loadTexts: bsnAPRegulatoryDomainMismatch.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPRegulatoryDomainMismatch.setDescription("This trap is generated if an AP's regulatory domain doesn't match the country the switch is configured for. Due to the mismatch, the AP will fail to associate with the Switch.")
bsnTrustedApHasInvalidPreamble = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 76)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnTrustedApHasInvalidPreamble.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApHasInvalidPreamble.setDescription('Issued when a Trusted Rogue AP is auto contained for using invalid preamble. The second param is for the preamble used and the third param is for preamble required. If the clear variable has value true, then the trap clears the earlier alert.')
bsnCurrentRadiosCount = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 18), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnCurrentRadiosCount.setStatus('current')
if mibBuilder.loadTexts: bsnCurrentRadiosCount.setDescription('')
bsnLicenseRadioCount = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 19), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnLicenseRadioCount.setStatus('current')
if mibBuilder.loadTexts: bsnLicenseRadioCount.setDescription('')
bsnMaxRogueCount = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 33), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnMaxRogueCount.setStatus('current')
if mibBuilder.loadTexts: bsnMaxRogueCount.setDescription('')
bsnStationMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 34), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnStationMacAddress.setDescription('')
bsnStationAPMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 35), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationAPMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnStationAPMacAddr.setDescription('')
bsnStationAPIfSlotId = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationAPIfSlotId.setStatus('current')
if mibBuilder.loadTexts: bsnStationAPIfSlotId.setDescription('')
bsnStationReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 40, 41, 42, 43, 44, 45, 46, 99, 101, 105, 106, 200, 201, 202, 203))).clone(namedValues=NamedValues(("unspecified", 1), ("previousAuthNotValid", 2), ("deauthenticationLeaving", 3), ("disassociationDueToInactivity", 4), ("disassociationAPBusy", 5), ("class2FrameFromNonAuthStation", 6), ("class2FrameFromNonAssStation", 7), ("disassociationStaHasLeft", 8), ("staReqAssociationWithoutAuth", 9), ("invalidInformationElement", 40), ("groupCipherInvalid", 41), ("unicastCipherInvalid", 42), ("akmpInvalid", 43), ("unsupportedRsnVersion", 44), ("invalidRsnIeCapabilities", 45), ("cipherSuiteRejected", 46), ("missingReasonCode", 99), ("maxAssociatedClientsReached", 101), ("maxAssociatedClientsReachedOnRadio", 105), ("maxAssociatedClientsReachedOnWlan", 106), ("unSpecifiedQosFailure", 200), ("qosPolicyMismatch", 201), ("inSufficientBandwidth", 202), ("inValidQosParams", 203)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationReasonCode.setStatus('current')
if mibBuilder.loadTexts: bsnStationReasonCode.setDescription('unspecified - Unspecified. previousAuthNotValid - Previous Authentication was not valid. deauthenticationLeaving - Leaving due to deauthentication. disassociationDueToInactivity - Disassociation due to Inactivity. disassociationAPBusy - Disassociation since AP was busy. class2FrameFromNonAuthStation - Class 2 frame from non authenticated station. class2FrameFromNonAssStation - Class 2 frame from non associated station. disassociationStaHasLeft - Station has left due to disassociation. staReqAssociationWithoutAuth - Station send association request without authentication. invalidInformationElement - Invalid information element. groupCipherInvalid - Invalid group Cipher. unicastCipherInvalid - Invalid unicast cipher. akmpInvalid - Invalid AKMP. unsupportedRsnVersion - Unsupported RSN version. invalidRsnIeCapabilities - Invalid RSN IE capabilities. cipherSuiteRejected - Cipher suite rejected. missingReasonCode - Reason code is missing. maxAssociatedClientsReached - Maximum allowed associated client number has reached. maxAssociatedClientsReachedOnRadio - Maximum allowed associated client number has reached on radio. maxAssociatedClientsReachedOnWlan - Maximum allowed associated client number has reached on wlan. unSpecifiedQosFailure - Unsupported QOS failure. qosPolicyMismatch - Mismatch on QOS policy. inSufficientBandwidth - Insufficient bandwidth. inValidQosParams - Invalid QOS parameters.')
bsnStationBlacklistingReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("failed80211Auth", 1), ("failedAssociation", 2), ("ipTheft", 3), ("failed8021xAuth", 4), ("failedWebAuth", 5)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationBlacklistingReasonCode.setStatus('current')
if mibBuilder.loadTexts: bsnStationBlacklistingReasonCode.setDescription('')
bsnStationUserName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 39), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnStationUserName.setStatus('current')
if mibBuilder.loadTexts: bsnStationUserName.setDescription('The user name of a client. This is used for the Client Associated trap. It may be null when not known.')
bsnRogueAPOnWiredNetwork = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnRogueAPOnWiredNetwork.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAPOnWiredNetwork.setDescription('This is the flag used on the bsnRogueAPDetected trap to state if the rogue is found on the wired network. Typically, after a rogue is found, there may be another bsnRogueAPDetected trap that will have the value of this flag 1 if the rogue is detected on the wired network.')
bsnNavDosAttackSourceMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 41), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNavDosAttackSourceMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnNavDosAttackSourceMacAddr.setDescription('MAC address generating the attack.')
bsnWlanIdTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 517))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnWlanIdTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnWlanIdTrapVariable.setDescription('WLAN ID used by the client when the WPA MIC error counter measure was activated.')
bsnUserIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 43), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnUserIpAddress.setStatus('current')
if mibBuilder.loadTexts: bsnUserIpAddress.setDescription('')
bsnRogueAdhocMode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnRogueAdhocMode.setStatus('current')
if mibBuilder.loadTexts: bsnRogueAdhocMode.setDescription('This is the flag used on the bsnRogueAPDetected trap to state if the rogue found is an Adhoc rogue or it is an AP.')
bsnClearTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnClearTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnClearTrapVariable.setDescription('This is the flag is used to indicate if this is a clear trap for the original alert or not.')
bsnDuplicateIpTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 46), IpAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnDuplicateIpTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnDuplicateIpTrapVariable.setDescription('This field is used on the bsnDuplicateIpAddressReported trap to contain the IP Address in question when switch or an AP detected a duplicate IP Address on another machine.')
bsnDuplicateIpTrapClear = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnDuplicateIpTrapClear.setStatus('current')
if mibBuilder.loadTexts: bsnDuplicateIpTrapClear.setDescription('This is the flag used to indicate clear state for the bsnDuplicateIpAddressReported trap.')
bsnDuplicateIpReportedByAP = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnDuplicateIpReportedByAP.setStatus('current')
if mibBuilder.loadTexts: bsnDuplicateIpReportedByAP.setDescription('This is the flag used on the bsnDuplicateIpAddressReported trap to indicate whether the switch or an AP detected a duplicate IP Address on another machine.')
bsnTrustedApRadioPolicyRequired = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dot11b", 1), ("dot11a", 2), ("dot11bg", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApRadioPolicyRequired.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApRadioPolicyRequired.setDescription('This is the radio policy required by a trusted Rogue.')
bsnTrustedApEncryptionUsed = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("open", 1), ("wep", 2), ("wpa", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApEncryptionUsed.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApEncryptionUsed.setDescription('This is the encryption type used by a trusted Rogue.')
bsnTrustedApEncryptionRequired = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("open", 1), ("wep", 2), ("wpa", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApEncryptionRequired.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApEncryptionRequired.setDescription('This is the encryption type required by a trusted Rogue.')
bsnTrustedApRadioPolicyUsed = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dot11b", 1), ("dot11a", 2), ("dot11bg", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApRadioPolicyUsed.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApRadioPolicyUsed.setDescription('This is the radio policy used by a trusted Rogue.')
bsnNetworkType = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dot11b", 1), ("dot11a", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNetworkType.setStatus('current')
if mibBuilder.loadTexts: bsnNetworkType.setDescription('')
bsnNetworkState = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnNetworkState.setStatus('current')
if mibBuilder.loadTexts: bsnNetworkState.setDescription('')
bsnSignatureType = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("standard", 0), ("custom", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureType.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureType.setDescription('Type of Signature whose attack is detected by the switch.')
bsnSignatureName = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 56), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureName.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureName.setDescription('Name of the Signature whose attack is detected by the switch.')
bsnSignatureDescription = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 57), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureDescription.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureDescription.setDescription('Description of the Signature whose attack is detected by the switch.')
bsnImpersonatedAPMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 58), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnImpersonatedAPMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnImpersonatedAPMacAddr.setDescription('MAC Address of the AP impersonated by another AP.')
bsnTrustedApPreambleUsed = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("short", 1), ("long", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApPreambleUsed.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApPreambleUsed.setDescription('The Preamble on this detecting AP.')
bsnTrustedApPreambleRequired = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("short", 1), ("long", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnTrustedApPreambleRequired.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApPreambleRequired.setDescription('The Preamble on this detecting AP.')
bsnSignatureAttackPreced = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureAttackPreced.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureAttackPreced.setDescription('The preced in the standard/custom signature list.')
bsnSignatureAttackFrequency = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureAttackFrequency.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureAttackFrequency.setDescription('The preced in the standard/custom signature list.')
bsnSignatureAttackChannel = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureAttackChannel.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureAttackChannel.setDescription('The preced in the standard/custom signature list.')
bsnSignatureAttackerMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 64), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureAttackerMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureAttackerMacAddress.setDescription("The MAC address of the Attacker's mac-interface.")
bsnApRegulatoryDomain = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 6, 9, 16, 21, 32, 33, 34, 35, 48, 65535))).clone(namedValues=NamedValues(("a", 0), ("e", 1), ("i", 6), ("j", 9), ("c", 16), ("n", 21), ("k", 32), ("p", 33), ("s", 34), ("t", 35), ("r", 48), ("notavailable", 65535)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnApRegulatoryDomain.setStatus('current')
if mibBuilder.loadTexts: bsnApRegulatoryDomain.setDescription('The regulatory domain configured on an AP.')
bsnRadiosExceedLicenseCount = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 42)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnCurrentRadiosCount"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseRadioCount"))
if mibBuilder.loadTexts: bsnRadiosExceedLicenseCount.setStatus('current')
if mibBuilder.loadTexts: bsnRadiosExceedLicenseCount.setDescription('Whenever the currently associated Radios exceed the License Count This trap will be sent to annoy the Customer')
bsnSensedTemperatureTooHigh = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 43)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnSensorTemperature"))
if mibBuilder.loadTexts: bsnSensedTemperatureTooHigh.setStatus('current')
if mibBuilder.loadTexts: bsnSensedTemperatureTooHigh.setDescription('Temperature sensor temp too High - temp is too high on the unit. Immediate action should be taken')
bsnSensedTemperatureTooLow = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 44)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnSensorTemperature"))
if mibBuilder.loadTexts: bsnSensedTemperatureTooLow.setStatus('current')
if mibBuilder.loadTexts: bsnSensedTemperatureTooLow.setDescription('Temperature sensor temp too Low - temp is too high on the unit. Immediate action should be taken')
bsnTemperatureSensorFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 45))
if mibBuilder.loadTexts: bsnTemperatureSensorFailure.setStatus('current')
if mibBuilder.loadTexts: bsnTemperatureSensorFailure.setDescription('Temperature sensor hw failure - temp sensor has failed. Temperature is unknown')
bsnTemperatureSensorClear = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 46)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnSensorTemperature"))
if mibBuilder.loadTexts: bsnTemperatureSensorClear.setStatus('current')
if mibBuilder.loadTexts: bsnTemperatureSensorClear.setDescription('Temperature sensor clear -- temp sensor alarm condition is over. sensor is operating within proper temp range')
bsnPOEControllerFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 47))
if mibBuilder.loadTexts: bsnPOEControllerFailure.setStatus('current')
if mibBuilder.loadTexts: bsnPOEControllerFailure.setDescription('POE Controller has failed. Its a very critical trap. User intervention is required.')
bsnMaxRogueCountExceeded = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 48)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"))
if mibBuilder.loadTexts: bsnMaxRogueCountExceeded.setStatus('current')
if mibBuilder.loadTexts: bsnMaxRogueCountExceeded.setDescription('The number of rogues has exceeded the maximum Rogues allowed')
bsnMaxRogueCountClear = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 49)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"))
if mibBuilder.loadTexts: bsnMaxRogueCountClear.setStatus('current')
if mibBuilder.loadTexts: bsnMaxRogueCountClear.setDescription('The number of rogues is within the maximum Rogues allowed')
bsnApMaxRogueCountExceeded = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 50)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnApMaxRogueCountExceeded.setStatus('current')
if mibBuilder.loadTexts: bsnApMaxRogueCountExceeded.setDescription('The number of rogues has exceeded the maximum Rogues allowed on the AP')
bsnApMaxRogueCountClear = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 51)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnApMaxRogueCountClear.setStatus('current')
if mibBuilder.loadTexts: bsnApMaxRogueCountClear.setDescription('The number of rogues is within the maximum Rogues allowed on the AP')
bsnApBigNavDosAttack = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 55)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSlotIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnNavDosAttackSourceMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnApBigNavDosAttack.setStatus('current')
if mibBuilder.loadTexts: bsnApBigNavDosAttack.setDescription('The AP sent a string of messages with large NAV field. This is most likely a malicious denial of service attack.')
bsnTooManyUnsuccessLoginAttempts = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 56)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"))
if mibBuilder.loadTexts: bsnTooManyUnsuccessLoginAttempts.setStatus('current')
if mibBuilder.loadTexts: bsnTooManyUnsuccessLoginAttempts.setDescription('The Management User made too many unsuccessful login attempts.')
bsnWepKeyDecryptError = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 57)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"))
if mibBuilder.loadTexts: bsnWepKeyDecryptError.setStatus('current')
if mibBuilder.loadTexts: bsnWepKeyDecryptError.setDescription('Issued when a decrypt error occurrs. The WEP Key configured at the station may be wrong.')
bsnWpaMicErrorCounterActivated = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 58)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnWlanIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnWpaMicErrorCounterActivated.setStatus('current')
if mibBuilder.loadTexts: bsnWpaMicErrorCounterActivated.setDescription('Issued when a WPA MIC error occurs and a counter measure is activated at the AP.')
bsnAdhocRogueAutoContained = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 65)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnAdhocRogueAutoContained.setStatus('current')
if mibBuilder.loadTexts: bsnAdhocRogueAutoContained.setDescription('Issued when an Adhoc Rogue is auto contained. If the clear variable has value true, then the trap clears the earlier alert.')
bsnRogueApAutoContained = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 66)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnRogueApAutoContained.setStatus('current')
if mibBuilder.loadTexts: bsnRogueApAutoContained.setDescription('Issued when a Rogue AP is auto contained for advertising our SSID. If the clear variable has value true, then the trap clears the earlier alert.')
bsnTrustedApHasInvalidEncryption = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 67)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnTrustedApHasInvalidEncryption.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApHasInvalidEncryption.setDescription('Issued when a Trusted Rogue AP is auto contained for using invalid encryption. The second param is for the encryption used and the third param is for encryption required. If the clear variable has value true, then the trap clears the earlier alert.')
bsnTrustedApHasInvalidRadioPolicy = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 68)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnTrustedApHasInvalidRadioPolicy.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApHasInvalidRadioPolicy.setDescription('Issued when a Trusted Rogue AP is auto contained for using invalid radio policy. The second param is for the radio policy used and the third param is for radio policy required. If the clear variable has value true, then the trap clears the earlier alert.')
bsnTrustedApHasInvalidSsid = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 63)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnTrustedApHasInvalidSsid.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApHasInvalidSsid.setDescription('Issued when a Trusted Rogue AP is auto contained for advertising invalid SSID. If the clear variable has value true, then the trap clears the earlier alert.')
bsnTrustedApIsMissing = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 64)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"))
if mibBuilder.loadTexts: bsnTrustedApIsMissing.setStatus('current')
if mibBuilder.loadTexts: bsnTrustedApIsMissing.setDescription('Issued when a Trusted Rogue AP is missing or has failed. If the clear variable has value true, then the trap clears the earlier alert.')
bsnImpersonatingSourceMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 74), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnImpersonatingSourceMacAddr.setStatus('current')
if mibBuilder.loadTexts: bsnImpersonatingSourceMacAddr.setDescription('This is the source mac address which is impersonating the AP.')
bsnSyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 7, 1))
bsnSyslogEnable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSyslogEnable.setStatus('current')
if mibBuilder.loadTexts: bsnSyslogEnable.setDescription('')
bsnSyslogRemoteAddress = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 7, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnSyslogRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: bsnSyslogRemoteAddress.setDescription('This would be the IP Address or host name')
bsnPing = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2))
bsnPingTestTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1), )
if mibBuilder.loadTexts: bsnPingTestTable.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestTable.setDescription(' PingTest Table')
bsnPingTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnPingTestId"))
if mibBuilder.loadTexts: bsnPingTestEntry.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestEntry.setDescription('An Entry (conceptual row) in the bsnPingTest Table.')
bsnPingTestId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnPingTestId.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestId.setDescription('Test ID')
bsnPingTestIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnPingTestIPAddress.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestIPAddress.setDescription('Ip Address to ping')
bsnPingTestSendCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnPingTestSendCount.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestSendCount.setDescription('Number of bytes sent')
bsnPingTestReceivedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnPingTestReceivedCount.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestReceivedCount.setDescription('Number of bytes received.')
bsnPingTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inprogress", 1), ("complete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnPingTestStatus.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestStatus.setDescription('Status of the ping test')
bsnPingTestMaxTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 6), Unsigned32()).setUnits('mSec').setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnPingTestMaxTimeInterval.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestMaxTimeInterval.setDescription('Maximum time interval in msec.')
bsnPingTestMinTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 7), Unsigned32()).setUnits('mSec').setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnPingTestMinTimeInterval.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestMinTimeInterval.setDescription('Minimum time interval in msec.')
bsnPingTestAvgTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 8), Unsigned32()).setUnits('mSec').setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnPingTestAvgTimeInterval.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestAvgTimeInterval.setDescription('Average time interval in msec.')
bsnPingTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 2, 1, 1, 25), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnPingTestRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnPingTestRowStatus.setDescription('Row Status')
bsnLinkTest = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3))
bsnLinkTestTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1), )
if mibBuilder.loadTexts: bsnLinkTestTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestTable.setDescription(' LinkTest Table')
bsnLinkTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnLinkTestId"))
if mibBuilder.loadTexts: bsnLinkTestEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestEntry.setDescription('An Entry (conceptual row) in the bsnLinkTest Table.')
bsnLinkTestId = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLinkTestId.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestId.setDescription('Link Test ID')
bsnLinkTestMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLinkTestMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestMacAddress.setDescription('MAC Address of link to test')
bsnLinkTestSendPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLinkTestSendPktCount.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestSendPktCount.setDescription('Number of packets sent.')
bsnLinkTestSendPktLength = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000)).clone(500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLinkTestSendPktLength.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestSendPktLength.setDescription('Length of sent packet')
bsnLinkTestReceivedPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLinkTestReceivedPktCount.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestReceivedPktCount.setDescription('Number of received packets.')
bsnLinkTestClientRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLinkTestClientRSSI.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestClientRSSI.setDescription('Client RSSI value of link.')
bsnLinkTestLocalSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLinkTestLocalSNR.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestLocalSNR.setDescription('Local SNR of the link')
bsnLinkTestLocalRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLinkTestLocalRSSI.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestLocalRSSI.setDescription('Local RSSI of the link.')
bsnLinkTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inprogress", 1), ("complete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnLinkTestStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestStatus.setDescription('Status of the link test.')
bsnLinkTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 7, 3, 1, 1, 30), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnLinkTestRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnLinkTestRowStatus.setDescription('Row Status')
bsnMobilityConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1))
bsnMobilityStats = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2))
bsnMobilityProtocolPortNum = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMobilityProtocolPortNum.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityProtocolPortNum.setDescription('Port Number on which mobility Protocol runs')
bsnMobilityDynamicDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMobilityDynamicDiscovery.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityDynamicDiscovery.setDescription('Statically Configured is always enabled if members are defined. To further enable rrm discovery, learned discovery, broadcast discovery, enable/disable this attribute.')
bsnMobilityStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("resetNow", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnMobilityStatsReset.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityStatsReset.setDescription('Reset mobility statistics by setting this atribute to resetNow. If you try to read this attribute value will always be 0.')
bsnMobilityGroupMembersTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10), )
if mibBuilder.loadTexts: bsnMobilityGroupMembersTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMembersTable.setDescription('MWAR List (statically configured members of the mobility group)')
bsnMobilityGroupMembersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobilityGroupMemberMacAddress"))
if mibBuilder.loadTexts: bsnMobilityGroupMembersEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMembersEntry.setDescription('An Entry (conceptual row) in the bsnMobilityGroupMembers Table.')
bsnMobilityGroupMemberMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10, 1, 1), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityGroupMemberMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMemberMacAddress.setDescription('Member switch MAC Address')
bsnMobilityGroupMemberIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityGroupMemberIPAddress.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMemberIPAddress.setDescription('Member switch IP Address')
bsnMobilityGroupMemberGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityGroupMemberGroupName.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMemberGroupName.setDescription("Member's group name. If left empty while adding a new group member, this assumes the default mobility group name of the switch.")
bsnMobilityGroupMemberRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 10, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityGroupMemberRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupMemberRowStatus.setDescription('Row Status')
bsnMobilityAnchorsTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 11), )
if mibBuilder.loadTexts: bsnMobilityAnchorsTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnMobilityAnchorsTable.setDescription('Statically configured mobility anchors')
bsnMobilityAnchorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 11, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnMobilityAnchorWlanSsid"), (0, "AIRESPACE-WIRELESS-MIB", "bsnMobilityAnchorSwitchIPAddress"))
if mibBuilder.loadTexts: bsnMobilityAnchorsEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnMobilityAnchorsEntry.setDescription('An Entry (conceptual row) in the bsnMobilityAnchorsTable Table.')
bsnMobilityAnchorWlanSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 11, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityAnchorWlanSsid.setStatus('deprecated')
if mibBuilder.loadTexts: bsnMobilityAnchorWlanSsid.setDescription('Local wlan-ssid to connect to Guest/Anchor switch')
bsnMobilityAnchorSwitchIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 11, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityAnchorSwitchIPAddress.setStatus('deprecated')
if mibBuilder.loadTexts: bsnMobilityAnchorSwitchIPAddress.setDescription('Guest/Anchor switch IP Address')
bsnMobilityAnchorRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 1, 11, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnMobilityAnchorRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnMobilityAnchorRowStatus.setDescription('Row Status')
bsnTotalHandoffRequests = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequests.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequests.setDescription('Total handoff requests')
bsnTotalHandoffs = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffs.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffs.setDescription('Total handoffs')
bsnCurrentExportedClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCurrentExportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnCurrentExportedClients.setDescription('Current exported client count')
bsnTotalExportedClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalExportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnTotalExportedClients.setDescription('Total exported client count')
bsnCurrentImportedClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnCurrentImportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnCurrentImportedClients.setDescription('Current Imported client count')
bsnTotalImportedClients = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalImportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnTotalImportedClients.setDescription('Total Imported client count')
bsnTotalHandoffErrors = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffErrors.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffErrors.setDescription('Total handoff errors')
bsnTotalCommunicationErrors = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalCommunicationErrors.setStatus('current')
if mibBuilder.loadTexts: bsnTotalCommunicationErrors.setDescription('Total communication errors')
bsnTotalReceiveErrors = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: bsnTotalReceiveErrors.setDescription('Total receive errors')
bsnTotalTransmitErrors = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalTransmitErrors.setStatus('current')
if mibBuilder.loadTexts: bsnTotalTransmitErrors.setDescription('Total Transmit errors')
bsnTotalResponsesRetransmitted = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalResponsesRetransmitted.setStatus('current')
if mibBuilder.loadTexts: bsnTotalResponsesRetransmitted.setDescription('Total Responses Retransmitted')
bsnTotalHandoffEndRequestsReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffEndRequestsReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffEndRequestsReceived.setDescription('Total Handoff End Requests Received')
bsnTotalStateTransitionsDisallowed = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalStateTransitionsDisallowed.setStatus('current')
if mibBuilder.loadTexts: bsnTotalStateTransitionsDisallowed.setDescription('Total State Transitions Disallowed')
bsnTotalResourceErrors = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalResourceErrors.setStatus('current')
if mibBuilder.loadTexts: bsnTotalResourceErrors.setDescription('Total Resource Errors')
bsnTotalHandoffRequestsSent = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequestsSent.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequestsSent.setDescription('Total Handoff Requests Sent')
bsnTotalHandoffRepliesReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRepliesReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRepliesReceived.setDescription('Total Handoff Replies Received')
bsnTotalHandoffAsLocalReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffAsLocalReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffAsLocalReceived.setDescription('Total Handoffs As Local Received')
bsnTotalHandoffAsForeignReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffAsForeignReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffAsForeignReceived.setDescription('Total Handoffs As Foreign Received')
bsnTotalHandoffDeniesReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffDeniesReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffDeniesReceived.setDescription('Total Handoff Denies Received')
bsnTotalAnchorRequestsSent = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorRequestsSent.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorRequestsSent.setDescription('Total Anchor Requests Sent')
bsnTotalAnchorDenyReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorDenyReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorDenyReceived.setDescription('Total Anchor Deny Received')
bsnTotalAnchorGrantReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorGrantReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorGrantReceived.setDescription('Total Anchor Grant Received')
bsnTotalAnchorTransferReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorTransferReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorTransferReceived.setDescription('Total Anchor Transfer Received')
bsnTotalHandoffRequestsIgnored = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequestsIgnored.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequestsIgnored.setDescription('Total Handoff Requests Ignored')
bsnTotalPingPongHandoffRequestsDropped = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalPingPongHandoffRequestsDropped.setStatus('current')
if mibBuilder.loadTexts: bsnTotalPingPongHandoffRequestsDropped.setDescription('Total Ping Pong Handoff Requests Dropped')
bsnTotalHandoffRequestsDropped = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequestsDropped.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequestsDropped.setDescription('Total Handoff Requests Dropped')
bsnTotalHandoffRequestsDenied = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequestsDenied.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequestsDenied.setDescription('Total Handoff Requests Denied')
bsnTotalClientHandoffAsLocal = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalClientHandoffAsLocal.setStatus('current')
if mibBuilder.loadTexts: bsnTotalClientHandoffAsLocal.setDescription('Total Client Handoffs As Local')
bsnTotalClientHandoffAsForeign = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalClientHandoffAsForeign.setStatus('current')
if mibBuilder.loadTexts: bsnTotalClientHandoffAsForeign.setDescription('Total Client Handoffs As Foreign')
bsnTotalAnchorRequestsReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorRequestsReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorRequestsReceived.setDescription('Total Anchor Requests Received')
bsnTotalAnchorRequestsDenied = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorRequestsDenied.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorRequestsDenied.setDescription('Total Anchor Requests Denied')
bsnTotalAnchorRequestsGranted = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorRequestsGranted.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorRequestsGranted.setDescription('Total Anchor Requests Granted')
bsnTotalAnchorTransferred = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalAnchorTransferred.setStatus('current')
if mibBuilder.loadTexts: bsnTotalAnchorTransferred.setDescription('Total Anchor Transferred')
bsnTotalHandoffRequestsReceived = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnTotalHandoffRequestsReceived.setStatus('current')
if mibBuilder.loadTexts: bsnTotalHandoffRequestsReceived.setDescription('Total Handoff Requests Received')
bsnMobilityGroupDirectoryTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9), )
if mibBuilder.loadTexts: bsnMobilityGroupDirectoryTable.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupDirectoryTable.setDescription('MWAR List (statically configured members of the mobility group)')
bsnMobilityGroupDirectoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryMemberMacAddress"))
if mibBuilder.loadTexts: bsnMobilityGroupDirectoryEntry.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroupDirectoryEntry.setDescription('An Entry (conceptual row) in the bsnMobilityGroupDirectory Table.')
bsnGroupDirectoryMemberIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGroupDirectoryMemberIPAddress.setStatus('current')
if mibBuilder.loadTexts: bsnGroupDirectoryMemberIPAddress.setDescription('Mwar Ip Address')
bsnGroupDirectoryMemberMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGroupDirectoryMemberMacAddress.setStatus('current')
if mibBuilder.loadTexts: bsnGroupDirectoryMemberMacAddress.setDescription('Mwar Mac Address')
bsnGroupDirectoryDicoveryType = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("rrm", 2), ("broadcast", 3), ("learned", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnGroupDirectoryDicoveryType.setStatus('current')
if mibBuilder.loadTexts: bsnGroupDirectoryDicoveryType.setDescription('Discovery type of the Group Directory.')
bsnMemberCurrentAnchoredClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberCurrentAnchoredClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberCurrentAnchoredClients.setDescription('Current anchored client count')
bsnMemberTotalAnchoredClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberTotalAnchoredClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberTotalAnchoredClients.setDescription('Total anchored client count')
bsnMemberCurrentExportedClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberCurrentExportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberCurrentExportedClients.setDescription('Current exported client count')
bsnMemberTotalExportedClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberTotalExportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberTotalExportedClients.setDescription('Total exported client count')
bsnMemberCurrentImportedClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberCurrentImportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberCurrentImportedClients.setDescription('Current Imported client count')
bsnMemberTotalImportedClients = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberTotalImportedClients.setStatus('current')
if mibBuilder.loadTexts: bsnMemberTotalImportedClients.setDescription('Total Imported client count')
bsnMemberTotalHandoffErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberTotalHandoffErrors.setStatus('current')
if mibBuilder.loadTexts: bsnMemberTotalHandoffErrors.setDescription('Total handoff errors')
bsnMemberTotalCommunicationErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 8, 2, 9, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsnMemberTotalCommunicationErrors.setStatus('current')
if mibBuilder.loadTexts: bsnMemberTotalCommunicationErrors.setDescription('Total Communication errors')
bsnAPGroupsVlanConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 14179, 2, 10))
bsnAPGroupsVlanFeature = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsnAPGroupsVlanFeature.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanFeature.setDescription('When enabled, Site Specific WLAN feature is enforced.')
bsnAPGroupsVlanTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 10, 2), )
if mibBuilder.loadTexts: bsnAPGroupsVlanTable.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanTable.setDescription('Wireless Sites Table.')
bsnAPGroupsVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 10, 2, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanName"))
if mibBuilder.loadTexts: bsnAPGroupsVlanEntry.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanEntry.setDescription('An entry in bsnAPGroupsVlanTable.')
bsnAPGroupsVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanName.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanName.setDescription('The string is an unique identifier/name assigned to a site.')
bsnAPGroupsVlanDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanDescription.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanDescription.setDescription('Description about the site.')
bsnAPGroupsVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 2, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: bsnAPGroupsVlanRowStatus.setDescription('Row Status for creation/deletion of entries in bsnAPGroupsVlanTable')
bsnAPGroupsVlanMappingTable = MibTable((1, 3, 6, 1, 4, 1, 14179, 2, 10, 3), )
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingTable.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingTable.setDescription('A table for the WLAN-interace-mappings allowed for each configured site. Each site can have a set of WLANs associated with it.')
bsnAPGroupsVlanMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14179, 2, 10, 3, 1), ).setIndexNames((0, "AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanName"), (0, "AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanMappingSsid"))
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingEntry.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingEntry.setDescription('An entry in bsnAPGroupsVlanMappingTable.')
bsnAPGroupsVlanMappingSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingSsid.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingSsid.setDescription("When an AP is associated with a site, and the site has an associated set of WLANs, then only those WLANs are beamed by the AP. Here 'bsnAPGroupsVlanMappingSsid' is the wlan to be used when a client connects on this AP.")
bsnAPGroupsVlanMappingInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingInterfaceName.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingInterfaceName.setDescription("When an AP is associated with a site, and the site has an associated set of WLANs, then only those WLANs are beamed by the AP. Here 'bsnAPGroupsVlanMappingInterfaceName' is the interface to be used when a client connects to the 'bsnAPGroupsVlanMappingSsid' WLAN on this AP.")
bsnAPGroupsVlanMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 14179, 2, 10, 3, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAPGroupsVlanMappingRowStatus.setDescription('Row Status for creation/deletion of WLAN-interface-mappings asscoiated with sites.')
bsnAPIPAddressFallback = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 77)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnApIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPStaticIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnAPIPAddressFallback.setStatus('current')
if mibBuilder.loadTexts: bsnAPIPAddressFallback.setDescription('This trap is sent out when an AP, with the configured static ip-address, fails to establish connection with outside world and starts using DHCP as a fallback option.')
bsnAPFunctionalityDisabled = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 78)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnApFunctionalityDisableReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyFeatureSetTrapVariable"))
if mibBuilder.loadTexts: bsnAPFunctionalityDisabled.setStatus('current')
if mibBuilder.loadTexts: bsnAPFunctionalityDisabled.setDescription("This trap is sent out when AP functionality on the switch is disabled because the License key has expired or has been deleted or doesn't match the switch image.")
bsnLicenseKeyTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 65), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnLicenseKeyTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnLicenseKeyTrapVariable.setDescription('This is the license key that has been found to be deleted, expired or is mismatched causing AP functionality to be disabled on the switch.')
bsnApFunctionalityDisableReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("licenseKeyExpired", 1), ("licenseKeyDeleted", 2), ("licenseKeyFeatureMismatch", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnApFunctionalityDisableReasonCode.setStatus('current')
if mibBuilder.loadTexts: bsnApFunctionalityDisableReasonCode.setDescription('This is the reason why the AP functionality was disabled on the switch. It could be either expiry or deletion or mismatch found of the license key.')
bsnLicenseKeyFeatureSetTrapVariable = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wps", 1), ("all", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnLicenseKeyFeatureSetTrapVariable.setStatus('current')
if mibBuilder.loadTexts: bsnLicenseKeyFeatureSetTrapVariable.setDescription('This is the switch feature set whose license key has expired or is deleted or is mismatched. To enable the AP functionality again, the license key for this feature set should be re-configured.')
bsnRxMulticastQueueFull = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 80))
if mibBuilder.loadTexts: bsnRxMulticastQueueFull.setStatus('current')
if mibBuilder.loadTexts: bsnRxMulticastQueueFull.setDescription("This trap indicates that the CPU's Receive Multicast Queue is Full.")
bsnAPAuthorizationFailureCause = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 0), ("keymismatch", 1), ("entrydoesnotexist", 2), ("invalidCertifcate", 3), ("entryIsMIC", 4), ("aaaEntryDoesNotExist", 5)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPAuthorizationFailureCause.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthorizationFailureCause.setDescription("This denotes the reason for AP authorization failure. [entrydoesnotexist]: The AP has not been added to Controller's AP Authorization List. [keymismatch]: The key entry in Controller's AP Authorization list does not match the SHA1 key received from the AP. [invalidCert]: Could not verify the self signed Certificate. [entryIsMIC]: AP has Self Signed Certificate where as in Controller AP Authorization list has Manufactured Installed Certificate [aaaEntryDoesNotExist]: RADIUS authorization for the AP failed. [unknown]: Default.")
bsnAPIfUpDownCause = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 0), ("radioFailure", 1), ("radioLowPower", 2), ("maxRetransmission", 3), ("echoTimeout", 4), ("configAP", 5), ("configRadio", 6), ("configNetwork", 7), ("adminConfigured", 8), ("missedRekey", 9), ("detectingInLinePower", 10), ("newDiscovery", 11)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPIfUpDownCause.setStatus('current')
if mibBuilder.loadTexts: bsnAPIfUpDownCause.setDescription('This denotes the reason for AP If up or down normal - radio Failure - radio failed radioLowPower - AP is not able draw enough power. maxRetransmission - max retransmission of AP Reached. echoTimeout - heartbeat timeout. configAP - admin enable/disable AP configRadio - admin enable/disable config radio configNetwork - admin enable/disable network adminConfigured - admin configuration missedRekey - Missed Rekey detectingInLinePower - Detecting in-line power newDiscovery - New Discovery')
bsnAPInvalidRadioType = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("unsupportedRadio", 0)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnAPInvalidRadioType.setStatus('current')
if mibBuilder.loadTexts: bsnAPInvalidRadioType.setDescription('Radio types which are not supported by controller.')
locationNotifyContent = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 72), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: locationNotifyContent.setStatus('current')
if mibBuilder.loadTexts: locationNotifyContent.setDescription('This is the content of the notification.')
bsnSignatureMacInfo = MibScalar((1, 3, 6, 1, 4, 1, 14179, 2, 6, 2, 73), BsnTxtSignatureMacInfo()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: bsnSignatureMacInfo.setStatus('current')
if mibBuilder.loadTexts: bsnSignatureMacInfo.setDescription('This object defines the pattern followed by the LWAPP APs to perform signature analysis with this signature and report the results to the Controller. ')
bsnRadarChannelDetected = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 81)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnRadarChannelDetected.setStatus('current')
if mibBuilder.loadTexts: bsnRadarChannelDetected.setDescription('This trap is sent when radar signals are detected on the current channel')
bsnRadarChannelCleared = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 82)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: bsnRadarChannelCleared.setStatus('current')
if mibBuilder.loadTexts: bsnRadarChannelCleared.setDescription('This trap will be generated, if a radar trap has been generated earlier, after the expiry of Non-Occupancy Period.')
bsnAPAuthorizationFailure = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 83)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthCertificateType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthorizationFailureCause"))
if mibBuilder.loadTexts: bsnAPAuthorizationFailure.setStatus('current')
if mibBuilder.loadTexts: bsnAPAuthorizationFailure.setDescription('This trap is sent out in case of authorization failure while attempting to associate the AP to the controller. bsnAPDot3MacAddress represents the mac-address of that AP. bsnAPName is name of AP')
radioCoreDumpTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 84)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: radioCoreDumpTrap.setStatus('current')
if mibBuilder.loadTexts: radioCoreDumpTrap.setDescription('When radio module in AP dumps core, it informs controller and controller generates this trap. The core file can be retrieved on demand.')
invalidRadioTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 85)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInvalidRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: invalidRadioTrap.setStatus('current')
if mibBuilder.loadTexts: invalidRadioTrap.setDescription('This trap will be generated when an AP has joined is using unsupported radio or a radio slot not currently not being used.')
countryChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 86)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11CountryIndex"))
if mibBuilder.loadTexts: countryChangeTrap.setStatus('deprecated')
if mibBuilder.loadTexts: countryChangeTrap.setDescription('This trap will be generated when an operator changes the country of operation. New country code will be sent in trap.')
unsupportedAPTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 87)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"))
if mibBuilder.loadTexts: unsupportedAPTrap.setStatus('current')
if mibBuilder.loadTexts: unsupportedAPTrap.setDescription('This trap will be generated when unsupported AP try to join 40xx/410x or 3500 with 64MB flash.')
heartbeatLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 88))
if mibBuilder.loadTexts: heartbeatLossTrap.setStatus('current')
if mibBuilder.loadTexts: heartbeatLossTrap.setDescription("This trap will be generated when controller loses connection with the Supervisor Switch in which it is physically embedded and doesn't hear the heartbeat keepalives from the Supervisor. ")
locationNotifyTrap = NotificationType((1, 3, 6, 1, 4, 1, 14179, 2, 6, 3, 89)).setObjects(("AIRESPACE-WIRELESS-MIB", "locationNotifyContent"))
if mibBuilder.loadTexts: locationNotifyTrap.setStatus('current')
if mibBuilder.loadTexts: locationNotifyTrap.setDescription('This trap will be generated by the location server for notifications of location events.')
bsnWrasCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 14179, 2, 51, 1)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnEssGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnApGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11Group"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnAAAGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnTrapsGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnUtilityGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasCompliance = bsnWrasCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasCompliance.setDescription('The compliance statement for the SNMP entities that implement the bsnWireless module.')
bsnWrasComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 14179, 2, 51, 2)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnEssGroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnApGroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11GroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnAAAGroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnTrapsGroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasTrapRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnUtilityGroupRev1"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasComplianceRev1 = bsnWrasComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: bsnWrasComplianceRev1.setDescription('The compliance statement for the SNMP entities that implement the bsnWireless module.')
bsnEssGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 1)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSessionTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssMacFiltering"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSecurityAuthType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPEncryptionType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPDefaultKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPKeyIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess8021xSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess8021xEncryptionType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIpsecSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnEncrTransform"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnAuthTransform"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeAuthMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnSharedKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnSharedKeySize"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkePhase1Mode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIpsecPassthruSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnPassthruGateway"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadioPolicy"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssQualityOfService"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDhcpRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDhcpServerIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnContivityMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnQotdServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBlacklistTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssNumberOfMobileStations"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebPassthru"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssCraniteSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBlacklistingCapability"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAAAOverride"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWepAllowSharedKeyAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssFortressSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssL2tpSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBroadcastSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssExternalPolicyValidation"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWmePolicySetting"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess80211ePolicySetting"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebPassthroughEmail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess7920PhoneSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthPrimaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthSecondaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthTertiaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctPrimaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctSecondaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctTertiaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEssIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMobilityStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAID"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAnchorAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPBCCOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationShortPreambleOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSessionTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAuthenticationAlgorithm"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationWepState"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationDeleteAction"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyManagerState"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSecurityPolicyStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMirrorMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationInterface"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationApMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationVlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEncryptionCypher"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEapType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCcxVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationE2eVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationStatusCode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPerRadioPerVapIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationBytesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationBytesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPacketsReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPacketsSent"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTotalDetectingAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPFirstReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTotalClients"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPMaxDetectedRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPState"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentChannelCount"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPWepMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPWpaMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByIpMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiData"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientTotalDetectingAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientFirstReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientBSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientContainmentLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientState"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientDot11MacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileDesc"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosAverageDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosBurstDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosAvgRealTimeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosBurstRealTimeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosMaxRFUsagePerAP"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileQueueDepth"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11WiredQosProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11802Dot1PTag"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11ResetProfileToDefault"), ("AIRESPACE-WIRELESS-MIB", "bsnTagDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTagType"), ("AIRESPACE-WIRELESS-MIB", "bsnTagTimeInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnTagBatteryStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnTagLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApName"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiData"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnTagBytesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTagPacketsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnEssGroup = bsnEssGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnEssGroup.setDescription('This collection of objects provides information about Airespace Wireless LAN Configuration Attributes These objects are defined under bsnEss object.')
bsnApGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 2)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNumOfSlots"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLocation"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMonitorOnlyMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPOperationStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSoftwareVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPBootVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPrimaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPReset"), ("AIRESPACE-WIRELESS-MIB", "bsnAPStatsTimer"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPModel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSerialNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPClearConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnApIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMirrorMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRemoteModeSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSecondaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPTertiaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIsStaticIP"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGateway"), ("AIRESPACE-WIRELESS-MIB", "bsnAPStaticIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPBridgingSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupVlanName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIOSVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCertificateType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPEthernetMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyTxPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaDiversity"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCellSiteConfigId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNumberOfVaps"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfOperStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaOptions"), ("AIRESPACE-WIRELESS-MIB", "bsnApIfNoOfUsers"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverride"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPacketsSniffingFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSniffChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSniffServerIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAntennaGain"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfChannelList"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAbsolutePowerList"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRegulatoryDomainSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11BeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11OperationalRateSet"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11DTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultiDomainCapabilityImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultiDomainCapabilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CountryString"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11SmtParamsConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11BSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MaximumTransmitPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FirstChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11NumberofChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacParamsConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TransmittedFragmentCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MulticastTransmittedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RetryCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultipleRetryCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FrameDuplicateCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RTSSuccessCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RTSFailureCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11ACKFailureCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11ReceivedFragmentCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MulticastReceivedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FCSErrorCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TransmittedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11WEPUndecryptableCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FailedCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11EDThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TIThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfProfileParamAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfForeignInterferenceThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfForeignNoiseThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRFUtilizationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfThroughputThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfMobilesThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfMobileMinExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadRxUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadTxUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadChannelUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadNumOfClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPoorSNRClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceChannelNo"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferencePower"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNoiseChannelNo"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDBNoisePower"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNoiseProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborSlot"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationRSSICoverageIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRSSILevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationCountOnRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationSNRCoverageIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSNRLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationCountOnSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRole"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaul"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaulPAP"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaulRAP"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRoutingState"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeMalformedNeighPackets"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodePoorNeighSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBlacklistPackets"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeInsufficientMemory"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRxNeighReq"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRxNeighRsp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeTxNeighReq"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeTxNeighRsp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeParentChanges"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeNeighTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeParentMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeEthernetBridge"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeHops"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighType"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighState"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnrUp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnrDown"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighLinkSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighAdjustedEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighUnadjustedEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighRapEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighTxParent"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighRxParent"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighPoorSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighLastUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighParentChange"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRadarDetectedChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRadarSignalLastHeard"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnApGroup = bsnApGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnApGroup.setDescription('This collection of objects provide the information about Airespace APs that are associated with the Switch. These objects are defined under bsnAP object.')
bsnGlobalDot11Group = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 3)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11PrivacyOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11AuthenticationResponseTimeOut"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11MultiDomainCapabilityImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11MultiDomainCapabilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11CountryIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11LoadBalancing"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11RogueTimer"), ("AIRESPACE-WIRELESS-MIB", "bsnPrimaryMwarForAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRtpProtocolPriority"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemCurrentTime"), ("AIRESPACE-WIRELESS-MIB", "bsnUpdateSystemTime"), ("AIRESPACE-WIRELESS-MIB", "bsnOperatingTemperatureEnvironment"), ("AIRESPACE-WIRELESS-MIB", "bsnSensorTemperature"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureAlarmLowLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureAlarmHighLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnVirtualGatewayAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRFMobilityDomainName"), ("AIRESPACE-WIRELESS-MIB", "bsnClientWatchListFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueLocationDiscoveryProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAutoContainFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnOverAirProvisionApMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMaximumNumberOfConcurrentLogins"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainRoguesAdvertisingSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainAdhocNetworks"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainTrustedClientsOnRogueAps"), ("AIRESPACE-WIRELESS-MIB", "bsnValidateRogueClientsAgainstAAA"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemTimezoneDelta"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemTimezoneDeltaMinutes"), ("AIRESPACE-WIRELESS-MIB", "bsnAllowAuthorizeApAgainstAAA"), ("AIRESPACE-WIRELESS-MIB", "bsnApFallbackEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnAppleTalkEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnPolicyForMisconfiguredAps"), ("AIRESPACE-WIRELESS-MIB", "bsnEncryptionPolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnPreamblePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11ModePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnRadioTypePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnValidateSsidForTrustedAp"), ("AIRESPACE-WIRELESS-MIB", "bsnAlertIfTrustedApMissing"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEntryExpirationTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive80211AssocFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive80211AuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive8021xAuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessiveWebAuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnIPTheftORReuse"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePrecedence"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureFrameType"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureAction"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureState"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureQuietTime"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureMacInfo"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureMacFreq"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternOffset"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternString"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternMask"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternOffSetStart"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePrecedence"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureFrameType"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureAction"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureState"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureQuietTime"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureMacInfo"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureMacFreq"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternOffset"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternString"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternMask"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternOffSetStart"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureCheckState"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagDataTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagAutoTimeoutStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNeighborAuthStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNeighborAuthAlarmThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRFNetworkName"), ("AIRESPACE-WIRELESS-MIB", "bsnFastSSIDChangeFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnBridgingZeroTouchConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnBridgingSharedSecretKey"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bNetworkStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bBeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCurrentChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicChannelUpdateInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bInputsForDCA"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicTransmitPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicTxPowerControlInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCurrentTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bInputsForDTP"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPowerUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPowerUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate1Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate2Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate5AndHalfMhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate11Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDot11gSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate6Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate9Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate12Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate18Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate24Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate36Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate48Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate54Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPicoCellMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingVoipMinRate"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingVoipPercentage"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11b80211eMaxBandwidth"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDTPCSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bRxSopThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMaximumTransmitPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFirstChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bNumberofChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bEDThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPBCCOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortPreambleOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aNetworkStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aLowBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMediumBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aHighBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aBeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCurrentChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicChannelUpdateInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aInputsForDCA"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicTransmitPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCurrentTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicTxPowerControlInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aInputsForDTP"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPowerUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPowerUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate6Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate9Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate12Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate18Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate24Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate36Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate48Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate54Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPicoCellMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingVoipMinRate"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingVoipPercentage"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11a80211eMaxBandwidth"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDTPCSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aRxSopThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMaximumTransmitPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFirstChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aNumberofChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aTIThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hPowerConstraint"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hChannelSwitchEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hChannelSwitchMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aGlobalAutomaticGrouping"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnGlobalDot11Group = bsnGlobalDot11Group.setStatus('deprecated')
if mibBuilder.loadTexts: bsnGlobalDot11Group.setDescription('This collection of objects provide the information about Airespace 802.11 standard attributes applied globally. These objects are defined under bsnGlobalDot11 object.')
bsnRrmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 4)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aForeignInterferenceThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aForeignNoiseThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aRFUtilizationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aThroughputThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aMobilesThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aCoverageThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aMobileMinExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aCoverageExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aSignalMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aNoiseMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aLoadMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aCoverageMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aChannelMonitorList"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aSetFactoryDefault"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bForeignInterferenceThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bForeignNoiseThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bRFUtilizationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bThroughputThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bMobilesThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bCoverageThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bMobileMinExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bCoverageExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bSignalMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bNoiseMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bLoadMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bCoverageMeasurementInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bChannelMonitorList"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bSetFactoryDefault"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnRrmGroup = bsnRrmGroup.setStatus('current')
if mibBuilder.loadTexts: bsnRrmGroup.setDescription('This collection of objects provide the information about Airespace Radio Resource Management Configuration Parameters. These objects are defined under bsnRrm object.')
bsnAAAGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 5)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientServerPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRFC3576"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSec"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecIKEPhase1"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecIKELifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerNetworkUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerMgmtUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRetransmitTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapKEKkey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapMACKkey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientServerPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerKey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSec"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecIKEPhase1"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecIKELifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerNetworkUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerRetransmitTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientRoundTripTime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRetransmissions"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessAccepts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRejects"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessChallenges"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientMalformedAccessResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientBadAuthenticators"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientPendingRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientTimeouts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientUnknownTypes"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientPacketsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRoundTripTime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRetransmissions"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientMalformedResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientBadAuthenticators"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientPendingRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientTimeouts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientUnknownTypes"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientPacketsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnAclApplyMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleAction"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDirection"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleSourceIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleSourceIpNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDestinationIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDestinationIpNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleStartSourcePort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleEndSourcePort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleStartDestinationPort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleEndDestinationPort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDscp"), ("AIRESPACE-WIRELESS-MIB", "bsnAclNewRuleIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterWlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserWlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserStartTime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserRemainingTime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserAccessMode"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthKeyWrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthCacheCredentialsLocally"), ("AIRESPACE-WIRELESS-MIB", "bsnAAAMacDelimiter"), ("AIRESPACE-WIRELESS-MIB", "bsnAAARadiusCompatibilityMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAAARadiusCallStationIdType"), ("AIRESPACE-WIRELESS-MIB", "bsnAAALocalDatabaseSize"), ("AIRESPACE-WIRELESS-MIB", "bsnAAACurrentLocalDatabaseSize"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnAcceptSelfSignedCertificate"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemClockTime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthCertificateType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthHashKey"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnAAAGroup = bsnAAAGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnAAAGroup.setDescription('This collection of objects provide the information about Airespace Authentication, Authorization, and Accounting Attributes. These objects are defined under bsnAAA object.')
bsnTrapsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 6)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11StationTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPProfileTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNameTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSlotIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPChannelNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageThresholdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageFailedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageTotalClients"), ("AIRESPACE-WIRELESS-MIB", "bsnClientMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnClientRssi"), ("AIRESPACE-WIRELESS-MIB", "bsnClientSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPortNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPParamUpdateTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnConfigSaveTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnRADIUSServerTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthenticationFailureTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsn80211SecurityTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnWpsTrapControlEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserType"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecErrorCount"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecSPI"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteUdpPort"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeAuthMethod"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitNoResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalRespFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteRespondFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnInitiatorCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnResponderCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnIsakmpInvalidCookies"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecTrapsMask"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnCurrentRadiosCount"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseRadioCount"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnStationBlacklistingReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAdhocMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpReportedByAP"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapClear"), ("AIRESPACE-WIRELESS-MIB", "bsnNavDosAttackSourceMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnWlanIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkType"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkState"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureType"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackPreced"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackerMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnApRegulatoryDomain"), ("AIRESPACE-WIRELESS-MIB", "bsnImpersonatedAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryMemberIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryMemberMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryDicoveryType"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentAnchoredClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalAnchoredClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalHandoffErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalCommunicationErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanMappingSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanMappingInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanMappingRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnApFunctionalityDisableReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyFeatureSetTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthorizationFailureCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfUpDownCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInvalidRadioType"), ("AIRESPACE-WIRELESS-MIB", "locationNotifyContent"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureMacInfo"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnTrapsGroup = bsnTrapsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnTrapsGroup.setDescription('This collection of objects provide the information about Airespace Trap Configuration and Trap definition. These objects are defined under bsnTrap.')
bsnUtilityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 7)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnSyslogEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnSyslogRemoteAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestId"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestSendCount"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestReceivedCount"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnUtilityGroup = bsnUtilityGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnUtilityGroup.setDescription('This collection of objects provide the information about Airespace General Utilities such as ping, syslog. These objects are defined under bsnUtility.')
bsnMobilityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 8)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnMobilityProtocolPortNum"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityDynamicDiscovery"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityStatsReset"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroupMemberMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroupMemberIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroupMemberGroupName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityGroupMemberRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityAnchorWlanSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityAnchorSwitchIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobilityAnchorRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffs"), ("AIRESPACE-WIRELESS-MIB", "bsnCurrentExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnCurrentImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalCommunicationErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalReceiveErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalTransmitErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalResponsesRetransmitted"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffEndRequestsReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalStateTransitionsDisallowed"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalResourceErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequestsSent"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRepliesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffAsLocalReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffAsForeignReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffDeniesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorRequestsSent"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorDenyReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorGrantReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorTransferReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequestsIgnored"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalPingPongHandoffRequestsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequestsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequestsDenied"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalClientHandoffAsLocal"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalClientHandoffAsForeign"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorRequestsReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorRequestsDenied"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorRequestsGranted"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalAnchorTransferred"), ("AIRESPACE-WIRELESS-MIB", "bsnTotalHandoffRequestsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnMobilityGroup = bsnMobilityGroup.setStatus('current')
if mibBuilder.loadTexts: bsnMobilityGroup.setDescription('This collection of objects provide the information about Airespace Mobility Group Parameters and ststistics. These are objects defined under bsnMobility.')
bsnIpsecGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 9)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCACertificate"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCACertificateUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertName"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertificateUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertificate"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnWrasIpsecCertStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnIpsecGroup = bsnIpsecGroup.setStatus('current')
if mibBuilder.loadTexts: bsnIpsecGroup.setDescription('This collection of objects provide the information about Airespace Global IpSec Group. These objects are defined under bsnIpsec.')
bsnWrasDepGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 10)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWPASecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWPAEncryptionType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWPAAuthKeyMgmtMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWPAAuthPresharedKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWPAAuthPresharedKeyHex"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNWPACompatibilityMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNAllowTKIPClients"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNAuthKeyMgmtMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNAuthPresharedKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRSNAuthPresharedKeyHex"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11NumberSupportedPowerLevels"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel1"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel2"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel3"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel4"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel5"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel6"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel7"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TxPowerLevel8"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CurrentCCAMode"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestId"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestSendPktCount"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestSendPktLength"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestReceivedPktCount"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestClientRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestLocalSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestLocalRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLinkTestRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasDepGroup = bsnWrasDepGroup.setStatus('deprecated')
if mibBuilder.loadTexts: bsnWrasDepGroup.setDescription('This collection of objects are derprecated in bsnWireless module.')
bsnWrasObsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 11)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnUserPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnUserEssIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnUserAccessMode"), ("AIRESPACE-WIRELESS-MIB", "bsnUserType"), ("AIRESPACE-WIRELESS-MIB", "bsnUserInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnUserRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerKey"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerConnectionStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPInterface"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAP802Dot1XRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPMirrorMode"), ("AIRESPACE-WIRELESS-MIB", "bsnThirdPartyAPRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnWatchListClientKey"), ("AIRESPACE-WIRELESS-MIB", "bsnWatchListClientType"), ("AIRESPACE-WIRELESS-MIB", "bsnWatchListClientRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasObsGroup = bsnWrasObsGroup.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWrasObsGroup.setDescription('This collection of objects are obsoleted in bsnWireless module.')
bsnWrasTrap = NotificationGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 12)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11StationDisassociate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationDeauthenticate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAuthenticateFail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAssociateFail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationBlacklisted"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAssociate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPUp"), ("AIRESPACE-WIRELESS-MIB", "bsnAPDown"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAssociated"), ("AIRESPACE-WIRELESS-MIB", "bsnAPDisassociated"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfUp"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDown"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLoadProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNoiseProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInterferenceProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLoadProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNoiseProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInterferenceProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCurrentTxPowerChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCurrentChannelChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aGroupingDone"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bGroupingDone"), ("AIRESPACE-WIRELESS-MIB", "bsnConfigSaved"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssCreated"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDeleted"), ("AIRESPACE-WIRELESS-MIB", "bsnRADIUSServerNotResponding"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthenticationFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspAuthFailureTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspReplayFailureTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspInvalidSpiTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecIkeNegFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecSuiteNegFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecInvalidCookieTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRemoved"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetectedOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnApHasNoRadioCards"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpAddressReported"), ("AIRESPACE-WIRELESS-MIB", "bsnAPContainedAsARogue"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkStateChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardTxFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardTxFailureClear"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardRxFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardRxFailureClear"), ("AIRESPACE-WIRELESS-MIB", "bsnAPImpersonationDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRegulatoryDomainMismatch"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiosExceedLicenseCount"), ("AIRESPACE-WIRELESS-MIB", "bsnSensedTemperatureTooHigh"), ("AIRESPACE-WIRELESS-MIB", "bsnSensedTemperatureTooLow"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureSensorFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureSensorClear"), ("AIRESPACE-WIRELESS-MIB", "bsnPOEControllerFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCountExceeded"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCountClear"), ("AIRESPACE-WIRELESS-MIB", "bsnApMaxRogueCountExceeded"), ("AIRESPACE-WIRELESS-MIB", "bsnApMaxRogueCountClear"), ("AIRESPACE-WIRELESS-MIB", "bsnApBigNavDosAttack"), ("AIRESPACE-WIRELESS-MIB", "bsnTooManyUnsuccessLoginAttempts"), ("AIRESPACE-WIRELESS-MIB", "bsnWepKeyDecryptError"), ("AIRESPACE-WIRELESS-MIB", "bsnWpaMicErrorCounterActivated"), ("AIRESPACE-WIRELESS-MIB", "bsnAdhocRogueAutoContained"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueApAutoContained"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidRadioPolicy"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApIsMissing"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIPAddressFallback"), ("AIRESPACE-WIRELESS-MIB", "bsnAPFunctionalityDisabled"), ("AIRESPACE-WIRELESS-MIB", "bsnRxMulticastQueueFull"), ("AIRESPACE-WIRELESS-MIB", "bsnRadarChannelDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnRadarChannelCleared"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthorizationFailure"), ("AIRESPACE-WIRELESS-MIB", "radioCoreDumpTrap"), ("AIRESPACE-WIRELESS-MIB", "invalidRadioTrap"), ("AIRESPACE-WIRELESS-MIB", "countryChangeTrap"), ("AIRESPACE-WIRELESS-MIB", "unsupportedAPTrap"), ("AIRESPACE-WIRELESS-MIB", "heartbeatLossTrap"), ("AIRESPACE-WIRELESS-MIB", "locationNotifyTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasTrap = bsnWrasTrap.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWrasTrap.setDescription('This collection of objects provides all notification that Switch need to generate to the Management System.')
bsnEssGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 13)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSessionTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssMacFiltering"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAdminStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssSecurityAuthType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPEncryptionType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPDefaultKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPKeyIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssStaticWEPKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess8021xSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess8021xEncryptionType"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIpsecSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnEncrTransform"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnAuthTransform"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeAuthMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnSharedKey"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnSharedKeySize"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkePhase1Mode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnIkeDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssIpsecPassthruSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnPassthruGateway"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadioPolicy"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssQualityOfService"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDhcpRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDhcpServerIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnContivityMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssVpnQotdServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBlacklistTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssNumberOfMobileStations"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebPassthru"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssCraniteSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBlacklistingCapability"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssAAAOverride"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWepAllowSharedKeyAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssFortressSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssL2tpSecurity"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssBroadcastSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssExternalPolicyValidation"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWmePolicySetting"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess80211ePolicySetting"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssWebPassthroughEmail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11Ess7920PhoneSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthPrimaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthSecondaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAuthTertiaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctPrimaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctSecondaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssRadiusAcctTertiaryServer"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEssIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMobilityStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAID"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAnchorAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPBCCOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationShortPreambleOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSessionTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationAuthenticationAlgorithm"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationWepState"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationDeleteAction"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyManagerState"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSecurityPolicyStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMirrorMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationInterface"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationApMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationVlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEncryptionCypher"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationEapType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationCcxVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationE2eVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationStatusCode"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPerRadioPerVapIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationBytesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationBytesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPolicyErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPacketsReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationPacketsSent"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTotalDetectingAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPFirstReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTotalClients"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPMaxDetectedRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPState"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetectingAPRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetectingAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPMaxRssiRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPClassType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetectingAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPChannelWidth"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentChannelCount"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPContainmentChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPWepMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPWpaMode"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPAirespaceAPSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByIpMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataApName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiData"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationRssiDataLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationByUserMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientRadioType"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientAirespaceAPSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientTotalDetectingAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientFirstReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientBSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientContainmentLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientState"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDot11MacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueClientDot11MacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileName"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileDesc"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosAverageDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosBurstDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosAvgRealTimeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosBurstRealTimeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosMaxRFUsagePerAP"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11QosProfileQueueDepth"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11WiredQosProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11802Dot1PTag"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11ResetProfileToDefault"), ("AIRESPACE-WIRELESS-MIB", "bsnTagDot11MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTagType"), ("AIRESPACE-WIRELESS-MIB", "bsnTagTimeInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnTagBatteryStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnTagLastReported"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataApName"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiData"), ("AIRESPACE-WIRELESS-MIB", "bsnTagRssiDataSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnTagBytesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnTagPacketsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnEssGroupRev1 = bsnEssGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnEssGroupRev1.setDescription('This collection of objects provides information about Airespace Wireless LAN Configuration Attributes These objects are defined under bsnEss object.')
bsnGlobalDot11GroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 14)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11PrivacyOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11AuthenticationResponseTimeOut"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11MultiDomainCapabilityImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11MultiDomainCapabilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11RogueTimer"), ("AIRESPACE-WIRELESS-MIB", "bsnPrimaryMwarForAPs"), ("AIRESPACE-WIRELESS-MIB", "bsnRtpProtocolPriority"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemCurrentTime"), ("AIRESPACE-WIRELESS-MIB", "bsnUpdateSystemTime"), ("AIRESPACE-WIRELESS-MIB", "bsnOperatingTemperatureEnvironment"), ("AIRESPACE-WIRELESS-MIB", "bsnSensorTemperature"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureAlarmLowLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureAlarmHighLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnVirtualGatewayAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRFMobilityDomainName"), ("AIRESPACE-WIRELESS-MIB", "bsnClientWatchListFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueLocationDiscoveryProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAutoContainFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnOverAirProvisionApMode"), ("AIRESPACE-WIRELESS-MIB", "bsnMaximumNumberOfConcurrentLogins"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainRoguesAdvertisingSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainAdhocNetworks"), ("AIRESPACE-WIRELESS-MIB", "bsnAutoContainTrustedClientsOnRogueAps"), ("AIRESPACE-WIRELESS-MIB", "bsnValidateRogueClientsAgainstAAA"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemTimezoneDelta"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemTimezoneDeltaMinutes"), ("AIRESPACE-WIRELESS-MIB", "bsnAllowAuthorizeApAgainstAAA"), ("AIRESPACE-WIRELESS-MIB", "bsnApFallbackEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnAppleTalkEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnPolicyForMisconfiguredAps"), ("AIRESPACE-WIRELESS-MIB", "bsnEncryptionPolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnPreamblePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11ModePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnRadioTypePolicyEnforced"), ("AIRESPACE-WIRELESS-MIB", "bsnValidateSsidForTrustedAp"), ("AIRESPACE-WIRELESS-MIB", "bsnAlertIfTrustedApMissing"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEntryExpirationTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive80211AssocFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive80211AuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessive8021xAuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnExcessiveWebAuthFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnIPTheftORReuse"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePrecedence"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureFrameType"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureAction"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureState"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureQuietTime"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureMacInfo"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureMacFreq"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternOffset"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternString"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternMask"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternOffSetStart"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignaturePatternRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePrecedence"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureFrameType"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureAction"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureState"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureQuietTime"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureMacInfo"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureMacFreq"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternOffset"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternString"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternMask"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternOffSetStart"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignaturePatternRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureCheckState"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagDataTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRfIdTagAutoTimeoutStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNeighborAuthStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNeighborAuthAlarmThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnRFNetworkName"), ("AIRESPACE-WIRELESS-MIB", "bsnFastSSIDChangeFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnBridgingZeroTouchConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnBridgingSharedSecretKey"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bNetworkStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bBeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCurrentChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicChannelUpdateInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bInputsForDCA"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicTransmitPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDynamicTxPowerControlInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCurrentTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bInputsForDTP"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPowerUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPowerUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate1Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate2Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate5AndHalfMhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate11Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDot11gSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate6Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate9Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate12Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate18Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate24Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate36Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate48Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDataRate54Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPicoCellMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingVoipMinRate"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFastRoamingVoipPercentage"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11b80211eMaxBandwidth"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDTPCSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bRxSopThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bDTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bEDThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bPBCCOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11bShortPreambleOptionImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aNetworkStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aLowBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMediumBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aHighBandNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aBeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCurrentChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicChannelUpdateInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aInputsForDCA"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicTransmitPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCurrentTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDynamicTxPowerControlInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aInputsForDTP"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPowerUpdateCmdInvoke"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPowerUpdateCmdStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate6Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate9Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate12Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate18Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate24Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate36Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate48Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDataRate54Mhz"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aPicoCellMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingMode"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingVoipMinRate"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFastRoamingVoipPercentage"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11a80211eMaxBandwidth"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDTPCSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aRxSopThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPollable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aCFPollRequest"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aDTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aTIThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11aChannelAgilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hPowerConstraint"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hChannelSwitchEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnGlobalDot11hChannelSwitchMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnGlobalDot11GroupRev1 = bsnGlobalDot11GroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnGlobalDot11GroupRev1.setDescription('This collection of objects provide the information about Airespace 802.11 standard attributes applied globally. These objects are defined under bsnGlobalDot11 object.')
bsnAAAGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 15)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientServerPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRFC3576"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSec"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecIKEPhase1"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecIKELifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerIPSecDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerNetworkUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerMgmtUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRetransmitTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapKEKkey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapMACKkey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerKeyWrapFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthServerRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientServerPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerKey"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerKeyFormat"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSec"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecAuth"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecIKEPhase1"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecIKELifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerIPSecDHGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerNetworkUserConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerRetransmitTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccServerRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientRoundTripTime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRetransmissions"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessAccepts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessRejects"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientAccessChallenges"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientMalformedAccessResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientBadAuthenticators"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientPendingRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientTimeouts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientUnknownTypes"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthClientPacketsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRoundTripTime"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientRetransmissions"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientMalformedResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientBadAuthenticators"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientPendingRequests"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientTimeouts"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientUnknownTypes"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAccClientPacketsDropped"), ("AIRESPACE-WIRELESS-MIB", "bsnAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnAclApplyMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleAction"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDirection"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleSourceIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleSourceIpNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDestinationIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDestinationIpNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleProtocol"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleStartSourcePort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleEndSourcePort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleStartDestinationPort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleEndDestinationPort"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleDscp"), ("AIRESPACE-WIRELESS-MIB", "bsnAclNewRuleIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAclRuleRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterWlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterInterfaceName"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnMacFilterRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserWlanId"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserStartTime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserRemainingTime"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalNetUserRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserPassword"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserAccessMode"), ("AIRESPACE-WIRELESS-MIB", "bsnLocalManagementUserRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnBlackListClientRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiusAuthKeyWrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnAAAMacDelimiter"), ("AIRESPACE-WIRELESS-MIB", "bsnAAARadiusCompatibilityMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAAARadiusCallStationIdType"), ("AIRESPACE-WIRELESS-MIB", "bsnAAALocalDatabaseSize"), ("AIRESPACE-WIRELESS-MIB", "bsnAAACurrentLocalDatabaseSize"), ("AIRESPACE-WIRELESS-MIB", "bsnExternalPolicyServerAclName"), ("AIRESPACE-WIRELESS-MIB", "bsnAcceptSelfSignedCertificate"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemClockTime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthCertificateType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthHashKey"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnAAAGroupRev1 = bsnAAAGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnAAAGroupRev1.setDescription('This collection of objects provide the information about Airespace Authentication, Authorization, and Accounting Attributes. These objects are defined under bsnAAA object.')
bsnTrapsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 16)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11StationTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPProfileTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMacAddrTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNameTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSlotIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPChannelNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageThresholdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageFailedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageTotalClients"), ("AIRESPACE-WIRELESS-MIB", "bsnClientMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnClientRssi"), ("AIRESPACE-WIRELESS-MIB", "bsnClientSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceEnergyAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPortNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPParamUpdateTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnConfigSaveTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnRADIUSServerTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthenticationFailureTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsn80211SecurityTrapControlMask"), ("AIRESPACE-WIRELESS-MIB", "bsnWpsTrapControlEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthFailureUserType"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteIPv4Address"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecErrorCount"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecSPI"), ("AIRESPACE-WIRELESS-MIB", "bsnRemoteUdpPort"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeAuthMethod"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalInitNoResponses"), ("AIRESPACE-WIRELESS-MIB", "bsnIkeTotalRespFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesSent"), ("AIRESPACE-WIRELESS-MIB", "bsnNotifiesReceived"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteInitFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnSuiteRespondFailures"), ("AIRESPACE-WIRELESS-MIB", "bsnInitiatorCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnResponderCookie"), ("AIRESPACE-WIRELESS-MIB", "bsnIsakmpInvalidCookies"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecTrapsMask"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPTrapEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnCurrentRadiosCount"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseRadioCount"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCount"), ("AIRESPACE-WIRELESS-MIB", "bsnStationMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnStationAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnUserIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnStationReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnStationBlacklistingReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnStationUserName"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAdhocMode"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpReportedByAP"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpTrapClear"), ("AIRESPACE-WIRELESS-MIB", "bsnNavDosAttackSourceMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnWlanIdTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnClearTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApEncryptionRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkType"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkState"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureType"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureName"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackPreced"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackFrequency"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackerMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnApRegulatoryDomain"), ("AIRESPACE-WIRELESS-MIB", "bsnImpersonatedAPMacAddr"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleUsed"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApPreambleRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApRadioPolicyRequired"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryMemberIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryMemberMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnGroupDirectoryDicoveryType"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentAnchoredClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalAnchoredClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalExportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberCurrentImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalImportedClients"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalHandoffErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnMemberTotalCommunicationErrors"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanDescription"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupsVlanRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnApFunctionalityDisableReasonCode"), ("AIRESPACE-WIRELESS-MIB", "bsnLicenseKeyFeatureSetTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthorizationFailureCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfUpDownCause"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInvalidRadioType"), ("AIRESPACE-WIRELESS-MIB", "locationNotifyContent"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureMacInfo"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPreviousChannelNumberTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnAPReasonCodeTrapVariable"), ("AIRESPACE-WIRELESS-MIB", "bsnNoiseBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnNoiseAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceBeforeChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnInterferenceAfterChannelUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnImpersonatingSourceMacAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnTrapsGroupRev1 = bsnTrapsGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnTrapsGroupRev1.setDescription('This collection of objects provide the information about Airespace Trap Configuration and Trap definition. These objects are defined under bsnTrap.')
bsnWrasTrapRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 17)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnDot11StationDisassociate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationDeauthenticate"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAuthenticateFail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAssociateFail"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationBlacklisted"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11StationAssociate"), ("AIRESPACE-WIRELESS-MIB", "bsnAPDisassociated"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLoadProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNoiseProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInterferenceProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageProfileFailed"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLoadProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNoiseProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPInterferenceProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCoverageProfileUpdatedToPass"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCurrentTxPowerChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCurrentChannelChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11aGroupingDone"), ("AIRESPACE-WIRELESS-MIB", "bsnRrmDot11bGroupingDone"), ("AIRESPACE-WIRELESS-MIB", "bsnConfigSaved"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssCreated"), ("AIRESPACE-WIRELESS-MIB", "bsnDot11EssDeleted"), ("AIRESPACE-WIRELESS-MIB", "bsnRADIUSServerNotResponding"), ("AIRESPACE-WIRELESS-MIB", "bsnAuthenticationFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspAuthFailureTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspReplayFailureTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecEspInvalidSpiTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecIkeNegFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecSuiteNegFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnIpsecInvalidCookieTrap"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPRemoved"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueAPDetectedOnWiredNetwork"), ("AIRESPACE-WIRELESS-MIB", "bsnApHasNoRadioCards"), ("AIRESPACE-WIRELESS-MIB", "bsnDuplicateIpAddressReported"), ("AIRESPACE-WIRELESS-MIB", "bsnAPContainedAsARogue"), ("AIRESPACE-WIRELESS-MIB", "bsnNetworkStateChanged"), ("AIRESPACE-WIRELESS-MIB", "bsnSignatureAttackDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardTxFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardTxFailureClear"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardRxFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRadioCardRxFailureClear"), ("AIRESPACE-WIRELESS-MIB", "bsnAPImpersonationDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidPreamble"), ("AIRESPACE-WIRELESS-MIB", "bsnRadiosExceedLicenseCount"), ("AIRESPACE-WIRELESS-MIB", "bsnSensedTemperatureTooHigh"), ("AIRESPACE-WIRELESS-MIB", "bsnSensedTemperatureTooLow"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureSensorFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnTemperatureSensorClear"), ("AIRESPACE-WIRELESS-MIB", "bsnPOEControllerFailure"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCountExceeded"), ("AIRESPACE-WIRELESS-MIB", "bsnMaxRogueCountClear"), ("AIRESPACE-WIRELESS-MIB", "bsnApMaxRogueCountExceeded"), ("AIRESPACE-WIRELESS-MIB", "bsnApMaxRogueCountClear"), ("AIRESPACE-WIRELESS-MIB", "bsnApBigNavDosAttack"), ("AIRESPACE-WIRELESS-MIB", "bsnTooManyUnsuccessLoginAttempts"), ("AIRESPACE-WIRELESS-MIB", "bsnWepKeyDecryptError"), ("AIRESPACE-WIRELESS-MIB", "bsnWpaMicErrorCounterActivated"), ("AIRESPACE-WIRELESS-MIB", "bsnAdhocRogueAutoContained"), ("AIRESPACE-WIRELESS-MIB", "bsnRogueApAutoContained"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidEncryption"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidRadioPolicy"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApHasInvalidSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnTrustedApIsMissing"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIPAddressFallback"), ("AIRESPACE-WIRELESS-MIB", "bsnAPFunctionalityDisabled"), ("AIRESPACE-WIRELESS-MIB", "bsnRxMulticastQueueFull"), ("AIRESPACE-WIRELESS-MIB", "bsnRadarChannelDetected"), ("AIRESPACE-WIRELESS-MIB", "bsnRadarChannelCleared"), ("AIRESPACE-WIRELESS-MIB", "bsnAPAuthorizationFailure"), ("AIRESPACE-WIRELESS-MIB", "radioCoreDumpTrap"), ("AIRESPACE-WIRELESS-MIB", "invalidRadioTrap"), ("AIRESPACE-WIRELESS-MIB", "unsupportedAPTrap"), ("AIRESPACE-WIRELESS-MIB", "heartbeatLossTrap"), ("AIRESPACE-WIRELESS-MIB", "locationNotifyTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasTrapRev1 = bsnWrasTrapRev1.setStatus('current')
if mibBuilder.loadTexts: bsnWrasTrapRev1.setDescription('This collection of objects provides all notification that Switch need to generate to the Management System.')
bsnApGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 18)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPDot3MacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNumOfSlots"), ("AIRESPACE-WIRELESS-MIB", "bsnAPName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPLocation"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMonitorOnlyMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPOperationStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSoftwareVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPBootVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPPrimaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPReset"), ("AIRESPACE-WIRELESS-MIB", "bsnAPStatsTimer"), ("AIRESPACE-WIRELESS-MIB", "bsnAPModel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSerialNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPClearConfig"), ("AIRESPACE-WIRELESS-MIB", "bsnApIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPMirrorMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPRemoteModeSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPSecondaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPTertiaryMwarName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIsStaticIP"), ("AIRESPACE-WIRELESS-MIB", "bsnAPNetmask"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGateway"), ("AIRESPACE-WIRELESS-MIB", "bsnAPStaticIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPBridgingSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPGroupVlanName"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIOSVersion"), ("AIRESPACE-WIRELESS-MIB", "bsnAPCertificateType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPEthernetMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSlotId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyTxPowerControl"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaMode"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaDiversity"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCellSiteConfigId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNumberOfVaps"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfOperStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPortNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPhyAntennaOptions"), ("AIRESPACE-WIRELESS-MIB", "bsnApIfNoOfUsers"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverride"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPacketsSniffingFeature"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSniffChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSniffServerIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAntennaGain"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfChannelList"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfAbsolutePowerList"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRegulatoryDomainSupport"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11BeaconPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MediumOccupancyLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CFPPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CFPMaxDuration"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11OperationalRateSet"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11DTIMPeriod"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultiDomainCapabilityImplemented"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultiDomainCapabilityEnabled"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11CountryString"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11SmtParamsConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11BSSID"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MaximumTransmitPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FirstChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11NumberofChannels"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacShortRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacLongRetryLimit"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacMaxTransmitMSDULifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacParamsConfigType"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MacMaxReceiveLifetime"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TransmittedFragmentCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MulticastTransmittedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RetryCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MultipleRetryCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FrameDuplicateCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RTSSuccessCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11RTSFailureCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11ACKFailureCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11ReceivedFragmentCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11MulticastReceivedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FCSErrorCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TransmittedFrameCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11WEPUndecryptableCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11FailedCount"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11EDThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDot11TIThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfProfileParamAssignment"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfForeignInterferenceThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfForeignNoiseThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRFUtilizationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfThroughputThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfMobilesThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfMobileMinExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageExceptionLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadRxUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadTxUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadChannelUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadNumOfClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfPoorSNRClients"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceChannelNo"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferencePower"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceUtilization"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNoiseChannelNo"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfDBNoisePower"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfLoadProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfInterferenceProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfNoiseProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfCoverageProfileState"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborIpAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborSlot"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationRSSICoverageIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRSSILevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationCountOnRSSI"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationSNRCoverageIndex"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfSNRLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfStationCountOnSNR"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedTxPowerLevel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedRTSThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRecommendedFragmentationThreshold"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideId"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideSsid"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfWlanOverrideRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRole"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeGroup"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaul"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaulPAP"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBackhaulRAP"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeDataRate"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRoutingState"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeMalformedNeighPackets"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodePoorNeighSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeBlacklistPackets"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeInsufficientMemory"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRxNeighReq"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeRxNeighRsp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeTxNeighReq"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeTxNeighRsp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeParentChanges"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeNeighTimeout"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeParentMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeAPType"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeEthernetBridge"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNodeHops"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighMacAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighType"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighState"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnrUp"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighSnrDown"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighLinkSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighAdjustedEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighUnadjustedEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighRapEase"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighTxParent"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighRxParent"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighPoorSnr"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighLastUpdate"), ("AIRESPACE-WIRELESS-MIB", "bsnMeshNeighParentChange"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRadarDetectedChannelNumber"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRadarSignalLastHeard"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborChannel"), ("AIRESPACE-WIRELESS-MIB", "bsnAPIfRxNeighborChannelWidth"), ("AIRESPACE-WIRELESS-MIB", "bsnStandardSignatureInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnCustomSignatureInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnApGroupRev1 = bsnApGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnApGroupRev1.setDescription('This collection of objects provide the information about Airespace APs that are associated with the Switch. These objects are defined under bsnAP object.')
bsnUtilityGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 19)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnSyslogEnable"), ("AIRESPACE-WIRELESS-MIB", "bsnSyslogRemoteAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestId"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestIPAddress"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestSendCount"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestReceivedCount"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestRowStatus"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestMaxTimeInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestMinTimeInterval"), ("AIRESPACE-WIRELESS-MIB", "bsnPingTestAvgTimeInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnUtilityGroupRev1 = bsnUtilityGroupRev1.setStatus('current')
if mibBuilder.loadTexts: bsnUtilityGroupRev1.setDescription('This collection of objects provide the information about Airespace General Utilities such as ping, syslog. These objects are defined under bsnUtility.')
bsnWrasObsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 20)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnMobileStationSampleTime"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationTxExcessiveRetries"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationTxRetries"), ("AIRESPACE-WIRELESS-MIB", "bsnMobileStationTxFiltered"), ("AIRESPACE-WIRELESS-MIB", "bsnSystemTimezoneDaylightSavings"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasObsGroupRev1 = bsnWrasObsGroupRev1.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWrasObsGroupRev1.setDescription('This collection of objects are obsoleted in bsnWireless module.')
bsnWrasObsTrap = NotificationGroup((1, 3, 6, 1, 4, 1, 14179, 2, 50, 21)).setObjects(("AIRESPACE-WIRELESS-MIB", "bsnAPUp"), ("AIRESPACE-WIRELESS-MIB", "bsnAPDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bsnWrasObsTrap = bsnWrasObsTrap.setStatus('obsolete')
if mibBuilder.loadTexts: bsnWrasObsTrap.setDescription('This collection of objects provides all notification that Switch need to generate to the Management System.')
mibBuilder.exportSymbols("AIRESPACE-WIRELESS-MIB", bsnAPIfCoverageThreshold=bsnAPIfCoverageThreshold, bsnTagStatsTable=bsnTagStatsTable, bsnSensedTemperatureTooLow=bsnSensedTemperatureTooLow, bsnMeshNodeParentMacAddress=bsnMeshNodeParentMacAddress, bsnSyslogRemoteAddress=bsnSyslogRemoteAddress, bsnDot11EssStaticWEPDefaultKey=bsnDot11EssStaticWEPDefaultKey, bsnPrimaryMwarForAPs=bsnPrimaryMwarForAPs, bsnDot11EssRadiusAuthPrimaryServer=bsnDot11EssRadiusAuthPrimaryServer, bsnGlobalDot11bCurrentChannel=bsnGlobalDot11bCurrentChannel, bsnMobileStationAPMacAddr=bsnMobileStationAPMacAddr, bsnDot11QosProfileDesc=bsnDot11QosProfileDesc, bsnAclApplyMode=bsnAclApplyMode, bsnTrapsGroup=bsnTrapsGroup, bsnGlobalDot11bDataRate24Mhz=bsnGlobalDot11bDataRate24Mhz, bsnAPIfDot11PhyChannelTable=bsnAPIfDot11PhyChannelTable, bsnDot11EssTable=bsnDot11EssTable, bsnAPIfRecommendedTxPowerLevel=bsnAPIfRecommendedTxPowerLevel, bsnGlobalDot11hChannelSwitchEnable=bsnGlobalDot11hChannelSwitchEnable, bsnGlobalDot11aDynamicTxPowerControlInterval=bsnGlobalDot11aDynamicTxPowerControlInterval, bsnDot11EssStaticWEPSecurity=bsnDot11EssStaticWEPSecurity, bsnAPIfPortNumber=bsnAPIfPortNumber, bsnRrmDot11bSignalMeasurementInterval=bsnRrmDot11bSignalMeasurementInterval, BsnTxtSignatureMacInfo=BsnTxtSignatureMacInfo, bsnStationMacAddress=bsnStationMacAddress, bsnMobileStationPortNumber=bsnMobileStationPortNumber, bsnRadiusAccServerTable=bsnRadiusAccServerTable, bsnRadiusAccClientRequests=bsnRadiusAccClientRequests, bsnAPIfForeignNoiseThreshold=bsnAPIfForeignNoiseThreshold, bsnTrustedApPreambleUsed=bsnTrustedApPreambleUsed, bsnSystemCurrentTime=bsnSystemCurrentTime, bsnApMaxRogueCountExceeded=bsnApMaxRogueCountExceeded, bsnThirdPartyAPTable=bsnThirdPartyAPTable, bsnAuthenticationFailureTrapEnable=bsnAuthenticationFailureTrapEnable, bsnDot11EssVpnContivityMode=bsnDot11EssVpnContivityMode, bsnGlobalDot11bPicoCellMode=bsnGlobalDot11bPicoCellMode, bsnGlobalDot11aCFPMaxDuration=bsnGlobalDot11aCFPMaxDuration, bsnMacFilterWlanId=bsnMacFilterWlanId, bsnDot11EssExternalPolicyValidation=bsnDot11EssExternalPolicyValidation, bsnRogueAPFirstReported=bsnRogueAPFirstReported, bsnRadiusAccClientPacketsDropped=bsnRadiusAccClientPacketsDropped, bsnRrmDot11aGroupingDone=bsnRrmDot11aGroupingDone, bsnLocalManagementUserAccessMode=bsnLocalManagementUserAccessMode, bsnMobileStationRssiDataEntry=bsnMobileStationRssiDataEntry, bsnRogueApAutoContained=bsnRogueApAutoContained, bsnGlobalDot11=bsnGlobalDot11, bsnIpsecEspAuthFailureTrap=bsnIpsecEspAuthFailureTrap, bsnAPIfDot11OperationalRateSet=bsnAPIfDot11OperationalRateSet, bsnTotalImportedClients=bsnTotalImportedClients, bsnMobilityGroup=bsnMobilityGroup, bsnRrmDot11aCoverageThreshold=bsnRrmDot11aCoverageThreshold, bsnAPIfChannelInterferenceInfoEntry=bsnAPIfChannelInterferenceInfoEntry, bsnTotalHandoffRequestsSent=bsnTotalHandoffRequestsSent, bsnAPIfDot11MacRTSThreshold=bsnAPIfDot11MacRTSThreshold, bsnGlobalDot11aDataRate54Mhz=bsnGlobalDot11aDataRate54Mhz, bsnMobilityGroupDirectoryTable=bsnMobilityGroupDirectoryTable, bsnTrustedApEncryptionUsed=bsnTrustedApEncryptionUsed, bsnNavDosAttackSourceMacAddr=bsnNavDosAttackSourceMacAddr, bsnAPIfDot11MultipleRetryCount=bsnAPIfDot11MultipleRetryCount, bsnLicenseRadioCount=bsnLicenseRadioCount, bsnWrasDot11aPeerIpAddress=bsnWrasDot11aPeerIpAddress, bsnAutoContainTrustedClientsOnRogueAps=bsnAutoContainTrustedClientsOnRogueAps, bsnMobileStationShortPreambleOptionImplemented=bsnMobileStationShortPreambleOptionImplemented, bsnAPIfType=bsnAPIfType, bsnAPCoverageProfileUpdatedToPass=bsnAPCoverageProfileUpdatedToPass, bsnLocalManagementUserName=bsnLocalManagementUserName, bsnAPNumOfSlots=bsnAPNumOfSlots, bsnAPIfRxNeighborSlot=bsnAPIfRxNeighborSlot, bsnRadiusAccServerAddress=bsnRadiusAccServerAddress, bsnUtility=bsnUtility, ProfileState=ProfileState, bsnAPIfDot11ReceivedFragmentCount=bsnAPIfDot11ReceivedFragmentCount, bsnRrmDot11aAPDefault=bsnRrmDot11aAPDefault, bsnBlackListClientEntry=bsnBlackListClientEntry, bsnApIfNoOfUsers=bsnApIfNoOfUsers, bsnTotalHandoffs=bsnTotalHandoffs, bsnAPIfStationRSSICoverageInfoTable=bsnAPIfStationRSSICoverageInfoTable, bsnWrasIpsecCACertificateUpdate=bsnWrasIpsecCACertificateUpdate, bsnCustomSignatureAction=bsnCustomSignatureAction, bsnAPIfChannelInterferenceInfoTable=bsnAPIfChannelInterferenceInfoTable, bsnRadiusAccServerStatus=bsnRadiusAccServerStatus, bsnDot11EssInterfaceName=bsnDot11EssInterfaceName, bsnGlobalDot11aLongRetryLimit=bsnGlobalDot11aLongRetryLimit, bsnRrmDot11b=bsnRrmDot11b, bsnAPIfWlanOverride=bsnAPIfWlanOverride, bsnRogueAPAirespaceAPWpaMode=bsnRogueAPAirespaceAPWpaMode, bsnGlobalDot11a80211eMaxBandwidth=bsnGlobalDot11a80211eMaxBandwidth, bsnMobileStationPerRadioPerVapIndex=bsnMobileStationPerRadioPerVapIndex, bsnValidateSsidForTrustedAp=bsnValidateSsidForTrustedAp, bsnAPRegulatoryDomainMismatch=bsnAPRegulatoryDomainMismatch, bsnAPIfPhyChannelAssignment=bsnAPIfPhyChannelAssignment, bsnTotalResponsesRetransmitted=bsnTotalResponsesRetransmitted, bsnAPRemoteModeSupport=bsnAPRemoteModeSupport, bsnWrasDot11aGroupTable=bsnWrasDot11aGroupTable, bsnAPIfLoadTxUtilization=bsnAPIfLoadTxUtilization, bsnDot11StationAssociate=bsnDot11StationAssociate, bsnTotalHandoffErrors=bsnTotalHandoffErrors, bsnAPIfWlanOverrideEntry=bsnAPIfWlanOverrideEntry, bsnGlobalDot11aBeaconPeriod=bsnGlobalDot11aBeaconPeriod, bsnWpsTrapControlEnable=bsnWpsTrapControlEnable, bsnNotifiesReceived=bsnNotifiesReceived, bsnRadiusAccClientRoundTripTime=bsnRadiusAccClientRoundTripTime, bsnTotalReceiveErrors=bsnTotalReceiveErrors, WEPKeytype=WEPKeytype, bsnRogueAPRadioType=bsnRogueAPRadioType, bsnAPIfRadarChannelStatisticsEntry=bsnAPIfRadarChannelStatisticsEntry, bsnClientExclusionPolicyConfig=bsnClientExclusionPolicyConfig, bsnResponderCookie=bsnResponderCookie, bsnAPIfRadarChannelStatisticsTable=bsnAPIfRadarChannelStatisticsTable, bsnTagRssiDataEntry=bsnTagRssiDataEntry, bsnRogueAPChannelNumber=bsnRogueAPChannelNumber, bsnRadiusAccClientRetransmissions=bsnRadiusAccClientRetransmissions, bsnAPIfDot11FCSErrorCount=bsnAPIfDot11FCSErrorCount, bsnDot11EssWebPassthroughEmail=bsnDot11EssWebPassthroughEmail, bsnGlobalDot11aInputsForDTP=bsnGlobalDot11aInputsForDTP, bsnGlobalDot11aShortRetryLimit=bsnGlobalDot11aShortRetryLimit, bsnAPIfWlanOverrideRowStatus=bsnAPIfWlanOverrideRowStatus, bsnGlobalDot11bShortRetryLimit=bsnGlobalDot11bShortRetryLimit, bsnTotalClientHandoffAsForeign=bsnTotalClientHandoffAsForeign, bsnWrasObsTrap=bsnWrasObsTrap, bsnAAACurrentLocalDatabaseSize=bsnAAACurrentLocalDatabaseSize, bsnMemberCurrentExportedClients=bsnMemberCurrentExportedClients, bsnAPIfStationSNRCoverageInfoEntry=bsnAPIfStationSNRCoverageInfoEntry, bsnApGroupRev1=bsnApGroupRev1, bsnPreamblePolicyEnforced=bsnPreamblePolicyEnforced, bsnGlobalDot11aPowerUpdateCmdStatus=bsnGlobalDot11aPowerUpdateCmdStatus, bsnAPIfRxNeighborChannelWidth=bsnAPIfRxNeighborChannelWidth, bsnMobileStationRssiData=bsnMobileStationRssiData, bsnAPIfChannelNoiseInfoTable=bsnAPIfChannelNoiseInfoTable, bsnRogueClientAirespaceAPMacAddress=bsnRogueClientAirespaceAPMacAddress, bsnAAA=bsnAAA, bsnGlobalDot11bNumberofChannels=bsnGlobalDot11bNumberofChannels, bsnTagRssiDataApMacAddress=bsnTagRssiDataApMacAddress, bsnAPIfWlanOverrideId=bsnAPIfWlanOverrideId, bsnRogueClientPerRogueAPEntry=bsnRogueClientPerRogueAPEntry, bsnGlobalDot11b=bsnGlobalDot11b, bsnGlobalDot11Group=bsnGlobalDot11Group, bsnIsakmpInvalidCookies=bsnIsakmpInvalidCookies, bsnMobileStationStatusCode=bsnMobileStationStatusCode, bsnThirdPartyAPMacAddress=bsnThirdPartyAPMacAddress, bsnRadiusAccServerIPSecAuth=bsnRadiusAccServerIPSecAuth, bsnRogueClientAirespaceAPLastHeard=bsnRogueClientAirespaceAPLastHeard, bsnAPIfRecommendedRFParametersEntry=bsnAPIfRecommendedRFParametersEntry, bsnAPIfLoadParametersTable=bsnAPIfLoadParametersTable, bsnRadiusAccClientUnknownTypes=bsnRadiusAccClientUnknownTypes, bsnDot11EssRadiusAcctTertiaryServer=bsnDot11EssRadiusAcctTertiaryServer, bsnRadiusAuthClientAccessChallenges=bsnRadiusAuthClientAccessChallenges, bsnGlobalDot11bDataRate6Mhz=bsnGlobalDot11bDataRate6Mhz, bsnWrasDot11aGroupEntry=bsnWrasDot11aGroupEntry, bsnStationUserName=bsnStationUserName, bsnRogueClientLastReported=bsnRogueClientLastReported, bsnCustomSignatureTable=bsnCustomSignatureTable, bsnGlobalDot11bDataRate48Mhz=bsnGlobalDot11bDataRate48Mhz, bsnRadiusAuthClientMalformedAccessResponses=bsnRadiusAuthClientMalformedAccessResponses, bsnMobilityStats=bsnMobilityStats, bsnMobilityGroupDirectoryEntry=bsnMobilityGroupDirectoryEntry, bsnRrm=bsnRrm, bsnClientMacAddr=bsnClientMacAddr, bsnMobileStationCcxVersion=bsnMobileStationCcxVersion, bsnMeshNeighTxParent=bsnMeshNeighTxParent, bsnAPIfDot11EDThreshold=bsnAPIfDot11EDThreshold, bsnMeshNodeBackhaulPAP=bsnMeshNodeBackhaulPAP, bsnRrmDot11aGroupLastUpdateTime=bsnRrmDot11aGroupLastUpdateTime, bsnRrmDot11aGlobalAutomaticGrouping=bsnRrmDot11aGlobalAutomaticGrouping, bsnUserIpAddress=bsnUserIpAddress, bsnMobileStationEncryptionCypher=bsnMobileStationEncryptionCypher, bsnTraps=bsnTraps, bsnAPGroupsVlanTable=bsnAPGroupsVlanTable, bsnAPTertiaryMwarName=bsnAPTertiaryMwarName, bsnAclRuleDestinationIpNetmask=bsnAclRuleDestinationIpNetmask, bsnAPIfRadarDetectedChannelNumber=bsnAPIfRadarDetectedChannelNumber, bsnAPIfDot11NumberSupportedPowerLevels=bsnAPIfDot11NumberSupportedPowerLevels, bsnAPIfDot11MacMaxTransmitMSDULifetime=bsnAPIfDot11MacMaxTransmitMSDULifetime, bsnLocalNetUserDescription=bsnLocalNetUserDescription, radioCoreDumpTrap=radioCoreDumpTrap, bsnGlobalDot11aFastRoamingVoipMinRate=bsnGlobalDot11aFastRoamingVoipMinRate, bsnDot11EssWebPassthru=bsnDot11EssWebPassthru, bsnTagTimeInterval=bsnTagTimeInterval, bsnTemperatureSensorClear=bsnTemperatureSensorClear, bsnAAALocalDatabaseSize=bsnAAALocalDatabaseSize, bsnCustomSignatureVersion=bsnCustomSignatureVersion, bsnWrasIpsecCertTable=bsnWrasIpsecCertTable, bsnAPImpersonationDetected=bsnAPImpersonationDetected, bsnGlobalDot11aDataRate36Mhz=bsnGlobalDot11aDataRate36Mhz, bsnMobilityAnchorWlanSsid=bsnMobilityAnchorWlanSsid, bsnLocalManagementUserTable=bsnLocalManagementUserTable, bsnRadiusAuthServerIPSecAuth=bsnRadiusAuthServerIPSecAuth, bsnLocalNetUserLifetime=bsnLocalNetUserLifetime, bsnGlobalDot11hChannelSwitchMode=bsnGlobalDot11hChannelSwitchMode, bsnAPIfUp=bsnAPIfUp, bsnNoiseAfterChannelUpdate=bsnNoiseAfterChannelUpdate, bsnRrmDot11aGroupLeaderMacAddr=bsnRrmDot11aGroupLeaderMacAddr, bsnMeshNodeInsufficientMemory=bsnMeshNodeInsufficientMemory, bsnRogueAPSSID=bsnRogueAPSSID, bsnRadiusAuthClientServerPortNumber=bsnRadiusAuthClientServerPortNumber, bsnExternalPolicyServerEntry=bsnExternalPolicyServerEntry, bsnTagRssiData=bsnTagRssiData, bsnRemoteIPv4Address=bsnRemoteIPv4Address, bsnGlobalDot11bChannelUpdateCmdInvoke=bsnGlobalDot11bChannelUpdateCmdInvoke, bsnLocalNetUserRemainingTime=bsnLocalNetUserRemainingTime, bsnRadiusAuthServerIPSecIKELifetime=bsnRadiusAuthServerIPSecIKELifetime, bsnTotalExportedClients=bsnTotalExportedClients, bsnGlobalDot11hPowerConstraint=bsnGlobalDot11hPowerConstraint, bsnDot11EssSsid=bsnDot11EssSsid, bsnGlobalDot11aNumberofChannels=bsnGlobalDot11aNumberofChannels, bsnExternalPolicyServerKey=bsnExternalPolicyServerKey, bsnTotalAnchorTransferred=bsnTotalAnchorTransferred, bsnOperatingTemperatureEnvironment=bsnOperatingTemperatureEnvironment, bsnRogueAPAirespaceAPRSSI=bsnRogueAPAirespaceAPRSSI, bsnTagDot11MacAddress=bsnTagDot11MacAddress, bsnAPIfPoorSNRClients=bsnAPIfPoorSNRClients, bsnGlobalDot11aMaxReceiveLifetime=bsnGlobalDot11aMaxReceiveLifetime, bsnClientWatchListFeature=bsnClientWatchListFeature, bsnRadiusAuthServerIPSecDHGroup=bsnRadiusAuthServerIPSecDHGroup, bsnRadiusAuthServerRFC3576=bsnRadiusAuthServerRFC3576, bsnAPIfCoverageProfileState=bsnAPIfCoverageProfileState, bsnRrmDot11aCoverageMeasurementInterval=bsnRrmDot11aCoverageMeasurementInterval, bsnAPIfSniffServerIPAddress=bsnAPIfSniffServerIPAddress, bsnRrmDot11aGroup=bsnRrmDot11aGroup, bsnWatchListClientEntry=bsnWatchListClientEntry, bsnMobileStationPolicyErrors=bsnMobileStationPolicyErrors, bsnRadiusAccServerKey=bsnRadiusAccServerKey, bsnDot11Ess7920PhoneSupport=bsnDot11Ess7920PhoneSupport, bsnAPSecondaryMwarName=bsnAPSecondaryMwarName, BsnSignaturePatternOffSetStart=BsnSignaturePatternOffSetStart, bsnRadiusAccServerInetAddress=bsnRadiusAccServerInetAddress, bsnAPIfInterferenceChannelNo=bsnAPIfInterferenceChannelNo, bsnCurrentRadiosCount=bsnCurrentRadiosCount, bsnLocalNetUserTable=bsnLocalNetUserTable, bsnTemperatureSensorFailure=bsnTemperatureSensorFailure, bsnMobileStationCFPollRequest=bsnMobileStationCFPollRequest, bsnAPIfDot11CFPPeriod=bsnAPIfDot11CFPPeriod, bsnThirdPartyAPInterface=bsnThirdPartyAPInterface, bsnTotalPingPongHandoffRequestsDropped=bsnTotalPingPongHandoffRequestsDropped, bsnStandardSignatureQuietTime=bsnStandardSignatureQuietTime, bsnWatchListClientTable=bsnWatchListClientTable, bsnGlobalDot11aConfig=bsnGlobalDot11aConfig, bsnRogueAPMaxDetectedRSSI=bsnRogueAPMaxDetectedRSSI, bsnMobileStationInterface=bsnMobileStationInterface, bsnGlobalDot11aLowBandNetwork=bsnGlobalDot11aLowBandNetwork, bsnWrasTrapRev1=bsnWrasTrapRev1, bsnDot11WiredQosProtocol=bsnDot11WiredQosProtocol, bsnStandardSignaturePrecedence=bsnStandardSignaturePrecedence, bsnRadiusAccClientResponses=bsnRadiusAccClientResponses, bsnGlobalDot11bDynamicChannelAssignment=bsnGlobalDot11bDynamicChannelAssignment, bsnMobilityGroupMembersTable=bsnMobilityGroupMembersTable, bsnWrasIpsecCertStatus=bsnWrasIpsecCertStatus, bsnAPIfDot11TxPowerLevel7=bsnAPIfDot11TxPowerLevel7, bsnStandardSignatureAction=bsnStandardSignatureAction, bsnAPIfDot11CountersTable=bsnAPIfDot11CountersTable, bsnRadiusAuthServerRowStatus=bsnRadiusAuthServerRowStatus, bsnAPIfUpDownCause=bsnAPIfUpDownCause, bsnGlobalDot11bDot11gSupport=bsnGlobalDot11bDot11gSupport, bsnMeshNodeRole=bsnMeshNodeRole, bsnAclRuleStartSourcePort=bsnAclRuleStartSourcePort)
mibBuilder.exportSymbols("AIRESPACE-WIRELESS-MIB", bsnRrmDot11bSetFactoryDefault=bsnRrmDot11bSetFactoryDefault, bsnUsersTable=bsnUsersTable, bsnMeshNodeEntry=bsnMeshNodeEntry, bsnImpersonatingSourceMacAddr=bsnImpersonatingSourceMacAddr, bsnRogueAPAirespaceAPName=bsnRogueAPAirespaceAPName, bsnStationBlacklistingReasonCode=bsnStationBlacklistingReasonCode, bsnGlobalDot11MultiDomainCapabilityImplemented=bsnGlobalDot11MultiDomainCapabilityImplemented, bsnStandardSignatureState=bsnStandardSignatureState, bsnPingTestMaxTimeInterval=bsnPingTestMaxTimeInterval, bsnAPIfCoverageExceptionLevel=bsnAPIfCoverageExceptionLevel, bsnAPIfDot11PhyChannelEntry=bsnAPIfDot11PhyChannelEntry, bsnWatchListClientRowStatus=bsnWatchListClientRowStatus, bsnRogueAPDetectingAPMacAddress=bsnRogueAPDetectingAPMacAddress, bsnGlobalDot11bDataRate2Mhz=bsnGlobalDot11bDataRate2Mhz, bsnAPIfDot11MultiDomainCapabilityEnabled=bsnAPIfDot11MultiDomainCapabilityEnabled, bsnAPStatsTimer=bsnAPStatsTimer, bsnTagType=bsnTagType, bsnMobileStationStatsEntry=bsnMobileStationStatsEntry, bsnDot11EssCreated=bsnDot11EssCreated, bsnCustomSignatureQuietTime=bsnCustomSignatureQuietTime, bsnAPMirrorMode=bsnAPMirrorMode, bsnAPIfSlotId=bsnAPIfSlotId, bsnAPSlotIdTrapVariable=bsnAPSlotIdTrapVariable, bsnAPIfPacketsSniffingFeature=bsnAPIfPacketsSniffingFeature, bsnDot11EssRadioPolicy=bsnDot11EssRadioPolicy, bsnMobileStationEntry=bsnMobileStationEntry, bsnMemberTotalImportedClients=bsnMemberTotalImportedClients, bsnRogueAPEntry=bsnRogueAPEntry, bsnDot11QosProfileQueueDepth=bsnDot11QosProfileQueueDepth, bsnMobileStationChannelAgilityEnabled=bsnMobileStationChannelAgilityEnabled, bsnAAAGroupRev1=bsnAAAGroupRev1, bsnCustomSignaturePatternIndex=bsnCustomSignaturePatternIndex, bsnRogueAPAirespaceAPSNR=bsnRogueAPAirespaceAPSNR, bsnAPCurrentTxPowerChanged=bsnAPCurrentTxPowerChanged, bsnAclRuleTable=bsnAclRuleTable, bsnStandardSignatureEntry=bsnStandardSignatureEntry, bsnWrasDot11bGroupTable=bsnWrasDot11bGroupTable, bsnAPNoiseProfileUpdatedToPass=bsnAPNoiseProfileUpdatedToPass, bsnDot11EssAclName=bsnDot11EssAclName, bsnMeshNeighUnadjustedEase=bsnMeshNeighUnadjustedEase, bsnRogueAPDot11MacAddress=bsnRogueAPDot11MacAddress, bsnLinkTestId=bsnLinkTestId, bsnMobileStationTxExcessiveRetries=bsnMobileStationTxExcessiveRetries, bsnRadiusAuthClientUnknownTypes=bsnRadiusAuthClientUnknownTypes, bsnStandardSignatureVersion=bsnStandardSignatureVersion, bsnGlobalDot11bDataRate12Mhz=bsnGlobalDot11bDataRate12Mhz, bsnAPIfDot11PhyTxPowerEntry=bsnAPIfDot11PhyTxPowerEntry, bsnMobileStationByUserMacAddress=bsnMobileStationByUserMacAddress, bsnGlobalDot11aDataRate9Mhz=bsnGlobalDot11aDataRate9Mhz, bsnValidateRogueClientsAgainstAAA=bsnValidateRogueClientsAgainstAAA, bsnRadiusAuthKeyWrapEnable=bsnRadiusAuthKeyWrapEnable, bsnIpsecIkeNegFailure=bsnIpsecIkeNegFailure, bsnMemberTotalCommunicationErrors=bsnMemberTotalCommunicationErrors, bsnGlobalDot11bPBCCOptionImplemented=bsnGlobalDot11bPBCCOptionImplemented, bsnAPIfDot11TxPowerLevel6=bsnAPIfDot11TxPowerLevel6, bsnRrmDot11aNoiseMeasurementInterval=bsnRrmDot11aNoiseMeasurementInterval, bsnRogueAPAirespaceAPMacAddress=bsnRogueAPAirespaceAPMacAddress, bsnAPIfRxNeighborsEntry=bsnAPIfRxNeighborsEntry, bsnAPIfDot11RTSSuccessCount=bsnAPIfDot11RTSSuccessCount, bsnRogueClientPerRogueAPTable=bsnRogueClientPerRogueAPTable, bsnMeshNeighSnrUp=bsnMeshNeighSnrUp, bsnGlobalDot11bDataRate18Mhz=bsnGlobalDot11bDataRate18Mhz, bsnMobileStationPBCCOptionImplemented=bsnMobileStationPBCCOptionImplemented, bsnGlobalDot11a=bsnGlobalDot11a, bsnEss=bsnEss, bsnAPIfLoadParametersEntry=bsnAPIfLoadParametersEntry, bsnStationAPIfSlotId=bsnStationAPIfSlotId, bsnSignatureAttackChannel=bsnSignatureAttackChannel, bsnAPIfRxNeighborMacAddress=bsnAPIfRxNeighborMacAddress, bsnAPIfDot11MulticastTransmittedFrameCount=bsnAPIfDot11MulticastTransmittedFrameCount, bsnWrasDot11bGroupEntry=bsnWrasDot11bGroupEntry, bsnMobileStationWepState=bsnMobileStationWepState, bsnAPIfProfileStateTable=bsnAPIfProfileStateTable, bsnWpaMicErrorCounterActivated=bsnWpaMicErrorCounterActivated, bsnAPIfDot11TxPowerLevel5=bsnAPIfDot11TxPowerLevel5, bsnIkeTotalInitFailures=bsnIkeTotalInitFailures, bsnAPIfMultiDomainCapabilityTable=bsnAPIfMultiDomainCapabilityTable, bsnRrmGroup=bsnRrmGroup, bsnGlobalDot11aDataRate18Mhz=bsnGlobalDot11aDataRate18Mhz, bsnIkeTotalRespFailures=bsnIkeTotalRespFailures, bsnAPIfRxNeighborIpAddress=bsnAPIfRxNeighborIpAddress, bsnMobileStationBytesReceived=bsnMobileStationBytesReceived, bsnRogueAPAirespaceAPEntry=bsnRogueAPAirespaceAPEntry, bsnGlobalDot11aCFPollRequest=bsnGlobalDot11aCFPollRequest, bsnRadiusAuthServerIPSecIKEPhase1=bsnRadiusAuthServerIPSecIKEPhase1, bsnAPIfAdminStatus=bsnAPIfAdminStatus, bsnIpsecSPI=bsnIpsecSPI, bsnMeshNodeBackhaul=bsnMeshNodeBackhaul, bsnAPIfChannelList=bsnAPIfChannelList, bsnCustomSignaturePatternOffSetStart=bsnCustomSignaturePatternOffSetStart, bsnMeshNodeTxNeighRsp=bsnMeshNodeTxNeighRsp, bsnFastSSIDChangeFeature=bsnFastSSIDChangeFeature, bsnRogueClientAirespaceAPEntry=bsnRogueClientAirespaceAPEntry, bsnMobileStationRssiDataApName=bsnMobileStationRssiDataApName, bsnAPIfStationRSSICoverageIndex=bsnAPIfStationRSSICoverageIndex, bsnDot11ModePolicyEnforced=bsnDot11ModePolicyEnforced, bsnTotalHandoffRequests=bsnTotalHandoffRequests, bsnSignatureCheckState=bsnSignatureCheckState, bsnIpsecGroup=bsnIpsecGroup, bsnExternalPolicyServerIndex=bsnExternalPolicyServerIndex, bsnAPAuthMacAddress=bsnAPAuthMacAddress, bsnLocalNetUserEntry=bsnLocalNetUserEntry, bsnIpsecInvalidCookieTrap=bsnIpsecInvalidCookieTrap, bsnMacFilterTable=bsnMacFilterTable, bsnStandardSignatureEnable=bsnStandardSignatureEnable, bsnRogueAPAirespaceAPWepMode=bsnRogueAPAirespaceAPWepMode, bsnRogueClientDot11MacAddr=bsnRogueClientDot11MacAddr, bsnTrustedApHasInvalidPreamble=bsnTrustedApHasInvalidPreamble, bsnPingTestStatus=bsnPingTestStatus, bsnAppleTalkEnabled=bsnAppleTalkEnabled, bsnWrasIpsecCertificate=bsnWrasIpsecCertificate, bsnRtpProtocolPriority=bsnRtpProtocolPriority, bsnApBigNavDosAttack=bsnApBigNavDosAttack, bsnRrmDot11aLoadMeasurementInterval=bsnRrmDot11aLoadMeasurementInterval, bsnAPIfStationCountOnSNR=bsnAPIfStationCountOnSNR, bsnTemperatureAlarmHighLimit=bsnTemperatureAlarmHighLimit, bsnAPIfLoadChannelUtilization=bsnAPIfLoadChannelUtilization, bsnMobileStationEapType=bsnMobileStationEapType, bsnLinkTestStatus=bsnLinkTestStatus, bsnStandardSignatureName=bsnStandardSignatureName, bsnNetworkState=bsnNetworkState, bsnIpsecEspInvalidSpiTrap=bsnIpsecEspInvalidSpiTrap, bsnUtilityGroupRev1=bsnUtilityGroupRev1, bsnGlobalDot11aHighBandNetwork=bsnGlobalDot11aHighBandNetwork, bsnStandardSignatureRowStatus=bsnStandardSignatureRowStatus, bsnAPInvalidRadioType=bsnAPInvalidRadioType, bsnIpsecEspReplayFailureTrap=bsnIpsecEspReplayFailureTrap, bsnAPIfDot11TxPowerLevel8=bsnAPIfDot11TxPowerLevel8, bsnGlobalDot11b80211eMaxBandwidth=bsnGlobalDot11b80211eMaxBandwidth, bsnAPEthernetMacAddress=bsnAPEthernetMacAddress, bsnDot11EssEntry=bsnDot11EssEntry, bsnAPIfDot11BeaconPeriod=bsnAPIfDot11BeaconPeriod, bsnTotalHandoffAsLocalReceived=bsnTotalHandoffAsLocalReceived, bsnAPAuthRowStatus=bsnAPAuthRowStatus, bsnAPIfDBNoisePower=bsnAPIfDBNoisePower, bsnAPIfDot11FrameDuplicateCount=bsnAPIfDot11FrameDuplicateCount, bsnWrasDot11aPeerMacAddress=bsnWrasDot11aPeerMacAddress, bsnAPCertificateType=bsnAPCertificateType, bsnDot11QosBurstRealTimeDataRate=bsnDot11QosBurstRealTimeDataRate, bsnAPChannelNumberTrapVariable=bsnAPChannelNumberTrapVariable, bsnMeshNeighSnrDown=bsnMeshNeighSnrDown, bsnAAAMacDelimiter=bsnAAAMacDelimiter, bsnAPTable=bsnAPTable, bsnExternalPolicyServerTable=bsnExternalPolicyServerTable, bsnDot11EssFortressSecurity=bsnDot11EssFortressSecurity, bsnAPIfNoiseProfileState=bsnAPIfNoiseProfileState, bsnLinkTestEntry=bsnLinkTestEntry, bsnMobileStationStatus=bsnMobileStationStatus, bsnGlobalDot11aFirstChannelNumber=bsnGlobalDot11aFirstChannelNumber, bsnRogueAPMaxRssiRadioType=bsnRogueAPMaxRssiRadioType, bsnCustomSignaturePatternMask=bsnCustomSignaturePatternMask, bsnMeshNodeEthernetBridge=bsnMeshNodeEthernetBridge, bsnUserEssIndex=bsnUserEssIndex, bsnUserAccessMode=bsnUserAccessMode, bsnLinkTestLocalSNR=bsnLinkTestLocalSNR, bsnMobileStationByIpAddress=bsnMobileStationByIpAddress, bsnAutoContainRoguesAdvertisingSsid=bsnAutoContainRoguesAdvertisingSsid, bsnRadiusAccServerKeyFormat=bsnRadiusAccServerKeyFormat, bsnRrmDot11aRFUtilizationThreshold=bsnRrmDot11aRFUtilizationThreshold, bsnIkeAuthMethod=bsnIkeAuthMethod, bsnDot11EssDhcpServerIpAddress=bsnDot11EssDhcpServerIpAddress, bsnAPIfProfileThresholdConfigEntry=bsnAPIfProfileThresholdConfigEntry, bsnThirdPartyAPIpAddress=bsnThirdPartyAPIpAddress, bsnAPIfPhyAntennaMode=bsnAPIfPhyAntennaMode, bsnMobileStationPolicyType=bsnMobileStationPolicyType, bsnGlobalDot11aDynamicChannelAssignment=bsnGlobalDot11aDynamicChannelAssignment, bsnRadiusAccServerIndex=bsnRadiusAccServerIndex, bsnApFunctionalityDisableReasonCode=bsnApFunctionalityDisableReasonCode, bsnMobileStationSessionTimeout=bsnMobileStationSessionTimeout, bsnAPIfSniffChannel=bsnAPIfSniffChannel, bsnDot11EssAAAOverride=bsnDot11EssAAAOverride, bsnDot11EssL2tpSecurity=bsnDot11EssL2tpSecurity, bsnRadiusAccServerIPSec=bsnRadiusAccServerIPSec, bsnAPPortNumber=bsnAPPortNumber, bsnCustomSignaturePatternOffset=bsnCustomSignaturePatternOffset, bsnTotalHandoffEndRequestsReceived=bsnTotalHandoffEndRequestsReceived, bsnRrmIsDot11aGroupLeader=bsnRrmIsDot11aGroupLeader, bsnAcceptSelfSignedCertificate=bsnAcceptSelfSignedCertificate, bsnRrmDot11bCoverageExceptionLevel=bsnRrmDot11bCoverageExceptionLevel, bsnGlobalDot11aTIThreshold=bsnGlobalDot11aTIThreshold, bsnRogueClientTotalDetectingAPs=bsnRogueClientTotalDetectingAPs, bsnRadiusAuthServerKeyWrapFormat=bsnRadiusAuthServerKeyWrapFormat, bsnAPIfLoadRxUtilization=bsnAPIfLoadRxUtilization, bsnMobileStationMacAddress=bsnMobileStationMacAddress, bsnGlobalDot11bDataRate54Mhz=bsnGlobalDot11bDataRate54Mhz, bsnRadiusAuthServerStatsEntry=bsnRadiusAuthServerStatsEntry, bsnRogueAPTable=bsnRogueAPTable, bsnGlobalDot11aDTIMPeriod=bsnGlobalDot11aDTIMPeriod, bsnMeshNodeChannel=bsnMeshNodeChannel, bsnDot11EssNumberOfMobileStations=bsnDot11EssNumberOfMobileStations, bsnDot11ResetProfileToDefault=bsnDot11ResetProfileToDefault, bsnMeshNeighParentChange=bsnMeshNeighParentChange, bsnWepKeyDecryptError=bsnWepKeyDecryptError, bsnGlobalDot11aMediumBandNetwork=bsnGlobalDot11aMediumBandNetwork, bsnLinkTestSendPktLength=bsnLinkTestSendPktLength, bsnAPIfDot11CFPMaxDuration=bsnAPIfDot11CFPMaxDuration, bsnAPCoverageTotalClients=bsnAPCoverageTotalClients, bsnGlobalDot11bDynamicTxPowerControlInterval=bsnGlobalDot11bDynamicTxPowerControlInterval, bsnGlobalDot11bPowerUpdateCmdInvoke=bsnGlobalDot11bPowerUpdateCmdInvoke, bsnDot11EssStaticWEPKeyFormat=bsnDot11EssStaticWEPKeyFormat, bsnMobileStationStatsTable=bsnMobileStationStatsTable, bsnAPIfRecommendedRFParametersTable=bsnAPIfRecommendedRFParametersTable, bsnWrasDepGroup=bsnWrasDepGroup, bsnExcessive8021xAuthFailures=bsnExcessive8021xAuthFailures, bsnSensedTemperatureTooHigh=bsnSensedTemperatureTooHigh, bsnRrmDot11aMobilesThreshold=bsnRrmDot11aMobilesThreshold, bsnRogueAPAirespaceAPLastHeard=bsnRogueAPAirespaceAPLastHeard, bsnAPAuthorizationFailure=bsnAPAuthorizationFailure, bsnAPIfMobileMinExceptionLevel=bsnAPIfMobileMinExceptionLevel, bsnAPIfDot11TxPowerLevel4=bsnAPIfDot11TxPowerLevel4, bsnRfIdTagAutoTimeoutStatus=bsnRfIdTagAutoTimeoutStatus, bsnStandardSignaturePatternRowStatus=bsnStandardSignaturePatternRowStatus, bsnRogueAPContainmentLevel=bsnRogueAPContainmentLevel, bsnAPGroupsVlanMappingInterfaceName=bsnAPGroupsVlanMappingInterfaceName, bsnMobileStationTxFiltered=bsnMobileStationTxFiltered, bsnPingTestTable=bsnPingTestTable, bsnRogueAPContainmentMode=bsnRogueAPContainmentMode, bsnTrustedApHasInvalidRadioPolicy=bsnTrustedApHasInvalidRadioPolicy, bsnSignatureType=bsnSignatureType, bsnCustomSignatureName=bsnCustomSignatureName, bsnRFNetworkName=bsnRFNetworkName, bsnAPIfNumberOfVaps=bsnAPIfNumberOfVaps, bsnGlobalDot11bDataRate11Mhz=bsnGlobalDot11bDataRate11Mhz, bsnPingTestEntry=bsnPingTestEntry, bsnAPAuthorizationFailureCause=bsnAPAuthorizationFailureCause, bsnTagRssiDataLastHeard=bsnTagRssiDataLastHeard, bsnRadarChannelDetected=bsnRadarChannelDetected, bsnStandardSignaturePatternIndex=bsnStandardSignaturePatternIndex, bsnGlobalDot11aCurrentTxPowerLevel=bsnGlobalDot11aCurrentTxPowerLevel, bsnAclRuleSourceIpNetmask=bsnAclRuleSourceIpNetmask, bsnRogueAPOnWiredNetwork=bsnRogueAPOnWiredNetwork, bsnLinkTestSendPktCount=bsnLinkTestSendPktCount, bsnAPAuthHashKey=bsnAPAuthHashKey, bsnLocalManagementUserRowStatus=bsnLocalManagementUserRowStatus, bsnPingTestReceivedCount=bsnPingTestReceivedCount, bsnAPIfLoadProfileState=bsnAPIfLoadProfileState, bsnRogueClientState=bsnRogueClientState, bsnDot11EssIpsecSecurity=bsnDot11EssIpsecSecurity, bsnGlobalDot11aMediumOccupancyLimit=bsnGlobalDot11aMediumOccupancyLimit, bsnPing=bsnPing, bsnStandardSignatureMacFreq=bsnStandardSignatureMacFreq, bsnAPIfDot11FirstChannelNumber=bsnAPIfDot11FirstChannelNumber, bsnRadiusAccServerRowStatus=bsnRadiusAccServerRowStatus, bsnAclRuleSourceIpAddress=bsnAclRuleSourceIpAddress, bsnGlobalDot11aCurrentChannel=bsnGlobalDot11aCurrentChannel, bsnAuthenticationFailure=bsnAuthenticationFailure, bsnRadiusAuthClientAccessRetransmissions=bsnRadiusAuthClientAccessRetransmissions, bsnRadiusAuthServerIPSec=bsnRadiusAuthServerIPSec, bsnMobileStationEssIndex=bsnMobileStationEssIndex, bsnGlobalDot11bDTPCSupport=bsnGlobalDot11bDTPCSupport, bsnAP=bsnAP, bsnAPIfRecommendedRTSThreshold=bsnAPIfRecommendedRTSThreshold, bsnGlobalDot11GroupRev1=bsnGlobalDot11GroupRev1, bsnAPIfProfileStateEntry=bsnAPIfProfileStateEntry)
mibBuilder.exportSymbols("AIRESPACE-WIRELESS-MIB", bsnMobileStationCFPollable=bsnMobileStationCFPollable, bsnAPIfForeignInterferenceThreshold=bsnAPIfForeignInterferenceThreshold, bsnMeshNeighSnr=bsnMeshNeighSnr, bsnRrmDot11bGroup=bsnRrmDot11bGroup, bsnGlobalDot11CountryIndex=bsnGlobalDot11CountryIndex, bsnDot11802Dot1PTag=bsnDot11802Dot1PTag, bsnLocalManagementUserPassword=bsnLocalManagementUserPassword, bsnAclRuleDirection=bsnAclRuleDirection, bsnIpsecErrorCount=bsnIpsecErrorCount, bsnLocalNetUserStartTime=bsnLocalNetUserStartTime, bsnSyslog=bsnSyslog, bsnPolicyForMisconfiguredAps=bsnPolicyForMisconfiguredAps, bsnTagRssiDataApIfType=bsnTagRssiDataApIfType, bsnRogueAPAirespaceAPPreamble=bsnRogueAPAirespaceAPPreamble, bsnAclTable=bsnAclTable, bsnTotalHandoffRequestsDropped=bsnTotalHandoffRequestsDropped, bsnThirdPartyAPMirrorMode=bsnThirdPartyAPMirrorMode, bsnSystemTimezoneDaylightSavings=bsnSystemTimezoneDaylightSavings, bsnAPIfDot11TxPowerLevel3=bsnAPIfDot11TxPowerLevel3, bsnRadioTypePolicyEnforced=bsnRadioTypePolicyEnforced, bsnDot11StationAssociateFail=bsnDot11StationAssociateFail, bsnSensorTemperature=bsnSensorTemperature, bsnAPIfDot11MediumOccupancyLimit=bsnAPIfDot11MediumOccupancyLimit, locationNotifyTrap=locationNotifyTrap, bsnStandardSignaturePatternMask=bsnStandardSignaturePatternMask, bsnMobilityGroupMemberIPAddress=bsnMobilityGroupMemberIPAddress, bsnAPIfMacOperationParamTable=bsnAPIfMacOperationParamTable, bsnGlobalDot11bMaximumTransmitPowerLevel=bsnGlobalDot11bMaximumTransmitPowerLevel, bsnConfigSaveTrapEnable=bsnConfigSaveTrapEnable, bsnRogueAPClassType=bsnRogueAPClassType, bsnAPEntry=bsnAPEntry, bsnAPIfDot11MacLongRetryLimit=bsnAPIfDot11MacLongRetryLimit, bsnRogueAPOnNetwork=bsnRogueAPOnNetwork, bsnTrustedApHasInvalidEncryption=bsnTrustedApHasInvalidEncryption, bsnPingTestAvgTimeInterval=bsnPingTestAvgTimeInterval, bsnGlobalDot11bRxSopThreshold=bsnGlobalDot11bRxSopThreshold, bsnSignatureAttackDetected=bsnSignatureAttackDetected, bsnLicenseKeyFeatureSetTrapVariable=bsnLicenseKeyFeatureSetTrapVariable, bsnAPIfSNRLevel=bsnAPIfSNRLevel, bsnMobileStationAPIfSlotId=bsnMobileStationAPIfSlotId, bsnTagStatsEntry=bsnTagStatsEntry, bsnMacFilterEntry=bsnMacFilterEntry, bsnDot11EssRSNAuthPresharedKeyHex=bsnDot11EssRSNAuthPresharedKeyHex, bsnCustomSignatureConfigType=bsnCustomSignatureConfigType, bsnLinkTestClientRSSI=bsnLinkTestClientRSSI, bsnNotifiesSent=bsnNotifiesSent, bsnAPIfDot11ACKFailureCount=bsnAPIfDot11ACKFailureCount, bsnCustomSignatureInterval=bsnCustomSignatureInterval, bsnTrustedApHasInvalidSsid=bsnTrustedApHasInvalidSsid, bsnOverAirProvisionApMode=bsnOverAirProvisionApMode, bsnCustomSignatureFrequency=bsnCustomSignatureFrequency, bsnAPAuthCertificateType=bsnAPAuthCertificateType, bsnRrmDot11aForeignNoiseThreshold=bsnRrmDot11aForeignNoiseThreshold, bsnApHasNoRadioCards=bsnApHasNoRadioCards, bsnGlobalDot11AuthenticationResponseTimeOut=bsnGlobalDot11AuthenticationResponseTimeOut, bsnAclRuleEndSourcePort=bsnAclRuleEndSourcePort, bsnMobilityAnchorRowStatus=bsnMobilityAnchorRowStatus, bsnRogueAPRowStatus=bsnRogueAPRowStatus, bsnExternalPolicyServerFailures=bsnExternalPolicyServerFailures, bsnEssGroup=bsnEssGroup, PYSNMP_MODULE_ID=bsnWireless, bsnGlobalDot11aDynamicTransmitPowerControl=bsnGlobalDot11aDynamicTransmitPowerControl, bsnTrustedApPolicyConfig=bsnTrustedApPolicyConfig, bsnGlobalDot11aCFPollable=bsnGlobalDot11aCFPollable, bsnAAARadiusCallStationIdType=bsnAAARadiusCallStationIdType, bsnPingTestRowStatus=bsnPingTestRowStatus, bsnMobileStationUserName=bsnMobileStationUserName, bsnGlobalDot11bCFPMaxDuration=bsnGlobalDot11bCFPMaxDuration, bsnAAAGroup=bsnAAAGroup, bsnLinkTestMacAddress=bsnLinkTestMacAddress, bsnRadiusAuthServerKeyFormat=bsnRadiusAuthServerKeyFormat, bsnAclRuleRowStatus=bsnAclRuleRowStatus, bsnDuplicateIpAddressReported=bsnDuplicateIpAddressReported, bsnMobilityAnchorsTable=bsnMobilityAnchorsTable, bsnMeshNodeRxNeighRsp=bsnMeshNodeRxNeighRsp, bsnMeshNeighRapEase=bsnMeshNeighRapEase, bsnDot11EssRadiusAuthSecondaryServer=bsnDot11EssRadiusAuthSecondaryServer, bsnRrmDot11aCoverageExceptionLevel=bsnRrmDot11aCoverageExceptionLevel, bsnWrasObsGroup=bsnWrasObsGroup, bsnMobilityAnchorSwitchIPAddress=bsnMobilityAnchorSwitchIPAddress, bsnCustomSignatureEnable=bsnCustomSignatureEnable, bsnTotalStateTransitionsDisallowed=bsnTotalStateTransitionsDisallowed, bsnRadiusAccServerNetworkUserConfig=bsnRadiusAccServerNetworkUserConfig, bsnAPParamUpdateTrapControlMask=bsnAPParamUpdateTrapControlMask, bsnAPIfDot11TransmittedFrameCount=bsnAPIfDot11TransmittedFrameCount, bsnTemperatureAlarmLowLimit=bsnTemperatureAlarmLowLimit, bsnMobilityGroupMembersEntry=bsnMobilityGroupMembersEntry, bsnMacFilterDescription=bsnMacFilterDescription, bsnAPProfileTrapControlMask=bsnAPProfileTrapControlMask, bsnGlobalDot11aInputsForDCA=bsnGlobalDot11aInputsForDCA, bsnCurrentExportedClients=bsnCurrentExportedClients, bsnDot11StationAuthenticateFail=bsnDot11StationAuthenticateFail, bsnAPGroupsVlanMappingEntry=bsnAPGroupsVlanMappingEntry, bsnAPIfProfileParamAssignment=bsnAPIfProfileParamAssignment, bsnRadiusAccClientBadAuthenticators=bsnRadiusAccClientBadAuthenticators, bsnRogueAdhocMode=bsnRogueAdhocMode, bsnLinkTest=bsnLinkTest, bsnSystemTimezoneDeltaMinutes=bsnSystemTimezoneDeltaMinutes, bsnTotalTransmitErrors=bsnTotalTransmitErrors, bsnVirtualGatewayAddress=bsnVirtualGatewayAddress, bsnAclRuleDestinationIpAddress=bsnAclRuleDestinationIpAddress, bsnAPReset=bsnAPReset, bsnAPIfRegulatoryDomainSupport=bsnAPIfRegulatoryDomainSupport, bsnRadiusAuthServerKey=bsnRadiusAuthServerKey, bsnRrmDot11a=bsnRrmDot11a, bsnGroupDirectoryMemberIPAddress=bsnGroupDirectoryMemberIPAddress, bsnRrmDot11bGroupingDone=bsnRrmDot11bGroupingDone, bsnGlobalDot11aDataRate24Mhz=bsnGlobalDot11aDataRate24Mhz, bsnClientSnr=bsnClientSnr, bsnAPIfLoadNumOfClients=bsnAPIfLoadNumOfClients, bsnAPLoadProfileUpdatedToPass=bsnAPLoadProfileUpdatedToPass, bsnDot11EssRowStatus=bsnDot11EssRowStatus, bsnDot11StationDisassociate=bsnDot11StationDisassociate, bsnMobilityConfig=bsnMobilityConfig, bsnTotalResourceErrors=bsnTotalResourceErrors, bsnDot11EssSessionTimeout=bsnDot11EssSessionTimeout, bsnMobileStationProtocol=bsnMobileStationProtocol, bsnRadiusAuthServerKeyWrapKEKkey=bsnRadiusAuthServerKeyWrapKEKkey, bsnRogueClientAirespaceAPTable=bsnRogueClientAirespaceAPTable, bsnApRegulatoryDomain=bsnApRegulatoryDomain, bsnDot11EssVpnSharedKeySize=bsnDot11EssVpnSharedKeySize, bsnMobileStationSecurityPolicyStatus=bsnMobileStationSecurityPolicyStatus, bsnThirdPartyAPRowStatus=bsnThirdPartyAPRowStatus, bsnInterferenceEnergyBeforeChannelUpdate=bsnInterferenceEnergyBeforeChannelUpdate, bsnExternalPolicyServerAddress=bsnExternalPolicyServerAddress, bsnMobileStationRssiDataApIfType=bsnMobileStationRssiDataApIfType, bsnGlobalDot11bFastRoamingVoipMinRate=bsnGlobalDot11bFastRoamingVoipMinRate, bsnRogueAPDetectedOnWiredNetwork=bsnRogueAPDetectedOnWiredNetwork, bsnRrmDot11bGlobalGroupInterval=bsnRrmDot11bGlobalGroupInterval, bsnRadiusAuthServerNetworkUserConfig=bsnRadiusAuthServerNetworkUserConfig, bsnDot11QosProfileEntry=bsnDot11QosProfileEntry, bsnDuplicateIpReportedByAP=bsnDuplicateIpReportedByAP, bsnDot11QosAverageDataRate=bsnDot11QosAverageDataRate, bsnRogueClientContainmentLevel=bsnRogueClientContainmentLevel, bsnLocalNetUserPassword=bsnLocalNetUserPassword, bsnCustomSignatureRowStatus=bsnCustomSignatureRowStatus, bsnWrasDot11bPeerIpAddress=bsnWrasDot11bPeerIpAddress, bsnAPCurrentChannelChanged=bsnAPCurrentChannelChanged, bsnDot11EssRadiusAcctSecondaryServer=bsnDot11EssRadiusAcctSecondaryServer, bsnEncryptionPolicyEnforced=bsnEncryptionPolicyEnforced, bsnAPIfStationSNRCoverageInfoTable=bsnAPIfStationSNRCoverageInfoTable, bsnStandardSignaturePatternOffset=bsnStandardSignaturePatternOffset, bsnGlobalDot11bChannelUpdateCmdStatus=bsnGlobalDot11bChannelUpdateCmdStatus, bsnGlobalDot11hConfig=bsnGlobalDot11hConfig, bsnTotalAnchorRequestsDenied=bsnTotalAnchorRequestsDenied, bsnSuiteInitFailures=bsnSuiteInitFailures, bsnAPIfDot11DTIMPeriod=bsnAPIfDot11DTIMPeriod, bsnRadiusAuthServerStatus=bsnRadiusAuthServerStatus, bsnTrapVariable=bsnTrapVariable, bsnMeshNodeRoutingState=bsnMeshNodeRoutingState, bsnAPCoverageProfileFailed=bsnAPCoverageProfileFailed, bsnNetworkStateChanged=bsnNetworkStateChanged, bsnGlobalDot11aFragmentationThreshold=bsnGlobalDot11aFragmentationThreshold, bsnGlobalDot11bPowerUpdateCmdStatus=bsnGlobalDot11bPowerUpdateCmdStatus, bsnStationAPMacAddr=bsnStationAPMacAddr, bsnWrasGroups=bsnWrasGroups, bsnAPGroupVlanName=bsnAPGroupVlanName, bsnRrmDot11aSetFactoryDefault=bsnRrmDot11aSetFactoryDefault, bsnRogueAPRemoved=bsnRogueAPRemoved, bsnSignatureName=bsnSignatureName, bsnGlobalDot11bCurrentTxPowerLevel=bsnGlobalDot11bCurrentTxPowerLevel, bsnAPIfSmtParamEntry=bsnAPIfSmtParamEntry, bsnRogueAPDetectingAPRadioType=bsnRogueAPDetectingAPRadioType, bsnGroupDirectoryMemberMacAddress=bsnGroupDirectoryMemberMacAddress, bsnApIpAddress=bsnApIpAddress, bsnGlobalDot11bLongRetryLimit=bsnGlobalDot11bLongRetryLimit, bsnDot11EssVpnIkeAuthMode=bsnDot11EssVpnIkeAuthMode, bsnMobileStationPerRadioPerVapTable=bsnMobileStationPerRadioPerVapTable, bsnDot11EssVpnSharedKey=bsnDot11EssVpnSharedKey, bsnInterferenceEnergyAfterChannelUpdate=bsnInterferenceEnergyAfterChannelUpdate, bsnRrmDot11bCoverageThreshold=bsnRrmDot11bCoverageThreshold, bsnAPDisassociated=bsnAPDisassociated, bsnTotalAnchorDenyReceived=bsnTotalAnchorDenyReceived, bsnAllowAuthorizeApAgainstAAA=bsnAllowAuthorizeApAgainstAAA, bsnEssGroupRev1=bsnEssGroupRev1, bsnRogueAutoContainFeature=bsnRogueAutoContainFeature, bsnMeshNodeTable=bsnMeshNodeTable, bsnAPPreviousChannelNumberTrapVariable=bsnAPPreviousChannelNumberTrapVariable, bsnDot11EssDeleted=bsnDot11EssDeleted, bsnRADIUSServerNotResponding=bsnRADIUSServerNotResponding, bsnTrapsGroupRev1=bsnTrapsGroupRev1, bsnAPIfDot11SmtParamsConfigType=bsnAPIfDot11SmtParamsConfigType, bsnMobileStationByIpTable=bsnMobileStationByIpTable, bsnCustomSignatureMacInfo=bsnCustomSignatureMacInfo, bsnTrustedApRadioPolicyRequired=bsnTrustedApRadioPolicyRequired, bsnCustomSignatureEntry=bsnCustomSignatureEntry, bsnTrustedApRadioPolicyUsed=bsnTrustedApRadioPolicyUsed, bsnAPIfDot11MacShortRetryLimit=bsnAPIfDot11MacShortRetryLimit, bsnMobilityStatsReset=bsnMobilityStatsReset, bsnPingTestId=bsnPingTestId, bsnRogueAPTotalClients=bsnRogueAPTotalClients, bsnAPIfInterferenceUtilization=bsnAPIfInterferenceUtilization, bsnMobileStationE2eVersion=bsnMobileStationE2eVersion, bsnRogueAPDetected=bsnRogueAPDetected, bsnAPIfDot11TxPowerLevel2=bsnAPIfDot11TxPowerLevel2, bsnAPIfEntry=bsnAPIfEntry, bsnGlobalDot11aRTSThreshold=bsnGlobalDot11aRTSThreshold, bsnRrmIsDot11bGroupLeader=bsnRrmIsDot11bGroupLeader, bsnGlobalDot11aDynamicChannelUpdateInterval=bsnGlobalDot11aDynamicChannelUpdateInterval, bsnCurrentImportedClients=bsnCurrentImportedClients, bsnAPIfOperStatus=bsnAPIfOperStatus, bsnBridgingPolicyConfig=bsnBridgingPolicyConfig, bsnApFallbackEnabled=bsnApFallbackEnabled, bsnAPGroupsVlanMappingTable=bsnAPGroupsVlanMappingTable, bsnRadiusAuthClientBadAuthenticators=bsnRadiusAuthClientBadAuthenticators, bsnDuplicateIpTrapVariable=bsnDuplicateIpTrapVariable, bsnSignatureMacInfo=bsnSignatureMacInfo, bsnAPIfTable=bsnAPIfTable, bsnAPGroupsVlanName=bsnAPGroupsVlanName, bsnRadiusAccServerIPSecDHGroup=bsnRadiusAccServerIPSecDHGroup, bsnWlanIdTrapVariable=bsnWlanIdTrapVariable, bsnTotalAnchorRequestsReceived=bsnTotalAnchorRequestsReceived, bsnTotalAnchorTransferReceived=bsnTotalAnchorTransferReceived, bsnRrmDot11bAPDefault=bsnRrmDot11bAPDefault, bsnMobileStationAID=bsnMobileStationAID, bsnAPAdminStatus=bsnAPAdminStatus, bsnLocalNetUserName=bsnLocalNetUserName, bsnTooManyUnsuccessLoginAttempts=bsnTooManyUnsuccessLoginAttempts, bsnMeshNodeHops=bsnMeshNodeHops, bsnAclEntry=bsnAclEntry, bsnRadiusAuthServerRetransmitTimeout=bsnRadiusAuthServerRetransmitTimeout, bsnMobileStationVlanId=bsnMobileStationVlanId, bsnAPIfRadarSignalLastHeard=bsnAPIfRadarSignalLastHeard, bsnRrmDot11bChannelMonitorList=bsnRrmDot11bChannelMonitorList, bsnMaxRogueCountExceeded=bsnMaxRogueCountExceeded, bsnTagRssiDataTable=bsnTagRssiDataTable, bsnAPName=bsnAPName, locationNotifyContent=locationNotifyContent, bsnRadiusAccServerStatsTable=bsnRadiusAccServerStatsTable, bsnMobileStationAuthenticationAlgorithm=bsnMobileStationAuthenticationAlgorithm, bsnSyslogEnable=bsnSyslogEnable, bsnRogueAPChannel=bsnRogueAPChannel, bsnRrmDot11aGlobalGroupInterval=bsnRrmDot11aGlobalGroupInterval, bsnStandardSignatureConfigType=bsnStandardSignatureConfigType, bsnAPDown=bsnAPDown, bsnRrmDot11bMobileMinExceptionLevel=bsnRrmDot11bMobileMinExceptionLevel, bsnMobileStationRssiDataLastHeard=bsnMobileStationRssiDataLastHeard, bsnGlobalDot11bEDThreshold=bsnGlobalDot11bEDThreshold, bsnAPIfDot11RTSFailureCount=bsnAPIfDot11RTSFailureCount, bsnAPReasonCodeTrapVariable=bsnAPReasonCodeTrapVariable, bsnDot11EssRadiusAuthTertiaryServer=bsnDot11EssRadiusAuthTertiaryServer, bsnRadiusAccClientServerPortNumber=bsnRadiusAccClientServerPortNumber, bsnRadiusAccServerEntry=bsnRadiusAccServerEntry, bsnAPCoverageThresholdTrapVariable=bsnAPCoverageThresholdTrapVariable, bsnWrasIpsecCertEntry=bsnWrasIpsecCertEntry, bsnInitiatorCookie=bsnInitiatorCookie, bsnGlobalDot11aCFPPeriod=bsnGlobalDot11aCFPPeriod, bsnWrasCompliances=bsnWrasCompliances, bsnGlobalDot11aMaximumTransmitPowerLevel=bsnGlobalDot11aMaximumTransmitPowerLevel, bsnAPIfMultiDomainCapabilityEntry=bsnAPIfMultiDomainCapabilityEntry, bsnGlobalDot11bMediumOccupancyLimit=bsnGlobalDot11bMediumOccupancyLimit, bsnMobilityDynamicDiscovery=bsnMobilityDynamicDiscovery, bsnGlobalDot11bInputsForDTP=bsnGlobalDot11bInputsForDTP, bsnAPGroupsVlanEntry=bsnAPGroupsVlanEntry)
mibBuilder.exportSymbols("AIRESPACE-WIRELESS-MIB", bsnGlobalDot11RogueTimer=bsnGlobalDot11RogueTimer, bsnAPRadioCardRxFailure=bsnAPRadioCardRxFailure, bsnAPRadioCardTxFailureClear=bsnAPRadioCardTxFailureClear, bsnGlobalDot11bFragmentationThreshold=bsnGlobalDot11bFragmentationThreshold, bsnStandardSignatureFrequency=bsnStandardSignatureFrequency, bsnDot11EssWPAAuthPresharedKeyHex=bsnDot11EssWPAAuthPresharedKeyHex, bsnDot11EssVpnIkeDHGroup=bsnDot11EssVpnIkeDHGroup, bsnMemberCurrentImportedClients=bsnMemberCurrentImportedClients, bsnLocalManagementUserEntry=bsnLocalManagementUserEntry, bsnRrmDot11bThroughputThreshold=bsnRrmDot11bThroughputThreshold, bsnAPNeighborAuthStatus=bsnAPNeighborAuthStatus, bsnCustomSignaturePatternTable=bsnCustomSignaturePatternTable, bsnDot11EssVpnAuthTransform=bsnDot11EssVpnAuthTransform, bsnDot11EssRadiusAcctPrimaryServer=bsnDot11EssRadiusAcctPrimaryServer, bsnAPIfDot11BSSID=bsnAPIfDot11BSSID, bsnGlobalDot11bDTIMPeriod=bsnGlobalDot11bDTIMPeriod, bsnDot11EssStaticWEPEncryptionType=bsnDot11EssStaticWEPEncryptionType, bsnMobileStationExtStatsEntry=bsnMobileStationExtStatsEntry, bsnAPIOSVersion=bsnAPIOSVersion, bsnThirdPartyAP802Dot1XRequired=bsnThirdPartyAP802Dot1XRequired, bsnTagEntry=bsnTagEntry, bsnDot11QosProfileTable=bsnDot11QosProfileTable, bsnAPClearConfig=bsnAPClearConfig, bsnMeshNeighsTable=bsnMeshNeighsTable, bsnCustomSignaturePatternRowStatus=bsnCustomSignaturePatternRowStatus, bsnWrasComplianceRev1=bsnWrasComplianceRev1, bsnAPIfPhyTxPowerControl=bsnAPIfPhyTxPowerControl, bsnRogueClientEntry=bsnRogueClientEntry, bsnMobileStationExtStatsTable=bsnMobileStationExtStatsTable, unsupportedAPTrap=unsupportedAPTrap, bsnRadiusAccServerIPSecEncryption=bsnRadiusAccServerIPSecEncryption, bsnAclRuleEntry=bsnAclRuleEntry, bsnDot11StationDeauthenticate=bsnDot11StationDeauthenticate, bsnTrustedApPreambleRequired=bsnTrustedApPreambleRequired, bsnMobileStationTxRetries=bsnMobileStationTxRetries, bsnAPNetmask=bsnAPNetmask, bsnAclRuleProtocol=bsnAclRuleProtocol, bsnRadiusAccClientMalformedResponses=bsnRadiusAccClientMalformedResponses, bsnStandardSignaturePatternEntry=bsnStandardSignaturePatternEntry, bsnAPIfAbsolutePowerList=bsnAPIfAbsolutePowerList, bsnDot11QosAvgRealTimeDataRate=bsnDot11QosAvgRealTimeDataRate, bsnTotalHandoffRepliesReceived=bsnTotalHandoffRepliesReceived, bsnGlobalDot11aMaxTransmitMSDULifetime=bsnGlobalDot11aMaxTransmitMSDULifetime, bsnAPIfDown=bsnAPIfDown, bsnMobilityProtocolPortNum=bsnMobilityProtocolPortNum, bsnAPMacAddrTrapVariable=bsnAPMacAddrTrapVariable, bsnMobileStationTable=bsnMobileStationTable, bsnRadiusAuthClientPacketsDropped=bsnRadiusAuthClientPacketsDropped, bsnDot11EssCraniteSecurity=bsnDot11EssCraniteSecurity, bsnMobileStationByUserName=bsnMobileStationByUserName, bsnAPIfDot11TxPowerLevel1=bsnAPIfDot11TxPowerLevel1, bsnAPIfMacOperationParamEntry=bsnAPIfMacOperationParamEntry, heartbeatLossTrap=heartbeatLossTrap, bsnStandardSignatureMacInfo=bsnStandardSignatureMacInfo, bsnAPLocation=bsnAPLocation, bsnDot11EssBlacklistTimeout=bsnDot11EssBlacklistTimeout, bsnStandardSignaturePatternString=bsnStandardSignaturePatternString, bsnMeshNeighsEntry=bsnMeshNeighsEntry, countryChangeTrap=countryChangeTrap, bsnRogueAPLastReported=bsnRogueAPLastReported, bsnGlobalDot11bBeaconPeriod=bsnGlobalDot11bBeaconPeriod, bsnGlobalDot11aFastRoamingMode=bsnGlobalDot11aFastRoamingMode, bsnMobileStationMacAddr=bsnMobileStationMacAddr, bsnAPIfDot11CurrentCCAMode=bsnAPIfDot11CurrentCCAMode, bsnMobileStationByIpMacAddress=bsnMobileStationByIpMacAddress, bsnMeshNodePoorNeighSnr=bsnMeshNodePoorNeighSnr, bsnRadiusAuthServerIPSecEncryption=bsnRadiusAuthServerIPSecEncryption, bsnAPNeighborAuthAlarmThreshold=bsnAPNeighborAuthAlarmThreshold, bsnTagBatteryStatus=bsnTagBatteryStatus, bsnIpsecSuiteNegFailure=bsnIpsecSuiteNegFailure, bsnInterferenceAfterChannelUpdate=bsnInterferenceAfterChannelUpdate, bsnIpsecTrapsMask=bsnIpsecTrapsMask, bsnAPModel=bsnAPModel, bsnAPIfDot11WEPUndecryptableCount=bsnAPIfDot11WEPUndecryptableCount, bsnMobileStationMirrorMode=bsnMobileStationMirrorMode, bsnDot11Ess8021xSecurity=bsnDot11Ess8021xSecurity, bsnAPCoverageFailedClients=bsnAPCoverageFailedClients, bsnLocalNetUserRowStatus=bsnLocalNetUserRowStatus, bsnTagRssiDataApIfSlotId=bsnTagRssiDataApIfSlotId, bsnAPIfDot11TransmittedFragmentCount=bsnAPIfDot11TransmittedFragmentCount, bsnStandardSignatureDescription=bsnStandardSignatureDescription, bsnRadiusAccClientTimeouts=bsnRadiusAccClientTimeouts, bsnTagLastReported=bsnTagLastReported, bsnTotalHandoffAsForeignReceived=bsnTotalHandoffAsForeignReceived, bsnGlobalDot11aChannelUpdateCmdStatus=bsnGlobalDot11aChannelUpdateCmdStatus, bsnAPIfPhyAntennaDiversity=bsnAPIfPhyAntennaDiversity, bsnTagPacketsReceived=bsnTagPacketsReceived, bsnMobileStationAnchorAddress=bsnMobileStationAnchorAddress, bsnLocalNetUserWlanId=bsnLocalNetUserWlanId, bsnSignatureAttackPreced=bsnSignatureAttackPreced, bsnLinkTestLocalRSSI=bsnLinkTestLocalRSSI, bsnAPIfRSSILevel=bsnAPIfRSSILevel, bsnMobileStationRssiDataTable=bsnMobileStationRssiDataTable, bsnDot11EssStaticWEPKeyIndex=bsnDot11EssStaticWEPKeyIndex, bsnTrustedApEntryExpirationTimeout=bsnTrustedApEntryExpirationTimeout, bsnWrasDot11bPeerMacAddress=bsnWrasDot11bPeerMacAddress, bsnRadiusAuthClientTimeouts=bsnRadiusAuthClientTimeouts, bsnMobileStationPacketsReceived=bsnMobileStationPacketsReceived, bsnWrasIpsecCertName=bsnWrasIpsecCertName, bsnAPIfRxNeighborsTable=bsnAPIfRxNeighborsTable, bsnDuplicateIpTrapClear=bsnDuplicateIpTrapClear, bsnDot11EssWPAAuthKeyMgmtMode=bsnDot11EssWPAAuthKeyMgmtMode, bsnRogueClientBSSID=bsnRogueClientBSSID, bsnTotalCommunicationErrors=bsnTotalCommunicationErrors, bsnRrmDot11bForeignInterferenceThreshold=bsnRrmDot11bForeignInterferenceThreshold, bsnWatchListClientKey=bsnWatchListClientKey, bsnPingTestSendCount=bsnPingTestSendCount, bsnGlobalDot11aDTPCSupport=bsnGlobalDot11aDTPCSupport, bsnDot11EssVpnIkeLifetime=bsnDot11EssVpnIkeLifetime, bsnTotalClientHandoffAsLocal=bsnTotalClientHandoffAsLocal, bsnDot11EssIpsecPassthruSecurity=bsnDot11EssIpsecPassthruSecurity, bsnRadiusAccServerIPSecIKEPhase1=bsnRadiusAccServerIPSecIKEPhase1, bsnMobileStationRssiDataApMacAddress=bsnMobileStationRssiDataApMacAddress, bsnAPIfWlanOverrideTable=bsnAPIfWlanOverrideTable, bsnRrmDot11aForeignInterferenceThreshold=bsnRrmDot11aForeignInterferenceThreshold, bsnGlobalDot11bCFPollable=bsnGlobalDot11bCFPollable, bsnCustomSignatureDescription=bsnCustomSignatureDescription, bsnNoiseBeforeChannelUpdate=bsnNoiseBeforeChannelUpdate, bsnTagTable=bsnTagTable, bsnMaxRogueCount=bsnMaxRogueCount, bsnAPIfNoiseChannelNo=bsnAPIfNoiseChannelNo, bsnAclRuleIndex=bsnAclRuleIndex, bsnAPNameTrapVariable=bsnAPNameTrapVariable, bsnMobilityAnchorsEntry=bsnMobilityAnchorsEntry, bsnDot11EssQualityOfService=bsnDot11EssQualityOfService, bsnRrmDot11aMobileMinExceptionLevel=bsnRrmDot11aMobileMinExceptionLevel, bsnRadiusAuthClientPendingRequests=bsnRadiusAuthClientPendingRequests, invalidRadioTrap=invalidRadioTrap, bsnGlobalDot11bCFPPeriod=bsnGlobalDot11bCFPPeriod, bsnGlobalDot11aPicoCellMode=bsnGlobalDot11aPicoCellMode, bsnCustomSignaturePrecedence=bsnCustomSignaturePrecedence, bsnDot11EssIPv6Bridging=bsnDot11EssIPv6Bridging, bsnBlackListClientDescription=bsnBlackListClientDescription, bsnAPIfThroughputThreshold=bsnAPIfThroughputThreshold, bsnGlobalDot11bRTSThreshold=bsnGlobalDot11bRTSThreshold, bsnTrapControl=bsnTrapControl, bsnRogueAPAirespaceAPSlotId=bsnRogueAPAirespaceAPSlotId, bsnMeshNeighLinkSnr=bsnMeshNeighLinkSnr, bsnDot11QosProfileName=bsnDot11QosProfileName, bsnMobilityGroupMemberMacAddress=bsnMobilityGroupMemberMacAddress, bsnMobileStationBytesSent=bsnMobileStationBytesSent, bsnSignatureConfig=bsnSignatureConfig, bsnRfIdTagConfig=bsnRfIdTagConfig, bsnRogueClientAirespaceAPSNR=bsnRogueClientAirespaceAPSNR, bsnAPTrapControlMask=bsnAPTrapControlMask, bsnRadarChannelCleared=bsnRadarChannelCleared, bsnExternalPolicyServerAclName=bsnExternalPolicyServerAclName, bsnDot11StationBlacklisted=bsnDot11StationBlacklisted, bsnAclRowStatus=bsnAclRowStatus, bsnClearTrapVariable=bsnClearTrapVariable, bsnBlackListClientTable=bsnBlackListClientTable, bsnAPAssociated=bsnAPAssociated, bsnDot11EssWPAEncryptionType=bsnDot11EssWPAEncryptionType, bsnGlobalDot11bNetworkStatus=bsnGlobalDot11bNetworkStatus, bsnAPPrimaryMwarName=bsnAPPrimaryMwarName, bsnRogueClientChannelNumber=bsnRogueClientChannelNumber, bsnStandardSignatureInterval=bsnStandardSignatureInterval, bsnAPUp=bsnAPUp, bsnGlobalDot11bCFPollRequest=bsnGlobalDot11bCFPollRequest, bsnDot11EssRSNWPACompatibilityMode=bsnDot11EssRSNWPACompatibilityMode, bsnLinkTestTable=bsnLinkTestTable, bsnRadiusAuthCacheCredentialsLocally=bsnRadiusAuthCacheCredentialsLocally, bsnSystemTimezoneDelta=bsnSystemTimezoneDelta, bsnGlobalDot11aPhy=bsnGlobalDot11aPhy, bsnMacFilterAddress=bsnMacFilterAddress, bsnGlobalDot11bMaxTransmitMSDULifetime=bsnGlobalDot11bMaxTransmitMSDULifetime, bsnMobileStationDeleteAction=bsnMobileStationDeleteAction, bsnRadiosExceedLicenseCount=bsnRadiosExceedLicenseCount, bsnTotalHandoffRequestsIgnored=bsnTotalHandoffRequestsIgnored, bsnAuthFailureUserType=bsnAuthFailureUserType, bsnAPStaticIPAddress=bsnAPStaticIPAddress, bsnMobilityGroupMemberGroupName=bsnMobilityGroupMemberGroupName, bsnAPDot3MacAddress=bsnAPDot3MacAddress, bsnDot11Ess8021xEncryptionType=bsnDot11Ess8021xEncryptionType, bsnMobileStationPacketsSent=bsnMobileStationPacketsSent, bsnRogueClientAirespaceAPName=bsnRogueClientAirespaceAPName, bsnRogueAPType=bsnRogueAPType, bsnAPRadioCardRxFailureClear=bsnAPRadioCardRxFailureClear, bsnDot11EssSecurityAuthType=bsnDot11EssSecurityAuthType, bsnAPMonitorOnlyMode=bsnAPMonitorOnlyMode, bsnAPAuthorizationTable=bsnAPAuthorizationTable, bsnGlobalDot11bMaxReceiveLifetime=bsnGlobalDot11bMaxReceiveLifetime, bsnAPIfSmtParamTable=bsnAPIfSmtParamTable, bsnAPIfPhyChannelNumber=bsnAPIfPhyChannelNumber, bsnRadiusAccClientPendingRequests=bsnRadiusAccClientPendingRequests, bsnMobileStationReasonCode=bsnMobileStationReasonCode, bsnMeshNodeDataRate=bsnMeshNodeDataRate, bsnDot11EssAdminStatus=bsnDot11EssAdminStatus, bsnAPIfPhyAntennaOptions=bsnAPIfPhyAntennaOptions, bsnRogueClientDot11MacAddress=bsnRogueClientDot11MacAddress, bsnNetworkType=bsnNetworkType, bsnExcessive80211AssocFailures=bsnExcessive80211AssocFailures, bsnTagRssiDataApName=bsnTagRssiDataApName, bsnRrmDot11aThroughputThreshold=bsnRrmDot11aThroughputThreshold, bsnRogueClientAirespaceAPRSSI=bsnRogueClientAirespaceAPRSSI, bsnRrmDot11bMobilesThreshold=bsnRrmDot11bMobilesThreshold, bsnRogueAPContainmentChannelCount=bsnRogueAPContainmentChannelCount, bsnRadiusAuthClientAccessAccepts=bsnRadiusAuthClientAccessAccepts, bsnRadiusAuthServerTable=bsnRadiusAuthServerTable, bsnGlobalDot11bDataRate9Mhz=bsnGlobalDot11bDataRate9Mhz, bsnDot11EssWebSecurity=bsnDot11EssWebSecurity, bsnMeshNeighAdjustedEase=bsnMeshNeighAdjustedEase, bsnImpersonatedAPMacAddr=bsnImpersonatedAPMacAddr, bsnApGroup=bsnApGroup, bsnRadiusAuthServerStatsTable=bsnRadiusAuthServerStatsTable, bsnRadiusAuthServerInetAddress=bsnRadiusAuthServerInetAddress, bsnGlobalDot11bDataRate1Mhz=bsnGlobalDot11bDataRate1Mhz, bsnAPIfDot11NumberofChannels=bsnAPIfDot11NumberofChannels, bsnGlobalDot11aDataRate48Mhz=bsnGlobalDot11aDataRate48Mhz, bsnDot11QosMaxRFUsagePerAP=bsnDot11QosMaxRFUsagePerAP, bsnRogueAPTotalDetectingAPs=bsnRogueAPTotalDetectingAPs, bsnGlobalDot11PrivacyOptionImplemented=bsnGlobalDot11PrivacyOptionImplemented, bsnTotalHandoffRequestsDenied=bsnTotalHandoffRequestsDenied, bsnAPIsStaticIP=bsnAPIsStaticIP, bsnRFMobilityDomainName=bsnRFMobilityDomainName, bsnAPGroupsVlanMappingSsid=bsnAPGroupsVlanMappingSsid, bsnDot11Ess80211ePolicySetting=bsnDot11Ess80211ePolicySetting, bsnMobileStationPerRadioPerVapEntry=bsnMobileStationPerRadioPerVapEntry, bsnRogueLocationDiscoveryProtocol=bsnRogueLocationDiscoveryProtocol, bsnAPIfDot11TIThreshold=bsnAPIfDot11TIThreshold, bsnAPContainedAsARogue=bsnAPContainedAsARogue, bsnUserName=bsnUserName, bsnThirdPartyAPEntry=bsnThirdPartyAPEntry, bsnMobileStationRSSI=bsnMobileStationRSSI, bsnGlobalDot11aDataRate6Mhz=bsnGlobalDot11aDataRate6Mhz, bsnAPGateway=bsnAPGateway, bsnRADIUSServerTrapEnable=bsnRADIUSServerTrapEnable, bsnRadiusAuthClientAccessRejects=bsnRadiusAuthClientAccessRejects, bsnRadiusAuthServerIndex=bsnRadiusAuthServerIndex, bsnAPNoiseProfileFailed=bsnAPNoiseProfileFailed, bsnDot11EssVpnQotdServerAddress=bsnDot11EssVpnQotdServerAddress, bsnMacFilterInterfaceName=bsnMacFilterInterfaceName, bsnIkeTotalInitNoResponses=bsnIkeTotalInitNoResponses, bsnMobileStationSnr=bsnMobileStationSnr, bsnAPInterferenceProfileFailed=bsnAPInterferenceProfileFailed, bsnIPTheftORReuse=bsnIPTheftORReuse, bsnAPIfDot11RetryCount=bsnAPIfDot11RetryCount, bsnAPInterferenceProfileUpdatedToPass=bsnAPInterferenceProfileUpdatedToPass, bsnTotalHandoffRequestsReceived=bsnTotalHandoffRequestsReceived, bsnDot11QosBurstDataRate=bsnDot11QosBurstDataRate, bsnAPPortNumberTrapVariable=bsnAPPortNumberTrapVariable, bsnRrmDot11aChannelMonitorList=bsnRrmDot11aChannelMonitorList, bsnRrmDot11bGlobalAutomaticGrouping=bsnRrmDot11bGlobalAutomaticGrouping, bsnAPAuthorizationEntry=bsnAPAuthorizationEntry, bsnMeshNodeBackhaulRAP=bsnMeshNodeBackhaulRAP, bsnMobileStationRssiDataApIfSlotId=bsnMobileStationRssiDataApIfSlotId, bsnMobileStationIpAddress=bsnMobileStationIpAddress, bsnTotalAnchorRequestsGranted=bsnTotalAnchorRequestsGranted, bsnMeshNodeGroup=bsnMeshNodeGroup, bsnExcessive80211AuthFailures=bsnExcessive80211AuthFailures, bsnExternalPolicyServerAdminStatus=bsnExternalPolicyServerAdminStatus, bsnRadiusAuthServerMgmtUserConfig=bsnRadiusAuthServerMgmtUserConfig, bsnAPIfMobilesThreshold=bsnAPIfMobilesThreshold, bsnDot11EssWPAAuthPresharedKey=bsnDot11EssWPAAuthPresharedKey)
mibBuilder.exportSymbols("AIRESPACE-WIRELESS-MIB", bsnUserPassword=bsnUserPassword, bsnUtilityGroup=bsnUtilityGroup, bsnAPGroupsVlanRowStatus=bsnAPGroupsVlanRowStatus, bsnDot11EssRSNAuthPresharedKey=bsnDot11EssRSNAuthPresharedKey, bsnRfIdTagStatus=bsnRfIdTagStatus, bsnRogueClientTable=bsnRogueClientTable, bsnRemoteUdpPort=bsnRemoteUdpPort, bsnAPRadioCardTxFailure=bsnAPRadioCardTxFailure, bsnRogueAPState=bsnRogueAPState, bsnRfIdTagDataTimeout=bsnRfIdTagDataTimeout, bsnAPIfRecommendedChannelNumber=bsnAPIfRecommendedChannelNumber, bsnAPIfInterferencePower=bsnAPIfInterferencePower, bsnRadiusAccServerIPSecIKELifetime=bsnRadiusAccServerIPSecIKELifetime, bsnCustomSignatureState=bsnCustomSignatureState, bsnAclRuleStartDestinationPort=bsnAclRuleStartDestinationPort, bsnAPIfDot11MacParamsConfigType=bsnAPIfDot11MacParamsConfigType, bsnDot11EssBroadcastSsid=bsnDot11EssBroadcastSsid, bsnDot11EssIndex=bsnDot11EssIndex, bsnMobileStationPolicyManagerState=bsnMobileStationPolicyManagerState, bsnMobileStationByIpEntry=bsnMobileStationByIpEntry, bsnAPIfDot11CountersEntry=bsnAPIfDot11CountersEntry, bsnTagRssiDataSnr=bsnTagRssiDataSnr, bsnInterferenceBeforeChannelUpdate=bsnInterferenceBeforeChannelUpdate, bsnGlobalDot11bDynamicTransmitPowerControl=bsnGlobalDot11bDynamicTransmitPowerControl, bsnAPIfRxNeighborChannel=bsnAPIfRxNeighborChannel, bsnMobileStationMobilityStatus=bsnMobileStationMobilityStatus, bsnDot11StationTrapControlMask=bsnDot11StationTrapControlMask, bsnTotalAnchorGrantReceived=bsnTotalAnchorGrantReceived, bsnAPIfWlanOverrideSsid=bsnAPIfWlanOverrideSsid, bsnAPIfRxNeighborRSSI=bsnAPIfRxNeighborRSSI, bsnRogueAPContainmentChannels=bsnRogueAPContainmentChannels, bsnBlackListClientRowStatus=bsnBlackListClientRowStatus, bsnDot11EssRSNAuthKeyMgmtMode=bsnDot11EssRSNAuthKeyMgmtMode, bsnAPIfStationSNRCoverageIndex=bsnAPIfStationSNRCoverageIndex, bsnMeshNeighLastUpdate=bsnMeshNeighLastUpdate, bsnAPIfStationRSSICoverageInfoEntry=bsnAPIfStationRSSICoverageInfoEntry, bsnAclNewRuleIndex=bsnAclNewRuleIndex, bsnTrustedApEncryptionRequired=bsnTrustedApEncryptionRequired, bsnRrmDot11bGroupLeaderMacAddr=bsnRrmDot11bGroupLeaderMacAddr, bsnAPIfStationCountOnRSSI=bsnAPIfStationCountOnRSSI, bsnUserRowStatus=bsnUserRowStatus, bsnConfigSaved=bsnConfigSaved, bsnMeshNeighType=bsnMeshNeighType, bsnTagBytesReceived=bsnTagBytesReceived, bsnBlackListClientMacAddress=bsnBlackListClientMacAddress, bsnMobility=bsnMobility, bsnAPBridgingSupport=bsnAPBridgingSupport, bsnMeshNeighRxParent=bsnMeshNeighRxParent, bsnAPIfDot11MulticastReceivedFrameCount=bsnAPIfDot11MulticastReceivedFrameCount, bsnAutoContainAdhocNetworks=bsnAutoContainAdhocNetworks, bsnAPNeighborAuthConfig=bsnAPNeighborAuthConfig, bsnStandardSignaturePatternTable=bsnStandardSignaturePatternTable, bsnDot11EssVpnPassthruGateway=bsnDot11EssVpnPassthruGateway, bsnWatchListClientType=bsnWatchListClientType, bsnDot11EssVpnIkePhase1Mode=bsnDot11EssVpnIkePhase1Mode, bsnMeshNodeNeighTimeout=bsnMeshNodeNeighTimeout, bsnGlobalDot11Config=bsnGlobalDot11Config, bsnDot11EssWmePolicySetting=bsnDot11EssWmePolicySetting, bsnGlobalDot11aNetworkStatus=bsnGlobalDot11aNetworkStatus, bsnGlobalDot11bConfig=bsnGlobalDot11bConfig, bsnAdhocRogueAutoContained=bsnAdhocRogueAutoContained, bsnAPIfProfileThresholdConfigTable=bsnAPIfProfileThresholdConfigTable, bsnRogueAPChannelWidth=bsnRogueAPChannelWidth, bsnMemberTotalAnchoredClients=bsnMemberTotalAnchoredClients, bsnLicenseKeyTrapVariable=bsnLicenseKeyTrapVariable, bsnExternalPolicyServerPortNumber=bsnExternalPolicyServerPortNumber, bsnMobileStationSampleTime=bsnMobileStationSampleTime, bsnAPIfRecommendedFragmentationThreshold=bsnAPIfRecommendedFragmentationThreshold, bsnSignatureAttackerMacAddress=bsnSignatureAttackerMacAddress, bsnGlobalDot11bShortPreamble=bsnGlobalDot11bShortPreamble, bsnDot11EssRSNSecurity=bsnDot11EssRSNSecurity, bsnTrap=bsnTrap, bsnDot11EssWPASecurity=bsnDot11EssWPASecurity, bsnGlobalDot11bInputsForDCA=bsnGlobalDot11bInputsForDCA, bsnAPIfDot11PhyTxPowerTable=bsnAPIfDot11PhyTxPowerTable, bsnMeshNodeAPType=bsnMeshNodeAPType, bsnRogueAPDetectingAPName=bsnRogueAPDetectingAPName, bsnMeshNodeBlacklistPackets=bsnMeshNodeBlacklistPackets, bsnWrasIpsecCACertificate=bsnWrasIpsecCACertificate, bsnRogueAPAirespaceAPTable=bsnRogueAPAirespaceAPTable, bsnWrasIpsecCertificateUpdate=bsnWrasIpsecCertificateUpdate, bsnRrmDot11bGroupLastUpdateTime=bsnRrmDot11bGroupLastUpdateTime, bsnStationReasonCode=bsnStationReasonCode, bsnMeshNodeParentChanges=bsnMeshNodeParentChanges, bsnExcessiveWebAuthFailures=bsnExcessiveWebAuthFailures, bsnIpsec=bsnIpsec, bsnRrmDot11bCoverageMeasurementInterval=bsnRrmDot11bCoverageMeasurementInterval, bsnMeshNeighState=bsnMeshNeighState, bsnRadiusAuthClientAccessRequests=bsnRadiusAuthClientAccessRequests, bsnRrmDot11aSignalMeasurementInterval=bsnRrmDot11aSignalMeasurementInterval, bsnPingTestIPAddress=bsnPingTestIPAddress, bsnRadiusAuthClientRoundTripTime=bsnRadiusAuthClientRoundTripTime, bsnAPGroupsVlanConfig=bsnAPGroupsVlanConfig, bsnRogueAPTrapEnable=bsnRogueAPTrapEnable, bsnGlobalDot11bDynamicChannelUpdateInterval=bsnGlobalDot11bDynamicChannelUpdateInterval, bsnAPIfCellSiteConfigId=bsnAPIfCellSiteConfigId, bsnTrustedApIsMissing=bsnTrustedApIsMissing, bsnPingTestMinTimeInterval=bsnPingTestMinTimeInterval, bsnUsersEntry=bsnUsersEntry, bsnAPIfDot11FailedCount=bsnAPIfDot11FailedCount, bsnDot11EssBlacklistingCapability=bsnDot11EssBlacklistingCapability, bsnRadiusAccServerRetransmitTimeout=bsnRadiusAccServerRetransmitTimeout, bsnAPGroupsVlanMappingRowStatus=bsnAPGroupsVlanMappingRowStatus, bsnSignatureAttackFrequency=bsnSignatureAttackFrequency, bsnRadiusAccServerStatsEntry=bsnRadiusAccServerStatsEntry, bsnGlobalDot11aPowerUpdateCmdInvoke=bsnGlobalDot11aPowerUpdateCmdInvoke, bsnBridgingZeroTouchConfig=bsnBridgingZeroTouchConfig, bsnApMaxRogueCountClear=bsnApMaxRogueCountClear, bsnRogueClientLastHeard=bsnRogueClientLastHeard, bsnRrmDot11bNoiseMeasurementInterval=bsnRrmDot11bNoiseMeasurementInterval, bsnAPOperationStatus=bsnAPOperationStatus, bsnMobileStationByUsernameTable=bsnMobileStationByUsernameTable, bsnSignatureDescription=bsnSignatureDescription, bsnMaximumNumberOfConcurrentLogins=bsnMaximumNumberOfConcurrentLogins, bsnRadiusAuthServerAddress=bsnRadiusAuthServerAddress, bsnGlobalDot11MultiDomainCapabilityEnabled=bsnGlobalDot11MultiDomainCapabilityEnabled, bsnRogueClientFirstReported=bsnRogueClientFirstReported, bsnGlobalDot11bDataRate5AndHalfMhz=bsnGlobalDot11bDataRate5AndHalfMhz, bsnGlobalDot11LoadBalancing=bsnGlobalDot11LoadBalancing, bsnSuiteRespondFailures=bsnSuiteRespondFailures, bsnAclRuleEndDestinationPort=bsnAclRuleEndDestinationPort, bsnGlobalDot11aChannelUpdateCmdInvoke=bsnGlobalDot11aChannelUpdateCmdInvoke, bsnGlobalDot11bDataRate36Mhz=bsnGlobalDot11bDataRate36Mhz, bsnClientRssi=bsnClientRssi, bsnExternalPolicyServerRowStatus=bsnExternalPolicyServerRowStatus, bsnGlobalDot11aDataRate12Mhz=bsnGlobalDot11aDataRate12Mhz, bsnRadiusAuthServerEntry=bsnRadiusAuthServerEntry, bsnAPIfDot11MacMaxReceiveLifetime=bsnAPIfDot11MacMaxReceiveLifetime, bsnRxMulticastQueueFull=bsnRxMulticastQueueFull, bsnAPIPAddressFallback=bsnAPIPAddressFallback, bsnAPIfDot11CountryString=bsnAPIfDot11CountryString, bsnRogueClientRadioType=bsnRogueClientRadioType, bsnMaxRogueCountClear=bsnMaxRogueCountClear, bsnAclRuleAction=bsnAclRuleAction, bsnTotalAnchorRequestsSent=bsnTotalAnchorRequestsSent, bsnGlobalDot11bPhy=bsnGlobalDot11bPhy, bsnGlobalDot11aChannelAgilityEnabled=bsnGlobalDot11aChannelAgilityEnabled, bsnAPIfRFUtilizationThreshold=bsnAPIfRFUtilizationThreshold, bsnRadiusAuthServerKeyWrapMACKkey=bsnRadiusAuthServerKeyWrapMACKkey, bsnExternalPolicyServerConnectionStatus=bsnExternalPolicyServerConnectionStatus, bsnStandardSignatureTable=bsnStandardSignatureTable, bsnDot11EssMacFiltering=bsnDot11EssMacFiltering, bsnAPType=bsnAPType, bsnMeshNeighMacAddress=bsnMeshNeighMacAddress, bsnUpdateSystemTime=bsnUpdateSystemTime, bsnGlobalDot11bFastRoamingMode=bsnGlobalDot11bFastRoamingMode, bsnMeshNodeRxNeighReq=bsnMeshNodeRxNeighReq, bsnMeshNeighPoorSnr=bsnMeshNeighPoorSnr, bsnAPGroupsVlanFeature=bsnAPGroupsVlanFeature, bsnCustomSignatureMacFreq=bsnCustomSignatureMacFreq, bsnDot11EssRSNAllowTKIPClients=bsnDot11EssRSNAllowTKIPClients, bsnMeshNodeMalformedNeighPackets=bsnMeshNodeMalformedNeighPackets, bsnUserInterfaceName=bsnUserInterfaceName, bsnWrasObsGroupRev1=bsnWrasObsGroupRev1, bsnDot11EssDhcpRequired=bsnDot11EssDhcpRequired, bsnAlertIfTrustedApMissing=bsnAlertIfTrustedApMissing, bsnAuthFailureUserName=bsnAuthFailureUserName, bsnRrmDot11bForeignNoiseThreshold=bsnRrmDot11bForeignNoiseThreshold, bsnAPSerialNumber=bsnAPSerialNumber, bsnAPIfPhyAntennaType=bsnAPIfPhyAntennaType, bsnAclRuleDscp=bsnAclRuleDscp, bsnAPGroupsVlanDescription=bsnAPGroupsVlanDescription, bsnWrasCompliance=bsnWrasCompliance, bsnMacFilterRowStatus=bsnMacFilterRowStatus, bsnRadiusAuthServerInetAddressType=bsnRadiusAuthServerInetAddressType, bsnAPIfPhyTxPowerLevel=bsnAPIfPhyTxPowerLevel, bsnAPIfDot11MultiDomainCapabilityImplemented=bsnAPIfDot11MultiDomainCapabilityImplemented, bsnMemberCurrentAnchoredClients=bsnMemberCurrentAnchoredClients, bsnGlobalDot11h=bsnGlobalDot11h, bsnGlobalDot11bFastRoamingVoipPercentage=bsnGlobalDot11bFastRoamingVoipPercentage, bsnAclName=bsnAclName, bsnMeshNodeTxNeighReq=bsnMeshNodeTxNeighReq, bsnMemberTotalExportedClients=bsnMemberTotalExportedClients, bsnGlobalDot11aRxSopThreshold=bsnGlobalDot11aRxSopThreshold, bsnRogueAPSsid=bsnRogueAPSsid, bsnAPIfDot11MacFragmentationThreshold=bsnAPIfDot11MacFragmentationThreshold, bsnRrmDot11bLoadMeasurementInterval=bsnRrmDot11bLoadMeasurementInterval, bsnAPFunctionalityDisabled=bsnAPFunctionalityDisabled, bsnMobileStationSsid=bsnMobileStationSsid, bsnStandardSignatureFrameType=bsnStandardSignatureFrameType, bsnAPIfAntennaGain=bsnAPIfAntennaGain, bsnLinkTestRowStatus=bsnLinkTestRowStatus, bsnAPBootVersion=bsnAPBootVersion, bsnWireless=bsnWireless, bsnGlobalDot11bShortPreambleOptionImplemented=bsnGlobalDot11bShortPreambleOptionImplemented, bsnDot11EssVpnEncrTransform=bsnDot11EssVpnEncrTransform, bsnAPIfInterferenceProfileState=bsnAPIfInterferenceProfileState, bsnMemberTotalHandoffErrors=bsnMemberTotalHandoffErrors, bsnPOEControllerFailure=bsnPOEControllerFailure, bsnTotalHandoffDeniesReceived=bsnTotalHandoffDeniesReceived, bsnMobilityGroupMemberRowStatus=bsnMobilityGroupMemberRowStatus, bsnRrmDot11bRFUtilizationThreshold=bsnRrmDot11bRFUtilizationThreshold, bsnMobileStationByUsernameEntry=bsnMobileStationByUsernameEntry, bsnMobileStationApMode=bsnMobileStationApMode, bsnWrasTrap=bsnWrasTrap, bsnGlobalDot11bChannelAgilityEnabled=bsnGlobalDot11bChannelAgilityEnabled, bsnRogueClientAirespaceAPSlotId=bsnRogueClientAirespaceAPSlotId, bsnLinkTestReceivedPktCount=bsnLinkTestReceivedPktCount, bsnAPSoftwareVersion=bsnAPSoftwareVersion, bsnSystemClockTime=bsnSystemClockTime, bsnAPIfDot11MaximumTransmitPowerLevel=bsnAPIfDot11MaximumTransmitPowerLevel, bsnStandardSignaturePatternOffSetStart=bsnStandardSignaturePatternOffSetStart, bsnBridgingSharedSecretKey=bsnBridgingSharedSecretKey, bsnRadiusAccServerInetAddressType=bsnRadiusAccServerInetAddressType, bsnCustomSignaturePatternEntry=bsnCustomSignaturePatternEntry, bsnAAARadiusCompatibilityMode=bsnAAARadiusCompatibilityMode, bsnDot11EssWepAllowSharedKeyAuth=bsnDot11EssWepAllowSharedKeyAuth, bsn80211SecurityTrapControlMask=bsn80211SecurityTrapControlMask, bsnWrasIpsecCertPassword=bsnWrasIpsecCertPassword, bsnRogueAPDot11MacAddr=bsnRogueAPDot11MacAddr, bsnAPLoadProfileFailed=bsnAPLoadProfileFailed, bsnGroupDirectoryDicoveryType=bsnGroupDirectoryDicoveryType, bsnAPIfPhyAntennaIndex=bsnAPIfPhyAntennaIndex, bsnUserType=bsnUserType, bsnCustomSignatureFrameType=bsnCustomSignatureFrameType, bsnGlobalDot11bFirstChannelNumber=bsnGlobalDot11bFirstChannelNumber, bsnCustomSignaturePatternString=bsnCustomSignaturePatternString, bsnAPIfChannelNoiseInfoEntry=bsnAPIfChannelNoiseInfoEntry, bsnGlobalDot11aFastRoamingVoipPercentage=bsnGlobalDot11aFastRoamingVoipPercentage)

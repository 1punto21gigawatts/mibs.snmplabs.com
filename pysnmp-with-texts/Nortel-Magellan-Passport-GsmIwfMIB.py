#
# PySNMP MIB module Nortel-Magellan-Passport-GsmIwfMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-GsmIwfMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:27:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
Gauge32, Counter32, RowStatus, DisplayString, RowPointer, StorageType, Integer32, Unsigned32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Gauge32", "Counter32", "RowStatus", "DisplayString", "RowPointer", "StorageType", "Integer32", "Unsigned32")
Link, AsciiString, FixedPoint2, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "Link", "AsciiString", "FixedPoint2", "NonReplicated")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, MibIdentifier, Integer32, Bits, iso, ModuleIdentity, ObjectIdentity, Unsigned32, Counter64, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "MibIdentifier", "Integer32", "Bits", "iso", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "Counter64", "NotificationType", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
gsmIwfMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129))
gsmCs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127))
gsmCsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1), )
if mibBuilder.loadTexts: gsmCsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCs components.')
gsmCsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"))
if mibBuilder.loadTexts: gsmCsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRowStatusEntry.setDescription('A single entry in the table represents a single gsmCs component.')
gsmCsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCs components. These components can be added and deleted.')
gsmCsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStorageType.setDescription('This variable represents the storage type value for the gsmCs tables.')
gsmCsTrunkGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191)))
if mibBuilder.loadTexts: gsmCsTrunkGrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsTrunkGrpIndex.setDescription('This variable represents the index for the gsmCs tables.')
gsmCsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100), )
if mibBuilder.loadTexts: gsmCsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsProvTable.setDescription('This group contains general provisioning data for the GsmIwfCallServer that does not fit within other provisioning groups.')
gsmCsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"))
if mibBuilder.loadTexts: gsmCsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsProvEntry.setDescription('An entry in the gsmCsProvTable.')
gsmCsCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, this attribute specifies the name of the trunk group at the Mobile Services-switching Center (MSC) configured for this GsmIwfCallServer plus any other commentary information.')
gsmCsMscIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsMscIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsMscIpAddress.setDescription('This attribute specifies the Internetwork Protocol (IP) Address of the Mobile Services-switching Center (MSC) Control Module (CM) that is permitted to set up GSM InterWorking Function (IWF) calls using this GsmIwfCallServer. This address must be specified in order for this GsmIwfCallServer to provide service. If call setups are attempted from an MSC which does not have this address, those calls are rejected. The callsRequested statistic of this GsmIwfCallServer is incremented, but the callsSetup statistic of this GsmIwfCallServer is not, when call setup attempts are rejected. Also, at the MSC, appropriate call failure logs are generated.')
gsmCsVirtualRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100, 1, 4), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsVirtualRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsVirtualRouterName.setDescription('This attribute specifies the VirtualRouter that this GsmIwfCallServer uses to transmit signaling messages to and receive signaling messages from the Mobile Services-switching Center (MSC) that utilizes this GsmIwfCallServer.')
gsmCsVoiceLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 100, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aLaw", 0), ("muLaw", 1))).clone('aLaw')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsVoiceLaw.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsVoiceLaw.setDescription('This attribute specifies the voice law to be established for the IWF to Public Switched Telephone Network (PSTN) modem link for calls established by this GsmIwfCallServer. Valid values are: aLaw, a protocol for encoding voice-band audio, Pulse Code Modulation (PCM). muLaw, a protocol for encoding voice-band audio, PCM. Note that this value must match the voice law used at the Mobile Services-switching Center (MSC) connected to this GsmIwfCallServer.')
gsmCsCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 103), )
if mibBuilder.loadTexts: gsmCsCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
gsmCsCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 103, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"))
if mibBuilder.loadTexts: gsmCsCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCidDataEntry.setDescription('An entry in the gsmCsCidDataTable.')
gsmCsCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 103, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
gsmCsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 104), )
if mibBuilder.loadTexts: gsmCsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gsmCsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"))
if mibBuilder.loadTexts: gsmCsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStateEntry.setDescription('An entry in the gsmCsStateTable.')
gsmCsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gsmCsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gsmCsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gsmCsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121), )
if mibBuilder.loadTexts: gsmCsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStatsTable.setDescription('This group contains operational attributes that measure the performance of this particular GsmIwfCallServer.')
gsmCsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"))
if mibBuilder.loadTexts: gsmCsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStatsEntry.setDescription('An entry in the gsmCsStatsTable.')
gsmCsCurrentCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCurrentCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCurrentCalls.setDescription('This attribute indicates the number of active calls currently serviced by this particular GsmIwfCallServer.')
gsmCsCallsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCallsRequested.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCallsRequested.setDescription('This attribute counts the number of IWF call setup requests received at this particular GsmIwfCallServer from the Mobile Services- switching Center (MSC). The counter wraps when it exceeds the maximum value.')
gsmCsCallsSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCallsSetup.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCallsSetup.setDescription('This attribute counts the number of IWF calls successfully setup by this particular GsmIwfCallServer. A call is considered setup when the IWF-Setup-Request message is received, indicating a request for a data communications service, and the IWF has successfully allocated the necessary resources to fulfill the request. The counter wraps when it exceeds the maximum value.')
gsmCsCallsActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCallsActivated.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCallsActivated.setDescription('This attribute counts the number of IWF calls successfully activated by this particular GsmIwfCallServer. A call is considered activated when the IWF receives an IWF-Activate-Request, indicating that the call parties are connected and that data communications must begin. The counter wraps when it exceeds the maximum value.')
gsmCsCallsReleasedNormal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCallsReleasedNormal.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCallsReleasedNormal.setDescription('This attribute counts the number of IWF calls that have completed successfully on this particular GsmIwfCallServer. The counter wraps when it exceeds the maximum value.')
gsmCsCallsReleasedAbnormal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsCallsReleasedAbnormal.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsCallsReleasedAbnormal.setDescription('This attribute counts the number of IWF calls that have been released due to error conditions at this particular GsmIwfCallServer or one if its GsmIwfBearerChannels. The counter wraps when it exceeds the maximum value.')
gsmCsChannelConfigChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsChannelConfigChanges.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsChannelConfigChanges.setDescription('This attribute counts the number of channel configuration requests from the Mobile-services Switching Center (MSC) that have been received at this GsmIwfCallServer and have resulted in successful responses. The counter wraps when it exceeds the maximum value.')
gsmCsChannelModeModifyRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsChannelModeModifyRequests.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsChannelModeModifyRequests.setDescription('This attribute counts the number of channel mode modify requests that have been generated by fax calls serviced by this particular GsmIwfCallServer. The counter wraps when it exceeds the maximum value.')
gsmCsStatusMessagesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsStatusMessagesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsStatusMessagesRx.setDescription('This attribute counts the number of status messages received from the Mobile Services-switching Center (MSC). The counter wraps when it exceeds the maximum value.')
gsmCsErroredMipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 121, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsErroredMipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsErroredMipFrames.setDescription('This attribute counts the number of MSC/IWF Interface Protocol (MIP) messages received from the Mobile Services-switching Center (MSC) that were in error. The counter wraps when it exceeds the maximum value.')
gsmCsModem = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2))
gsmCsModemRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1), )
if mibBuilder.loadTexts: gsmCsModemRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsModem components.')
gsmCsModemRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsModemIndex"))
if mibBuilder.loadTexts: gsmCsModemRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemRowStatusEntry.setDescription('A single entry in the table represents a single gsmCsModem component.')
gsmCsModemRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsModemRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsModem components. These components cannot be added nor deleted.')
gsmCsModemComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsModemComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsModemStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsModemStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemStorageType.setDescription('This variable represents the storage type value for the gsmCsModem tables.')
gsmCsModemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6, 7, 8, 9))).clone(namedValues=NamedValues(("v17", 0), ("v21", 1), ("v22", 2), ("v22bis", 3), ("v23", 4), ("v27ter", 6), ("v29", 7), ("v32", 8), ("v32bis", 9))))
if mibBuilder.loadTexts: gsmCsModemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsModemIndex.setDescription('This variable represents the index for the gsmCsModem tables.')
gsmCsRlp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3))
gsmCsRlpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1), )
if mibBuilder.loadTexts: gsmCsRlpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsRlp components.')
gsmCsRlpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsRlpIndex"))
if mibBuilder.loadTexts: gsmCsRlpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpRowStatusEntry.setDescription('A single entry in the table represents a single gsmCsRlp component.')
gsmCsRlpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsRlpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsRlp components. These components cannot be added nor deleted.')
gsmCsRlpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsRlpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsRlpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsRlpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpStorageType.setDescription('This variable represents the storage type value for the gsmCsRlp tables.')
gsmCsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("half6kRate", 0), ("full6kRate", 1), ("full12kRate", 2), ("full14k5Rate", 3))))
if mibBuilder.loadTexts: gsmCsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpIndex.setDescription('This variable represents the index for the gsmCsRlp tables.')
gsmCsRlpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10), )
if mibBuilder.loadTexts: gsmCsRlpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpProvTable.setDescription('This group contains provisionable attributes for the Radio Link Protocol (RLP) parameters used for the call set up by this particular GsmIwfCallServer. Changes to these attributes do not effect existing calls.')
gsmCsRlpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsRlpIndex"))
if mibBuilder.loadTexts: gsmCsRlpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpProvEntry.setDescription('An entry in the gsmCsRlpProvTable.')
gsmCsRlpHighestVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpHighestVersion.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpHighestVersion.setDescription('This attribute specifies the highest version of the Radio Link Protocol (RLP) protocol supported on this GsmIwfCallServer. Valid values are: 0, Single-link basic version. 1, Single-link extended version (for example, extended by data compression). During the Exchange Information (XID) negotiation at the start of the call, both RLP entities (mobile station and IWF) can agree to use a particular RLP version. The IWF attempts to negotiate the value specified by this attribute. Note that if V.42bis data compression is be established between the mobile station and IWF, both entities must agree to use version 1 (or higher). The default value for highestVersion is 1 to enable support for V.42bis data compression. The negotiated value can be viewed in the component GsmIwfRlpOp attribute highestVersion. Changes to this attribute do not effect existing calls.')
gsmCsRlpIwfToMsWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61)).clone(61)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpIwfToMsWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpIwfToMsWindowSize.setDescription('This attribute specifies the maximum number of sequentially numbered Information (I) frames that may be outstanding (that is, unacknowledged) at any given time from the IWF to the mobile station. GSM specification 4.22 defines the range as 0 to 61. During the Exchange Information (XID) negotiation, both Radio Link Protocol (RLP) entities (mobile station and IWF) can agree to use a specific window size. The IWF attempts to negotiate to the value specified by this attribute. The negotiated value can be viewed in the component GsmIwfRlpOp attribute iwfToMsWindowSize. Changes to this attribute do not effect existing calls.')
gsmCsRlpMsToIwfWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61)).clone(61)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpMsToIwfWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpMsToIwfWindowSize.setDescription('This attribute specifies the maximum number of sequentially numbered Information (I) frames that may be outstanding (that is, unacknowledged) at any given time from the mobile station to IWF. GSM specification 4.22 defines the range as 0-61. During the Exchange Information (XID) negotiation, both Radio Link Protocol (RLP) entities (mobile station and IWF) can agree to use a specific window size. The IWF attempts to negotiate to the value specified by this attribute. The negotiated value can be viewed in the component GsmIwfRlpOp attribute msToIwfWindowSize. Changes to this attribute do not effect existing calls.')
gsmCsRlpT1AckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(380, 1020))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpT1AckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpT1AckTimer.setDescription('This attribute specifies the time in milliseconds within which an acknowledgment of a sent frame must be received. Once this timer expires, the transmitting Radio Link Protocol (RLP) entity shall assume that the frame was lost. During the Exchange Information (XID) negotiation, both RLP entities (mobile station and IWF) can agree to use specific value for this timer (T1). The IWF attempts to negotiate to the value specified by this attribute. The default value for t1AckTimer is 520 msec for the full14k5Rate instance of this component, 480 msec for full12kRate, 540 msec for full6kRate, and 780 msec for half6kRate. The negotiated value can be viewed in the component GsmIwfRlpOp attribute t1AckTimer. Changes to this attribute do not effect existing calls.')
gsmCsRlpT2AckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 79)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpT2AckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpT2AckDelayTimer.setDescription('This attribute specifies the maximum time in milliseconds the receiving Radio Link Protocol (RLP) entity shall wait before sending an acknowledgment for a received information frame. During the Exchange Information (XID) negotiation, both RLP entities (mobile station and IWF) can agree to use specific value for this timer (T2). The IWF attempts to negotiate to the value specified by this attribute. The negotiated value can be viewed in the component GsmIwfRlpOp attribute t2AckDelayTimer. Changes to this attribute do not effect existing calls.')
gsmCsRlpN2RetransmitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsRlpN2RetransmitCount.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsRlpN2RetransmitCount.setDescription('This attribute specifies the maximum number of times a Radio Link Protocol (RLP) entity shall retransmit an individual frame following the expiry of timer T1. During the Exchange Information (XID) negotiation, both RLP entities (mobile station and InterWorking Function (IWF)) can agree to use specific value for N2 (Retransmit Count). The IWF attempts to negotiate to the value specified by this attribute. The negotiated value can be viewed in the component GsmIwfRlpOp attribute n2RetransmitCount. Changes to this attribute do not effect existing calls.')
gsmCsFax = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4))
gsmCsFaxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1), )
if mibBuilder.loadTexts: gsmCsFaxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsFax components.')
gsmCsFaxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsFaxIndex"))
if mibBuilder.loadTexts: gsmCsFaxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxRowStatusEntry.setDescription('A single entry in the table represents a single gsmCsFax component.')
gsmCsFaxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsFaxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsFax components. These components cannot be added nor deleted.')
gsmCsFaxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsFaxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsFaxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsFaxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxStorageType.setDescription('This variable represents the storage type value for the gsmCsFax tables.')
gsmCsFaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmCsFaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxIndex.setDescription('This variable represents the index for the gsmCsFax tables.')
gsmCsFaxProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 10), )
if mibBuilder.loadTexts: gsmCsFaxProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxProvTable.setDescription('This group contains the provisionable attributes for the fascimile protocol (T.30 and GSM 03.45) for this particular GsmIwfCallServer. Changes to these attributes do not effect existing calls.')
gsmCsFaxProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsFaxIndex"))
if mibBuilder.loadTexts: gsmCsFaxProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxProvEntry.setDescription('An entry in the gsmCsFaxProvTable.')
gsmCsFaxT1CalledToneTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 4, 10, 1, 1), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(150, 300)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsFaxT1CalledToneTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsFaxT1CalledToneTimer.setDescription('This attribute specifies the delay to generate a Called (CED) tone at the IWF after the called station is connected to the line for mobile terminated calls. Changes to this attribute do not effect existing calls.')
gsmCsV42 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5))
gsmCsV42RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1), )
if mibBuilder.loadTexts: gsmCsV42RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42RowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsV42 components.')
gsmCsV42RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsV42Index"))
if mibBuilder.loadTexts: gsmCsV42RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42RowStatusEntry.setDescription('A single entry in the table represents a single gsmCsV42 component.')
gsmCsV42RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42RowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsV42 components. These components cannot be added nor deleted.')
gsmCsV42ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsV42StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42StorageType.setDescription('This variable represents the storage type value for the gsmCsV42 tables.')
gsmCsV42Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmCsV42Index.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42Index.setDescription('This variable represents the index for the gsmCsV42 tables.')
gsmCsV42ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10), )
if mibBuilder.loadTexts: gsmCsV42ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42ProvTable.setDescription('This group contains the provisionable attributes for the V.42 protocol for this particular GsmIwfCallServer. Changes to these attributes do not effect existing calls.')
gsmCsV42ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsV42Index"))
if mibBuilder.loadTexts: gsmCsV42ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42ProvEntry.setDescription('An entry in the gsmCsV42ProvTable.')
gsmCsV42T400DetectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 1), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(75, 254)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42T400DetectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42T400DetectTimer.setDescription('This attribute specifies the maximum amount of time that the IWF waits for an Originator Detection Pattern (ODP) or Answerer Detection Pattern (ADP). ODP/ADP is a series of special bit patterns used during the call setup procedures. If the IWF is the Originator of the call, it starts sending ODP patterns and waits for an ADP for the duration of T400 milliseconds from the answerer at call setup time. If the IWF is the Answerer of the call, it waits for an ODP for T400 seconds from the originator and if it receives during that time it sends an ADP pattern to the originator at the call setup time. Since both sides operate with different values of T400 timer, a higher value increases the chance of a successful call setup. Changes to this attribute do not effect existing calls.')
gsmCsV42T401AckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 2), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(50, 900)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42T401AckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42T401AckTimer.setDescription('This attribute specifies the maximum amount of time that the IWF waits for an acknowledgment before retransmitting a frame. Since information about the T401 timer is not carried in the Exchange Identification (XID) negotiations at call setup time, both sides operate with different timer values. The value for T401 depends on many factors, such as propagation delay or frame processing time. A frame is retransmitted up to N400 times if the timer T401 expires before an acknowledgment for a frame is actually received. The performance of the data link layer can be impacted by the value of this timer as retransmissions of frames occur on expiry of timer T401. Changes to this attribute do not effect existing calls.')
gsmCsV42T402AckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 3), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(25, 450)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42T402AckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42T402AckDelayTimer.setDescription('This attribute specifies the maximum amount of time that the IWF may wait following the receipt of any frame requiring a reply before it initiates transmission of an appropriate reply in order to ensure that the reply frame is received by the remote error-correcting entity prior to expiration of the T401 timer of the remote error-correcting entity. Since information about the T402 timer is not carried in the Exchange Identification (XID) negotiations at call setup, both sides operate with different timer values. If this timer expires, then the reply that would have been returned prior to its expiration is not sent. The performance of the data link layer can be impacted by the value of this timer as retransmissions of frames occur on expiry of timer T401. For better performance, a value of t402AckDelayTimer (T402) equal to half the value of t401AckTimer (T401) is recommended. Changes to this attribute do not effect existing calls.')
gsmCsV42T403IdleProbeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 90)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42T403IdleProbeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42T403IdleProbeTimer.setDescription('This attribute specifies the maximum amount of time that the IWF allows to elapse without frames being exchanged. The link is permitted to remain idle with no frames being exchanged on the data link. Upon expiry of this timer, the IWF polls its peer for status. Since information about the T403 timer is not carried in the Exchange Identification (XID) negotiations at call setup time, both sides operate with different timer values. Changes to this attribute do not effect existing calls.')
gsmCsV42TxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42TxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42TxN401FrameSize.setDescription('This attribute specifies the maximum number of octets that can be carried in the information field of an Information (I) frame, Exchange Identification (XID) frame, and a Unnumbered Information (UI) frame from the IWF to the remote entity. The default value is 128 octets, and no XID negotiations required for txN401FrameSize. If the value for txN401FrameSize value is set to other than 128 octets, then XID frames are exchanged to negotiate a value. The value provided for txN401FrameSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 128 is specified, then the IWF negotiates or attempts to negotiate a value between the 128 (as a minimum) and the given value (as a maximum). If a value less than 128 is specified, then the IWF attempts to negotiate a value between the given value (as a minimum) and 128 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to 128 is recommended. The negotiated value can be viewed in the component GsmIwfV42Op attribute txN401FrameSize. Changes to this attribute do not effect existing calls.')
gsmCsV42RxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42RxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42RxN401FrameSize.setDescription('This attribute specifies the maximum number of octets that can be carried in the information field of an Information (I) frame, Exchange Identification (XID) frame, and a Unnumbered Information (UI) frame from the remote entity to the IWF. The default value is 128 octets, and no XID negotiations are required for rxN401FrameSize. If the value set for rxN401FrameSize is other than 128, XID frames are exchanged to negotiate a value. The value provided for rxN401FrameSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 128 is specified, then the IWF attempts to negotiate for a value between 128 (as a minimum) and the given value (as a maximum). If a value less than 128 value is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 128 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to the default is recommended. The negotiated value can be viewed in the component GsmIwfV42Op attribute rxN401FrameSize. Changes to this attribute do not effect existing calls.')
gsmCsV42TxKwindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42TxKwindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42TxKwindowSize.setDescription('This attribute specifies the maximum number of outstanding unacknowledged sequenced Information (I) frames from the IWF to the remote entity. The default value is 15 frames, and if this value is used then no Exchange Identification (XID) negotiations are required for txKwindowSize. If the value set for txKwindowSize is other than 15, then XID frames are exchanged to negotiate a value. The value provided for txKwindowSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 15 is specified, then the IWF attempts to negotiate a value between 15 (as a minimum) and the given value (as a maximum). If a value less than 15 is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 15 (as a maximum). Any value can be specified as long at it is within the provisionable limits. However, a value equal to or close to the default is recommended. The negotiated value can be viewed in the component GsmIwfV42Op attribute txKwindowSize. Changes to this attribute do not effect existing calls.')
gsmCsV42RxKwindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42RxKwindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42RxKwindowSize.setDescription('This attribute specifies the maximum number of outstanding unacknowledged sequenced Information (I) frames from the remote entity to the IWF. The default value is 15 frames, and if this value is used then no Exchange Identification (XID) negotiations are required for rxKwindowSize. If the value set for rxKwindowSize is other than 15, then XID frames are exchanged to negotiate a value. The value provided for rxKwindowSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 15 is specified, then the IWF attempts to negotiate a value between 15 (as a minimum) and the given value (as a maximum). If a value less than 15 is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 15 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to the default is recommended. The negotiated value can be viewed in the component GsmIwfV42Op attribute rxKwindowSize. Changes to this attribute do not effect existing calls.')
gsmCsV42N400RetransLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 5, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42N400RetransLimit.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42N400RetransLimit.setDescription('This attribute specifies the maximum number of times the IWF retransmits a frame upon expiry of t401AckTimer before appropriate recovery action is taken. Information about N400 (Retransmission Limit) is not carried in the Exchange Identification (XID) negotiation at call setup time so both sides operate with different N400 values. Changes to this attribute do not effect existing calls.')
gsmCsV42bis = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6))
gsmCsV42bisRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1), )
if mibBuilder.loadTexts: gsmCsV42bisRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsV42bis components.')
gsmCsV42bisRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsV42bisIndex"))
if mibBuilder.loadTexts: gsmCsV42bisRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisRowStatusEntry.setDescription('A single entry in the table represents a single gsmCsV42bis component.')
gsmCsV42bisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42bisRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsV42bis components. These components cannot be added nor deleted.')
gsmCsV42bisComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42bisComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsV42bisStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsV42bisStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisStorageType.setDescription('This variable represents the storage type value for the gsmCsV42bis tables.')
gsmCsV42bisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmCsV42bisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisIndex.setDescription('This variable represents the index for the gsmCsV42bis tables.')
gsmCsV42bisProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10), )
if mibBuilder.loadTexts: gsmCsV42bisProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisProvTable.setDescription('This group contains the provisionable attributes for the V.42bis data compression protocol parameters used for the calls set up by this particular GsmIwfCallServer. Changes to these attributes do not effect existing calls.')
gsmCsV42bisProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsV42bisIndex"))
if mibBuilder.loadTexts: gsmCsV42bisProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisProvEntry.setDescription('An entry in the gsmCsV42bisProvTable.')
gsmCsV42bisCompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("encode", 1), ("decode", 2), ("both", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42bisCompressionDirection.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisCompressionDirection.setDescription('This attribute specifies the V.42bis data compression direction to be supported. The value for compression direction is negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P0 (compression direction). During XID negotiation of parameter P0, both sides (IWF and mobile or IWF and Public Switched Telephone Network (PSTN)) agree on the compression direction. Valid values are: none, No compression is present. encode, The data sent by the IWF to the other entity is compressed. decode, The data received by the IWF from the other entity is compressed. both, The data sent and received by the IWF is compressed. The negotiated value can be viewed in the component GsmIwfV42bisOp attribute compressionDirection. Changes to this attribute do not effect existing calls.')
gsmCsV42bisMaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(2048)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42bisMaximumCodewords.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisMaximumCodewords.setDescription('This attribute specifies the maximum number of V.42bis codewords the IWF supports. A codeword is a binary number that represents a string of characters in compressed form. V.42bis keeps a dictionary of codewords for each compression direction. During Exchange Identification (XID) negotiation of parameter P1 (number of codewords), both sides (IWF and mobile or IWF and Public Switched Telephone Network (PSTN)) agree on the total number of codewords in the dictionaries. Changes to this attribute impact the compression ratio for the encoder (component GsmV42BisOp attribute compRatioEncoder). Changes also impact the amount of memory used (more memory is used when increasing the attribute). The gain in performance obtained from the selection of a larger dictionary may be offset by the larger codeword size needed, and for certain types of data, better performance may be obtained by using a smaller dictionary. The negotiated value can be viewed in the component GsmIwfV42bisOp attribute maximumCodewords . Changes to this attribute do not effect existing calls.')
gsmCsV42bisMaximumStringSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 250)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42bisMaximumStringSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisMaximumStringSize.setDescription('This attribute specifies the maximum number of characters allowed in a string represented by a codeword that the IWF supports. Each codeword in a V.42bis dictionary represents a string of characters. During Exchange Identification (XID) negotiation of parameter P2 (maximum string size), both sides (IWF and mobile or IWF and Public Switched Telephone Network (PSTN)) agree on the maximum string length to be used in the dictionaries. Changes to this attribute impact the compression ratio for the encoder (component GsmIwfV42bisOp attribute compRatioEncoder). The negotiated value can be viewed in the component GsmIwfV42bisOp attribute maximumStringSize. Changes to this attribute do not effect existing calls.')
gsmCsV42bisActionOnError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("resetLink", 0), ("takeDownCall", 1))).clone('resetLink')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsV42bisActionOnError.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsV42bisActionOnError.setDescription('This attribute specifies whether or not V.42bis takes down the call or resets the link when any of the following errors occur: 1.Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). 2. Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). 3. Receipt of a codeword representing an empty dictionary entry. 4. Receipt of a reserved command code. 5. Receipt of any other error. If the value is resetLink, the error corrected connection and V.42bis dictionaries are reset. Some data is lost but the call continues. If the value is takeDownCall, the call is taken down. Changes to this attribute do not effect existing calls.')
gsmCsLp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7))
gsmCsLpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1), )
if mibBuilder.loadTexts: gsmCsLpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpRowStatusTable.setDescription('This entry controls the addition and deletion of gsmCsLp components.')
gsmCsLpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsLpIndex"))
if mibBuilder.loadTexts: gsmCsLpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpRowStatusEntry.setDescription('A single entry in the table represents a single gsmCsLp component.')
gsmCsLpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmCsLpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmCsLp components. These components can be added and deleted.')
gsmCsLpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmCsLpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpStorageType.setDescription('This variable represents the storage type value for the gsmCsLp tables.')
gsmCsLpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: gsmCsLpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpIndex.setDescription('This variable represents the index for the gsmCsLp tables.')
gsmCsLpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10), )
if mibBuilder.loadTexts: gsmCsLpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpOperTable.setDescription('This group contains operational attributes pertaining to information about GsmIwfBearerChannels and logical processors associated with a GsmIwfCallServer from a high-level view.')
gsmCsLpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmCsLpIndex"))
if mibBuilder.loadTexts: gsmCsLpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpOperEntry.setDescription('An entry in the gsmCsLpOperTable.')
gsmCsLpConfiguredBearerChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 124))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpConfiguredBearerChannels.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpConfiguredBearerChannels.setDescription('This attribute indicates the number of GsmIwfBearerChannel components provisioned for the Logical Processor represented by this component.')
gsmCsLpActiveCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 124))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpActiveCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpActiveCalls.setDescription('This attribute indicates the number of GsmIwfBearerChannel components currently active on this LogicalProcessor.')
gsmCsLpAssignedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpAssignedCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpAssignedCapacity.setDescription("This attribute indicates what percentage (0 to 100%) of a given LogicalProcessor has been reserved for the data calls which are currently active. When the assignedCapacity reaches 100%, no new calls are established on the given LogicalProcessor. During the life of a call, the compute requirements will vary. The compute capacity required for a given call type depends on the type of call established including such factors as connection type, data compression, user rate, error correction, flow control; therefore, at call establishment the compute capacity is added to the assignedCapacity for a LogicalProcessor. When the call is released, it's compute capacity is subtracted from the assigned capacity for the Lp.The GsmIwfCallServer uses this information to balance the distribution of data calls across the logical processors.")
gsmCsLpModemsSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 127, 7, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCsLpModemsSupported.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCsLpModemsSupported.setDescription('This attribute indicates if modems are supported with this LogicalProcessor.')
gsmBc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128))
gsmBcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1), )
if mibBuilder.loadTexts: gsmBcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBc components.')
gsmBcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"))
if mibBuilder.loadTexts: gsmBcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRowStatusEntry.setDescription('A single entry in the table represents a single gsmBc component.')
gsmBcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmBcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBc components. These components can be added and deleted.')
gsmBcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcStorageType.setDescription('This variable represents the storage type value for the gsmBc tables.')
gsmBcTrunkGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191)))
if mibBuilder.loadTexts: gsmBcTrunkGrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcTrunkGrpIndex.setDescription('This variable represents an index for the gsmBc tables.')
gsmBcCicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2047)))
if mibBuilder.loadTexts: gsmBcCicIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcCicIndex.setDescription('This variable represents an index for the gsmBc tables.')
gsmBcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101), )
if mibBuilder.loadTexts: gsmBcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcOperTable.setDescription('This group contains operational attributes concerning the operation of this particular GsmIwfBearerChannel for the current or most recent call.')
gsmBcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"))
if mibBuilder.loadTexts: gsmBcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcOperEntry.setDescription('An entry in the gsmBcOperTable.')
gsmBcMipState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 0), ("pendingSetup", 1), ("setup", 2), ("pendingActivation", 3), ("activated", 4), ("holdDisconnect", 5), ("suspended", 6))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcMipState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcMipState.setDescription('This attribute indicates the current state of the MSC/IWF Interface Protocol (MIP) for an IWF element. Valid values are: idle, Startup state of IWF element. pendingSetup, Pending initial state of IWF element. setup, Initial state of IWF element. pendingActivation, Synchronization has been requested, but the IWF element is not yet in the Synchronization state. activated, Synchronization state. holdDisconnect, Flush buffer state, during call clearing the MSC is responsible for holding the network connection towards the disconnected party while the IWF completes the data transmission (flushing any buffered data towards the disconnected party; any buffered data towards the disconnecting party is discarded.) currentlySuspended, The call is temporarily switched to speech phase during a dual services call.')
gsmBcMaxUserDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("n300", 0), ("n600", 1), ("n1200", 2), ("n120075", 3), ("n2400", 4), ("n4800", 5), ("n7200", 6), ("n9600", 7), ("n12000", 8), ("n14400", 9), ("n16800", 10), ("n19200", 11), ("n21600", 12), ("n24000", 13), ("n26400", 14), ("n28800", 15), ("n31200", 16), ("n32000", 17), ("n33600", 18), ("n38400", 19), ("n43200", 20), ("n48000", 21), ("n56000", 22), ("n57600", 23), ("n64000", 24), ("none", 25))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcMaxUserDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcMaxUserDataRate.setDescription('This attribute indicates the user rate which is in affect between the IWF and the fixed network. A user rate of 1200_75 is 75 bit/s in the receive direction 1200 bit/s in the transmit direction.')
gsmBcConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("synchronous", 0), ("asynchronous", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcConnectionType.setDescription('This attribute indicates the connection types between the terminal equipment or terminal adaptor and mobile and between the IWF and the network. Valid connection types are: asynchronous, Transmission of data which does not require clocking of the data signal. synchronous, Transmission of data which requires clocking of the data signal.')
gsmBcDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 99))).clone(namedValues=NamedValues(("n7", 0), ("n8", 1), ("notApplicable", 99))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcDataBits.setDescription('This attribute indicates the number of data bits encoded between start and stop bits in an asynchronous data call connection data stream. This attribute is set to notApplicable for a synchronous data call.')
gsmBcStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 99))).clone(namedValues=NamedValues(("n1", 0), ("n2", 1), ("notApplicable", 99))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcStopBits.setDescription('This attribute indicates the number of stop bits (a mark (binary 1) placed at the end of each data byte) inserted between the data bits in an asynchronous data call connection data stream, this marks the end of the character. This attribute is set to notApplicable for a synchronous data call.')
gsmBcParity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("none", 0), ("odd", 1), ("even", 2), ("forced0", 3), ("forced1", 4), ("notApplicable", 99))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcParity.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcParity.setDescription('This attribute indicates the type of parity for the data bits in an asynchronous data call connection data stream. Parity is a redundant bit that is added to each data byte to aid in error detection. If odd parity is used, all data bytes have an odd number of 1s, and if even parity is used, all data bytes have an even number of 1s. Also parity may be forced to 0, forced to 1, or may not be used at all (required for sending 8-bit data). This attribute will be set to notApplicable for a synchronouse data call. Valid values are: none, No parity. odd, Odd parity. even, Even parity. forced0, Parity forced to 0. forced1, Parity forced to 1. notApplicable, Parity not applicable.')
gsmBcFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noFlowControlActive", 0), ("inband", 1), ("v110FlowCntrl", 2), ("errorCntrl", 3))).clone('noFlowControlActive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFlowControl.setDescription('This attribute indicates the current flow control status of this GsmIwfBearerChannel for an asynchronous call. For a synchronous data call this attribute will be set to noFlowControlActive. Valid values are: noFlowControlActive, There is no flow control active over the air interface and network interfaces. The applications at the end points handle flow control. inband, Embedded characters in the data stream indicate flow control. v110FlowCtnrl, Utilization of V.110 flow control. errorCntrl, Flow control is handle by datalink protocols.')
gsmBcCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("faxG3", 0), ("cda31khz", 1), ("cdaUdi", 2), ("cdsUdi", 3), ("cds31khz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcCallType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcCallType.setDescription('This attribute indicates the current call type. Valid values are: faxG3, group 3 fax calls cda31khz, asynchronous 3.1kHz modem cdaUdi, asynchronous unrestricted digital data call cdsUdi, synchronous unrestricted digital data call cds31khz, synchronous 3.1kHz modem')
gsmBcLastResponseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 99))).clone(namedValues=NamedValues(("requestDone", 0), ("systemError", 1), ("applicationError", 2), ("noResources", 3), ("msgSizeMismatch", 4), ("protocolViolation", 5), ("requestNotSupported", 6), ("requestDenied", 7), ("invalidMessage", 8), ("bufferNotFlushed", 9), ("notApplicable", 99))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLastResponseCode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLastResponseCode.setDescription("This attribute indicates the MSC/IWF Interface Protocol (MIP) response code returned for the last call which was active on this particular GsmIwfBearerChannel. Valid values are: requestDone, the call was terminated normally. systemError, the call was terminated due to a base system problem. applicationError, the call was terminated due to an application level problem. noResources, the call was terminated due to a lack of available resources. msgSizeMismatch, Message length does not match length defined by the MSC/IWF Interface Protocol for the particular message type. protocolViolation, Failed to perform the request because the coding of the request message was invalid; message was not understood. requestNotSupported, Message was understood but not supported by the IWF or MSC. requestDenied, Message was understood and supported by the IWF or MSC but the request is denied. invalidMessage, Message received is invalid for the current state of the IWF's state machine or the MSC data call state machine. The message is ignored. bufferNotFlushed, Message from the Iwf to the MSC indicating that the buffers are not flushed as requested by the MSC. notApplicable, this attribute is not applicable for this call. This is the default value for this attribute.")
gsmBcMateBearerChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 101, 1, 10), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcMateBearerChannel.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcMateBearerChannel.setDescription('This attribute contains the name of the mate GsmIwfBearerChannel that this GsmIwfBearerChannel is involved with in the currently active call.')
gsmBcCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 104), )
if mibBuilder.loadTexts: gsmBcCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
gsmBcCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"))
if mibBuilder.loadTexts: gsmBcCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcCidDataEntry.setDescription('An entry in the gsmBcCidDataTable.')
gsmBcCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 104, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmBcCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
gsmBcStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 105), )
if mibBuilder.loadTexts: gsmBcStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gsmBcStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 105, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"))
if mibBuilder.loadTexts: gsmBcStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcStateEntry.setDescription('An entry in the gsmBcStateTable.')
gsmBcAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 105, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gsmBcOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 105, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gsmBcUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 105, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gsmBcFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2))
gsmBcFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1), )
if mibBuilder.loadTexts: gsmBcFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcFramer components.')
gsmBcFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFramerIndex"))
if mibBuilder.loadTexts: gsmBcFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcFramer component.')
gsmBcFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcFramer components. These components cannot be added nor deleted.')
gsmBcFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerStorageType.setDescription('This variable represents the storage type value for the gsmBcFramer tables.')
gsmBcFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerIndex.setDescription('This variable represents the index for the gsmBcFramer tables.')
gsmBcFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 10), )
if mibBuilder.loadTexts: gsmBcFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
gsmBcFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFramerIndex"))
if mibBuilder.loadTexts: gsmBcFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerProvEntry.setDescription('An entry in the gsmBcFramerProvTable.')
gsmBcFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmBcFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
gsmBcFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11), )
if mibBuilder.loadTexts: gsmBcFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
gsmBcFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFramerIndex"))
if mibBuilder.loadTexts: gsmBcFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerStatsEntry.setDescription('An entry in the gsmBcFramerStatsTable.')
gsmBcFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerFrmToIf.setDescription('This attribute counts the number of frames transmitted to the link interface by Framer. The counter wraps when it exceeds the maximum value.')
gsmBcFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerFrmFromIf.setDescription('This attribute counts the number of frames received from the link interface by Framer. The counter wraps when it exceeds the maximum value.')
gsmBcFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerOctetFromIf.setDescription('This attribute counts the number of bytes received from the link interface by Framer. The counter wraps when it exceeds the maximum value.')
gsmBcFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerCrcErrors.setDescription('This attribute coutns the the total number of frames with CRC errors, occurring in the receive direction from the link. The counter wraps when it exceeds the maximum value.')
gsmBcFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerLrcErrors.setDescription('This attribute counts the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link. The counter wraps when it exceeds the maximum value.')
gsmBcFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerNonOctetErrors.setDescription('This attribute counts the total number of frames that were non octet aligned. The counter wraps when it exceeds the maximum value.')
gsmBcFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerOverruns.setDescription('This attribute counts the total number of frames received from the link for which overruns occurred. The counter wraps when it exceeds the maximum value.')
gsmBcFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerUnderruns.setDescription('This attributecounts the total number of frames transmitted to the link for which underruns occurred. The counter wraps when it exceeds the maximum value.')
gsmBcFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 12), )
if mibBuilder.loadTexts: gsmBcFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerLinkTable.setDescription('This group contains provisionable attributes for the GsmIwfFramer which controls link layer framing for application components sending and receiving data on a link interface for this particular GsmIwfBearerChannel.')
gsmBcFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFramerIndex"))
if mibBuilder.loadTexts: gsmBcFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerLinkEntry.setDescription('An entry in the gsmBcFramerLinkTable.')
gsmBcFramerFramingType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 8))).clone(namedValues=NamedValues(("btdsFraming", 2), ("gsmFraming", 8))).clone('gsmFraming')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmBcFramerFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerFramingType.setDescription('This attribute indicates the type of framing for the link layer data received and transmitted on this channel. Valid values are: BtdsFraming, bit transparent framing required for the GsmIwfBearerChannel components on MVP cards. GsmFraming, GSM framing for the GsmIwfBearerChannel components on DS1C/E1C cards.')
gsmBcFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 13), )
if mibBuilder.loadTexts: gsmBcFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gsmBcFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFramerIndex"))
if mibBuilder.loadTexts: gsmBcFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerStateEntry.setDescription('An entry in the gsmBcFramerStateTable.')
gsmBcFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gsmBcFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gsmBcFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gsmBcLayer1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3))
gsmBcLayer1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1), )
if mibBuilder.loadTexts: gsmBcLayer1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1RowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcLayer1 components.')
gsmBcLayer1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcLayer1Index"))
if mibBuilder.loadTexts: gsmBcLayer1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1RowStatusEntry.setDescription('A single entry in the table represents a single gsmBcLayer1 component.')
gsmBcLayer1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1RowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcLayer1 components. These components cannot be added nor deleted.')
gsmBcLayer1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcLayer1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1StorageType.setDescription('This variable represents the storage type value for the gsmBcLayer1 tables.')
gsmBcLayer1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcLayer1Index.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1Index.setDescription('This variable represents the index for the gsmBcLayer1 tables.')
gsmBcLayer1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10), )
if mibBuilder.loadTexts: gsmBcLayer1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1OperTable.setDescription('This group contains physical layer operational attributes concerning the operation of this particular GsmIwfBearerChannel.')
gsmBcLayer1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcLayer1Index"))
if mibBuilder.loadTexts: gsmBcLayer1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1OperEntry.setDescription('An entry in the gsmBcLayer1OperTable.')
gsmBcLayer1ActiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("v110", 0), ("aTrau", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1ActiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1ActiveMode.setDescription('This attribute indicates the active physical layer protocol between the mobile and the IWF. Valid values are: v110, GSM V.110 rate adaptation scheme for interworking V-series connections to an Integrated Services Digital Network (ISDN). aTrau, GSM A-Transcoder/Rate Adaptor (A-TRAU).')
gsmBcLayer1Connection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transparent", 0), ("nonTransparent", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1Connection.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1Connection.setDescription('This attribute indicates the connection between the mobile and the IWF. Valid values are: transparent, Constant throughput, constant transit delay, and variable error rate (does not use Radio Link Protocol). nonTransparent, Improved error rate with variable transit delay and variable throughput (uses Radio Link Protocol).')
gsmBcLayer1DataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 64000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1DataRate.setDescription('This attribute indicates the layer 1 user data rate for the currently active call for this GsmIwfBearerChannel. This is the data rate between the mobile and IWF.')
gsmBcLayer1IntermediateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1IntermediateRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1IntermediateRate.setDescription('This attribute indicates the intermediate rate used in the physical layer rate adaptation process. This field is valid between the mobile and the IWF. For user data rates of 300 bit/s - 4800 bit/s the intermediate rate is 8 kbit/s. For user data rates 9600 bit/s and above the intermediate rate is 16 kbit/s.')
gsmBcLayer1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11), )
if mibBuilder.loadTexts: gsmBcLayer1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1StatsTable.setDescription('This group contains physical layer statistics concerning the operation of this particular GsmIwfBearerChannel.')
gsmBcLayer1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcLayer1Index"))
if mibBuilder.loadTexts: gsmBcLayer1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1StatsEntry.setDescription('An entry in the gsmBcLayer1StatsTable.')
gsmBcLayer1FramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1FramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1FramesTx.setDescription('This attribute counts the number of frames transmitted on the link. The counter wraps when it exceeds the maximum value.')
gsmBcLayer1FramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1FramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1FramesRx.setDescription('This attribute counts the number of frames received on the link. Discarded frames are not included in this count. The counter wraps when it exceeds the maximum value.')
gsmBcLayer1BytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1BytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1BytesTx.setDescription('This attribute counts number of bytes transmitted on the link. The counter wraps when it exceeds the maximum value.')
gsmBcLayer1BytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1BytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1BytesRx.setDescription('This attribute counts the number of bytes received on the link. Bytes from discarded frames are not included in this count. The counter wraps when it exceeds the maximum value.')
gsmBcLayer1UnderRunsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1UnderRunsTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1UnderRunsTx.setDescription('This attribute counts number of underruns, on a per-call basis, in the transmit direction reported by the hardware on the mobile-side.. These frames are not counted towards the number of frames transmitted (framesTx). The counter wraps when it exceeds the maximum value.')
gsmBcLayer1OverRunsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1OverRunsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1OverRunsRx.setDescription('This attribute counts number of overruns, on a per-call basis, in the receive direction reported by the hardware on the mobile-side. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcLayer1NonOctetErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1NonOctetErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1NonOctetErrorsRx.setDescription('This attribute counts the number of non-octet synchronous frame errors, on a per-call basis, received on the link reported by the hardware. This is when a frame whose bit content was not divisible by eight was detected. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcLayer1LargeFrameErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1LargeFrameErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1LargeFrameErrorsRx.setDescription('This attribute counts the number of frames, on a per-call basis, received on the link that exceeded internal buffer limits reported by the hardware. A large number of these errors could indicate a bad physical medium. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcLayer1FramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1FramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1FramesDiscarded.setDescription('This attribute counts the number of frames discarded, on a per-call basis, in the receive direction by software due to frame errors. The counter wraps when it exceeds the maximum value.')
gsmBcLayer1LrcErrorsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcLayer1LrcErrorsTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcLayer1LrcErrorsTx.setDescription('This attribute counts the number of corrupted frames, on a per-call basis, due to memory inconsistencies found by Longitude Redundancy Check (LRC) checks at the IWF. These frames are not counted towards the number of frames transmitted (framesTx). The counter wraps when it exceeds the maximum value.')
gsmBcModem = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4))
gsmBcModemRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1), )
if mibBuilder.loadTexts: gsmBcModemRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcModem components.')
gsmBcModemRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcModemIndex"))
if mibBuilder.loadTexts: gsmBcModemRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcModem component.')
gsmBcModemRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcModem components. These components cannot be added nor deleted.')
gsmBcModemComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcModemStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemStorageType.setDescription('This variable represents the storage type value for the gsmBcModem tables.')
gsmBcModemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcModemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemIndex.setDescription('This variable represents the index for the gsmBcModem tables.')
gsmBcModemOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10), )
if mibBuilder.loadTexts: gsmBcModemOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemOperTable.setDescription('This group contains operational attributes that measure performance of the modem component for this particular GsmIwfBearerChannel.')
gsmBcModemOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcModemIndex"))
if mibBuilder.loadTexts: gsmBcModemOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemOperEntry.setDescription('An entry in the gsmBcModemOperTable.')
gsmBcModemRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("n300", 0), ("n600", 1), ("n1200", 2), ("n120075", 3), ("n2400", 4), ("n4800", 5), ("n7200", 6), ("n9600", 7), ("n12000", 8), ("n14400", 9), ("n16800", 10), ("n19200", 11), ("n21600", 12), ("n24000", 13), ("n26400", 14), ("n28800", 15), ("n31200", 16), ("n32000", 17), ("n33600", 18), ("n38400", 19), ("n43200", 20), ("n48000", 21), ("n56000", 22), ("n57600", 23), ("n64000", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemRate.setDescription('This attribute indicates the transmission rate of the current modem in use. A rate of 1200_75 is 75 bit/s in the transmit direction and 1200 bit/s in the receive direction. All other rates are the same in both the transmit and receive directions.')
gsmBcModemAlgorithmInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemAlgorithmInUse.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemAlgorithmInUse.setDescription('This attribute indicates the current modem algorithm(s) active for the channel. Valid values are: v17, V.17 is active.V.17 is an ITU-T 14400bit/s modem standard. v27ter, V.27ter is active. V.27ter is an ITU-T 7200bit/s modem standard. v29, V.29 is active. V.29 an ITU-T 9600bit/s modem standard. v21, V.21 active. V.21 is an ITU-4 300bit/s modem standard. v22bis, V.22 or V.22bis active. V.22 ia an ITU-T modem standard that operates at 1200bit/s and 600 baud. V.22bis is an ITU-T modem standard that operates at 2400bit/s and 600 baud. v23, V.23 active. V.23 is an ITU-T modem standard that operates at a speed of 1200bit/s. v26ter, V.26ter active. V.26ter is an ITU-T modem standard that operates at a speed of 2400bit/s. v32bis, V.32 or V.32bis active. V.32 is an ITU-T modem standard that operates at 9600bit/s and 2400 baud. V.32bis is an ITU-T modem standard that operates at a speed of 14.4kbit/s. v34, V.34 active. V.34 is an ITU-T modem standard that operates at a speed of up to 28.8kbit/s. Description of bits: notused0(0) v17(1) v29(2) v27ter(3) v21(4) v22bis(5) v23(6) v26ter(7) v32bis(8) v34(9)')
gsmBcModemProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("training", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemProtocolState.setDescription('This attribute indicates the active protocol state of the modem in use.Valid values are: idle, Modem is in an inactive state and has no current connection established. training, Modem is attempting to establish a connection with the far end modem via handshaking. connected, Modem has establish a connection with the far end modem.')
gsmBcModemReceiverTransmitter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("rxOnTxOff", 1), ("rxOffTxOn", 2), ("rxTxOn", 3))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemReceiverTransmitter.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemReceiverTransmitter.setDescription('This attribute indicates whether the fax data modem is in receive or transmit mode. If this is not a fax data modem call, then the value is set to notApplicable. Valid values are: notApplicable, Not an applicable field. rxOnTxOff, Receiver is on, transmitter is off. rxOffTxOn, Receiver is off, transmitter is on. rxTxOn, Reciever is on, transmitter is on.')
gsmBcModemTraining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 99))).clone(namedValues=NamedValues(("short", 0), ("long", 1), ("notApplicable", 99))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemTraining.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemTraining.setDescription('This attribute indicates the training procedure used by the V.17 modems. ITU-T defines two training procedures. A longer training procedure used at call setup, and a short training procedure is used during the fax call when switching from the V.21 modem to the V.17 modem. A value of notApplicable indicates that the attribute is not applicable for the modem.')
gsmBcModemToUpperFlowControlActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemToUpperFlowControlActive.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemToUpperFlowControlActive.setDescription('This attribute indicates whether flow control was requested and an indication was sent to an upper layer protocol.')
gsmBcModemToDspFlowControlActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemToDspFlowControlActive.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemToDspFlowControlActive.setDescription('This attribute indicates whether an upper layer protocol requested flow control and an indication was sent to the Digital Signal Processor.')
gsmBcModemAsyncMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemAsyncMode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemAsyncMode.setDescription('This attribute indicates whether conversion between synchronous and asynchronous data format (specifacally, the stripping or insertion of start and stop bits) is being performed. The value will be on unless the V.42 layer is active or it is a fax call.')
gsmBcModemAutoHdlcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemAutoHdlcMode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemAutoHdlcMode.setDescription('This attribute indicates whether High-Level Data Link Control (HDLC) functions are being performed by the modem to support HDLC applications (V.42 for example).')
gsmBcModemOutbandFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemOutbandFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemOutbandFlowControl.setDescription('This attribute indicates whether inband or outband flow control conversions are being performed. The modem performs either inband or outband flow control unless V.42 layer is active, it is a fax call, or no flow control was specified by the MSC.')
gsmBcModemOutbandBreak = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemOutbandBreak.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemOutbandBreak.setDescription('This attribute indicates whether inband or outband break control conversions are being performed. This is when the modem detects a break condition as defined by ITU-T X.28 and reports it. When a break condition is discovered all subsequent incoming data is discarded until a start bit is received.')
gsmBcModemAutobaud = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemAutobaud.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemAutobaud.setDescription('This attribute indicates whether autobaud is active. The modem is instructed at call setup time by the MSC on: What is the initial modem data rate value and Whether a modem is allowed to perform autobauding (on) or not (off). With Autobauding on, the modem is allowed to connect using a valid modem data rate less than or equal to the initial rate specified to the modem by the MSC. If a modem can not perform autobauding and the carrier can not be established at the initial data rate, the modem is disabled.')
gsmBcModemStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 11), )
if mibBuilder.loadTexts: gsmBcModemStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemStatsTable.setDescription('This group contains operational attributes that measure performance of the modem component for this particular GsmIwfBearerChannel.')
gsmBcModemStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcModemIndex"))
if mibBuilder.loadTexts: gsmBcModemStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemStatsEntry.setDescription('An entry in the gsmBcModemStatsTable.')
gsmBcModemBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemBytesTx.setDescription('This attribute counts the number of payload bytes transmitted. The counter wraps when it exceeds the maximum value.')
gsmBcModemBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemBytesRx.setDescription('This attribute counts the number of payload bytes received. The counter wraps when it exceeds the maximum value.')
gsmBcModemFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcModemFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcModemFramingErrors.setDescription('This attribute counts the number of framing errors detected by the hardware. This is the absence of a stop bit after a start bit and eight bits of data. All incoming data is discarded until the next start bit is received. The counter wraps when it exceeds the maximum value.')
gsmBcV110 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5))
gsmBcV110RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1), )
if mibBuilder.loadTexts: gsmBcV110RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110RowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcV110 components.')
gsmBcV110RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV110Index"))
if mibBuilder.loadTexts: gsmBcV110RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110RowStatusEntry.setDescription('A single entry in the table represents a single gsmBcV110 component.')
gsmBcV110RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110RowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcV110 components. These components cannot be added nor deleted.')
gsmBcV110ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcV110StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110StorageType.setDescription('This variable represents the storage type value for the gsmBcV110 tables.')
gsmBcV110Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcV110Index.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110Index.setDescription('This variable represents the index for the gsmBcV110 tables.')
gsmBcV110OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 10), )
if mibBuilder.loadTexts: gsmBcV110OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110OperTable.setDescription('This group contains operational attributes that measure the performance of V110.')
gsmBcV110OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV110Index"))
if mibBuilder.loadTexts: gsmBcV110OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110OperEntry.setDescription('An entry in the gsmBcV110OperTable.')
gsmBcV110DataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110DataRate.setDescription('This attribute contains the layer 1 user data rate for the currently active call for this GsmIwfBearerChannel. This is the data rate between the IWF and the fixed network.')
gsmBcV110IntermediateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n8KbitS", 0), ("n16KbitS", 1), ("n32KbitS", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110IntermediateRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110IntermediateRate.setDescription('This attribute indicates the intermediate rate used in the physical layer rate adaptation process. This field is valid between the network and the IWF. For user data rates of 300 bit/s to 4800 bit/s the intermediate rate is 8 kbit/s. For a user data rate of 9600 bit/s the intermediate rate is 16 kbit/s. For user data rates of 1200 bit/s to 19200 bit/s the intermediate rate is 32 kbit/s. Data rates above this have no intermediate rate.')
gsmBcV110StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11), )
if mibBuilder.loadTexts: gsmBcV110StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110StatsTable.setDescription('This group contains statistical attributes which measure the performance of V110.')
gsmBcV110StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV110Index"))
if mibBuilder.loadTexts: gsmBcV110StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110StatsEntry.setDescription('An entry in the gsmBcV110StatsTable.')
gsmBcV110FramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110FramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110FramesTx.setDescription('This attribute counts the number of frames transmitted on the link. The counter wraps when it exceeds the maximum value.')
gsmBcV110FramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110FramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110FramesRx.setDescription('This attribute counts the number of frames received on the link. Discarded frames are not included in this count. The counter wraps when it exceeds the maximum value.')
gsmBcV110BytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110BytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110BytesTx.setDescription('This attribute counts the number of bytes transmitted on the link. The counter wraps when it exceeds the maximum value.')
gsmBcV110BytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110BytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110BytesRx.setDescription('This attribute counts the number of bytes received on the link. Bytes from discarded frames are not included in this count. The counter wraps when it exceeds the maximum value.')
gsmBcV110UnderRunsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110UnderRunsTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110UnderRunsTx.setDescription('This attribute counts the number of underruns, on a per-call basis, in the transmit direction reported by the hardware on the network side. These frames are not counted towards the number of frames transmitted (framesTx). The counter wraps when it exceeds the maximum value.')
gsmBcV110OverRunsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110OverRunsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110OverRunsRx.setDescription('This attribute counts the number of overruns, on a per-call basis, in the receive direction reported by the hardware on the network side. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcV110NonOctetErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110NonOctetErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110NonOctetErrorsRx.setDescription('This attribute counts the number of non-octet synchronous frame errors, on a per-call basis, received on the link reported by the hardware. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcV110LargeFrameErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110LargeFrameErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110LargeFrameErrorsRx.setDescription('This attribute counts the number of frames received on the link that exceeded internal buffer limits reported by the hardware, on a per- call basis. These frames are discarded. These frames are not counted towards the number of frames received (framesRx). The counter wraps when it exceeds the maximum value.')
gsmBcV110FramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110FramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110FramesDiscarded.setDescription('This attribute counts the number of frames discarded, on a per-call basis, in the receive direction by software due to frame errors. The counter wraps when it exceeds the maximum value.')
gsmBcV110LrcErrorsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 5, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV110LrcErrorsTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV110LrcErrorsTx.setDescription('This attribute counts the number of corrupted frames, on a per-call basis, due to memory inconsistencies found by Longitude Redundancy Check (LRC) checks at the IWF. The counter wraps when it exceeds the maximum value.')
gsmBcFax = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6))
gsmBcFaxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1), )
if mibBuilder.loadTexts: gsmBcFaxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcFax components.')
gsmBcFaxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFaxIndex"))
if mibBuilder.loadTexts: gsmBcFaxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcFax component.')
gsmBcFaxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcFax components. These components cannot be added nor deleted.')
gsmBcFaxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcFaxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxStorageType.setDescription('This variable represents the storage type value for the gsmBcFax tables.')
gsmBcFaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcFaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxIndex.setDescription('This variable represents the index for the gsmBcFax tables.')
gsmBcFaxOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 10), )
if mibBuilder.loadTexts: gsmBcFaxOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxOperTable.setDescription('This group contains operational attributes which measure the performance of the fax protocol.')
gsmBcFaxOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFaxIndex"))
if mibBuilder.loadTexts: gsmBcFaxOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxOperEntry.setDescription('An entry in the gsmBcFaxOperTable.')
gsmBcFaxActiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("ecm", 1))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxActiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxActiveMode.setDescription('This attribute indicates the mode of the fax T.30 protocol, determined during Exchange Identification (XID) negotiations. The following modes are supported: normal, normal T.30 protocol, Error Correction Mode (ECM) not used ecm, Error Correction Mode used. Fax error correction is done using a half-duplex page selective repeat technique.')
gsmBcFaxProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("setup", 0), ("idle", 1), ("bcsRx", 2), ("bcsTx", 3), ("msgRx", 4), ("msgTx", 5))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxProtocolState.setDescription('This attribute indicates the protocol state of the fax adaptor. The values are: setup, call setup state idle, idle state only transmitting Synchronize (SYNC) frames bcsRx, receiving Binary Coded Signal (BCS) packet from modem bcsTx, transmitting BCS packet to modem msgRx, receiving fax message from modem msgTx, transmitting fax message to modem')
gsmBcFaxMessageRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxMessageRate.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxMessageRate.setDescription('This attribute indicates the fax message rate used for sending fax documents.')
gsmBcFaxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11), )
if mibBuilder.loadTexts: gsmBcFaxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxStatsTable.setDescription('This group contains statistical attributes which measure the performance of the fax protocol.')
gsmBcFaxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcFaxIndex"))
if mibBuilder.loadTexts: gsmBcFaxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxStatsEntry.setDescription('An entry in the gsmBcFaxStatsTable.')
gsmBcFaxMessageFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxMessageFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxMessageFramesRx.setDescription('This attribute counts the number of fax message frames received from the mobile. One fax message frame is an eight byte DATA frame defined in GSM 3.45. The counter wraps when it exceeds the maximum value.')
gsmBcFaxMessageFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxMessageFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxMessageFramesTx.setDescription('This attribute counts the number of fax message frames transmitted to the mobile. One fax message frame is an eight byte DATA frame defined in GSM 3.45. The counter wraps when it exceeds the maximum value.')
gsmBcFaxBcsFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxBcsFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxBcsFramesRx.setDescription('This attribute counts the number of fax Binary Coded Signal (BCS) frames received from the mobile. A fax BCS frame is an 8-byte STATUS frame, which carries T.30 BCS data as defined in GSM 3.45. The counter wraps when it exceeds the maximum value.')
gsmBcFaxBcsFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxBcsFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxBcsFramesTx.setDescription('This attribute counts the number of fax Binary Coded Signal (BCS) frames transmitted to the mobile. A fax BCS frame is an 8-byte STATUS frame, which carries T.30 BCS data as defined in GSM 3.45. The counter wraps when it exceeds the maximum value.')
gsmBcFaxPagesRxFromMobile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxPagesRxFromMobile.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxPagesRxFromMobile.setDescription('This attribute counts the number of fax pages received from the mobile. The counter wraps when it exceeds the maximum value.')
gsmBcFaxPagesTxToMobile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxPagesTxToMobile.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxPagesTxToMobile.setDescription('The attribute counts the number of fax pages transmitted to the mobile. The counter wraps when it exceeds the maximum value.')
gsmBcFaxChannelModeModify = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxChannelModeModify.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxChannelModeModify.setDescription('This attribute counts the number of Channel Mode Modify (CMM) requests initiated by the IWF. For transparent fax calls, the transmission speed is determined by the two fax machines at call setup. The speed may change during the transmission to satisfy the T.30 protocol. The CMM request is used by the GSM IWF to request that the T.30 requested speed change can be propagated throughout the network. The counter wraps when it exceeds the maximum value.')
gsmBcFaxBcsFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 6, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcFaxBcsFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcFaxBcsFrameErrors.setDescription('This attribute counts the number of fax Binary Coded Signal (BCS) frames in error. This attribute indicates the count of corrupted fax BCS frames over the GSM radio channel. The counter wraps when it exceeds the maximum value.')
gsmBcRlp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7))
gsmBcRlpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1), )
if mibBuilder.loadTexts: gsmBcRlpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcRlp components.')
gsmBcRlpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcRlpIndex"))
if mibBuilder.loadTexts: gsmBcRlpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcRlp component.')
gsmBcRlpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcRlp components. These components cannot be added nor deleted.')
gsmBcRlpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcRlpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpStorageType.setDescription('This variable represents the storage type value for the gsmBcRlp tables.')
gsmBcRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpIndex.setDescription('This variable represents the index for the gsmBcRlp tables.')
gsmBcRlpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10), )
if mibBuilder.loadTexts: gsmBcRlpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpOperTable.setDescription('This group contains operational attributes that measure performance of the GsmIwfBearerChannel.')
gsmBcRlpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcRlpIndex"))
if mibBuilder.loadTexts: gsmBcRlpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpOperEntry.setDescription('An entry in the gsmBcRlpOperTable.')
gsmBcRlpProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("detached", 0), ("disconnected", 1), ("connPending", 2), ("discPending", 3), ("connectEstablished", 4), ("synchronized", 5))).clone('detached')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpProtocolState.setDescription('This attribute indicates the last Radio Link Protocol (RLP) state before call take down. The following are the states: detached, Initial State. The call has not even started. disconnected, Asynchronous Disconnected Mode (ADM). connPending, In ADM, but sent Set Asynchronous Balanced Mode (SABM) and waiting for a response. discPending, Sent Disconnect (DISC), waiting for a response. connectEstablished, In Asynchronous Balanced Mode (ABM), Information frames can be exchanged. synchronized, Synchronization state entered after a change of channel coding. Handles REMAP procedure.')
gsmBcRlpFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpFrameSize.setDescription('This attribute indicates the current Radio Link Protocol (RLP) frame size transmitted. The size of the frame depends on the radio channel type. The frames can be 240 bits long for 12 kbit/s and 6 kbit/s or 576 bits long for 14.5 kbit/s.')
gsmBcRlpHighestVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpHighestVersion.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpHighestVersion.setDescription('This attribute indicates the current highest version of the Radio Link Protocol (RLP) protocol negotiated by the Radio Link Protocol (RLP), during Exchange Information (XID). Valid values are: 0, Single-link basic version. 1, Single-link extended version (for example, extended by data compression). The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute highestVersion.')
gsmBcRlpIwfToMsWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpIwfToMsWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpIwfToMsWindowSize.setDescription('This attribute indicates the current IWF to mobile window size negotiated by the Radio Link Protocol (RLP) during Exchange Information (XID). The window size is the maximum number of sequentially numbered Information (I) frames that may be unacknowledged at any given time. GSM specification 4.22 defines the range as 0 to 61. The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute iwftoMsWindowSize.')
gsmBcRlpMsToIwfWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpMsToIwfWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpMsToIwfWindowSize.setDescription('This attribute indicates the current mobile to IWF window size negotiated by the Radio Link Protocol (RLP), during Exchange Information (XID). The window size is the maximum number of sequentially numbered Information (I) frames that may be unacknowledged at any given time. GSM specification 4.22 defines the range as 0 to 61. The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute msToIwfWindowSize.')
gsmBcRlpT1AckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(380, 1020))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpT1AckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpT1AckTimer.setDescription('This attribute indicates the current T1 timer negotiated by the Radio Link Protocol (RLP), during Exchange Information (XID). This is the period in milliseconds within which an acknowledgment of a sent frame must be received. Once this timer expires, the transmitting RLP entity shall assume that the frame was lost. The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute t1AckTimer.')
gsmBcRlpT2AckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 70))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpT2AckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpT2AckDelayTimer.setDescription('This attribute indicates the current T2 timer negotiated by the Radio Link Protocol (RLP), during Exchange Information (XID). This is the maximum period in milliseconds the receiving RLP entity shall wait before sending an acknowledgment for a received in sequenced frame. The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute t2AckDelayTimer.')
gsmBcRlpN2RetransmitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmBcRlpN2RetransmitCount.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpN2RetransmitCount.setDescription('This attribute indicates the current value of N2 negotiated by the Radio Link Protocol (RLP), during Exchange Information (XID). This is the maximum number of times a RLP entity shall retransmit an individual frame following the expiry of timer T1. The value used for XID negotiations can be provisioned by component GsmIwfRadioLinkProtocol attribute n2RetransmitCount.')
gsmBcRlpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11), )
if mibBuilder.loadTexts: gsmBcRlpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpStatsTable.setDescription('This group contains operational attributes that measure performance of the GsmIwfBearerChannel.')
gsmBcRlpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcRlpIndex"))
if mibBuilder.loadTexts: gsmBcRlpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpStatsEntry.setDescription('An entry in the gsmBcRlpStatsTable.')
gsmBcRlpIFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpIFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpIFramesTx.setDescription('This attribute counts the number of valid Information frames transmitted. This count does not include the Information frames discarded. The counter wraps when it exceeds the maximum value.')
gsmBcRlpIFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpIFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpIFramesRx.setDescription('This attributes counts the number of valid Information (I) frames received. The counter wraps when it exceeds the maximum value.')
gsmBcRlpFramesRetransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpFramesRetransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpFramesRetransmitted.setDescription('This attribute counts the total number of frames retransmitted. Frames that are not acknowledged within the T1 timer are retransmitted. The counter wraps when it exceeds the maximum value.')
gsmBcRlpT1AckTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpT1AckTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpT1AckTimeouts.setDescription('This attribute counts the total number of T1 timer time-outs. Retransmission of all unacknowledged frames is started after T1 timer expiry. The counter wraps when it exceeds the maximum value.')
gsmBcRlpInvalidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpInvalidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpInvalidFrames.setDescription('This attribute counts the number of invalid frames received. These invalid frames are frames received from the mobile which contain errors in the header information. This count does not include the number of frames with Cyclic Redundancy Check (CRC) errors or out-of-sequence Frame Errors. The counter wraps when it exceeds the maximum value.')
gsmBcRlpCrcErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpCrcErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpCrcErrorsRx.setDescription('This attribute counts the number of frames with Cyclic Redundancy Check (CRC) errors received by the IWF Radio Link Protocol (RLP) entity. CRC is a type of block check character that is very effective in detecting communications errors. CRCs are commonly 16 or 32 bits long (though, in GSM non-transparent services, a 24- bit CRC is used). The counter wraps when it exceeds the maximum value.')
gsmBcRlpOutOfSequenceFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpOutOfSequenceFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpOutOfSequenceFrames.setDescription('This attribute counts the number of out-of-sequence Information frames received by the IWF Radio Link Protocol (RLP) entity. The counter wraps when it exceeds the maximum value.')
gsmBcRlpRemoteBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpRemoteBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpRemoteBusyIndications.setDescription('This attribute counts the number of times the mobile Radio Link Protocol (RLP) entity is busy (that is, it is in Asynchronous Balanced Mode (ABM) and is not ready to receive Information frames). The RLP entity is considered to be not ready to receive information frames if the mobile sends a flow control indication RNR (Receive Not Ready). A Receive Ready is sent to the RLP entity when the mobile is ready to receive data. The counter wraps when it exceeds the maximum value.')
gsmBcRlpLocalBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpLocalBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpLocalBusyIndications.setDescription('This attribute counts the number of times the IWF RLP entity is busy (that is it is in Asynchronous Balanced Mode (ABM) and is not ready to receive Information frames). When the network side introduces flow control towards the mobile and a Receive Not Ready (RNR) is sent to the mobile to stop the mobile from sending any more data frames. A Receive Ready (RR) is sent to the mobile when the RLP entity is ready to receive data. The counter wraps when it exceeds the maximum value.')
gsmBcRlpIFramesTxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpIFramesTxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpIFramesTxDiscarded.setDescription('This attribute counts the number of frames discarded by the IWF. Untransmitted and unacknowledged frames are discarded when a Set Asynchronous Balanced Mode (SABM) or Disconnect (DISC) is received or sent in Asynchronous Balanced Mode (ABM) mode. The counter wraps when it exceeds the maximum value.')
gsmBcRlpResetsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 7, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcRlpResetsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcRlpResetsRx.setDescription('This attribute counts the number of resets sent by the mobile. Loss of information may occur when a reset is issued. A reset is issued by the mobile on failure of checkpoint recovery. That is if the mobile does not receive acknowledgment for its information frame, it does checkpoint recovery (it sends a supervisory frame requesting the status of the other entity. If the responding entity fails to respond to N2 of this checkpoint frame a reset is initiated by the originating entity. A reset can also be issued by the mobile during handover where a loss of connection or synchronization occurs. The counter wraps when it exceeds the maximum value.')
gsmBcV42 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8))
gsmBcV42RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1), )
if mibBuilder.loadTexts: gsmBcV42RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcV42 components.')
gsmBcV42RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42Index"))
if mibBuilder.loadTexts: gsmBcV42RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RowStatusEntry.setDescription('A single entry in the table represents a single gsmBcV42 component.')
gsmBcV42RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcV42 components. These components cannot be added nor deleted.')
gsmBcV42ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcV42StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42StorageType.setDescription('This variable represents the storage type value for the gsmBcV42 tables.')
gsmBcV42Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcV42Index.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42Index.setDescription('This variable represents the index for the gsmBcV42 tables.')
gsmBcV42OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10), )
if mibBuilder.loadTexts: gsmBcV42OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42OperTable.setDescription('This group contains operational attributes which measure V.42 error detection and correction performance.')
gsmBcV42OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42Index"))
if mibBuilder.loadTexts: gsmBcV42OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42OperEntry.setDescription('An entry in the gsmBcV42OperTable.')
gsmBcV42ProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notActive", 0), ("disconnected", 1), ("linksetup", 2), ("frameReject", 3), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 6))).clone('notActive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42ProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42ProtocolState.setDescription('This attribute indicates the state of V.42. Valid states are: notActive, The V.42 link connection with the Public Switched Telephoned Network) PSTN modem is not established. None of the V.42 functions including the error detection, error correction, and flow control is provided to the data call. This is the initial state of V.42. disconnected, This means that the V42 link is disconnected. linksetup, The V.42 operation enters this state from the disconnected state after the V.42 sends to the PSTN modem a Set Asynchronous Balanced Mode Extended (SABME) frame in an attempt to establish the error control connection with the PSTN modem. frameReject, The V.42 operation enters into this state after it identifies an invalid frame sent by the peer and it sends back a frame reject (FRMR) frame to the peer. disconnectRequest, The V.42 operation enters into this state after it sends to the peer a disconnect (DISC) frame with the attempt to disconnect the V.42 error control link. informationTransfer, The V.42 enters into this state after it receives a UA (unnumbered acknowledgment) frame which the peer sent upon receipt of the SAMBE frame from IWF V.42. Once in this state, the V.42 can exchange data and supervisory information with its peer. waitingAck, The V.42 enters this state after it sends polling enquiry to its peer. The V.42 sends the polling enquiry when it receives a reject frame (REJ) from its peer or either its acknowledgment timer or inactivity timer timed out on the information frames sent out.')
gsmBcV42TxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65355))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42TxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42TxN401FrameSize.setDescription('This attribute indicates the current value of parameter N401 for V.42 which is negotiated during Exchange Information (XID). This is the maximum number of octets that can be carried in the information field of an information frame that the IWF V.42 transmits to the Public Switched Telephone Network (PSTN) modem. The IWF V.42 puts this or even smaller size of data into the outgoing information frame. The value used for XID negotiations can be provisioned by component GsmIwfV42 attribute txN401FrameSize.')
gsmBcV42RxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42RxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RxN401FrameSize.setDescription('This attribute indicates the current value of N401, that is negotiated during Exchange Identification (XID). This is the maximum number of octets that can be carried in the information field of an information frame received from the Public Switched Telephone Network (PSTN) modem. An incoming information frame carrying data octets more than this size shall be rejected by the IWF V.42. The value used for XID negotiations can be provisioned by component GsmIwfV42 attribute rxN401FrameSize.')
gsmBcV42TxKwindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42TxKwindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42TxKwindowSize.setDescription('This attribute indicates the current value of k, that is negotiated during Exchange Identification (XID). This is the size of flow control sliding window used for the information frames that the V.42 transmits to the Public Switched Telephone Network (PSTN) modem. This size governs the maximum number of information frames that the IWF V.42 error-correcting entity can have outstanding (that is, unacknowledged). The value used for XID negotiations can be provisioned by component GsmIwfV42 attribute txKwindowSize.')
gsmBcV42RxKwindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42RxKwindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RxKwindowSize.setDescription('This attribute indicates the current value of k that is negotiated during Exchange Identification (XID). This is the size of flow control sliding window used for information frames transmitted from the Public Switched Telephone Network (PSTN) modem. This size governs the maximum number of information frames that the peer of the IWF V.42 error-correcting entity can have outstanding (that is, unacknowledged). The value used for XID negotiations can be provisioned by component GsmIwfV42 attribute rxKwindowSize.')
gsmBcV42StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11), )
if mibBuilder.loadTexts: gsmBcV42StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42StatsTable.setDescription('This group contains statistical attributes that measure the V.42 error detection and correction performance.')
gsmBcV42StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42Index"))
if mibBuilder.loadTexts: gsmBcV42StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42StatsEntry.setDescription('An entry in the gsmBcV42StatsTable.')
gsmBcV42IBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42IBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42IBytesRx.setDescription('This attribute counts the total number of bytes that the V.42 actually received from the Public Switched Telephone Network (PSTN) modem in a data call. The counter wraps when it exceeds the maximum value.')
gsmBcV42IBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42IBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42IBytesTx.setDescription('This attribute counts the total number of bytes that the V.42 transmitted to the Public Switched Telephone Network (PSTN) modem in a data call. The counter wraps when it exceeds the maximum value.')
gsmBcV42IFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42IFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42IFramesRx.setDescription('This attribute counts the total number of Information (I) frames that the V.42 received from the Public Switched Telephone Network (PSTN) modem in a data call. The counter wraps when it exceeds the maximum value.')
gsmBcV42IFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42IFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42IFramesTx.setDescription('This attribute counts the total number of information frames that the V.42 transmitted to the Public Switched Telephone Network (PSTN) modem in a data call. The counter wraps when it exceeds the maximum value.')
gsmBcV42FramesRetransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42FramesRetransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42FramesRetransmitted.setDescription('This attribute counts the total number of frames retransmitted by the IWF V.42 entity in a data call. The V.42 retransmits the same frame when the associated T401 acknowledgment timer time-outs or when a Reject (REJ) supervisory frame has been received from the Public Switched Telephone Network (PSTN) modem. The counter wraps when it exceeds the maximum value.')
gsmBcV42T1AckTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42T1AckTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42T1AckTimeouts.setDescription("This attribute counts the total number of times that the T401 timer has timed out within a data call. If this timer times-out frequently, the operator may need to adjust the provisional parameter T401 acknowledgment timer to a larger time amount, since every time that V.42 sends out a frame it sets the T401 timer to wait for the peer's acknowledgment of the frame. When the timer times-out and no acknowledgment has been received, the V.42 sends the same frame to its peer. The counter wraps when it exceeds the maximum value.")
gsmBcV42RemoteBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42RemoteBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42RemoteBusyIndications.setDescription('This attribute counts the total number of times the Public Switched Telephone Network (PSTN) modem enters a busy state (the IWF has received a Receive Not Ready message) and asks the IWF V.42 not to send Information (I) frames to it until it is ready to receive information frames again (indicated by receipt of a Receive Ready message or a data message). The counter wraps when it exceeds the maximum value.')
gsmBcV42LocalBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42LocalBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42LocalBusyIndications.setDescription('This attribute counts the total number of times the IWF V.42 enters in a busy condition and asks the peer to stop sending information frames until it has cleared up from the busy condition. The V.42 enters busy condition when its data buffer is about to be overflowed by the incoming Information (I) frames. The counter wraps when it exceeds the maximum value.')
gsmBcV42BadFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42BadFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42BadFramesRx.setDescription("This attribute counts the total number of bad frames the IWF V.42 has received from the Public Switched Telephone Network (PSTN) remote modem within the data call. In this instance, 'bad frames' refer to the V.42 protocol error frames other than the check sequence error frames. The counter wraps when it exceeds the maximum value.")
gsmBcV42CrcErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 8, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42CrcErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42CrcErrorsRx.setDescription('This attribute counts the total number of frames received from the remote Public Switched Telephone Network (PSTN) modem that contain incorrect frame check sequence. A high value signifies the condition of the physical medium is poor. The counter wraps when it exceeds the maximum value.')
gsmBcV42bis = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9))
gsmBcV42bisRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1), )
if mibBuilder.loadTexts: gsmBcV42bisRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcV42bis components.')
gsmBcV42bisRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42bisIndex"))
if mibBuilder.loadTexts: gsmBcV42bisRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcV42bis component.')
gsmBcV42bisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcV42bis components. These components cannot be added nor deleted.')
gsmBcV42bisComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcV42bisStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisStorageType.setDescription('This variable represents the storage type value for the gsmBcV42bis tables.')
gsmBcV42bisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcV42bisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisIndex.setDescription('This variable represents the index for the gsmBcV42bis tables.')
gsmBcV42bisOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10), )
if mibBuilder.loadTexts: gsmBcV42bisOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisOperTable.setDescription('This group contains operational attributes that measure the performance of V.42bis.')
gsmBcV42bisOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42bisIndex"))
if mibBuilder.loadTexts: gsmBcV42bisOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisOperEntry.setDescription('An entry in the gsmBcV42bisOperTable.')
gsmBcV42bisProtocolModeEncoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transparent", 0), ("compressed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisProtocolModeEncoder.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisProtocolModeEncoder.setDescription('This attribute indicates the current mode of the V.42bis encoder. This mode can be either: transparent - A mode of operation in which compression has been selected but data is being transmitted in uncompressed form. Transparent mode command sequences may be inserted into the data stream. compressed - A mode of operation in which data is transmitted in codewords. The encoder switches between the two modes depending on whether the data coming from the Date Terminal Equipment (DTE) is suitable for compression. The data comression function periodically determines the compressibility of the data based on a comparison of the number of bits required to represent a segment of the data stream before and after compression.')
gsmBcV42bisProtocolModeDecoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transparent", 0), ("compressed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisProtocolModeDecoder.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisProtocolModeDecoder.setDescription('This attribute indicates the current mode of the V.42bis decoder. This mode can be either: transparent - A mode of operation in which compression has been selected but data is being transmitted in uncompressed form. Transparent mode command sequences may be inserted into the data stream. compressed - A mode of operation in which data is transmitted in codewords. The encoder (at the mobile or Public Switched Telephone Network) switches between the two modes depending on whether the data coming from the Date Terminal Equipment (DTE) is suitable for compression. The data comression function periodically determines the compressibility of the data based on a comparison of the number of bits required to represent a segment of the data stream before and after compression.')
gsmBcV42bisCompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("encode", 1), ("decode", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisCompressionDirection.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisCompressionDirection.setDescription('This attribute indicates the direction in which V.42bis is active, negotiated at link setup by the data link protocol through Exchange Identification (XID) negotiation of parameter P0 (compression direction). The value used for XID negotiations can be provisioned by component GsmIwfV42bisProv attribute compressionDirection. Valid values are: none, No compression is present. encode, The data sent by the IWF to the other entity is compressed. decode, The data received by the IWF from the other entity is compressed. both, The data sent and received by the IWF is compressed.')
gsmBcV42bisMaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisMaximumCodewords.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisMaximumCodewords.setDescription('This attribute indicates the maximum number of codewords in the dictionary negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P1 (number of codewords). The value used for XID negotiations can be provisioned by component GsmIwfV42bisProv attribute maximumCodewords.')
gsmBcV42bisMaximumStringSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisMaximumStringSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisMaximumStringSize.setDescription('This attribute indicates the maximum number of characters allowed in a string represented by a codeword negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P2 (maximum string size). The value used for XID negotiations can be provisioned by component GsmIwfV42bisProv attribute maximumStringSize.')
gsmBcV42bisLastDecodeError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("badStepup", 1), ("codewordEqC1", 2), ("emptyCodeword", 3), ("reservedCommand", 4), ("generalError", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisLastDecodeError.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisLastDecodeError.setDescription('This attribute indicates last error found by the decoder. Error values are: none, No errors found. badStepup, Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). codewordEqC1, Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). emptyCodeword, Receipt of a codeword representing an empty dictionary entry. reservedCommand, Receipt of a reserved command code. generalError, Receipt of any other error. The action taken by V.42bis on detecting an error is provisioned by component GsmIwfV42bis attribute actionOnError.')
gsmBcV42bisCompRatioEncoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 7), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisCompRatioEncoder.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisCompRatioEncoder.setDescription('This attribute indicates the number of uncompressed bytes divided by the number of compressed bytes. A value greater than one means that the data is being compressed. This is the compression ratio achieved by the V.42bis encoder running on the Passport. This attribute is relevant for both protocol modes transparent and compressed as the encoder switches between the two modes.')
gsmBcV42bisCompRatioDecoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 10, 1, 8), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisCompRatioDecoder.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisCompRatioDecoder.setDescription('This attribute indicates the number of uncompressed bytes divided by the number of compressed bytes. A value greater than one means that the data is being compressed. This is the compression ratio achieved by the V.42bis encoder at the mobile or Public Switched Telephone Network (PSTN). This attribute is relevant for both protocol modes transparent and compressed as the encoder switches between the two modes.')
gsmBcV42bisStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11), )
if mibBuilder.loadTexts: gsmBcV42bisStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisStatsTable.setDescription('This group contains operational attributes that measure the performance of V.42bis.')
gsmBcV42bisStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcV42bisIndex"))
if mibBuilder.loadTexts: gsmBcV42bisStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisStatsEntry.setDescription('An entry in the gsmBcV42bisStatsTable.')
gsmBcV42bisModeChangesEncode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisModeChangesEncode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisModeChangesEncode.setDescription('This attribute counts the number of mode changes (from transparent to compressed or from compressed to transparent) by the encoder. The counter wraps when it exceeds the maximum value.')
gsmBcV42bisModeChangesDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisModeChangesDecode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisModeChangesDecode.setDescription('This attribute counts the number of mode changes (from transparent to compressed or from compressed to transparent) by the decoder. The mode changes are determined by the encoder at the mobile or the Public Switched Telephone Network (PSTN). The counter wraps when it exceeds the maximum value.')
gsmBcV42bisResetsEncode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisResetsEncode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisResetsEncode.setDescription('This attribute counts the number of resets sent by the encoder. A reset is a command code sent by the encoder to force dictionary reinitialization. The counter wraps when it exceeds the maximum value.')
gsmBcV42bisResetsDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisResetsDecode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisResetsDecode.setDescription('This attribute counts the number of resets received by the decoder. A reset is a command code sent by the encoder to force dictionary reinitialization. The resets of the decoder are determined by the encoder at the mobile or Public Switched Telephone Network (PSTN). The counter wraps when it exceeds the maximum value.')
gsmBcV42bisReInitializations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisReInitializations.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisReInitializations.setDescription('This attribute counts the number of times V.42bis is reinitialized because of a destructive break (a destructive break is a break that causes data to be discarded) occurring on the error-corrected connection initiatated by either the mobile or Public Switched Telephone Network (PSTN). The counter wraps when it exceeds the maximum value.')
gsmBcV42bisErrorsInDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 9, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcV42bisErrorsInDecode.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcV42bisErrorsInDecode.setDescription('This attribute counts the number of errors found by the decoder. The errors could be any of the following: 1.Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). 2. Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). 3. Receipt of a codeword representing an empty dictionary entry. 4. Receipt of a reserved command code. 5. Receipt of any other error. The counter wraps when it exceeds the maximum value. The action taken by V.42bis on detecting any of these errors is provisioned by component GsmIwfV42bis attribute actionOnError.')
gsmBcL2RCop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10))
gsmBcL2RCopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1), )
if mibBuilder.loadTexts: gsmBcL2RCopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcL2RCop components.')
gsmBcL2RCopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcL2RCopIndex"))
if mibBuilder.loadTexts: gsmBcL2RCopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcL2RCop component.')
gsmBcL2RCopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcL2RCop components. These components cannot be added nor deleted.')
gsmBcL2RCopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcL2RCopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopStorageType.setDescription('This variable represents the storage type value for the gsmBcL2RCop tables.')
gsmBcL2RCopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcL2RCopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopIndex.setDescription('This variable represents the index for the gsmBcL2RCop tables.')
gsmBcL2RCopOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 10), )
if mibBuilder.loadTexts: gsmBcL2RCopOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopOperTable.setDescription('This group contains operational attributes that measure the performance of L2RCop.')
gsmBcL2RCopOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcL2RCopIndex"))
if mibBuilder.loadTexts: gsmBcL2RCopOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopOperEntry.setDescription('An entry in the gsmBcL2RCopOperTable.')
gsmBcL2RCopFlowControlStateTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopFlowControlStateTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopFlowControlStateTx.setDescription('This attribute indicates whether flow control is active in the transmit direction (towards the network side) for Layer2 Relay.')
gsmBcL2RCopFlowControlStateRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopFlowControlStateRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopFlowControlStateRx.setDescription('This attribute indicates whether flow control is active in the receive direction (towards the mobile) for Layer2 Relay.')
gsmBcL2RCopStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11), )
if mibBuilder.loadTexts: gsmBcL2RCopStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopStatsTable.setDescription('This group contains operational attributes that measure the performance of L2RCop.')
gsmBcL2RCopStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcL2RCopIndex"))
if mibBuilder.loadTexts: gsmBcL2RCopStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopStatsEntry.setDescription('An entry in the gsmBcL2RCopStatsTable.')
gsmBcL2RCopBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopBytesTx.setDescription('This attribute counts the number of data bytes relayed by Layer2 Relay in the transmit direction (towards the network). The counter wraps when it exceeds the maximum value.')
gsmBcL2RCopBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopBytesRx.setDescription('This attribute counts the number of data bytes relayed by Layer2 Relay in the receive direction (towards the mobile). The counter wraps when it exceeds the maximum value.')
gsmBcL2RCopBreakCountRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopBreakCountRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopBreakCountRx.setDescription('This attribute counts the number of breaks received from the mobile. A break received from the mobile results in the V.42bis function being reset and the break condition forwarded to the network. The counter wraps when it exceeds the maximum value.')
gsmBcL2RCopBreakCountTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 10, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcL2RCopBreakCountTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcL2RCopBreakCountTx.setDescription('This attribute counts the number of breaks transmitted to the mobile (a break was received from the network). A break received from the network results in the V.42bis function being reset and the break condition forwarded to the mobile. The counter wraps when it exceeds the maximum value.')
gsmBcUpperRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11))
gsmBcUpperRelayRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1), )
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatusTable.setDescription('This entry controls the addition and deletion of gsmBcUpperRelay components.')
gsmBcUpperRelayRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcUpperRelayIndex"))
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatusEntry.setDescription('A single entry in the table represents a single gsmBcUpperRelay component.')
gsmBcUpperRelayRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayRowStatus.setDescription('This variable is used as the basis for SNMP naming of gsmBcUpperRelay components. These components cannot be added nor deleted.')
gsmBcUpperRelayComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gsmBcUpperRelayStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayStorageType.setDescription('This variable represents the storage type value for the gsmBcUpperRelay tables.')
gsmBcUpperRelayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gsmBcUpperRelayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayIndex.setDescription('This variable represents the index for the gsmBcUpperRelay tables.')
gsmBcUpperRelayOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 10), )
if mibBuilder.loadTexts: gsmBcUpperRelayOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayOperTable.setDescription('This group contains operational attributes that measure the performance of the UpperRelay.')
gsmBcUpperRelayOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcUpperRelayIndex"))
if mibBuilder.loadTexts: gsmBcUpperRelayOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayOperEntry.setDescription('An entry in the gsmBcUpperRelayOperTable.')
gsmBcUpperRelayBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayBufferSize.setDescription('This attribute indicates the size of the transmit and receive flow control buffers.')
gsmBcUpperRelayFlowControlStateTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayFlowControlStateTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayFlowControlStateTx.setDescription('This attribute indicates whether the transmit flow control is active or not.')
gsmBcUpperRelayFlowControlStateRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayFlowControlStateRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayFlowControlStateRx.setDescription('This attribute indicates whether the receive flow control is active or not.')
gsmBcUpperRelayStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 11), )
if mibBuilder.loadTexts: gsmBcUpperRelayStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayStatsTable.setDescription('This group contains operational attributes that measure the performance of the UpperRelay.')
gsmBcUpperRelayStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcTrunkGrpIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcCicIndex"), (0, "Nortel-Magellan-Passport-GsmIwfMIB", "gsmBcUpperRelayIndex"))
if mibBuilder.loadTexts: gsmBcUpperRelayStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayStatsEntry.setDescription('An entry in the gsmBcUpperRelayStatsTable.')
gsmBcUpperRelayFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayFramesTx.setDescription('This attribute counts the number of frames that are sent in the transmit direction. The counter wraps when it exceeds the maximum value.')
gsmBcUpperRelayFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayFramesRx.setDescription('This attribute counts the number of frames that are sent in the receive direction. The counter wraps when it exceeds the maximum value.')
gsmBcUpperRelayUnacknowledgedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 128, 11, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmBcUpperRelayUnacknowledgedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: gsmBcUpperRelayUnacknowledgedFrames.setDescription('This attribute indicates the number of current frames sent that have not been acknowledged.')
gsmIwfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 1))
gsmIwfGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 1, 5))
gsmIwfGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 1, 5, 2))
gsmIwfGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 1, 5, 2, 2))
gsmIwfCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 3))
gsmIwfCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 3, 5))
gsmIwfCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 3, 5, 2))
gsmIwfCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 129, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-GsmIwfMIB", gsmCsRlp=gsmCsRlp, gsmBcV110IntermediateRate=gsmBcV110IntermediateRate, gsmBcFaxMessageFramesRx=gsmBcFaxMessageFramesRx, gsmBcParity=gsmBcParity, gsmBcL2RCopOperTable=gsmBcL2RCopOperTable, gsmCsLpAssignedCapacity=gsmCsLpAssignedCapacity, gsmBcModemFramingErrors=gsmBcModemFramingErrors, gsmCsRlpMsToIwfWindowSize=gsmCsRlpMsToIwfWindowSize, gsmCsLpActiveCalls=gsmCsLpActiveCalls, gsmBcV42RemoteBusyIndications=gsmBcV42RemoteBusyIndications, gsmBcRlpT1AckTimeouts=gsmBcRlpT1AckTimeouts, gsmBcV42IFramesTx=gsmBcV42IFramesTx, gsmBcRlpLocalBusyIndications=gsmBcRlpLocalBusyIndications, gsmBcCidDataEntry=gsmBcCidDataEntry, gsmIwfCapabilities=gsmIwfCapabilities, gsmBcCallType=gsmBcCallType, gsmBcV42bisMaximumCodewords=gsmBcV42bisMaximumCodewords, gsmBcFramerRowStatusTable=gsmBcFramerRowStatusTable, gsmBcL2RCopBreakCountTx=gsmBcL2RCopBreakCountTx, gsmBcV42RowStatus=gsmBcV42RowStatus, gsmCsChannelModeModifyRequests=gsmCsChannelModeModifyRequests, gsmBcFramerRowStatusEntry=gsmBcFramerRowStatusEntry, gsmBcFramerInterfaceName=gsmBcFramerInterfaceName, gsmBcFaxMessageRate=gsmBcFaxMessageRate, gsmCsV42bisComponentName=gsmCsV42bisComponentName, gsmBcStopBits=gsmBcStopBits, gsmIwfGroupBE01=gsmIwfGroupBE01, gsmBcV42bisLastDecodeError=gsmBcV42bisLastDecodeError, gsmCsRlpProvEntry=gsmCsRlpProvEntry, gsmCsStatsTable=gsmCsStatsTable, gsmBcV42bisModeChangesDecode=gsmBcV42bisModeChangesDecode, gsmCsRlpRowStatus=gsmCsRlpRowStatus, gsmCsRowStatusTable=gsmCsRowStatusTable, gsmBcModemStatsTable=gsmBcModemStatsTable, gsmBcL2RCopStatsEntry=gsmBcL2RCopStatsEntry, gsmCsCallsReleasedAbnormal=gsmCsCallsReleasedAbnormal, gsmCsV42RowStatusEntry=gsmCsV42RowStatusEntry, gsmCsModemRowStatus=gsmCsModemRowStatus, gsmCsV42TxN401FrameSize=gsmCsV42TxN401FrameSize, gsmBcOperationalState=gsmBcOperationalState, gsmBcRlpMsToIwfWindowSize=gsmBcRlpMsToIwfWindowSize, gsmCsV42Index=gsmCsV42Index, gsmCsRowStatusEntry=gsmCsRowStatusEntry, gsmBcV42RxKwindowSize=gsmBcV42RxKwindowSize, gsmBcV110StatsEntry=gsmBcV110StatsEntry, gsmCsLpModemsSupported=gsmCsLpModemsSupported, gsmBcRlpCrcErrorsRx=gsmBcRlpCrcErrorsRx, gsmBcL2RCopOperEntry=gsmBcL2RCopOperEntry, gsmBcTrunkGrpIndex=gsmBcTrunkGrpIndex, gsmCsStatsEntry=gsmCsStatsEntry, gsmBcLayer1StorageType=gsmBcLayer1StorageType, gsmBcV42bisRowStatusTable=gsmBcV42bisRowStatusTable, gsmBcFramerComponentName=gsmBcFramerComponentName, gsmBcV42ProtocolState=gsmBcV42ProtocolState, gsmBcV42bisErrorsInDecode=gsmBcV42bisErrorsInDecode, gsmBcRlpFramesRetransmitted=gsmBcRlpFramesRetransmitted, gsmBcFaxComponentName=gsmBcFaxComponentName, gsmCs=gsmCs, gsmBcFaxBcsFramesTx=gsmBcFaxBcsFramesTx, gsmBcLayer1LrcErrorsTx=gsmBcLayer1LrcErrorsTx, gsmBcRlpT2AckDelayTimer=gsmBcRlpT2AckDelayTimer, gsmBcRlpOperEntry=gsmBcRlpOperEntry, gsmCsV42ProvTable=gsmCsV42ProvTable, gsmBcFramerIndex=gsmBcFramerIndex, gsmBcV42bisOperTable=gsmBcV42bisOperTable, gsmIwfGroupBE01A=gsmIwfGroupBE01A, gsmCsV42bisMaximumCodewords=gsmCsV42bisMaximumCodewords, gsmBcRlpRowStatusEntry=gsmBcRlpRowStatusEntry, gsmBcModemOperEntry=gsmBcModemOperEntry, gsmCsV42ProvEntry=gsmCsV42ProvEntry, gsmCsRlpProvTable=gsmCsRlpProvTable, gsmBcLayer1FramesTx=gsmBcLayer1FramesTx, gsmIwfGroup=gsmIwfGroup, gsmCsCallsSetup=gsmCsCallsSetup, gsmCsAdminState=gsmCsAdminState, gsmBcFramerNonOctetErrors=gsmBcFramerNonOctetErrors, gsmCsStatusMessagesRx=gsmCsStatusMessagesRx, gsmBcRlpInvalidFrames=gsmBcRlpInvalidFrames, gsmBcUpperRelayUnacknowledgedFrames=gsmBcUpperRelayUnacknowledgedFrames, gsmBcRlpIFramesTxDiscarded=gsmBcRlpIFramesTxDiscarded, gsmBcV110RowStatusTable=gsmBcV110RowStatusTable, gsmCsFaxT1CalledToneTimer=gsmCsFaxT1CalledToneTimer, gsmCsVoiceLaw=gsmCsVoiceLaw, gsmCsLp=gsmCsLp, gsmBcL2RCopComponentName=gsmBcL2RCopComponentName, gsmCsV42T401AckTimer=gsmCsV42T401AckTimer, gsmCsV42T400DetectTimer=gsmCsV42T400DetectTimer, gsmBcModemToUpperFlowControlActive=gsmBcModemToUpperFlowControlActive, gsmBcModemStatsEntry=gsmBcModemStatsEntry, gsmBcModemProtocolState=gsmBcModemProtocolState, gsmBcL2RCopStatsTable=gsmBcL2RCopStatsTable, gsmCsProvTable=gsmCsProvTable, gsmBcFramer=gsmBcFramer, gsmBcLayer1RowStatus=gsmBcLayer1RowStatus, gsmBcRlpStatsEntry=gsmBcRlpStatsEntry, gsmBcComponentName=gsmBcComponentName, gsmBcV110UnderRunsTx=gsmBcV110UnderRunsTx, gsmBcFramerLrcErrors=gsmBcFramerLrcErrors, gsmBcFaxRowStatus=gsmBcFaxRowStatus, gsmBcModemBytesTx=gsmBcModemBytesTx, gsmCsV42RxN401FrameSize=gsmCsV42RxN401FrameSize, gsmBcLayer1OverRunsRx=gsmBcLayer1OverRunsRx, gsmBcFramerProvEntry=gsmBcFramerProvEntry, gsmBcModemOperTable=gsmBcModemOperTable, gsmBcV42IFramesRx=gsmBcV42IFramesRx, gsmBcLayer1IntermediateRate=gsmBcLayer1IntermediateRate, gsmBcV110Index=gsmBcV110Index, gsmCsV42bis=gsmCsV42bis, gsmCsLpRowStatusEntry=gsmCsLpRowStatusEntry, gsmBcFramerOperationalState=gsmBcFramerOperationalState, gsmBcLastResponseCode=gsmBcLastResponseCode, gsmBcFramerUnderruns=gsmBcFramerUnderruns, gsmBcV42bisCompRatioDecoder=gsmBcV42bisCompRatioDecoder, gsmBcRlpComponentName=gsmBcRlpComponentName, gsmBcUpperRelayStatsTable=gsmBcUpperRelayStatsTable, gsmBcV42LocalBusyIndications=gsmBcV42LocalBusyIndications, gsmCsV42bisRowStatusTable=gsmCsV42bisRowStatusTable, gsmBcRlpIndex=gsmBcRlpIndex, gsmBcV42StatsTable=gsmBcV42StatsTable, gsmBcLayer1StatsTable=gsmBcLayer1StatsTable, gsmBcModemAutoHdlcMode=gsmBcModemAutoHdlcMode, gsmCsRlpRowStatusEntry=gsmCsRlpRowStatusEntry, gsmBcV110ComponentName=gsmBcV110ComponentName, gsmBcFaxStatsEntry=gsmBcFaxStatsEntry, gsmCsCallsRequested=gsmCsCallsRequested, gsmBcV110StatsTable=gsmBcV110StatsTable, gsmBcLayer1Index=gsmBcLayer1Index, gsmBcLayer1StatsEntry=gsmBcLayer1StatsEntry, gsmBcModemTraining=gsmBcModemTraining, gsmCsRlpStorageType=gsmCsRlpStorageType, gsmBcV42bisReInitializations=gsmBcV42bisReInitializations, gsmCsRlpHighestVersion=gsmCsRlpHighestVersion, gsmBcUpperRelayRowStatusEntry=gsmBcUpperRelayRowStatusEntry, gsmBcV42bisRowStatus=gsmBcV42bisRowStatus, gsmBcV110NonOctetErrorsRx=gsmBcV110NonOctetErrorsRx, gsmBcFaxStatsTable=gsmBcFaxStatsTable, gsmBcV42BadFramesRx=gsmBcV42BadFramesRx, gsmCsProvEntry=gsmCsProvEntry, gsmBcV110RowStatusEntry=gsmBcV110RowStatusEntry, gsmCsCallsReleasedNormal=gsmCsCallsReleasedNormal, gsmBcModemRowStatus=gsmBcModemRowStatus, gsmCsOperationalState=gsmCsOperationalState, gsmCsV42ComponentName=gsmCsV42ComponentName, gsmBcRlp=gsmBcRlp, gsmBcFaxRowStatusTable=gsmBcFaxRowStatusTable, gsmBcFramerFramingType=gsmBcFramerFramingType, gsmBcV42bisOperEntry=gsmBcV42bisOperEntry, gsmCsModemComponentName=gsmCsModemComponentName, gsmBcFaxBcsFramesRx=gsmBcFaxBcsFramesRx, gsmBcV42bisMaximumStringSize=gsmBcV42bisMaximumStringSize, gsmBcUpperRelayStatsEntry=gsmBcUpperRelayStatsEntry, gsmBcV42bisIndex=gsmBcV42bisIndex, gsmBcRlpIwfToMsWindowSize=gsmBcRlpIwfToMsWindowSize, gsmIwfCapabilitiesBE=gsmIwfCapabilitiesBE, gsmBcL2RCopFlowControlStateRx=gsmBcL2RCopFlowControlStateRx, gsmBcUpperRelay=gsmBcUpperRelay, gsmBcV110BytesTx=gsmBcV110BytesTx, gsmBcFaxBcsFrameErrors=gsmBcFaxBcsFrameErrors, gsmBcFaxIndex=gsmBcFaxIndex, gsmBcV42bisCompressionDirection=gsmBcV42bisCompressionDirection, gsmBcModem=gsmBcModem, gsmBcFramerFrmToIf=gsmBcFramerFrmToIf, gsmCsV42RowStatus=gsmCsV42RowStatus, gsmCsFax=gsmCsFax, gsmCsLpComponentName=gsmCsLpComponentName, gsmBcFaxStorageType=gsmBcFaxStorageType, gsmCsRlpIwfToMsWindowSize=gsmCsRlpIwfToMsWindowSize, gsmCsV42bisRowStatus=gsmCsV42bisRowStatus, gsmBcV42T1AckTimeouts=gsmBcV42T1AckTimeouts, gsmBcRlpHighestVersion=gsmBcRlpHighestVersion, gsmBcDataBits=gsmBcDataBits, gsmBcUpperRelayComponentName=gsmBcUpperRelayComponentName, gsmBcFaxRowStatusEntry=gsmBcFaxRowStatusEntry, gsmBcL2RCopRowStatusEntry=gsmBcL2RCopRowStatusEntry, gsmBcV42bisCompRatioEncoder=gsmBcV42bisCompRatioEncoder, gsmIwfGroupBE=gsmIwfGroupBE, gsmBcFaxChannelModeModify=gsmBcFaxChannelModeModify, gsmBcV42bisStorageType=gsmBcV42bisStorageType, gsmBcV42TxN401FrameSize=gsmBcV42TxN401FrameSize, gsmBcLayer1RowStatusTable=gsmBcLayer1RowStatusTable, gsmBcStateTable=gsmBcStateTable, gsmBcV110LrcErrorsTx=gsmBcV110LrcErrorsTx, gsmCsV42RxKwindowSize=gsmCsV42RxKwindowSize, gsmBcLayer1FramesRx=gsmBcLayer1FramesRx, gsmBcV42FramesRetransmitted=gsmBcV42FramesRetransmitted, gsmBcLayer1DataRate=gsmBcLayer1DataRate, gsmBcV42OperTable=gsmBcV42OperTable, gsmBcRowStatusEntry=gsmBcRowStatusEntry, gsmCsCommentText=gsmCsCommentText, gsmCsChannelConfigChanges=gsmCsChannelConfigChanges, gsmBcUpperRelayFlowControlStateRx=gsmBcUpperRelayFlowControlStateRx, gsmCsCustomerIdentifier=gsmCsCustomerIdentifier, gsmBcRlpT1AckTimer=gsmBcRlpT1AckTimer, gsmCsFaxStorageType=gsmCsFaxStorageType, gsmCsCidDataEntry=gsmCsCidDataEntry, gsmBcRlpStatsTable=gsmBcRlpStatsTable, gsmBcV42bisProtocolModeDecoder=gsmBcV42bisProtocolModeDecoder, gsmCsV42RowStatusTable=gsmCsV42RowStatusTable, gsmBcV110FramesTx=gsmBcV110FramesTx, gsmBcRlpRowStatus=gsmBcRlpRowStatus, gsmBcV42CrcErrorsRx=gsmBcV42CrcErrorsRx, gsmBcStorageType=gsmBcStorageType, gsmCsRlpIndex=gsmCsRlpIndex, gsmBcRowStatus=gsmBcRowStatus, gsmBcV42TxKwindowSize=gsmBcV42TxKwindowSize, gsmBcFramerUsageState=gsmBcFramerUsageState, gsmBcStateEntry=gsmBcStateEntry, gsmBcL2RCopStorageType=gsmBcL2RCopStorageType, gsmBcV42bisModeChangesEncode=gsmBcV42bisModeChangesEncode, gsmCsComponentName=gsmCsComponentName, gsmCsVirtualRouterName=gsmCsVirtualRouterName, gsmCsV42bisMaximumStringSize=gsmCsV42bisMaximumStringSize, gsmCsRlpT1AckTimer=gsmCsRlpT1AckTimer, gsmBcV110FramesDiscarded=gsmBcV110FramesDiscarded, gsmBcFaxMessageFramesTx=gsmBcFaxMessageFramesTx, gsmBcV110OperTable=gsmBcV110OperTable, gsmBcFaxPagesRxFromMobile=gsmBcFaxPagesRxFromMobile, gsmCsLpRowStatusTable=gsmCsLpRowStatusTable, gsmBcL2RCopIndex=gsmBcL2RCopIndex, gsmBcModemReceiverTransmitter=gsmBcModemReceiverTransmitter, gsmBcFaxPagesTxToMobile=gsmBcFaxPagesTxToMobile, gsmBcLayer1ComponentName=gsmBcLayer1ComponentName, gsmBcLayer1NonOctetErrorsRx=gsmBcLayer1NonOctetErrorsRx, gsmCsV42T403IdleProbeTimer=gsmCsV42T403IdleProbeTimer, gsmBcFramerStatsEntry=gsmBcFramerStatsEntry, gsmBcUpperRelayRowStatusTable=gsmBcUpperRelayRowStatusTable, gsmCsLpStorageType=gsmCsLpStorageType, gsmBcV110FramesRx=gsmBcV110FramesRx, gsmIwfMIB=gsmIwfMIB, gsmBcLayer1LargeFrameErrorsRx=gsmBcLayer1LargeFrameErrorsRx, gsmBcRlpProtocolState=gsmBcRlpProtocolState, gsmBcV42RowStatusTable=gsmBcV42RowStatusTable, gsmBcV42RxN401FrameSize=gsmBcV42RxN401FrameSize, gsmCsV42StorageType=gsmCsV42StorageType, gsmBcFaxOperTable=gsmBcFaxOperTable, gsmBcUpperRelayRowStatus=gsmBcUpperRelayRowStatus, gsmCsV42=gsmCsV42, gsmBcUsageState=gsmBcUsageState, gsmCsFaxRowStatusTable=gsmCsFaxRowStatusTable, gsmBcModemOutbandFlowControl=gsmBcModemOutbandFlowControl, gsmCsLpOperTable=gsmCsLpOperTable, gsmBcAdminState=gsmBcAdminState, gsmBcModemAsyncMode=gsmBcModemAsyncMode, gsmBcLayer1Connection=gsmBcLayer1Connection, gsmBcV42StatsEntry=gsmBcV42StatsEntry, gsmBcFramerAdminState=gsmBcFramerAdminState, gsmBcUpperRelayStorageType=gsmBcUpperRelayStorageType, gsmCsV42N400RetransLimit=gsmCsV42N400RetransLimit, gsmCsStateTable=gsmCsStateTable, gsmCsErroredMipFrames=gsmCsErroredMipFrames, gsmBcV110OverRunsRx=gsmBcV110OverRunsRx, gsmBcModemComponentName=gsmBcModemComponentName, gsmBcCidDataTable=gsmBcCidDataTable, gsmBcV42bisResetsEncode=gsmBcV42bisResetsEncode)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-GsmIwfMIB", gsmCsCidDataTable=gsmCsCidDataTable, gsmCsV42bisRowStatusEntry=gsmCsV42bisRowStatusEntry, gsmBcV42=gsmBcV42, gsmCsFaxRowStatus=gsmCsFaxRowStatus, gsmBcV42IBytesTx=gsmBcV42IBytesTx, gsmCsV42bisProvTable=gsmCsV42bisProvTable, gsmCsModemRowStatusTable=gsmCsModemRowStatusTable, gsmCsV42bisActionOnError=gsmCsV42bisActionOnError, gsmBcL2RCopRowStatus=gsmBcL2RCopRowStatus, gsmCsRlpRowStatusTable=gsmCsRlpRowStatusTable, gsmBcUpperRelayIndex=gsmBcUpperRelayIndex, gsmBcV42StorageType=gsmBcV42StorageType, gsmCsModemIndex=gsmCsModemIndex, gsmBcModemRowStatusTable=gsmBcModemRowStatusTable, gsmBcLayer1BytesRx=gsmBcLayer1BytesRx, gsmBcModemIndex=gsmBcModemIndex, gsmCsMscIpAddress=gsmCsMscIpAddress, gsmBcL2RCopFlowControlStateTx=gsmBcL2RCopFlowControlStateTx, gsmBcV42bisComponentName=gsmBcV42bisComponentName, gsmBcModemRowStatusEntry=gsmBcModemRowStatusEntry, gsmCsV42bisIndex=gsmCsV42bisIndex, gsmBcOperTable=gsmBcOperTable, gsmBcModemAlgorithmInUse=gsmBcModemAlgorithmInUse, gsmBcUpperRelayFramesTx=gsmBcUpperRelayFramesTx, gsmBcLayer1FramesDiscarded=gsmBcLayer1FramesDiscarded, gsmBcFramerLinkTable=gsmBcFramerLinkTable, gsmBcV110DataRate=gsmBcV110DataRate, gsmBcRlpFrameSize=gsmBcRlpFrameSize, gsmBcV110RowStatus=gsmBcV110RowStatus, gsmCsFaxProvEntry=gsmCsFaxProvEntry, gsmBcLayer1=gsmBcLayer1, gsmBcCustomerIdentifier=gsmBcCustomerIdentifier, gsmCsV42T402AckDelayTimer=gsmCsV42T402AckDelayTimer, gsmBcRlpStorageType=gsmBcRlpStorageType, gsmBcFramerOctetFromIf=gsmBcFramerOctetFromIf, gsmBcRlpOperTable=gsmBcRlpOperTable, gsmCsFaxRowStatusEntry=gsmCsFaxRowStatusEntry, gsmIwfCapabilitiesBE01A=gsmIwfCapabilitiesBE01A, gsmBcV42bisStatsEntry=gsmBcV42bisStatsEntry, gsmBcOperEntry=gsmBcOperEntry, gsmCsRlpN2RetransmitCount=gsmCsRlpN2RetransmitCount, gsmCsCallsActivated=gsmCsCallsActivated, gsmBcV42bisResetsDecode=gsmBcV42bisResetsDecode, gsmBcV42IBytesRx=gsmBcV42IBytesRx, gsmBcFlowControl=gsmBcFlowControl, gsmBcL2RCop=gsmBcL2RCop, gsmBcLayer1BytesTx=gsmBcLayer1BytesTx, gsmBcModemOutbandBreak=gsmBcModemOutbandBreak, gsmCsStorageType=gsmCsStorageType, gsmCsFaxComponentName=gsmCsFaxComponentName, gsmBcMaxUserDataRate=gsmBcMaxUserDataRate, gsmBcV42Index=gsmBcV42Index, gsmBcV42RowStatusEntry=gsmBcV42RowStatusEntry, gsmBcLayer1RowStatusEntry=gsmBcLayer1RowStatusEntry, gsmCsV42bisCompressionDirection=gsmCsV42bisCompressionDirection, gsmBcFramerCrcErrors=gsmBcFramerCrcErrors, gsmBcFramerLinkEntry=gsmBcFramerLinkEntry, gsmBcFaxOperEntry=gsmBcFaxOperEntry, gsmBcLayer1OperTable=gsmBcLayer1OperTable, gsmBcUpperRelayFlowControlStateTx=gsmBcUpperRelayFlowControlStateTx, gsmBcFramerFrmFromIf=gsmBcFramerFrmFromIf, gsmCsModem=gsmCsModem, gsmCsRowStatus=gsmCsRowStatus, gsmBcRlpIFramesRx=gsmBcRlpIFramesRx, gsmCsV42bisStorageType=gsmCsV42bisStorageType, gsmBcL2RCopBytesRx=gsmBcL2RCopBytesRx, gsmBcV42bisRowStatusEntry=gsmBcV42bisRowStatusEntry, gsmBcRlpN2RetransmitCount=gsmBcRlpN2RetransmitCount, gsmCsV42bisProvEntry=gsmCsV42bisProvEntry, gsmBcV42bisProtocolModeEncoder=gsmBcV42bisProtocolModeEncoder, gsmCsStateEntry=gsmCsStateEntry, gsmBcMateBearerChannel=gsmBcMateBearerChannel, gsmBcConnectionType=gsmBcConnectionType, gsmIwfCapabilitiesBE01=gsmIwfCapabilitiesBE01, gsmBcModemAutobaud=gsmBcModemAutobaud, gsmBcModemBytesRx=gsmBcModemBytesRx, gsmBcFramerStateTable=gsmBcFramerStateTable, gsmBcV110=gsmBcV110, gsmCsFaxIndex=gsmCsFaxIndex, gsmCsUsageState=gsmCsUsageState, gsmBcRlpRemoteBusyIndications=gsmBcRlpRemoteBusyIndications, gsmCsLpOperEntry=gsmCsLpOperEntry, gsmBcCicIndex=gsmBcCicIndex, gsmBcUpperRelayBufferSize=gsmBcUpperRelayBufferSize, gsmBcRlpOutOfSequenceFrames=gsmBcRlpOutOfSequenceFrames, gsmBcFramerStorageType=gsmBcFramerStorageType, gsmBcV110LargeFrameErrorsRx=gsmBcV110LargeFrameErrorsRx, gsmBcFax=gsmBcFax, gsmBcV110StorageType=gsmBcV110StorageType, gsmCsFaxProvTable=gsmCsFaxProvTable, gsmBcModemToDspFlowControlActive=gsmBcModemToDspFlowControlActive, gsmBcRlpResetsRx=gsmBcRlpResetsRx, gsmCsModemRowStatusEntry=gsmCsModemRowStatusEntry, gsmBc=gsmBc, gsmBcFaxProtocolState=gsmBcFaxProtocolState, gsmBcV42bisStatsTable=gsmBcV42bisStatsTable, gsmBcMipState=gsmBcMipState, gsmBcFramerStateEntry=gsmBcFramerStateEntry, gsmBcLayer1UnderRunsTx=gsmBcLayer1UnderRunsTx, gsmBcV42bis=gsmBcV42bis, gsmBcRowStatusTable=gsmBcRowStatusTable, gsmBcModemStorageType=gsmBcModemStorageType, gsmBcFramerRowStatus=gsmBcFramerRowStatus, gsmCsRlpT2AckDelayTimer=gsmCsRlpT2AckDelayTimer, gsmCsLpIndex=gsmCsLpIndex, gsmCsCurrentCalls=gsmCsCurrentCalls, gsmBcUpperRelayFramesRx=gsmBcUpperRelayFramesRx, gsmCsLpRowStatus=gsmCsLpRowStatus, gsmBcRlpRowStatusTable=gsmBcRlpRowStatusTable, gsmBcLayer1OperEntry=gsmBcLayer1OperEntry, gsmBcL2RCopBytesTx=gsmBcL2RCopBytesTx, gsmBcUpperRelayOperTable=gsmBcUpperRelayOperTable, gsmBcUpperRelayOperEntry=gsmBcUpperRelayOperEntry, gsmCsModemStorageType=gsmCsModemStorageType, gsmBcV42ComponentName=gsmBcV42ComponentName, gsmBcFramerOverruns=gsmBcFramerOverruns, gsmBcModemRate=gsmBcModemRate, gsmBcL2RCopRowStatusTable=gsmBcL2RCopRowStatusTable, gsmCsRlpComponentName=gsmCsRlpComponentName, gsmBcLayer1ActiveMode=gsmBcLayer1ActiveMode, gsmBcV42OperEntry=gsmBcV42OperEntry, gsmBcV110OperEntry=gsmBcV110OperEntry, gsmBcV110BytesRx=gsmBcV110BytesRx, gsmBcRlpIFramesTx=gsmBcRlpIFramesTx, gsmBcL2RCopBreakCountRx=gsmBcL2RCopBreakCountRx, gsmCsLpConfiguredBearerChannels=gsmCsLpConfiguredBearerChannels, gsmCsTrunkGrpIndex=gsmCsTrunkGrpIndex, gsmBcFramerStatsTable=gsmBcFramerStatsTable, gsmBcFramerProvTable=gsmBcFramerProvTable, gsmBcFaxActiveMode=gsmBcFaxActiveMode, gsmCsV42TxKwindowSize=gsmCsV42TxKwindowSize)

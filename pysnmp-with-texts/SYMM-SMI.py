#
# PySNMP MIB module SYMM-SMI (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYMM-SMI
# Produced by pysmi-0.3.4 at Wed May  1 15:14:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, NotificationType, IpAddress, ModuleIdentity, Integer32, Gauge32, TimeTicks, Counter32, Bits, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, MibIdentifier, Unsigned32, ObjectIdentity, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "NotificationType", "IpAddress", "ModuleIdentity", "Integer32", "Gauge32", "TimeTicks", "Counter32", "Bits", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "MibIdentifier", "Unsigned32", "ObjectIdentity", "enterprises")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
symmetricom = ModuleIdentity((1, 3, 6, 1, 4, 1, 9070))
symmetricom.setRevisions(('1910-02-06 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: symmetricom.setRevisionsDescriptions(('jflory - updated NTP, tyming, and etc descriptions',))
if mibBuilder.loadTexts: symmetricom.setLastUpdated('1002061200Z')
if mibBuilder.loadTexts: symmetricom.setOrganization('Symmetricom, Inc.')
if mibBuilder.loadTexts: symmetricom.setContactInfo(' Symmetricom, Inc. 2300 Orchard Parkway San Jose, CA 95131')
if mibBuilder.loadTexts: symmetricom.setDescription("This is the MIB Module for Symmetricom's enterprise specific parameters.")
symmNetworkManagement = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1))
if mibBuilder.loadTexts: symmNetworkManagement.setStatus('current')
if mibBuilder.loadTexts: symmNetworkManagement.setDescription('This is the root object identifier for all MIBS under the Symmetricom tree.')
symmCmipManagement = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 1))
if mibBuilder.loadTexts: symmCmipManagement.setStatus('current')
if mibBuilder.loadTexts: symmCmipManagement.setDescription('This is the root object identifier for CMIP based objects.')
symmSnmpManagement = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2))
if mibBuilder.loadTexts: symmSnmpManagement.setStatus('current')
if mibBuilder.loadTexts: symmSnmpManagement.setDescription('This is the root object identifier for SNMP based objects.')
symmTimePictra = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2, 1))
if mibBuilder.loadTexts: symmTimePictra.setStatus('current')
if mibBuilder.loadTexts: symmTimePictra.setDescription("This is reserved for objects related to Symmetricom's TimePictra products.")
symmBroadband = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2, 2))
if mibBuilder.loadTexts: symmBroadband.setStatus('current')
if mibBuilder.loadTexts: symmBroadband.setDescription("The subtree that contains objects related to Symmetricom's GoWide products.")
symmTTM = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3))
if mibBuilder.loadTexts: symmTTM.setStatus('current')
if mibBuilder.loadTexts: symmTTM.setDescription("The subtree that contains objects related to Symmetricom's Timing, Test and Measurement products.")
products = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1))
experiment = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 99))
ts2000 = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 1))
nts = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 2))
ts2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 3))
s100 = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 4))
syncserver = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5))
xli = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 6))
version = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1))
ntpSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1))
tyming = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2))
gps = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3))
dialup = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 4))
net = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 5))
etc = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6))
ntpSysLeap = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noWarning", 0), ("addSecond", 1), ("subtractSecond", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysLeap.setStatus('current')
if mibBuilder.loadTexts: ntpSysLeap.setDescription('NTP Leap Indicator. This is a two-bit code warning of an impending leap second to be inserted into the NTP timescale. The bits are set before 23:59 on the day of insertion and reset after 00:00 on the following day. This causes the number of seconds (rollover interval) in the day of insertion to be increased or decreased by one. In the case of primary servers the bits are set by operator intervention, while in the case of secondary servers the bits are set by the protocol. The two bits, bit 0 and bit 1, respectively, are coded as follows: =================================================== 00 no warning 01 last minute has 61 seconds 10 last minute has 59 seconds 11 alarm condition(clock not synchronized) =================================================== In all except the alarm condition(11), NTP itself does nothing with these bits, except pass them on to the time-conversion routines that are not part of NTP. The alarm condition occurs when, for whatever reason, the local clock is not synchronized, such as when first coming up or after an extended period when no primary reference source is available.')
ntpSysStratum = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysStratum.setStatus('current')
if mibBuilder.loadTexts: ntpSysStratum.setDescription('Current NTP stratum level. This is an integer indicating the stratum of the local clock with values defined as follows: ================================================ 0 unspecified 1 primary reference (e.g., calibrated atomic clock, radio clock) 2-255 secondary reference (via NTP) ================================================')
ntpSysPrecision = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPrecision.setStatus('current')
if mibBuilder.loadTexts: ntpSysPrecision.setDescription('Current NTP precision value. This is a signed integer indicating the precision of the various clocks, in seconds to the nearest power of two. The value must be rounded to the next larger power of two; for instance, a 50-Hz (20ms) or 60-Hz (16.17ms) power-frequency clock would be assigned the value -5 (31.25ms), while a 1000-Hz (1ms) crystal-controlled clock would be assigned the value -9 (1.95ms).')
ntpSysRootDelay = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysRootDelay.setStatus('current')
if mibBuilder.loadTexts: ntpSysRootDelay.setDescription('Total roundtrip delay to the primary reference source at the root of the synchronization subnet, in seconds')
ntpSysRootDispersion = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysRootDispersion.setStatus('current')
if mibBuilder.loadTexts: ntpSysRootDispersion.setDescription('Maximum error relative to the primary reference source at the root of the synchronization subnet, in seconds. Only positive values greater than zero are possible')
ntpSysRefID = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysRefID.setStatus('current')
if mibBuilder.loadTexts: ntpSysRefID.setDescription('NTP Reference Clock Identifier. This is a 32 bit code identifying the particular reference clock. In the case of stratum 0 (unspecified) or stratum 1 (primary reference), this is a four- octet, left-justified, zero-padded ASCII string. While not enumerated as part of the NTP spec, the following are suggested ASCII identifiers: ============================================== DCN DCN routing protocol NIST NIST public modem TSP TSP time protocol DTS Digital Time Service ATOM Atomic clock (calibrated) VLF VLF radio (OMEGA,etc.) callsign Generic radio LORC LORAN-C radionavigation GOES GOES UHF environment satellite GPS GPS UHF satellite positioning ============================================== The following ref ids are used by the SyncServer: ============================================== GPS GPS satellite) IRIG IRIG B timecode 1PPS Ext. 1 PPS input E10M Ext. 10 MHz input FREE Internal Clock FLY Internal Clock after the Hardware Clock reference is lost ==============================================')
ntpSysRefTime = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysRefTime.setStatus('current')
if mibBuilder.loadTexts: ntpSysRefTime.setDescription('NTP Reference Timestamp. This is the time, in timestamp format (converted to DisplayString), when the local clock was last updated. If the local clock has never been synchronized, the value is zero.')
ntpSysPoll = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPoll.setStatus('current')
if mibBuilder.loadTexts: ntpSysPoll.setDescription('Minimum interval between transmitted messages, in seconds as a power of two. For instance, a value of six indicates a minimum interval of 64 seconds.')
ntpSysPeer = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPeer.setStatus('current')
if mibBuilder.loadTexts: ntpSysPeer.setDescription('Current synchronization source. In stratum > 1 this variable returns the decimal representation of the IPv4 address of its current peer. In stratum = 1 this variable returns the decimal representation of the hardware clock which is 2981759.')
ntpSysPhase = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPhase.setStatus('current')
if mibBuilder.loadTexts: ntpSysPhase.setDescription('System clock offset from the selected source.')
ntpSysFreq = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysFreq.setStatus('current')
if mibBuilder.loadTexts: ntpSysFreq.setDescription('System clock frequency correction from ntpd.')
ntpSysError = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysError.setStatus('current')
if mibBuilder.loadTexts: ntpSysError.setDescription('Current system error from ntpd.')
ntpSysClock = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysClock.setStatus('current')
if mibBuilder.loadTexts: ntpSysClock.setDescription('Current system time from ntpd. This is usually derived from the hardware clock but could be from any other ntp source.')
ntpSysSystem = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysSystem.setStatus('current')
if mibBuilder.loadTexts: ntpSysSystem.setDescription('Description of the current system.')
ntpSysProcessor = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysProcessor.setStatus('current')
if mibBuilder.loadTexts: ntpSysProcessor.setDescription('Type of local processor.')
ntpSysNotrust = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysNotrust.setStatus('mandatory')
if mibBuilder.loadTexts: ntpSysNotrust.setDescription('Force authentication.')
ntpSysPktsReceived = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPktsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ntpSysPktsReceived.setDescription('This variable is a rollover counter which reflects the number of ntp packets received by the SyncServer. It is valid for all versions of the SyncServer.')
ntpSysMode = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unspecified", 0), ("symactive", 1), ("sympassive", 2), ("client", 3), ("server", 4), ("broadcast", 5), ("reservedctl", 6), ("reservedpriv", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysMode.setStatus('mandatory')
if mibBuilder.loadTexts: ntpSysMode.setDescription('An integer indicating the NTP association mode and are coded as follows: ============================================ 0 unspecified 1 symmetric active 2 symmetric passive 3 client 4 server 5 broadcast 6 reserved for NTP control messages 7 reserved for private use ============================================')
ntpSysVersion = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysVersion.setStatus('current')
if mibBuilder.loadTexts: ntpSysVersion.setDescription('The version of the NTP daemon on the system.')
tymingStatus = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tymingStatus.setStatus('current')
if mibBuilder.loadTexts: tymingStatus.setDescription('Indicates what status the Hardware Clock considers itself to be as a timing source defined as follows: ============================================ Good HW Clock has a valid time reference. Bad HW Clock has no valid time reference. ============================================')
tymingSource = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tymingSource.setStatus('current')
if mibBuilder.loadTexts: tymingSource.setDescription('The time or frequency source currently in use by the Hardware Clock defined as follows: ============================================ 0 None 1 GPS 4 NTP 8 IRIG 16 External 1PPS 24 External 10 MHz 31 Freerun mode. ============================================')
tymingTime = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tymingTime.setStatus('current')
if mibBuilder.loadTexts: tymingTime.setDescription('The time according to the Hardware Clock in the format of: WWW MMM dd hh:mm:ss yyyy defined as follows: ============================================ WWW weekday MMM character month dd day of month hh:mm:ss time yyyy year Example Thu Sep 21 23:46:09 2006 ============================================')
tymingVersion = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tymingVersion.setStatus('current')
if mibBuilder.loadTexts: tymingVersion.setDescription("The version of the software on the SyncServer's Hardware Clock.")
tymingFlyPeriod = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tymingFlyPeriod.setStatus('current')
if mibBuilder.loadTexts: tymingFlyPeriod.setDescription('This variable is not currently used and returns zero.')
gpsPosition = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsPosition.setStatus('current')
if mibBuilder.loadTexts: gpsPosition.setDescription('Returns the current position in the format of: A BB CC DD EEE F GGG HH II JJJ KK defined as follows: =============================================== A sign of the latitude (1 = North, -1 = South) BB degrees of the latitude CC minutes of the latitude DD seconds of the latitude EEE milliseconds of the latitude F sign of the longitude (1 = East, -1 = West) GGG degrees of the longitude HH minutes of the longitude II seconds of the longitude JJJ milliseconds of the longitude KK altitude in meters ===============================================')
gpsUTCOffset = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsUTCOffset.setStatus('current')
if mibBuilder.loadTexts: gpsUTCOffset.setDescription('This variable returns the current offset between the monotonic time maintained by the GPS satellite constellation and UTC time. This value is commonly referred to as the leap second count. It is only valid on a Syncserver with GPS.')
gpsHealth = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsHealth.setStatus('current')
if mibBuilder.loadTexts: gpsHealth.setDescription("This is the GPS receiver health status defined as follows: ====================================================== 0 = Receiver Down The Hardware Clock can't communicate with the receiver. 1 = No Signal 2 = Acquiring Signal The receiver is tracking a GPS signal. 3 = 2d Position mode The receiver is able to perform position fixes for latitude and longitude but does not have enough satellites for altitude. 4 = 3d Position mode The receiver is now able to perform position fixes for latitude, longitude and altitude. 5 = Position Hold mode Position fixes are no longer attempted, and the user entered or surveyed position is used. 6 = Time Valid mode The receiver has valid timing information from GPS satellites (including current leap second information). This is the final state for all configured GPS modes. ======================================================")
gpsSatlist = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsSatlist.setStatus('current')
if mibBuilder.loadTexts: gpsSatlist.setDescription('Displays the GPS satellite tracking information in the format of: N,X1,Y1,Z1,...,XN,YN,ZN defined as follows: ====================================================== N Number of satellites. If one or more satellites are available, Xi,Yi,Zi follows N. Xi Satellite vehicle number. Yi Satellite signal strength in dBW where less than -200 dBW means no signal. Zi Zi can be either T or C. T(racking) means the SyncServer receives the information from the satellite but the information is not used in its timing solution. C(urrent) means the SyncServer currently uses satellite information in its timing solution. Examples For no satellites: 0 For one satellite with vehicle number 16: 1,16,C,-158 For six satellites: 6,12,C,-156,14,C,-155,8,T,-162,24,C,-158,18,C,161,6,C,-160 ======================================================')
gpsMode = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsMode.setStatus('current')
if mibBuilder.loadTexts: gpsMode.setDescription("The mode of the GPS receiver defined as follows: ====================================================== Receiver Mode: Survey. The receiver is surveying and averaging its position. When it has finished surveying, the receiver switches to Position Hold mode. Survey mode and Position Hold mode are appropriate for static applications, such as a typical server room environment. This is the default mode when the SyncServer starts. Receiver Mode: Dynamic. The GPS receiver surveys continuously to determine its position and doesn't switch to another mode. This mode must be initiated by a user, and is appropriate for mobile applications such as ships, land vehicles, and aircraft. The degree of accuracy this mode offers is fine for NTP time over networks, but is less than optimal for the IRIG-B, 1 PPS, 10 MHz outputs available on some SyncServer models. Receiver Mode: Hold. The GPS receiver has completed Survey mode and switched to this mode, or the user has manually entered a position and forced it into this mode. The accuracy and stability of the SyncServer's timing outputs are optimal when the receiver has its exact position and is in this mode. ======================================================")
etcVersion = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcVersion.setStatus('current')
if mibBuilder.loadTexts: etcVersion.setDescription('Version info for SyncServer system.')
etcSerialNbr = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcSerialNbr.setStatus('current')
if mibBuilder.loadTexts: etcSerialNbr.setDescription('Unique serial number factory programmed into each unit.')
etcModel = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcModel.setStatus('current')
if mibBuilder.loadTexts: etcModel.setDescription('Model type factory programmed into each unit.')
etcUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcUpgrade.setStatus('current')
if mibBuilder.loadTexts: etcUpgrade.setDescription('Describes whether or not an upgrade is available from the upgrade server described as follows: ====================================================== 0 No upgrade is available. 1 An upgrade is available. ======================================================')
etcUpgradeServer = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcUpgradeServer.setStatus('current')
if mibBuilder.loadTexts: etcUpgradeServer.setDescription('Address of the server where new upgrades can be downloaded.')
etcAlarmString = MibScalar((1, 3, 6, 1, 4, 1, 9070, 1, 2, 3, 1, 5, 1, 6, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etcAlarmString.setStatus('current')
if mibBuilder.loadTexts: etcAlarmString.setDescription('Defines the format for the system alarm traps. This is only valid embedded in a trap message.')
etcAlarm = NotificationType((1, 3, 6, 1, 4, 1, 9070) + (0,0)).setObjects(("SYMM-SMI", "etcAlarmString"))
if mibBuilder.loadTexts: etcAlarm.setDescription('The trap provides notification of Hardware Clock, NTP, system, and network alarms events. The user can configure which alarms send traps on the ADMIN - Alarms page.')
mibBuilder.exportSymbols("SYMM-SMI", ntpSysFreq=ntpSysFreq, gpsHealth=gpsHealth, ntpSysRootDispersion=ntpSysRootDispersion, symmSnmpManagement=symmSnmpManagement, gpsMode=gpsMode, gpsSatlist=gpsSatlist, tymingSource=tymingSource, tymingStatus=tymingStatus, etcAlarmString=etcAlarmString, etcUpgradeServer=etcUpgradeServer, gpsUTCOffset=gpsUTCOffset, ntpSysPktsReceived=ntpSysPktsReceived, ntpSysRootDelay=ntpSysRootDelay, ntpSysMode=ntpSysMode, tymingFlyPeriod=tymingFlyPeriod, tymingVersion=tymingVersion, etc=etc, xli=xli, tymingTime=tymingTime, ntpSysPoll=ntpSysPoll, PYSNMP_MODULE_ID=symmetricom, ntpSysStratum=ntpSysStratum, etcVersion=etcVersion, gps=gps, ts2000=ts2000, ntpSysPrecision=ntpSysPrecision, ntpSysVersion=ntpSysVersion, etcUpgrade=etcUpgrade, ntpSysClock=ntpSysClock, ntpSysNotrust=ntpSysNotrust, version=version, symmNetworkManagement=symmNetworkManagement, symmTTM=symmTTM, ntpSysPeer=ntpSysPeer, symmetricom=symmetricom, products=products, ntpSysError=ntpSysError, symmTimePictra=symmTimePictra, ntpSysPhase=ntpSysPhase, dialup=dialup, ntpSysProcessor=ntpSysProcessor, etcModel=etcModel, s100=s100, experiment=experiment, symmCmipManagement=symmCmipManagement, ntpSysLeap=ntpSysLeap, etcAlarm=etcAlarm, tyming=tyming, ntpSystem=ntpSystem, ntpSysRefID=ntpSysRefID, nts=nts, syncserver=syncserver, net=net, ntpSysSystem=ntpSysSystem, gpsPosition=gpsPosition, etcSerialNbr=etcSerialNbr, symmBroadband=symmBroadband, ts2100=ts2100, ntpSysRefTime=ntpSysRefTime)

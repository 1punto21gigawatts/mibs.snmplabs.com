#
# PySNMP MIB module Novell-LANtern-Admin-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Novell-LANtern-Admin-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, ModuleIdentity, Integer32, IpAddress, MibIdentifier, Gauge32, Unsigned32, Bits, enterprises, NotificationType, Counter32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "ModuleIdentity", "Integer32", "IpAddress", "MibIdentifier", "Gauge32", "Unsigned32", "Bits", "enterprises", "NotificationType", "Counter32", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
novell = MibIdentifier((1, 3, 6, 1, 4, 1, 23))
productType = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 1))
mibDoc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2))
networkMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 1, 1))
ethernetLANtern = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 1, 1, 1))
lantern = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 1))
lanternAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 1, 1))
class Time(Integer32):
    pass

class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

class Seconds(Integer32):
    pass

adminIdentification = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminIdentification.setStatus('mandatory')
if mibBuilder.loadTexts: adminIdentification.setDescription('An identifying ASCII string may be attached to the LANtern network monitor by writing adminIdentification. Conversely, the LANtern network monitor may be identified by reading adminIdentification. adminIdentification is stored in nonvolatile RAM.')
adminDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 2), Time()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDateAndTime.setStatus('mandatory')
if mibBuilder.loadTexts: adminDateAndTime.setDescription("Reading adminDateAndTime returns the current date and time in use by the LANtern network monitor. The LANtern network monitor's date and time may be adjusted at any time by writing to adminDateAndTime. However, although the new value is updated correctly as time advances, it does not replace the previous value until the LANtern network monitor is restarted. adminDateAndTime is stored in the clock/calendar chip.")
adminTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminTimeZone.setStatus('mandatory')
if mibBuilder.loadTexts: adminTimeZone.setDescription('A DisplayString defining the time zone of the LANtern network monitor. adminTimeZone is neither parsed nor used by the LANtern network monitor, it is merely stored and divulged upon request. It is strongly recommended that adminTimeZone be used to store time zone information in a manner identical to the UNIX System V time zone environment variable (TZ). This standard approach would permit interoperability with network management consoles from multiple vendors. adminTimeZone is stored in nonvolatile RAM.')
adminPowerOnTime = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 4), Time()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminPowerOnTime.setStatus('mandatory')
if mibBuilder.loadTexts: adminPowerOnTime.setDescription('The date and time when the LANtern network monitor was last powered on or restarted.')
adminPowerOffTime = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 5), Time()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminPowerOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: adminPowerOffTime.setDescription('The date and time when the LANtern network monitor was last powered off or restarted. The value is 0 (midnight, 1 January 1900) after a cold start.')
adminNetworkDataLink = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ethernetDIX", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNetworkDataLink.setStatus('mandatory')
if mibBuilder.loadTexts: adminNetworkDataLink.setDescription('The type of data link encapsulation to be used on the monitored network. adminNetworkDataLink may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminNetworkDataLink is read, it returns the value currently in use, regardless of any previous writes. adminNetworkDataLink is stored in nonvolatile RAM.')
adminNetworkIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 7), IpAddress().clone(hexValue="c044cd01")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNetworkIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminNetworkIPAddr.setDescription('The IP address to be used by the LANtern network monitor on the monitored network. adminNetworkIPAddr may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminNetworkIPAddr is read, it returns the IP address currently in use, regardless of any previous writes. adminNetworkIPAddr is stored in nonvolatile RAM. On start up, if the LANtern does not have an IP address, it will attempt to acquire one via BOOTP and/or RARP. If neither method is successful, the address 192.68.205.1 is used.')
adminNetworkSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 8), IpAddress().clone(hexValue="ffffff80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNetworkSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminNetworkSubnetMask.setDescription('The subnet mask for the monitored network. adminNetworkSubnetMask may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminNetworkSubnetMask is read, it returns the subnet mask currently in use, regardless of any previous writes. adminNetworkSubnetMask is stored in nonvolatile RAM. When the value 0.0.0.0 is stored in this variable, the LANtern assumes no subnetting. This value is acquired via BOOTP if the value of adminNetworkIPAddr is acquired via BOOTP. If neither BOOTP nor RARP succeeds in acquiring adminNetworkIPAddr, the value 255.255.255.128 is used')
adminNetworkGateway = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNetworkGateway.setStatus('mandatory')
if mibBuilder.loadTexts: adminNetworkGateway.setDescription("The IP address of a gateway directly connected to the monitored network (the LANtern network monitor's default gateway). adminNetworkGateway may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminNetworkGateway is read it returns the gateway IP address currently in use, regardless of any previous writes. adminNetworkGateway is stored in nonvolatile RAM.")
adminClientTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10), )
if mibBuilder.loadTexts: adminClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientTable.setDescription('A table providing data on all authorized LANtern clients. The table is accessed by adminClientIPAddr. A new entry may be created by writing to a nonexistent instance. Note that adminClientIPAddr is set implicitly from this write; it cannot be written directly. An entry may subsequently be deleted by writing (any value) to adminClientDelete. adminClientTable is stored in nonvolatile RAM. Default: a single entry with: adminClientIPAddr.0.0.0.0=0.0.0.0, adminClientIPMask.0.0.0.0=0.0.0.0, adminClientCommunities.0.0.0.0=7')
adminClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10, 1), ).setIndexNames((0, "Novell-LANtern-Admin-MIB", "adminClientIPAddr"))
if mibBuilder.loadTexts: adminClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientEntry.setDescription('Data about each authorized client.')
adminClientIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminClientIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientIPAddr.setDescription('The IP address (or portion thereof) of a station authorized to access the LANtern network monitor.')
adminClientIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10, 1, 2), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminClientIPMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientIPMask.setDescription("A 32-bit mask that is bitwise anded with the candidate client's IP address before attempting to match against adminClientIPAddr.")
adminClientCommunities = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10, 1, 3), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminClientCommunities.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientCommunities.setDescription('A bit array where the presence of a particular bit indicates that use of that particular community name is permitted. Bit Community 2^0 administrator 2^1 logger 2^2 monitor.')
adminClientDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 10, 1, 4), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: adminClientDelete.setStatus('mandatory')
if mibBuilder.loadTexts: adminClientDelete.setDescription('A write (any value) causes the table entry to be deleted.')
adminUnauthorizedIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: adminUnauthorizedIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminUnauthorizedIPAddr.setDescription('The IP address of the station that generated the authentication failure.')
adminUnauthorizedCommunity = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 12), OctetString())
if mibBuilder.loadTexts: adminUnauthorizedCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: adminUnauthorizedCommunity.setDescription('The community name string used in the PDU that generated the authentication failure.')
adminNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13), )
if mibBuilder.loadTexts: adminNotificationTable.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationTable.setDescription('A list of all stations wishing to receive traps from the LANtern network monitor; accessed by adminNotificationIPAddr. A new entry may be created by writing to a nonexistent instance. Note that adminNotificationIPAddr is set implicitly from this write; it cannot be written directly. An entry may subsequently be deleted by writing (any value) to adminNotificationDelete adminNotificationTable is stored in nonvolatile RAM.')
adminNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1), ).setIndexNames((0, "Novell-LANtern-Admin-MIB", "adminNotificationIPAddr"))
if mibBuilder.loadTexts: adminNotificationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationEntry.setDescription('Data for each station on the notification list.')
adminNotificationIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminNotificationIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationIPAddr.setDescription('The IP address of the station wishing to receive traps from the LANtern network monitor.')
adminNotificationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primaryContact", 1), ("backupContact", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationStatus.setDescription('Traps are sent to all primaryContacts who have the corresponding bit set in adminNotificationTrapMask. Traps are sent to backupContacts only if they have the corresponding bit set in adminNotificationTrapMask and if a confirmed delivery to a station naming it as backup failed. Default: primaryContact(1)')
adminNotificationTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationTrapMask.setDescription('A bit array specifying which traps the station wishes to receive. Bit Trap 2^0 warmStart 2^1 cableFailure 2^2 reserved 2^3 duplicateIPAddr 2^4 utilizationAlarm 2^5 errorsAlarm 2^6 broadcastsAlarm 2^7 collisionsAlarm 2^8 authenticationFailure 2^9 hostInactive 2^10 hostActive 2^11 newHost 2^12 hostLimitExceeded')
adminNotificationConfirmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationConfirmMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationConfirmMask.setDescription('A bit array specifying which traps the station wishes to receive with confirmed delivery. Any bits set must also be set in adminNotificationTrapMask. If a trap sent with confirmed delivery is not acknowledged within adminNotificationTimeout seconds it is sent again. After adminNotificationRetries attempts to deliver the trap, the LANtern network monitor gives up, and tries to deliver it to the station specified by adminNotificationBackup.')
adminNotificationTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 5), Seconds().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationTimeout.setDescription('For traps with confirmed delivery, adminNotificationTimeout specifies the interval (in seconds) between retries.')
adminNotificationRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 6), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationRetries.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationRetries.setDescription('For traps with confirmed delivery, adminNotificationRetries specifies the number of retries that should be attempted before giving up and trying to deliver the trap to adminNotificationBackupIPAddr.')
adminNotificationBackupIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminNotificationBackupIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationBackupIPAddr.setDescription('For traps with confirmed delivery, adminNotificationBackupIPAddr specifies the IP address of a backup station (also in adminNotificationTable) to be contacted should delivery of the trap to this station fail. Default: 0.0.0.0 (no backup)')
adminNotificationDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 13, 1, 8), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: adminNotificationDelete.setStatus('mandatory')
if mibBuilder.loadTexts: adminNotificationDelete.setDescription('A write (any value) causes the table entry to be deleted.')
adminTrapHandle = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 14), Integer32())
if mibBuilder.loadTexts: adminTrapHandle.setStatus('mandatory')
if mibBuilder.loadTexts: adminTrapHandle.setDescription('A unique handle that is generated for each trap issued and that is passed in the trap-PDU along with any other variable bindings.')
adminTrapAcknowledge = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 15), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: adminTrapAcknowledge.setStatus('mandatory')
if mibBuilder.loadTexts: adminTrapAcknowledge.setDescription('A trap is acknowledged by writing the value of adminTrapHandle passed in the trap-PDU to adminTrapAcknowledge.')
adminDownLoadFile = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDownLoadFile.setStatus('mandatory')
if mibBuilder.loadTexts: adminDownLoadFile.setDescription('The name of the executable file to be downloaded from adminDownLoadServer.')
adminDownLoadServer = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDownLoadServer.setStatus('mandatory')
if mibBuilder.loadTexts: adminDownLoadServer.setDescription('The name of the file server from which to download a new executable image (adminDownLoadFile).')
adminDownload = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11))).clone(namedValues=NamedValues(("temporaryChange", 1), ("permanentChange", 2), ("downloadSuccess", 3), ("tftpFailed", 4), ("badFile", 5), ("tftpUndefined", 6), ("tftpFileNotFound", 7), ("tftpAccessViolation", 8), ("tftpIllegalOperation", 10), ("tftpUnknownTransferID", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDownload.setStatus('mandatory')
if mibBuilder.loadTexts: adminDownload.setDescription('A write to adminDownload of temporaryChange(1) or permanentChange(2) causes the LANtern network monitor to discontinue its normal functions and perform a TFTP read of the file specified by adminDownLoadFile from the server specified by adminDownLoadServer into RAM. Upon successful completion of the file transfer, the new image is written to the flash EPROM memory (permanentChange only), destroying the previous image. The LANtern network monitor then performs a warm restart to activate the new image. A read of adminDownLoad returns the status of the last download. The values temporaryChange(1) and permanentChange(2) indicate a download is in progress. tftpFailed(4) indicates the server failed to respond or the transfer timed out. badFile(5) occurs if the LANtern network monitor determines the downloaded file has been corrupted or is not a LANtern executable. All other error codes are the values defined by the TFTP protocol [RFC 783], offset by six. Note: adminDownloadFile and adminDownLoadServer must be set prior (separate PDU) to setting adminDownLoad.')
adminReset = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("coldRestart", 1), ("warmRestart", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: adminReset.setStatus('mandatory')
if mibBuilder.loadTexts: adminReset.setDescription('A write to adminReset causes the LANtern network monitor to discontinue its normal functions and commence a restart sequence. The contents of RAM, including all counters and statistics, are lost. A coldRestart destroys the contents of the nonvolatile RAM and causes the LANtern network monitor to start up exactly as if power was supplied for the first time. This is equivalent to supplying power to the LANtern network monitor while holding the hardware reset button depressed. A warmRestart preserves the contents of the nonvolatile RAM and causes the LANtern network monitor to start up exactly as if the reset button had been pressed (or power was being restored after an outage).')
adminSerialDataLink = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("slip", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialDataLink.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialDataLink.setDescription('The type of data link encapsulation to be used on the serial line. adminSerialDataLink may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminSerialDataLink is read, it returns the value currently in use, regardless of any previous writes. adminSerialDataLink is stored in nonvolatile RAM.')
adminSerialIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 21), IpAddress().clone(hexValue="c044cd81")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialIPAddr.setDescription('The IP address currently in use by the LANtern network monitor on the serial channel. adminSerialIPAddr may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminSerialIPAddr is read, it returns the IP address currently in use, regardless of any previous writes. adminSerialIPAddr is stored in nonvolatile RAM.')
adminSerialSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 22), IpAddress().clone(hexValue="ffffff80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialSubnetMask.setDescription('The subnet mask for the serial channel. adminSerialSubnetMask may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When this variable is read, it returns the subnet mask currently in use, regardless of any previous writes. When the value 0.0.0.0 is stored in this variable, the LANtern assumes no subnetting. adminSerialSubnetMask is stored in nonvolatile RAM.')
adminSerialBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("baud300", 1), ("baud1200", 2), ("baud2400", 3), ("baud4800", 4), ("baud7200", 5), ("baud9600", 6), ("baud19200", 7), ("baud38400", 8))).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialBaudRate.setDescription('A codification of the baud rate to be used on the serial line for incoming calls or when the line is directly connected. Change does not switch line speed until next state change of modem or reset. adminSerialBaudRate is stored in nonvolatile RAM.')
adminSerialTimeout = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 24), Seconds().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialTimeout.setDescription('Once a phone connection has been established, the LANtern network monitor maintains that connection until either the other end hangs up or adminSerialTimeout seconds elapses with no communication. adminSerialTimeout is stored in nonvolatile RAM.')
adminSerialConnection = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modem", 1), ("direct", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialConnection.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialConnection.setDescription('The type of connection used by the serial line. adminSerialConnection may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminSerialConnection is read, it returns the value currently in use, regardless of any previous writes. adminSerialConnection is stored in nonvolatile RAM.')
adminSerialFlowControl = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("rts-cts", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSerialFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: adminSerialFlowControl.setDescription('The type of flow control used on the serial line. adminSerialFlowControl may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminSerialFlowControl is read, it returns the value currently in use, regardless of any previous writes. adminSerialFlowControl is stored in nonvolatile RAM.')
adminModemControl = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 27), OctetString().clone('#^ATS0=1 Q0 V1 X4 &S1 &D2^M^1AT &W0\n                     &Y0^M#^1ATDT#^2+++^2ATH0^M#')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminModemControl.setStatus('mandatory')
if mibBuilder.loadTexts: adminModemControl.setDescription('A delimited string containing commands to initialize, dial, and hang up the modem. See Section 3.1.2 for more details on the format of this string. adminModemControl may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminModemControl is read, it returns the value currently in use, regardless of any previous writes. adminModemControl is stored in nonvolatile RAM.')
adminModemConnect = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 28), OctetString().clone('#19200#CONNECT 19200#9600#CONNECT\n                     9600#4800#CONNECT 4800#2400#CONNECT\n                     2400#1200#CONNECT 1200#300#CONNECT#')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminModemConnect.setStatus('mandatory')
if mibBuilder.loadTexts: adminModemConnect.setDescription('A delimited string containing baud rates and modem responses when it connects at particular baud rates. See Section 3.1.2 for more details on the format of this string. adminModemConnect may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminModemConnect is read, it returns the value currently in use, regardless of any previous writes. adminModemConnect is stored in nonvolatile RAM.')
adminModemNoConnect = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 29), OctetString().clone('#NO DIALTONE#NO CARRIER#BUSY#VOICE#TIMEOUT#')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminModemNoConnect.setStatus('mandatory')
if mibBuilder.loadTexts: adminModemNoConnect.setDescription('A delimited string containing baud rates and modem responses when it connects at particular baud rates. See Section 3 for more details on the format of this string. adminModemNoConnect may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminModemNoConnect is read, it returns the value currently in use, regardless of any previous writes. adminModemNoConnect is stored in nonvolatile RAM.')
adminGatewayControl = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gateway-off", 1), ("gateway-on", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminGatewayControl.setStatus('mandatory')
if mibBuilder.loadTexts: adminGatewayControl.setDescription('A switch to enable or disable IP gatewaying between the serial line and the network. See Section 3 for more details on the format of this string. adminGatewayControl may be written at any time; however, the change does not take effect until the LANtern network monitor is restarted. When adminGatewayControl is read, it returns the value currently in use, regardless of any previous writes. adminGatewayControl is stored in nonvolatile RAM.')
adminPhoneTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31), )
if mibBuilder.loadTexts: adminPhoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneTable.setDescription('A table that provides information about each possible phone connection that can be made over the serial channel. The table is accessed by adminPhoneIPAddr. A new entry can be created by writing to a nonexistent instance. Note that adminPhoneIPAddr is set implicitly from this write. adminPhoneIPAddr cannot be written directly. An entry may subsequently be deleted by writing (any value) to adminPhoneDelete. See Section 3 for more details about using the phone table. adminPhoneTable is stored in nonvolatile RAM.')
adminPhoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1), ).setIndexNames((0, "Novell-LANtern-Admin-MIB", "adminPhoneIPAddr"))
if mibBuilder.loadTexts: adminPhoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneEntry.setDescription('Data for a particular phone connection that can be established over the serial channel.')
adminPhoneIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminPhoneIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneIPAddr.setDescription('The IP address of the machine or IP network (SLIP gateway) at adminPhoneNumber.')
adminPhoneIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminPhoneIPMask.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneIPMask.setDescription('The IP subnet mask to be used when communicating over this phone connection. When the value 0.0.0.0 is stored in this variable, the LANtern network monitor assumes no subnetting. Default: 0.0.0.0 (no subnetting)')
adminPhoneLocalIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminPhoneLocalIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneLocalIPAddr.setDescription('The IP address the LANtern network monitor uses for its serial port while communicating over this phone connection.')
adminPhoneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminPhoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneNumber.setDescription('The phone number string the modem uses to dial the machine with IP address adminPhoneIPAddr.')
adminPhoneConnectionProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminPhoneConnectionProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneConnectionProtocol.setDescription('An ASCII string specifying the logon sequence once the phone is connected.')
adminPhoneDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 31, 1, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: adminPhoneDelete.setStatus('mandatory')
if mibBuilder.loadTexts: adminPhoneDelete.setDescription('A write (any value) causes the table entry to be deleted.')
adminFCBControl = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminFCBControl.setStatus('mandatory')
if mibBuilder.loadTexts: adminFCBControl.setDescription("A switch to disable the packet capture feature. To enable this flag (after disabling it) a cool start must apply to the LANtern in order to gain access into the administrator menu via the terminal hookup to the LANtern's serial port.")
mibBuilder.exportSymbols("Novell-LANtern-Admin-MIB", adminPhoneDelete=adminPhoneDelete, adminSerialIPAddr=adminSerialIPAddr, DisplayString=DisplayString, mibDoc=mibDoc, adminNotificationStatus=adminNotificationStatus, adminFCBControl=adminFCBControl, adminSerialBaudRate=adminSerialBaudRate, adminPhoneIPMask=adminPhoneIPMask, adminSerialDataLink=adminSerialDataLink, adminIdentification=adminIdentification, adminPowerOffTime=adminPowerOffTime, adminClientEntry=adminClientEntry, adminNotificationTable=adminNotificationTable, adminTrapAcknowledge=adminTrapAcknowledge, adminNetworkGateway=adminNetworkGateway, Seconds=Seconds, adminClientCommunities=adminClientCommunities, adminNotificationRetries=adminNotificationRetries, adminDownLoadFile=adminDownLoadFile, adminDownLoadServer=adminDownLoadServer, adminSerialSubnetMask=adminSerialSubnetMask, adminReset=adminReset, adminNetworkSubnetMask=adminNetworkSubnetMask, adminClientTable=adminClientTable, adminNotificationEntry=adminNotificationEntry, adminPhoneConnectionProtocol=adminPhoneConnectionProtocol, adminNetworkDataLink=adminNetworkDataLink, adminClientIPAddr=adminClientIPAddr, adminNotificationIPAddr=adminNotificationIPAddr, lanternAdmin=lanternAdmin, adminClientIPMask=adminClientIPMask, adminClientDelete=adminClientDelete, adminSerialTimeout=adminSerialTimeout, PhysAddress=PhysAddress, lantern=lantern, adminUnauthorizedIPAddr=adminUnauthorizedIPAddr, adminSerialFlowControl=adminSerialFlowControl, adminPhoneIPAddr=adminPhoneIPAddr, adminSerialConnection=adminSerialConnection, adminModemNoConnect=adminModemNoConnect, networkMonitor=networkMonitor, adminNetworkIPAddr=adminNetworkIPAddr, adminDateAndTime=adminDateAndTime, productType=productType, adminPowerOnTime=adminPowerOnTime, ethernetLANtern=ethernetLANtern, adminNotificationBackupIPAddr=adminNotificationBackupIPAddr, adminPhoneTable=adminPhoneTable, novell=novell, adminModemConnect=adminModemConnect, adminNotificationTrapMask=adminNotificationTrapMask, adminPhoneLocalIPAddr=adminPhoneLocalIPAddr, adminDownload=adminDownload, adminTimeZone=adminTimeZone, adminNotificationDelete=adminNotificationDelete, adminModemControl=adminModemControl, adminNotificationConfirmMask=adminNotificationConfirmMask, adminNotificationTimeout=adminNotificationTimeout, adminPhoneEntry=adminPhoneEntry, Time=Time, adminPhoneNumber=adminPhoneNumber, adminUnauthorizedCommunity=adminUnauthorizedCommunity, adminGatewayControl=adminGatewayControl, adminTrapHandle=adminTrapHandle)

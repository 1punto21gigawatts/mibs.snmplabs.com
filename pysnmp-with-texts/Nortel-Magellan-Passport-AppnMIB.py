#
# PySNMP MIB module Nortel-Magellan-Passport-AppnMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-AppnMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
RowStatus, RowPointer, DisplayString, Integer32, PassportCounter64, Gauge32, StorageType, Unsigned32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "RowPointer", "DisplayString", "Integer32", "PassportCounter64", "Gauge32", "StorageType", "Unsigned32")
EnterpriseDateAndTime, NonReplicated, Link, Hex, AsciiStringIndex, HexString, AsciiString, DigitString, DashedHexString = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "EnterpriseDateAndTime", "NonReplicated", "Link", "Hex", "AsciiStringIndex", "HexString", "AsciiString", "DigitString", "DashedHexString")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, Counter64, Counter32, Integer32, ObjectIdentity, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, ModuleIdentity, NotificationType, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "Counter32", "Integer32", "ObjectIdentity", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "ModuleIdentity", "NotificationType", "Unsigned32", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
appnMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29))
appn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110))
appnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1), )
if mibBuilder.loadTexts: appnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnRowStatusTable.setDescription('This entry controls the addition and deletion of appn components.')
appnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"))
if mibBuilder.loadTexts: appnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnRowStatusEntry.setDescription('A single entry in the table represents a single appn component.')
appnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appn components. These components can be added and deleted.')
appnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnStorageType.setDescription('This variable represents the storage type value for the appn tables.')
appnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnIndex.setDescription('This variable represents the index for the appn tables.')
appnProcessParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 100), )
if mibBuilder.loadTexts: appnProcessParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnProcessParmsTable.setDescription('This group contains attributes of the SNA service which are required for operation within the Passport environment.')
appnProcessParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"))
if mibBuilder.loadTexts: appnProcessParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnProcessParmsEntry.setDescription('An entry in the appnProcessParmsTable.')
appnLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 100, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: appnLogicalProcessor.setDescription('This attribute specifies the logical processor on which the Appn component will utilize memory and CPU resources.')
appnMaximumSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumSvcs.setDescription('This attribute specifies the total number of general switched virtual circuits (GSVC) that can be active on this Appn node. Once this number is reached no GSVC calls will be accepted by the service. This attribute does not include the Frame Relay switched virtual circuits.')
appnMaximumLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 100, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumLinkStations.setDescription('This attribute specifies the total number of link stations for GSVCs, Frame Relay PVCs and SVCs that can be active on this Appn node. Once the value of activeLinkStations reaches or exceeds the value of maximumLinkStations, no new incoming SVC calls (GSVCs and Frame Relay SVCs) will be accepted by the service until the value of activeLinkStations is again below the value of maximumLinkStations. Outgoing GSVCs and Frame Relay PVCs (incoming or outgoing) are provisioned and their call setups at this end are not affected when the value of activeLinkStations reaches or exceeds the value of maximumLinkStations. Link stations are dynamically created for the end user applications as required. Therefore the value of activeLinkStations may exceed the value of maximumLinkStations.')
appnControlPointCreateParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101), )
if mibBuilder.loadTexts: appnControlPointCreateParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnControlPointCreateParmsTable.setDescription('Parameters required to define the behavior of the SNA node.')
appnControlPointCreateParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"))
if mibBuilder.loadTexts: appnControlPointCreateParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnControlPointCreateParmsEntry.setDescription('An entry in the appnControlPointCreateParmsTable.')
appnFqCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFqCpName.setStatus('mandatory')
if mibBuilder.loadTexts: appnFqCpName.setDescription('The network qualified control point (CP) name. This is the name by which the node is identified within the APPN network. It is signalled on the XID 3 exchange and is the end-point of CP-CP sessions established with this node. The first portion of this name, up to the period, is the network identifier for the network to which this node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnBlockNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 3), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnBlockNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnBlockNumber.setDescription('The block number identifies the product of the node. It is the first three hexadecimal digits of the SNA node id.')
appnIdNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 4), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIdNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnIdNumber.setDescription('The idNumber is used to identify the local SNA node. It is the last five hexadecimal digits of the SNA node id and is administratively defined. The idNumber will be combined with the three hexadecimal digit block number to form the SNA node id. The SNA node id is included in APPN alerts and in XIDs. A unique value is required for connections to SNA.')
appnRouteAdditionResistance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnRouteAdditionResistance.setStatus('mandatory')
if mibBuilder.loadTexts: appnRouteAdditionResistance.setDescription('Route addition resistance is a value that indicates the relative desirability of using this node for intermediate session traffic.The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
appnFeatures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: appnFeatures.setDescription('This attribute supports several YES/NO flags which are defined in the create parameters: multipleDomainSupport If present, specifies that Management Services (MS) supports Multiple Domain Support (MDS) and MS capabilities exchange. registerWithCDS If present, for a network node this specifies whether local and domain resources may be registered with a central directory server. storeEndptRscvs If present, specifies that route selection control vectors (RSCV) should be stored for diagnostic purposes on sessions which terminate in this node. Note that selecting this value means that an RSCV will be stored for each ISR session. This extra storage can be up to 256 bytes per session. storeIsrRscvs If present, specifies that route selection control vectors (RSCV) should be stored for diagnostic purposes on intermediate session routing (ISR) sessions. Note that selecting this value means that an RSCV will be stored for each ISR session. This extra storage can be up to 256 bytes per session. Description of bits: multipleDomainSupport(0) registerWithCDS(1) storeEndptRscvs(2) storeIsrRscvs(3)')
appnMaximumLocates = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumLocates.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumLocates.setDescription('This attribute represents the maximum number of locate requests the node can handle simultaneously. Attribute locateTimeout should be set to ensure that locate requests can timeout, thereby freeing up node resources.')
appnMaximumDirectorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumDirectorySize.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumDirectorySize.setDescription('This attribute contains the maximum number of SnaDirectoryEntry components that can be defined or learned by this node. A value of zero means unlimited.')
appnMdsTxAlertQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMdsTxAlertQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnMdsTxAlertQueueSize.setDescription('This is the size of Multiple Domain Support send alert queue. When the limit is reached, the MDS component deletes the oldest entry in the queue.')
appnTreeCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(8, 65535)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnTreeCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnTreeCacheSize.setDescription('This is the topology database routing tree cache size.')
appnTreeCacheUseLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnTreeCacheUseLimit.setStatus('mandatory')
if mibBuilder.loadTexts: appnTreeCacheUseLimit.setDescription('This is the number of times a cached tree can be reused. Once this number is exceeded, the tree is discarded and recomputed. This allows the node to balance sessions among equal weight routes. A low value provides better load balancing at the expense of increased activation latency. The minimum is 1.')
appnMaximumTopologyNodes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumTopologyNodes.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumTopologyNodes.setDescription('This is the maximum number of Appn network nodes that can be stored in the Topology Database (zero means unlimited).')
appnMaximumTopologyTgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumTopologyTgs.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumTopologyTgs.setDescription('This is the maximum number of Transmission Groups that can be stored in the Topology Database (zero means unlimited).')
appnMaximumIsrSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 65535)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnMaximumIsrSessions.setStatus('mandatory')
if mibBuilder.loadTexts: appnMaximumIsrSessions.setDescription('This attribute represents the maximum number of ISR sessions this node can participate in at once. The minimum value is 100.')
appnIsrUpperCongestionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsrUpperCongestionThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrUpperCongestionThreshold.setDescription("This is the upper threshold for ISR sessions. This attribute and the following one control the node's ISR congestion status. The node state changes from uncongested to congested if the number of ISR sessions exceeds the upper threshold. The node state changes back to uncongested once the number of ISR sessions dips below the lower threshold. To prevent thrashing, the lower threshold should be less than the upper threshold. The upper threshold should be lower than maximumIsrSessions.")
appnIsrLowerCongestionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsrLowerCongestionThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrLowerCongestionThreshold.setDescription('This is the lower threshold for the ISR session congestion algorithm. This value should be less than isrUpperCongestionThreshold.')
appnIsrMaxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsrMaxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrMaxRuSize.setDescription('Maximum request unit (RU) size supported for intermediate routing (ISR) sessions.')
appnIsrRxPacingWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnIsrRxPacingWindow.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrRxPacingWindow.setDescription('This is the suggested receive pacing window size for intermediate sessions. This value is only used on the secondary hop of intermediate sessions if the adjacent node does not support adaptive pacing. A value of zero means that no pacing will occur.')
appnLocateTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLocateTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocateTimeout.setDescription('This attribute specifies the time in seconds before a network search will time-out. A value of zero indicates that the search has no time limit.')
appnHprSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("anrOnly", 1), ("rtp", 2))).clone('rtp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnHprSupport.setStatus('mandatory')
if mibBuilder.loadTexts: appnHprSupport.setDescription('This attribute specifies the type of High Performance Routing (HPR) that is to be used on this node. The options are: none - the node does not support HPR, anrOnly - the node only supports Automatic Network Routing (ANR), or rtp - the node supports Rapid Transport Protocol as an end point. The default value of rtp ensures that the node can Aping other nodes via a HPR pipe, this option is also required to allow dependent LU sessions teminating on this node to use HPR and for the node to act as a boundary node between ISR only nodes and the HPR capable portion of the network. With this option, the node can work with non-HPR capable nodes.')
appnDlurSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 101, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlurSupport.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlurSupport.setDescription('This attribute specifies whether or not this node supports dependent logical unit requestor (DLUR). By default, DLUR is not supported. If this attribute is set to yes, ensure that the Dlur subcomponent is provisioned with appropriate values, if this attribute is set to no, the Dlur subcomponent is not used and is ignored if present.')
appnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 102), )
if mibBuilder.loadTexts: appnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
appnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 102, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"))
if mibBuilder.loadTexts: appnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnStateEntry.setDescription('An entry in the appnStateTable.')
appnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
appnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 102, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: appnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
appnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 102, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: appnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
appnOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103), )
if mibBuilder.loadTexts: appnOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnOperationalTable.setDescription('This group contains the node operational characteristics.')
appnOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"))
if mibBuilder.loadTexts: appnOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnOperationalEntry.setDescription('An entry in the appnOperationalTable.')
appnUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: appnUpTime.setDescription('This attribute represents the time in hundredths of a second since the node was started or restarted.')
appnHeapSpaceLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnHeapSpaceLimit.setStatus('mandatory')
if mibBuilder.loadTexts: appnHeapSpaceLimit.setDescription('This attribute represents the size of the heap in bytes, as obtained by storage management from the underlying operating system.')
appnHeapSpaceCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnHeapSpaceCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: appnHeapSpaceCurrent.setDescription('This attribute contains the number of bytes in the memory segment that are currently allocated to the processes associated with the Appn component. SNMP APPN MIB = ibmappnMemoryUsed')
appnMemWarningThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnMemWarningThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: appnMemWarningThreshold.setDescription('This attribute contains the memory allocation threshold beyond which storage management considers the storage resources to be constrained. This is calculated as a fraction of heapSpaceLimit. The value returned now is always zero until the functionality is supported in future release. SNMP APPN MIB = ibmappnMemoryWarnThresh')
appnMemCriticalThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnMemCriticalThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: appnMemCriticalThreshold.setDescription('This attribute represents the memory allocation threshold beyond which storage management considers the storage resources to be critically constrained. The value is calculated as a fraction of heapSpaceLimit. The value returned now is always zero until the functionality is supported in future release.')
appnNnFunctionsSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnFunctionsSupported.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnFunctionsSupported.setDescription('The network node functions supported may include any of the following: receiveRegistration - If present, indicates that this node supports receiving registered characteristics on a GDS frame. This function is not supported in the current release. gateway - If present, indicates that this is a gateway node. centralDirectoryServer - If present, indicates that this node supports central directory server cache. treeCaching -If present, indicates that this node supports route tree cache. treeUpdates - If present, indicates that this node supports incremental tree update, which is only supported when tree caching is supported. intermediateSessionRouting - Indicates that the node supports intermediate session routing. Description of bits: receiveRegistration(0) gateway(1) centralDirectoryServer(2) treeCaching(3) treeUpdates(4) intermediateSessionRouting(5)')
appnGeneralFunctionsSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnGeneralFunctionsSupported.setStatus('mandatory')
if mibBuilder.loadTexts: appnGeneralFunctionsSupported.setDescription('The general functions supported may include any of the following: negotiableLs -If present, indicates that this node supports negotiable link stations. segmentReassembly -If present, indicates whether this node supports segment reassembly. This is only supported when segment generation is also supported. bindReassembly -If present, indicates whether this node supports Bind segment reassembly. This will only be supported when Bind segment generation is also supported. parallelTgs -If present, indicates whether this node supports parallel TGs. callIn - If present, indicates whether this node allows call-in from nodes not defined locally. adaptivePacing - If present, indicates whether this node supports adaptive bind pacing. Description of bits: negotiableLs(0) segmentReassembly(1) bindReassembly(2) parallelTgs(3) callIn(4) adaptivePacing(5)')
appnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnStatus.setDescription('This attribute contains the status of the node. This may be nodeUncongested or one or more of the following: isrCongested The number of ISR sessions is greater than specified by the isrSessionsUpperThreshold attribute. This node is not be included in route selection by other nodes when this congestion exists. endPtDepleted The number of end-point sessions has reached the maximum specified. isrDepleted The number of ISR sessions has reached the maximum specified by the maximumIsrSessions attribute. This node is not included in intermediate route selection by other nodes when resources are depleted. quiescing Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing. Description of bits: nodeUncongested(0) notused1(1) quiescing(2) notused3(3) notused4(4) endPtDepleted(5) isrDepleted(6) isrCongested(7)')
appnFlowReductionSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnFlowReductionSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnFlowReductionSequenceNumber.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This object is the last FRSN sent in a topology update the adjacent network nodes. SNMP APPN MIB = ibmappnNodeNnFrsn')
appnResourceSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnResourceSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnResourceSequenceNumber.setDescription('Resource sequence number of this Appn network node.')
appnDefinedLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDefinedLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnDefinedLsGoodXids.setDescription('This attribute represents the total number of successful XIDs that have been received on all defined link stations since the last time this node was initialized. When the upper limit is reached, the number wraps around to 0.')
appnDefinedLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDefinedLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnDefinedLsBadXids.setDescription('This attribute represents the total number of unsuccessful XIDs that have been received on all defined link stations since the last time this node was initialized. When the upper limit is reached, the number wraps around to 0.')
appnDynamicLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDynamicLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnDynamicLsGoodXids.setDescription('This attribute represents the total number of successful XIDs that have been received on all dynamic link stations since the last time this node was initialized. When the upper limit is reached, the number wraps around to 0.')
appnDynamicLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDynamicLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnDynamicLsBadXids.setDescription('This attribute represents the total number of unsuccessful XIDs that have been received on all dynamic link stations since the last time this node was initialized. When the upper limit is reached, the number wraps around to 0.')
appnActiveSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnActiveSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: appnActiveSvcs.setDescription('This attribute indicates the number of general switched virtual circuits (GSVC) on this Appn node at the time of the query. This attribute does not include the Frame Relay switched virtual circuits.')
appnActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 103, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: appnActiveLinkStations.setDescription('This attribute indicates the number of link stations (for GSVCs, Frame Relay PVCs and SVCs) on the Appn node at the time of the query.')
appnDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2))
appnDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1), )
if mibBuilder.loadTexts: appnDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaRowStatusTable.setDescription('This entry controls the addition and deletion of appnDna components.')
appnDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"))
if mibBuilder.loadTexts: appnDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaRowStatusEntry.setDescription('A single entry in the table represents a single appnDna component.')
appnDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDna components. These components cannot be added nor deleted.')
appnDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaStorageType.setDescription('This variable represents the storage type value for the appnDna tables.')
appnDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaIndex.setDescription('This variable represents the index for the appnDna tables.')
appnDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 10), )
if mibBuilder.loadTexts: appnDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaAddressTable.setDescription("Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. String of address digits is complemented by type of address and Npi. These attributes are used to interpret format of the address digits.")
appnDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"))
if mibBuilder.loadTexts: appnDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaAddressEntry.setDescription('An entry in the appnDnaAddressTable.')
appnDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet switched data networks.')
appnDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDataNetworkAddress.setDescription('Dna attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) to telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
appnDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12), )
if mibBuilder.loadTexts: appnDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaOutgoingOptionsTable.setDescription('OutgoingOptions group defines call options of a Dna for calls which are made out of the interface represented by Dna. All these options are not used for calls arriving to the interface represented by Dna.')
appnDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"))
if mibBuilder.loadTexts: appnDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaOutgoingOptionsEntry.setDescription('An entry in the appnDnaOutgoingOptionsTable.')
appnDnaOutDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaOutDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaOutDefaultPriority.setDescription('This attribute, if set to normal indicates that the default priority for outgoing calls (from the DTE to the network) using this particular Dna is normal priority - if the priority is not specified by the DTE. If this attribute is set to high then the default priority for outgoing calls using this particular Dna is high priority. This option can be also included in X.25 signalling, in such case it will be overruled.')
appnDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('throughput')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaOutDefaultPathSensitivity.setStatus('obsolete')
if mibBuilder.loadTexts: appnDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of routing for delay/ throughput sensitive routing for all outgoing calls (from the DTE to the network) using this particular Dna. The chosen default class of routing applies to all outgoing calls established using this Dna, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of throughput, indicates that the default class of routing is throughput sensitive routing. If set to a value of delay, then the default class of routing is delay sensitive routing. In the future, the class of routing sensitivity may be overridden at the calling end of the call as follows: The default class of routing sensitivity can be overridden by the DTE in the call request packet through the TDS&I (Transit Delay Selection & Indication) facility if the DTE supports this facility. Whether or not the DTE is permitted to signal the TDS&I facility will depend on the DTE (i.e.: TDS&I is supported in X.25 only), and will depend on whether the port is configured to permit the TDS&I facility. In Passport, the treatment of DTE facilities (for example, NUI, RPOA, and TDS&I) is not fully defined yet since it is not required. At the point in time when it is required, the parameter to control whether or not the DTE is permitted to signal the TDS&I will be in a Facility Treatment component. Currently, the default is to disallow the TDS&I facility from the DTE.')
appnDnaOutPathSensitivityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaOutPathSensitivityOverRide.setStatus('obsolete')
if mibBuilder.loadTexts: appnDnaOutPathSensitivityOverRide.setDescription('If this attribute is set to yes in the call request, the called end will use the calling end provisioning data on sensitivity to override its provisioning data,')
appnDnaOutDefaultPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaOutDefaultPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaOutDefaultPathReliability.setDescription('This attribute specifies the default class of routing for reliability routing for all outgoing calls (from the DTE to the network) using this particular Dna. The chosen default class of routing applies to all outgoing calls established using this Dna, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of normal, indicates that the default class of routing is normal reliability routing. If set to a value of high, then the default class of routing is high reliability routing. High reliability is the standard choice for most DPN and Passport services. It usually indicates that packets are overflowed or retransmitted at various routing levels. Typically high reliability results in duplication and disordering of packets in the network when errors are detected or during link congestion. However, the Vc handles the duplication and disordering to ensure that packets are delivered to the DTE properly. For the Frame Relay service, duplication of packets is not desired, in which case, normal reliability may be chosen as the preferred class of routing.')
appnDnaOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaOutAccess.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaOutAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) to the open (non-CUG) part of the network are permitted. It also permits outgoing calls to DTEs that have Incoming Access capabilities. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Outgoing Access' feature for Dna's in that outgoing access is granted if this attribute is set to a value of allowed.")
appnDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It is overRidden by the transferPriority provisioned in the DLCI Direct Call sub- component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of defaultTransferPriority is normal.')
appnDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 12, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes in the call request, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. The default of outTransferPriorityOverRide is yes.')
appnDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 13), )
if mibBuilder.loadTexts: appnDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaIncomingOptionsTable.setDescription('IncomingOptions defines set of options for incoming calls. These options are used for calls arriving to the interface represented by Dna. For calls originated from the interface, IncomingOptions attributes are not used.')
appnDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"))
if mibBuilder.loadTexts: appnDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaIncomingOptionsEntry.setDescription('An entry in the appnDnaIncomingOptionsTable.')
appnDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTEs that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Incoming Access' feature for Dnas in that incoming access is granted if this attribute is set to a value of allowed.")
appnDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14), )
if mibBuilder.loadTexts: appnDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCallOptionsTable.setDescription('CallOptions group defines additional options for calls not related directly to direction of a call.')
appnDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"))
if mibBuilder.loadTexts: appnDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCallOptionsEntry.setDescription('An entry in the appnDnaCallOptionsTable.')
appnDnaDefaultRecvFrmNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDefaultRecvFrmNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDefaultRecvFrmNetworkThruputClass.setDescription('This attribute indicates the default receive throughput class for all calls using this particular Dna.')
appnDnaDefaultSendToNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDefaultSendToNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDefaultSendToNetworkThruputClass.setDescription('This attribute indicates the default send throughput class for all calls using this particular Dna.')
appnDnaDefaultRecvFrmNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDefaultRecvFrmNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDefaultRecvFrmNetworkWindowSize.setDescription('This attribute indicates the default number of data packets that can be received by the DTE from the DCE before more packets can be received. This view is oriented with respect to the DTE.')
appnDnaDefaultSendToNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaDefaultSendToNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaDefaultSendToNetworkWindowSize.setDescription('This attribute indicates the number of data packets that can be transmitted from the DTE to the DCE and must be acknowledged before more packets can be transmitted.')
appnDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator and it is an arbitrary number.')
appnDnaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaAccountCollection.setDescription('This attribute indicates that accounting records are to be collected by the network for the various reasons: billing, test, study, auditing. The last of the parameters, force, indicates that accounting records are to be collected irrespective of other collection reasons. If none of these reasons are set, then accounting will be suppressed. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
appnDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 14, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaServiceExchange.setDescription('This attribute is an arbitrary number, entered by the network operator. It is included in the accounting record created by Vc.')
appnDnaHgM = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2))
appnDnaHgMRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1), )
if mibBuilder.loadTexts: appnDnaHgMRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMRowStatusTable.setDescription('This entry controls the addition and deletion of appnDnaHgM components.')
appnDnaHgMRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMIndex"))
if mibBuilder.loadTexts: appnDnaHgMRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMRowStatusEntry.setDescription('A single entry in the table represents a single appnDnaHgM component.')
appnDnaHgMRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaHgMRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDnaHgM components. These components can be added and deleted.')
appnDnaHgMComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDnaHgMStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMStorageType.setDescription('This variable represents the storage type value for the appnDnaHgM tables.')
appnDnaHgMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDnaHgMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMIndex.setDescription('This variable represents the index for the appnDnaHgM tables.')
appnDnaHgMIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 10), )
if mibBuilder.loadTexts: appnDnaHgMIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMIfTable.setDescription('This group contains the interface parameters between the HuntGroupMember and the Hunt Group server.')
appnDnaHgMIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMIndex"))
if mibBuilder.loadTexts: appnDnaHgMIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMIfEntry.setDescription('An entry in the appnDnaHgMIfTable.')
appnDnaHgMAvailabilityUpdateThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaHgMAvailabilityUpdateThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMAvailabilityUpdateThreshold.setDescription('This attribute indicates the number of channels that have to be freed or occupied before the Availability Message Packet (AMP) is sent to the Hunt Group Server informing it of the status of this interface.')
appnDnaHgMOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 11), )
if mibBuilder.loadTexts: appnDnaHgMOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMOpTable.setDescription('This group contains the operational attributes of the HuntGroupMember component.')
appnDnaHgMOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMIndex"))
if mibBuilder.loadTexts: appnDnaHgMOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMOpEntry.setDescription('An entry in the appnDnaHgMOpTable.')
appnDnaHgMMaxAvailableChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMMaxAvailableChannels.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMMaxAvailableChannels.setDescription('This attribute indicates the maximum number of available channels for this HuntGroupMember.')
appnDnaHgMAvailableChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMAvailableChannels.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMAvailableChannels.setDescription('This attribute indicates the number of available channels reported to the hunt group in the Availability Message Packet (AMP). It is incremented by the application when a channel is freed and decremented when a channel is occupied.')
appnDnaHgMAvailabilityDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-4096, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMAvailabilityDelta.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMAvailabilityDelta.setDescription('This attribute indicates the net change in the available channels since the last Availability Message Packet (AMP) was sent to the Hunt Group. Once the absolute value of this attribute reaches the availabilityUpdateThreshold an AMP is sent to the host and the availabilityDelta is reset to 0. If this attribute is positive it means an increase of the number of available channels. If it is negative it means a decrease in the number of available channels.')
appnDnaHgMHgAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2))
appnDnaHgMHgAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1), )
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatusTable.setDescription('This entry controls the addition and deletion of appnDnaHgMHgAddr components.')
appnDnaHgMHgAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatusEntry.setDescription('A single entry in the table represents a single appnDnaHgMHgAddr component.')
appnDnaHgMHgAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDnaHgMHgAddr components. These components can be added and deleted.')
appnDnaHgMHgAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMHgAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDnaHgMHgAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaHgMHgAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrStorageType.setDescription('This variable represents the storage type value for the appnDnaHgMHgAddr tables.')
appnDnaHgMHgAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: appnDnaHgMHgAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrIndex.setDescription('This variable represents the index for the appnDnaHgMHgAddr tables.')
appnDnaHgMHgAddrAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 10), )
if mibBuilder.loadTexts: appnDnaHgMHgAddrAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrAddrTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes.')
appnDnaHgMHgAddrAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: appnDnaHgMHgAddrAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrAddrEntry.setDescription('An entry in the appnDnaHgMHgAddrAddrTable.')
appnDnaHgMHgAddrNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaHgMHgAddrNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrNumberingPlanIndicator.setDescription('This attribute specifies the Numbering Plan Indicator (NPI) of the Dna that is entered. The address may belong to the X.121 or E.164 numbering plans.')
appnDnaHgMHgAddrDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaHgMHgAddrDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaHgMHgAddrDataNetworkAddress.setDescription('This attribute specifies the digits that form the unique identifier of the customer interface. It can be compared (approximation only) to a telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
appnDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3))
appnDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1), )
if mibBuilder.loadTexts: appnDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of appnDnaCug components.')
appnDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaCugIndex"))
if mibBuilder.loadTexts: appnDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single appnDnaCug component.')
appnDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDnaCug components. These components can be added and deleted.')
appnDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugStorageType.setDescription('This variable represents the storage type value for the appnDnaCug tables.')
appnDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: appnDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugIndex.setDescription('This variable represents the index for the appnDnaCug tables.')
appnDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10), )
if mibBuilder.loadTexts: appnDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugCugOptionsTable.setDescription('Attributes in this group defines ClosedUserGroup options associated with interlockCode. Dnas with the same Cug (interlockCode) make calls within this group. Various combinations which permit or prevent calls in the same Cug group are defined here.')
appnDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDnaCugIndex"))
if mibBuilder.loadTexts: appnDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugCugOptionsEntry.setDescription('An entry in the appnDnaCugCugOptionsTable.')
appnDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugType.setDescription('This attribute specifies the Cug type - the Cug is either a national Cug, or an international Cug. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National Cugs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the Cug is a national Cug, in which case, the dnic should be left at its default value since it is not part of a national Cug. If this attribute is set to international, then the Cug is an international Cug, in which case, the dnic should be set appropriately as part of the Cug interlockCode.')
appnDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) the Cug by which packet networks are identified. This attribute is not applicable if the Cug is a national Cug, as specified by the Cug type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by CCITT.')
appnDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugInterlockCode.setDescription('This attribute specifies the Cug identifier of a national or international Cug call. It is an arbitrary number and it also can be called Cug in some descriptions. Interfaces (Dnas) with this number can make calls to Dnas with the same interlockCode.')
appnDnaCugPreferential = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugPreferential.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugPreferential.setDescription('This attribute, if set to yes indicates that this Cug is the preferential Cug, in which case it will be used during the call establishment phase if the DTE has not explicitly specified a Cug index in the call request packet. If set to no, then this Cug is not the preferential Cug. Only one of the Cugs associated with a particular Dna can be the preferential Cug - only one Cug can have this attribute set to yes.')
appnDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugOutCalls.setDescription("This attribute, if set to allowed indicates that outgoing calls (from the DTE into the network) be made using this particular Cug. If set to a value of disallowed, then outgoing calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for Cugs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
appnDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) be made using this particular Cug. If set to disallowed, then incoming calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for Cugs in that incoming calls are barred if this attribute is set to a value of disallowed.")
appnDnaCugPrivileged = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 2, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDnaCugPrivileged.setStatus('mandatory')
if mibBuilder.loadTexts: appnDnaCugPrivileged.setDescription('This attribute, if set to yes indicates that this Cug is a privileged Cug. In DPN, at least one side of a call setup within a Cug must have the Cug as a privileged Cug. If set to no, then the Cug is not privileged. If both the local DTE and the remote DTE subscribe to the Cug, but it is not privileged, then the call will be cleared. This attribute is typically used for a host DTE which must accept calls from many other DTEs in which case the other DTEs cannot call one another, but can call the host. In this example, the host would have the privileged Cug, and the other DTEs would belong to the same Cug, but it would not be privileged.')
appnDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3))
appnDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1), )
if mibBuilder.loadTexts: appnDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlci components.')
appnDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"))
if mibBuilder.loadTexts: appnDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciRowStatusEntry.setDescription('A single entry in the table represents a single appnDlci component.')
appnDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlci components. These components can be added and deleted.')
appnDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciStorageType.setDescription('This variable represents the storage type value for the appnDlci tables.')
appnDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4095)))
if mibBuilder.loadTexts: appnDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciIndex.setDescription('This variable represents the index for the appnDlci tables.')
appnDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 10), )
if mibBuilder.loadTexts: appnDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
appnDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"))
if mibBuilder.loadTexts: appnDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciStateEntry.setDescription('An entry in the appnDlciStateTable.')
appnDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
appnDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
appnDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
appnDlciSpOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12), )
if mibBuilder.loadTexts: appnDlciSpOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpOpTable.setDescription('This group contains the actual service parameters in use for this instance of Dlci.')
appnDlciSpOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"))
if mibBuilder.loadTexts: appnDlciSpOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpOpEntry.setDescription('An entry in the appnDlciSpOpTable.')
appnDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciRateEnforcement.setDescription('This attribute indicates whether rate enforcement is in use for this Dlci.')
appnDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCommittedInformationRate.setDescription('This attribute indicates the current effective committed information rate (cir) in bits per second (bit/s). cir is the rate at which the network agrees to transfer data with Discard Eligiblity indication DE=0 under normal conditions. This attribute should be ignored when rateEnforcement is off.')
appnDlciCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCommittedBurstSize.setDescription('This attribute indicates the committed burst size (bc) in bits. bc is the amount of data that the network agrees to transfer under normal conditions over a measurement interval (t). bc is used for data with Discard Eligibility indication DE=0. DE=1 data does not use bc at all, excessBurstSize if is used instead. This attribute should be ignored when rateEnforcement is off.')
appnDlciExcessInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciExcessInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciExcessInformationRate.setDescription('This attribute indicates the current effective excess information rate (eir) in bits per second (bit/s). eir is the rate at which the network agrees to transfer data with Discard Eligibility indication DE=1 under normal conditions. DE can be set by the user or the network. DE indication of a data frame is set to 1 by the network after cir has been exceeded while eir is still available for data transfer.')
appnDlciExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciExcessBurstSize.setDescription('This attribute indicates the excess burst size (be) in bits. be is the amount of uncommitted data that the network will attempt to deliver over measurement interval (t). Data marked DE=1 by the user or by the network is accounted for here. This attribute should be ignored when rateEnforcement is off.')
appnDlciMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 12, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciMeasurementInterval.setDescription('This attribute indicates the time interval (in milliseconds) over which rates and burst sizes are measured. This attribute should be ignored when rateEnforcement is off.')
appnDlciDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2))
appnDlciDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1), )
if mibBuilder.loadTexts: appnDlciDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciDc components.')
appnDlciDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciDcIndex"))
if mibBuilder.loadTexts: appnDlciDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciDc component.')
appnDlciDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciDc components. These components cannot be added nor deleted.')
appnDlciDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcStorageType.setDescription('This variable represents the storage type value for the appnDlciDc tables.')
appnDlciDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDlciDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcIndex.setDescription('This variable represents the index for the appnDlciDc tables.')
appnDlciDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10), )
if mibBuilder.loadTexts: appnDlciDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcOptionsTable.setDescription('The Options group defines attributes associated with a direct call. It defines a complete connection in terms of path and call options. This connection can be permanent (PVC) or switched (SVC). It can have facilities. The total number of bytes of facilities including the facility codes, and all of the facility data from all of the four classes of facilities: CCITT_Facilities DTE_Facilities National_Facilities International_Facilities must not exceed 512.')
appnDlciDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciDcIndex"))
if mibBuilder.loadTexts: appnDlciDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcOptionsEntry.setDescription('An entry in the appnDlciDcOptionsTable.')
appnDlciDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRemoteNpi.setDescription('This attribute specifies the numbering plan used for remoteDna.')
appnDlciDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent. Initially, the called DTE address attribute must be present, that is, there must be a valid destination address. However, it may be possible in the future to configure the direct call with a mnemonic address, in which case, this attribute will contain a zero-length Dna, and the mnemonic address will be carried as one of the facilities.')
appnDlciDcRemoteDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcRemoteDlci.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcRemoteDlci.setDescription('This attribute provides the remote DLCI (Logical Channel Number) - it is used only for PVCs, where attribute type is set to permanentMaster or permanentSlave or permanentBackupSlave. In switched case, value of remoteDlci is not known when call request is made.')
appnDlciDcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("permanentMaster", 1), ("permanentSlave", 2), ("permanentBackupSlave", 3), ("permanentSlaveWithBackup", 4))).clone('permanentMaster')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcType.setDescription('This attribute specifies the type of Vc call: permanentMaster, permanentSlave, permanentSlaveWithBackup, permanentBackupSlave. If the value is set to permanentMaster, then a permanent connection will be established between two ends. The remote end must be defined as a permanentSlave, permanentBackupSlave or permanentSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as permanentMaster always initiates the calls. It will attempt to call once per minute. If the value is set to permanentSlave then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote end is defined as anything else. The permanentSlave end will attempt to call once per minute. If the value is set to permanentSlaveWithBackup then a permanent connection will be established between the 2 ends . The remote end must be defined as a permanentMaster. The Connection cannot be established if the remote end is defined as anything else. The permanentSlaveWithBackup end will attempt to call once per minute. If the value is set to permanentBackupSlave then a permanent connection will be established between the 2 ends only if the permanentMaster end is disconnected from the permanentSlaveWithBackup end and a backup call is established by the redirection system. If the permanentSlaveWithBackup interface becomes visible again, the permanentBackupSlave end is disconnected and the permanentSlaveWithBackup end is reconnected to the permanentMaster end. The permanentBackupSlave end does not try to establish PVC call.')
appnDlciDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9, 255))).clone(namedValues=NamedValues(("normal", 0), ("high", 9), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcTransferPriority.setDescription('This attribute specifies the transfer priority to network for the outgoing calls using this particular DLCI. It overRides the defaultTransferPriority provisioned in its associated Dna component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of transferPriority is useDnaDefTP. It means using the provisioning value under defaultTransferPriority of its associated Dna for this DLCI.')
appnDlciDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority are discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
appnDlciDcNfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 283), )
if mibBuilder.loadTexts: appnDlciDcNfaTable.setStatus('obsolete')
if mibBuilder.loadTexts: appnDlciDcNfaTable.setDescription('Two explicit attributes discardPriority and transferPriority are created to replace H.01 and H.30 in the group VcsDirectCallOptionsProv of this file. The migrate escape here (DcComponent::migrateFaxEscape) propagates the old provisioning data under H.01 and H.30 into discardPriority and transferPriority. The rule of the above propagation are: 0 in H.01 is equivalent to discardPriority 0; 1 in H.01 is equivalent to discardPriority 1. And 0 in H.30 is equivalent to transferPriority normal; 1 in H.30 is equivalent to transferPriority high. Please refer to discardPriority and transferPriority for more information on how to use them.')
appnDlciDcNfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 283, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciDcIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciDcNfaIndex"))
if mibBuilder.loadTexts: appnDlciDcNfaEntry.setStatus('obsolete')
if mibBuilder.loadTexts: appnDlciDcNfaEntry.setDescription('An entry in the appnDlciDcNfaTable.')
appnDlciDcNfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 283, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(48, 48), )))
if mibBuilder.loadTexts: appnDlciDcNfaIndex.setStatus('obsolete')
if mibBuilder.loadTexts: appnDlciDcNfaIndex.setDescription('This variable represents the index for the appnDlciDcNfaTable.')
appnDlciDcNfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 283, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciDcNfaValue.setStatus('obsolete')
if mibBuilder.loadTexts: appnDlciDcNfaValue.setDescription('This variable represents an individual value for the appnDlciDcNfaTable.')
appnDlciDcNfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 2, 283, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: appnDlciDcNfaRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: appnDlciDcNfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the appnDlciDcNfaTable.')
appnDlciVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3))
appnDlciVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1), )
if mibBuilder.loadTexts: appnDlciVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciVc components.')
appnDlciVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcIndex"))
if mibBuilder.loadTexts: appnDlciVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciVc component.')
appnDlciVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciVc components. These components cannot be added nor deleted.')
appnDlciVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcStorageType.setDescription('This variable represents the storage type value for the appnDlciVc tables.')
appnDlciVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDlciVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcIndex.setDescription('This variable represents the index for the appnDlciVc tables.')
appnDlciVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10), )
if mibBuilder.loadTexts: appnDlciVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCadTable.setDescription('This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
appnDlciVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcIndex"))
if mibBuilder.loadTexts: appnDlciVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCadEntry.setDescription('An entry in the appnDlciVcCadTable.')
appnDlciVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcType.setDescription('This attribute displays the type of call, pvc,svc or spvc.')
appnDlciVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
appnDlciVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
appnDlciVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
appnDlciVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
appnDlciVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
appnDlciVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
appnDlciVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
appnDlciVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
appnDlciVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
appnDlciVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
appnDlciVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
appnDlciVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
appnDlciVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPathReliability.setDescription('This attribute displays the path reliability.')
appnDlciVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
appnDlciVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
appnDlciVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
appnDlciVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
appnDlciVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
appnDlciVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
appnDlciVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
appnDlciVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
appnDlciVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
appnDlciVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11), )
if mibBuilder.loadTexts: appnDlciVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
appnDlciVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcIndex"))
if mibBuilder.loadTexts: appnDlciVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcIntdEntry.setDescription('An entry in the appnDlciVcIntdTable.')
appnDlciVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
appnDlciVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
appnDlciVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
appnDlciVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
appnDlciVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
appnDlciVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12), )
if mibBuilder.loadTexts: appnDlciVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcFrdTable.setDescription('This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
appnDlciVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcIndex"))
if mibBuilder.loadTexts: appnDlciVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcFrdEntry.setDescription('An entry in the appnDlciVcFrdTable.')
appnDlciVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
appnDlciVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
appnDlciVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
appnDlciVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
appnDlciVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
appnDlciVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
appnDlciVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
appnDlciVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
appnDlciVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
appnDlciVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
appnDlciVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
appnDlciVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
appnDlciVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
appnDlciVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
appnDlciVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
appnDlciVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
appnDlciVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
appnDlciVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 417), )
if mibBuilder.loadTexts: appnDlciVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDmepTable.setDescription('This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
appnDlciVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 417, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciVcDmepValue"))
if mibBuilder.loadTexts: appnDlciVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDmepEntry.setDescription('An entry in the appnDlciVcDmepTable.')
appnDlciVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 3, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciVcDmepValue.setDescription('This variable represents both the value and the index for the appnDlciVcDmepTable.')
appnDlciBnnLsDef = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4))
appnDlciBnnLsDefRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1), )
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciBnnLsDef components.')
appnDlciBnnLsDefRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBnnLsDefIndex"))
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciBnnLsDef component.')
appnDlciBnnLsDefRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciBnnLsDef components. These components can be added and deleted.')
appnDlciBnnLsDefComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBnnLsDefComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciBnnLsDefStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBnnLsDefStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefStorageType.setDescription('This variable represents the storage type value for the appnDlciBnnLsDef tables.')
appnDlciBnnLsDefIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(224, 224), ValueRangeConstraint(228, 228), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(240, 240), ValueRangeConstraint(244, 244), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )))
if mibBuilder.loadTexts: appnDlciBnnLsDefIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefIndex.setDescription('This variable represents the index for the appnDlciBnnLsDef tables.')
appnDlciBnnLsDefProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2), )
if mibBuilder.loadTexts: appnDlciBnnLsDefProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefProvTable.setDescription('This group contains the provisioning data for a Link Station on a frame relay DLCI.')
appnDlciBnnLsDefProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBnnLsDefIndex"))
if mibBuilder.loadTexts: appnDlciBnnLsDefProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefProvEntry.setDescription('An entry in the appnDlciBnnLsDefProvTable.')
appnDlciBnnLsDefDspuService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("none", 0), ("dlur", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefDspuService.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefDspuService.setDescription('This attribute specifies which down stream physical unit service is supported on this Link Station.')
appnDlciBnnLsDefAdjacentCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentCpName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentCpName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the adjacent node. This attribute is ignored if the adjacent node is not an APPN node. If this attribute is not empty it is checked against the name received from the adjacent node during the XID exchange, unless adjacentCpType is set to backLevelLenNode (in which case it is used to identify the adjacent node). The first portion of this name, up to the period, is the network identifier for the network to which the adjacent node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBnnLsDefAdjacentCpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("appnNode", 0), ("networkNode", 2), ("endNode", 3), ("backLevelLenNode", 5), ("hostXID3", 6), ("hostXID0", 7), ("dlurXID", 8), ("dlurNoXID", 9))).clone('appnNode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentCpType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentCpType.setDescription('This attribute specifies the adjacent control point (CP) type: networkNode - Specifies that the adjacent device is an APPN network node. endNode - Specifies that the adjacent device is an APPN end node. appnNode - Specifies that the adjacent device is an APPN node or an up-level LEN node, and the node type will be dynamically determined during XID exchange. backLevelLenNode - Specifies that the adjacent device is a back- level LEN node. hostXID3 - Specifies that the adjacent device is a host and that this APPN node should respond to a polling XID from the node with a format 3 XID. hostXID0 - Specifies that the adjacent device is a host and that this APPN node should respond to a polling XID from the node with a format 0 XID. dlurXID - Specifies that the adjacent device is a downstream PU requiring DLUR services and XID exchange in link activation dlurNoXID - Specifies that the adjacent device is a downstream PU requiring DLUR services and no XID exchange in link activation')
appnDlciBnnLsDefTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefTgNum.setDescription('This attribute specifies the TG number to be used for this link. It is only relevant if the adjacent device is an APPN node and is ignored otherwise. If adjacentCpType is set to backLevelLenNode this attribute is ignored and the TG number is assumed to be 1. If this attribute is set to zero (0), the TG number is dynamically assigned and can be determined from the tgNum attribute of the related LinkStation component. If this attribute is non-zero, the adjacentCpType must be set to appnNode, networkNode, endNode or backLevelLenNode, and the TG number on the adjacent device must also be set to the same value.')
appnDlciBnnLsDefDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 6), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefDlusName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the primary DLUS for this link station. This attribute is ignored if the adjacent device does not request DLUR services. This attribute overrides the primaryDefDlusName and secondaryDefDlusName specified in the DLUR component. If this attribute is empty, the primaryDefDlusName (specified in the DLUR component), or secondaryDefDlusName (specified in the DLUR component) will be used. The first portion of this name, up to the period, is the network identifier for the network to which the DLUS node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBnnLsDefBackupDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefBackupDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefBackupDlusName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the backup DLUS for this link station. This attribute is ignored if the adjacent device does not request DLUR services. This attribute overrides the primaryDefDlusName and secondaryDefDlusName specified in the DLUR component. If this attribute is empty and the dlusName attribute is empty, the primaryDefDlusName (specified in the DLUR component), or secondaryDefDlusName (specified in the DLUR component) will be used. If this attribute is specified, the dlusName attribute must also contain a non-empty string. The first portion of this name, up to the period, is the network identifier for the network to which the DLUS node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBnnLsDefHprSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("sameAsNode", 1))).clone('sameAsNode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefHprSupported.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefHprSupported.setDescription('This attribute specifies whether high performance routing (HPR) is supported on this link station. If this attribute is set to sameAsNode, and the hprSupport attribute in the APPN component is set to either rtp or anr, HPR will be negotiated with the remote node, if the hprSupport attrbute in the APPN component is set to no HPR will not be negotiated with the remote node. If this attribute is set to no, HPR will not be negotiated on this link station. The results of this negotiation are visible in the hprSupport attribute of the related LinkStation component')
appnDlciBnnLsDefAdjacentNodeID = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 9), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentNodeID.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefAdjacentNodeID.setDescription('This attribute specifies the node id of the adjacent device. This attribute, if non-zero, is used to check the identity of the adjacent device. If this attribute is zero, the identity is not checked. If adjacentCpType is set to dlurNoXID, this attribute is used to identify the downstream PU to the DLUS.')
appnDlciBnnLsDefCpCpSessionSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefCpCpSessionSupport.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefCpCpSessionSupport.setDescription('This attribute specifies whether this link station supports CP-CP sessions. This attribute is ignored if the adjacent device is not an APPN node.')
appnDlciBnnLsDefMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(99, 32768)).clone(2048)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefMaxTxBtuSize.setDescription('This attribute specifies the maximum basic transmission unit (BTU) size that can be sent on this link station. This attribute is used to negotiate the maximum BTU size that can be transmitted between a link station pair. If the link and node are HPR-capable, then this attribute must be set to a value greater than or equal to 768.')
appnDlciBnnLsDefLsRole = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("negotiable", 0), ("primary", 1), ("secondary", 2))).clone('negotiable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBnnLsDefLsRole.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBnnLsDefLsRole.setDescription('This attribute specifies the role for this link station. This attribute will be ignored if adjacentCpType is set to hostXID0 or hostXID3 (the link station will always be secondary), or if adjacentCpType is set to dlurXID or dlurNoXID (the link station will always be primary).')
appnDlciSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5))
appnDlciSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1), )
if mibBuilder.loadTexts: appnDlciSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciSp components.')
appnDlciSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciSpIndex"))
if mibBuilder.loadTexts: appnDlciSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciSp component.')
appnDlciSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciSp components. These components cannot be added nor deleted.')
appnDlciSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpStorageType.setDescription('This variable represents the storage type value for the appnDlciSp tables.')
appnDlciSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDlciSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpIndex.setDescription('This variable represents the index for the appnDlciSp tables.')
appnDlciSpParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11), )
if mibBuilder.loadTexts: appnDlciSpParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpParmsTable.setDescription('This group contains the provisionable attributes for the Data Link Connection Identifier. These attributes reflect the service parameters specific to this instance of Dlci.')
appnDlciSpParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciSpIndex"))
if mibBuilder.loadTexts: appnDlciSpParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpParmsEntry.setDescription('An entry in the appnDlciSpParmsTable.')
appnDlciSpRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciSpRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpRateEnforcement.setDescription('This attribute specifies whether rate enforcement is to be used on this DLCI. Turning on rate enforcement means that the data sent from the service to the virtual circuit is subjected to rate control.')
appnDlciSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (cir) in bits per second (bit/s). When rateEnforcement is set to on, cir is the rate at which the network agrees to transfer information under normal conditions. This rate is measured over a measurement interval (t) that is determined internally based on cir and the committed burst size (bc). An exception to this occurs when cir is provisioned to be zero, in which case the measurement interval (t) must be provisioned explicitly. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, bc must also be 0.')
appnDlciSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (bc) in bits. bc is the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t). Data marked DE=1 is not accounted for in bc. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, cir must also be 0.')
appnDlciSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (be) in bits. be is the amount of uncommitted data that the network will attempt to deliver over measurement interval (t). Data marked DE=1 by the user or by the network is accounted for here. cir, bc, and be cannot all be 0 when rateEnforcement is on.')
appnDlciSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 5, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciSpMeasurementInterval.setDescription('This attribute specifies the time interval (in milliseconds) over which rates and burst sizes are measured. When cir and bc are 0 and rateEnforcement is on, this attribute must be provisioned. When cir and bc are non-zero, the time interval is internally calculated. In that situation, this attribute is ignored, and is not representative of the time interval. This attribute is also ignored when rateEnforcement is off. If rateEnforcement is on and both cir and bc are 0, this field must be non-zero.')
appnDlciBanLsDef = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6))
appnDlciBanLsDefRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1), )
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciBanLsDef components.')
appnDlciBanLsDefRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanLsDefMacIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanLsDefSapIndex"))
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciBanLsDef component.')
appnDlciBanLsDefRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciBanLsDef components. These components can be added and deleted.')
appnDlciBanLsDefComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBanLsDefComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciBanLsDefStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBanLsDefStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefStorageType.setDescription('This variable represents the storage type value for the appnDlciBanLsDef tables.')
appnDlciBanLsDefMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: appnDlciBanLsDefMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefMacIndex.setDescription('This variable represents an index for the appnDlciBanLsDef tables.')
appnDlciBanLsDefSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(224, 224), ValueRangeConstraint(228, 228), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(240, 240), ValueRangeConstraint(244, 244), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )))
if mibBuilder.loadTexts: appnDlciBanLsDefSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefSapIndex.setDescription('This variable represents an index for the appnDlciBanLsDef tables.')
appnDlciBanLsDefProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2), )
if mibBuilder.loadTexts: appnDlciBanLsDefProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefProvTable.setDescription('This group contains the provisioning data for a Link Station on a frame relay DLCI.')
appnDlciBanLsDefProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanLsDefMacIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanLsDefSapIndex"))
if mibBuilder.loadTexts: appnDlciBanLsDefProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefProvEntry.setDescription('An entry in the appnDlciBanLsDefProvTable.')
appnDlciBanLsDefDspuService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("none", 0), ("dlur", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefDspuService.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefDspuService.setDescription('This attribute specifies which down stream physical unit service is supported on this Link Station.')
appnDlciBanLsDefAdjacentCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentCpName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentCpName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the adjacent node. This attribute is ignored if the adjacent node is not an APPN node. If this attribute is not empty it is checked against the name received from the adjacent node during the XID exchange, unless adjacentCpType is set to backLevelLenNode (in which case it is used to identify the adjacent node). The first portion of this name, up to the period, is the network identifier for the network to which the adjacent node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBanLsDefAdjacentCpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("appnNode", 0), ("networkNode", 2), ("endNode", 3), ("backLevelLenNode", 5), ("hostXID3", 6), ("hostXID0", 7), ("dlurXID", 8), ("dlurNoXID", 9))).clone('appnNode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentCpType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentCpType.setDescription('This attribute specifies the adjacent control point (CP) type: networkNode - Specifies that the adjacent device is an APPN network node. endNode - Specifies that the adjacent device is an APPN end node. appnNode - Specifies that the adjacent device is an APPN node or an up-level LEN node, and the node type will be dynamically determined during XID exchange. backLevelLenNode - Specifies that the adjacent device is a back- level LEN node. hostXID3 - Specifies that the adjacent device is a host and that this APPN node should respond to a polling XID from the node with a format 3 XID. hostXID0 - Specifies that the adjacent device is a host and that this APPN node should respond to a polling XID from the node with a format 0 XID. dlurXID - Specifies that the adjacent device is a downstream PU requiring DLUR services and XID exchange in link activation dlurNoXID - Specifies that the adjacent device is a downstream PU requiring DLUR services and no XID exchange in link activation')
appnDlciBanLsDefTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefTgNum.setDescription('This attribute specifies the TG number to be used for this link. It is only relevant if the adjacent device is an APPN node and is ignored otherwise. If adjacentCpType is set to backLevelLenNode this attribute is ignored and the TG number is assumed to be 1. If this attribute is set to zero (0), the TG number is dynamically assigned and can be determined from the tgNum attribute of the related LinkStation component. If this attribute is non-zero, the adjacentCpType must be set to appnNode, networkNode, endNode or backLevelLenNode, and the TG number on the adjacent device must also be set to the same value.')
appnDlciBanLsDefDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 6), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefDlusName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the primary DLUS for this link station. This attribute is ignored if the adjacent device does not request DLUR services. This attribute overrides the primaryDefDlusName and secondaryDefDlusName specified in the DLUR component. If this attribute is empty, the primaryDefDlusName (specified in the DLUR component), or secondaryDefDlusName (specified in the DLUR component) will be used. The first portion of this name, up to the period, is the network identifier for the network to which the DLUS node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBanLsDefBackupDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefBackupDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefBackupDlusName.setDescription('This attribute specifies the fully qualified control point (FQCP) name of the backup DLUS for this link station. This attribute is ignored if the adjacent device does not request DLUR services. This attribute overrides the primaryDefDlusName and secondaryDefDlusName specified in the DLUR component. If this attribute is empty and the dlusName attribute is empty, the primaryDefDlusName (specified in the DLUR component), or secondaryDefDlusName (specified in the DLUR component) will be used. If this attribute is specified, the dlusName attribute must also contain a non-empty string. The first portion of this name, up to the period, is the network identifier for the network to which the DLUS node belongs. An APPN network is a portion of a virtual private network which has a separately administered name space. This network identifier is the implicit qualifier of all resources which do not have an explicit network identifier.')
appnDlciBanLsDefHprSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("sameAsNode", 1))).clone('sameAsNode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefHprSupported.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefHprSupported.setDescription('This attribute specifies whether high performance routing (HPR) is supported on this link station. If this attribute is set to sameAsNode, and the hprSupport attribute in the APPN component is set to either rtp or anr, HPR will be negotiated with the remote node, if the hprSupport attrbute in the APPN component is set to no HPR will not be negotiated with the remote node. If this attribute is set to no, HPR will not be negotiated on this link station. The results of this negotiation are visible in the hprSupport attribute of the related LinkStation component')
appnDlciBanLsDefAdjacentNodeID = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 9), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentNodeID.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefAdjacentNodeID.setDescription('This attribute specifies the node id of the adjacent device. This attribute, if non-zero, is used to check the identity of the adjacent device. If this attribute is zero, the identity is not checked. If adjacentCpType is set to dlurNoXID, this attribute is used to identify the downstream PU to the DLUS.')
appnDlciBanLsDefCpCpSessionSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefCpCpSessionSupport.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefCpCpSessionSupport.setDescription('This attribute specifies whether this link station supports CP-CP sessions. This attribute is ignored if the adjacent device is not an APPN node.')
appnDlciBanLsDefMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(99, 32768)).clone(2048)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefMaxTxBtuSize.setDescription('This attribute specifies the maximum basic transmission unit (BTU) size that can be sent on this link station. This attribute is used to negotiate the maximum BTU size that can be transmitted between a link station pair. If the link and node are HPR-capable, then this attribute must be set to a value greater than or equal to 768.')
appnDlciBanLsDefLsRole = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("negotiable", 0), ("primary", 1), ("secondary", 2))).clone('negotiable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLsDefLsRole.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLsDefLsRole.setDescription('This attribute specifies the role for this link station. This attribute will be ignored if adjacentCpType is set to hostXID0 or hostXID3 (the link station will always be secondary), or if adjacentCpType is set to dlurXID or dlurNoXID (the link station will always be primary).')
appnDlciBan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7))
appnDlciBanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1), )
if mibBuilder.loadTexts: appnDlciBanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciBan components.')
appnDlciBanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanIndex"))
if mibBuilder.loadTexts: appnDlciBanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciBan component.')
appnDlciBanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciBan components. These components can be added and deleted.')
appnDlciBanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciBanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciBanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanStorageType.setDescription('This variable represents the storage type value for the appnDlciBan tables.')
appnDlciBanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDlciBanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanIndex.setDescription('This variable represents the index for the appnDlciBan tables.')
appnDlciBanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 2), )
if mibBuilder.loadTexts: appnDlciBanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanProvTable.setDescription('This group contains the provisioning data for the local link address (MAP,SAP pair) to be used for a Frame Relay connection with BAN encapsulation.')
appnDlciBanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 2, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciBanIndex"))
if mibBuilder.loadTexts: appnDlciBanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanProvEntry.setDescription('An entry in the appnDlciBanProvTable.')
appnDlciBanLocalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 2, 1, 1), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="4fff00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLocalMac.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLocalMac.setDescription('This attribute specifies the MAC address to be used for a Frame Relay connection with BAN encapsulation.')
appnDlciBanLocalSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 7, 2, 1, 2), Hex().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(224, 224), ValueRangeConstraint(228, 228), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(240, 240), ValueRangeConstraint(244, 244), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciBanLocalSap.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciBanLocalSap.setDescription('This attribute specifies the local SAP number to be used for a Frame Relay connection with BAN encapsulation.')
appnDlciCn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8))
appnDlciCnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1), )
if mibBuilder.loadTexts: appnDlciCnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnRowStatusTable.setDescription('This entry controls the addition and deletion of appnDlciCn components.')
appnDlciCnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlciCnIndex"))
if mibBuilder.loadTexts: appnDlciCnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnRowStatusEntry.setDescription('A single entry in the table represents a single appnDlciCn component.')
appnDlciCnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDlciCnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlciCn components. These components can be added and deleted.')
appnDlciCnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciCnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlciCnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlciCnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnStorageType.setDescription('This variable represents the storage type value for the appnDlciCn tables.')
appnDlciCnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 3, 8, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnDlciCnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlciCnIndex.setDescription('This variable represents the index for the appnDlciCn tables.')
appnLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4))
appnLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1), )
if mibBuilder.loadTexts: appnLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnRowStatusTable.setDescription('This entry controls the addition and deletion of appnLcn components.')
appnLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"))
if mibBuilder.loadTexts: appnLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnRowStatusEntry.setDescription('A single entry in the table represents a single appnLcn component.')
appnLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnLcn components. These components can be added and deleted.')
appnLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnStorageType.setDescription('This variable represents the storage type value for the appnLcn tables.')
appnLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: appnLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnIndex.setDescription('This variable represents the index for the appnLcn tables.')
appnLcnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 10), )
if mibBuilder.loadTexts: appnLcnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
appnLcnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"))
if mibBuilder.loadTexts: appnLcnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnStateEntry.setDescription('An entry in the appnLcnStateTable.')
appnLcnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
appnLcnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
appnLcnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
appnLcnDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2))
appnLcnDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1), )
if mibBuilder.loadTexts: appnLcnDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcRowStatusTable.setDescription('This entry controls the addition and deletion of appnLcnDc components.')
appnLcnDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnDcIndex"))
if mibBuilder.loadTexts: appnLcnDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcRowStatusEntry.setDescription('A single entry in the table represents a single appnLcnDc component.')
appnLcnDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnLcnDc components. These components cannot be added nor deleted.')
appnLcnDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnLcnDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcStorageType.setDescription('This variable represents the storage type value for the appnLcnDc tables.')
appnLcnDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnLcnDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcIndex.setDescription('This variable represents the index for the appnLcnDc tables.')
appnLcnDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10), )
if mibBuilder.loadTexts: appnLcnDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcOptionsTable.setDescription('Options group defines attributes associated with direct call. It defines complete connection in terms of path and call options. This connection can be permanent (pvc) or switched (svc). It can have facilities. The total number of bytes of facilities including the facility codes, and all of the facility data from all of the four classes of facilities: CCITT_Facilities DTE_Facilities National_Facilities International_Facilities must not exceed 512 bytes.')
appnLcnDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnDcIndex"))
if mibBuilder.loadTexts: appnLcnDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcOptionsEntry.setDescription('An entry in the appnLcnDcOptionsTable.')
appnLcnDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLcnDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcRemoteNpi.setDescription('RemoteNumbering Plan Indicator (Npi) indicates the numbering plan used in the remoteDna.')
appnLcnDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLcnDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent. Initially, the called DTE address attribute must be present, that is, there must be a valid destination address. However, it may be possible in the future to configure the direct call with a mnemonic address, in which case, this attribute will contain a zero-length Dna, and the mnemonic address will be carried as one of the facilities.')
appnLcnDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9, 255))).clone(namedValues=NamedValues(("normal", 0), ("high", 9), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLcnDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcTransferPriority.setDescription('This attribute specifies the transfer priority to network for the outgoing calls using this particular LCN. It overRides the defaultTransferPriority provisioned in its associated Dna component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of transferPriority is useDnaDefTP. It means using the provisioning value under defaultTransferPriority of its associated Dna for this DLCI.')
appnLcnDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnLcnDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this LCN. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority are discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
appnLcnVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3))
appnLcnVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1), )
if mibBuilder.loadTexts: appnLcnVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcRowStatusTable.setDescription('This entry controls the addition and deletion of appnLcnVc components.')
appnLcnVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnVcIndex"))
if mibBuilder.loadTexts: appnLcnVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcRowStatusEntry.setDescription('A single entry in the table represents a single appnLcnVc component.')
appnLcnVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnLcnVc components. These components cannot be added nor deleted.')
appnLcnVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnLcnVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcStorageType.setDescription('This variable represents the storage type value for the appnLcnVc tables.')
appnLcnVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnLcnVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcIndex.setDescription('This variable represents the index for the appnLcnVc tables.')
appnLcnVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10), )
if mibBuilder.loadTexts: appnLcnVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCadTable.setDescription('This group represents operational call data related to General Vc. It can be displayed only for General Vc which is created by application.')
appnLcnVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnVcIndex"))
if mibBuilder.loadTexts: appnLcnVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCadEntry.setDescription('An entry in the appnLcnVcCadTable.')
appnLcnVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcType.setDescription('This attribute displays the type of call, pvc or svc. type is provided at provisioning time.')
appnLcnVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
appnLcnVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
appnLcnVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
appnLcnVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
appnLcnVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
appnLcnVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
appnLcnVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
appnLcnVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
appnLcnVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
appnLcnVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
appnLcnVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
appnLcnVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
appnLcnVcLocalRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcLocalRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcLocalRxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
appnLcnVcLocalTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcLocalTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcLocalTxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
appnLcnVcLocalTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcLocalTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcLocalTxWindowSize.setDescription('This attribute displays the send window size provided on incoming call packets or the default when a call request packet does not explicitly provide the window size.')
appnLcnVcLocalRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcLocalRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcLocalRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets or the default when a call request does not explicitly provide the window sizes.')
appnLcnVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPathReliability.setDescription('This attribute displays the path reliability.')
appnLcnVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
appnLcnVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
appnLcnVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
appnLcnVcSubnetTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSubnetTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSubnetTxPktSize.setDescription('This attribute displays the locally negotiated size of the data packets on this Vc.')
appnLcnVcSubnetTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSubnetTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSubnetTxWindowSize.setDescription('This attribute displays the current send window size of Vc.')
appnLcnVcSubnetRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSubnetRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSubnetRxPktSize.setDescription('This attribute displays the locally negotiated size of receive packets.')
appnLcnVcSubnetRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSubnetRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSubnetRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets and to the default when a call request does not explicitly provide the window sizes.')
appnLcnVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcMaxSubnetPktSize.setDescription('This attribute displays the maximum packet size allowed on Vc.')
appnLcnVcTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcTransferPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcTransferPriorityToNetwork.setDescription('This attribute displays the priority in which data is transferred to the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput.')
appnLcnVcTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcTransferPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcTransferPriorityFromNetwork.setDescription('This attribute displays the priority in which data is transferred from the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, and the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, and the routing metric is set to throughput.')
appnLcnVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11), )
if mibBuilder.loadTexts: appnLcnVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
appnLcnVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnVcIndex"))
if mibBuilder.loadTexts: appnLcnVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcIntdEntry.setDescription('An entry in the appnLcnVcIntdTable.')
appnLcnVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
appnLcnVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
appnLcnVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
appnLcnVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
appnLcnVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
appnLcnVcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12), )
if mibBuilder.loadTexts: appnLcnVcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcStatsTable.setDescription('... Statistics(Stats) This group defines general attributes collected by general Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods.')
appnLcnVcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLcnVcIndex"))
if mibBuilder.loadTexts: appnLcnVcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcStatsEntry.setDescription('An entry in the appnLcnVcStatsTable.')
appnLcnVcAckStackingTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcAckStackingTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcAckStackingTimeouts.setDescription('This attribute counts the number of ack stacking timer expiries. It is used as an indicator of the acknowledgment behavior across the subnet when ack stacking is in effect. If it expires often, usually this means end users will experience longer delay. The ack stacking timer specifies how long the Vc will wait before finally sending the subnet acknowledgment. if this attribute is set to a value of 0, then the Vc will automatically return acknowledgment packets without delay. If this attribute is set to a value other than zero, then the Vc will wait for this amount of time in an attempt to piggyback the acknowledgment packet on another credit or data packet. If the Vc cannot piggyback the acknowledgment packet within this time, then the packet is returned without piggybacking.')
appnLcnVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcOutOfRangeFrmFromSubnet.setDescription('This attribute counts the number of subnet frames discarded due to the sequence number being out of range. Two Categories apply for the General Vc 1) lost Acks (previous Range) 2) unexpected Packets (next Range) Vc internally maintains its own sequence number of packet order and sequencing. Due to packet retransmission, Vc may receive duplicate packets that have the same Vc internal sequence number. Only 1 copy is accepted by the Vc and other copies of the same packets are detected through this count. This attribute can be used to record the frequency of packet retransmission due to Vc and other part of the subnet.')
appnLcnVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcDuplicatesFromSubnet.setDescription('This attribute counts the number of subnet packets discarded due to duplication. It is used to detect software error fault or duplication caused by retransmitting.')
appnLcnVcFrmRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcFrmRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcFrmRetryTimeouts.setDescription('This attribute counts the number of frames which have retransmission time-out. If packets from Vc into the subnet are discarded by the subnet, the source Vc will not receive any acknowledgment. The retransmission timer then expires and packets will be retransmitted again. Note that the Vc idle probe may be retransmitted and is included in this count. This statistics does not show the distribution of how many times packets are retransmitted (e.g. first retransmission results in successful packet forwarding).')
appnLcnVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPeakRetryQueueSize.setDescription('This attribute indicates the peak size of the retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest body of unacknowledged packets.')
appnLcnVcPeakOoSeqQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPeakOoSeqQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPeakOoSeqQueueSize.setDescription('This attribute indicates the peak size of the out of sequence queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets.')
appnLcnVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPeakOoSeqFrmForwarded.setDescription('This attribute indicates the peak size of the sequence packet queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets, which by the receipt of an expected packet have been transformed to expected packets. The number of times this peak is reached is not recorded as it is traffic dependent.')
appnLcnVcPeakStackedAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcPeakStackedAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcPeakStackedAcksRx.setDescription('This attribute indicates the peak size of wait acks. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest collective acknowledgment.')
appnLcnVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcSubnetRecoveries.setDescription('This attribute counts the number of successful Vc recovery attempts. This attribute is used as an indicator of how many times the Vc path is broken but can be recovered. This attribute is useful to record the number of network path failures.')
appnLcnVcWindowClosuresToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcWindowClosuresToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcWindowClosuresToSubnet.setDescription('This attribute counts the number of window closures to subnet. A packet may have been sent into the subnet but its acknowledgment from the remote Vc has not yet been received. This is a 8 bit sequence number.This number is useful in detecting whether the Vc is sending any packet into the subnet.')
appnLcnVcWindowClosuresFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcWindowClosuresFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcWindowClosuresFromSubnet.setDescription('This attribute counts the number of window closures from subnet. This attribute is useful in detecting whether the Vc is receiving any packet from the subnet.')
appnLcnVcWrTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 4, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLcnVcWrTriggers.setStatus('mandatory')
if mibBuilder.loadTexts: appnLcnVcWrTriggers.setDescription('This attribute displays the number of times the Vc stays within the W-R region. The W-R region is a value used to determined the timing of credit transmission. Should the current window size be beneath this value, the credits will be transmitted immediately. Otherwise, they will be transmitted later with actual data. The wrTriggers statistic is therefore used to analyze the flow control and credit mechanism.')
appnPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5))
appnPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1), )
if mibBuilder.loadTexts: appnPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnPort components.')
appnPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnPortIndex"))
if mibBuilder.loadTexts: appnPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortRowStatusEntry.setDescription('A single entry in the table represents a single appnPort component.')
appnPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnPort components. These components cannot be added nor deleted.')
appnPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortStorageType.setDescription('This variable represents the storage type value for the appnPort tables.')
appnPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortIndex.setDescription('This variable represents the index for the appnPort tables.')
appnPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10), )
if mibBuilder.loadTexts: appnPortConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortConfigTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Learned attributes of a SNA Port.')
appnPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnPortIndex"))
if mibBuilder.loadTexts: appnPortConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortConfigEntry.setDescription('An entry in the appnPortConfigTable.')
appnPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonSwitched", 1), ("switched", 2), ("sharedAccessFacilities", 3))).clone('sharedAccessFacilities')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortType.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortType.setDescription('This attribute specifies the type of line used by the port. The possible values are: nonSwitched - switched - sharedAccessFacilities -')
appnPortMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2048)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortMaxRxBtuSize.setDescription('This is the maximum basic transmission unit (BTU) size that can be received. The BTU is the unit of data and control information passed between path control components.')
appnPortMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2048)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortMaxTxBtuSize.setDescription('This is the maximum basic transmission unit (BTU) size that can be sent. The BTU is the unit of data and control information passed between path control components.')
appnPortTotLinkActLim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(99)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortTotLinkActLim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortTotLinkActLim.setDescription('This is the total link activation limit. This is the maximum number of active adjacent link stations the port will support. This value limits the number of adjacent link stations that can be concurrently connected to the local node through this port. The limit includes adjacent link stations connected by both inbound and outbound link activations. The distinction of inbound or outbound for link activations is used to indicate which node initiated the connection. For inbound link activations, the adjacent link station initiates the connection with the local link station. For outbound link activations, the local node initiates the connection with the adjacent link station. totLinkActLim must be greater than either inbLinkActLim or outLinkActLim, but it should not greater than the sum of inbLinkActLim and outLinkActLim.')
appnPortInbLinkActLim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(97)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortInbLinkActLim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortInbLinkActLim.setDescription('This is the inbound link activation limit. This is the maximum number of link stations which can be simultaneously active as a result of connection initiations from adjacent nodes.')
appnPortOutLinkActLim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortOutLinkActLim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortOutLinkActLim.setDescription('This is the outbound link activation limit. This is the maximum number of link stations which can be simultaneously active as a result of connection initiations by the local node.')
appnPortLsRole = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("negotiable", 3))).clone('negotiable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortLsRole.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortLsRole.setDescription("This is the initial role of the port's local link station when communicating with an adjacent link station. The possible options are negotiable, primary and secondary.")
appnPortActXidExchLim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortActXidExchLim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortActXidExchLim.setDescription('This is the exchange limit for activation XIDs.')
appnPortNonactXidExchLim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortNonactXidExchLim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortNonactXidExchLim.setDescription('This is the exchange limit for non-activation XIDs.')
appnPortLsXmitRxCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("twa", 0), ("tws", 1))).clone('tws')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortLsXmitRxCap.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortLsXmitRxCap.setDescription('This is Link Station transmit/receive capability. This is either tws (two-way simultaneous (full-duplex)) or twa (two-way alternate (half-duplex)).')
appnPortMaxIfrmRxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortMaxIfrmRxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortMaxIfrmRxWindow.setDescription('This is the maximum number of I-frames that can be received by the local link stations before an acknowledgment is sent.')
appnPortTargetPacingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortTargetPacingCount.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortTargetPacingCount.setDescription('This is the desired pacing window size for BINDs on this transmission group. The number is significant only when fixed BIND pacing is being performed.')
appnPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11), )
if mibBuilder.loadTexts: appnPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Operational attributes of a SNA Port.')
appnPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnPortIndex"))
if mibBuilder.loadTexts: appnPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortOperEntry.setDescription('An entry in the appnPortOperTable.')
appnPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendingActive", 2), ("active", 3), ("pendingInactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortState.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortState.setDescription('The attribute represents the current operational state of the port. The value can be any of the following: inactive - pendingActive - active - pendingInactive -')
appnPortDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 30, 31))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("tokenRing", 6), ("frameRelay", 30), ("x25", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortDlcType.setDescription('Type of the DLC interface used by this port. Possible values are: sdlc - synchronous data link control x25 - QLLC logical link control tokenRing - IEEE 802.2 logical link control frameRelay - RFC1490 and IEEE 802.2 logical link control other - dlc type other than those listed above.')
appnPortSimRim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortSimRim.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortSimRim.setDescription('This attribute indicates whether Set Initialization Mode (SIM) and Receive Initialization Mode (RIM) are supported.')
appnPortDefinedLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDefinedLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortDefinedLsGoodXids.setDescription('This is the total number of successful XIDs that have been received on all of the defined link stations on this port since the last time this port was started.')
appnPortDefinedLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDefinedLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortDefinedLsBadXids.setDescription('This attributes contains the total number of unsuccessful XIDs that have been received on all of the defined link stations on this port since the last time this port was started.')
appnPortDynLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDynLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortDynLsGoodXids.setDescription('This is the total number of successful XIDs that have been received on all of the dynamic link stations on this port since the last time this port was started.')
appnPortDynLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 11, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortDynLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortDynLsBadXids.setDescription('This is the total number of unsuccessful XIDs that have been received on all of the dynamic link stations on this port since the last time this port was started.')
appnPortTgCharTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12), )
if mibBuilder.loadTexts: appnPortTgCharTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortTgCharTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** These attributes of the link station are in a group using a common structure. This set provides the TG characteristics of the link through this link station for route selection.')
appnPortTgCharEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnPortIndex"))
if mibBuilder.loadTexts: appnPortTgCharEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortTgCharEntry.setDescription('An entry in the appnPortTgCharTable.')
appnPortEffectiveCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("n600Gbps", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortEffectiveCap.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortEffectiveCap.setDescription('The effective capacity is an integer value that indicates the capacity in kilo bits per second. It is derived from the link bandwidth and the maximum load factor with the range of 0 thru 603,979,776.')
appnPortConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortConnectCost.setDescription('The cost-per-connect time is a characteristic represented by a single-byte value in the range 0 to 255 that expresses a relative cost of using a transmission group. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the transmission group. The cost-per-connect time values that a network administrator assigns to the transmission groups in a network should reflect the relative expense of each transmission group as compared to all other transmission groups in the network. A value of 0 means that the cost of connecting over the transmission group is at no additional cost (as in the case of a non-switched facility.')
appnPortByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortByteCost.setDescription('Cost-per-byte is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated transmission group. The units for cost-per-byte are user-defined. Like cost-per-connect-time, cost-per-byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnPortSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("unKnown", 0), ("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('nonSecure')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortSecurity.setDescription('This static characteristic indicates the level of security protection. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided unknown - has not been determined guardedConduit - guarded conduit; protected against physical tapping secureConduit - secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, e.g. satellite-connected, located in a nonsecure country.')
appnPortPropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153))).clone('terrestrial')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortPropagationDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortPropagationDelay.setDescription('The propagation delay is the length of time that it takes for a signal to propagate from one end of the transmission group to the other. Typical values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnPortUserDefinedParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortUserDefinedParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortUserDefinedParm1.setDescription('This is the user defined routing parameter in range 0-255.')
appnPortUserDefinedParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortUserDefinedParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortUserDefinedParm2.setDescription('This is the user defined routing parameter in range 0-255.')
appnPortUserDefinedParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 5, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortUserDefinedParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnPortUserDefinedParm3.setDescription('This is the user defined routing parameter in range 0-255.')
appnLs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6))
appnLsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1), )
if mibBuilder.loadTexts: appnLsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnLs components.')
appnLsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsRowStatusEntry.setDescription('A single entry in the table represents a single appnLs component.')
appnLsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnLs components. These components cannot be added nor deleted.')
appnLsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnLsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsStorageType.setDescription('This variable represents the storage type value for the appnLs tables.')
appnLsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnLsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsIndex.setDescription('This variable represents the index for the appnLs tables.')
appnLsLsVcReferenceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 10), )
if mibBuilder.loadTexts: appnLsLsVcReferenceTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsLsVcReferenceTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This identifies which physical interface is associated with this link station.')
appnLsLsVcReferenceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsLsVcReferenceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsLsVcReferenceEntry.setDescription('An entry in the appnLsLsVcReferenceTable.')
appnLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsName.setDescription('This string identifies which physical interface the link station is associated with.')
appnLsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 10, 1, 2), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsSap.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsSap.setDescription('This attribute indicates the SAP number of the device assigned to this link station. This field is only valid for dlcType of llc2. If the dlcType is not llc2, this field will be 0.')
appnLsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 11), )
if mibBuilder.loadTexts: appnLsConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsConfigTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the attributes that define the behavior of a SNA link station.')
appnLsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsConfigEntry.setDescription('An entry in the appnLsConfigTable.')
appnLsPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsPortName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsPortName.setDescription('This attribute contains the name of the port associated with this link station.')
appnLsFeatures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsFeatures.setDescription('Various optional features of a link station. autoActSupp If present specifies that the link can be activated automatically when required by a session. A link cannot be automatically activated from an independent LU session unless it has been started previously. The link cannot be defined to support CP-CP sessions and to be auto-activatable because this might cause inconsistent network behavior. limitedResource If present, specifies that this link station is to be deactivated when there are no sessions using the link. Note that link stations on a non- switched port cannot be configured as limited resource. backLvlLenEn If present, specifies that this link is to a back level LEN End Node. cpCpSessSupport If present, specifies that CP-CP sessions are supported by this link station. Description of bits: autoActSupp(0) limitedResource(1) backLvlLenEn(2) cpCpSessSupport(3)')
appnLsMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsMaxTxBtuSize.setDescription('This is the maximum basic transmission unit (BTU) size that can be sent. The BTU is the unit of data and control information passed between path control components.')
appnLsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12), )
if mibBuilder.loadTexts: appnLsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Operational data of the link station.')
appnLsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOperEntry.setDescription('An entry in the appnLsOperTable.')
appnLsDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 30, 31))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("tokenRing", 6), ("llc2", 30), ("x25", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsDlcType.setDescription('This attribute indicates the type of data link control that this LS is associated. Possible types are: sdlc - synchronous data link control x25 - QLLC logical link control tokenRing - IEEE 802.2 logical link control llc2 - RFC1490 and IEEE 802.2 logical link control. other - dlc type other than those listed above.')
appnLsLinkStationState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendingActive", 2), ("active", 3), ("pendingInactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsLinkStationState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsLinkStationState.setDescription('This the current state of the link station. The possible values are: inactive - active - pendingActive - pendingInactive -')
appnLsLinkStationSubState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("inactive", 1), ("sentReqOpnstn", 2), ("pendXidExch", 3), ("sentActAs", 4), ("sentSentMode", 5), ("active", 6), ("sentDeactAsOrd", 7), ("sentDiscOrd", 8), ("sentDestroyTg", 9), ("sentCreateTg", 10), ("sentConnReq", 11), ("pendRcvConnInd", 12), ("pendSendConnRsp", 13), ("sentConnRsp", 14), ("pendDeact", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsLinkStationSubState.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsLinkStationSubState.setDescription('This is the current sub-state of the link station. The possible values are: inactive, sentReqOpnstn, pendXidExch, sentActAs, sendSetMode, active, sentDeactAsOrd, sentDiscOrd, sentDestroyTg, sentCreateTg, sentConnReq,pendRcvConnInd, pendSendConnRsp, sentConnRsp, pendDeact. These are described in the APPN Architecture reference')
appnLsActSessCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsActSessCount.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsActSessCount.setDescription('This is the total number of active sessions (both endpoint and intermediate) using this link.')
appnLsActualCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsActualCpName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsActualCpName.setDescription('This is the actual network qualified adjacent control point (CP) name as determined from the XID 3 exchange.')
appnLsActualCpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("toBeDetermined", 0), ("networkNode", 1), ("endNode", 2), ("lowEntryNode", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsActualCpType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsActualCpType.setDescription('This is the actual type of adjacent node type as determined during contact negotiation. The possible types are: endNode lowEntryNode networkNode toBeDetermine')
appnLsDlcName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsDlcName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsDlcName.setDescription('This is the name of the port group associated with the port through which this link station is attached.')
appnLsDynamicOrDefined = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("defined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsDynamicOrDefined.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsDynamicOrDefined.setDescription('This attribute reflects whether the link was created explicitly or dynamically (either in response to a connection request from the adjacent node, or to connect dynamically to another node across a connection network). The possible values are dynamic or defined.')
appnLsMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMigration.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsMigration.setDescription('This attribute specifies whether the adjacent node is a migration level node, such as a low entry networking or LEN node.')
appnLsTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsTgNum.setDescription('This is the number associated with the transmission group using this link station. It can be used to distinguish it from other transmission groups to the same adjacent node.')
appnLsHprSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("anr", 1), ("rtp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsHprSupport.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsHprSupport.setDescription('This is the type of High Performance Routing (HPR) being used on this link station. It is one of anr, rtp or none. The value in this attribute are bounded by the values provisioned on this node and the attached node.')
appnLsAnrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 12, 1, 12), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsAnrLabel.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsAnrLabel.setDescription('This is the HPR ANR label associated with this link station.')
appnLsTgCharTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13), )
if mibBuilder.loadTexts: appnLsTgCharTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsTgCharTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** These attributes of the link station are in a group using a common structure. This set provides the TG characteristics of the link through this link station for route selection.')
appnLsTgCharEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsTgCharEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsTgCharEntry.setDescription('An entry in the appnLsTgCharTable.')
appnLsEffectiveCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("n600Gbps", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsEffectiveCap.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsEffectiveCap.setDescription('The effective capacity is an integer value that indicates the capacity in kilo bits per second. It is derived from the link bandwidth and the maximum load factor with the range of 0 thru 603,979,776.')
appnLsConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsConnectCost.setDescription('The cost-per-connect time is a characteristic represented by a single-byte value in the range 0 to 255 that expresses a relative cost of using a transmission group. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the transmission group. The cost-per-connect time values that a network administrator assigns to the transmission groups in a network should reflect the relative expense of each transmission group as compared to all other transmission groups in the network. A value of 0 means that the cost of connecting over the transmission group is at no additional cost (as in the case of a non-switched facility.')
appnLsByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsByteCost.setDescription('Cost-per-byte is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated transmission group. The units for cost-per-byte are user-defined. Like cost-per-connect-time, cost-per-byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnLsSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("unKnown", 0), ("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('nonSecure')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsSecurity.setDescription('This static characteristic indicates the level of security protection. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided unknown - has not been determined guardedConduit - guarded conduit; protected against physical tapping secureConduit - secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, e.g. satellite-connected, located in a nonsecure country.')
appnLsPropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153))).clone('terrestrial')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsPropagationDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsPropagationDelay.setDescription('The propagation delay is the length of time that it takes for a signal to propagate from one end of the transmission group to the other. Typical values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnLsUserDefinedParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsUserDefinedParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsUserDefinedParm1.setDescription('This is the user defined routing parameter in range 0-255.')
appnLsUserDefinedParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsUserDefinedParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsUserDefinedParm2.setDescription('This is the user defined routing parameter in range 0-255.')
appnLsUserDefinedParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 13, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsUserDefinedParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsUserDefinedParm3.setDescription('This is the user defined routing parameter in range 0-255.')
appnLsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14), )
if mibBuilder.loadTexts: appnLsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational statistics of the link station.')
appnLsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLsIndex"))
if mibBuilder.loadTexts: appnLsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsStatsEntry.setDescription('An entry in the appnLsStatsTable.')
appnLsInXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInXidBytes.setDescription('This attribute counts the total number of XID bytes received on this link station.')
appnLsInMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInMsgBytes.setDescription('This attribute counts the total number of message (I-frame) bytes received on this link station.')
appnLsInXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInXidFrames.setDescription('This attribute counts the total number of XID frames received on this link station.')
appnLsInMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInMsgFrames.setDescription('This attribute counts the total number of message (I-frame) frames received on this link station.')
appnLsOutXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOutXidBytes.setDescription('This attribute counts the total number of XID bytes sent on this link station.')
appnLsOutMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOutMsgBytes.setDescription('This attribute counts the total number of message (I-frame) bytes sent on this link station.')
appnLsOutXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOutXidFrames.setDescription('This attribute counts the total number of XID frames sent on this link station.')
appnLsOutMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOutMsgFrames.setDescription('This attribute counts the total number of message (I-frame) frames sent on this link station.')
appnLsInInvalidSnaFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInInvalidSnaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInInvalidSnaFrames.setDescription('This attribute counts the total number of invalid SNA frames received on this link station.')
appnLsInSessionControlFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsInSessionControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsInSessionControlFrames.setDescription('This attribute counts the total number of session control frames received on this link station.')
appnLsOutSessionControlFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsOutSessionControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsOutSessionControlFrames.setDescription('This attribute counts the total number of session control frames sent on this link station.')
appnLsEchoResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsEchoResponse.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsEchoResponse.setDescription('This attribute counts the total number of echo responses returned from the adjacent node. A response should be returned for each test frame sent by this node. Echo requests are sent periodically to gauge the propagation delay to the adjacent node.')
appnLsCurrentDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsCurrentDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsCurrentDelay.setDescription('This attribute counts the time (in milliseconds) that it took for the last test signal to be sent and returned from this link station to the adjacent link station.')
appnLsMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsMaxDelay.setDescription('This is the longest time taken (in milliseconds) for a test signal to be sent and returned from this link station to the adjacent link station.')
appnLsMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsMinDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsMinDelay.setDescription('This is the shortest time taken (in milliseconds) for a test signal to be sent and returned from this link station to the adjacent link station.')
appnLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 17), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsGoodXids.setDescription('This attribute contains the total number of successful XIDs that have been received on this link station since it was started.')
appnLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 6, 14, 1, 18), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: appnLsBadXids.setDescription('This attribute contains the total number of unsuccessful XIDs that have been received on this link station since it was started.')
appnDirEnt = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7))
appnDirEntRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1), )
if mibBuilder.loadTexts: appnDirEntRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDirEnt components.')
appnDirEntRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDirEntIndex"))
if mibBuilder.loadTexts: appnDirEntRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntRowStatusEntry.setDescription('A single entry in the table represents a single appnDirEnt component.')
appnDirEntRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDirEnt components. These components cannot be added nor deleted.')
appnDirEntComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDirEntStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntStorageType.setDescription('This variable represents the storage type value for the appnDirEnt tables.')
appnDirEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnDirEntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntIndex.setDescription('This variable represents the index for the appnDirEnt tables.')
appnDirEntOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10), )
if mibBuilder.loadTexts: appnDirEntOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines the attributes of the Directory Entry server.')
appnDirEntOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDirEntIndex"))
if mibBuilder.loadTexts: appnDirEntOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntOperEntry.setDescription('An entry in the appnDirEntOperTable.')
appnDirEntServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntServerName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntServerName.setDescription('The fully-qualified control point (CP) name of the network node server. For unassociated end node entries, the end node fully- qualified name is returned.')
appnDirEntLuOwnerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntLuOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntLuOwnerName.setDescription('It is the fully-qualified CP name of the node at which the LU is located. This name is the same as the serving NN name when the LU is located at a network node or an unassociated end node. It is also the same as the fully-qualified LU name when this is the control point LU for this node.')
appnDirEntLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("domain", 1), ("xdomain", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntLocation.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntLocation.setDescription('Specifies the location of the resource. This may be one of the following: The resource is at the local node. The resource belongs to an attached end node. The resource is not within the domain of the local node.')
appnDirEntEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("cache", 0), ("register", 2), ("home", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntEntryType.setDescription('Specifies whether the type of the directory entry is: cache - The LU has previously been located by a broadcast search and the location information has been saved. home - The LU is in the domain of the local network node and the LU information has been configured at the local node. register - The LU is at an end node that is in the domain of the local network node. Registered entries are registered by the served end node.')
appnDirEntWildCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 7, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("explicit", 2), ("partialWildcard", 3), ("fullWildcard", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDirEntWildCard.setStatus('mandatory')
if mibBuilder.loadTexts: appnDirEntWildCard.setDescription('It indicates the type of wildcard used for the resources used for LEN node.')
appnAdjNn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8))
appnAdjNnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1), )
if mibBuilder.loadTexts: appnAdjNnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnAdjNn components.')
appnAdjNnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnAdjNnIndex"))
if mibBuilder.loadTexts: appnAdjNnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnRowStatusEntry.setDescription('A single entry in the table represents a single appnAdjNn component.')
appnAdjNnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnAdjNn components. These components cannot be added nor deleted.')
appnAdjNnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnAdjNnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnStorageType.setDescription('This variable represents the storage type value for the appnAdjNn tables.')
appnAdjNnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnAdjNnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnIndex.setDescription('This variable represents the index for the appnAdjNn tables.')
appnAdjNnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10), )
if mibBuilder.loadTexts: appnAdjNnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** These operational attributes are only available for network nodes which are directly attached to the current node. They are in a separate group.')
appnAdjNnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnAdjNnIndex"))
if mibBuilder.loadTexts: appnAdjNnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnOperEntry.setDescription('An entry in the appnAdjNnOperTable.')
appnAdjNnCpCpSessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("conLoserActive", 2), ("conWinnerActive", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnCpCpSessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnCpCpSessStatus.setDescription('Indicates the state of CP-CP sessions between this node and adjacent network and end nodes. Inactive indicates no CP-CP sessions exists between this node and the adjacent node. Active indicates CP-CP sessions are active using both the ConWinner and ConLoser sessions. The session initiated by this node is referred to as the ConWinner session and is used by this node to send to the adjacent node. The ConLoser session is initiated by the adjacent node and is used by this node to receive from the adjacent node.')
appnAdjNnOutOfSeqTdus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnOutOfSeqTdus.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnOutOfSeqTdus.setDescription('Number of out of sequence topology database updates (TDU) received from this node.')
appnAdjNnLastFrsnSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnLastFrsnSent.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnLastFrsnSent.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU sent to this adjacent node.')
appnAdjNnLastFrsnReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 8, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnAdjNnLastFrsnReceived.setStatus('mandatory')
if mibBuilder.loadTexts: appnAdjNnLastFrsnReceived.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU received from this adjacent node.')
appnNn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9))
appnNnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1), )
if mibBuilder.loadTexts: appnNnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnNn components.')
appnNnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnIndex"))
if mibBuilder.loadTexts: appnNnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnRowStatusEntry.setDescription('A single entry in the table represents a single appnNn component.')
appnNnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnNn components. These components cannot be added nor deleted.')
appnNnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnNnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnStorageType.setDescription('This variable represents the storage type value for the appnNn tables.')
appnNnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnNnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnIndex.setDescription('This variable represents the index for the appnNn tables.')
appnNnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10), )
if mibBuilder.loadTexts: appnNnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Operational attributes of a network node in the topology database.')
appnNnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnIndex"))
if mibBuilder.loadTexts: appnNnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnOperEntry.setDescription('An entry in the appnNnOperTable.')
appnNnDaysLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnDaysLeft.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnDaysLeft.setDescription('The number of days before deletion of this node entry from the Topology Database. This is set to zero for the local node entry, which always exists.')
appnNnNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("toBeDetermined", 0), ("networkNode", 1), ("virtualRoutingNode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnNodeType.setDescription('Type of the APPN node. Possible values are networkNode (nn) and virtualRoutingNode (vrn).')
appnNnResourceSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnResourceSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnResourceSequenceNumber.setDescription('Resource sequence number. This is assigned by the network node that owns this resource.')
appnNnRouteAdditionResistance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnRouteAdditionResistance.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnRouteAdditionResistance.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. This value is used for route computation. The lower the value, the more desirable the node is for intermediate routing.')
appnNnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnStatus.setDescription('This attribute specifies the status of the node. This may be one or more of the following: congested - If present, indicates that this node is congested. This node is not be included in route selection by other nodes when this congestion exists. irrDepleted - If present, indicates that intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted. SNMP APPN MIB = ibmappnNnNodeIsrDepleted errDepleted - If present, indicates that session endpoint resources are depleted. quiescing - If present, indicates that the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing. Description of bits: congested(0) irrDepleted(1) errDepleted(2) quiescing(3)')
appnNnFunctionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 9, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnFunctionSupported.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnFunctionSupported.setDescription('This attribute specifies which functions are supported. This may be one or more of the following: borderNode - If present, indicates that border node functionality is supported. centralDirectoryServer -If present, indicates that the node is a central directory. gateway - If present, indicates that the node provides gateway functions. isr - If present, indicates that the node supports intermediate session routing. Description of bits: notused0(0) gateway(1) centralDirectoryServer(2) hpr(3) rtp(4) isr(5) borderNode(6)')
appnLocTg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10))
appnLocTgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1), )
if mibBuilder.loadTexts: appnLocTgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnLocTg components.')
appnLocTgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnLocTgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgRowStatusEntry.setDescription('A single entry in the table represents a single appnLocTg component.')
appnLocTgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnLocTg components. These components cannot be added nor deleted.')
appnLocTgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnLocTgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgStorageType.setDescription('This variable represents the storage type value for the appnLocTg tables.')
appnLocTgDestFqcpNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 17)))
if mibBuilder.loadTexts: appnLocTgDestFqcpNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgDestFqcpNameIndex.setDescription('This variable represents an index for the appnLocTg tables.')
appnLocTgTransmissionGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnLocTgTransmissionGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgTransmissionGroupIndex.setDescription('This variable represents an index for the appnLocTg tables.')
appnLocTgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 10), )
if mibBuilder.loadTexts: appnLocTgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Gives the operational status of the local node transmission group.')
appnLocTgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnLocTgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgOperEntry.setDescription('An entry in the appnLocTgOperTable.')
appnLocTgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgStatus.setDescription('Status of the transmission group can be one of operational, CpCpSession or quiescing. Description of bits: notused0(0) notused1(1) notused2(2) notused3(3) cpCpSession(4) quiescing(5) notused6(6) operational(7)')
appnLocTgResourceSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgResourceSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgResourceSequenceNumber.setDescription('This attribute contains the resource sequence number.')
appnLocTgLinkAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 11), )
if mibBuilder.loadTexts: appnLocTgLinkAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgLinkAddressTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Contains the attribute for destination address.')
appnLocTgLinkAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnLocTgLinkAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgLinkAddressEntry.setDescription('An entry in the appnLocTgLinkAddressTable.')
appnLocTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 11, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgDlcData.setDescription('This attribute contains specific data related to the link connection. Token-Ring - contains MAC/SAP X.25 Switched - contains dial digits X.21 Switched - contains dial digits Circuit Switched - contains dial digits Frame-Relay - contains DLCI and SAP The value will be set to zero if the destination node type is not a virtual routing node.')
appnLocTgTgCharTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12), )
if mibBuilder.loadTexts: appnLocTgTgCharTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgTgCharTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** These attributes of the link station are in a group using a common structure. This set provides the TG characteristics of the link through this link station for route selection.')
appnLocTgTgCharEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnLocTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnLocTgTgCharEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgTgCharEntry.setDescription('An entry in the appnLocTgTgCharTable.')
appnLocTgEffectiveCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("n600Gbps", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgEffectiveCap.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgEffectiveCap.setDescription('The effective capacity is an integer value that indicates the capacity in kilo bits per second. It is derived from the link bandwidth and the maximum load factor with the range of 0 thru 603,979,776.')
appnLocTgConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgConnectCost.setDescription('The cost-per-connect time is a characteristic represented by a single-byte value in the range 0 to 255 that expresses a relative cost of using a transmission group. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the transmission group. The cost-per-connect time values that a network administrator assigns to the transmission groups in a network should reflect the relative expense of each transmission group as compared to all other transmission groups in the network. A value of 0 means that the cost of connecting over the transmission group is at no additional cost (as in the case of a non-switched facility.')
appnLocTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgByteCost.setDescription('Cost-per-byte is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated transmission group. The units for cost-per-byte are user-defined. Like cost-per-connect-time, cost-per-byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnLocTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("unKnown", 0), ("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('nonSecure')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgSecurity.setDescription('This static characteristic indicates the level of security protection. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided unknown - has not been determined guardedConduit - guarded conduit; protected against physical tapping secureConduit - secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, e.g. satellite-connected, located in a nonsecure country.')
appnLocTgPropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153))).clone('terrestrial')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgPropagationDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgPropagationDelay.setDescription('The propagation delay is the length of time that it takes for a signal to propagate from one end of the transmission group to the other. Typical values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnLocTgUserDefinedParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgUserDefinedParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgUserDefinedParm1.setDescription('This is the user defined routing parameter in range 0-255.')
appnLocTgUserDefinedParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgUserDefinedParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgUserDefinedParm2.setDescription('This is the user defined routing parameter in range 0-255.')
appnLocTgUserDefinedParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 10, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocTgUserDefinedParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnLocTgUserDefinedParm3.setDescription('This is the user defined routing parameter in range 0-255.')
appnIsrSess = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11))
appnIsrSessRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1), )
if mibBuilder.loadTexts: appnIsrSessRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnIsrSess components.')
appnIsrSessRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"))
if mibBuilder.loadTexts: appnIsrSessRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessRowStatusEntry.setDescription('A single entry in the table represents a single appnIsrSess component.')
appnIsrSessRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnIsrSess components. These components cannot be added nor deleted.')
appnIsrSessComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnIsrSessStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessStorageType.setDescription('This variable represents the storage type value for the appnIsrSess tables.')
appnIsrSessFqcpNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 17)))
if mibBuilder.loadTexts: appnIsrSessFqcpNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessFqcpNameIndex.setDescription('This variable represents an index for the appnIsrSess tables.')
appnIsrSessProcedureCorrelationIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 1, 1, 11), HexString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: appnIsrSessProcedureCorrelationIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessProcedureCorrelationIdIndex.setDescription('This variable represents an index for the appnIsrSess tables.')
appnIsrSessOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 10), )
if mibBuilder.loadTexts: appnIsrSessOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains dynamic information about an intermediate session for which the network node is providing transit routing.')
appnIsrSessOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"))
if mibBuilder.loadTexts: appnIsrSessOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessOperEntry.setDescription('An entry in the appnIsrSessOperTable.')
appnIsrSessTransmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessTransmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessTransmissionPriority.setDescription('This attribute contains the transmission priority. This is one of low, medium, high or network.')
appnIsrSessCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessCosName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessCosName.setDescription('This is the class of service used to select the route. Class of service (COS) is a designation of the transport network characteristics, such as route security, transmission priority, and bandwidth, needed for a particular session. The class of service is derived from the mode name specified by the initiator of the session.')
appnIsrSessLimitedResource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessLimitedResource.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessLimitedResource.setDescription('This attribute specifies whether the session uses a limited resource link. A limited resource link remains active only when being used and is deactivated when session traffic ceases.')
appnIsrSessPriStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100))
appnIsrSessPriStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1), )
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnIsrSessPriStats components.')
appnIsrSessPriStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessPriStatsIndex"))
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatusEntry.setDescription('A single entry in the table represents a single appnIsrSessPriStats component.')
appnIsrSessPriStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnIsrSessPriStats components. These components cannot be added nor deleted.')
appnIsrSessPriStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnIsrSessPriStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsStorageType.setDescription('This variable represents the storage type value for the appnIsrSessPriStats tables.')
appnIsrSessPriStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnIsrSessPriStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsIndex.setDescription('This variable represents the index for the appnIsrSessPriStats tables.')
appnIsrSessPriStatsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10), )
if mibBuilder.loadTexts: appnIsrSessPriStatsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains counters and statistics for a session.')
appnIsrSessPriStatsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessPriStatsIndex"))
if mibBuilder.loadTexts: appnIsrSessPriStatsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsStatsEntry.setDescription('An entry in the appnIsrSessPriStatsStatsTable.')
appnIsrSessPriStatsRxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsRxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRxRuSize.setDescription('This is the maximum request unit (RU) size that can be used on the session.')
appnIsrSessPriStatsMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxTxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be sent on the session.')
appnIsrSessPriStatsMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxRxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be received on the session.')
appnIsrSessPriStatsMaxTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxTxPacWin.setDescription('This is the maximum size of the send pacing window on the session.')
appnIsrSessPriStatsCurTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsCurTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsCurTxPacWin.setDescription('This is the current size of the send pacing window on the session.')
appnIsrSessPriStatsMaxRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsMaxRxPacWin.setDescription('This is the maximum size of the receive pacing window on the session.')
appnIsrSessPriStatsCurRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsCurRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsCurRxPacWin.setDescription('This is the current size of the receive pacing window on the session.')
appnIsrSessPriStatsTxDataframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsTxDataframes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsTxDataframes.setDescription('This attribute counts the number of normal flow data frames sent on the session, the counter wraps to zero.')
appnIsrSessPriStatsTxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsTxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsTxFmdFrames.setDescription('This attribute counts the number of FMD data frames sent on the session, the counter wraps to zero.')
appnIsrSessPriStatsTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsTxDataBytes.setDescription('This is the number of normal flow data bytes sent on the session, the counter wraps to zero.')
appnIsrSessPriStatsRxDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsRxDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRxDataFrames.setDescription('This is the number of normal flow data frames received on the session, the counter wraps to zero.')
appnIsrSessPriStatsRxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsRxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRxFmdFrames.setDescription('This attribute counts the number of FMD data frames received on the session, the counter wraps to zero.')
appnIsrSessPriStatsRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsRxDataBytes.setDescription('This is the number of normal flow data bytes received on the session, the counter wraps to zero.')
appnIsrSessPriStatsSidh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 14), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsSidh.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsSidh.setDescription('This attribute contains the session identifier high byte on the session.')
appnIsrSessPriStatsSidl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 15), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsSidl.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsSidl.setDescription('This attribute contains the session ID low byte on the SSCP session.')
appnIsrSessPriStatsOdai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsOdai.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsOdai.setDescription('This is the origin destination assignor indicator (ODAI) on the session.')
appnIsrSessPriStatsLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 100, 10, 1, 17), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessPriStatsLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessPriStatsLsName.setDescription('This is the link station name associated with these counters and statistics. This is an 8 character name of the link station over which the data flowed. This field can be used to correlate the session statistics with the link over which session data flows.')
appnIsrSessSecStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101))
appnIsrSessSecStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1), )
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnIsrSessSecStats components.')
appnIsrSessSecStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessSecStatsIndex"))
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatusEntry.setDescription('A single entry in the table represents a single appnIsrSessSecStats component.')
appnIsrSessSecStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnIsrSessSecStats components. These components cannot be added nor deleted.')
appnIsrSessSecStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnIsrSessSecStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsStorageType.setDescription('This variable represents the storage type value for the appnIsrSessSecStats tables.')
appnIsrSessSecStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnIsrSessSecStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsIndex.setDescription('This variable represents the index for the appnIsrSessSecStats tables.')
appnIsrSessSecStatsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10), )
if mibBuilder.loadTexts: appnIsrSessSecStatsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains counters and statistics for a session.')
appnIsrSessSecStatsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessProcedureCorrelationIdIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnIsrSessSecStatsIndex"))
if mibBuilder.loadTexts: appnIsrSessSecStatsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsStatsEntry.setDescription('An entry in the appnIsrSessSecStatsStatsTable.')
appnIsrSessSecStatsRxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsRxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRxRuSize.setDescription('This is the maximum request unit (RU) size that can be used on the session.')
appnIsrSessSecStatsMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxTxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be sent on the session.')
appnIsrSessSecStatsMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxRxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be received on the session.')
appnIsrSessSecStatsMaxTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxTxPacWin.setDescription('This is the maximum size of the send pacing window on the session.')
appnIsrSessSecStatsCurTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsCurTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsCurTxPacWin.setDescription('This is the current size of the send pacing window on the session.')
appnIsrSessSecStatsMaxRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsMaxRxPacWin.setDescription('This is the maximum size of the receive pacing window on the session.')
appnIsrSessSecStatsCurRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsCurRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsCurRxPacWin.setDescription('This is the current size of the receive pacing window on the session.')
appnIsrSessSecStatsTxDataframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsTxDataframes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsTxDataframes.setDescription('This attribute counts the number of normal flow data frames sent on the session, the counter wraps to zero.')
appnIsrSessSecStatsTxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsTxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsTxFmdFrames.setDescription('This attribute counts the number of FMD data frames sent on the session, the counter wraps to zero.')
appnIsrSessSecStatsTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsTxDataBytes.setDescription('This is the number of normal flow data bytes sent on the session, the counter wraps to zero.')
appnIsrSessSecStatsRxDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsRxDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRxDataFrames.setDescription('This is the number of normal flow data frames received on the session, the counter wraps to zero.')
appnIsrSessSecStatsRxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsRxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRxFmdFrames.setDescription('This attribute counts the number of FMD data frames received on the session, the counter wraps to zero.')
appnIsrSessSecStatsRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsRxDataBytes.setDescription('This is the number of normal flow data bytes received on the session, the counter wraps to zero.')
appnIsrSessSecStatsSidh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 14), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsSidh.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsSidh.setDescription('This attribute contains the session identifier high byte on the session.')
appnIsrSessSecStatsSidl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 15), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsSidl.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsSidl.setDescription('This attribute contains the session ID low byte on the SSCP session.')
appnIsrSessSecStatsOdai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsOdai.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsOdai.setDescription('This is the origin destination assignor indicator (ODAI) on the session.')
appnIsrSessSecStatsLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 11, 101, 10, 1, 17), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnIsrSessSecStatsLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnIsrSessSecStatsLsName.setDescription('This is the link station name associated with these counters and statistics. This is an 8 character name of the link station over which the data flowed. This field can be used to correlate the session statistics with the link over which session data flows.')
appnNnTg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12))
appnNnTgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1), )
if mibBuilder.loadTexts: appnNnTgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnNnTg components.')
appnNnTgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgOwnerFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnNnTgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgRowStatusEntry.setDescription('A single entry in the table represents a single appnNnTg component.')
appnNnTgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnNnTg components. These components cannot be added nor deleted.')
appnNnTgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnNnTgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgStorageType.setDescription('This variable represents the storage type value for the appnNnTg tables.')
appnNnTgOwnerFqcpNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 17)))
if mibBuilder.loadTexts: appnNnTgOwnerFqcpNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgOwnerFqcpNameIndex.setDescription('This variable represents an index for the appnNnTg tables.')
appnNnTgDestFqcpNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 11), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 17)))
if mibBuilder.loadTexts: appnNnTgDestFqcpNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgDestFqcpNameIndex.setDescription('This variable represents an index for the appnNnTg tables.')
appnNnTgTransmissionGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: appnNnTgTransmissionGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgTransmissionGroupIndex.setDescription('This variable represents an index for the appnNnTg tables.')
appnNnTgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10), )
if mibBuilder.loadTexts: appnNnTgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational status of the transmission group entry in the topology database.')
appnNnTgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgOwnerFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnNnTgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgOperEntry.setDescription('An entry in the appnNnTgOperTable.')
appnNnTgFlowReductionSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgFlowReductionSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgFlowReductionSequenceNumber.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node. SNMP APPN MIB = ibmappnNnTgFrsn')
appnNnTgDaysLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgDaysLeft.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgDaysLeft.setDescription('Number of days left until entry purged.')
appnNnTgResourceSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgResourceSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgResourceSequenceNumber.setDescription('Resource sequence number.')
appnNnTgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgStatus.setDescription('This attribute contains status information about the transmission group from the topology database. It can be any combination of the following: operational If present indicates that the transmission group is operational. CpCpSessions If present, indicates that CP-CP sessions are supported on this transmission group. quiescing If present, indicates that the transmission group is quiescing. Description of bits: notused0(0) notused1(1) notused2(2) notused3(3) cpCpSessions(4) quiescing(5) notused6(6) operational(7)')
appnNnTgLinkAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 11), )
if mibBuilder.loadTexts: appnNnTgLinkAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgLinkAddressTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Contains the attribute for destination address.')
appnNnTgLinkAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgOwnerFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnNnTgLinkAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgLinkAddressEntry.setDescription('An entry in the appnNnTgLinkAddressTable.')
appnNnTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 11, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgDlcData.setDescription('This attribute contains specific data related to the link connection. Token-Ring - contains MAC/SAP X.25 Switched - contains dial digits X.21 Switched - contains dial digits Circuit Switched - contains dial digits Frame-Relay - contains DLCI and SAP The value will be set to zero if the destination node type is not a virtual routing node.')
appnNnTgTgCharTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12), )
if mibBuilder.loadTexts: appnNnTgTgCharTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgTgCharTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** These attributes of the link station are in a group using a common structure. This set provides the TG characteristics of the link through this link station for route selection.')
appnNnTgTgCharEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgOwnerFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgDestFqcpNameIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnNnTgTransmissionGroupIndex"))
if mibBuilder.loadTexts: appnNnTgTgCharEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgTgCharEntry.setDescription('An entry in the appnNnTgTgCharTable.')
appnNnTgEffectiveCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("n600Gbps", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgEffectiveCap.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgEffectiveCap.setDescription('The effective capacity is an integer value that indicates the capacity in kilo bits per second. It is derived from the link bandwidth and the maximum load factor with the range of 0 thru 603,979,776.')
appnNnTgConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgConnectCost.setDescription('The cost-per-connect time is a characteristic represented by a single-byte value in the range 0 to 255 that expresses a relative cost of using a transmission group. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the transmission group. The cost-per-connect time values that a network administrator assigns to the transmission groups in a network should reflect the relative expense of each transmission group as compared to all other transmission groups in the network. A value of 0 means that the cost of connecting over the transmission group is at no additional cost (as in the case of a non-switched facility.')
appnNnTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgByteCost.setDescription('Cost-per-byte is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated transmission group. The units for cost-per-byte are user-defined. Like cost-per-connect-time, cost-per-byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnNnTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("unKnown", 0), ("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('nonSecure')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgSecurity.setDescription('This static characteristic indicates the level of security protection. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided unknown - has not been determined guardedConduit - guarded conduit; protected against physical tapping secureConduit - secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, e.g. satellite-connected, located in a nonsecure country.')
appnNnTgPropagationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153))).clone('terrestrial')).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgPropagationDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgPropagationDelay.setDescription('The propagation delay is the length of time that it takes for a signal to propagate from one end of the transmission group to the other. Typical values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnNnTgUserDefinedParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgUserDefinedParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgUserDefinedParm1.setDescription('This is the user defined routing parameter in range 0-255.')
appnNnTgUserDefinedParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgUserDefinedParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgUserDefinedParm2.setDescription('This is the user defined routing parameter in range 0-255.')
appnNnTgUserDefinedParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 12, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnNnTgUserDefinedParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnNnTgUserDefinedParm3.setDescription('This is the user defined routing parameter in range 0-255.')
appnRtp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13))
appnRtpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1), )
if mibBuilder.loadTexts: appnRtpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnRtp components.')
appnRtpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnRtpIndex"))
if mibBuilder.loadTexts: appnRtpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRowStatusEntry.setDescription('A single entry in the table represents a single appnRtp component.')
appnRtpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnRtp components. These components cannot be added nor deleted.')
appnRtpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnRtpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpStorageType.setDescription('This variable represents the storage type value for the appnRtp tables.')
appnRtpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnRtpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpIndex.setDescription('This variable represents the index for the appnRtp tables.')
appnRtpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10), )
if mibBuilder.loadTexts: appnRtpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational data for the High Performance Routing-Rapid Transport Protocol pipe')
appnRtpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnRtpIndex"))
if mibBuilder.loadTexts: appnRtpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpOperEntry.setDescription('An entry in the appnRtpOperTable.')
appnRtpLocalLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpLocalLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpLocalLsName.setDescription('This is the name of the local link station associated with this High Performance Routing-Rapid Transport Protocol pipe')
appnRtpRemoteCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpRemoteCpName.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRemoteCpName.setDescription('This is the CP name of the node at the other end of the High Performance Routing-Rapid Transport Protocol pipe')
appnRtpCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpCosName.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpCosName.setDescription('This is the name of the Class of Service associated with this High Performance Routing-Rapid Transport Protocol pipe')
appnRtpActiveSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpActiveSessions.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpActiveSessions.setDescription('The number of active sessions using this High Performance Routing-Rapid Transport Protocol pipe')
appnRtpLocalTcid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 5), HexString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpLocalTcid.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpLocalTcid.setDescription('The Transport Connection Identifier (TCID) assigned to this HPR RTP pipe by the local node')
appnRtpRemoteTcid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 6), HexString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpRemoteTcid.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRemoteTcid.setDescription('The Transport Connection Identifier (TCID) assigned to this HPR RTP pipe by the remote node.')
appnRtpIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpIdleTimer.setDescription('The idle timer of this High Performance Routing-Rapid Transport Protocol pipe (in seconds)')
appnRtpMaxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpMaxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpMaxBtuSize.setDescription('The maximum BTU size (the length of the information field in a frame) of the High Performance Routing-Rapid Transport Protocol pipe.')
appnRtpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11), )
if mibBuilder.loadTexts: appnRtpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the statistics and counters for the High Performance Routing-Rapid Transport Protocol pipe.')
appnRtpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnRtpIndex"))
if mibBuilder.loadTexts: appnRtpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpStatsEntry.setDescription('An entry in the appnRtpStatsTable.')
appnRtpTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpTxBytes.setDescription('This attribute is the total number of bytes sent on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRxBytes.setDescription('This attribute is the total number of bytes received on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpBytesResent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpBytesResent.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpBytesResent.setDescription('This attribute counts the total number of bytes resent on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpBytesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpBytesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpBytesDiscarded.setDescription('This attribute counts the total number of bytes discarded on this High Performance Routing-Rapid Transport Protocol pipe. High numbers of discarded bytes may indicate a problem in the APPN network. This counter wraps to zero.')
appnRtpPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpPktTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpPktTx.setDescription('This attribute counts the total number of packets sent on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpPktRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpPktRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpPktRx.setDescription('This attribute counts the total number of packets received on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpPktResent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpPktResent.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpPktResent.setDescription('This attribute counts the total number of packets resent on this High Performance Routing-Rapid Transport Protocol pipe. This counter wraps to zero.')
appnRtpPktDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpPktDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpPktDiscard.setDescription('This attribute counts the total number of packets discarded on this High Performance Routing-Rapid Transport Protocol pipe. Large numbers of discarded packets may indicate a problem in the APPN network. This counter wraps to zero.')
appnRtpLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpLostFrames.setDescription('This attribute counts the number of lost frames detected on this pipe. Excessive numbers of lost frames may indicate a problem in the APPN network. This counter wraps to zero.')
appnRtpCurTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpCurTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpCurTxRate.setDescription('This attribute gives the current send rate on this pipe.')
appnRtpMaxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpMaxTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpMaxTxRate.setDescription('This attribute give the maximum send rate on this pipe.')
appnRtpMinTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpMinTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpMinTxRate.setDescription('This attribute gives the minimum send rate on this pipe.')
appnRtpCurRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpCurRxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpCurRxRate.setDescription('This attribute gives the current receive rate on this pipe.')
appnRtpMaxRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 14), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpMaxRxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpMaxRxRate.setDescription('This attribute gives the maximum receive rate on this pipe.')
appnRtpMinRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 15), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpMinRxRate.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpMinRxRate.setDescription('This attribute gives the minimum receive rate on this pipe.')
appnRtpBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 16), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpBurstSize.setDescription('This attribute gives the current burst size on this pipe.')
appnRtpUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpUptime.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpUptime.setDescription('This attribute gives the total uptime of this High Performance Routing-Rapid Transport Protocol pipe.')
appnRtpSmoothRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 18), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpSmoothRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpSmoothRoundTripTime.setDescription('This attribute gives the smoothed round-trip time on this pipe.')
appnRtpLastRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 19), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpLastRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpLastRoundTripTime.setDescription('This attribute gives the last round-trip time on this pipe.')
appnRtpShortReqTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 20), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpShortReqTimer.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpShortReqTimer.setDescription('This attribute gives the short request timer duration on this pipe.')
appnRtpShortReqTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 21), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpShortReqTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpShortReqTimeouts.setDescription('This attribute counts the number of short request timer timeouts on this pipe.')
appnRtpIdleTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 22), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpIdleTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpIdleTimeouts.setDescription('This attribute count the number of idle timer timeouts on this pipe.')
appnRtpRxInvalidSnaFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 23), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpRxInvalidSnaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpRxInvalidSnaFrames.setDescription('This attribute counts the number of invalid SNA frames received on this pipe.')
appnRtpInSessionControlFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 24), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpInSessionControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpInSessionControlFrames.setDescription('This attribute counts the number of Session Control frames received on this pipe.')
appnRtpOutSessionControlFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 13, 11, 1, 25), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnRtpOutSessionControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnRtpOutSessionControlFrames.setDescription('This attribute counts the number of Session Control frames sent on this pipe.')
appnDlu = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14))
appnDluRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1), )
if mibBuilder.loadTexts: appnDluRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDlu components.')
appnDluRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"))
if mibBuilder.loadTexts: appnDluRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluRowStatusEntry.setDescription('A single entry in the table represents a single appnDlu component.')
appnDluRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlu components. These components cannot be added nor deleted.')
appnDluComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDluStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluStorageType.setDescription('This variable represents the storage type value for the appnDlu tables.')
appnDluIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnDluIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluIndex.setDescription('This variable represents the index for the appnDlu tables.')
appnDluOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10), )
if mibBuilder.loadTexts: appnDluOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** The group contains the operational data for a dependent LU session.')
appnDluOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"))
if mibBuilder.loadTexts: appnDluOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluOperEntry.setDescription('An entry in the appnDluOperTable.')
appnDluSscpSessActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpSessActive.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpSessActive.setDescription('This attribute tells whether the SSCP-LU session is active')
appnDluPluSessActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluPluSessActive.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluPluSessActive.setDescription('This attribute tells whether the dependent LU session is active.')
appnDluDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDlusName.setDescription('This attribute tells the name of the dependent LU server name that this dependent LU is connected to.')
appnDluPluName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluPluName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluPluName.setDescription('This attribute tells the partner LU name of this dependent LU if the LU is connected, it is a NULL string if the dependent LU does not have an active session with a partner LU.')
appnDluNauAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluNauAddress.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluNauAddress.setDescription('This attribute gives the NAU address of the dependent LU.')
appnDluSscp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100))
appnDluSscpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1), )
if mibBuilder.loadTexts: appnDluSscpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDluSscp components.')
appnDluSscpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluSscpIndex"))
if mibBuilder.loadTexts: appnDluSscpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRowStatusEntry.setDescription('A single entry in the table represents a single appnDluSscp component.')
appnDluSscpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDluSscp components. These components cannot be added nor deleted.')
appnDluSscpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDluSscpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpStorageType.setDescription('This variable represents the storage type value for the appnDluSscp tables.')
appnDluSscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDluSscpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpIndex.setDescription('This variable represents the index for the appnDluSscp tables.')
appnDluSscpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10), )
if mibBuilder.loadTexts: appnDluSscpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains counters and statistics for a session.')
appnDluSscpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluSscpIndex"))
if mibBuilder.loadTexts: appnDluSscpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpStatsEntry.setDescription('An entry in the appnDluSscpStatsTable.')
appnDluSscpRxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpRxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRxRuSize.setDescription('This is the maximum request unit (RU) size that can be used on the session.')
appnDluSscpMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpMaxTxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be sent on the session.')
appnDluSscpMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpMaxRxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be received on the session.')
appnDluSscpMaxTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpMaxTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpMaxTxPacWin.setDescription('This is the maximum size of the send pacing window on the session.')
appnDluSscpCurTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpCurTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpCurTxPacWin.setDescription('This is the current size of the send pacing window on the session.')
appnDluSscpMaxRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpMaxRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpMaxRxPacWin.setDescription('This is the maximum size of the receive pacing window on the session.')
appnDluSscpCurRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpCurRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpCurRxPacWin.setDescription('This is the current size of the receive pacing window on the session.')
appnDluSscpTxDataframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpTxDataframes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpTxDataframes.setDescription('This attribute counts the number of normal flow data frames sent on the session, the counter wraps to zero.')
appnDluSscpTxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpTxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpTxFmdFrames.setDescription('This attribute counts the number of FMD data frames sent on the session, the counter wraps to zero.')
appnDluSscpTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpTxDataBytes.setDescription('This is the number of normal flow data bytes sent on the session, the counter wraps to zero.')
appnDluSscpRxDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpRxDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRxDataFrames.setDescription('This is the number of normal flow data frames received on the session, the counter wraps to zero.')
appnDluSscpRxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpRxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRxFmdFrames.setDescription('This attribute counts the number of FMD data frames received on the session, the counter wraps to zero.')
appnDluSscpRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpRxDataBytes.setDescription('This is the number of normal flow data bytes received on the session, the counter wraps to zero.')
appnDluSscpSidh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 14), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpSidh.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpSidh.setDescription('This attribute contains the session identifier high byte on the session.')
appnDluSscpSidl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 15), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpSidl.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpSidl.setDescription('This attribute contains the session ID low byte on the SSCP session.')
appnDluSscpOdai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpOdai.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpOdai.setDescription('This is the origin destination assignor indicator (ODAI) on the session.')
appnDluSscpLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 100, 10, 1, 17), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluSscpLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluSscpLsName.setDescription('This is the link station name associated with these counters and statistics. This is an 8 character name of the link station over which the data flowed. This field can be used to correlate the session statistics with the link over which session data flows.')
appnDluUsStat = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101))
appnDluUsStatRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1), )
if mibBuilder.loadTexts: appnDluUsStatRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDluUsStat components.')
appnDluUsStatRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluUsStatIndex"))
if mibBuilder.loadTexts: appnDluUsStatRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRowStatusEntry.setDescription('A single entry in the table represents a single appnDluUsStat component.')
appnDluUsStatRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDluUsStat components. These components cannot be added nor deleted.')
appnDluUsStatComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDluUsStatStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatStorageType.setDescription('This variable represents the storage type value for the appnDluUsStat tables.')
appnDluUsStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDluUsStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatIndex.setDescription('This variable represents the index for the appnDluUsStat tables.')
appnDluUsStatStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10), )
if mibBuilder.loadTexts: appnDluUsStatStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains counters and statistics for a session.')
appnDluUsStatStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluUsStatIndex"))
if mibBuilder.loadTexts: appnDluUsStatStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatStatsEntry.setDescription('An entry in the appnDluUsStatStatsTable.')
appnDluUsStatRxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatRxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRxRuSize.setDescription('This is the maximum request unit (RU) size that can be used on the session.')
appnDluUsStatMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatMaxTxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be sent on the session.')
appnDluUsStatMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatMaxRxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be received on the session.')
appnDluUsStatMaxTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatMaxTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatMaxTxPacWin.setDescription('This is the maximum size of the send pacing window on the session.')
appnDluUsStatCurTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatCurTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatCurTxPacWin.setDescription('This is the current size of the send pacing window on the session.')
appnDluUsStatMaxRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatMaxRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatMaxRxPacWin.setDescription('This is the maximum size of the receive pacing window on the session.')
appnDluUsStatCurRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatCurRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatCurRxPacWin.setDescription('This is the current size of the receive pacing window on the session.')
appnDluUsStatTxDataframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatTxDataframes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatTxDataframes.setDescription('This attribute counts the number of normal flow data frames sent on the session, the counter wraps to zero.')
appnDluUsStatTxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatTxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatTxFmdFrames.setDescription('This attribute counts the number of FMD data frames sent on the session, the counter wraps to zero.')
appnDluUsStatTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatTxDataBytes.setDescription('This is the number of normal flow data bytes sent on the session, the counter wraps to zero.')
appnDluUsStatRxDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatRxDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRxDataFrames.setDescription('This is the number of normal flow data frames received on the session, the counter wraps to zero.')
appnDluUsStatRxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatRxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRxFmdFrames.setDescription('This attribute counts the number of FMD data frames received on the session, the counter wraps to zero.')
appnDluUsStatRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatRxDataBytes.setDescription('This is the number of normal flow data bytes received on the session, the counter wraps to zero.')
appnDluUsStatSidh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 14), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatSidh.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatSidh.setDescription('This attribute contains the session identifier high byte on the session.')
appnDluUsStatSidl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 15), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatSidl.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatSidl.setDescription('This attribute contains the session ID low byte on the SSCP session.')
appnDluUsStatOdai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatOdai.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatOdai.setDescription('This is the origin destination assignor indicator (ODAI) on the session.')
appnDluUsStatLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 101, 10, 1, 17), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluUsStatLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluUsStatLsName.setDescription('This is the link station name associated with these counters and statistics. This is an 8 character name of the link station over which the data flowed. This field can be used to correlate the session statistics with the link over which session data flows.')
appnDluDsStat = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102))
appnDluDsStatRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1), )
if mibBuilder.loadTexts: appnDluDsStatRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDluDsStat components.')
appnDluDsStatRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluDsStatIndex"))
if mibBuilder.loadTexts: appnDluDsStatRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRowStatusEntry.setDescription('A single entry in the table represents a single appnDluDsStat component.')
appnDluDsStatRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDluDsStat components. These components cannot be added nor deleted.')
appnDluDsStatComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDluDsStatStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatStorageType.setDescription('This variable represents the storage type value for the appnDluDsStat tables.')
appnDluDsStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDluDsStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatIndex.setDescription('This variable represents the index for the appnDluDsStat tables.')
appnDluDsStatStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10), )
if mibBuilder.loadTexts: appnDluDsStatStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This component contains counters and statistics for a session.')
appnDluDsStatStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDluDsStatIndex"))
if mibBuilder.loadTexts: appnDluDsStatStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatStatsEntry.setDescription('An entry in the appnDluDsStatStatsTable.')
appnDluDsStatRxRuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatRxRuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRxRuSize.setDescription('This is the maximum request unit (RU) size that can be used on the session.')
appnDluDsStatMaxTxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatMaxTxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatMaxTxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be sent on the session.')
appnDluDsStatMaxRxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatMaxRxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatMaxRxBtuSize.setDescription('This is the maximum BTU size (length of the information field in a frame) that can be received on the session.')
appnDluDsStatMaxTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatMaxTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatMaxTxPacWin.setDescription('This is the maximum size of the send pacing window on the session.')
appnDluDsStatCurTxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatCurTxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatCurTxPacWin.setDescription('This is the current size of the send pacing window on the session.')
appnDluDsStatMaxRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatMaxRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatMaxRxPacWin.setDescription('This is the maximum size of the receive pacing window on the session.')
appnDluDsStatCurRxPacWin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatCurRxPacWin.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatCurRxPacWin.setDescription('This is the current size of the receive pacing window on the session.')
appnDluDsStatTxDataframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatTxDataframes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatTxDataframes.setDescription('This attribute counts the number of normal flow data frames sent on the session, the counter wraps to zero.')
appnDluDsStatTxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatTxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatTxFmdFrames.setDescription('This attribute counts the number of FMD data frames sent on the session, the counter wraps to zero.')
appnDluDsStatTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatTxDataBytes.setDescription('This is the number of normal flow data bytes sent on the session, the counter wraps to zero.')
appnDluDsStatRxDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatRxDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRxDataFrames.setDescription('This is the number of normal flow data frames received on the session, the counter wraps to zero.')
appnDluDsStatRxFmdFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatRxFmdFrames.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRxFmdFrames.setDescription('This attribute counts the number of FMD data frames received on the session, the counter wraps to zero.')
appnDluDsStatRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatRxDataBytes.setDescription('This is the number of normal flow data bytes received on the session, the counter wraps to zero.')
appnDluDsStatSidh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 14), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatSidh.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatSidh.setDescription('This attribute contains the session identifier high byte on the session.')
appnDluDsStatSidl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 15), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatSidl.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatSidl.setDescription('This attribute contains the session ID low byte on the SSCP session.')
appnDluDsStatOdai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatOdai.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatOdai.setDescription('This is the origin destination assignor indicator (ODAI) on the session.')
appnDluDsStatLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 14, 102, 10, 1, 17), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDluDsStatLsName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDluDsStatLsName.setDescription('This is the link station name associated with these counters and statistics. This is an 8 character name of the link station over which the data flowed. This field can be used to correlate the session statistics with the link over which session data flows.')
appnDlus = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15))
appnDlusRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1), )
if mibBuilder.loadTexts: appnDlusRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnDlus components.')
appnDlusRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlusIndex"))
if mibBuilder.loadTexts: appnDlusRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusRowStatusEntry.setDescription('A single entry in the table represents a single appnDlus component.')
appnDlusRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDlus components. These components cannot be added nor deleted.')
appnDlusComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDlusStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusStorageType.setDescription('This variable represents the storage type value for the appnDlus tables.')
appnDlusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnDlusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusIndex.setDescription('This variable represents the index for the appnDlus tables.')
appnDlusOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 10), )
if mibBuilder.loadTexts: appnDlusOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Information on the DLUR-DLUS pipe.')
appnDlusOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlusIndex"))
if mibBuilder.loadTexts: appnDlusOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusOperEntry.setDescription('An entry in the appnDlusOperTable.')
appnDlusPrimaryDlus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusPrimaryDlus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusPrimaryDlus.setDescription('This attribute indicates if this is the pipe to the primary default dependent LU server.')
appnDlusPipeState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("inactive", 0), ("pendingActive", 1), ("active", 2), ("pendingInactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusPipeState.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusPipeState.setDescription('This attribute indicates the current state of the DLUR-DLUS pipe. inactive indicates the pipe is not connected (the session has likely failed), pendingActive indicates the pipe is connecting, active indicates the pipe is currently connected and data is flowing, and pendingInactive indicates the pipe is being disconnected.')
appnDlusActivePUs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusActivePUs.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusActivePUs.setDescription('This attribute indicates the number of active physical units using the pipe.')
appnDlusDlusStatTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11), )
if mibBuilder.loadTexts: appnDlusDlusStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDlusStatTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the counters and statistics for the DLUR-DLUS pipe')
appnDlusDlusStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDlusIndex"))
if mibBuilder.loadTexts: appnDlusDlusStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDlusStatEntry.setDescription('An entry in the appnDlusDlusStatTable.')
appnDlusReqActPuTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusReqActPuTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusReqActPuTx.setDescription('This attribute counts the number of REQACTPUs sent to the DLUS. The counter wraps to zero.')
appnDlusReqActPuRspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusReqActPuRspRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusReqActPuRspRx.setDescription('This attribute counts the number of REQACTPU responses received from the DLUS. The counter wraps to zero.')
appnDlusActPuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusActPuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusActPuRx.setDescription('This attributes counts the number of ACTPUs received from the DLUS. The counter wraps to zero.')
appnDlusActPuRspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusActPuRspTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusActPuRspTx.setDescription('This attribute counts the number of ACTPU responses sent to the DLUS. The counter wraps to zero.')
appnDlusReqDactPuTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusReqDactPuTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusReqDactPuTx.setDescription('This attribute counts the number of REQDACTPUs sent to the DLUS. The counter wraps to zero.')
appnDlusReqDactPuRspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusReqDactPuRspRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusReqDactPuRspRx.setDescription('This attribute counts the number of REQDACTPU responses received from the DLUS. The counter wraps to zero.')
appnDlusDactPuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusDactPuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDactPuRx.setDescription('This attribute counts the number of DACTPUs received from the DLUS. The counter wraps to zero.')
appnDlusDactPuRspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusDactPuRspTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDactPuRspTx.setDescription('This attribute counts the number of DACTPU responses received from the DLUS. The counter wraps to zero.')
appnDlusActLuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusActLuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusActLuRx.setDescription('This attribute counts the number of ACTLUs received from the DLUS. The counter wraps to zero.')
appnDlusActLuRspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusActLuRspTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusActLuRspTx.setDescription('This attribute counts the number of ACTLU responses sent to the DLUS. The counter wraps to zero.')
appnDlusDactLuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 11), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusDactLuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDactLuRx.setDescription('This attribute counts the number of DACTLUs received from the DLUS. The counter wraps to zero.')
appnDlusDactLuRspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 12), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusDactLuRspTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusDactLuRspTx.setDescription('This attribute counts the number of DACTLU responses sent to the DLUS. The counter wraps to zero.')
appnDlusSscpPuMuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusSscpPuMuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusSscpPuMuRx.setDescription('This attribute counts the number of SSCP-PU MUs received. The counter wraps to zero.')
appnDlusSscpPuMuTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusSscpPuMuTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusSscpPuMuTx.setDescription('This attribute counts the number of SSCP-PU MUs sent. The counter wraps to zero.')
appnDlusSscpLuMuRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusSscpLuMuRx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusSscpLuMuRx.setDescription('This attributes counts the number of SSCP-LU MUs received. The counter wraps to zero.')
appnDlusSscpLuMuTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 15, 11, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDlusSscpLuMuTx.setStatus('mandatory')
if mibBuilder.loadTexts: appnDlusSscpLuMuTx.setDescription('This attributes counts the number of SSCP-LU MUs sent. The counter wraps to zero.')
appnDLUR = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16))
appnDLURRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1), )
if mibBuilder.loadTexts: appnDLURRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURRowStatusTable.setDescription('This entry controls the addition and deletion of appnDLUR components.')
appnDLURRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDLURIndex"))
if mibBuilder.loadTexts: appnDLURRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURRowStatusEntry.setDescription('A single entry in the table represents a single appnDLUR component.')
appnDLURRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDLURRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnDLUR components. These components can be added and deleted.')
appnDLURComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDLURComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnDLURStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnDLURStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURStorageType.setDescription('This variable represents the storage type value for the appnDLUR tables.')
appnDLURIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnDLURIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURIndex.setDescription('This variable represents the index for the appnDLUR tables.')
appnDLURDlurParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2), )
if mibBuilder.loadTexts: appnDLURDlurParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURDlurParmsTable.setDescription('These parameters define the dependent LU requester options.')
appnDLURDlurParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnDLURIndex"))
if mibBuilder.loadTexts: appnDLURDlurParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURDlurParmsEntry.setDescription('An entry in the appnDLURDlurParmsTable.')
appnDLURPrimaryDefDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDLURPrimaryDefDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURPrimaryDefDlusName.setDescription('The fully qualified CP name of the node that will serve as the primary dependent LU server (DLUS).')
appnDLURSecondaryDefDlusName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDLURSecondaryDefDlusName.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURSecondaryDefDlusName.setDescription('The fully qualified CP name of the node that will serve as the backup or secondary dependent LU server (DLUS).')
appnDLURDlusRetryTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDLURDlusRetryTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURDlusRetryTimeout.setDescription('This attribute specifies the time in seconds before a network search to locate a DLUS times out.')
appnDLURDlusRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 16, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnDLURDlusRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: appnDLURDlusRetryLimit.setDescription('This attribute specifies the maximum number of retry attempts that will be made after an initial failure to contact a DLUS. If zero is specifed, APPN will retry indefinitely. When this limit has been reached, downstream PUs that are connected to APPN will be sent a QDISC frame.')
appnCos = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17))
appnCosRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1), )
if mibBuilder.loadTexts: appnCosRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosRowStatusTable.setDescription('This entry controls the addition and deletion of appnCos components.')
appnCosRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"))
if mibBuilder.loadTexts: appnCosRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosRowStatusEntry.setDescription('A single entry in the table represents a single appnCos component.')
appnCosRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnCos components. These components can be added and deleted.')
appnCosComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnCosStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosStorageType.setDescription('This variable represents the storage type value for the appnCos tables.')
appnCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appnCosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosIndex.setDescription('This variable represents the index for the appnCos tables.')
appnCosProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 104), )
if mibBuilder.loadTexts: appnCosProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosProvTable.setDescription('This provisioning group specifies the transmission priority associated with a Class of Service.')
appnCosProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"))
if mibBuilder.loadTexts: appnCosProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosProvEntry.setDescription('An entry in the appnCosProvTable.')
appnCosTransmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4))).clone('low')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTransmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTransmissionPriority.setDescription('This attribute specifies the transmission priority of session traffic using this class of service.')
appnCosTg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10))
appnCosTgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1), )
if mibBuilder.loadTexts: appnCosTgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgRowStatusTable.setDescription('This entry controls the addition and deletion of appnCosTg components.')
appnCosTgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosTgIndex"))
if mibBuilder.loadTexts: appnCosTgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgRowStatusEntry.setDescription('A single entry in the table represents a single appnCosTg component.')
appnCosTgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnCosTg components. These components can be added and deleted.')
appnCosTgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnCosTgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosTgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgStorageType.setDescription('This variable represents the storage type value for the appnCosTg tables.')
appnCosTgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: appnCosTgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgIndex.setDescription('This variable represents the index for the appnCosTg tables.')
appnCosTgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10), )
if mibBuilder.loadTexts: appnCosTgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgProvTable.setDescription('This group specifies a range of TG characteristics for a class of service and is used in route selection for session traffic. During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session.')
appnCosTgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosTgIndex"))
if mibBuilder.loadTexts: appnCosTgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgProvEntry.setDescription('An entry in the appnCosTgProvTable.')
appnCosTgMinEffectiveCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("max", 255))).clone('min')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinEffectiveCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinEffectiveCapacity.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum acceptable speed for a TG using this Class of Service.')
appnCosTgMaxEffectiveCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("min", 0), ("n170bps", 1), ("n190bps", 2), ("n210bps", 3), ("n230bps", 4), ("n240bps", 5), ("n260bps", 6), ("n280bps", 7), ("n300bps", 8), ("n340bps", 9), ("n380bps", 10), ("n410bps", 11), ("n450bps", 12), ("n490bps", 13), ("n530bps", 14), ("n560bps", 15), ("n600bps", 16), ("n680bps", 17), ("n750bps", 18), ("n830bps", 19), ("n900bps", 20), ("n980bps", 21), ("n1050bps", 22), ("n1130bps", 23), ("n1200bps", 24), ("n1350bps", 25), ("n1500bps", 26), ("n1700bps", 27), ("n1800bps", 28), ("n2000bps", 29), ("n2100bps", 30), ("n2300bps", 31), ("n2400bps", 32), ("n2700bps", 33), ("n3000bps", 34), ("n3300bps", 35), ("n3600bps", 36), ("n3900bps", 37), ("n4200bps", 38), ("n4500bps", 39), ("n4800bps", 40), ("n5400bps", 41), ("n6000bps", 42), ("n6600bps", 43), ("n7200bps", 44), ("n7800bps", 45), ("n8400bps", 46), ("n9000bps", 47), ("n9600bps", 48), ("n10800bps", 49), ("n12000bps", 50), ("n13200bps", 51), ("n14400bps", 52), ("n15600bps", 53), ("n17kbps", 54), ("n18kbps", 55), ("n19kbps", 56), ("n22kbps", 57), ("n24kbps", 58), ("n26kbps", 59), ("n29kbps", 60), ("n31kbps", 61), ("n34kbps", 62), ("n36kbps", 63), ("n38kbps", 64), ("n43kbps", 65), ("n48kbps", 66), ("n53kbps", 67), ("n58kbps", 68), ("n62kbps", 69), ("n67kbps", 70), ("n72kbps", 71), ("n77kbps", 72), ("n86kbps", 73), ("n96kbps", 74), ("n106kbps", 75), ("n115kbps", 76), ("n125kbps", 77), ("n134kbps", 78), ("n144kbps", 79), ("n154kbps", 80), ("n170kbps", 81), ("n190kbps", 82), ("n210kbps", 83), ("n230kbps", 84), ("n250kbps", 85), ("n270kbps", 86), ("n290kbps", 87), ("n310kbps", 88), ("n350kbps", 89), ("n380kbps", 90), ("n420kbps", 91), ("n460kbps", 92), ("n500kbps", 93), ("n540kbps", 94), ("n580kbps", 95), ("n610kbps", 96), ("n690kbps", 97), ("n770kbps", 98), ("n840kbps", 99), ("n920kbps", 100), ("n1000kbps", 101), ("n1080kbps", 102), ("n1150kbps", 103), ("n1230kbps", 104), ("n1380kbps", 105), ("n1540kbps", 106), ("n1700kbps", 107), ("n1800kbps", 108), ("n2000kbps", 109), ("n2200kbps", 110), ("n2300kbps", 111), ("n2500kbps", 112), ("n2800kbps", 113), ("n3100kbps", 114), ("n3400kbps", 115), ("n3700kbps", 116), ("n4000kbps", 117), ("n4300kbps", 118), ("n4600kbps", 119), ("n4900kbps", 120), ("n5500kbps", 121), ("n6100kbps", 122), ("n6800kbps", 123), ("n7400kbps", 124), ("n8000kbps", 125), ("n8600kbps", 126), ("n9200kbps", 127), ("n9800kbps", 128), ("n11100kbps", 129), ("n12300kbps", 130), ("n13500kbps", 131), ("n14700kbps", 132), ("n16Mbps", 133), ("n17Mbps", 134), ("n18Mbps", 135), ("n20Mbps", 136), ("n22Mbps", 137), ("n25Mbps", 138), ("n27Mbps", 139), ("n29Mbps", 140), ("n32Mbps", 141), ("n34Mbps", 142), ("n37Mbps", 143), ("n39Mbps", 144), ("n44Mbps", 145), ("n49Mbps", 146), ("n54Mbps", 147), ("n59Mbps", 148), ("n64Mbps", 149), ("n69Mbps", 150), ("n74Mbps", 151), ("n79Mbps", 152), ("n88Mbps", 153), ("n98Mbps", 154), ("n108Mbps", 155), ("n118Mbps", 156), ("n128Mbps", 157), ("n138Mbps", 158), ("n147Mbps", 159), ("n157Mbps", 160), ("n180Mbps", 161), ("n200Mbps", 162), ("n220Mbps", 163), ("n240Mbps", 164), ("n260Mbps", 165), ("n280Mbps", 166), ("n290Mbps", 167), ("n310Mbps", 168), ("n350Mbps", 169), ("n390Mbps", 170), ("n430Mbps", 171), ("n470Mbps", 172), ("n510Mbps", 173), ("n550Mbps", 174), ("n590Mbps", 175), ("n630Mbps", 176), ("n710Mbps", 177), ("n790Mbps", 178), ("n870Mbps", 179), ("n940Mbps", 180), ("n1020Mbps", 181), ("n1100Mbps", 182), ("n1180Mbps", 183), ("n1260Mbps", 184), ("n1420Mbps", 185), ("n1570Mbps", 186), ("n1700Mbps", 187), ("n1900Mbps", 188), ("n2000Mbps", 189), ("n2200Mbps", 190), ("n2400Mbps", 191), ("n2500Mbps", 192), ("n2800Mbps", 193), ("n3100Mbps", 194), ("n3500Mbps", 195), ("n3800Mbps", 196), ("n4100Mbps", 197), ("n4400Mbps", 198), ("n4700Mbps", 199), ("n5000Mbps", 200), ("n5700Mbps", 201), ("n6300Mbps", 202), ("n6900Mbps", 203), ("n7500Mbps", 204), ("n8200Mbps", 205), ("n8800Mbps", 206), ("n9400Mbps", 207), ("n10100Mbps", 208), ("n11300Mbps", 209), ("n12600Mbps", 210), ("n13800Mbps", 211), ("n15100Mbps", 212), ("n16Gbps", 213), ("n18Gbps", 214), ("n19Gbps", 215), ("n20Gbps", 216), ("n23Gbps", 217), ("n25Gbps", 218), ("n28Gbps", 219), ("n30Gbps", 220), ("n33Gbps", 221), ("n35Gbps", 222), ("n38Gbps", 223), ("n40Gbps", 224), ("n45Gbps", 225), ("n50Gbps", 226), ("n55Gbps", 227), ("n60Gbps", 228), ("n65Gbps", 229), ("n70Gbps", 230), ("n75Gbps", 231), ("n81Gbps", 232), ("n91Gbps", 233), ("n101Gbps", 234), ("n111Gbps", 235), ("n121Gbps", 236), ("n131Gbps", 237), ("n141Gbps", 238), ("n151Gbps", 239), ("n160Gbps", 240), ("n180Gbps", 241), ("n200Gbps", 242), ("n220Gbps", 243), ("n240Gbps", 244), ("n260Gbps", 245), ("n280Gbps", 246), ("n300Gbps", 247), ("n320Gbps", 248), ("n360Gbps", 249), ("n400Gbps", 250), ("n440Gbps", 251), ("n480Gbps", 252), ("n520Gbps", 253), ("n560Gbps", 254)) + NamedValues(("max", 255))).clone('max')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxEffectiveCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxEffectiveCapacity.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum acceptable speed for a TG using this Class of Service.')
appnCosTgMinConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinConnectCost.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum cost per connect time for a TG. It is represented by a number between 0 and 255 and is the relative cost of using a TG. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the TG. The cost-per-connect time values that a network administrator assigns to the TGs in a network should reflect the relative expense of each TG as compared to all other TGs in the network. A value of 0 means that there is no additional cost in connecting over the TG(as in the case of a non-switched facility).')
appnCosTgMaxConnectCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxConnectCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxConnectCost.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum cost per connect time for a TG. It is represented by a number between 0 and 255 and is the relative cost of using a TG. The units for cost-per-connect time are installation-defined and are typically based on the applicable tariffs of the transmission facility being used by the TG. The cost per connect time values that a network administrator assigns to the TGs in a network should reflect the relative expense of each TG as compared to all other TGs in the network. A value of 0 means that there is no additional cost in connecting over the TG (as in the case of a non-switched facility).')
appnCosTgMinByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinByteCost.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum cost per byte allowed for a TG to be used for a session. It is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated TG. The units for cost per byte are user defined. Like cost per connect time, cost per byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnCosTgMaxByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxByteCost.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum cost per byte allowed for a TG to be used for a session. It is a single byte value in the range 0 to 255 that expresses a relative cost of transmitting a byte over the associated TG. The units for cost per byte are user defined. Like cost per connect time, cost per byte is network specific and will not be uniform across networks unless assignments are coordinated.')
appnCosTgMinSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('nonSecure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinSecurity.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum level of security protection required for a TG to be allowed to route session traffic. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided guardedConduit - guarded conduit; protected against physical tapping secureConduit- secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, for example satellite-connected, located in a nonsecure country.')
appnCosTgMaxSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonSecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192))).clone('guardedRadiation')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxSecurity.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum level of security protection required for a TG to be allowed to route session traffic. The security values are architecturally defined to provide continuity across all networks. Currently, security is encoded as one of the following seven values: guardedRadiation - guarded conduit containing the transmission medium; protected against physical and radiation tapping. encrypted - link level encryption is provided guardedConduit - guarded conduit; protected against physical tapping secureConduit- secure conduit, not guarded; e.g. pressurized pipe undergroundCable - underground cable located in a secure country publicSwitchedNetwork - public switched network; secure in the sense that there is no predetermined route that traffic will take nonSecure - all else, for example. satellite-connected, located in a nonsecure country.')
appnCosTgMinPropDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153, 255))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153), ("maximum", 255))).clone('minimum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinPropDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinPropDelay.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum propagation delay for this Class of Service. Propogation delay is the length of time that it takes for a signal to propagate from one end of the TG to the other. Possible values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnCosTgMaxPropDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 76, 113, 145, 153, 255))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 76), ("terrestrial", 113), ("packetSwitched", 145), ("long", 153), ("maximum", 255))).clone('maximum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxPropDelay.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxPropDelay.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum propagation delay for this Class of Service. Propagation delay is the length of time that it takes for a signal to propagate from one end of the TG to the other. Possible values are: minimum - minimum negligible - 400 microsec terrestrial - 10 msec packetSwitched - 150 msec long - 300 msec')
appnCosTgMinModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinModemClass.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum modem class allowed for a TG to carry session traffic.')
appnCosTgMaxModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxModemClass.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum modem class allowed for a TG to carry session traffic.')
appnCosTgMinUserDefParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinUserDefParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinUserDefParm1.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum acceptable value for user defined routing parameter number 1.')
appnCosTgMaxUserDefParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm1.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm1.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum acceptable value for user defined routing parameter number 1.')
appnCosTgMinUserDefParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinUserDefParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinUserDefParm2.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum acceptable value for user defined routing parameter number 2.')
appnCosTgMaxUserDefParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm2.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm2.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum acceptable value for user defined routing parameter number 2.')
appnCosTgMinUserDefParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMinUserDefParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMinUserDefParm3.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum acceptable value for user defined routing parameter number 3.')
appnCosTgMaxUserDefParm3 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 10, 10, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm3.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosTgMaxUserDefParm3.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and contains the maximum acceptable value for user defined routing parameter number 3.')
appnCosNode = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11))
appnCosNodeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1), )
if mibBuilder.loadTexts: appnCosNodeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeRowStatusTable.setDescription('This entry controls the addition and deletion of appnCosNode components.')
appnCosNodeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosNodeIndex"))
if mibBuilder.loadTexts: appnCosNodeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeRowStatusEntry.setDescription('A single entry in the table represents a single appnCosNode component.')
appnCosNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnCosNode components. These components can be added and deleted.')
appnCosNodeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnCosNodeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCosNodeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeStorageType.setDescription('This variable represents the storage type value for the appnCosNode tables.')
appnCosNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: appnCosNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeIndex.setDescription('This variable represents the index for the appnCosNode tables.')
appnCosNodeProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10), )
if mibBuilder.loadTexts: appnCosNodeProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeProvTable.setDescription('This group specifies a range of node characteristics for a class of service and is used in route selection for session traffic. During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session.')
appnCosNodeProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCosNodeIndex"))
if mibBuilder.loadTexts: appnCosNodeProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeProvEntry.setDescription('An entry in the appnCosNodeProvTable.')
appnCosNodeMinRouteAddResistance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosNodeMinRouteAddResistance.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeMinRouteAddResistance.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum route addition resistance value allowed for a node to route session traffic. Route addition resistance defines the desirability for a network node to perform additional intermediate session routing. The higher the value, the less desirable the node is for session routing purposes.')
appnCosNodeMaxRouteAddResistance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosNodeMaxRouteAddResistance.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeMaxRouteAddResistance.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum route addition resistance value allowed for a node to route session traffic. Route addition resistance defines the desirability for a network node to perform additional intermediate session routing. The higher the value, the less desirable the node is for session routing purposes.')
appnCosNodeMinStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("uncongested", 0), ("congested", 1))).clone('uncongested')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosNodeMinStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeMinStatus.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the minimum congestion value that will be allowed for a node to carry session traffic.')
appnCosNodeMaxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 17, 11, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("uncongested", 0), ("congested", 1))).clone('uncongested')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnCosNodeMaxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCosNodeMaxStatus.setDescription('During route computation, APPN determines the optimum route through a network in the following steps: - obtains the required route characteristics from the COS database using the mode name specified in the session request - determines all possible combinations of transmission groups and nodes that form a route to the destination database - the actual characteristics of the Nodes and TGs in these routes are compared against the COS tables that contain the required characteristics of the session. A weight is assigned based on how well the actual characteristics meet the required characteristics. Where there is no match between actual and required characteristics, the route containing the node or TG is excluded from further computation. - Each possible route is quantified by adding the weights assigned to the node and TGs in the route. The route with the lowest weight is the one used for the session. This attribute is part of the COS tables and specifies the maximum congestion value that will be allowed for a node to carry session traffic.')
appnFrSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18))
appnFrSvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1), )
if mibBuilder.loadTexts: appnFrSvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcRowStatusTable.setDescription('This entry controls the addition and deletion of appnFrSvc components.')
appnFrSvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnFrSvcIndex"))
if mibBuilder.loadTexts: appnFrSvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcRowStatusEntry.setDescription('A single entry in the table represents a single appnFrSvc component.')
appnFrSvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnFrSvc components. These components can be added and deleted.')
appnFrSvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnFrSvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnFrSvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnFrSvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcStorageType.setDescription('This variable represents the storage type value for the appnFrSvc tables.')
appnFrSvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: appnFrSvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcIndex.setDescription('This variable represents the index for the appnFrSvc tables.')
appnFrSvcBanTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 10), )
if mibBuilder.loadTexts: appnFrSvcBanTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcBanTable.setDescription('This group contains the BAN device MAC and SAP parameters for the APPN service Frame Relay SVC calls.')
appnFrSvcBanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnFrSvcIndex"))
if mibBuilder.loadTexts: appnFrSvcBanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcBanEntry.setDescription('An entry in the appnFrSvcBanTable.')
appnFrSvcBanLocalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 10, 1, 1), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="4fff00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcBanLocalMac.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcBanLocalMac.setDescription('This attribute specifies the MAC address to be used for Frame Relay SVCs with BAN encapsulation.')
appnFrSvcBanLocalSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 10, 1, 2), Hex().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(224, 224), ValueRangeConstraint(228, 228), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(240, 240), ValueRangeConstraint(244, 244), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcBanLocalSap.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcBanLocalSap.setDescription('This attribute specifies the local SAP number to be used for Frame Relay SVCs with BAN encapsulation.')
appnFrSvcProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 11), )
if mibBuilder.loadTexts: appnFrSvcProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcProvisionedTable.setDescription('This group contains the provisonable parameters for the APPN service Frame Relay SVC calls.')
appnFrSvcProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnFrSvcIndex"))
if mibBuilder.loadTexts: appnFrSvcProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcProvisionedEntry.setDescription('An entry in the appnFrSvcProvisionedTable.')
appnFrSvcMaximumFrameRelaySvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3072)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcMaximumFrameRelaySvcs.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcMaximumFrameRelaySvcs.setDescription('This attribute specifies the maximum number of concurrently active Frame Relay SVC calls that are allowed for this service. This attribute does not include the general switched virtual circuits (GSVC).')
appnFrSvcRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcRateEnforcement.setDescription('This attribute specifies whether rate enforcement is to be used for new Frame Relay SVCs on this service. When rate enforcement is on the rate of data sent by the service to individual Frame Relay SVCs is controlled.')
appnFrSvcMaximumCir = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(2048000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnFrSvcMaximumCir.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcMaximumCir.setDescription('This attribute specifies the maximum rate enforcement CIR (Committed Information Rate) that is allowed for use with the Frame Relay SVCs on this service. During call setup negotiation, if the caller to this service requests a higher CIR value be used, the CIR used is reduced to the value of maximumCir.')
appnFrSvcOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 12), )
if mibBuilder.loadTexts: appnFrSvcOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcOperationalTable.setDescription('This group contains the operational attributes for the APPN Frame Relay SVC calls.')
appnFrSvcOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnFrSvcIndex"))
if mibBuilder.loadTexts: appnFrSvcOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcOperationalEntry.setDescription('An entry in the appnFrSvcOperationalTable.')
appnFrSvcCurrentNumberOfSvcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 18, 12, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnFrSvcCurrentNumberOfSvcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: appnFrSvcCurrentNumberOfSvcCalls.setDescription('This attribute indicates the number of Frame Relay SVCs currently existing on this service. This attribute does not include the general switched virtual circuits (GSVC).')
appnCn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19))
appnCnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1), )
if mibBuilder.loadTexts: appnCnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of appnCn components.')
appnCnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCnIndex"))
if mibBuilder.loadTexts: appnCnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnRowStatusEntry.setDescription('A single entry in the table represents a single appnCn component.')
appnCnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnRowStatus.setDescription('This variable is used as the basis for SNMP naming of appnCn components. These components cannot be added nor deleted.')
appnCnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
appnCnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnStorageType.setDescription('This variable represents the storage type value for the appnCn tables.')
appnCnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appnCnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnIndex.setDescription('This variable represents the index for the appnCn tables.')
appnCnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 5), )
if mibBuilder.loadTexts: appnCnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for this ConnectionNetwork component.')
appnCnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 5, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AppnMIB", "appnIndex"), (0, "Nortel-Magellan-Passport-AppnMIB", "appnCnIndex"))
if mibBuilder.loadTexts: appnCnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnOperEntry.setDescription('An entry in the appnCnOperTable.')
appnCnNumberActivePorts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 110, 19, 5, 1, 219), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnCnNumberActivePorts.setStatus('mandatory')
if mibBuilder.loadTexts: appnCnNumberActivePorts.setDescription('This attribute specifies the number of active ports under this ConnectionNetwork.')
appnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 1))
appnGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 1, 5))
appnGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 1, 5, 2))
appnGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 1, 5, 2, 2))
appnCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 3))
appnCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 3, 5))
appnCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 3, 5, 2))
appnCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 29, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AppnMIB", appnLcnVcRowStatus=appnLcnVcRowStatus, appnDlciBnnLsDefComponentName=appnDlciBnnLsDefComponentName, appnDlciSpComponentName=appnDlciSpComponentName, appnLcnVcMaxSubnetPktSize=appnLcnVcMaxSubnetPktSize, appnDlciDcIndex=appnDlciDcIndex, appnCosNodeMinStatus=appnCosNodeMinStatus, appnDluSscpMaxRxBtuSize=appnDluSscpMaxRxBtuSize, appnIsrSessRowStatusTable=appnIsrSessRowStatusTable, appnDlciSpRowStatusEntry=appnDlciSpRowStatusEntry, appnDirEntLocation=appnDirEntLocation, appnDlciVcRowStatusTable=appnDlciVcRowStatusTable, appnNnTgByteCost=appnNnTgByteCost, appnDlciBnnLsDefDspuService=appnDlciBnnLsDefDspuService, appnDlciSpParmsTable=appnDlciSpParmsTable, appnDluUsStatMaxTxBtuSize=appnDluUsStatMaxTxBtuSize, appnIsrSessSecStatsRxDataBytes=appnIsrSessSecStatsRxDataBytes, appnDlciBnnLsDefProvTable=appnDlciBnnLsDefProvTable, appnDluRowStatusTable=appnDluRowStatusTable, appnCosTgMinConnectCost=appnCosTgMinConnectCost, appnDluSscpRowStatus=appnDluSscpRowStatus, appnIsrSessPriStatsSidh=appnIsrSessPriStatsSidh, appnRtpRowStatusTable=appnRtpRowStatusTable, appnFrSvcComponentName=appnFrSvcComponentName, appnDlciBnnLsDefAdjacentCpName=appnDlciBnnLsDefAdjacentCpName, appnPortConnectCost=appnPortConnectCost, appnDlciDcNfaRowStatus=appnDlciDcNfaRowStatus, appnIsrSessSecStatsRowStatus=appnIsrSessSecStatsRowStatus, appnLocTg=appnLocTg, appnDlciVcIntdEntry=appnDlciVcIntdEntry, appnDlciVcCombErrorsFromSubnet=appnDlciVcCombErrorsFromSubnet, appnIsrSessPriStatsCurRxPacWin=appnIsrSessPriStatsCurRxPacWin, appnCosNodeMaxRouteAddResistance=appnCosNodeMaxRouteAddResistance, appnDlciVcRcosToNetwork=appnDlciVcRcosToNetwork, appnNnRouteAdditionResistance=appnNnRouteAdditionResistance, appnDluSscpRxDataFrames=appnDluSscpRxDataFrames, appnDefinedLsGoodXids=appnDefinedLsGoodXids, appnDnaOutDefaultPriority=appnDnaOutDefaultPriority, appnDlciVcSegmentSize=appnDlciVcSegmentSize, appnNnTgSecurity=appnNnTgSecurity, appnIsrSessSecStatsMaxRxPacWin=appnIsrSessSecStatsMaxRxPacWin, appnLcnVcSegmentsRx=appnLcnVcSegmentsRx, appnDlciBanLsDefAdjacentCpType=appnDlciBanLsDefAdjacentCpType, appnNnTgStatus=appnNnTgStatus, appnFrSvcProvisionedEntry=appnFrSvcProvisionedEntry, appnDnaCugRowStatusTable=appnDnaCugRowStatusTable, appnFeatures=appnFeatures, appnOperationalTable=appnOperationalTable, appnLsMaxTxBtuSize=appnLsMaxTxBtuSize, appnLcnVcPeakOoSeqFrmForwarded=appnLcnVcPeakOoSeqFrmForwarded, appnLcnIndex=appnLcnIndex, appnRtpPktResent=appnRtpPktResent, appnLcnVcCadEntry=appnLcnVcCadEntry, appnLocTgUserDefinedParm2=appnLocTgUserDefinedParm2, appnDluDlusName=appnDluDlusName, appnDluOperTable=appnDluOperTable, appnDlciSp=appnDlciSp, appnCosRowStatusTable=appnCosRowStatusTable, appnAdjNnRowStatusEntry=appnAdjNnRowStatusEntry, appnDnaCugIndex=appnDnaCugIndex, appnDluNauAddress=appnDluNauAddress, appnIsrSessSecStats=appnIsrSessSecStats, appnCosTgMinUserDefParm2=appnCosTgMinUserDefParm2, appnDlciVcOoSeqPktCntExceeded=appnDlciVcOoSeqPktCntExceeded, appnDnaHgMHgAddrAddrEntry=appnDnaHgMHgAddrAddrEntry, appnDlciVcEmissionPriorityFromNetwork=appnDlciVcEmissionPriorityFromNetwork, appnLcnDcComponentName=appnLcnDcComponentName, appnRtpIndex=appnRtpIndex, appnGroupBE=appnGroupBE, appnDlusDactPuRx=appnDlusDactPuRx, appnDnaRowStatus=appnDnaRowStatus, appnPortUserDefinedParm2=appnPortUserDefinedParm2, appnRtpCosName=appnRtpCosName, appnDluSscp=appnDluSscp, appnMaximumTopologyNodes=appnMaximumTopologyNodes, appnDnaCugStorageType=appnDnaCugStorageType, appnDluDsStatMaxRxBtuSize=appnDluDsStatMaxRxBtuSize, appnLcnVcIntdEntry=appnLcnVcIntdEntry, appnLocTgStatus=appnLocTgStatus, appnDlciDcStorageType=appnDlciDcStorageType, appnDnaHgMMaxAvailableChannels=appnDnaHgMMaxAvailableChannels, appnDluDsStatCurTxPacWin=appnDluDsStatCurTxPacWin, appnLocTgEffectiveCap=appnLocTgEffectiveCap, appnDlciBanComponentName=appnDlciBanComponentName, appnDlusRowStatusTable=appnDlusRowStatusTable, appnFrSvcOperationalEntry=appnFrSvcOperationalEntry, appnIsrSessPriStatsTxDataBytes=appnIsrSessPriStatsTxDataBytes, appnDlciBanLsDefRowStatusEntry=appnDlciBanLsDefRowStatusEntry, appnDlciSpIndex=appnDlciSpIndex, appnDluSscpTxDataBytes=appnDluSscpTxDataBytes, appnDnaIncomingOptionsTable=appnDnaIncomingOptionsTable, appnMemWarningThreshold=appnMemWarningThreshold, appnDnaHgMHgAddrAddrTable=appnDnaHgMHgAddrAddrTable, appnDlciVcFrdTable=appnDlciVcFrdTable, appnDirEntEntryType=appnDirEntEntryType, appnDlusActLuRspTx=appnDlusActLuRspTx, appnLsStorageType=appnLsStorageType, appnNnTgConnectCost=appnNnTgConnectCost, appnLcnDcDiscardPriority=appnLcnDcDiscardPriority, appnLcnVcStatsEntry=appnLcnVcStatsEntry, appnDlu=appnDlu, appnDlusOperEntry=appnDlusOperEntry, appnDlciVcStartTime=appnDlciVcStartTime, appnCosNodeComponentName=appnCosNodeComponentName, appnDnaCugComponentName=appnDnaCugComponentName, appnDlciVcOutOfRangeFrmFromSubnet=appnDlciVcOutOfRangeFrmFromSubnet, appnPortOperEntry=appnPortOperEntry, appnDLURSecondaryDefDlusName=appnDLURSecondaryDefDlusName, appnDnaHgMHgAddrNumberingPlanIndicator=appnDnaHgMHgAddrNumberingPlanIndicator, appnDlciDcDiscardPriority=appnDlciDcDiscardPriority, appnNnRowStatusEntry=appnNnRowStatusEntry, appnFrSvcBanEntry=appnFrSvcBanEntry, appnLcnVcLocalRxPktSize=appnLcnVcLocalRxPktSize, appnFlowReductionSequenceNumber=appnFlowReductionSequenceNumber, appnPortNonactXidExchLim=appnPortNonactXidExchLim, appnIsrSessRowStatusEntry=appnIsrSessRowStatusEntry, appnIsrSessSecStatsMaxTxBtuSize=appnIsrSessSecStatsMaxTxBtuSize, appnIsrSessProcedureCorrelationIdIndex=appnIsrSessProcedureCorrelationIdIndex, appnLocTgPropagationDelay=appnLocTgPropagationDelay, appnDluDsStatRowStatus=appnDluDsStatRowStatus, appnDnaNumberingPlanIndicator=appnDnaNumberingPlanIndicator, appnDLURRowStatusTable=appnDLURRowStatusTable, appnDluDsStatMaxTxPacWin=appnDluDsStatMaxTxPacWin, appnIsrSessSecStatsLsName=appnIsrSessSecStatsLsName, appnDluDsStatRxRuSize=appnDluDsStatRxRuSize, appnDluSscpRowStatusEntry=appnDluSscpRowStatusEntry, appnDlciBnnLsDefRowStatusEntry=appnDlciBnnLsDefRowStatusEntry, appnDlciStateTable=appnDlciStateTable, appnControlPointCreateParmsTable=appnControlPointCreateParmsTable, appnDlciUsageState=appnDlciUsageState, appnPortState=appnPortState, appnPort=appnPort, appnOperationalState=appnOperationalState, appnDlciBnnLsDefLsRole=appnDlciBnnLsDefLsRole, appnDluUsStatStatsTable=appnDluUsStatStatsTable, appnCosTgMaxEffectiveCapacity=appnCosTgMaxEffectiveCapacity, appnNnOperEntry=appnNnOperEntry, appnIsrSessOperTable=appnIsrSessOperTable, appnDluDsStatCurRxPacWin=appnDluDsStatCurRxPacWin, appnLcnVcDuplicatesFromSubnet=appnLcnVcDuplicatesFromSubnet, appnLsPropagationDelay=appnLsPropagationDelay, appnDlciBnnLsDefBackupDlusName=appnDlciBnnLsDefBackupDlusName, appnDefinedLsBadXids=appnDefinedLsBadXids, appnIsrSessTransmissionPriority=appnIsrSessTransmissionPriority, appnLcnVcTransferPriorityFromNetwork=appnLcnVcTransferPriorityFromNetwork, appnDlciBanRowStatusEntry=appnDlciBanRowStatusEntry, appnLsDynamicOrDefined=appnLsDynamicOrDefined, appnDlciVcIndex=appnDlciVcIndex, appnLsSap=appnLsSap, appnDnaCugPreferential=appnDnaCugPreferential, appnDluOperEntry=appnDluOperEntry, appnAdjNnRowStatusTable=appnAdjNnRowStatusTable, appnRtpPktTx=appnRtpPktTx, appnRtpComponentName=appnRtpComponentName, appnDlciCnRowStatus=appnDlciCnRowStatus, appnLcnUsageState=appnLcnUsageState, appnDluDsStatRowStatusEntry=appnDluDsStatRowStatusEntry, appnDluSscpStorageType=appnDluSscpStorageType, appnMaximumIsrSessions=appnMaximumIsrSessions, appnDlusSscpPuMuRx=appnDlusSscpPuMuRx, appnDnaDefaultTransferPriority=appnDnaDefaultTransferPriority, appnDluRowStatusEntry=appnDluRowStatusEntry, appnDlusDactLuRspTx=appnDlusDactLuRspTx, appnDirEntOperEntry=appnDirEntOperEntry, appnDnaCugIncCalls=appnDnaCugIncCalls, appnDlciExcessBurstSize=appnDlciExcessBurstSize, appnLcnVcWindowClosuresFromSubnet=appnLcnVcWindowClosuresFromSubnet, appnDnaCallOptionsEntry=appnDnaCallOptionsEntry, appnDnaCallOptionsTable=appnDnaCallOptionsTable, appnDnaHgMOpTable=appnDnaHgMOpTable, appnPortUserDefinedParm3=appnPortUserDefinedParm3, appnCosTgProvEntry=appnCosTgProvEntry, appnDirEntWildCard=appnDirEntWildCard, appnAdjNnStorageType=appnAdjNnStorageType, appnDlciBanProvEntry=appnDlciBanProvEntry, appnPortDefinedLsGoodXids=appnPortDefinedLsGoodXids, appnLsIndex=appnLsIndex, appnCosTgMinByteCost=appnCosTgMinByteCost, appnDlciSpOpEntry=appnDlciSpOpEntry, appnLcnDcIndex=appnLcnDcIndex, appnDlusDactPuRspTx=appnDlusDactPuRspTx, appnLsTgCharTable=appnLsTgCharTable, appnNnFunctionSupported=appnNnFunctionSupported, appnDnaHgMRowStatus=appnDnaHgMRowStatus, appnLcnVcCalledDna=appnLcnVcCalledDna, appnPortTotLinkActLim=appnPortTotLinkActLim, appnRtp=appnRtp, appnDluDsStat=appnDluDsStat, appnCos=appnCos, appnIsrSessSecStatsTxDataBytes=appnIsrSessSecStatsTxDataBytes, appnLsOutMsgFrames=appnLsOutMsgFrames, appnDluUsStatMaxTxPacWin=appnDluUsStatMaxTxPacWin, appnBlockNumber=appnBlockNumber, appnCosTg=appnCosTg, appnDnaDefaultRecvFrmNetworkWindowSize=appnDnaDefaultRecvFrmNetworkWindowSize, appnFrSvcBanLocalMac=appnFrSvcBanLocalMac, appnPortUserDefinedParm1=appnPortUserDefinedParm1, appnLsFeatures=appnLsFeatures, appnDlciDcRowStatusEntry=appnDlciDcRowStatusEntry, appnDluUsStatSidl=appnDluUsStatSidl, appnCapabilities=appnCapabilities, appnLsInSessionControlFrames=appnLsInSessionControlFrames, appnDluUsStatStatsEntry=appnDluUsStatStatsEntry, appnAdjNnIndex=appnAdjNnIndex, appnLcnDcStorageType=appnLcnDcStorageType, appnDnaDataNetworkAddress=appnDnaDataNetworkAddress, appnDlciBanLsDefProvTable=appnDlciBanLsDefProvTable, appnDnaHgMHgAddr=appnDnaHgMHgAddr, appnDnaOutDefaultPathSensitivity=appnDnaOutDefaultPathSensitivity, appnAdjNn=appnAdjNn, appnRtpBurstSize=appnRtpBurstSize, appnDlciVcDmepEntry=appnDlciVcDmepEntry, appnDlciVcFrdEntry=appnDlciVcFrdEntry, appnLsInMsgBytes=appnLsInMsgBytes, appnIsrSessSecStatsStatsEntry=appnIsrSessSecStatsStatsEntry, appnIsrSessSecStatsCurTxPacWin=appnIsrSessSecStatsCurTxPacWin, appnCosTgRowStatus=appnCosTgRowStatus, appnDluStorageType=appnDluStorageType, appnHeapSpaceCurrent=appnHeapSpaceCurrent, appnIsrSessPriStatsMaxRxBtuSize=appnIsrSessPriStatsMaxRxBtuSize, appnLsComponentName=appnLsComponentName, appnCosRowStatus=appnCosRowStatus, appnDlciRateEnforcement=appnDlciRateEnforcement, appnDluSscpLsName=appnDluSscpLsName, appnLsTgCharEntry=appnLsTgCharEntry, appnDlciVcFrmLossTimeouts=appnDlciVcFrmLossTimeouts, appnLcnRowStatus=appnLcnRowStatus, appnLsMaxDelay=appnLsMaxDelay, appnStatus=appnStatus, appnIsrUpperCongestionThreshold=appnIsrUpperCongestionThreshold, appnLcnDcRowStatusEntry=appnLcnDcRowStatusEntry, appnDLURRowStatusEntry=appnDLURRowStatusEntry, appnRowStatusTable=appnRowStatusTable, appnLcnDcTransferPriority=appnLcnDcTransferPriority, appnDirEntRowStatusEntry=appnDirEntRowStatusEntry, appnIsrSessPriStatsMaxRxPacWin=appnIsrSessPriStatsMaxRxPacWin, appnDluUsStat=appnDluUsStat, appnDlciVcCallReferenceNumber=appnDlciVcCallReferenceNumber, appnDLURComponentName=appnDLURComponentName, appnDluPluName=appnDluPluName, appnLsConfigTable=appnLsConfigTable, appnDlciBanLsDefMaxTxBtuSize=appnDlciBanLsDefMaxTxBtuSize, appnDlciVcCallingDna=appnDlciVcCallingDna, appnIsrSessPriStatsSidl=appnIsrSessPriStatsSidl, appnPortDlcType=appnPortDlcType, appnNnTgOperTable=appnNnTgOperTable, appnDlusStorageType=appnDlusStorageType, appnUpTime=appnUpTime, appnLsStatsEntry=appnLsStatsEntry, appnDluUsStatOdai=appnDluUsStatOdai, appnDlciMeasurementInterval=appnDlciMeasurementInterval, appnDlciVcAccountingEnabled=appnDlciVcAccountingEnabled, appnCosIndex=appnCosIndex, appnNnTgOwnerFqcpNameIndex=appnNnTgOwnerFqcpNameIndex, appnDlciBanLsDefHprSupported=appnDlciBanLsDefHprSupported)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AppnMIB", appnLcnVcWindowClosuresToSubnet=appnLcnVcWindowClosuresToSubnet, appnRtpMinTxRate=appnRtpMinTxRate, appnStateEntry=appnStateEntry, appnCosComponentName=appnCosComponentName, appnDlciVcDmepTable=appnDlciVcDmepTable, appnRtpRowStatusEntry=appnRtpRowStatusEntry, appnDluUsStatLsName=appnDluUsStatLsName, appnDLURStorageType=appnDLURStorageType, appnCosTgRowStatusEntry=appnCosTgRowStatusEntry, appnDlciVcCallingLcn=appnDlciVcCallingLcn, appnPortInbLinkActLim=appnPortInbLinkActLim, appnDlciSpExcessBurstSize=appnDlciSpExcessBurstSize, appnLsUserDefinedParm3=appnLsUserDefinedParm3, appnComponentName=appnComponentName, appnDlciVcIntdTable=appnDlciVcIntdTable, appnLcnVcState=appnLcnVcState, appnPortOutLinkActLim=appnPortOutLinkActLim, appnCosTgProvTable=appnCosTgProvTable, appnDlciRowStatusEntry=appnDlciRowStatusEntry, appnDirEntServerName=appnDirEntServerName, appnIsrSessFqcpNameIndex=appnIsrSessFqcpNameIndex, appnDlciVcPeakOoSeqPktCount=appnDlciVcPeakOoSeqPktCount, appnLcnVcIntdTable=appnLcnVcIntdTable, appnAdjNnCpCpSessStatus=appnAdjNnCpCpSessStatus, appnPortMaxRxBtuSize=appnPortMaxRxBtuSize, appnDLURDlusRetryTimeout=appnDLURDlusRetryTimeout, appnNnStorageType=appnNnStorageType, appnDluSscpMaxRxPacWin=appnDluSscpMaxRxPacWin, appnDlusPipeState=appnDlusPipeState, appnDlciBanLsDefAdjacentNodeID=appnDlciBanLsDefAdjacentNodeID, appnDnaHgMIndex=appnDnaHgMIndex, appnNnTgLinkAddressTable=appnNnTgLinkAddressTable, appnRtpCurRxRate=appnRtpCurRxRate, appnDlciVc=appnDlciVc, appnRtpSmoothRoundTripTime=appnRtpSmoothRoundTripTime, appnIsrSessPriStatsOdai=appnIsrSessPriStatsOdai, appnDlciRowStatusTable=appnDlciRowStatusTable, appnDlciBan=appnDlciBan, appnLcn=appnLcn, appnRtpRemoteTcid=appnRtpRemoteTcid, appnDluUsStatRxDataBytes=appnDluUsStatRxDataBytes, appnDnaHgMComponentName=appnDnaHgMComponentName, appnDnaHgMIfTable=appnDnaHgMIfTable, appnDlciBnnLsDefRowStatusTable=appnDlciBnnLsDefRowStatusTable, appnNn=appnNn, appnDluSscpRxRuSize=appnDluSscpRxRuSize, appnNnOperTable=appnNnOperTable, appnDlciComponentName=appnDlciComponentName, appnPortRowStatus=appnPortRowStatus, appnLsInXidFrames=appnLsInXidFrames, appnDlusDactLuRx=appnDlusDactLuRx, appnMemCriticalThreshold=appnMemCriticalThreshold, appnDnaAddressEntry=appnDnaAddressEntry, appnLcnVcStatsTable=appnLcnVcStatsTable, appnLocTgUserDefinedParm3=appnLocTgUserDefinedParm3, appnLcnVcPathReliability=appnLcnVcPathReliability, appnLcnVcStartTime=appnLcnVcStartTime, appnDluSscpRowStatusTable=appnDluSscpRowStatusTable, appnPortStorageType=appnPortStorageType, appnNnFunctionsSupported=appnNnFunctionsSupported, appnLocTgLinkAddressTable=appnLocTgLinkAddressTable, appnIsrSessSecStatsStorageType=appnIsrSessSecStatsStorageType, appnCnRowStatusEntry=appnCnRowStatusEntry, appnLocateTimeout=appnLocateTimeout, appnDlciBanRowStatusTable=appnDlciBanRowStatusTable, appnIsrSessPriStatsCurTxPacWin=appnIsrSessPriStatsCurTxPacWin, appnDlciVcPktRetryTimeouts=appnDlciVcPktRetryTimeouts, appnIsrSessSecStatsComponentName=appnIsrSessSecStatsComponentName, appnDlciVcOoSeqByteCntExceeded=appnDlciVcOoSeqByteCntExceeded, appnNnResourceSequenceNumber=appnNnResourceSequenceNumber, appnNnTgEffectiveCap=appnNnTgEffectiveCap, appnDluSscpRxDataBytes=appnDluSscpRxDataBytes, appnFrSvcProvisionedTable=appnFrSvcProvisionedTable, appnIsrSessSecStatsSidl=appnIsrSessSecStatsSidl, appnLsRowStatus=appnLsRowStatus, appnDnaRowStatusEntry=appnDnaRowStatusEntry, appnDlciDcOptionsTable=appnDlciDcOptionsTable, appnNnTgStorageType=appnNnTgStorageType, appnDluSscpTxFmdFrames=appnDluSscpTxFmdFrames, appnLsPortName=appnLsPortName, appnLcnVcPreviousDiagnosticCode=appnLcnVcPreviousDiagnosticCode, appnCnNumberActivePorts=appnCnNumberActivePorts, appnTreeCacheUseLimit=appnTreeCacheUseLimit, appnNnTg=appnNnTg, appnDnaHgMOpEntry=appnDnaHgMOpEntry, appnFrSvcRowStatusEntry=appnFrSvcRowStatusEntry, appnRowStatusEntry=appnRowStatusEntry, appnLcnDc=appnLcnDc, appnDlciBanProvTable=appnDlciBanProvTable, appnLcnStorageType=appnLcnStorageType, appnLsActSessCount=appnLsActSessCount, appnDluSscpStatsTable=appnDluSscpStatsTable, appnDlciDcRemoteDna=appnDlciDcRemoteDna, appnLsEchoResponse=appnLsEchoResponse, appnLcnVcAccountingEnd=appnLcnVcAccountingEnd, appnDluSscpStatsEntry=appnDluSscpStatsEntry, appnLcnVcDiagnosticCode=appnLcnVcDiagnosticCode, appnLsInMsgFrames=appnLsInMsgFrames, appnDluIndex=appnDluIndex, appnCnOperTable=appnCnOperTable, appnNnTgTransmissionGroupIndex=appnNnTgTransmissionGroupIndex, appnDlciVcDmepValue=appnDlciVcDmepValue, appnDlciVcCalledDna=appnDlciVcCalledDna, appnLocTgTgCharEntry=appnLocTgTgCharEntry, appnDnaTransferPriorityOverRide=appnDnaTransferPriorityOverRide, appnDluDsStatSidh=appnDluDsStatSidh, appnDlusReqDactPuTx=appnDlusReqDactPuTx, appnDlciBanLsDefCpCpSessionSupport=appnDlciBanLsDefCpCpSessionSupport, appnIsrSessPriStatsRxDataFrames=appnIsrSessPriStatsRxDataFrames, appnIsrSessOperEntry=appnIsrSessOperEntry, appnDnaHgMHgAddrStorageType=appnDnaHgMHgAddrStorageType, appnDnaHgMStorageType=appnDnaHgMStorageType, appnDlciDcRowStatusTable=appnDlciDcRowStatusTable, appnRtpBytesResent=appnRtpBytesResent, appnDlciVcDataPath=appnDlciVcDataPath, appnMIB=appnMIB, appnLcnVcFrmRetryTimeouts=appnLcnVcFrmRetryTimeouts, appnIsrSessSecStatsTxFmdFrames=appnIsrSessSecStatsTxFmdFrames, appnRtpLostFrames=appnRtpLostFrames, appnPortDynLsGoodXids=appnPortDynLsGoodXids, appnLocTgStorageType=appnLocTgStorageType, appnDlciCnStorageType=appnDlciCnStorageType, appnDlciVcState=appnDlciVcState, appnHeapSpaceLimit=appnHeapSpaceLimit, appnDlusComponentName=appnDlusComponentName, appnDnaCugRowStatus=appnDnaCugRowStatus, appnLcnVcCalledNpi=appnLcnVcCalledNpi, appnDLURIndex=appnDLURIndex, appnRtpMaxRxRate=appnRtpMaxRxRate, appnDnaHgMAvailabilityUpdateThreshold=appnDnaHgMAvailabilityUpdateThreshold, appnPortLsRole=appnPortLsRole, appnLsUserDefinedParm2=appnLsUserDefinedParm2, appnFrSvcRowStatusTable=appnFrSvcRowStatusTable, appnCosNodeProvTable=appnCosNodeProvTable, appnDirEntIndex=appnDirEntIndex, appnRowStatus=appnRowStatus, appnMaximumSvcs=appnMaximumSvcs, appnDlciRowStatus=appnDlciRowStatus, appnDlciSpMeasurementInterval=appnDlciSpMeasurementInterval, appn=appn, appnNnTgDaysLeft=appnNnTgDaysLeft, appnRtpPktDiscard=appnRtpPktDiscard, appnPortIndex=appnPortIndex, appnFrSvcMaximumFrameRelaySvcs=appnFrSvcMaximumFrameRelaySvcs, appnRtpMaxBtuSize=appnRtpMaxBtuSize, appnAdjNnRowStatus=appnAdjNnRowStatus, appnLsInXidBytes=appnLsInXidBytes, appnDlusActivePUs=appnDlusActivePUs, appnDlciCnIndex=appnDlciCnIndex, appnDnaAccountClass=appnDnaAccountClass, appnLcnVcRowStatusEntry=appnLcnVcRowStatusEntry, appnDlciVcElapsedTimeTillNow=appnDlciVcElapsedTimeTillNow, appnLcnVcCallingDna=appnLcnVcCallingDna, appnIsrSessSecStatsSidh=appnIsrSessSecStatsSidh, appnLsOutXidBytes=appnLsOutXidBytes, appnLcnRowStatusEntry=appnLcnRowStatusEntry, appnDluUsStatRxFmdFrames=appnDluUsStatRxFmdFrames, appnDirEnt=appnDirEnt, appnPortEffectiveCap=appnPortEffectiveCap, appnLcnDcRemoteNpi=appnLcnDcRemoteNpi, appnDnaAccountCollection=appnDnaAccountCollection, appnDlciBnnLsDefStorageType=appnDlciBnnLsDefStorageType, appnLsCurrentDelay=appnLsCurrentDelay, appnLcnStateEntry=appnLcnStateEntry, appnCosNodeProvEntry=appnCosNodeProvEntry, appnDlurSupport=appnDlurSupport, appnDluDsStatComponentName=appnDluDsStatComponentName, appnMaximumTopologyTgs=appnMaximumTopologyTgs, appnIsrSessPriStatsRxRuSize=appnIsrSessPriStatsRxRuSize, appnControlPointCreateParmsEntry=appnControlPointCreateParmsEntry, appnCosProvEntry=appnCosProvEntry, appnLcnVcSegmentSize=appnLcnVcSegmentSize, appnLsLsVcReferenceEntry=appnLsLsVcReferenceEntry, appnCosTgMinPropDelay=appnCosTgMinPropDelay, appnDlciCommittedInformationRate=appnDlciCommittedInformationRate, appnDlci=appnDlci, appnDluDsStatTxDataBytes=appnDluDsStatTxDataBytes, appnPortActXidExchLim=appnPortActXidExchLim, appnDluSscpOdai=appnDluSscpOdai, appnDlciVcCannotForwardToSubnet=appnDlciVcCannotForwardToSubnet, appnPortDefinedLsBadXids=appnPortDefinedLsBadXids, appnLocTgResourceSequenceNumber=appnLocTgResourceSequenceNumber, appnDluUsStatRowStatus=appnDluUsStatRowStatus, appnProcessParmsEntry=appnProcessParmsEntry, appnFqCpName=appnFqCpName, appnRtpShortReqTimer=appnRtpShortReqTimer, appnRtpRemoteCpName=appnRtpRemoteCpName, appnRtpOperTable=appnRtpOperTable, appnLcnVcPeakRetryQueueSize=appnLcnVcPeakRetryQueueSize, appnDirEntOperTable=appnDirEntOperTable, appnNnDaysLeft=appnNnDaysLeft, appnDlciVcFrmCongestedToSubnet=appnDlciVcFrmCongestedToSubnet, appnDlusRowStatusEntry=appnDlusRowStatusEntry, appnLocTgByteCost=appnLocTgByteCost, appnDlciBanLsDefLsRole=appnDlciBanLsDefLsRole, appnNnTgRowStatus=appnNnTgRowStatus, appnNnTgResourceSequenceNumber=appnNnTgResourceSequenceNumber, appnIdNumber=appnIdNumber, appnCnRowStatus=appnCnRowStatus, appnRtpRxInvalidSnaFrames=appnRtpRxInvalidSnaFrames, appnDlciVcNotDataXferToSubnet=appnDlciVcNotDataXferToSubnet, appnDlciBnnLsDefProvEntry=appnDlciBnnLsDefProvEntry, appnIsrSessSecStatsTxDataframes=appnIsrSessSecStatsTxDataframes, appnDirEntComponentName=appnDirEntComponentName, appnDluSscpCurTxPacWin=appnDluSscpCurTxPacWin, appnDlciBnnLsDefAdjacentCpType=appnDlciBnnLsDefAdjacentCpType, appnDlusRowStatus=appnDlusRowStatus, appnLcnVcCadTable=appnLcnVcCadTable, appnRtpStorageType=appnRtpStorageType, appnDlciBnnLsDefMaxTxBtuSize=appnDlciBnnLsDefMaxTxBtuSize, appnIsrSessPriStatsStatsTable=appnIsrSessPriStatsStatsTable, appnDlciCnRowStatusTable=appnDlciCnRowStatusTable, appnDlciBanIndex=appnDlciBanIndex, appnUsageState=appnUsageState, appnLcnVcIndex=appnLcnVcIndex, appnLsBadXids=appnLsBadXids, appnRtpIdleTimer=appnRtpIdleTimer, appnLocTgLinkAddressEntry=appnLocTgLinkAddressEntry, appnCosRowStatusEntry=appnCosRowStatusEntry, appnLocTgOperEntry=appnLocTgOperEntry, appnDlciVcCallingNpi=appnDlciVcCallingNpi, appnDlciBanLsDefMacIndex=appnDlciBanLsDefMacIndex, appnRtpIdleTimeouts=appnRtpIdleTimeouts, appnDluDsStatTxFmdFrames=appnDluDsStatTxFmdFrames, appnDnaHgMHgAddrRowStatus=appnDnaHgMHgAddrRowStatus, appnDluUsStatCurRxPacWin=appnDluUsStatCurRxPacWin, appnCapabilitiesBE=appnCapabilitiesBE, appnLsActualCpType=appnLsActualCpType, appnNnTgUserDefinedParm3=appnNnTgUserDefinedParm3, appnNnTgRowStatusTable=appnNnTgRowStatusTable, appnLsActualCpName=appnLsActualCpName, appnDluDsStatIndex=appnDluDsStatIndex, appnPortComponentName=appnPortComponentName, appnDlciVcPathReliability=appnDlciVcPathReliability, appnDlciStateEntry=appnDlciStateEntry, appnCosNode=appnCosNode, appnFrSvcBanTable=appnFrSvcBanTable, appnDluSscpIndex=appnDluSscpIndex, appnDna=appnDna, appnDirEntRowStatus=appnDirEntRowStatus, appnDLUR=appnDLUR, appnLcnVcPeakOoSeqQueueSize=appnLcnVcPeakOoSeqQueueSize, appnFrSvcOperationalTable=appnFrSvcOperationalTable, appnDnaCugCugOptionsEntry=appnDnaCugCugOptionsEntry, appnDlciAdminState=appnDlciAdminState, appnCnOperEntry=appnCnOperEntry, appnIsrSessPriStatsRowStatusTable=appnIsrSessPriStatsRowStatusTable, appnDlciBanLsDefTgNum=appnDlciBanLsDefTgNum, appnDluSscpMaxTxPacWin=appnDluSscpMaxTxPacWin, appnDlciCnRowStatusEntry=appnDlciCnRowStatusEntry, appnDluUsStatMaxRxBtuSize=appnDluUsStatMaxRxBtuSize, appnPortSimRim=appnPortSimRim, appnPortSecurity=appnPortSecurity, appnNnTgLinkAddressEntry=appnNnTgLinkAddressEntry)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AppnMIB", appnDluDsStatMaxRxPacWin=appnDluDsStatMaxRxPacWin, appnDLURDlurParmsTable=appnDLURDlurParmsTable, appnDlciVcSubnetRecoveries=appnDlciVcSubnetRecoveries, appnPortConfigTable=appnPortConfigTable, appnDlciBanLsDefDspuService=appnDlciBanLsDefDspuService, appnDlciVcFastSelectCall=appnDlciVcFastSelectCall, appnIsrSessPriStatsRxFmdFrames=appnIsrSessPriStatsRxFmdFrames, appnIsrRxPacingWindow=appnIsrRxPacingWindow, appnLsRowStatusTable=appnLsRowStatusTable, appnStateTable=appnStateTable, appnFrSvc=appnFrSvc, appnRtpRowStatus=appnRtpRowStatus, appnIsrSessPriStatsRxDataBytes=appnIsrSessPriStatsRxDataBytes, appnDlciVcRcosFromNetwork=appnDlciVcRcosFromNetwork, appnDluComponentName=appnDluComponentName, appnLcnVcCallingNpi=appnLcnVcCallingNpi, appnDlciDcTransferPriority=appnDlciDcTransferPriority, appnDlciVcDiagnosticCode=appnDlciVcDiagnosticCode, appnDlciSpParmsEntry=appnDlciSpParmsEntry, appnDynamicLsGoodXids=appnDynamicLsGoodXids, appnLcnVcComponentName=appnLcnVcComponentName, appnLsOutMsgBytes=appnLsOutMsgBytes, appnDlciBnnLsDefTgNum=appnDlciBnnLsDefTgNum, appnLsHprSupport=appnLsHprSupport, appnAdjNnOperEntry=appnAdjNnOperEntry, appnNnTgComponentName=appnNnTgComponentName, appnDlciVcCadTable=appnDlciVcCadTable, appnDluDsStatMaxTxBtuSize=appnDluDsStatMaxTxBtuSize, appnLsMigration=appnLsMigration, appnMaximumLinkStations=appnMaximumLinkStations, appnCosNodeRowStatusEntry=appnCosNodeRowStatusEntry, appnPortConfigEntry=appnPortConfigEntry, appnDluPluSessActive=appnDluPluSessActive, appnDlciBanLsDefAdjacentCpName=appnDlciBanLsDefAdjacentCpName, appnDnaIncomingOptionsEntry=appnDnaIncomingOptionsEntry, appnRtpActiveSessions=appnRtpActiveSessions, appnRtpLocalTcid=appnRtpLocalTcid, appnDlciSpRateEnforcement=appnDlciSpRateEnforcement, appnLcnVcPeakStackedAcksRx=appnLcnVcPeakStackedAcksRx, appnDluSscpComponentName=appnDluSscpComponentName, appnTreeCacheSize=appnTreeCacheSize, appnIsrSessSecStatsRxDataFrames=appnIsrSessSecStatsRxDataFrames, appnDirEntStorageType=appnDirEntStorageType, appnDluDsStatRxFmdFrames=appnDluDsStatRxFmdFrames, appnDluDsStatRxDataBytes=appnDluDsStatRxDataBytes, appnLcnOperationalState=appnLcnOperationalState, appnPortPropagationDelay=appnPortPropagationDelay, appnNnTgTgCharEntry=appnNnTgTgCharEntry, appnDluRowStatus=appnDluRowStatus, appnDnaCugCugOptionsTable=appnDnaCugCugOptionsTable, appnDlciVcAccountingEnd=appnDlciVcAccountingEnd, appnLsByteCost=appnLsByteCost, appnLocTgTransmissionGroupIndex=appnLocTgTransmissionGroupIndex, appnCosNodeRowStatus=appnCosNodeRowStatus, appnLcnComponentName=appnLcnComponentName, appnLsMinDelay=appnLsMinDelay, appnLcnVcSegmentsSent=appnLcnVcSegmentsSent, appnIsrSessStorageType=appnIsrSessStorageType, appnDluUsStatCurTxPacWin=appnDluUsStatCurTxPacWin, appnIsrSessPriStatsTxDataframes=appnIsrSessPriStatsTxDataframes, appnDynamicLsBadXids=appnDynamicLsBadXids, appnLsLinkStationState=appnLsLinkStationState, appnCosTgIndex=appnCosTgIndex, appnGroup=appnGroup, appnLocTgComponentName=appnLocTgComponentName, appnNnComponentName=appnNnComponentName, appnDnaOutAccess=appnDnaOutAccess, appnDluDsStatRxDataFrames=appnDluDsStatRxDataFrames, appnCosTgMinEffectiveCapacity=appnCosTgMinEffectiveCapacity, appnPortRowStatusTable=appnPortRowStatusTable, appnDlciBnnLsDef=appnDlciBnnLsDef, appnDlciDcRemoteNpi=appnDlciDcRemoteNpi, appnDlusSscpLuMuRx=appnDlusSscpLuMuRx, appnCosNodeMaxStatus=appnCosNodeMaxStatus, appnCosTgMaxUserDefParm1=appnCosTgMaxUserDefParm1, appnLcnVcWrTriggers=appnLcnVcWrTriggers, appnDlciCommittedBurstSize=appnDlciCommittedBurstSize, appnLcnVcSubnetTxWindowSize=appnLcnVcSubnetTxWindowSize, appnLs=appnLs, appnIsrSessSecStatsMaxTxPacWin=appnIsrSessSecStatsMaxTxPacWin, appnNnTgUserDefinedParm2=appnNnTgUserDefinedParm2, appnIsrSessSecStatsOdai=appnIsrSessSecStatsOdai, appnIsrSessComponentName=appnIsrSessComponentName, appnDlciVcNotDataXferFromSubnet=appnDlciVcNotDataXferFromSubnet, appnFrSvcCurrentNumberOfSvcCalls=appnFrSvcCurrentNumberOfSvcCalls, appnFrSvcBanLocalSap=appnFrSvcBanLocalSap, appnLcnVcPreviousState=appnLcnVcPreviousState, appnCosTgMaxPropDelay=appnCosTgMaxPropDelay, appnLsLsVcReferenceTable=appnLsLsVcReferenceTable, appnResourceSequenceNumber=appnResourceSequenceNumber, appnDluDsStatStatsEntry=appnDluDsStatStatsEntry, appnLocTgDestFqcpNameIndex=appnLocTgDestFqcpNameIndex, appnNnTgDlcData=appnNnTgDlcData, appnLocTgRowStatusEntry=appnLocTgRowStatusEntry, appnDlciIndex=appnDlciIndex, appnNnTgFlowReductionSequenceNumber=appnNnTgFlowReductionSequenceNumber, appnNnRowStatus=appnNnRowStatus, appnDlciDc=appnDlciDc, appnDlciBanLsDefComponentName=appnDlciBanLsDefComponentName, appnDlciDcNfaIndex=appnDlciDcNfaIndex, appnDluUsStatComponentName=appnDluUsStatComponentName, appnIsrSessLimitedResource=appnIsrSessLimitedResource, appnDnaOutgoingOptionsTable=appnDnaOutgoingOptionsTable, appnIsrSessPriStatsStorageType=appnIsrSessPriStatsStorageType, appnDluSscpCurRxPacWin=appnDluSscpCurRxPacWin, appnDlusReqDactPuRspRx=appnDlusReqDactPuRspRx, appnCosTgMaxSecurity=appnCosTgMaxSecurity, appnDluUsStatStorageType=appnDluUsStatStorageType, appnOperationalEntry=appnOperationalEntry, appnLsName=appnLsName, appnDnaAddressTable=appnDnaAddressTable, appnCosTgMinModemClass=appnCosTgMinModemClass, appnIsrSessCosName=appnIsrSessCosName, appnDnaHgMRowStatusTable=appnDnaHgMRowStatusTable, appnRtpRxBytes=appnRtpRxBytes, appnFrSvcStorageType=appnFrSvcStorageType, appnDlciVcEmissionPriorityToNetwork=appnDlciVcEmissionPriorityToNetwork, appnIsrSessSecStatsRxFmdFrames=appnIsrSessSecStatsRxFmdFrames, appnDlusIndex=appnDlusIndex, appnDluSscpSidh=appnDluSscpSidh, appnDnaIncAccess=appnDnaIncAccess, appnDnaHgMAvailableChannels=appnDnaHgMAvailableChannels, appnLcnDcRemoteDna=appnLcnDcRemoteDna, appnRtpOperEntry=appnRtpOperEntry, appnDnaCugInterlockCode=appnDnaCugInterlockCode, appnLcnVcCallReferenceNumber=appnLcnVcCallReferenceNumber, appnLsConnectCost=appnLsConnectCost, appnIsrSessPriStats=appnIsrSessPriStats, appnCnRowStatusTable=appnCnRowStatusTable, appnRtpUptime=appnRtpUptime, appnRouteAdditionResistance=appnRouteAdditionResistance, appnDnaOutgoingOptionsEntry=appnDnaOutgoingOptionsEntry, appnDnaHgMRowStatusEntry=appnDnaHgMRowStatusEntry, appnDnaHgMHgAddrIndex=appnDnaHgMHgAddrIndex, appnDlciSpStorageType=appnDlciSpStorageType, appnAdjNnOperTable=appnAdjNnOperTable, appnLocTgUserDefinedParm1=appnLocTgUserDefinedParm1, appnIsrSessPriStatsComponentName=appnIsrSessPriStatsComponentName, appnDluUsStatTxFmdFrames=appnDluUsStatTxFmdFrames, appnDlusActPuRx=appnDlusActPuRx, appnCosTgRowStatusTable=appnCosTgRowStatusTable, appnFrSvcIndex=appnFrSvcIndex, appnDluSscpTxDataframes=appnDluSscpTxDataframes, appnLsEffectiveCap=appnLsEffectiveCap, appnDlciBnnLsDefDlusName=appnDlciBnnLsDefDlusName, appnIsrSessSecStatsIndex=appnIsrSessSecStatsIndex, appnDnaDefaultRecvFrmNetworkThruputClass=appnDnaDefaultRecvFrmNetworkThruputClass, appnDlciVcCalledNpi=appnDlciVcCalledNpi, appnLocTgDlcData=appnLocTgDlcData, appnRtpLastRoundTripTime=appnRtpLastRoundTripTime, appnAdjNnComponentName=appnAdjNnComponentName, appnDnaHgMHgAddrRowStatusEntry=appnDnaHgMHgAddrRowStatusEntry, appnLogicalProcessor=appnLogicalProcessor, appnAdminState=appnAdminState, appnDnaCugPrivileged=appnDnaCugPrivileged, appnDlciBnnLsDefHprSupported=appnDlciBnnLsDefHprSupported, appnLcnVcRowStatusTable=appnLcnVcRowStatusTable, appnLcnVcLocalRxWindowSize=appnLcnVcLocalRxWindowSize, appnNnTgTgCharTable=appnNnTgTgCharTable, appnCosTgMaxConnectCost=appnCosTgMaxConnectCost, appnLsDlcType=appnLsDlcType, appnRtpInSessionControlFrames=appnRtpInSessionControlFrames, appnPortMaxIfrmRxWindow=appnPortMaxIfrmRxWindow, appnPortDynLsBadXids=appnPortDynLsBadXids, appnDluSscpSessActive=appnDluSscpSessActive, appnLcnVcTransferPriorityToNetwork=appnLcnVcTransferPriorityToNetwork, appnDnaStorageType=appnDnaStorageType, appnDluDsStatSidl=appnDluDsStatSidl, appnIsrSessSecStatsCurRxPacWin=appnIsrSessSecStatsCurRxPacWin, appnLcnVcAccountingEnabled=appnLcnVcAccountingEnabled, appnIsrSessPriStatsLsName=appnIsrSessPriStatsLsName, appnDlciBanLocalSap=appnDlciBanLocalSap, appnDirEntLuOwnerName=appnDirEntLuOwnerName, appnDlciVcCadEntry=appnDlciVcCadEntry, appnDlciVcPriority=appnDlciVcPriority, appnLsOutXidFrames=appnLsOutXidFrames, appnLocTgConnectCost=appnLocTgConnectCost, appnFrSvcRowStatus=appnFrSvcRowStatus, appnLsAnrLabel=appnLsAnrLabel, appnLsDlcName=appnLsDlcName, appnLcnVc=appnLcnVc, appnNnTgDestFqcpNameIndex=appnNnTgDestFqcpNameIndex, appnDirEntRowStatusTable=appnDirEntRowStatusTable, appnPortOperTable=appnPortOperTable, appnIsrSessSecStatsRowStatusTable=appnIsrSessSecStatsRowStatusTable, appnCapabilitiesBE01=appnCapabilitiesBE01, appnDlciVcType=appnDlciVcType, appnLcnVcFastSelectCall=appnLcnVcFastSelectCall, appnDlciSpRowStatus=appnDlciSpRowStatus, appnDluDsStatTxDataframes=appnDluDsStatTxDataframes, appnDluSscpRxFmdFrames=appnDluSscpRxFmdFrames, appnGroupBE01A=appnGroupBE01A, appnNnRowStatusTable=appnNnRowStatusTable, appnActiveSvcs=appnActiveSvcs, appnLcnDcOptionsTable=appnLcnDcOptionsTable, appnIsrSessPriStatsMaxTxBtuSize=appnIsrSessPriStatsMaxTxBtuSize, appnDlciBnnLsDefCpCpSessionSupport=appnDlciBnnLsDefCpCpSessionSupport, appnNnTgRowStatusEntry=appnNnTgRowStatusEntry, appnIsrMaxRuSize=appnIsrMaxRuSize, appnDlciVcStorageType=appnDlciVcStorageType, appnLsLinkStationSubState=appnLsLinkStationSubState, appnDnaRowStatusTable=appnDnaRowStatusTable, appnDlus=appnDlus, appnDlciVcMaxSubnetPktSize=appnDlciVcMaxSubnetPktSize, appnIsrSessSecStatsRxRuSize=appnIsrSessSecStatsRxRuSize, appnCosTgComponentName=appnCosTgComponentName, appnDlciBnnLsDefIndex=appnDlciBnnLsDefIndex, appnLcnVcType=appnLcnVcType, appnLsConfigEntry=appnLsConfigEntry, appnIsrSessPriStatsTxFmdFrames=appnIsrSessPriStatsTxFmdFrames, appnRtpMinRxRate=appnRtpMinRxRate, appnPortRowStatusEntry=appnPortRowStatusEntry, appnDlciVcCalledLcn=appnDlciVcCalledLcn, appnMdsTxAlertQueueSize=appnMdsTxAlertQueueSize, appnLcnVcElapsedTimeTillNow=appnLcnVcElapsedTimeTillNow, appnDnaDefaultSendToNetworkThruputClass=appnDnaDefaultSendToNetworkThruputClass, appnAdjNnOutOfSeqTdus=appnAdjNnOutOfSeqTdus, appnIsrSessPriStatsMaxTxPacWin=appnIsrSessPriStatsMaxTxPacWin, appnCosNodeMinRouteAddResistance=appnCosNodeMinRouteAddResistance, appnPortTgCharEntry=appnPortTgCharEntry, appnDlciDcNfaEntry=appnDlciDcNfaEntry, appnRtpStatsTable=appnRtpStatsTable, appnPortTargetPacingCount=appnPortTargetPacingCount, appnLcnVcLocalTxWindowSize=appnLcnVcLocalTxWindowSize, appnDnaComponentName=appnDnaComponentName, appnDlciVcSegmentsRx=appnDlciVcSegmentsRx, appnLsOperEntry=appnLsOperEntry, appnCapabilitiesBE01A=appnCapabilitiesBE01A, appnDlciBanLocalMac=appnDlciBanLocalMac, appnDluUsStatRxRuSize=appnDluUsStatRxRuSize, appnAdjNnLastFrsnReceived=appnAdjNnLastFrsnReceived, appnDlciVcDuplicatesFromSubnet=appnDlciVcDuplicatesFromSubnet, appnCnStorageType=appnCnStorageType, appnDlciBanLsDef=appnDlciBanLsDef, appnDlciBanLsDefStorageType=appnDlciBanLsDefStorageType, appnDnaOutDefaultPathReliability=appnDnaOutDefaultPathReliability, appnLcnDcOptionsEntry=appnLcnDcOptionsEntry, appnLcnDcRowStatus=appnLcnDcRowStatus, appnDlusActLuRx=appnDlusActLuRx, appnLsStatsTable=appnLsStatsTable, appnPortType=appnPortType, appnRtpBytesDiscarded=appnRtpBytesDiscarded, appnLcnVcAckStackingTimeouts=appnLcnVcAckStackingTimeouts, appnFrSvcMaximumCir=appnFrSvcMaximumCir, appnLcnVcSubnetTxPktSize=appnLcnVcSubnetTxPktSize, appnDlusSscpPuMuTx=appnDlusSscpPuMuTx, appnDlciCnComponentName=appnDlciCnComponentName, appnDlciExcessInformationRate=appnDlciExcessInformationRate, appnNnStatus=appnNnStatus, appnIsrSessRowStatus=appnIsrSessRowStatus, appnRtpTxBytes=appnRtpTxBytes, appnDlciVcPreviousDiagnosticCode=appnDlciVcPreviousDiagnosticCode, appnDlciSpRowStatusTable=appnDlciSpRowStatusTable, appnLcnVcStorageType=appnLcnVcStorageType)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AppnMIB", appnIsrSess=appnIsrSess, appnIsrLowerCongestionThreshold=appnIsrLowerCongestionThreshold, appnDnaCugRowStatusEntry=appnDnaCugRowStatusEntry, appnDlciBnnLsDefRowStatus=appnDlciBnnLsDefRowStatus, appnIsrSessSecStatsMaxRxBtuSize=appnIsrSessSecStatsMaxRxBtuSize, appnDlciDcComponentName=appnDlciDcComponentName, appnLsTgNum=appnLsTgNum, appnStorageType=appnStorageType, appnDlciBanLsDefDlusName=appnDlciBanLsDefDlusName, appnNnTgOperEntry=appnNnTgOperEntry, appnDnaHgMAvailabilityDelta=appnDnaHgMAvailabilityDelta, appnDlciVcComponentName=appnDlciVcComponentName, appnDlciVcPeakRetryQueueSize=appnDlciVcPeakRetryQueueSize, appnDLURPrimaryDefDlusName=appnDLURPrimaryDefDlusName, appnDnaCug=appnDnaCug, appnLsOutSessionControlFrames=appnLsOutSessionControlFrames, appnDnaHgMHgAddrComponentName=appnDnaHgMHgAddrComponentName, appnFrSvcRateEnforcement=appnFrSvcRateEnforcement, appnLcnVcCallingLcn=appnLcnVcCallingLcn, appnLsUserDefinedParm1=appnLsUserDefinedParm1, appnNnTgPropagationDelay=appnNnTgPropagationDelay, appnRtpStatsEntry=appnRtpStatsEntry, appnDluUsStatIndex=appnDluUsStatIndex, appnDlciBanStorageType=appnDlciBanStorageType, appnDlusDlusStatTable=appnDlusDlusStatTable, appnDluSscpMaxTxBtuSize=appnDluSscpMaxTxBtuSize, appnDlciVcSendSequenceNumber=appnDlciVcSendSequenceNumber, appnRtpMaxTxRate=appnRtpMaxTxRate, appnLsOperTable=appnLsOperTable, appnCosNodeRowStatusTable=appnCosNodeRowStatusTable, appnDlciBanLsDefProvEntry=appnDlciBanLsDefProvEntry, appnDlciVcRowStatus=appnDlciVcRowStatus, appnDlciVcPeakOoSeqByteCount=appnDlciVcPeakOoSeqByteCount, appnDnaCugDnic=appnDnaCugDnic, appnDlciBanLsDefBackupDlusName=appnDlciBanLsDefBackupDlusName, appnLcnVcSubnetRxPktSize=appnLcnVcSubnetRxPktSize, appnDlusSscpLuMuTx=appnDlusSscpLuMuTx, appnDLURDlurParmsEntry=appnDLURDlurParmsEntry, appnGeneralFunctionsSupported=appnGeneralFunctionsSupported, appnDlciBanLsDefRowStatus=appnDlciBanLsDefRowStatus, appnDluDsStatRowStatusTable=appnDluDsStatRowStatusTable, appnCn=appnCn, appnDlusActPuRspTx=appnDlusActPuRspTx, appnCnIndex=appnCnIndex, appnIsrSessPriStatsStatsEntry=appnIsrSessPriStatsStatsEntry, appnDluUsStatSidh=appnDluUsStatSidh, appnLcnAdminState=appnLcnAdminState, appnRtpPktRx=appnRtpPktRx, appnLocTgOperTable=appnLocTgOperTable, appnLcnVcLocalTxPktSize=appnLcnVcLocalTxPktSize, appnDluDsStatStatsTable=appnDluDsStatStatsTable, appnNnTgUserDefinedParm1=appnNnTgUserDefinedParm1, appnLsSecurity=appnLsSecurity, appnDnaHgMHgAddrRowStatusTable=appnDnaHgMHgAddrRowStatusTable, appnNnIndex=appnNnIndex, appnIndex=appnIndex, appnDluUsStatTxDataframes=appnDluUsStatTxDataframes, appnDlciOperationalState=appnDlciOperationalState, appnCosTgMaxModemClass=appnCosTgMaxModemClass, appnDlciDcNfaTable=appnDlciDcNfaTable, appnDlciBnnLsDefAdjacentNodeID=appnDlciBnnLsDefAdjacentNodeID, appnLsGoodXids=appnLsGoodXids, appnDluUsStatRowStatusEntry=appnDluUsStatRowStatusEntry, appnCosTgStorageType=appnCosTgStorageType, appnMaximumLocates=appnMaximumLocates, appnCosTgMaxUserDefParm3=appnCosTgMaxUserDefParm3, appnDlciStorageType=appnDlciStorageType, appnDnaIndex=appnDnaIndex, appnDlusPrimaryDlus=appnDlusPrimaryDlus, appnRtpCurTxRate=appnRtpCurTxRate, appnDluUsStatRowStatusTable=appnDluUsStatRowStatusTable, appnDlciDcType=appnDlciDcType, appnRtpShortReqTimeouts=appnRtpShortReqTimeouts, appnNnNodeType=appnNnNodeType, appnDluSscpSidl=appnDluSscpSidl, appnMaximumDirectorySize=appnMaximumDirectorySize, appnDnaHgMIfEntry=appnDnaHgMIfEntry, appnDluDsStatStorageType=appnDluDsStatStorageType, appnDnaHgM=appnDnaHgM, appnDnaDefaultSendToNetworkWindowSize=appnDnaDefaultSendToNetworkWindowSize, appnCosProvTable=appnCosProvTable, appnLocTgRowStatusTable=appnLocTgRowStatusTable, appnPortByteCost=appnPortByteCost, appnIsrSessPriStatsRowStatus=appnIsrSessPriStatsRowStatus, appnAdjNnLastFrsnSent=appnAdjNnLastFrsnSent, appnCosTgMaxUserDefParm2=appnCosTgMaxUserDefParm2, appnDluDsStatLsName=appnDluDsStatLsName, appnDlciDcNfaValue=appnDlciDcNfaValue, appnHprSupport=appnHprSupport, appnCosNodeIndex=appnCosNodeIndex, appnLcnVcOutOfRangeFrmFromSubnet=appnLcnVcOutOfRangeFrmFromSubnet, appnDnaOutPathSensitivityOverRide=appnDnaOutPathSensitivityOverRide, appnDlusDlusStatEntry=appnDlusDlusStatEntry, appnIsrSessPriStatsRowStatusEntry=appnIsrSessPriStatsRowStatusEntry, appnDlciDcRowStatus=appnDlciDcRowStatus, appnRtpLocalLsName=appnRtpLocalLsName, appnRtpOutSessionControlFrames=appnRtpOutSessionControlFrames, appnLsRowStatusEntry=appnLsRowStatusEntry, appnCosStorageType=appnCosStorageType, appnLcnDcRowStatusTable=appnLcnDcRowStatusTable, appnLcnVcCalledLcn=appnLcnVcCalledLcn, appnDlciSpOpTable=appnDlciSpOpTable, appnPortLsXmitRxCap=appnPortLsXmitRxCap, appnLocTgSecurity=appnLocTgSecurity, appnDlciSpCommittedBurstSize=appnDlciSpCommittedBurstSize, appnDlusOperTable=appnDlusOperTable, appnCosTgMaxByteCost=appnCosTgMaxByteCost, appnDlciVcPeakOoSeqFrmForwarded=appnDlciVcPeakOoSeqFrmForwarded, appnLcnRowStatusTable=appnLcnRowStatusTable, appnCosTgMinUserDefParm1=appnCosTgMinUserDefParm1, appnDnaServiceExchange=appnDnaServiceExchange, appnDlciDcRemoteDlci=appnDlciDcRemoteDlci, appnDnaCugType=appnDnaCugType, appnDlciCn=appnDlciCn, appnLsInInvalidSnaFrames=appnLsInInvalidSnaFrames, appnLocTgTgCharTable=appnLocTgTgCharTable, appnDLURDlusRetryLimit=appnDLURDlusRetryLimit, appnDlusReqActPuRspRx=appnDlusReqActPuRspRx, appnIsrSessPriStatsIndex=appnIsrSessPriStatsIndex, appnPortMaxTxBtuSize=appnPortMaxTxBtuSize, appnLcnVcPriority=appnLcnVcPriority, appnPortTgCharTable=appnPortTgCharTable, appnDLURRowStatus=appnDLURRowStatus, appnLcnVcSubnetRxWindowSize=appnLcnVcSubnetRxWindowSize, appnCosTransmissionPriority=appnCosTransmissionPriority, appnDlciBanLsDefRowStatusTable=appnDlciBanLsDefRowStatusTable, appnCosNodeStorageType=appnCosNodeStorageType, appnGroupBE01=appnGroupBE01, appnDlciVcSegmentsSent=appnDlciVcSegmentsSent, appnIsrSessSecStatsStatsTable=appnIsrSessSecStatsStatsTable, appnDluDsStatOdai=appnDluDsStatOdai, appnDlciBanLsDefSapIndex=appnDlciBanLsDefSapIndex, appnDnaHgMHgAddrDataNetworkAddress=appnDnaHgMHgAddrDataNetworkAddress, appnDnaCugOutCalls=appnDnaCugOutCalls, appnDlciBanRowStatus=appnDlciBanRowStatus, appnDluUsStatTxDataBytes=appnDluUsStatTxDataBytes, appnProcessParmsTable=appnProcessParmsTable, appnDluUsStatRxDataFrames=appnDluUsStatRxDataFrames, appnCosTgMinSecurity=appnCosTgMinSecurity, appnDlusReqActPuTx=appnDlusReqActPuTx, appnCosTgMinUserDefParm3=appnCosTgMinUserDefParm3, appnDlciDcOptionsEntry=appnDlciDcOptionsEntry, appnDlciVcRowStatusEntry=appnDlciVcRowStatusEntry, appnIsrSessSecStatsRowStatusEntry=appnIsrSessSecStatsRowStatusEntry, appnCnComponentName=appnCnComponentName, appnDlciVcPreviousState=appnDlciVcPreviousState, appnDluUsStatMaxRxPacWin=appnDluUsStatMaxRxPacWin, appnActiveLinkStations=appnActiveLinkStations, appnDlciSpCommittedInformationRate=appnDlciSpCommittedInformationRate, appnLcnVcSubnetRecoveries=appnLcnVcSubnetRecoveries, appnLocTgRowStatus=appnLocTgRowStatus, appnLcnStateTable=appnLcnStateTable)

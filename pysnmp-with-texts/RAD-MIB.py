#
# PySNMP MIB module RAD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RAD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:13:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
atmVplVpi, atmVpCrossConnectEntry, atmTrafficDescrParamEntry, atmVclVpi, atmVcCrossConnectEntry, atmVclVci = mibBuilder.importSymbols("ATM-MIB", "atmVplVpi", "atmVpCrossConnectEntry", "atmTrafficDescrParamEntry", "atmVclVpi", "atmVcCrossConnectEntry", "atmVclVci")
dot1dBasePortEntry, BridgeId, Timeout = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry", "BridgeId", "Timeout")
schedEntry, = mibBuilder.importSymbols("DISMAN-SCHEDULE-MIB", "schedEntry")
dot3OamOperStatus, dot3OamEntry = mibBuilder.importSymbols("DOT3-OAM-MIB", "dot3OamOperStatus", "dot3OamEntry")
dsx1LineIndex, dsx1IntervalNumber, dsx1CurrentIndex, dsx1IntervalIndex, dsx1LineStatusLastChange, dsx1LoopbackStatus, dsx1LineStatus, dsx1TotalIndex = mibBuilder.importSymbols("DS1-MIB", "dsx1LineIndex", "dsx1IntervalNumber", "dsx1CurrentIndex", "dsx1IntervalIndex", "dsx1LineStatusLastChange", "dsx1LoopbackStatus", "dsx1LineStatus", "dsx1TotalIndex")
dsx3LoopbackStatus, dsx3ConfigEntry, dsx3LineStatus = mibBuilder.importSymbols("DS3-MIB", "dsx3LoopbackStatus", "dsx3ConfigEntry", "dsx3LineStatus")
IANAifType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAifType")
dot1agCfmMaIndex, dot1agCfmMdIndex, dot1agCfmMepDbRMepIdentifier, dot1agCfmMepIdentifier = mibBuilder.importSymbols("IEEE8021-CFM-MIB", "dot1agCfmMaIndex", "dot1agCfmMdIndex", "dot1agCfmMepDbRMepIdentifier", "dot1agCfmMepIdentifier")
ifIndex, ifDescr, InterfaceIndex, ifAlias = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifDescr", "InterfaceIndex", "ifAlias")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
LldpPortIdSubtype, = mibBuilder.importSymbols("LLDP-MIB", "LldpPortIdSubtype")
PerfTotalCount, PerfCurrentCount, PerfIntervalCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfTotalCount", "PerfCurrentCount", "PerfIntervalCount")
dot1qVlanStaticEntry, PortList, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "dot1qVlanStaticEntry", "PortList", "VlanId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, iso, MibIdentifier, enterprises, ModuleIdentity, Unsigned32, Integer32, IpAddress, Gauge32, ObjectIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Bits, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "MibIdentifier", "enterprises", "ModuleIdentity", "Unsigned32", "Integer32", "IpAddress", "Gauge32", "ObjectIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Bits", "TimeTicks")
RowPointer, MacAddress, DisplayString, DateAndTime, RowStatus, TimeStamp, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "MacAddress", "DisplayString", "DateAndTime", "RowStatus", "TimeStamp", "TruthValue", "TextualConvention")
rad = MibIdentifier((1, 3, 6, 1, 4, 1, 164))
radTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 1))
radFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 2))
radWan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3))
radBridges = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4))
radConverters = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 5))
radGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6))
radStkHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 7))
radAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12))
radRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11))
rtrBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7))
systems = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1))
radSysTR = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1))
radRADring = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 1))
radTMA = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 2))
radRingMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 3))
radSysFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 2))
radFDX100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 2, 1))
radSysWan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3))
radSysWanEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0))
if mibBuilder.loadTexts: radSysWanEvents.setStatus('current')
if mibBuilder.loadTexts: radSysWanEvents.setDescription('The events for RAD Wan products.')
radMP2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 1))
radMP2104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 2))
radMP2100B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 3))
radMP2100F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 4))
radMP2100H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 5))
radMP2104H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 6))
radMP2200B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 7))
radMP2200F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 8))
radMX3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 9))
radMX3004 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 10))
radMX30 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 11))
radMX300 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 12))
radVOIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 13))
radKM2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 15))
radKM2104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 16))
radDXC30 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 20))
radDXC10A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 21))
radDXC8R = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 22))
radDXC30E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 23))
radDXC3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 24))
radDXC8RNew = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 25))
radFcdT1LC = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 26))
radFcdE1LC = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 27))
radFcdT1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 28))
radFcdE1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 29))
radFcdT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 30))
radFcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 31))
radFcdE1I = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 32))
radFcdT1M = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 33))
radFcdE1M = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 34))
radFcdIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 35))
radFcdT1A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 36))
radFcdE1A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 37))
radFcdW = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 38))
radFcdSTM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 39))
radHtuE1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 40))
radHtuE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 41))
radHtu2Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 42))
radHtu2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 43))
radAsmi450R768Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 44))
radAsmi450R768 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 45))
radAsmi450R1152Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 46))
radAsmi450R1152 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 47))
radLrs12F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 48))
radLrs12B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 49))
radLrs52 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 50))
radHcdE1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 51))
radHcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 52))
radHtuT1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 53))
radHtuT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 54))
radOptimux4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 55))
radOptimux4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 56))
radOptimuxXLE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 57))
radOptimuxXLT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 58))
radOptimuxXL16E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 59))
radImx64 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 60))
radImx6L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 61))
radImx2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 62))
radImx4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 63))
radImx4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 64))
radImx2T1E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 65))
radImxi4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 66))
radOptimux155 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 67))
radOptimux4T1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 68))
radOptimux4E1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 69))
radHtuE1SaV2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 70))
radHtuE1V2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 71))
radFomiE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 72))
radFomiT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 73))
radOpt4E1C = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 74))
radOpt4T1C = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 75))
radPrbiE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 76))
radPrbiT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 77))
radHcd4Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 78))
radOptimuxT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 79))
radFRmon = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 80))
radIpMux4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 81))
radIpMux1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 82))
radIpMux16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 83))
radIpMux1E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 84))
radVmux2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 85))
radMP104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 86))
radMP204 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 87))
radVmux110 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 88))
radFcd155 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 90))
radIpMux8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 91))
radOptimux155DS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 92))
radOptimuxT3L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 93))
radGmux2000 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 94))
radOp16E1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 95))
radOp16E1LS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 96))
radPRBm20 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 97))
radPRBm22 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 98))
radAsmi52A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 99))
radOpXLE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 100))
radOpXLT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 101))
radOpXL16E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 102))
radOp4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 103))
radOp4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 104))
radDxc4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 105))
radIpMux11 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 106))
radIpMux14 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 107))
radOp1550 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 108))
radFdsl101 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 110))
radFdsl201 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 111))
radVmux120 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 112))
radVmux2200 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 113))
radVmux400 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 114))
radIpMux116 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 115))
radOp4E1LNew = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 116))
radOp4T1LNew = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 117))
radFcd155E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 118))
radFcd155ES = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 119))
radMP4100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 120))
radAsmi52L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 121))
radVmux210 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 122))
radOp34E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 123))
radVmux312 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 124))
radVmux404 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 125))
radVmux420 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 126))
radIpMux12 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 127))
radOptimux4E1V3dot5 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 128))
radOptimux4E1Mar06 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 129))
radFcd155EwAPS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 130))
radOptimux4T1Mar06 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 131))
radFcd155EwAPS2pdh = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 132))
radVmux320 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 133))
radMP2100VoIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 134))
radMP2104VoIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 135))
radIpMux24 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 136))
radOp4E1NG1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 137))
radOp4T1NG1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 138))
radOp25 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 139))
radAsmi54 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 140))
radVmux314 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 141))
radFcd622 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 142))
radLrs22 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 143))
radUNT20E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 144))
radIpMux2L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 145))
radUNT20Fcd = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 146))
radIpMux216 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 147))
radLrs102 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 148))
radGmux2004 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 149))
radLrs102unbal = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 150))
radLrs16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 151))
radVmux405 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 152))
radVmux425 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 153))
radMiniCVS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 154))
radSysBRG = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4))
radTRE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 1))
radTRE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 2))
radTRE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 3))
radTRE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 4))
radMBE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 5))
radMBE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 6))
radMBE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 7))
radMBE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 8))
radMLBT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 9))
radFEB4DAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 10))
radTrimBrg10 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 11))
radTrimBrg16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 12))
radRRTRE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 13))
radRRTRE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 14))
radRRMLBT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 15))
radRRMLBTF = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 16))
radRRTRE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 17))
radTRERAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 18))
radTRERASa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 19))
radMBERAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 20))
radMBERASa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 21))
radFEB4FDX = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 22))
radFEB4SAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 23))
radRRFTBDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 24))
radRRFTBSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 25))
radFTBDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 26))
radFTBSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 27))
radFastWay100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 28))
radSysCnvrtr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5))
radSTC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 1))
radSTC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 3))
radSTC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 4))
radSTC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 6))
radFTC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 10))
radFTC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 12))
radFTC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 13))
radFTC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 15))
radSEC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 20))
radSEC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 22))
radSEC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 23))
radSEC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 25))
radFEC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 30))
radFEC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 32))
radFEC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 33))
radFEC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 35))
radRIC155 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 36))
radRICE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 37))
radETX102 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 38))
radRIC155GE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 39))
radRiciT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 40))
radRiciE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 41))
radRiciT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 42))
radETX202 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 43))
radETX105 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 44))
radETX205 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 45))
radRiciSE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 46))
radRIC622GE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 47))
radSPH = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 48))
radMiricE1T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 49))
radMiricE3T3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 50))
radEthAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6))
radETX510 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 1))
radEGate100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 2))
radEGate20 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 3))
radRici8E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 4))
radRici8T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 5))
radRici4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 6))
radRici4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 7))
radIMXI4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 8))
radETX550 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 9))
radRici16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 10))
radETX102A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 11))
radETX202A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 12))
radETX201A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 13))
radETX201 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 14))
radUNT20Ric = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 15))
radRici4E1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 16))
radRici8E1L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 17))
radRici155GE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 18))
radRici622GE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 19))
radETX208 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 20))
radETX202AW = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 21))
radETX102H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 22))
radETX202H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 6, 23))
radSysStkHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7))
radRBHE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 1))
radRBHT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 2))
radRBHEEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 1, 0))
if mibBuilder.loadTexts: radRBHEEvents.setStatus('current')
if mibBuilder.loadTexts: radRBHEEvents.setDescription('The events for RAD Stackable products.')
radRBHTEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 2, 0))
if mibBuilder.loadTexts: radRBHTEvents.setStatus('current')
if mibBuilder.loadTexts: radRBHTEvents.setDescription('The events for RAD Stackable products.')
radETS4fddiDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 3))
radETS4fddiSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 4))
radSAHEMX = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 5))
radSAHTM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 6))
radETS4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 7))
radSAHEMU = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 8))
unknown = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 9))
radSAH16Eint = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 10))
radSAH16Tint = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 11))
radSAH16Eext = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 12))
radSAH16Text = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 13))
radSysPS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8))
radSysPSEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 0))
if mibBuilder.loadTexts: radSysPSEvents.setStatus('current')
if mibBuilder.loadTexts: radSysPSEvents.setDescription('The events for RAD Packet Switch (PS) products.')
radSPS2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 1))
radSPS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 2))
radSPS6 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 3))
radSPS9 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 4))
radSPS12 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 5))
radAPD2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 6))
radAPD8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 7))
radAPS8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 8))
radAPS16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 9))
radAPS24 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 10))
radSPS3S = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 11))
radFPS8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 12))
radFPS12 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 13))
radSPS3ScSL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 14))
radSPS3Sc2S = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 15))
radFPS8c = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 16))
radFPS4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 17))
radSPS4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 18))
radSysEth = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9))
radEP8T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 1))
radEP4TAUI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 2))
radEP4T2FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 3))
radEP4TFL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 4))
radEP4FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 5))
radEPR8T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 7))
radEPR4TAUI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 8))
radEPR4T2FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 9))
radEPR4TFL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 10))
radEPR4FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 11))
radSysRtr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11))
radSysRtrEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 0))
if mibBuilder.loadTexts: radSysRtrEvents.setStatus('current')
if mibBuilder.loadTexts: radSysRtrEvents.setDescription('The events for RAD Router products.')
radRTED = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 1))
radRTEM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 2))
radRTEC = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 3))
radWebRanger = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 4))
radTinyRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 5))
radLA240 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 6))
radSuperLan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 7))
radLA240I = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 8))
radFcdIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 9))
radEFcdIp = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 10))
radFcdIpD = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 11))
radFcdIpM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 12))
radFcdIpL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 13))
radSysAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12))
radSysAtmEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0))
if mibBuilder.loadTexts: radSysAtmEvents.setStatus('current')
if mibBuilder.loadTexts: radSysAtmEvents.setDescription('The events for RAD ATM products.')
radStarSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1))
radStarSwitchATM25 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 1))
radStarSwitchATM25L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 2))
radStarSwitchATM155 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 3))
radAtmCsuDsu = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2))
radAmcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 1))
radAmcdT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 2))
radAce20E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 3))
radAce20T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 4))
radAce2005 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 5))
radAce2002 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 6))
radAce2002E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 7))
radAce2E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 8))
radAce2T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 9))
radMlAtmE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 10))
radMlAtmT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 11))
radAmc102 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 12))
radAmc102c = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 13))
radAce202 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 14))
radAce = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3))
radAce101 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 1))
radAce102 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 2))
radAce50 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 3))
radAce52 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 4))
radAce52L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 5))
radAce201 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 7))
radAce3200 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 8))
radAce3100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 9))
radAce3400 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 10))
radAce3402 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 11))
radAce3100PSN = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 12))
radAce3200PSN = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 13))
radAce3400PSN = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 14))
radAce3402PSN = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 15))
radAce3600 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 16))
radAce3205 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 17))
radAce3105 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 18))
radSysLA = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13))
radLA140 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13, 1))
radLA110 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13, 2))
radLA104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13, 3))
radLA130 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13, 4))
radLA210 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 13, 5))
radSysTerminal = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 100))
agnt = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2))
agnHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnHwVersion.setStatus('current')
if mibBuilder.loadTexts: agnHwVersion.setDescription("ASCII string for description and display of the agent hardware version, as it is known by the agent software.The user can update the version upon request when he changes components in the agent's module ")
agnTrapMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTrapMask.setStatus('current')
if mibBuilder.loadTexts: agnTrapMask.setDescription("The value of this attribute determines the type of traps the agent should mask and not send to the management console. The value is differently determined for different products. There are mainly two methods: - an integer number, specifying the traps' severity. - a sum of 2**n, where n is a bit assigned to a certain masked trap group. User should consult the product specification, to find out the method employed.")
agnTrapValue = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTrapValue.setStatus('deprecated')
if mibBuilder.loadTexts: agnTrapValue.setDescription('The value of the trap decoded in internal RAD format. Full description is given in the Trap definition file')
agnChangeCnt = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnChangeCnt.setStatus('current')
if mibBuilder.loadTexts: agnChangeCnt.setDescription('The number of changes in system configuration that were reported to the manager since last cold start')
agnSpecific = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSpecific.setStatus('current')
if mibBuilder.loadTexts: agnSpecific.setDescription(' Object identifier of entity containing additional information regarding this instance.')
agnConfigMsg = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnConfigMsg.setStatus('current')
if mibBuilder.loadTexts: agnConfigMsg.setDescription("Full configuration message coded in internal RAD application format. This entry describes agent's configuration. For MP-2200 R3, this object describes agent's support of the V5.1 feature: 1 octet ; bit 0 (LSB). '1' - V5.1 feature is supported '0' - V5.1 feature is not supported.")
mngTrapIpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 7), )
if mibBuilder.loadTexts: mngTrapIpTable.setStatus('current')
if mibBuilder.loadTexts: mngTrapIpTable.setDescription('This table indicates the destination address of the traps. Internally it will be limited to ten addresses. ')
mngEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1), ).setIndexNames((0, "RAD-MIB", "mngID"))
if mibBuilder.loadTexts: mngEntry.setStatus('current')
if mibBuilder.loadTexts: mngEntry.setDescription('An entry in table.')
mngID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mngID.setStatus('current')
if mibBuilder.loadTexts: mngID.setDescription(' This value indicates an index of a specific IP address')
mngIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIP.setStatus('current')
if mibBuilder.loadTexts: mngIP.setDescription('This value indicates the destination address of the traps. IP 0.0.0.0 removes the entry. ')
mngIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIPMask.setStatus('deprecated')
if mibBuilder.loadTexts: mngIPMask.setDescription('This value indicates the mask of the destination addresses of the traps. ')
mngTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngTrapMask.setStatus('current')
if mibBuilder.loadTexts: mngTrapMask.setDescription("The value of this attribute determines the type of traps the agent should mask and not send to this NMS. The value is differently determined for different products. There are mainly two methods: - an integer number, specifying the traps' severity. - a sum of 2**n, where n is a bit assigned to a certain masked trap group. User should consult the product specification, to find out the method employed.")
mngAlarmTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngAlarmTrapMask.setStatus('current')
if mibBuilder.loadTexts: mngAlarmTrapMask.setDescription('The value of this object determines the alarm traps that the agent should mask (not send to this manager). The value is an Octet String, where each bit is assigned to a certain trap. If the bit = 1, the trap will be masked. If the bit = 0, the trap will not be masked. For more details on the specific alarm traps masked, see product specification.')
mngSnmpTrapUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngSnmpTrapUdpPort.setStatus('current')
if mibBuilder.loadTexts: mngSnmpTrapUdpPort.setDescription('This variable enables to set the UDP port (socket) used for SNMP traps.')
agnIndication = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("faulty", 1), ("warning", 2), ("normal", 3), ("minor", 4), ("major", 5), ("event", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnIndication.setStatus('current')
if mibBuilder.loadTexts: agnIndication.setDescription('Attribute describing the state of the entity the agent is responsible for. In case of a modular entity, the value of this attribute will be according to the component which is in the worst state. The order of severity (from top to bottom) is: critical-> major (or faulty)-> minor-> event-> warning-> normal (off).')
agnMonitorModeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnMonitorModeCmd.setStatus('current')
if mibBuilder.loadTexts: agnMonitorModeCmd.setDescription('Setting this attribute to ON, will enforce the agent to change its mode of operation to Monitor Mode')
agnLed = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnLed.setStatus('current')
if mibBuilder.loadTexts: agnLed.setDescription('This entry specifies the LEDs status of the agent module . Each led will be represented by 4 bits where the first 2 bits (left) will specify the status : (00=NA, 01=OFF, 10=ON, 11=BLINK), and the next two bits (right) will specify the color : (00=GREEN, 01=RED, 10=YELLOW, 11=GRAY)')
trapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 11), )
if mibBuilder.loadTexts: trapTable.setStatus('current')
if mibBuilder.loadTexts: trapTable.setDescription("This table may include the last few traps generated by the agent, for future retrieval. The table has a limited capacity. If traps are not retrieved in proper time, they will be over-written by new traps. For other devices, it can include generic variables that will be attached to traps as 'accessible-for-notify'.")
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1), ).setIndexNames((0, "RAD-MIB", "trapID"))
if mibBuilder.loadTexts: trapEntry.setStatus('current')
if mibBuilder.loadTexts: trapEntry.setDescription('An entry in trapTable.')
trapID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapID.setStatus('current')
if mibBuilder.loadTexts: trapID.setDescription(" This object indicates an index of a specific trap. Can be used also for any trap, while trapVal is used as 'accessible-for-notify' or trapNumeric is used.")
trapVal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapVal.setStatus('current')
if mibBuilder.loadTexts: trapVal.setDescription("This object is the actual ASCII description of the trap. It can be used also as attached variable of traps, in order to detail in explicit ASCII text, data of the trap. In this case, it is used as 'accessible-for-notify'.")
trapTimeSinceOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setStatus('current')
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setDescription('This object indicates the amount of time passed since the occurrence of the event that triggered this trap. ')
trapNumeric = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 4), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: trapNumeric.setStatus('current')
if mibBuilder.loadTexts: trapNumeric.setDescription(' This object is a numeric general parameter, that can be attached to any trap. Values can be positive or negative.')
fileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 12))
fileServerIP = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileServerIP.setStatus('current')
if mibBuilder.loadTexts: fileServerIP.setDescription('The IP address of the server from which the file is loaded ')
fileName = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileName.setStatus('current')
if mibBuilder.loadTexts: fileName.setDescription('The name of the file to be loaded. For protection, read returns NULL. ')
fileTransCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("swDwnLoad", 1), ("configDwnLoad", 2), ("configUpLoad", 3), ("coProcDwnLoad", 4), ("stateUpLoad", 5), ("dwnLoadUserFile", 6), ("upLoadUserFile", 7), ("swDwnLoadAndReset", 8), ("swUpLoad", 9), ("swDwnLoad2BkupStorage", 10), ("bootDwnLoad", 11), ("bootUpLoad", 12), ("swUpLoadFromBkupStorage", 13), ("licenseDwnLoad", 14), ("configDwnLoadToDefaultFile", 15), ("noOp", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransCmd.setStatus('current')
if mibBuilder.loadTexts: fileTransCmd.setDescription('The command to be executed on fileName at fileServerIP.')
tftpRetryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpRetryTimeOut.setStatus('current')
if mibBuilder.loadTexts: tftpRetryTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
tftpTotalTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpTotalTimeOut.setStatus('current')
if mibBuilder.loadTexts: tftpTotalTimeOut.setDescription(' Total Retransmission time-out value (seconds) ')
tftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noOp", 2), ("connecting", 3), ("transferringData", 4), ("endedTimeOut", 5), ("endedOk", 6), ("error", 7))).clone('noOp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpStatus.setStatus('current')
if mibBuilder.loadTexts: tftpStatus.setDescription("Status of tftp session. When a session ended with success, the tftpStatus should be endedOk(6). Before restarting a tftp session, the NMS should set the tftpStatus to noOp(2). That's the reason of MAX-ACCESS read-write to this field.")
tftpError = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpError.setStatus('current')
if mibBuilder.loadTexts: tftpError.setDescription(' The MSB represents the standard error code. The LSB represents the private error code. 0x0000 is No Error 0x0100 is File Not Found 0x0200 is Access violation 0x0300 is Disk full or allocation exceeded 0x0400 is Illegal TFTP operation 0x0500 is Unknown transfer ID 0x0600 is File already exists 0x0700 is No such user 0x0001 is Server Overflow 0x0002 is No empty UDP port 0x0003 is No empty connection 0x0004 is Illegal File Mode 0x0007 is Illegal PDU size 0x0008 is TFTP Server does not exist 0x0009 is Incorrect File 0x000A is Wrong License format 0x000B is License ID already used ')
fileTransferToSubSystems = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferToSubSystems.setStatus('current')
if mibBuilder.loadTexts: fileTransferToSubSystems.setDescription(" This object represents the sub-systems the fileTransCmd refers to. It should be used when a system is divided to sub-systems and each sub-system (or part of them) can have a different SW/Configuration. Each bit of this object will represent one of the sub-systems. Bit='1' - APPLY to respective sub-system Bit='0' - DO NOT APPLY to respective sub-system For the meaning of each bit, see product's specification. User will select the sub-systems envolved by filling-in the bits that represent these sub-systems. In this case, the file represented by 'fileName' will include several parts, each representing one of the sub-systems. The agent will refer only to the part/s indicated by this object. 0 Octet Strings = not applicable DEFVAL = 0h for the products that support this object.")
fileNameWithinProduct = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileNameWithinProduct.setStatus('current')
if mibBuilder.loadTexts: fileNameWithinProduct.setDescription('The file name used by the product within the product file system.')
intSwdlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10), )
if mibBuilder.loadTexts: intSwdlTable.setStatus('current')
if mibBuilder.loadTexts: intSwdlTable.setDescription('This parameters table is for internal Software down load. It also includes data about all files contained in the Object from which down-load is performed.')
intSwdlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1), ).setIndexNames((0, "RAD-MIB", "intSwdlObjIdx"), (0, "RAD-MIB", "intSwdlFileIdx"))
if mibBuilder.loadTexts: intSwdlEntry.setStatus('current')
if mibBuilder.loadTexts: intSwdlEntry.setDescription('An entry in table.')
intSwdlObjIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlObjIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlObjIdx.setDescription('The index of the object from which down-load is performed.')
intSwdlFileIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileIdx.setDescription('The index of the files included in intSwdlObjIdx. One of these files can be selected to be internally downloaded.')
intSwdlFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileName.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileName.setDescription('The name of the file.')
intSwdlFileSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileSwVer.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileSwVer.setDescription('The software version of the file.')
intSwdlSwDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlSwDate.setStatus('current')
if mibBuilder.loadTexts: intSwdlSwDate.setDescription('The software version date of the file.')
intSwdlSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlSize.setStatus('current')
if mibBuilder.loadTexts: intSwdlSize.setDescription('The size of the file.')
intSwdlCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: intSwdlCmd.setStatus('current')
if mibBuilder.loadTexts: intSwdlCmd.setDescription('The command to down-load a SW file to an object. The Agent will change the value of this MIB object to off(2) automatically, after accepting the command.')
intSwdlToSubSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: intSwdlToSubSystem.setStatus('current')
if mibBuilder.loadTexts: intSwdlToSubSystem.setDescription(" This object defines the subsystem for download. Bit='1'- APPLY to respective sub system. Bit='0'- DO NOT APPLY to respective sub system. For more details see product specification. For every octet bit0=LSB, bit7=MSB")
intSwdlCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 220, 221, 222, 223, 270, 271, 272, 273, 280, 281, 282, 283, 284, 290, 300, 301, 302, 303, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349))).clone(namedValues=NamedValues(("unknown", 1), ("gstm1", 220), ("goc3", 221), ("gstm1D", 222), ("goc3D", 223), ("serverE1", 270), ("serverT1", 271), ("serverE1Pw", 272), ("serverT1Pw", 273), ("gigabitEth", 280), ("gigabitEth2", 281), ("eth2", 282), ("gigabitEth8", 283), ("eth8", 284), ("channelizedT3Pw1", 290), ("cesT128", 300), ("cesE128", 301), ("cesT1Pw28", 302), ("cesE1Pw28", 303), ("vmxE1VeDe", 310), ("vmxE1VeDi", 311), ("vmxE1ViDe", 312), ("vmxE1ViDi", 313), ("vmxT1VeDe", 314), ("vmxT1VeDi", 315), ("vmxT1ViDe", 316), ("vmxT1ViDi", 317), ("vc12E1UeNe", 318), ("vc12E1UeNi", 319), ("vc12E1UiNe", 320), ("vc12E1UiNi", 321), ("vc12T1UeNe", 322), ("vc12T1UeNi", 323), ("vc12T1UiNe", 324), ("vc12T1UiNi", 325), ("vca16E1UeNe", 326), ("vca16E1UeNi", 327), ("vca16E1UiNe", 328), ("vca16E1UiNi", 329), ("vca16T1UeNe", 330), ("vca16T1UeNi", 331), ("vca16T1UiNe", 332), ("vca16T1UiNi", 333), ("vca12E1UeNe", 334), ("vca12E1UeNi", 335), ("vca12E1UiNe", 336), ("vca12E1UiNi", 337), ("vca12T1UeNe", 338), ("vca12T1UeNi", 339), ("vca12T1UiNe", 340), ("vca12T1UiNi", 341), ("vmg16E1Ue", 342), ("vmg16E1Ui", 343), ("vmg16T1Ue", 344), ("vmg16T1Ui", 345), ("vmg12E1Ue", 346), ("vmg12E1Ui", 347), ("vmg12T1Ue", 348), ("vmg12T1Ui", 349)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlCardType.setStatus('current')
if mibBuilder.loadTexts: intSwdlCardType.setDescription('This object defines the Card type that this file is relevant for.')
intSwdlFlashIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFlashIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlFlashIdx.setDescription('The index of the flash memory this file is stored in (1 or 2) (Example: 1= The file is stored in flash No.1). ASMi52 file will always be stored in Flash No.2 (intSwdlFlashIdx=2).')
swdlStatusTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11), )
if mibBuilder.loadTexts: swdlStatusTable.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTable.setDescription('This parameters table is for software download status. It also includes data about the files down-loaded or attempted to be down-loaded.')
swdlStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1), ).setIndexNames((0, "RAD-MIB", "swdlStatusTypeIdx"), (0, "RAD-MIB", "swdlStatusIdx"))
if mibBuilder.loadTexts: swdlStatusEntry.setStatus('current')
if mibBuilder.loadTexts: swdlStatusEntry.setDescription('An entry in table.')
swdlStatusTypeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusTypeIdx.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTypeIdx.setDescription('The index of the down-load type (e.g. external (1) or internal (2)).')
swdlStatusIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusIdx.setStatus('current')
if mibBuilder.loadTexts: swdlStatusIdx.setDescription('The index of the status rows.')
swdlStatusFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusFileName.setStatus('current')
if mibBuilder.loadTexts: swdlStatusFileName.setDescription('The name of the file.')
swdlStatusSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusSlot.setStatus('current')
if mibBuilder.loadTexts: swdlStatusSlot.setDescription('The slot of the updated (or attempted to be updated) object.')
swdlStatusSubSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusSubSystem.setStatus('current')
if mibBuilder.loadTexts: swdlStatusSubSystem.setDescription('The subsystem that updated (or attempted to be updated).')
swdlStatusStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusStatus.setStatus('current')
if mibBuilder.loadTexts: swdlStatusStatus.setDescription('The status of the down load process. Value: Fail (2), OK (3), InProcess (4).')
swdlStatusTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusTime.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTime.setDescription('This MIB parameter indicates the time SW download was finished. The format shuld be YYYY-MM-DD, hh:mm:ss')
clearDwldStatusLog = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearDwldStatusLog.setStatus('current')
if mibBuilder.loadTexts: clearDwldStatusLog.setDescription('This object clears the status log. Value: off(2), external(3), internal(4) The Agent will change the value of this MIB object to off(2) automatically, after accepting the command .')
autoFileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13))
autoFileTransferTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1), )
if mibBuilder.loadTexts: autoFileTransferTable.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferTable.setDescription('Scheduling configuration table for Agent initiated file transfer.')
autoFileTransferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1), ).setIndexNames((0, "RAD-MIB", "autoFileTransferType"))
if mibBuilder.loadTexts: autoFileTransferEntry.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferEntry.setDescription('An entry in the table.')
autoFileTransferType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("alarmsBuffer", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: autoFileTransferType.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferType.setDescription('This object defines the type of file to be transferred by agent. ')
autoFileTransferServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferServerIp.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferServerIp.setDescription('This object defines the IP Address of the server to which the file is uploaded.')
autoFileTransferFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 3), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferFileName.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferFileName.setDescription('This object defines the name of the file to be uploaded.')
autoFileTransferScheduling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("now", 2), ("recurrence", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferScheduling.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferScheduling.setDescription("This object defines schedule for TFTP Automatic session(s) initiated by Agent, according to the value selected: now - initiate immediate single session. recurrence- initiate single session 'every M time units'. or 'every N occurrences' or upon both, (earliest event). Time reccurence period (M) is defined by fileTransferTimeRecurrence. Occurrence reccurence (N) is defined by fileTransferOccurrenceRecurrence. Zero value means that the object is not relevant (not taken into account for the recurrence). It is invalid that both will have zero values in our case (recurrence). When both are non zero, file is transferred upon earliest event")
autoFileTransferTimeRecurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferTimeRecurrence.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferTimeRecurrence.setDescription("This object defines time reccurence interval, e.g. M can be 'every M days', 'every M hours' etc. Zero is used to indicate there's no time reccurence (0= notApplicable). This object is taken into account only if autoFileTransferScheduling = recurrence For LA-110 time units are days.")
autoFileTransferOccurrenceRecurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferOccurrenceRecurrence.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferOccurrenceRecurrence.setDescription("This object defines Occurrence reccurence interval, e.g N can be in 'every N alarms', 'every N log entries' etc. zero is used to indicate There's no Event Reccurence. (0= notApplicable) This object is taken into account only if autoFileTransferScheduling = recurrence Occurence Type (Alarms, etc.) is according to autoFileTransferType.")
fileTransferServerPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 14), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferServerPort.setStatus('current')
if mibBuilder.loadTexts: fileTransferServerPort.setDescription('Server Port number used for File Transfer. Applicable for SFTP. Valid values: 0..65535.')
fileTransferProtocol = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("sftp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferProtocol.setStatus('current')
if mibBuilder.loadTexts: fileTransferProtocol.setDescription('File Transfer protocol used.')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("resetConfig", 4), ("resetMapping", 5), ("resetStandby", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('current')
if mibBuilder.loadTexts: systemReset.setDescription('Reset action to be performed on the system. - resetMapping - reset SDH/SONET mapping to default for all SDH/SONET links. - resetStandby(6) - can be used only by devices with redundancy on MAIN/CL.')
systemTiming = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 14))
systemDate = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDate.setStatus('current')
if mibBuilder.loadTexts: systemDate.setDescription('System date.')
systemTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemTime.setStatus('current')
if mibBuilder.loadTexts: systemTime.setDescription('System time.')
systemTimeElapsed = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: systemTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement period. Same for all ports of the device.')
systemNtp = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4))
systemNtpMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("broadcastClient", 3), ("unicastClient", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpMode.setStatus('current')
if mibBuilder.loadTexts: systemNtpMode.setDescription('This variable represents the NTP Mode.')
systemNtpGmt = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpGmt.setStatus('current')
if mibBuilder.loadTexts: systemNtpGmt.setDescription('This variable represents the NTP GMT (Greenwich Mean Time), Possible values range is -12..12. For new devices/versions this variable will be in minutes.')
systemNtpServerAddressType = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 3), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpServerAddressType.setStatus('current')
if mibBuilder.loadTexts: systemNtpServerAddressType.setDescription('This variable represents the NTP Server Address Type.')
systemNtpServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 4), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpServerAddress.setStatus('current')
if mibBuilder.loadTexts: systemNtpServerAddress.setDescription('This variable represents the NTP Server Address.')
systemNtpUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: systemNtpUpdateInterval.setDescription('This variable represents the NTP Update Interval, measured in seconds.')
systemNtpCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("sendUpdateRequest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemNtpCmd.setStatus('current')
if mibBuilder.loadTexts: systemNtpCmd.setDescription('This variable represents NTP possible commands. After the Agent accepts a command, it will automatically change the value to off(2).')
schedXTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 5), )
if mibBuilder.loadTexts: schedXTable.setStatus('current')
if mibBuilder.loadTexts: schedXTable.setDescription('An Augment to the Schedule table (schedTable in DISMAN-SCHEDULE-MIB; RFC-3231).')
schedXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 5, 1), )
schedEntry.registerAugmentions(("RAD-MIB", "schedXEntry"))
schedXEntry.setIndexNames(*schedEntry.getIndexNames())
if mibBuilder.loadTexts: schedXEntry.setStatus('current')
if mibBuilder.loadTexts: schedXEntry.setDescription('An entry in the table.')
schedYear = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 5, 1, 1), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: schedYear.setStatus('current')
if mibBuilder.loadTexts: schedYear.setDescription('The year during which the scheduled action should take place.')
schedWeekInMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("first", 1), ("second", 2), ("third", 3), ("fourth", 4), ("last", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: schedWeekInMonth.setStatus('current')
if mibBuilder.loadTexts: schedWeekInMonth.setDescription('The week in month (schedMonth) during which the scheduled action should take place.')
schedParam = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 5, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: schedParam.setStatus('current')
if mibBuilder.loadTexts: schedParam.setDescription('A Parameter that might be used whenever the scheduled action takes place. For summer-time schedule - This variable represents the time offset (in minutes), meaning: the number of minutes that should be added for summer-time.')
systemPort = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15))
physicalConnectorTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1), )
if mibBuilder.loadTexts: physicalConnectorTable.setStatus('current')
if mibBuilder.loadTexts: physicalConnectorTable.setDescription('This table includes the connector type of ports or interfaces.')
physicalConnectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1), ).setIndexNames((0, "RAD-MIB", "portIdx"))
if mibBuilder.loadTexts: physicalConnectorEntry.setStatus('current')
if mibBuilder.loadTexts: physicalConnectorEntry.setDescription('An entry in table.')
portIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIdx.setStatus('current')
if mibBuilder.loadTexts: portIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
physicalConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 255))).clone(namedValues=NamedValues(("other", 1), ("v35", 2), ("rs530", 3), ("x21", 4), ("bnc", 5), ("utp", 6), ("aui", 7), ("rs422", 8), ("crossUtp", 9), ("rj45", 10), ("v24", 11), ("g703", 12), ("termBlock3AndRj45", 13), ("terminalBlock3", 14), ("terminalBlock5", 15), ("terminalBlock7", 16), ("db25", 17), ("db15", 18), ("rj45ethernet", 19), ("termBlock5AndRj45", 20), ("db9", 21), ("g703E1", 22), ("g703E1-LTU", 23), ("sc", 24), ("st", 25), ("stl", 26), ("fc", 27), ("tb5w", 28), ("termBlock6AndRj45", 29), ("ethBnc", 30), ("scsi26", 31), ("eth4381", 32), ("twoBnc", 33), ("scsi50", 34), ("twoMiniBnc", 35), ("sf1", 36), ("terminalBlock4", 37), ("sf2", 38), ("db25Balanced", 39), ("v36", 40), ("block4W", 41), ("iripRj45", 42), ("irEthQRj45", 43), ("iripBnc", 44), ("rs530WA", 45), ("v35WA", 46), ("irEthQBnc", 47), ("v35Db25", 48), ("rj11", 49), ("mtrj", 50), ("lc", 51), ("terminalBlock2", 52), ("irEth10s100", 53), ("scsi68", 54), ("sf3", 55), ("fcLH", 56), ("telco50", 57), ("telco64", 58), ("irEthQN", 59), ("terminalBlock6", 60), ("scLH", 61), ("stLH", 62), ("lcLH", 63), ("sfpIn", 64), ("sfpOut", 65), ("db44", 66), ("db62", 67), ("v24Db9", 68), ("scsi40", 69), ("sf1NineRow", 70), ("sf2NineRow", 71), ("sf3NineRow", 72), ("smartSerial26", 73), ("miniUsb5", 74), ("db26", 75), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalConnector.setStatus('current')
if mibBuilder.loadTexts: physicalConnector.setDescription('The connector of the port/interface. other - none of the specified connectors none - no connector.')
portOptWaveLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notApplicable", 1), ("nm850", 2), ("nm1310", 3), ("nm1310Laser", 4), ("nm1550Laser", 5), ("nm1470Laser", 6), ("nm1490Laser", 7), ("nm1510Laser", 8), ("nm1530Laser", 9), ("nm1570Laser", 10), ("nm1590Laser", 11), ("nm1610Laser", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOptWaveLength.setStatus('current')
if mibBuilder.loadTexts: portOptWaveLength.setDescription('Wave Length of an Optical interface/port in [nm] and specification if Laser or not. notApplicable - for non-optical ports.')
portOptMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("singleMode", 2), ("multiMode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOptMode.setStatus('current')
if mibBuilder.loadTexts: portOptMode.setDescription('Laser Mode of an Optical Laser interface/port. notApplicable - for non-Laser ports.')
portBalance = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unbalanced", 2), ("balanced", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBalance.setStatus('current')
if mibBuilder.loadTexts: portBalance.setDescription('This object is according to the port Impedance. For T1 - always balanced. For E1 - there are different impedance values for balanced and unbalanced.')
portDdmSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDdmSupport.setStatus('current')
if mibBuilder.loadTexts: portDdmSupport.setDescription('SFP (Small Form Pluggable) port -support Digital Diagnostics Monitoring.')
portMfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMfgName.setStatus('current')
if mibBuilder.loadTexts: portMfgName.setDescription('(SFP) Port Manufacturer name (Maximum - 16 characters).')
portTypicalMaxRange = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTypicalMaxRange.setStatus('current')
if mibBuilder.loadTexts: portTypicalMaxRange.setDescription('Maximum range supported by SFP port, in meter units.')
physicalConnectorString = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalConnectorString.setStatus('current')
if mibBuilder.loadTexts: physicalConnectorString.setDescription('(SFP) connector type. It can be Vendor Specific (unknown in advance). Being a string, the object is not affected by any future new connectors. This object will usually not be used for drawing the connector.')
portVendorPartNo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVendorPartNo.setStatus('current')
if mibBuilder.loadTexts: portVendorPartNo.setDescription('SFP Vendor Part Number. Being a string, the object is not affected by any future new SFPs.')
prtSupervisory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2))
prtSpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1), )
if mibBuilder.loadTexts: prtSpTable.setStatus('current')
if mibBuilder.loadTexts: prtSpTable.setDescription('A table.')
prtSpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtSupervisoryIndex"))
if mibBuilder.loadTexts: prtSpEntry.setStatus('current')
if mibBuilder.loadTexts: prtSpEntry.setDescription('Supervisory port parameter table.')
prtSupervisoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSupervisoryIndex.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryIndex.setDescription("The SP port index. For some products, having modules (cards): The LS byte of the integer is the port index 1..255. The MS byte is different than 0 only if the port belongs to a module. In that case it is the module number. For other products' index see their specification.")
prtSupervisoryRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("auto", 1), ("s300bps", 2), ("s1200bps", 3), ("s2400bps", 4), ("s4800bps", 5), ("s9600bps", 6), ("s19200bps", 7), ("s38400bps", 8), ("s57600bps", 9), ("s115200bps", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryRate.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryRate.setDescription('This attribute indicates the operation rate (speed) of the port. auto - automatic rate selection, by the agent.')
prtSupervisoryDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7", 1), ("dataBits8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDataBits.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryDataBits.setDescription('This attribute indicates the number of data bits in an async frame')
prtSupervisoryParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryParity.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryParity.setDescription('This attribute indicates the parity mode in an async frame')
prtSupervisoryStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("stopBits1", 2), ("stopBits1dot5", 3), ("stopBits2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryStopBits.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryStopBits.setDescription('This attribute indicates the parity mode in an async frame.')
prtSupervisoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("terminal", 3), ("nmsSlip", 4), ("nmsPpp", 5), ("muxSlip", 6), ("muxPpp", 7), ("dialOut", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryUsage.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryUsage.setDescription('This attribute indicates the usage of the SP port.')
prtSupervisoryInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("dce", 2), ("dte", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryInterface.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryInterface.setDescription('This attribute indicates the supervisory port interface.')
prtSupervisoryCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3), ("dteWait", 4), ("dteIgnore", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryCTS.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryCTS.setDescription('CTS line state.')
prtSupervisoryDcdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("d0", 2), ("d10", 3), ("d50", 4), ("d100", 5), ("d200", 6), ("d300", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDcdDelay.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryDcdDelay.setDescription('DCD delay in msec.')
prtSupervisoryDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("dtr", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDSR.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryDSR.setDescription('DSR line state.')
prtSupervisoryRoutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryRoutProtocol.setStatus('current')
if mibBuilder.loadTexts: prtSupervisoryRoutProtocol.setDescription('This attribute indicates the routing protocol of the port. notApplicable - for DP.')
prtPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3))
prtPerfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1), )
if mibBuilder.loadTexts: prtPerfTable.setStatus('current')
if mibBuilder.loadTexts: prtPerfTable.setDescription('This table includes G.826 ports or interfaces.')
prtPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtPerfIdx"), (0, "RAD-MIB", "prtPerfPeriodRef"))
if mibBuilder.loadTexts: prtPerfEntry.setStatus('current')
if mibBuilder.loadTexts: prtPerfEntry.setDescription('An entry in table.')
prtPerfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfIdx.setStatus('current')
if mibBuilder.loadTexts: prtPerfIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
prtPerfPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfPeriodRef.setStatus('current')
if mibBuilder.loadTexts: prtPerfPeriodRef.setDescription('This object is an index that specifies which period of time, the next 5 objects refer to. currentPeriod - the period since last prtPerfSaveAndResetCmd received or since Start-up (if no prtPerfSaveAndResetCmd was received since Start-up) until now. lastPeriod - the period between last two commands of prtPerfSaveAndResetCmd. - If only one command occured since Start-up: the period between Start-up and last command. - If no command occured since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
prtPerfElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfElapsedTime.setStatus('current')
if mibBuilder.loadTexts: prtPerfElapsedTime.setDescription('Elapsed Time in seconds. - for prtPerfPeriodRef=currentPeriod: The period since last prtPerfSaveAndResetCmd received or since Start-up (if no prtPerfSaveAndResetCmd was received since Start-up) until now. - for prtPerfPeriodRef=lastPeriod: The value of prtPerfElapsedTime when last prtPerfSaveAndResetCmd was received.')
prtPerfUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfUAS.setStatus('current')
if mibBuilder.loadTexts: prtPerfUAS.setDescription('Number of Unavailable Seconds for the reference period (prtPerfPeriodRef).')
prtPerfES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfES.setStatus('current')
if mibBuilder.loadTexts: prtPerfES.setDescription('Number of Errored Seconds for the reference period (prtPerfPeriodRef).')
prtPerfSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfSES.setStatus('current')
if mibBuilder.loadTexts: prtPerfSES.setDescription('Number of Severely Errored Seconds for the reference period (prtPerfPeriodRef).')
prtPerfBBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfBBE.setStatus('current')
if mibBuilder.loadTexts: prtPerfBBE.setDescription('Number of Background Block (or Frame) Errors for the reference period (prtPerfPeriodRef).')
prtPerfBlocksPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfBlocksPerSec.setStatus('current')
if mibBuilder.loadTexts: prtPerfBlocksPerSec.setDescription('Blocks per second (or frames per second) of the port/interface indicated by portIdx. This object is constant for a certain port/interface. It is not affected by the prtPerfPeriodRef index.')
prtPerfTimeTag = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfTimeTag.setStatus('current')
if mibBuilder.loadTexts: prtPerfTimeTag.setDescription('Time Tag of Last Period: sysUpTime when last prtPerfSaveAndResetCmd was executed. This object is applicable only for prtPerfPeriodRef=lastPeriod. For prtPerfPeriodRef=currentPeriod, the value will always be 0.')
prtPerfSaveAndResetCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPerfSaveAndResetCmd.setStatus('current')
if mibBuilder.loadTexts: prtPerfSaveAndResetCmd.setDescription('A command per port/interface, to Save data of Current Period in Last Period data-set and start a new counting period for Current Period. This object is applicable only for prtPerfPeriodRef=currentPeriod. Setting this object to on(3) for prtPerfPeriodRef=last, will cause the agent to return: Bad Value response. When setting validly this object to on(3), agent will perform the required command and will reset automatically the value of this object to off(2). Setting this object to off(2), will do nothing.')
prtTest = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4))
prtTestTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1), )
if mibBuilder.loadTexts: prtTestTable.setStatus('current')
if mibBuilder.loadTexts: prtTestTable.setDescription('This table includes test data for ports or interfaces.')
prtTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtTestIdx"))
if mibBuilder.loadTexts: prtTestEntry.setStatus('current')
if mibBuilder.loadTexts: prtTestEntry.setDescription('An entry in table.')
prtTestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestIdx.setStatus('current')
if mibBuilder.loadTexts: prtTestIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
prtTestCmdAndStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestCmdAndStatus.setStatus('current')
if mibBuilder.loadTexts: prtTestCmdAndStatus.setDescription("Setting this object to a value as detailed further on (except 0) will initiate a test on the specific port. The test/s requested will be set according to the respective bit. The value of this object will be a sum of (2**n), where n is the Bit: TEST BIT VALUE ----------- --- ------ reserved 0 1 PayloadLoop=RLB 1 (=Remote Loopback) 2 LineLoop=DIG 2 (=Digital) 4 OtherLoop 3 8 InwardLoop=LLB 4 (=Local Loopback) 16 BERT 5 32 LC 6 64 ToneInjection 7 128 Inband 8 256 BERT Remote (or E1/T1 RLB) 9 512 Downstream-AIS (or E1/T1 LLB) 10 1024 Upstream-AIS 11 2048 Rem-Loop-on-Rem-Unit 12 4096 MacSwapLoop 13 8192 OamETHLoopback 14 16384 OamETHLinkTrace 15 32768 e.g : If the requested value is 20 -> 010100 -> Bits 2 & 4 are set -> the requested tests are : LineLoopback=DIG InwardLoopback=LLB Not all tests combinations are valid. For valid test combination, see each product's specification. For LRS52, only single test is allowed simultaneously The terminology and order of the first tests (except BERT) is according to the one used for Test Status of DS1 and DS3 standards. The notations : RLB, LLB, DIG are the most used in RAD's products, but they can be different. For exact definition see product's spec. Setting this object to stop (value=0 ; all bits are 0), will stop all the user requested tests running on the selected port. When no test is running on the port, the Get value (test status) will be 0. PayloadLoop=RLB The received signal at this interface is looped through the device. Typically the received signal is looped back for retransmission after it has passed through the device's framing function. LineLoop=DIG The received signal at this interface does not go through the device (minimum penetration) but is looped back out. OtherLoop Loopbacks that are not defined here. InwardLoop=LLB The sent signal at this interface is looped back through the device. LC This loop is applicable only for HSSI interface, towards the router . ToneInjection This loop is applicable for analog voice (like FXS). Downstream-AIS E1 AIS signal (all ones) is transmitted in the relevant channel toward the STM-1 line. Upstream-AIS E1 AIS signal (all ones) is generated in the relevant channel toward the local received tributary channel output Rem-Loop-on-Rem-Unit Request from far end device to activate remote loopback towards near-end device MacSwapLoop This loop is applicable for ethernet port. Loop is implemented by swapping the MAC addresses of the incoming message. OamETHLoopback Ethernet Loopback is used to verify connectivity of a MEP with a MIP or peer MEP(s) (ITU-T Y.1731, Clause 7.2). OamETHLinkTrace Ethernet Link Trace is an on-demand OAM function which can be used for the two following purposes: - Adjacent Relation Retrieval - Fault Localization (ITU-T Y.1731, Clause 7.3).")
prtBertCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertCounter.setStatus('current')
if mibBuilder.loadTexts: prtBertCounter.setDescription('This object indicates the number of BERT errors encountered during the BERT operation. It is valid only when BERT (Bit Error Rate Test) is active on the specific port. The Counter starts from zero (0) anytime BERT is initiated.')
prtTestInitiator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("user", 2), ("remoteUnit", 3), ("dteRouter", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestInitiator.setStatus('current')
if mibBuilder.loadTexts: prtTestInitiator.setDescription("This object indicates who initiated this port's test/s.")
prtTestTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestTimeout.setStatus('current')
if mibBuilder.loadTexts: prtTestTimeout.setDescription('This object is applicable only when a single test is running. It indicates the test activation timeout in minutes. For RICi-E1T1, RICi-E3T3 the measurement unit is in seconds. When the timeout expires, the test is stopped. Value of 0 indicates test may run Forever ')
prtTestVctRxResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("fail", 2), ("normal", 3), ("open", 4), ("short", 5), ("shortToCrossPair", 6), ("coupleWithCrossPair", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctRxResult.setStatus('current')
if mibBuilder.loadTexts: prtTestVctRxResult.setDescription('This object indicates the result of the Vct on the cable connected to the RX connector.')
prtTestVctTxResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("fail", 2), ("normal", 3), ("open", 4), ("short", 5), ("shortToCrossPair", 6), ("coupleWithCrossPair", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctTxResult.setStatus('current')
if mibBuilder.loadTexts: prtTestVctTxResult.setDescription('This object indicates the result of the Vct on the cable connected to the TX connector.')
prtTestVctRxDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctRxDistance.setStatus('current')
if mibBuilder.loadTexts: prtTestVctRxDistance.setDescription('This object indicates the distance in Meters to the RX cable Open/ Short location discovered by the Vct. This parameter is applicable for Vct Result = Normal or Fail only, Else the value of this parameter will be equal to 0.')
prtTestVctTxDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctTxDistance.setStatus('current')
if mibBuilder.loadTexts: prtTestVctTxDistance.setDescription('This object indicates the distance in Meters to the TX cable Open/ Short location discovered by the Vct. This parameter is applicable for Vct Result = Normal or Fail only, Else the value of this parameter will be equal to 0.')
prtTestVctCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestVctCmd.setStatus('current')
if mibBuilder.loadTexts: prtTestVctCmd.setDescription('Vct command. on (3) = Start Vct on both cables connected to RX and TX connectors of this port. Agent will perform the required command and change automatically the value of this object to off(2).')
prtTestVctRxCrossPair = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctRxCrossPair.setStatus('current')
if mibBuilder.loadTexts: prtTestVctRxCrossPair.setDescription('This object should be equal to the Index (prtTestIdx) of the Rx cross pair. This object is applicable only for Vct Result = shortToCrossPair or coupleWithCrossPair. This object was especially created for ETX-202. Currently not in use.')
prtTestVctTxCrossPair = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestVctTxCrossPair.setStatus('current')
if mibBuilder.loadTexts: prtTestVctTxCrossPair.setDescription('This object should be equal to the Index (prtTestIdx) of the Tx cross pair. This object is applicable only for Vct Result = shortToCrossPair or coupleWithCrossPair.')
prtTestActivationDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 13), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestActivationDelay.setStatus('current')
if mibBuilder.loadTexts: prtTestActivationDelay.setDescription('This object is applicable only when a single test is running. It indicates test activation delay in seconds. A Value of 0 indicates that the test starts immediately.')
prtTestMacSwapLoopDataMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("allExceptMng", 2), ("specificVlan", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestMacSwapLoopDataMode.setStatus('current')
if mibBuilder.loadTexts: prtTestMacSwapLoopDataMode.setDescription('This object defines which part of the data will be looped back.')
prtTestMacSwapLoopVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestMacSwapLoopVlanId.setStatus('current')
if mibBuilder.loadTexts: prtTestMacSwapLoopVlanId.setDescription('This object specifies the VLAN ID for prtTestMacSwapLoopDataMode=specificVlan.')
prtTestMacSwapLoopDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestMacSwapLoopDirection.setStatus('current')
if mibBuilder.loadTexts: prtTestMacSwapLoopDirection.setDescription("This object defines the direction of the performed loopback. In ETX102 'local' corresponds to Ingress loop (either on User port or on Network port), and 'remote' corresponds to Egress loop (either on User port or on Network port).")
prtTestMacSwapLoopDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 17), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestMacSwapLoopDestAddr.setStatus('current')
if mibBuilder.loadTexts: prtTestMacSwapLoopDestAddr.setDescription('Configures the MAC address that will be sent in the Destination field of the packet in the outgoing direction. ')
prtTestMacSwapLoopSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 18), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestMacSwapLoopSrcAddr.setStatus('current')
if mibBuilder.loadTexts: prtTestMacSwapLoopSrcAddr.setDescription('Configures the MAC address that will be sent in the Source field of the packet in the outgoing direction. ')
prtTestOamMinRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestOamMinRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: prtTestOamMinRoundTripDelay.setDescription('The mininal value of round trip delay of loopback message for a session of OAM loopback.Units are msec.')
prtTestOamMaxRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestOamMaxRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: prtTestOamMaxRoundTripDelay.setDescription('The maximum value of round trip delay of loopback message for a session of OAM loopback.Units are msec.')
prtTestOamAvgRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestOamAvgRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: prtTestOamAvgRoundTripDelay.setDescription('The average round trip delay of loopback message for a session of OAM loopback.Units are msec.')
prtTestOamTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 22), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestOamTxInterval.setStatus('current')
if mibBuilder.loadTexts: prtTestOamTxInterval.setDescription('Indicates the interval between loopback sent messages.Units are msec.')
prtTestDestinationIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestDestinationIpAddress.setStatus('current')
if mibBuilder.loadTexts: prtTestDestinationIpAddress.setDescription('Indicates the destination IP Address in the transmitted messages that are looped back.')
prtTestTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 24), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestTTL.setStatus('current')
if mibBuilder.loadTexts: prtTestTTL.setDescription('Time-to-live.Number of hops the loopback message will go through the net before deciding to discard it.')
prtTestBwProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 25), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestBwProfile.setStatus('current')
if mibBuilder.loadTexts: prtTestBwProfile.setDescription('Indicates the BW profile (from bwProfileTable) that is assigned to the loopback test in order to limit the traffic that is looped back.')
prtParam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5))
prtParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1), )
if mibBuilder.loadTexts: prtParamTable.setStatus('current')
if mibBuilder.loadTexts: prtParamTable.setDescription('This table includes general port parameters. The meaning is different for every product that supports it due to a general parameter - prtControlCnfg. For ACE2002: -This table is used as a mechanism to create the next interface index. The algorithm description: The NMS will send the agent the following get command: get(nextIfIndex.index), where index=interface on which the new index is dependent on. Upon this command the agent will generate and return the new index to the NMS. - This table is partially supported according to the interface type. Upon getNext function the irrelevant parameters will be skipped.')
prtParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtParamIdx"))
if mibBuilder.loadTexts: prtParamEntry.setStatus('current')
if mibBuilder.loadTexts: prtParamEntry.setDescription('An entry in table.')
prtParamIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamIdx.setStatus('current')
if mibBuilder.loadTexts: prtParamIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used. For ACE2002: This parameter is the physical layer ifIndex of the slot on which the NMS requires the next interface index.')
prtControlCnfg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtControlCnfg.setStatus('current')
if mibBuilder.loadTexts: prtControlCnfg.setDescription("This object may be used for port RW general parameter/s. For detailed meaning, see product's spec. Supported by: PRBi-E3/T3. For ACE2002: This parameter will include the value of the new index generated by agent. For Optimux-T3 and OP-155-1: This parameter will be used for Release Remote LLB Command: on=2= Set value only. Command to release LLB of Remote Unit. Agent will return automatically to 'off' value after performing the command. off=3=Get value only. For LA140 This parameter will be used as EchoCanceler per timeslot off = 2 Echo Canceler is disabled on = 3 Echo Canceler is enabled For FCD-155 This parameter will be used to select the port that is clock source for a PDH port, For E1/T1 PDH VC12/VT1.5 = 2 SDH/SONET = 3 For E3/T3 PDH VC3/DS3 = 2 SDH/SONET = 3 For ACE-52 This parameter will be used as Transmit Frame Type, i.e. which type of frame the corresponding bridge port will transmit: Untagged = 2 Tagged = 3 .")
prtParamClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2), ("throughTiming", 3), ("adaptive", 4), ("master", 5), ("fallback", 6), ("station", 7), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamClkSrc.setStatus('current')
if mibBuilder.loadTexts: prtParamClkSrc.setDescription("The source of Transmit Clock. 'loopTiming' or 'loopback' indicates that the recovered receive clock is used as the transmit clock. 'localTiming' or 'internal' indicates that a local clock source is used or when an external clock is attached to the box containing the interface. 'throughTiming' or 'external' indicates that recovered receive clock from another card or interface is used as the transmit clock. 'adaptive' indicates that the clock is recovered according to the received data flow rate. 'master' and 'fallback' values may be used RO to indicate active clock. 'station' - indicate clock received from station port is used as transmit clock.")
prtParamPhantom = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamPhantom.setStatus('current')
if mibBuilder.loadTexts: prtParamPhantom.setDescription('Power feeding to another device.')
prtParamResetStatsCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamResetStatsCmd.setStatus('current')
if mibBuilder.loadTexts: prtParamResetStatsCmd.setDescription('Reset statistics of the selected port.')
prtParamLastResetStatsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamLastResetStatsTime.setStatus('current')
if mibBuilder.loadTexts: prtParamLastResetStatsTime.setDescription("The value of MIB II's sysUpTime object at the last time that prtParamResetStatsCmd was Set to on(3) for this port. If prtParamResetStatsCmd was never Set to on(3) since last re-initialization of the agent, then this object contains a zero value. This object enables calculating the running time of Statistics counters for this port, by: [sysUpTime-prtParamLastResetStatsTime]. For some devices other types of 'Reset' may affect this parameter")
prtParamInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("notApplicable", 1), ("e1", 2), ("t1", 3), ("fr", 4), ("hdlc", 5), ("hdsl2", 6), ("shdsl", 7), ("adsl", 8), ("adsl2", 9), ("reAdsl2", 10), ("mPair", 11), ("efm", 12), ("atmIma", 13), ("ds1", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamInterfaceType.setStatus('current')
if mibBuilder.loadTexts: prtParamInterfaceType.setDescription('The type of the port.')
prtParamClearAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamClearAlarm.setStatus('current')
if mibBuilder.loadTexts: prtParamClearAlarm.setDescription('Setting this attribute to ON, will enforce a clear operation on the Port Alarms. Upon completion, the value will automatically change to off(2).')
prtParamLeds = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamLeds.setStatus('current')
if mibBuilder.loadTexts: prtParamLeds.setDescription('This entry specifies the LEDs status of the port. Each led is represented by 4 bits where the first 2 bits (left) specify the status : (00=NA, 01=OFF, 10=ON, 11=BLINK), and the next two bits (right) specify the color : (00=GREEN, 01=RED, 10=YELLOW, 11=GRAY). The order of the LEDS is from top to bottom, left to right: For each row starting from the top, the LEDS are returned from left to right.')
prtParamLineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("long", 2), ("normal", 3), ("short", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamLineLength.setStatus('current')
if mibBuilder.loadTexts: prtParamLineLength.setDescription('Line Length of the line connected to this port.')
prtParamUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("user", 2), ("network", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamUsage.setStatus('current')
if mibBuilder.loadTexts: prtParamUsage.setDescription('Defines whether this port works as User port or as Network port.')
prtParamMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("auto", 3), ("manual", 4), ("adjacent", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamMappingMode.setStatus('current')
if mibBuilder.loadTexts: prtParamMappingMode.setDescription('This object defines path protection on SONET/SDH link Auto - SONET/SDH mapping for port is copied automatically to same TU on the redundant SONET/SDH local (reside on same slot) link by agent. Manual - the user can configure the redundant mapping for port on the same link or to the other link on any TU Adjacent - similar to auto, but mapping is copied automatically by agent to link on adjacent slot .')
prtParamAlarmIndication = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamAlarmIndication.setStatus('current')
if mibBuilder.loadTexts: prtParamAlarmIndication.setDescription("This object indicates status-aggregation of non-masked alarms associated with all interface layers, related to this physical port. When at least one non-masked alarm exists on any layer, value of this object is on (3). Indication will be off (2) only when there's no active non-masked alarm on any interface layer related to this port. Masking an Alarm, will consider it as not exist for this indication. Example: When a port has an ATM higher layer and at least one VC has alarm, value of this object will be on (3)")
prtParamClkQualityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamClkQualityLevel.setStatus('current')
if mibBuilder.loadTexts: prtParamClkQualityLevel.setDescription("This parameter indicates quality level of clock signal. Quality is encoded according to SSM (Synchronization Status Messages) encoding. Bits 8 -5 of byte are encoded as follows (when bit1=0): Left most bit - MSB(8) ---> LSB(5) 8765 0000 Quality Unknown 0010 PRC (Primary Reference Clock) - Rec. G.811 0100 SSU-T (Sync. Source Unit-Transit)- Rec. G.812 Transit 1000 SSU-L (Sync. Source Unit Local) - Rec. G.812 Local 1011 SEC (SDH Equipment Clock) 1111 DNU (do not use for synchronization) 0001 PRS (=ST1 = Stratum 1 Traceable) 0111 ST2 (Stratum 2 Traceable) 1010 ST3 (Stratum 3 Traceable) 1100 SMC (SONET Minimum Clock Traceable) 1101 Stratum 3E Traceable bit1 = '1' - indicates all octet is Not Applicable")
prtParamClkWaveShape = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("sine", 2), ("square", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamClkWaveShape.setStatus('current')
if mibBuilder.loadTexts: prtParamClkWaveShape.setDescription('Wave shape of station clock source signal.')
prtParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("up", 2), ("signalLoss", 3), ("syncLoss", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamStatus.setStatus('current')
if mibBuilder.loadTexts: prtParamStatus.setDescription('Station clock source Status.')
prtParamSignalLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamSignalLevel.setStatus('current')
if mibBuilder.loadTexts: prtParamSignalLevel.setDescription('This object indicates signal level (in thenth of dB units) on selected port.')
prtParamClkUserQualityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamClkUserQualityLevel.setStatus('current')
if mibBuilder.loadTexts: prtParamClkUserQualityLevel.setDescription('This parameter allows user to mark quality level of clock. Quality is encoded according to SSM (Synchronization Status Messages) encoding. Bits 8 -5 of byte are encoded as follows: Left most bit - MSB(8) ---> LSB(5) 8765 0000 Quality Unknown 0010 PRC (Primary Reference Clock) - Rec. G.811 0100 SSU-T (Sync. Source Unit-Transit) Rec. G.812 Transit 1000 SSU-L (Sync. Source Unit Local) - Rec. G.812 Local 1011 SEC (SDH Equipment Clock) 1111 DNU (do not use for synchronization)')
prtParamDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 19), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamDataRate.setStatus('current')
if mibBuilder.loadTexts: prtParamDataRate.setDescription('Rate of serial data port (V.11, V.24, V.35) in kbps units.')
prtParamLoopDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamLoopDetect.setStatus('current')
if mibBuilder.loadTexts: prtParamLoopDetect.setDescription('Enable/disable Loop Detection on a port. Examples of ports: physical, Channelized Bundle over TDM Uplink, Bridge Ports.')
prtParamActUponLoopDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamActUponLoopDetect.setStatus('current')
if mibBuilder.loadTexts: prtParamActUponLoopDetect.setDescription("This parameter is used to indicate which actions should be taken in case a loop is detected in the network the port is part of. Each action is represented by a bit. Currently defined (for RIC155GE/RIC622GE): Bit 0 - Transmit Shut Down Bit 1 - Forward Alarms If bit value = '1' then the action is taken. If bit value = '0' then the actions is not taken.")
prtParamPSNLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("l2", 2), ("l3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamPSNLayer.setStatus('current')
if mibBuilder.loadTexts: prtParamPSNLayer.setDescription('This object indicates the network layer from which clock is derived.')
prtParamRxSsm = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("rx", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamRxSsm.setStatus('current')
if mibBuilder.loadTexts: prtParamRxSsm.setDescription('This object indicates if Station Clock SSM messages received will serve as criteria for clock selection.')
prtParamClkSsmRxSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sa4", 2), ("sa5", 3), ("sa6", 4), ("sa7", 5), ("sa8", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamClkSsmRxSource.setStatus('current')
if mibBuilder.loadTexts: prtParamClkSsmRxSource.setDescription('This object indicates the Sa-bit of the E1 frame, in which SSM messages are carried.')
prtParamFarEndDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 26), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamFarEndDevice.setStatus('current')
if mibBuilder.loadTexts: prtParamFarEndDevice.setDescription('Programmed Far-End device connected to this port. This object is relevant for products having multiple DBs. It will enable configuring offline, the relevant data. For MP-4100, LRS-102 OP-108/106 cards, the options will be: 1 = None (when a port is not connected to any remote device) 2 = OP-108 3 = OP-108/ETH 4 = OP-106 5 = OP-106/ETH 6 = card of MP or LRS-102')
prtParamTxClk = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtParamTxClk.setStatus('current')
if mibBuilder.loadTexts: prtParamTxClk.setDescription('enable/disable station clock signal output.')
prtIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6))
prtIpParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1), )
if mibBuilder.loadTexts: prtIpParamTable.setStatus('current')
if mibBuilder.loadTexts: prtIpParamTable.setDescription('A table - Parameters for IP Ports.')
prtIpParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtIpParamConfigIdx"), (0, "RAD-MIB", "prtIpParamSlotIdx"), (0, "RAD-MIB", "prtIpParamIdx"))
if mibBuilder.loadTexts: prtIpParamEntry.setStatus('current')
if mibBuilder.loadTexts: prtIpParamEntry.setDescription('An entry in table.')
prtIpParamConfigIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamConfigIdx.setStatus('current')
if mibBuilder.loadTexts: prtIpParamConfigIdx.setDescription('This object indicates the Configuration number (1..255) referred. Value of 255 specifies the TmpCnfg (Scratch). For products having Agent and Edit configurations, Write operation for the table entries is allowed only to Config=255.')
prtIpParamSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamSlotIdx.setStatus('current')
if mibBuilder.loadTexts: prtIpParamSlotIdx.setDescription("This object indicates a unique number of the slot position in which the module is inserted. notApplicable = 255 (for products that don't have slots). For KM: kmxMlA (103), kmxMlB (104).")
prtIpParamIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamIdx.setStatus('current')
if mibBuilder.loadTexts: prtIpParamIdx.setDescription('This object indicates a unique Port Index.')
prtIpParamHostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamHostIP.setStatus('current')
if mibBuilder.loadTexts: prtIpParamHostIP.setDescription('The host interface IP address.')
prtIpParamHostMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamHostMask.setStatus('current')
if mibBuilder.loadTexts: prtIpParamHostMask.setDescription('The host interface subnet mask.')
prtIpParamDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: prtIpParamDefaultGateway.setDescription("Default Gateway's IP Address.")
prtIpParamMediaMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("halfDuplex", 2), ("fullDuplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamMediaMode.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMediaMode.setDescription('This object indicates the real Media Mode.')
prtIpParamMediaRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("r10Mbps", 2), ("r100Mbps", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamMediaRate.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMediaRate.setDescription('This object indicates the real Media Rate (Mbps).')
prtIpParamMngVlanSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamMngVlanSupport.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMngVlanSupport.setDescription('Management VLAN support (Tagging). no - No support of VLAN Tagging. yes - 4 VLAN bytes will be added to the frame.')
prtIpParamMngVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamMngVlanId.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMngVlanId.setDescription('Management VLAN ID.')
prtIpParamMngVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamMngVlanPriority.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMngVlanPriority.setDescription('Management VLAN Frame priority.')
prtIpParamRingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamRingMode.setStatus('current')
if mibBuilder.loadTexts: prtIpParamRingMode.setDescription('This object indicates If Ring Mode is enabled or not.')
prtIpParamProtIpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamProtIpEnable.setStatus('current')
if mibBuilder.loadTexts: prtIpParamProtIpEnable.setDescription('This object indicates whether a list of Protected IP Addresses is enabled or not. This object is applicable only if prtIpParamRingMode=enable.')
prtIpParamTrafficPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamTrafficPriority.setStatus('current')
if mibBuilder.loadTexts: prtIpParamTrafficPriority.setDescription('This object indicates the traffic priority of this port.')
prtIpParamRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamRemoteIP.setStatus('current')
if mibBuilder.loadTexts: prtIpParamRemoteIP.setDescription('This is the IP Address of the remote device that is connected to the current device (Point to Point Application). It is used for sending OAM packets on the LAN to the remote side in order to check that the connection is OK.')
prtIpParamMaxTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("full", 2), ("e1", 3), ("t1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamMaxTxBandwidth.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMaxTxBandwidth.setDescription('This object shows the Max Bandwidth allowed on the LAN. Full - means that a Maximum of 100 Mega Byte Rate may go through the LAN. e1(3) means that the maximum is an E1 rate. t1(4) is for a maximum of a T1 rate.')
prtIpParamTos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamTos.setStatus('current')
if mibBuilder.loadTexts: prtIpParamTos.setDescription('TOS = Type of Service transmitted. Valid values: 0..255.')
prtIpParamConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamConnect.setStatus('current')
if mibBuilder.loadTexts: prtIpParamConnect.setDescription('Port Connection.')
prtIpParamAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamAgingTime.setStatus('current')
if mibBuilder.loadTexts: prtIpParamAgingTime.setDescription('Aging Time in seconds.')
prtIpParamEncapsulationProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("tcp", 2), ("udp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamEncapsulationProt.setStatus('current')
if mibBuilder.loadTexts: prtIpParamEncapsulationProt.setDescription('Encapsulation Protocol.')
prtIpParamEncapProtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamEncapProtPort.setStatus('current')
if mibBuilder.loadTexts: prtIpParamEncapProtPort.setDescription('Encapsulation Protocol Port (TCP/UDP Port).')
prtIpParamVlanSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamVlanSupport.setStatus('current')
if mibBuilder.loadTexts: prtIpParamVlanSupport.setDescription("VLAN support (Tagging). 'no' - No support of VLAN Tagging. 'yes' - 4 VLAN bytes will be added to the frame.")
prtIpParamVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamVlanId.setStatus('current')
if mibBuilder.loadTexts: prtIpParamVlanId.setDescription('VLAN Identifier.')
prtIpParamVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamVlanPriority.setStatus('current')
if mibBuilder.loadTexts: prtIpParamVlanPriority.setDescription('VLAN Frame priority.')
prtIpParamDoubleTagVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamDoubleTagVlanId.setStatus('current')
if mibBuilder.loadTexts: prtIpParamDoubleTagVlanId.setDescription('VLAN Identifier of the Double Tagging VLAN.')
prtIpParamDoubleTagVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamDoubleTagVlanPriority.setStatus('current')
if mibBuilder.loadTexts: prtIpParamDoubleTagVlanPriority.setDescription('VLAN Frame priority of the Double Tagging VLAN.')
prtIpParamVlanTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("unmodified", 2), ("tag", 3), ("doubleTag", 4), ("doubleTagAndFallBack", 5), ("untag", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamVlanTagging.setStatus('current')
if mibBuilder.loadTexts: prtIpParamVlanTagging.setDescription("VLAN Tagging. 'unmodified' - No change will be done to the Frame. 'tag' - Add Tag to Untagged Frames. 'doubleTag' - Add Tag to all Frames. 'doubleTagAndFallBack' - Double Tagging will have different rules for VLANs that this port is member in, than these it is not a member in. 'untag' - Remove Tag from tagged frames.")
prtIpParamRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamRateLimit.setStatus('current')
if mibBuilder.loadTexts: prtIpParamRateLimit.setDescription('The maximum rate permitted to transfer via this port, in Kbps.')
prtIpParamDefInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamDefInterface.setStatus('current')
if mibBuilder.loadTexts: prtIpParamDefInterface.setDescription('The Default Interface for packets with unresolved destination subnet. For internal-X port: 100 + X .')
prtIpParamMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamMng.setStatus('current')
if mibBuilder.loadTexts: prtIpParamMng.setDescription('This object indicates whether Management is enabled/disabled via this port.')
prtIpParamFloodedRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamFloodedRateLimit.setStatus('current')
if mibBuilder.loadTexts: prtIpParamFloodedRateLimit.setDescription('The maximum rate permitted to transfer broadcast, multicast, and unicast flooded frames via this port, in Kbps. 0 - Disable. In Ipmux14 this parameter is applicable when prtIpParamRateLimit=0 (disable).')
prtIpParamBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 32), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamBurstSize.setStatus('current')
if mibBuilder.loadTexts: prtIpParamBurstSize.setDescription('The burst size that the port can support beyond rate limitation determined in prtIpParamRateLimit. Burst Size is measured in bytes.')
prtIpParamLimitPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("broadMultiFloodedUnicast", 2), ("broadcastMulticast", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamLimitPacketType.setStatus('current')
if mibBuilder.loadTexts: prtIpParamLimitPacketType.setDescription('The packet type that will be rate limited. Rate limitation determined in prtIpParamRateLimit. all - All packet types are rate limited. broadMultiFloodedUnicast - Broadcast, Multicast and Flooded Unicast packets are rate limited. broadcastMulticast - Broadcast and Multicast packets are rate limited. broadcast - Broadcast packets are rate limited.')
prtIpParamKeepAliveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamKeepAliveInterval.setStatus('current')
if mibBuilder.loadTexts: prtIpParamKeepAliveInterval.setDescription('This parameter indicates the period of time (in msec.) between two consequent Keep Alive messages.')
prtIpParamKeepAliveThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamKeepAliveThresh.setStatus('current')
if mibBuilder.loadTexts: prtIpParamKeepAliveThresh.setDescription('This parameter indicates the maximum number of missed Keep Alive answer messages acceptable, after which link status will be failed.')
prtIpParamP2pKeepAliveVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamP2pKeepAliveVlanId.setStatus('current')
if mibBuilder.loadTexts: prtIpParamP2pKeepAliveVlanId.setDescription('Dedicated VLAN ID for keep alive messages.')
prtIpParamP2pKeepAliveVlanPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIpParamP2pKeepAliveVlanPrio.setStatus('current')
if mibBuilder.loadTexts: prtIpParamP2pKeepAliveVlanPrio.setDescription('VLAN priority for P2P keep alive messages .')
prtIpParamRingAdjacentMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 6, 1, 1, 38), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIpParamRingAdjacentMacAddr.setStatus('current')
if mibBuilder.loadTexts: prtIpParamRingAdjacentMacAddr.setDescription('The MAC address of the adjacent NE connected to this port in an ETH ring. If the port is not a member of a ring, the value of this parameter will be 00-00-00-00-00-00.')
prtClkSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7))
prtClkSrcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1), )
if mibBuilder.loadTexts: prtClkSrcTable.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcTable.setDescription('A table - Parameters for master and fallback clock source of ports .')
prtClkSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtClkSrcCnfgIdx"), (0, "RAD-MIB", "prtClkSrcPrtIdx"), (0, "RAD-MIB", "prtClkSrcIdx"))
if mibBuilder.loadTexts: prtClkSrcEntry.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcEntry.setDescription('An entry in table.')
prtClkSrcCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: prtClkSrcCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
prtClkSrcPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: prtClkSrcPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcPrtIdx.setDescription('This object indicates a unique Port Index (receiving clock). Refer to device specification for port Index')
prtClkSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2))))
if mibBuilder.loadTexts: prtClkSrcIdx.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcIdx.setDescription('An index in the table. master - refers Master clock parameters fallback - refers Fallback clock parameters')
prtClkSrcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("internal", 2), ("rxClk", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtClkSrcMode.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcMode.setDescription('This entry indicates the source the nodal timing is locked to.')
prtClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 7, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtClkSrcPrt.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcPrt.setDescription('This entry is valid only when working in rxClk mode. It specifies the port from which the clock willl be taken. Refer to device specification for source port Index')
opticalPort = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8))
optPrtMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1), )
if mibBuilder.loadTexts: optPrtMonitorTable.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorTable.setDescription('A table - optical port (e.g SFP) monitoring parameters, according to SFF-8472 Specification for Diagnostic Monitoring Interface for Optical Xcvrs. and ITU-T rec. G.958')
optPrtMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1), ).setIndexNames((0, "RAD-MIB", "optPrtMonitorPrtIdx"), (0, "RAD-MIB", "optPrtMonitorSample"))
if mibBuilder.loadTexts: optPrtMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorEntry.setDescription('An entry in table.')
optPrtMonitorPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: optPrtMonitorPrtIdx.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorPrtIdx.setDescription('This object indicates a unique (optical) Port Index . Refer to device specification for port Index.')
optPrtMonitorSample = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("actual", 1), ("minimum", 2), ("maximum", 3))))
if mibBuilder.loadTexts: optPrtMonitorSample.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorSample.setDescription('This index indicates historic and current values - minimum, maximum and actual (current) value. ')
optPrtMonitorTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: optPrtMonitorTxPower.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorTxPower.setDescription('Transmitted optical power level. Value is given in units of hundredth (1/100) of dBm. ')
optPrtMonitorLaserBias = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: optPrtMonitorLaserBias.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorLaserBias.setDescription('LASER bias current level. Value is given in units of microAmper (uA).')
optPrtMonitorLaserTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: optPrtMonitorLaserTemp.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorLaserTemp.setDescription('LASER temperature level, in hundredth (1/100) (C) degrees.')
optPrtMonitorRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: optPrtMonitorRxPower.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorRxPower.setDescription('Received optical power in units of hundredth (1/100) of dBm. ')
optPrtMonitorSupplyVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: optPrtMonitorSupplyVoltage.setStatus('current')
if mibBuilder.loadTexts: optPrtMonitorSupplyVoltage.setDescription('Supply voltage, in hundredth (1/100) of volts (V).')
optPrtCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 2), )
if mibBuilder.loadTexts: optPrtCnfgTable.setStatus('current')
if mibBuilder.loadTexts: optPrtCnfgTable.setDescription('A table - optical port configuration')
optPrtCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 2, 1), ).setIndexNames((0, "RAD-MIB", "optPrtCnfgIdx"), (0, "RAD-MIB", "optPrtCnfgPrtIdx"))
if mibBuilder.loadTexts: optPrtCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: optPrtCnfgEntry.setDescription('An entry in table.')
optPrtCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: optPrtCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: optPrtCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.x.')
optPrtCnfgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: optPrtCnfgPrtIdx.setStatus('current')
if mibBuilder.loadTexts: optPrtCnfgPrtIdx.setDescription('This object indicates a unique (optical) Port Index . Refer to device specification for port Index.')
optPrtCnfgALS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: optPrtCnfgALS.setStatus('current')
if mibBuilder.loadTexts: optPrtCnfgALS.setDescription('enable/disable Automatic Laser Shutdown ')
systemResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemResetAllStatsCmd.setStatus('current')
if mibBuilder.loadTexts: systemResetAllStatsCmd.setDescription('Reset statistics of all ports and connections of the device.')
systemClearTablesCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("tempCnfgTables", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemClearTablesCmd.setStatus('current')
if mibBuilder.loadTexts: systemClearTablesCmd.setDescription("tempCnfgTables - Set *RowStatus = destroy for all entries of some tables having *RowStatus object, for temporary configuration only! (255). For the relevant tables, see product's specification. This object should be used by WAN product applications before performing the Update operation, in order to clear old entries of these tables. For MP-104/204 the entries will be destroyed for cnfg=1. off - agent will automatically change to this value, after performing the command. ")
systemParameter = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemParameter.setStatus('current')
if mibBuilder.loadTexts: systemParameter.setDescription("This parameter can be used for different purposes: - TELNET session time-out in seconds. - Ace20: when trying to create row in a table that already has row with the same values, if set of values has to be unique in table, this attribute is set to the index of the existing row. - Optimux-T3: when CH interfaces are RJ-45, user can select via this object, the interface type for each Group of channels: T1 or E1: The selection will be a sum of the following Bits. '0' = T1 '1' = E1 Bit Group Value for each Bit having '1' 1 1 (CH-1..CH-8) 1 2 2 (CH-9..CH-12) 2 3 3 (CH-13..CH-20) 4 4 4 (CH-21..CH-28) 8 Examples: 15 = all Groups are selected to be E1 6 = Group 2 and Group 3 are selected to be E1 (Group 1 and Group 4 are T1). - FCD-A, FCD-M: user can select via this object the configuration used for Get values of MSDSL parameters that don't have configuration index. 1 =active configuration 255=temporary configuration. Set of this object should be done before Getting the MSDSL RW parameters. - Ace2002: This parameter indicates the number of intervals that were successfully uploaded upon statistics collection session. - FCD-IP, WR, FCD-IPD, LA-240: This parameter indicates whether Telnet Access is enabled/disabled: Values: 2 - Telnet Access is Disabled. 3 - Telnet Access is Enabled. -Vmux-110: This parameter value equals to maximum number of bundles. -Optimux-155: Simmilar usage to Optimux T3. user can select via this object, interface type T1 or E1 for each Group of channels (LIU): LIU group consists of 7 channels. Up to 12 LIUs are represented (84 T1 Channels). The selection will be a sum of the 2**n For each bit:'0' = T1 ,'1' = E1 Bit Group 1 1 (CH-1 .. CH-7) 2 2 (CH-8 .. CH-14) 3 3 (CH-15 ..CH-21) ... 9 9 (CH-56.. CH-63) ... 10 10 (CH-64..CH-70) 11 11 (CH-71..CH-77) 12 12 (CH-78..CH-84) ")
agnGlobalAlarmMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnGlobalAlarmMask.setStatus('current')
if mibBuilder.loadTexts: agnGlobalAlarmMask.setDescription('The value of this attribute determines the alarm traps the agent should mask and not send to the managers. Each bit from a certain octet represents a certain alarm.')
alarmSeverity = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSeverity.setStatus('current')
if mibBuilder.loadTexts: alarmSeverity.setDescription('This object specifies the severity of the alarms.')
alarmState = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmState.setStatus('current')
if mibBuilder.loadTexts: alarmState.setDescription('.')
agnTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTestStatus.setStatus('current')
if mibBuilder.loadTexts: agnTestStatus.setDescription('Indicates the current test status (for all levels: system, card, port). This attribute will be set to: on(3): when there is at least one test in progress on the system/card/port off(2): when there is NO test in progress on the system/card/port')
systemSaveAndResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setStatus('current')
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setDescription('on - a command to Save data of Current Period in Last Period data-set and start a new counting period for Current Period. off - agent will automatically change to this value, after performing the command.')
systemDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: systemDefaultGateway.setDescription("Default Gateway's IP Address.")
systemPsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 25), )
if mibBuilder.loadTexts: systemPsTable.setStatus('current')
if mibBuilder.loadTexts: systemPsTable.setDescription("This table describes the PS types of a device. Usage of this table is specified in the device's NMS SRS")
systemPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1), ).setIndexNames((0, "RAD-MIB", "systemPsIndex1"), (0, "RAD-MIB", "systemPsIndex2"))
if mibBuilder.loadTexts: systemPsEntry.setStatus('current')
if mibBuilder.loadTexts: systemPsEntry.setDescription('An entry in table.')
systemPsIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsIndex1.setStatus('current')
if mibBuilder.loadTexts: systemPsIndex1.setDescription('First Index. In HUBs: 1 = PS-A slot 2 = PS-B slot 3 = PS-C slot. In SA units: 1 = PS1 2 = PS2 Default = 1')
systemPsIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsIndex2.setStatus('current')
if mibBuilder.loadTexts: systemPsIndex2.setDescription('Second Index. In HUBs: 1 always. In SA units: 1 = Local 2 = Remote Default = 1.')
systemPsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("ac", 2), ("dc", 3), ("acDc", 4), ("acPF", 5), ("dcPF", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsType.setStatus('current')
if mibBuilder.loadTexts: systemPsType.setDescription('The type of PS, for a stand-alone product. acDc - PS that supports both AC and DC. acPF - Power Feeding (phantom) box that is feeding another box by external AC. dcPF - Power Feeding (phantom) box that is feeding another box by external DC.')
systemPsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("failed", 2), ("ok", 3), ("degraded", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsStatus.setStatus('current')
if mibBuilder.loadTexts: systemPsStatus.setDescription('The Status of the PS unit.')
systemPsHotSwap = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("fixed", 2), ("hotSwap", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsHotSwap.setStatus('current')
if mibBuilder.loadTexts: systemPsHotSwap.setDescription('Is PS unit hot swap or fixed.')
agnFans = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnFans.setStatus('current')
if mibBuilder.loadTexts: agnFans.setDescription("This entry specifies the FANs existence and status. Each fan will be represented by 2 bits, where the first bit (right) will specify the existence: (0= Not exist, 1=exist), and the left bit will specify it's status (0= OK, 1=FAIL), so for each fan: 00 - FAN does not exist 01 - FAN exists and OK (Low Mode) 10 - High Mode (FAN OK) 11 - FAN exists and is Failed bits 0-1 are for first fan bits 2-3 are for 2nd fan (if exists) bits 4-5 are for 3nd fan (if exists) bits 6-7 are for 4nd fan (if exists) bits 8-9 are for 5nd fan (if exists) bits 10-11 are for 6nd fan (if exists) bits 12-13 are for 7nd fan (if exists) bits 14-15 are for 8nd fan (if exists).")
agnSendTrapParameter = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSendTrapParameter.setStatus('current')
if mibBuilder.loadTexts: agnSendTrapParameter.setDescription('This object specifies if the agent will attach a specific parameter to a trap. For ACE2002 the agent will attach or not the openViewSeverity parameter according to the value of this parameter: 1 - will attach openViewSeverity. 0 - will not attach openViewSeverity.')
agnSensorsStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSensorsStatus.setStatus('current')
if mibBuilder.loadTexts: agnSensorsStatus.setDescription("This entry specifies the Sensors (Temperature sensors or others) existence and status. Each sensor will be represented by 2 bits, where the first bit (right) will specify the existence: (0= Not exist, 1=exist), and the left bit will specify it's status (0= OK, 1=FAIL), so for each sensor: 00 - sensor does not exist 01 - sensor exists and status is OK 11 - sensor exists and status is not OK ( e.g. temperature exceeds pre-defined threshold) bits 0-1 are for first sensor bits 2-3 are for 2nd sensor (if exists) and so on... Bit 0 is the LSB.")
agnStationClockCard = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("notExist", 2), ("notValid", 3), ("ok", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnStationClockCard.setStatus('current')
if mibBuilder.loadTexts: agnStationClockCard.setDescription('This entry specifies the station clock card existence and status. notExist - station clock card (piggy) does not exist. notValid - station clock card exists but clock status is not valid. ok - station clock card exists, and its status is OK When the sepcific reason for clock status not being valid is known, it may be reported by lossOfSync or lossOfSignal values.')
xcIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xcIndexNext.setStatus('current')
if mibBuilder.loadTexts: xcIndexNext.setDescription('This object contains an appropriate value to be used for xcIndex when creating entries in the xcTable. The value 0 indicates that no unassigned entries are available. To obtain the xcIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
xcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 31), )
if mibBuilder.loadTexts: xcTable.setStatus('current')
if mibBuilder.loadTexts: xcTable.setDescription('Configuration of system cross-connect entries. The table follows the behavior described in RFC 2515, RFC 1604 regarding the creation deletion and modification of an entry within the table.')
xcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1), ).setIndexNames((0, "RAD-MIB", "xcIndex"), (0, "RAD-MIB", "xcIfIndex1"), (0, "RAD-MIB", "xcVpi"), (0, "RAD-MIB", "xcVci"), (0, "RAD-MIB", "xcIfIndex2"))
if mibBuilder.loadTexts: xcEntry.setStatus('current')
if mibBuilder.loadTexts: xcEntry.setDescription('An entry in table.')
xcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 1), Integer32())
if mibBuilder.loadTexts: xcIndex.setStatus('current')
if mibBuilder.loadTexts: xcIndex.setDescription('Cross Connect Identifier.')
xcIfIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 2), Integer32())
if mibBuilder.loadTexts: xcIfIndex1.setStatus('current')
if mibBuilder.loadTexts: xcIfIndex1.setDescription('The interface Index from the ifTable, which identify one side of the connection.')
xcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 3), Integer32())
if mibBuilder.loadTexts: xcVpi.setStatus('current')
if mibBuilder.loadTexts: xcVpi.setDescription('The VPI value.')
xcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 4), Integer32())
if mibBuilder.loadTexts: xcVci.setStatus('current')
if mibBuilder.loadTexts: xcVci.setDescription('The VCI value.')
xcIfIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 5), Integer32())
if mibBuilder.loadTexts: xcIfIndex2.setStatus('current')
if mibBuilder.loadTexts: xcIfIndex2.setDescription('The interface Index from the ifTable, which identifies the other side of the connection.')
xcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xcRowStatus.setStatus('current')
if mibBuilder.loadTexts: xcRowStatus.setDescription('This parameter allows NMS to create/delete entries of this table.')
xcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 7), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xcDescr.setStatus('current')
if mibBuilder.loadTexts: xcDescr.setDescription('A textual string containing information about the xc entry.')
xcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xcAdminStatus.setStatus('current')
if mibBuilder.loadTexts: xcAdminStatus.setDescription('The desired administrative status of this bi-directional cross-connect.')
xcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xcOperStatus.setStatus('current')
if mibBuilder.loadTexts: xcOperStatus.setDescription('The operational status of this bi-directional cross-connect.')
xcAttachedIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("free", 2), ("routerAtm", 3), ("lis", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xcAttachedIfType.setStatus('current')
if mibBuilder.loadTexts: xcAttachedIfType.setDescription("This object indicates if the specific VCC is already attached to any interface, and indicates the type of the interface. This object's purpose is to ease the checking to the NMS. notApplicable - used for entries that are not LAN (as HDLC), or when the VCC was attached to a bridge, or when this parameter is irrelevant. free - the LAN VCC wasn't attached yet to any router interface. routerAtm - attached to an ATM router interface. lis - attached to a LIS interface.")
xcInputPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xcInputPriority.setStatus('current')
if mibBuilder.loadTexts: xcInputPriority.setDescription('This object is the priority, by which the LAN frames will be internaly sent to the ATM HW. This parameter is applicable if atmNteMdlInputPriorityMechanism=enabled. 1 - Highest priority. Will be the first to be sent to the ATM HW. 4 - Lowest priority. Will be the last to be sent to the ATM HW.')
xcBitMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 31, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xcBitMapping.setStatus('current')
if mibBuilder.loadTexts: xcBitMapping.setDescription("This object maps this entry to a bit of an octet string. For ACE2002 this object maps the LAN VCC to the bit of the VLAN Port Lists. If the value is '0' then it means that this VCC is not mapped to a port list or it may be an HDSL entry.")
systemModule = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 32))
modlParam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1))
modlParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1), )
if mibBuilder.loadTexts: modlParamTable.setStatus('current')
if mibBuilder.loadTexts: modlParamTable.setDescription('This table include parameters for system modules.')
modlParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "modlParamIndex"))
if mibBuilder.loadTexts: modlParamEntry.setStatus('current')
if mibBuilder.loadTexts: modlParamEntry.setDescription('An entry in table.')
modlParamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modlParamIndex.setStatus('current')
if mibBuilder.loadTexts: modlParamIndex.setDescription('The module index. The index can be the slot number or any other module index as described in the specifications of the device. For Vmux-2100 device, the index will have values of: 1..4 for slots 1..4.')
modlParamReset = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("factory", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modlParamReset.setStatus('current')
if mibBuilder.loadTexts: modlParamReset.setDescription('Reset action to be performed on the module. Set the parameter will be done always to on(3) or factory (4). After performing the Reset operation, Agent will automatically set the parameter to off(2).')
modlParamSwdlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("inProcess", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modlParamSwdlStatus.setStatus('current')
if mibBuilder.loadTexts: modlParamSwdlStatus.setDescription('This parameter indicates whatever the swdl is in process or not.')
modlParamLeds = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modlParamLeds.setStatus('current')
if mibBuilder.loadTexts: modlParamLeds.setDescription('This entry specifies the LEDs status of the module. Each led is represented by 4 bits where the first 2 bits (left) specify the status : (00=NA, 01=OFF, 10=ON, 11=BLINK), and the next two bits (right) specify the color : (00=GREEN, 01=RED, 10=YELLOW, 11=GRAY). The order of the LEDS is from top to bottom, left to right: For each row starting from the top, the LEDS are returned from left to right.')
modlParamType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 2), ("empty", 3), ("miRicE1", 4), ("miRicT1", 5), ("miRicE3", 6), ("miRicT3", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modlParamType.setStatus('current')
if mibBuilder.loadTexts: modlParamType.setDescription('This attribute indicates the Module Type.')
modlParamSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 32, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modlParamSwVer.setStatus('current')
if mibBuilder.loadTexts: modlParamSwVer.setDescription("This attribute indicates the Module's Software Version.")
agnNearFarConnection = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disconnected", 2), ("connected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnNearFarConnection.setStatus('current')
if mibBuilder.loadTexts: agnNearFarConnection.setDescription('This parameter describes the connection between near-end and far-end agents.')
agnAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 34))
agnTelnetAccess = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 34, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("managersOnly", 4), ("enableSecure", 5), ("managersOnlySecure", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTelnetAccess.setStatus('current')
if mibBuilder.loadTexts: agnTelnetAccess.setDescription("Enable/Disable accessing the device via Telnet. disable - no one will be allowed to access the device via Telnet. enable - all users are allowed Telnet Access. managersOnly - Only manager stations listed in the manager's list are allowed. enableSecure - same as 'enable' above + only Secure data will be accepted (SSH) managersOnlySecure - same as 'managersOnly' above + only Secure data will be accepted (SSH).")
agnWebAccess = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 34, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("managersOnly", 4), ("enableSecure", 5), ("managersOnlySecure", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnWebAccess.setStatus('current')
if mibBuilder.loadTexts: agnWebAccess.setDescription("Enable/Disable accessing the device via Web. disable - no one will be allowed to access the device via Web. enable - all users are allowed Web Access. managersOnly - Only manager stations listed in the manager's list are allowed. enableSecure - same as 'enable' above + only Secure data will be accepted (SSL) managersOnlySecure - same as 'managersOnly' above + only Secure data will be accepted (SSL).")
agnRadiusAccess = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 34, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnRadiusAccess.setStatus('current')
if mibBuilder.loadTexts: agnRadiusAccess.setDescription('Enable/Disable authentication via RADIUS server.')
agnSshAccess = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 34, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("managersOnly", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSshAccess.setStatus('current')
if mibBuilder.loadTexts: agnSshAccess.setDescription("Enable/Disable accessing the device via SSH. disable - no one will be allowed to access the device via SSH. enable - all users are allowed SSH Access. managersOnly - Only manager stations listed in the manager's list are allowed.")
systemInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 35))
class SysIfEntityType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 6, 37, 62, 142, 200, 209))
    namedValues = NamedValues(("other", 1), ("ethernetLan", 6), ("atm", 37), ("fastEther", 62), ("ipForward", 142), ("teLink", 200), ("bridge", 209))

ifCreateTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1), )
if mibBuilder.loadTexts: ifCreateTable.setStatus('current')
if mibBuilder.loadTexts: ifCreateTable.setDescription('The Interface Configuration Table. This table enables to create interfaces of Entities.')
ifCreateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1), ).setIndexNames((0, "RAD-MIB", "ifCreateEntityType"), (0, "RAD-MIB", "ifCreateEntityIdx"), (0, "RAD-MIB", "ifCreateNumber"))
if mibBuilder.loadTexts: ifCreateEntry.setStatus('current')
if mibBuilder.loadTexts: ifCreateEntry.setDescription('An entry in the Interface Configuration table.')
ifCreateEntityType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 1), SysIfEntityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCreateEntityType.setStatus('current')
if mibBuilder.loadTexts: ifCreateEntityType.setDescription('This object indicates the Type of the Entity that exists above the created interface. For a Logical Port, this value can be: other (1) when there is no fixed entity above it.')
ifCreateEntityIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCreateEntityIdx.setStatus('current')
if mibBuilder.loadTexts: ifCreateEntityIdx.setDescription('This object indicates the Index of the Entity that exists above the created interface. For a Logical Port, this value can be: 9999 - N/A when there is no fixed entity above it.')
ifCreateNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCreateNumber.setStatus('current')
if mibBuilder.loadTexts: ifCreateNumber.setDescription('This object indicates the number of the Interface that is created.')
ifCreateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifCreateRowStatus.setStatus('current')
if mibBuilder.loadTexts: ifCreateRowStatus.setDescription('This object enables the user to create/delete entries in this table.')
ifCreateType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 5), IANAifType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifCreateType.setStatus('current')
if mibBuilder.loadTexts: ifCreateType.setDescription('This object indicates the Type of the Interface that is created.')
ifCreateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCreateIndex.setStatus('current')
if mibBuilder.loadTexts: ifCreateIndex.setDescription('This object indicates the ifIndex of the created Interface. The ifIndex is assigned by the device.')
ifCreateConnectedTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifCreateConnectedTo.setStatus('current')
if mibBuilder.loadTexts: ifCreateConnectedTo.setDescription('This object indicates the entity connected to the created Interface. The value of this object can be ifIndex of the connected entity or any other number that can identify it.')
ifCreateParams = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifCreateParams.setStatus('current')
if mibBuilder.loadTexts: ifCreateParams.setDescription("This object represents one or more parameters of the created Interface. Each group of bits (one or more bits) represents a specific parameter and its possible values. This object's mapping and interpretation will be specified in each device's specification documents. The parameter should be used within the create PDU assuming atomic operation.")
ifCreateConnectionPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 1, 1, 9), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ifCreateConnectionPointer.setStatus('current')
if mibBuilder.loadTexts: ifCreateConnectionPointer.setDescription("This parameter represents the entity that is connected to this Interface. It can be used instead of ifCreateConnectedTo. It is an OBJECT IDENTIFIER. This parameter's SYNTAX allows the following possibilities: - can be simply used for entity that is not an interface - is not limited to include up to 32 bits The value of this parameter is a pointer to an existing row of a table, where the entity connected to this Interface is defined (i.e. the pointer uniquely identifies the connected entity). Examples: In case of an interface (from 2863.ifTable): points to 'ifEntry' of corresponding row = <ifEntry OID>.<ifIndex> In case of a VPI/VCI (from 2515.atmVclTable): points to 'atmVclEntry' of corresponding row = <atmVclEntry OID>.<ATM>.VPI.VCI In case no entity is connected, value = 0 .")
interfacePerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2))
ifPerfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1), )
if mibBuilder.loadTexts: ifPerfTable.setStatus('current')
if mibBuilder.loadTexts: ifPerfTable.setDescription('Interface Performance Table. The propose of this table is to support statistics counters having 64 bit by using 2 parameters with syntax= Integer32. This is because SNMPv1 does not support Counter64 properly. For SNMPv3, ifPerfHCCounter (Counter64) may be supported. ')
ifPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "ifPerfCounterType"))
if mibBuilder.loadTexts: ifPerfEntry.setStatus('current')
if mibBuilder.loadTexts: ifPerfEntry.setDescription('An entry in the Interface Performance Table.')
ifPerfCounterType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: ifPerfCounterType.setStatus('current')
if mibBuilder.loadTexts: ifPerfCounterType.setDescription("2nd index of the ifPerfTable. This parameter represents the Counter Type. Each application can have a different association between this object's value and counter type - see relevant application spec. For VPLS-MTU application use the following values: 1= Rx Octets, 2= Tx Octets, 3= Rx Frames, 4= Tx Frames, 5=Rx Dropped Frames, 6= Tx Dropped Frames. Optionally, counter type description appears in agnListDecodingTable ")
ifPerfLowCounterPart = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifPerfLowCounterPart.setStatus('current')
if mibBuilder.loadTexts: ifPerfLowCounterPart.setDescription('In order to support Counters having 64 bit length, the performance counter is divided into two 32 bit parameters as follows: [ 64 bit parameter ] = [ High 32 bit parameter ][ Low 32 bit parameter ]. This parameter holds the Low 32 bits of the counter, while the following parameter holds the High 32 bits of the counter.')
ifPerfHighCounterPart = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifPerfHighCounterPart.setStatus('current')
if mibBuilder.loadTexts: ifPerfHighCounterPart.setDescription('This parameter holds the High 32 bits of the counter (see description in the above parameter).')
ifPerfHCCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 35, 2, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifPerfHCCounter.setStatus('current')
if mibBuilder.loadTexts: ifPerfHCCounter.setDescription('This High Capacity counter holds whole 64 bits of the counter indicated by ifPerfCounterType (concatenates both counter parts ifPerfHighCounterPart&ifPerfLowCounterPart) This object can be supported only by agents using SNMPv2 or SNMPv3.')
systemOam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 36))
systemOamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1), )
if mibBuilder.loadTexts: systemOamTable.setStatus('current')
if mibBuilder.loadTexts: systemOamTable.setDescription('The OAM Configuration Table.')
systemOamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1, 1), ).setIndexNames((0, "RAD-MIB", "systemOamCnfgIdx"))
if mibBuilder.loadTexts: systemOamEntry.setStatus('current')
if mibBuilder.loadTexts: systemOamEntry.setDescription('An entry in the OAM table.')
systemOamCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: systemOamCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: systemOamCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
systemOamFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemOamFrequency.setStatus('current')
if mibBuilder.loadTexts: systemOamFrequency.setDescription('Time in sec. between 2 OAM packets.')
systemOamTimeoutCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemOamTimeoutCycles.setStatus('current')
if mibBuilder.loadTexts: systemOamTimeoutCycles.setDescription('No. of cycles the agent will send OAM packets without receiving a response from the remote device before declaring that the connection to the remote side is down - Time Out.')
systemOamLinkCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemOamLinkCheck.setStatus('current')
if mibBuilder.loadTexts: systemOamLinkCheck.setDescription('This MIB object determines whether continuous connectivity Link checks will be performed by the device for uplinks. For Vmux-2100: enable (3) value can be set upon device installation. In this case, TDM Link Connectivity checks can be performed even before the user configures the Links of the device.If the value is enable (3) and there is no connection with the remote side, the Test LED will blink on the Main Board Module.')
systemOamDescrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2), )
if mibBuilder.loadTexts: systemOamDescrTable.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrTable.setDescription('The OAM Descriptors Configuration Table.')
systemOamDescrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1), ).setIndexNames((0, "RAD-MIB", "systemOamDescrIdx"))
if mibBuilder.loadTexts: systemOamDescrEntry.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrEntry.setDescription('An entry in the OAM table.')
systemOamDescrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: systemOamDescrIdx.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrIdx.setDescription('The OAM Descriptor Index.')
systemOamDescrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: systemOamDescrRowStatus.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrRowStatus.setDescription('Enables the user to create/delete entries in this table.')
systemOamDescrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("intermediate", 1), ("segmentTermination", 2), ("endToEndTermination", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: systemOamDescrMode.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrMode.setDescription('The OAM Mode of the Descriptor.')
systemOamDescrCCDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("both", 2), ("none", 3), ("source", 4), ("sink", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: systemOamDescrCCDirection.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrCCDirection.setDescription('OAM Continuity Check function mode. both(2) - Agent sends OAM CC cells and checks received OAM CC cells. none(3) - Agent does not send and does not check received OAM CC cells. source(4)- Agent sends OAM CC cells. sink(5) - Agent checks received OAM CC cells.')
systemOamDescrLoopbackOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: systemOamDescrLoopbackOperation.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrLoopbackOperation.setDescription('The OAM Loopback function mode. off(2) - Stop sending loopback OAM cells. on(3) - Start loopback OAM cells.')
systemOamDescrLoopbackDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 6), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: systemOamDescrLoopbackDestAddr.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrLoopbackDestAddr.setDescription('Loopback Destination Address.')
systemOamDescrXcCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 36, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemOamDescrXcCounter.setStatus('current')
if mibBuilder.loadTexts: systemOamDescrXcCounter.setDescription('The number of connections that use this OAM Descriptor.')
agnDeviceView = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("oldLook", 2), ("newLook", 3), ("newLook2", 4), ("plastic", 5), ("metal", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDeviceView.setStatus('current')
if mibBuilder.loadTexts: agnDeviceView.setDescription('This variable denotes the view of the device: Look: old look, new look or new look 2. Material: Plastic or Metal.')
bitMappingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 38), )
if mibBuilder.loadTexts: bitMappingTable.setStatus('current')
if mibBuilder.loadTexts: bitMappingTable.setDescription("This table maps bits of an octet string to an interface. For ACE-2002 this table is used to map bits of VLAN port lists to LAN VCC's. This table is the opposite view of the xcTable for xcBitMapping. It is used to ease the bit translation for the NMS.")
bitMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 38, 1), ).setIndexNames((0, "RAD-MIB", "bitMappingLocation"))
if mibBuilder.loadTexts: bitMappingEntry.setStatus('current')
if mibBuilder.loadTexts: bitMappingEntry.setDescription('Each entry in the table describes a correlation of a bit location to an interface. For ACE-2002 - Upon creation of a new LAN VCC the agent will add an entry to this table that will define the bit location for that VCC.')
bitMappingLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 38, 1, 1), Integer32())
if mibBuilder.loadTexts: bitMappingLocation.setStatus('current')
if mibBuilder.loadTexts: bitMappingLocation.setDescription('The bit location in an octet string.')
bitMappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 38, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitMappingIndex.setStatus('current')
if mibBuilder.loadTexts: bitMappingIndex.setDescription('The interface index or any other index that should be mapped.')
bitMappingView = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 39), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitMappingView.setStatus('current')
if mibBuilder.loadTexts: bitMappingView.setDescription("A view of the bitMappingTable in one object - each entry in the biMappingTable will have the corresponding Bit of this object (bitMappingLocation) = '1'. For ACE-2002 it is used to describe all the existing LAN VCC's So that the NMS can easily calculate which VCC's can be selected as members for a VLAN, instead of reading all the bitMapping Table.")
hostTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 40), )
if mibBuilder.loadTexts: hostTable.setStatus('current')
if mibBuilder.loadTexts: hostTable.setDescription('Host interface table.')
hostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1), ).setIndexNames((0, "RAD-MIB", "hostIndex"))
if mibBuilder.loadTexts: hostEntry.setStatus('current')
if mibBuilder.loadTexts: hostEntry.setDescription('An entry in the Host Table. The hostParam1, hostParam2, and hostParam3 entries may have different use in different applications.')
hostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 1), Integer32())
if mibBuilder.loadTexts: hostIndex.setStatus('current')
if mibBuilder.loadTexts: hostIndex.setDescription('The Host Table Index. This index can have the same value as Host No.')
hostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostIP.setStatus('current')
if mibBuilder.loadTexts: hostIP.setDescription('The host interface IP address.')
hostIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostIPMask.setStatus('current')
if mibBuilder.loadTexts: hostIPMask.setDescription('The host interface subnet mask.')
hostDefaultNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostDefaultNextHop.setStatus('current')
if mibBuilder.loadTexts: hostDefaultNextHop.setDescription('The host interface Default Next Hop address.')
hostMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostMode.setStatus('current')
if mibBuilder.loadTexts: hostMode.setDescription('This parameter represents the Host mode of operation. There can be different values for each application. For example: Not Applicable = 1.')
hostParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostParam1.setStatus('current')
if mibBuilder.loadTexts: hostParam1.setDescription('This parameter represents the first Host parameter. There can be different values for each application. For example: Not Applicable = 1.')
hostParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostParam2.setStatus('current')
if mibBuilder.loadTexts: hostParam2.setDescription('This parameter represents the 2nd Host parameter. There can be different values for each application.')
hostParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostParam3.setStatus('current')
if mibBuilder.loadTexts: hostParam3.setDescription('This parameter represents the 3nd Host parameter. There can be different values for each application.')
hostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostRowStatus.setStatus('current')
if mibBuilder.loadTexts: hostRowStatus.setDescription('Creation/Deletion of rows in the table.')
hostVlanTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("untag", 2), ("tag", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostVlanTagging.setStatus('current')
if mibBuilder.loadTexts: hostVlanTagging.setDescription('Host VLAN support (Tagging). untag - No support of VLAN Tagging. tag - 4 VLAN bytes will be added to the frame.')
hostVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostVlanId.setStatus('current')
if mibBuilder.loadTexts: hostVlanId.setDescription('Host VLAN ID.')
hostVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 40, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hostVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hostVlanPriority.setDescription('Host VLAN Frame priority.')
invNameXCTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 41), )
if mibBuilder.loadTexts: invNameXCTable.setStatus('current')
if mibBuilder.loadTexts: invNameXCTable.setDescription('Inverse Name XC Table. This table can be used to ease the search for a connection first index by the connection name.')
invNameXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 41, 1), ).setIndexNames((1, "RAD-MIB", "invNameXC"))
if mibBuilder.loadTexts: invNameXCEntry.setStatus('current')
if mibBuilder.loadTexts: invNameXCEntry.setDescription('An entry in the table.')
invNameXC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 41, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: invNameXC.setStatus('current')
if mibBuilder.loadTexts: invNameXC.setDescription('The unique Connection name, associated to a Cross-Connection.')
invNameXCType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 41, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: invNameXCType.setStatus('current')
if mibBuilder.loadTexts: invNameXCType.setDescription('The OBJECT IDENTIFIER of the respective XC Table. Examples: XC Table invNameXCType --------------------------------------------------- atmVpCrossConnectTable 1.3.6.1.2.1.37.1.9 atmVcCrossConnectTable 1.3.6.1.2.1.37.1.11 atmfCESConfTable 1.3.6.1.4.1.353.5.2.2.1.1 .')
invNameXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 41, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: invNameXCIndex.setStatus('current')
if mibBuilder.loadTexts: invNameXCIndex.setDescription('The XC Table (invNameXCType) may include more than one index. This object represents the value of the first XC Index.')
agnDeviceCapabilities = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 42), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDeviceCapabilities.setStatus('current')
if mibBuilder.loadTexts: agnDeviceCapabilities.setDescription("Indicates the optional capabilities that are implemented by this device and are manageable through this MIB. For each capability 1 BIT is allocated in each Octet starting from the LSB. If the value of the BIT = 1, the capability is Enabled. If the value of the BIT = 0, the capability is Disabled. For bit assignment, refer to device specification. Capabilities example: Router - BIT 0 (0000 0001 = 01 Hex = 1 Decimal). The 2nd octet (MSB) will represent the maximum number of intervals that the Agent can keep in its DB (same for all ports). For Vmux, this object describes agent's support of LBRAD coder feature: 1 octet ; bit 0 (LSB). '1' - LBRAD feature is supported '0' - LBRAD feature is not supported.")
rowInfoTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 43), )
if mibBuilder.loadTexts: rowInfoTable.setStatus('current')
if mibBuilder.loadTexts: rowInfoTable.setDescription('This table holds information of other tables.')
rowInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 43, 1), ).setIndexNames((0, "RAD-MIB", "rowInfoTableId"))
if mibBuilder.loadTexts: rowInfoEntry.setStatus('current')
if mibBuilder.loadTexts: rowInfoEntry.setDescription('An entry in the table.')
rowInfoTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 43, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: rowInfoTableId.setStatus('current')
if mibBuilder.loadTexts: rowInfoTableId.setDescription('The OBJECT IDENTIFIER of the Table, which its information is held by this table (rowInfoTable). Examples: Table Name rowInfoTableId --------------------------------------------------- atmTrafficDescrParamTable 1.3.6.1.2.1.37.1.5 atmVpCrossConnectTable 1.3.6.1.2.1.37.1.9 atmVcCrossConnectTable 1.3.6.1.2.1.37.1.11 atmfCESConfTable 1.3.6.1.4.1.353.5.2.2.1.1 .')
rowInfoCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 43, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rowInfoCounter.setStatus('current')
if mibBuilder.loadTexts: rowInfoCounter.setDescription('The Number of rows in the table, indicated by rowInfoTableId.')
rowInfoIndexNext = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 43, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rowInfoIndexNext.setStatus('current')
if mibBuilder.loadTexts: rowInfoIndexNext.setDescription('The First Free Index of the table, indicated by rowInfoTableId.')
rowInfoMaxNoOfRows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 43, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rowInfoMaxNoOfRows.setStatus('current')
if mibBuilder.loadTexts: rowInfoMaxNoOfRows.setDescription('The maximum possible number of rows in the table, indicated by rowInfoTableId.')
agnStoreCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("inFlash", 3), ("asDefConfigFile", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnStoreCmd.setStatus('current')
if mibBuilder.loadTexts: agnStoreCmd.setDescription("Store command. inFlash(3) = store the current Agent configuration in Flash memory. asDefConfigFile(4) = store the current Agent configuration as Default Configuration file (e.g. 'DefConfig.cfg'). Agent will perform the required command and change automatically the value of this object to off(2).")
agnFunctionTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 45), )
if mibBuilder.loadTexts: agnFunctionTable.setStatus('current')
if mibBuilder.loadTexts: agnFunctionTable.setDescription('This table is used in order to activate/deactivate device functions. The index indicates the function. Each function can be Enabled or Disabled.')
agnFunctionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 45, 1), ).setIndexNames((0, "RAD-MIB", "agnFunction"))
if mibBuilder.loadTexts: agnFunctionEntry.setStatus('current')
if mibBuilder.loadTexts: agnFunctionEntry.setDescription('An entry in the table.')
agnFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 45, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("routing", 2), ("backup", 3), ("alarmForwarding", 4), ("uplinkLoopDetect", 5), ("systemClock", 6))))
if mibBuilder.loadTexts: agnFunction.setStatus('current')
if mibBuilder.loadTexts: agnFunction.setDescription('This MIB object indicates the function that will be enabled or disabled in the device. alarmForwarding= Fault Propagation (usually towards user port). For Vmux: routing (2) - enable/disable Router backup (3) - enable/disable Backup between E1/T1/Serial Link and ETH. uplinkLoopDetect (5) - enable/disable Loop Detection on the TDM Uplink. systemClock (6) - enable/disable the System Clock. ')
agnFunctionActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 45, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnFunctionActivation.setStatus('current')
if mibBuilder.loadTexts: agnFunctionActivation.setDescription('This MIB object indicates the activation of the current function.')
agnManagerConfigPorts = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnManagerConfigPorts.setStatus('current')
if mibBuilder.loadTexts: agnManagerConfigPorts.setDescription('This variable defines from which port/s this manager can manage the device. The value is a sum of 2**n, where n is a bit assigned to a certain port. For RIC-E1 and ETX 102 the value will be according to the ports combination: Network = bit 0 User= bit 1 For Example: All = 3.')
agnEgressRateRange = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unlimited", 1), ("range1", 2), ("range2", 3), ("range3", 4), ("range4", 5), ("range5", 6), ("range6", 7), ("range7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnEgressRateRange.setStatus('current')
if mibBuilder.loadTexts: agnEgressRateRange.setDescription('This variable defines the valid ranges of egress rate. For example, for ETX 102: range 1 (2)= 128KBPS - 8MBPS, range 2 (3)= 256KBPS - 16MBPS, range 3 (4)= 512KBPS - 32MBPS, range 4 (5)= 1MBPS - 64MBPS, range 5 (6)= 1.5MBPS - 80MBPS.')
agnNoOfCurrentConns = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnNoOfCurrentConns.setStatus('current')
if mibBuilder.loadTexts: agnNoOfCurrentConns.setDescription('This variable indicates the number of connections currently configured for the agent.')
agnIngressRateRange = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unlimited", 1), ("range1", 2), ("range2", 3), ("range3", 4), ("range4", 5), ("range5", 6), ("range6", 7), ("range7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnIngressRateRange.setStatus('current')
if mibBuilder.loadTexts: agnIngressRateRange.setDescription('This variable defines the valid ranges of ingress rate. For example, for ETX 102: range 1 (2)= 128KBPS - 8MBPS, range 2 (3)= 256KBPS - 16MBPS, range 3 (4)= 512KBPS - 32MBPS, range 4 (5)= 1MBPS - 64MBPS, range 5 (6)= 1.5MBPS - 80MBPS.')
alarmForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 50), )
if mibBuilder.loadTexts: alarmForwardingTable.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingTable.setDescription('The Alarm Forwarding Mechanism will be operated for this table entries.')
alarmForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1), ).setIndexNames((0, "RAD-MIB", "alarmForwardingFailPort"), (0, "RAD-MIB", "alarmForwardingToPort"))
if mibBuilder.loadTexts: alarmForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingEntry.setDescription('Each entry in this table is a pair of ports that the Alarm Forwarding Mechanism is determined for.')
alarmForwardingFailPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: alarmForwardingFailPort.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingFailPort.setDescription('An Index of the port on which a fail occurs.')
alarmForwardingToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: alarmForwardingToPort.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingToPort.setDescription('An Index of the port that will be affected upon the failure of the alarmForwardingFailPort.')
alarmForwardingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingRowStatus.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingRowStatus.setDescription('Creation/ Deletion of rows in the table.')
alarmForwardingRecoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingRecoveryTime.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingRecoveryTime.setDescription('This parameter defines the maximum time (sec) the affected port will hold the down state.')
alarmForwardingGroupConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingGroupConditions.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingGroupConditions.setDescription('This parameter is applicable when there is a group of interfaces in which a fault may occur, and one interface to which alarm is propagated (forwarded). 0 = All - Forwarding will take place only when all interfaces of the same group are faulty. 1 = Single - Forwarding will take place when at least one (single) interface of the same group (any of them) is faulty. n - forwarding will take place only when n (n < all) interfaces of the same group fail.')
alarmForwardingCause = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 6), Bits().clone(namedValues=NamedValues(("loss", 0), ("ais", 1), ("rdi", 2), ("protocolDown", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingCause.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingCause.setDescription('Bit map representing the cause upon which alarm forwarding will take place. bit 0 - LOSS (LINE DOWN) bit 1 - AIS bit 2 - RDI bit 3 - PROTOCOL DOWN.')
alarmForwardingRecoveryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingRecoveryMode.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingRecoveryMode.setDescription('This parameter determines the Recovery Mode. manual - The user should stop the alarm forwarding by using the alarmForwardingRecoveryCommand. automatic - Alarm forwarding will be automatically stopped upon alarmForwardingFailPort recovery.')
alarmForwardingRecoveryCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingRecoveryCommand.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingRecoveryCommand.setDescription("This parameter is a command. It is applicable when alarmForwardingRecoveryMode = manual. on - Will stop alarm forwarding. After setting to 'On', the agent will set this parameter back to 'Off'.")
alarmForwardingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingDelay.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingDelay.setDescription('This parameter determines the period of time (in seconds) the alarm of the alarmForwardingFailPort should exist before starting alarm forwarding.')
alarmForwardingDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unidirectional", 1), ("bidirectional", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingDirection.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingDirection.setDescription('This parameter determines the Direction of the Alarm Forwarding. unidirectional - alarmForwardingFailPort affects the alarmForwardingToPort. bidirectional - alarmForwardingFailPort affects the alarmForwardingToPort AND vice-versa. For such cases, this value will be selected, instead of entering an additional unidirectional entry in the table, where the indexes are swapped.')
alarmForwardingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 50, 1, 11), Bits().clone(namedValues=NamedValues(("noAction", 0), ("interfaceDeactivation", 1), ("oamSignaling", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alarmForwardingAction.setStatus('current')
if mibBuilder.loadTexts: alarmForwardingAction.setDescription("Bit map representing the action to be performed when alarm forwarding will take place. bit 0 - No Action. '1' value - device should NOT perform any action, though other bits indicate the action to be taken. '0' value - device should perform the action/s indicated by rest of the bits. In this case, one of the other bits should be '1'. bit 1 - Interface Deactivation (of the affected Port: alarmForwardingToPort) bit 2 - OAM Signaling. Affected Port (alarmForwardingToPort) will send special OAM Signaling to the Far-End unit about the Failure. This object will be used only for devices that support Deactivation per entry OR can support more than one action.")
agnSwVersionSwapCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("mainAndBackup", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSwVersionSwapCmd.setStatus('current')
if mibBuilder.loadTexts: agnSwVersionSwapCmd.setDescription('SW switch command. mainAndBackup (3) = Swap between Main SW and the backup one. Agent will perform the required command and change automatically the value of this object to off(2).')
agnClockSource = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 52))
agnClkSrcPortTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1), )
if mibBuilder.loadTexts: agnClkSrcPortTable.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortTable.setDescription('Pool of Ports for the Master/Fallback Clock Source and of Recovered IDs. For devices with more than one configuration: Set operation is valid only to the TmpCnfg entry.')
agnClkSrcPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnClkSrcPortCnfgIdx"), (0, "RAD-MIB", "agnClkSrcPortSrcIdx"), (0, "RAD-MIB", "agnClkSrcPortIdx"))
if mibBuilder.loadTexts: agnClkSrcPortEntry.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortEntry.setDescription('An entry in the table.')
agnClkSrcPortCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: agnClkSrcPortCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortCnfgIdx.setDescription('This object indicates the Idx of the Cnfg being accessed ; Idx of 255 relates to the TmpCnfg. For product supporting a single configuration, the value will be 1.')
agnClkSrcPortSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("recovered", 3))))
if mibBuilder.loadTexts: agnClkSrcPortSrcIdx.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortSrcIdx.setDescription('Clock Source Index. master - refers to Master clock fallback - refers to Fallback clock recovered - refers to Recovered clock.')
agnClkSrcPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: agnClkSrcPortIdx.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortIdx.setDescription('This object indicates the running Idx of the port that is to be used as Clock Source, for each agnClkSrcPortSrcIdx instance. In case of Recovered Clock - it indicates the Clock ID.')
agnClkSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPort.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPort.setDescription('This object indicates the Port/Interface Index of the port that is to be used as Clock Source. In case of Recovered Clock - it indicates the PW number.')
agnClkSrcPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPortRowStatus.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortRowStatus.setDescription('This object enables Creation/ Deletion of rows in the table.')
agnClkSrcPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("down", 2), ("up", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortAdminStatus.setDescription('This object indicates the Recovered Clock Administrative Status.')
agnClkSrcPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("adaptive", 2), ("ieee1588v2", 3), ("commonClock", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPortType.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortType.setDescription('This object is relevant only in case of Recovery Clock. It indicates the Clock Type.')
agnClkSrcPortQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("stratum1", 2), ("stratum2", 3), ("stratum3", 4), ("stratum3e", 5), ("stratum4", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPortQuality.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortQuality.setDescription('This object indicates the Clock Source Quality.')
agnClkSrcPortNetType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("typeA", 2), ("typeB", 3), ("typeC", 4), ("typeD", 5), ("typeE", 6), ("typeF", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnClkSrcPortNetType.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortNetType.setDescription('This object is relevant only in case of Recovery Clock. It indicates the Clock Network Type, i.e. the PSN network characteristics and behavior.')
agnClkSrcPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("freeRun", 1), ("frequencyAcquisition", 2), ("rapidPhaseLock", 3), ("finePhaseLock", 4), ("holdover", 5), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkSrcPortState.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcPortState.setDescription('This object indicates the Clock State. freeRun(1) - Clock recovery is not locked to any clock. frequencyAcquisition(2) - Adaptive clock recovery is learning the frequency. rapidPhaseLock(3) - Clock recovery is in training process till it reaches fine phase lock. finePhaseLock(4) - Clock is locked and clock recovery is qualified and stable. holdover(5) - Clock recovery is in holdover mode. notApplicable(6) - Clock recovery is not applicable. .')
agnCurrClkTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2), )
if mibBuilder.loadTexts: agnCurrClkTable.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkTable.setDescription('Current Clock Source.')
agnCurrClkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnCurrClkObjIdx"))
if mibBuilder.loadTexts: agnCurrClkEntry.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkEntry.setDescription('An entry in the table.')
agnCurrClkObjIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: agnCurrClkObjIdx.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkObjIdx.setDescription('This MIB object identifies the object for which the Clock Source is used (System, Other System, Card).')
agnCurrClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("internal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkMode.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkMode.setDescription('Current Clock Source Mode. master - refers Master clock fallback - refers Fallback clock internal - only when both Master and Fallback Sources failed ')
agnCurrClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 255))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("rxClk", 3), ("station", 4), ("lbt", 5), ("ntr", 6), ("adaptive", 7), ("stationB", 8), ("automatic", 9), ("system", 10), ("sSubsystem", 11), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkSrc.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkSrc.setDescription('This object indicates the Current Clock Source.')
agnCurrClkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkPort.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkPort.setDescription('This object indicates the Port/Interface Index of the port that is Currently used as Clock Source.')
agnCurrClkHoldover = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkHoldover.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkHoldover.setDescription("Current Clock Holdover State. As a last resort, in the absence of higher quality timing: - a SONET/SDH object can enter 'holdover' state, until higher quality external timing becomes available again. In this state (value=yes) the SONET/SDH object uses its own timing circuits for clock of the SONET/SDH signal. - for other objects, the 'holdover'=yes state means that the object uses last available clock (stored by the object) for a pre-defined time, until another clock source is used.")
agnCurrClkSsmBased = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkSsmBased.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkSsmBased.setDescription('This parameter indicates whether clock source is selected based on receive clock quality. Clock quality is indicated in S1 byte inside SONET/SDH overhead, (encoded as SSM - Synchronization Status Messaging).')
agnCurrClkState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("freeRun", 1), ("rapidPhaseLock", 2), ("finePhaseLock", 3), ("holdover", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkState.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkState.setDescription('This object indicates the Current Clock State. freeRun(1) - Current clock state machine is not locked and run from the internal oscillator. rapidPhaseLock(2) - Current clock state machine is locked. finePhaseLock(3) - Current clock state machine is in pre-locking. holdover(4) - Current clock state machine is in holdover mode (due to loss of event). .')
agnCurrClkQualification = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disqualified", 2), ("qualified", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCurrClkQualification.setStatus('current')
if mibBuilder.loadTexts: agnCurrClkQualification.setDescription('This object indicates the Current Clock Qualification and defines whether the PLL can locked according to the stratum definitions.')
agnClockMonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3))
agnClkCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1), )
if mibBuilder.loadTexts: agnClkCurrentTable.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentTable.setDescription('The Clock Current table.')
agnClkCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnClkCurrentIndex"))
if mibBuilder.loadTexts: agnClkCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentEntry.setDescription('An entry in the Clock Current table.')
agnClkCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: agnClkCurrentIndex.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentIndex.setDescription('An Index that is uniquely represents the Clock.')
agnClkCurrentRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkCurrentRxPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentRxPackets.setDescription('The counter associated with the number of Received Packets, encountered by a Bridge Port in the current 15 minute interval.')
agnClkCurrentLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkCurrentLostPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentLostPackets.setDescription('The counter associated with the number of Lost Packets, encountered by a Bridge Port in the current 15 minute interval.')
agnClkCurrentOutOfOrderPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkCurrentOutOfOrderPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentOutOfOrderPackets.setDescription('The counter associated with the number of times Out-of-Order Packets encountered by a Bridge Port in the current 15 minute interval.')
agnClkCurrentBufferUnderflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkCurrentBufferUnderflow.setStatus('current')
if mibBuilder.loadTexts: agnClkCurrentBufferUnderflow.setDescription('The counter associated with the number of times Underflow event encountered by a Bridge Port in the current 15 minute interval.')
agnClkIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2), )
if mibBuilder.loadTexts: agnClkIntervalTable.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalTable.setDescription('The Clock Interval table.')
agnClkIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnClkIntervalIndex"), (0, "RAD-MIB", "agnClkIntervalNumber"))
if mibBuilder.loadTexts: agnClkIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalEntry.setDescription('An entry in the Clock Interval table.')
agnClkIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: agnClkIntervalIndex.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalIndex.setDescription('An Index that is uniquely represents the Clock.')
agnClkIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: agnClkIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals exist).')
agnClkIntervalRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkIntervalRxPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalRxPackets.setDescription('The counter associated with the number of Received Packets, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
agnClkIntervalLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkIntervalLostPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalLostPackets.setDescription('The counter associated with the number of Lost Packets, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
agnClkIntervalOutOfOrderPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkIntervalOutOfOrderPackets.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalOutOfOrderPackets.setDescription('The counter associated with the number of times Out-of-Order Packets are detected, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
agnClkIntervalBufferUnderflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 52, 3, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnClkIntervalBufferUnderflow.setStatus('current')
if mibBuilder.loadTexts: agnClkIntervalBufferUnderflow.setDescription('The counter associated with the number of times Underflow event is detected, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
agnMaxNoOfConns = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnMaxNoOfConns.setStatus('current')
if mibBuilder.loadTexts: agnMaxNoOfConns.setDescription('This variable indicates the maximum number of connections that can be configured for the agent.')
lag = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 54))
lagTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1), )
if mibBuilder.loadTexts: lagTable.setStatus('current')
if mibBuilder.loadTexts: lagTable.setDescription('A table defining Link Aggregation Groups port association, and other parameters.')
lagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1), ).setIndexNames((0, "RAD-MIB", "lagCnfgIdx"), (0, "RAD-MIB", "lagIdx"))
if mibBuilder.loadTexts: lagEntry.setStatus('current')
if mibBuilder.loadTexts: lagEntry.setDescription('An entry in the LAG table.')
lagCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: lagCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: lagCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
lagIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: lagIdx.setStatus('current')
if mibBuilder.loadTexts: lagIdx.setDescription('This object indicates LAG unique index.')
lagPortMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 3), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagPortMembers.setStatus('current')
if mibBuilder.loadTexts: lagPortMembers.setDescription('The set of ports which are permanently assigned to the Link Aggregation Group. The default value of this object is a string of zeros.')
lagDistributionMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("portBased", 2), ("oneToOne", 3), ("sourceMac", 4), ("destinationMac", 5), ("sourceXorDestinationMac", 6), ("sourceAndDestinationMac", 7), ("sourceIp", 8), ("destinationIp", 9), ("sourceAndDestinationMacAndIp", 10), ("roundRobin", 11)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagDistributionMethod.setStatus('current')
if mibBuilder.loadTexts: lagDistributionMethod.setDescription('This object defines the criteria for the 802.3ad (LAG) to split the traffic between ports')
lagRecoveryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("nonRevertive", 2), ("revertive", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagRecoveryMode.setStatus('current')
if mibBuilder.loadTexts: lagRecoveryMode.setDescription('This object defines whether traffic will be returned to a port after its recovery. This object is applicable only when lagDistributionMethod= oneToOne (3).')
lagWaitToRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 720))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: lagWaitToRestore.setDescription('This object defines traffic recovery time (in seconds) to the port after its recovery. This object is applicable only when lagRecoveryMode= revertive (3).')
lagRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagRowStatus.setStatus('current')
if mibBuilder.loadTexts: lagRowStatus.setDescription('This object enables user to create/delete entries of this table. Note: When using LAG standard package, this table is static, hence, only the values active(1), notInService(2) are used.')
lagShutDownDurationUponFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagShutDownDurationUponFlip.setStatus('current')
if mibBuilder.loadTexts: lagShutDownDurationUponFlip.setDescription('This object defines the duration (in seconds) the active port transmission is shut down after LAG Flip occurs. The transmission is shut down and then opened again (after the duration defined by this object), in order to cause the other side to flip to the new active port. 0=no shut-down. This object is applicable only when lagDistributionMethod=oneToOne(3) and mainly when each of the Links of our device is connected to a different device.')
lagRdnMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loadSharing", 1), ("redundancy", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagRdnMethod.setStatus('current')
if mibBuilder.loadTexts: lagRdnMethod.setDescription('This object defines the redundancy method.')
lagLacpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lagLacpEnable.setStatus('current')
if mibBuilder.loadTexts: lagLacpEnable.setDescription('Enabling/Disabling the LACP for a LAG. The LACP will be enabled for all ports belonging to this LAG.')
lagStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 2), )
if mibBuilder.loadTexts: lagStatTable.setStatus('current')
if mibBuilder.loadTexts: lagStatTable.setDescription('A table defining Link Aggregation Groups Redundancy. This table is applicable only when lagDistributionMethod = oneToOne.')
lagStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 2, 1), ).setIndexNames((0, "RAD-MIB", "lagIdx"))
if mibBuilder.loadTexts: lagStatEntry.setStatus('current')
if mibBuilder.loadTexts: lagStatEntry.setDescription('An entry in the LAG Status table.')
lagStatForcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 2, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lagStatForcePort.setStatus('current')
if mibBuilder.loadTexts: lagStatForcePort.setDescription('This object enables user to enforce the active port. 0 = No Enforcement; Otherwise the ifIndex of the port.')
lagStatActivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 54, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lagStatActivePort.setStatus('current')
if mibBuilder.loadTexts: lagStatActivePort.setDescription('This object indicates the current active port. It is applicable only when lagDistributionMethod = oneToOne. The value is the ifIndex of the port. 0 = none of the ports is active.')
gfp = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 55))
gfpCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1), )
if mibBuilder.loadTexts: gfpCnfgTable.setStatus('current')
if mibBuilder.loadTexts: gfpCnfgTable.setDescription('Configuration table for GFP (General Framing Protocol).')
gfpCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "gfpCnfgIdx"))
if mibBuilder.loadTexts: gfpCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: gfpCnfgEntry.setDescription('An entry in the GFP configuration table.')
gfpCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: gfpCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: gfpCnfgIdx.setDescription('Index to GFP configuration table.')
gfpPayloadFcs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gfpPayloadFcs.setStatus('current')
if mibBuilder.loadTexts: gfpPayloadFcs.setDescription('This object defines whether protocol header will include FCS.')
gfpRxTxScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noScramble", 1), ("rxTxScramble", 2), ("rxOnlyScramble", 3), ("txOnlyScramble", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gfpRxTxScramble.setStatus('current')
if mibBuilder.loadTexts: gfpRxTxScramble.setDescription('This object defines whether transmission will be scrambled.')
gfpVcatHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 55, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gfpVcatHeader.setStatus('current')
if mibBuilder.loadTexts: gfpVcatHeader.setDescription('VCAT header is LCAS CONTROL packet as described in the G-7043. one control packet is transmitted in a period of 16 Multi frame')
agnGroupTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 56), )
if mibBuilder.loadTexts: agnGroupTable.setStatus('current')
if mibBuilder.loadTexts: agnGroupTable.setDescription('A table that enables associating components to Group/s (or removing components of a group). The Group Idx can then be used in other tables (e.g alarmForwardingTable).')
agnGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 56, 1), ).setIndexNames((0, "RAD-MIB", "agnGroupCnfgIdx"), (0, "RAD-MIB", "agnGroupIdx"), (0, "RAD-MIB", "agnGroupComponentIdx"))
if mibBuilder.loadTexts: agnGroupEntry.setStatus('current')
if mibBuilder.loadTexts: agnGroupEntry.setDescription('An entry in the agnGroupTable.')
agnGroupCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 56, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: agnGroupCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnGroupCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
agnGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 56, 1, 2), Unsigned32())
if mibBuilder.loadTexts: agnGroupIdx.setStatus('current')
if mibBuilder.loadTexts: agnGroupIdx.setDescription('This object indicates a unique Group Index.')
agnGroupComponentIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 56, 1, 3), Unsigned32())
if mibBuilder.loadTexts: agnGroupComponentIdx.setStatus('current')
if mibBuilder.loadTexts: agnGroupComponentIdx.setDescription('This object indicates a unique Component Index that belongs to the Group defined by agnGroupIdx.')
agnGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 56, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: agnGroupRowStatus.setDescription('This object enables user to create/delete entries of this table. destroy - If a Group is used in another table, Agent may not allow destroying the entry/ies that belong to this Group Index.')
agnStatNoOfUploadedIntervals = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnStatNoOfUploadedIntervals.setStatus('current')
if mibBuilder.loadTexts: agnStatNoOfUploadedIntervals.setDescription('This parameter indicates the Number of Intervals that were successfully collected and uploaded in the last statistics collection session.')
agnSyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 58))
agnSyslogDeviceUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 58, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSyslogDeviceUdpPort.setStatus('current')
if mibBuilder.loadTexts: agnSyslogDeviceUdpPort.setDescription('The UDP Port of the device, from which Syslog messages are sent. Default=514.')
agnSyslogFacility = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 58, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("local1", 17), ("local2", 18), ("local3", 19), ("local4", 20), ("local5", 21), ("local6", 22), ("local7", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSyslogFacility.setStatus('current')
if mibBuilder.loadTexts: agnSyslogFacility.setDescription('A user defined SW module, task or function, from which Syslog messages are sent to the remote Server.')
agnSyslogSeverityLevel = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 58, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("critical", 1), ("major", 2), ("minor", 3), ("warning", 4), ("event", 5), ("info", 6), ("debug", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSyslogSeverityLevel.setStatus('current')
if mibBuilder.loadTexts: agnSyslogSeverityLevel.setDescription('Device will send events equal or exceeding this severity level (configured by user).')
agnNetworkInterfaceType = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("t1", 2), ("t3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnNetworkInterfaceType.setStatus('current')
if mibBuilder.loadTexts: agnNetworkInterfaceType.setDescription('This MIB object indicates the network interface type to be used by the device. It is used for devices that use only one network port type.')
agnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 60), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTrapDelay.setStatus('current')
if mibBuilder.loadTexts: agnTrapDelay.setDescription('This variable enables the user to set a delay (in seconds) before a trap is sent. This delay will be used only for traps that need to be sent during device initialization. It is needed because the device connected to our device starts transmitting traps later. The delay starts from the end of the Boot process. The device will keep the init traps in the correct order, and cancel those which clear former ones in the list. After this init delay, traps will be sent without a delay.')
agnStringToIndexTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 62), )
if mibBuilder.loadTexts: agnStringToIndexTable.setStatus('current')
if mibBuilder.loadTexts: agnStringToIndexTable.setDescription('This table holds the conversions of tables from unique String to numeric index.')
agnStringToIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 62, 1), ).setIndexNames((0, "RAD-MIB", "agnStringToIndexTableId"), (1, "RAD-MIB", "agnStringToIndexUserName"))
if mibBuilder.loadTexts: agnStringToIndexEntry.setStatus('current')
if mibBuilder.loadTexts: agnStringToIndexEntry.setDescription('An entry in the table.')
agnStringToIndexTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 62, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: agnStringToIndexTableId.setStatus('current')
if mibBuilder.loadTexts: agnStringToIndexTableId.setDescription('The OBJECT IDENTIFIER of the Table, having as index numeric values. In this table, the value of agnStringToIndexUserName is an attribute.')
agnStringToIndexUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 62, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: agnStringToIndexUserName.setStatus('current')
if mibBuilder.loadTexts: agnStringToIndexUserName.setDescription("This object indicates a unique name used by agnStringToIndexTableId, although it is not it's index.")
agnStringToIndexTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 62, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnStringToIndexTableIndex.setStatus('current')
if mibBuilder.loadTexts: agnStringToIndexTableIndex.setDescription('The numeric Index of agnStringToIndexTableId.')
agnRowPointerTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 63), )
if mibBuilder.loadTexts: agnRowPointerTable.setStatus('current')
if mibBuilder.loadTexts: agnRowPointerTable.setDescription('This table holds information about a specific entry in a table. For example, number of usages of this row.')
agnRowPointerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 63, 1), ).setIndexNames((0, "RAD-MIB", "agnRowPointerIndex"))
if mibBuilder.loadTexts: agnRowPointerEntry.setStatus('current')
if mibBuilder.loadTexts: agnRowPointerEntry.setDescription('An entry in the table.')
agnRowPointerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 63, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: agnRowPointerIndex.setStatus('current')
if mibBuilder.loadTexts: agnRowPointerIndex.setDescription('The OBJECT IDENTIFIER of an entry in a table.')
agnRowPointerNoOfUsages = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 63, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnRowPointerNoOfUsages.setStatus('current')
if mibBuilder.loadTexts: agnRowPointerNoOfUsages.setDescription('The number of usages of specific entry in a table, which is pointed by agnRowPointerIndex.Usually, when the value of this counter is greater than 0,the entry cannot be removed.')
radTransport = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 4))
radTransportDomains = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 4, 1))
radTransportDomainSnmpEfmOam = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 4, 1, 1))
if mibBuilder.loadTexts: radTransportDomainSnmpEfmOam.setStatus('current')
if mibBuilder.loadTexts: radTransportDomainSnmpEfmOam.setDescription('The SNMP over EFM OAM transport domain. The corresponding transport address is of type RadTransportAddressEfmOam for EFM OAM addresses (port).')
class RadTransportAddressType(TextualConvention, Integer32):
    description = 'A value that represents a transport domain. This is the enumerated version of the transport domain registrations in this MIB module. It was added in RAD MIB due to the fact that it is not defined in Standard MIB. The enumerated values have the following meaning: unknown(0) unknown transport address type efmOam (1) radTransportDomainSnmpEfmOam This textual convention can be used to represent transport domains in situations where a syntax of TransportDomain is unwieldy (for example, when used as an index). The usage of this textual convention implies that additional transport domains can only be supported by updating this MIB module.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("unknown", 0), ("efmOam", 1))

class RadTransportAddressEfmOam(TextualConvention, OctetString):
    description = 'Represents a transport address consisting of an EFM OAM port number.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

systemsEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 0))
if mibBuilder.loadTexts: systemsEvents.setStatus('current')
if mibBuilder.loadTexts: systemsEvents.setDescription('The events for RAD products.')
tftpStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 1)).setObjects(("RAD-MIB", "tftpStatus"))
if mibBuilder.loadTexts: tftpStatusChangeTrap.setStatus('current')
if mibBuilder.loadTexts: tftpStatusChangeTrap.setDescription('This trap is sent whenever the status of tftp changed.')
agnStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 2)).setObjects(("RAD-MIB", "agnIndication"))
if mibBuilder.loadTexts: agnStatusChangeTrap.setStatus('current')
if mibBuilder.loadTexts: agnStatusChangeTrap.setDescription('This trap is sent whenever the state of the entity the agent is responsible for changed. TDM devices will send agnTestStatus variable to indicate the current test status.')
prtStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 3))
if mibBuilder.loadTexts: prtStatusChangeTrap.setStatus('current')
if mibBuilder.loadTexts: prtStatusChangeTrap.setDescription('This trap is sent whenever the state of a port changed. Attached, will be parameter/s that indicate the new port status. The attached variables will be specified in the specifications of the products supporting this trap.')
swdlStatusResult = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 4)).setObjects(("RAD-MIB", "swdlStatusFileName"))
if mibBuilder.loadTexts: swdlStatusResult.setStatus('current')
if mibBuilder.loadTexts: swdlStatusResult.setDescription('This notification is sent when Software Down Load is finished. The attached object indicates the File Name.')
intSwdlSlotFileMismatch = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 5)).setObjects(("RAD-MIB", "intSwdlFileName"))
if mibBuilder.loadTexts: intSwdlSlotFileMismatch.setStatus('current')
if mibBuilder.loadTexts: intSwdlSlotFileMismatch.setDescription("This notification is sent when the card in the chosen slot doesn't match the chosen file. The attached object indicates the File Name.")
agnCounterChange = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 6))
if mibBuilder.loadTexts: agnCounterChange.setStatus('current')
if mibBuilder.loadTexts: agnCounterChange.setDescription('This notification is sent when the value of a specific Counter is changed. Agent can send as attached object the updated Counter. For details about this Counter and attached object, see spec of the relevant application.')
prtClkSrcChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 7))
if mibBuilder.loadTexts: prtClkSrcChangeTrap.setStatus('current')
if mibBuilder.loadTexts: prtClkSrcChangeTrap.setDescription('This trap is sent upon any port clock change.')
moduleFailTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 8))
if mibBuilder.loadTexts: moduleFailTrap.setStatus('current')
if mibBuilder.loadTexts: moduleFailTrap.setDescription('This trap is sent upon a module failure.')
moduleInitFailTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 9))
if mibBuilder.loadTexts: moduleInitFailTrap.setStatus('current')
if mibBuilder.loadTexts: moduleInitFailTrap.setDescription('This trap is sent upon a module initialization failure.')
clkSrcChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 10))
if mibBuilder.loadTexts: clkSrcChangeTrap.setStatus('current')
if mibBuilder.loadTexts: clkSrcChangeTrap.setDescription('This trap is sent upon any change in Clock Source.')
agnUploadDataTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 11))
if mibBuilder.loadTexts: agnUploadDataTrap.setStatus('current')
if mibBuilder.loadTexts: agnUploadDataTrap.setDescription('This trap is sent upon an upload data session termination. For more details see product specification.')
enrollmentTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 12))
if mibBuilder.loadTexts: enrollmentTrap.setStatus('current')
if mibBuilder.loadTexts: enrollmentTrap.setDescription('This trap is a periodically trap, which sent to manager untill Agent get any response (Get or Set) from this manager.')
agnPowerFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 13))
if mibBuilder.loadTexts: agnPowerFailureTrap.setStatus('current')
if mibBuilder.loadTexts: agnPowerFailureTrap.setDescription('This trap is sent upon power failure. It is applicable for the following devices: 1. Devices having one PS unit, which sense the failure in advance, and still have time to send this trap before it goes off. 2. Devices having 2 PS units and send this trap in order to notify a failure in one of the units.')
agnFanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 14))
if mibBuilder.loadTexts: agnFanFailureTrap.setStatus('current')
if mibBuilder.loadTexts: agnFanFailureTrap.setDescription('This trap is sent upon fan failure/recovery.')
agnSystemParameterChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 15)).setObjects(("RAD-MIB", "systemParameter"))
if mibBuilder.loadTexts: agnSystemParameterChangeTrap.setStatus('current')
if mibBuilder.loadTexts: agnSystemParameterChangeTrap.setDescription('This trap is sent upon any change of the systemParameter value.')
agnConfigDBChecksumError = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 16)).setObjects(("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: agnConfigDBChecksumError.setStatus('current')
if mibBuilder.loadTexts: agnConfigDBChecksumError.setDescription('This trap indicates that the database currently stored in the non-volatile memory of the device is corrupted')
agnAlarmBufferOverflow = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 17)).setObjects(("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: agnAlarmBufferOverflow.setStatus('current')
if mibBuilder.loadTexts: agnAlarmBufferOverflow.setDescription('This trap indicates that the quantity of alarm messages which have been written in the alarm buffer, since the last clear command, exceeds predefined threshold. (Buffer size) The new alarms are overwriting the oldest alarms (the first alarms written in the buffer). For LA-110,threshold value is 200 alarms.')
agnAlarmBufferClear = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 18)).setObjects(("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: agnAlarmBufferClear.setStatus('current')
if mibBuilder.loadTexts: agnAlarmBufferClear.setDescription('This trap indicates that alarm buffer has been cleared.')
agnParametersValueChanged = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 19)).setObjects(("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: agnParametersValueChanged.setStatus('current')
if mibBuilder.loadTexts: agnParametersValueChanged.setDescription('This trap indicates that due to software upgrade, some of the parameters are assigned new values')
agnDriverSwMismatch = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 20)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: agnDriverSwMismatch.setStatus('current')
if mibBuilder.loadTexts: agnDriverSwMismatch.setDescription('There is mismatch between the SW driver and the HW of the device uplink interface.')
agnActualLowRate = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 21)).setObjects(("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: agnActualLowRate.setStatus('current')
if mibBuilder.loadTexts: agnActualLowRate.setDescription('The main link is synchronized at a rate lower than expected.')
xModemFileTransferStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 22)).setObjects(("RAD-MIB", "trapVal"))
if mibBuilder.loadTexts: xModemFileTransferStatusTrap.setStatus('current')
if mibBuilder.loadTexts: xModemFileTransferStatusTrap.setDescription("This trap is sent in the following cases: - When an xModem File Transfer Session begins. In this case, the trapVal.1 string sent will be: 'Start'. - When an xModem File Transfer Session ends. In this case, the trapVal.1 string sent will be one of the following, according to the way the session ended : - 'End: OK' - 'End: Failed' ")
agnStationClkFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 23))
if mibBuilder.loadTexts: agnStationClkFailureTrap.setStatus('current')
if mibBuilder.loadTexts: agnStationClkFailureTrap.setDescription('This trap is sent upon Station Clock failure.')
successfulLogin = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 24))
if mibBuilder.loadTexts: successfulLogin.setStatus('current')
if mibBuilder.loadTexts: successfulLogin.setDescription("This trap is sent when a user performed successful Login via Terminal/Telnet/Web. This trap is used when the device is located at End-User's premises while management is at Service Provider's premises.")
failedLogin = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 25))
if mibBuilder.loadTexts: failedLogin.setStatus('current')
if mibBuilder.loadTexts: failedLogin.setDescription("This trap is sent when a user tried to Login via Terminal/Telnet/Web and failed. This trap is used when the device is located at End-User's premises while management is at Service Provider's premises.")
modlChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 26))
if mibBuilder.loadTexts: modlChangeTrap.setStatus('current')
if mibBuilder.loadTexts: modlChangeTrap.setDescription('This trap is sent whenever a module is inserted or removed. The trap should include the new module type (e.g. modlParamType).')
licenseUpdateTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 27))
if mibBuilder.loadTexts: licenseUpdateTrap.setStatus('current')
if mibBuilder.loadTexts: licenseUpdateTrap.setDescription("This trap is sent whenever a license is successfully downloaded or whenever a license's demo duration is expired.")
agnClkSrcStateChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 28)).setObjects(("RAD-MIB", "agnClkSrcPortState"))
if mibBuilder.loadTexts: agnClkSrcStateChangeTrap.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcStateChangeTrap.setDescription('The trap is sent upon change in Recovery Clock State.')
agnSelfTestResultChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 29))
if mibBuilder.loadTexts: agnSelfTestResultChangeTrap.setStatus('current')
if mibBuilder.loadTexts: agnSelfTestResultChangeTrap.setDescription('The trap is sent upon each change in the result of a Self State operation.')
agnClkSrcFrequencyAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 31))
if mibBuilder.loadTexts: agnClkSrcFrequencyAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: agnClkSrcFrequencyAlarmTrap.setDescription('The trap is sent upon Recovered Clock Frequency alarm.')
genBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1))
radBridgeAction = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 255))).clone(namedValues=NamedValues(("reset", 1), ("sendNetworkTab", 2), ("deleteNetworkTab", 3), ("sendRoutingTab", 4), ("deleteRoutinTab", 5), ("sendLanTab", 6), ("deleteLanTab", 7), ("deleteArpTab", 8), ("sendArpTab", 9), ("deleteRouteTab", 10), ("sendRouteTab", 11), ("deactivateAllMasks", 12), ("saveAllActiveMasks", 13), ("loadAndActivateAllMasksFromNVRAM", 14), ("clearAllMasksFromNVRAM", 15), ("defaultConfig", 16), ("resetNVRAM", 17), ("clearIPNVRAM", 18), ("noOp", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeAction.setStatus('current')
if mibBuilder.loadTexts: radBridgeAction.setDescription('This variable enables the operator to perform one of the specified actions on the tables maintained by the network device. Send actions are not currently implemented. Not all actions can be performed on all bridges.')
radBridgeInactiveArpTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeInactiveArpTimeOut.setStatus('current')
if mibBuilder.loadTexts: radBridgeInactiveArpTimeOut.setDescription('This variable defines the maximum time period that can pass between ARP requests concerning an entry in the ARP table. After this time period, the entry is deleted from the table.')
radBridgeMaskTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 3), )
if mibBuilder.loadTexts: radBridgeMaskTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskTable.setDescription('Mask tables enable definition of forwarding restrictions and control of message flow in the internetwork. Each entry in this table defines a mask statement consisting of up to three mask definitions and an action defined by radBridgeMaskOper. Different types of mask entries are supported, as defined by radBridgeMaskType.')
radBridgeMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeMaskType"), (0, "RAD-MIB", "radBridgeMaskIfIndex"), (0, "RAD-MIB", "radBridgeMaskNum"))
if mibBuilder.loadTexts: radBridgeMaskEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskEntry.setDescription('An entry in table radBridgeMaskTable.')
radBridgeMaskType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2), ("compress", 3), ("priority", 4), ("loadSharing", 5), ("facs", 6), ("codConnect", 7), ("codDisconnect", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeMaskType.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskType.setDescription('Defines the type of mask entry.')
radBridgeMaskIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeMaskIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskIfIndex.setDescription('Specifies the if Index of the interface to which the mask is applied.')
radBridgeMaskNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeMaskNum.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskNum.setDescription('The Mask entry number, defined by its line number in the mask table.')
radBridgeMaskDest = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unassigned-cond", 1), ("broadcast-msge", 2), ("multicast-msge", 3), ("all-msge", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskDest.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskDest.setDescription('Specifies the type of destination address carried by the frame to which the mask will be applied. Unassigned-condition deactivates the mask entry.')
radBridgeMaskPat1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskPat1.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskPat1.setDescription('Describes the mask field which is either a 16 bit binary pattern, or four digit hexadecimal pattern.')
radBridgeMaskActiveBit1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskActiveBit1.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskActiveBit1.setDescription('Specifies the positions of the wild card characters (*) in the radBridgeMaskPat1 field.')
radBridgeMaskFrom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mac", 1), ("llc", 2), ("net", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskFrom1.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskFrom1.setDescription('Offset base of radBridgeMaskPat1 within the frame. Net can be in some cases the data start point.')
radBridgeMaskOffset1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskOffset1.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskOffset1.setDescription('Specifies the radBridgeMaskPat1 offset within the frame (in bytes) from the base defined in by radBridgeMaskForm1.The mask offset is an even decimal number in the range of 0 to 1518.')
radBridgeMaskCond1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskCond1.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskCond1.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by radBridgeMaskOffset1 the packet contains data that matches the content of radBridgeMaskPat1. false - Condition is valid if at the position specified by radBridgeMaskOffset1 the packet contains data that does not match the content of radBridgeMaskPat1.')
radBridgeMaskPat2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskPat2.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskPat2.setDescription('Describes the mask field which is either a 16 bit binary pattern, or four digit hexadecimal pattern.')
radBridgeMaskActiveBit2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskActiveBit2.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskActiveBit2.setDescription('Specifies the positions of the wild card characters (*) in the radBridgeMaskPat2 field.')
radBridgeMaskFrom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mac", 1), ("llc", 2), ("net", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskFrom2.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskFrom2.setDescription('Offset base of radBridgeMaskPat2 within the frame. Net can be in some cases the data start point.')
radBridgeMaskOffset2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskOffset2.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskOffset2.setDescription('Specifies the radBridgeMaskPat2 offset within the frame (in bytes) from the base defined in by radBridgeMaskForm2.The mask offset is an even decimal number in the range of 0 to 1518.')
radBridgeMaskCond2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskCond2.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskCond2.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by radBridgeMaskOffset2 the packet contains data that matches the content of radBridgeMaskPat2. false - Condition is valid if at the position specified by radBridgeMaskOffset2 the packet contains data that does not match the content of radBridgeMaskPat2.')
radBridgeMaskPat3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskPat3.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskPat3.setDescription('Describes the mask field which is either a 16 bit binary pattern, or four digit hexadecimal pattern.')
radBridgeMaskActiveBit3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskActiveBit3.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskActiveBit3.setDescription('Specifies the positions of the wild card characters (*) in the radBridgeMaskPat3 field.')
radBridgeMaskFrom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mac", 1), ("llc", 2), ("net", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskFrom3.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskFrom3.setDescription('Offset base of radBridgeMaskPat3 within the frame. Net can be in some cases the data start point.')
radBridgeMaskOffset3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskOffset3.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskOffset3.setDescription('Specifies the radBridgeMaskPat3 offset within the frame (in bytes) from the base defined in by radBridgeMaskForm3. The mask offset is an even decimal number in the range of 0 to 1518.')
radBridgeMaskCond3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskCond3.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskCond3.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by radBridgeMaskOffset3 the packet contains data that matches the content of radBridgeMaskPat3 false - Condition is valid if at the position specified by radBridgeMaskOffset3 the packet contains data that does not match the content of radBridgeMaskPat3.')
radBridgeMaskOper = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("block", 1), ("forward", 2), ("route", 3), ("forward-route", 4), ("high-priority", 5), ("noOp", 6), ("delete", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMaskOper.setStatus('current')
if mibBuilder.loadTexts: radBridgeMaskOper.setDescription('The type of action to be taken if the frame meets the conditions of the mask. noOp = disabled (mask remains on list, but is not active) delete = mask is removed from the list. ')
radBridgeCOD = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 4))
radBridgeCODParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1), )
if mibBuilder.loadTexts: radBridgeCODParamTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODParamTable.setDescription('The table of COD parameters ')
radBridgeCODEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeCODIfIndex"))
if mibBuilder.loadTexts: radBridgeCODEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODEntry.setDescription('Each radBridgeCODEntry consists of the following parameters')
radBridgeCODIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODIfIndex.setDescription('The interface to which this COD entry is applicable.')
radBridgeCODManualConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connect", 1), ("disconnect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODManualConnect.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODManualConnect.setDescription('The management station can start connection manually by setting this parameter')
radBridgeCODMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("answer", 1), ("originate", 2), ("disable", 3), ("answerAndOriginate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODMode.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODMode.setDescription('In answer mode only one incoming call may be accepted at a time. Other nodes attempting to access the local modem will receive a busy signal until the connection is terminated. (Answer mode has no difficulty supporting multiple remote connections to one local port, as blocking multiple incoming calls is just a modem function. Originate mode, on the other hand will only support a single local port to remote port connection). The disable parameter disables the COD utility for this interface. Choosing any other mode will enable the COD utility.')
radBridgeCODConnectDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODConnectDelay.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODConnectDelay.setDescription('The connect delay defines the minimum time period that the link must stay disconnected, between 2 succesive connections (in seconds).')
radBridgeCODisConnectDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODisConnectDelay.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODisConnectDelay.setDescription('The disconnect delay defines the minimum time period the link must stay connected, between 2 succesive disconnections (in seconds).')
radBridgeCODImplicitSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODImplicitSwitch.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODImplicitSwitch.setDescription('The inplicit switch allows the user to ignore implicit triggers provided by the COD software.')
radBridgeCODNumAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODNumAccess.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODNumAccess.setDescription('The number of successful connections that have been established since the COD has been reset.')
radBridgeCODTotalConnecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODTotalConnecTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTotalConnecTime.setDescription('The sum of all the connect time intervals since the COD was reset.')
radBridgeCODTimeTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2), )
if mibBuilder.loadTexts: radBridgeCODTimeTriggerTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerTable.setDescription('The table of COD parameters ')
radBridgeCODTimeTriggerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeCODTimeIfIndex"), (0, "RAD-MIB", "radBridgeCODDay"), (0, "RAD-MIB", "radBridgeCODTimeTriggerNum"))
if mibBuilder.loadTexts: radBridgeCODTimeTriggerEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerEntry.setDescription('Each radBridgeCODTimeTriggerEntry consists of the following parameters')
radBridgeCODTimeIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODTimeIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeIfIndex.setDescription('The interface to which this COD Time Trigger entry is applicable.')
radBridgeCODDay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("mon", 1), ("tue", 2), ("wed", 3), ("thu", 4), ("fri", 5), ("sat", 6), ("sun", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODDay.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODDay.setDescription(' The day of the week in which the dial up connection operates.')
radBridgeCODTimeTriggerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODTimeTriggerNum.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerNum.setDescription(' Every day of the week the user can configure 3 dial up connections.')
radBridgeCODTimeTriggerFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODTimeTriggerFrom.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerFrom.setDescription('Time to start Dial Up connection, in format hh:mm.')
radBridgeCODTimeTriggerTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODTimeTriggerTo.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerTo.setDescription('Time to terminate Dial Up connection, in format HH:MM.')
radBridgeCODTimeTriggerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODTimeTriggerStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTimeTriggerStatus.setDescription('The status of a table entry.')
radBridgeCODTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3))
radBridgeCODTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 1), )
if mibBuilder.loadTexts: radBridgeCODTrafficTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTrafficTable.setDescription('The table of COD Traffic trigger ')
radBridgeCODTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeCODProtocolType"))
if mibBuilder.loadTexts: radBridgeCODTrafficEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTrafficEntry.setDescription('Each radBridgeCODTrafficEntry consists of the following parameters.')
radBridgeCODProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("ipx", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODProtocolType.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODProtocolType.setDescription('The Protocol Type of the Traffic Table')
radBridgeCODTrafficTriggerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODTrafficTriggerStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTrafficTriggerStatus.setDescription('Command of Status of the Protocol Traffic Trigger')
radBridgeCODRemoteIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODRemoteIPAddr.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODRemoteIPAddr.setDescription(' This is the Remote IP Address')
radBridgeCODIPMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODIPMask.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODIPMask.setDescription(' This is the Mask of the Remote IP Address')
radBridgeCODTrafficTriggerProtType = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 3, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODTrafficTriggerProtType.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODTrafficTriggerProtType.setDescription('Protocol Type for the User Defined Protocol Traffic Trigger (3).')
radBridgeCODCondTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4), )
if mibBuilder.loadTexts: radBridgeCODCondTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODCondTable.setDescription('The table of COD Condition parameters ')
radBridgeCODCondEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeCODCondIfIndex"))
if mibBuilder.loadTexts: radBridgeCODCondEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODCondEntry.setDescription('Each radBridgeCODCondEntry consists of the following parameters')
radBridgeCODCondIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODCondIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODCondIfIndex.setDescription('The interface, this COD entry is applicable to.')
radBridgeCODOriginateConnectCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("onPowerOn", 1), ("whenAnyStationOnLan", 2), ("onTraffic", 3), ("onManualConnect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODOriginateConnectCondition.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODOriginateConnectCondition.setDescription(' This condition, allows the user to specify the condition under which the link is connected. The options are onPowerOn - On power on. whenAnyStationOnLan - When any station on lan. onTraffic - On traffic. The user can specify the condition/s for connection. The connection will be defined in CODSpecificOnTrafficConditionOID . onManualConnect - depends on radBridgeCODManualConnect OBJECT-TYPE (=connect). ')
radBridgeCODOriginateDisConnectCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noStationOnLan", 1), ("onTraffic", 2), ("onDelayFromConnectionOnRequest", 3), ("onManualDisConnect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODOriginateDisConnectCondition.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODOriginateDisConnectCondition.setDescription('This condition allows the user to specify the condition under which the link is disconnected. The options are: noStationOnLan - When there is no station on lan. Counts 15 minutes from the point the last frame from lan has been received. If no frame have been transmitted on lan by the end of this period, disconnect the connection. onTraffic - On traffic. The user can specify the condition/s for disconnection. The disconnection will be defined in CODSpecificOnTrafficConditionOID . onDelayFromConnectionOnRequest - On Delay From Connection On Request . The delay time period will be defined in CODOriginateDisConnectDelay . onManualDisConnect - depends on radBridgeCODManualConnect OBJECT-TYPE (=disconnect). ')
radBridgeCODOriginateDisConnectDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODOriginateDisConnectDelay.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODOriginateDisConnectDelay.setDescription('Delay time in seconds. ')
radBridgeCODAnswerConnectCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("onPowerOn", 1), ("whenAnyStationOnLan", 2), ("onTraffic", 3), ("onManualConnect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODAnswerConnectCondition.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODAnswerConnectCondition.setDescription('CODCondAnswerConnect allows the user to specify the condition under which the link is connected. The options are: onPowerOn - On power on. whenAnyStationOnLan - When any station on lan. onTraffic - On traffic. The user can specify the condition/s for connection. The connection will be defined in CODSpecificOnTrafficConditionOID . onManualConnect - depends on radBridgeCODManualConnect OBJECT-TYPE . ')
radBridgeCODSpecificOnTrafficOIDCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCODSpecificOnTrafficOIDCondition.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODSpecificOnTrafficOIDCondition.setDescription('A reference to a specific entry in the radBridgeMaskTable, which describes the particular COD condition . If Connect or Disconnect Conditions are not onTraffic, its value should be set to the OBJECT IDENTIFIER { 0 0 }. ')
radBridgeCODDisConnectMinimunFramesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 4, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeCODDisConnectMinimunFramesNumber.setStatus('current')
if mibBuilder.loadTexts: radBridgeCODDisConnectMinimunFramesNumber.setDescription('Frames rate.')
radBridgeIPX = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 5))
radBridgeIPXdriver = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 1))
radBridgeIPXRip = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2))
radBridgeIPXSap = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3))
radBridgeIPXForwarding = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("not-forwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXForwarding.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXForwarding.setDescription('The indication of whether this entity is acting as an IPX gateway in respect to the forwarding of datagrams received by, but not addressed to, this entity. IPX gateways forward datagrams. IPX hosts do not. Note that changing this parameter requiers RESET of the router.')
radBridgeIPXRipOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipOutPackets.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipOutPackets.setDescription('The total number of packets transmitted by RIP.')
radBridgeIPXRipInPackets = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipInPackets.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInPackets.setDescription('The total number of packets received by RIP. This will include any packets that are subsequently discarded.')
radBridgeIPXRipInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipInDiscards.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInDiscards.setDescription('The number of received packets discarded by RIP.')
radBridgeIPXRipTblNoOfEntries = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipTblNoOfEntries.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipTblNoOfEntries.setDescription('The max number of entries that exist in the RIP routing table.')
radBridgeIPXRipTblBcastTrigUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipTblBcastTrigUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipTblBcastTrigUpdateInterval.setDescription('The default time interval (in seconds)between triggered RIP updates on a broadcast type interface. A triggered update occurs when a change is detected in the routing database. This time interval delays the broadcasting of these updates so that changes on the network will not result in a lot of triggered updates.')
radBridgeIPXRipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6), )
if mibBuilder.loadTexts: radBridgeIPXRipTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipTable.setDescription('The routing table used by RIP to calculate routes to remote desination networks.')
radBridgeIPXRipTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeIPXRipDestNetwork"), (0, "RAD-MIB", "radBridgeIPXRipPolicy"))
if mibBuilder.loadTexts: radBridgeIPXRipTableEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipTableEntry.setDescription("The routing information for one of this entity's destination networks.")
radBridgeIPXRipDestNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipDestNetwork.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipDestNetwork.setDescription("The destination network address to which this entry's routing information pertains.")
radBridgeIPXRipPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("alternate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipPolicy.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipPolicy.setDescription('A value specifying the precidence of the route. A value of zero means that the route is the best route, a value of one means that the route is the second best route and so on.')
radBridgeIPXRipForwardingRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipForwardingRouter.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipForwardingRouter.setDescription("The IPX node address of the next hop (router) for the entry's associated destination network.")
radBridgeIPXRipNIC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipNIC.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipNIC.setDescription('An interface identifier specifying what IPX interface the next hop can be found on.')
radBridgeIPXRipTickMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipTickMetric.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipTickMetric.setDescription('The metric, in terms of transit time, associated with the route given by the entry. This time is in terms of 1/18ths of a second.')
radBridgeIPXRipHopMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipHopMetric.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipHopMetric.setDescription('The metric, in terms of distance , associated with the route given by the entry.')
radBridgeIPXRipAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipAgingTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipAgingTime.setDescription('The last time that the entry was updated. The time will be provided in terms of the MIB-I object sysUpTime.')
radBridgeIPXRipValueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("invalid", 3), ("semiDynamic", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipValueStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipValueStatus.setDescription('The entry status value; whether the entry is permanent (added statically), reachable or unreachable. In the latter two cases it would be added by RIP. A semiDynamic entry is an entry enterd manualy by the user and can be updated by the router.')
radBridgeIPXRipForwardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipForwardType.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipForwardType.setDescription('The type of route. Note that local(2) refers to a route for which the next hop is the final destination; remote(3) refers to a route for which the next hop is not the final destination.')
radBridgeIPXRipInfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 7), )
if mibBuilder.loadTexts: radBridgeIPXRipInfTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInfTable.setDescription('The RIP interface table.')
radBridgeIPXRipInfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 7, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeIPXRipInfIfIndex"))
if mibBuilder.loadTexts: radBridgeIPXRipInfEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInfEntry.setDescription('Each entry corresponds to one ifindex.')
radBridgeIPXRipInfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXRipInfIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInfIfIndex.setDescription('This value of Ifindex is same as radBridgeIPXIfIndex in the IPX Interface Table.')
radBridgeIPXRipInfBcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipInfBcastUpdate.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInfBcastUpdate.setDescription('The RIP periodic update interval, in seconds. Zero value corresponds to infinite interval.')
radBridgeIPXRipInfAgeMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 2, 7, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXRipInfAgeMultiplier.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXRipInfAgeMultiplier.setDescription('The holding multiplier for information received in RIP periodic updates. Zero value corresponds to infinite aging time.')
radBridgeIPXSapOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapOutPackets.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapOutPackets.setDescription('The total number of packets transmitted by SAP.')
radBridgeIPXSapInPackets = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapInPackets.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInPackets.setDescription('The total number of packets received by SAP. This will include any packets that are subsequently discarded.')
radBridgeIPXSapInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapInDiscards.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInDiscards.setDescription('The number of received packets discarded by SAP.')
radBridgeIPXSapTblNoOfEntries = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapTblNoOfEntries.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapTblNoOfEntries.setDescription('The max number of entries that exist in the SAP Server Information table.')
radBridgeIPXSapTblBcastTrigUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapTblBcastTrigUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapTblBcastTrigUpdateInterval.setDescription('The default time interval (in seconds) between triggered SAP updates on a broadcast style interface. A triggered update occurs when a change is detected in the service database. This time interval delays the transmission of these updates so that changes on the network will not result in a lot of triggered updates.')
radBridgeIPXSapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6), )
if mibBuilder.loadTexts: radBridgeIPXSapTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapTable.setDescription('The Server Information table is used by SAP to store information of services which are available on the internetwork.')
radBridgeIPXSapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeIPXSapServerType"), (0, "RAD-MIB", "radBridgeIPXSapName"))
if mibBuilder.loadTexts: radBridgeIPXSapTableEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapTableEntry.setDescription("The server information for one of this entity's server entries.")
radBridgeIPXSapServerType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapServerType.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapServerType.setDescription('The type of the server for which this entry pertains.')
radBridgeIPXSapName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(48, 48)).setFixedLength(48)).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapName.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapName.setDescription('The name of the server for which this entry pertains.')
radBridgeIPXSapNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapNetwork.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapNetwork.setDescription('The IPX network address of the host on which this server exists.')
radBridgeIPXSapNode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapNode.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapNode.setDescription('The IPX node address of the host on which this server exists.')
radBridgeIPXSapSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapSocket.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapSocket.setDescription('The IPX socket number that is being used by the server to which this entry pertains.')
radBridgeIPXSapHopsToServer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapHopsToServer.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapHopsToServer.setDescription('The number of hops to the entity on which this server exists.')
radBridgeIPXSapNIC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapNIC.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapNIC.setDescription('An Network Interface Card identifier specifying what IPX interface the next hop can be found on.')
radBridgeIPXSapAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapAgingTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapAgingTime.setDescription('The last time that the entry was updated. The time will be provided in terms of the MIB-I object sysUpTime.')
radBridgeIPXSapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("permanent", 1), ("dynamic", 2), ("invalid", 3), ("semiDynamic", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapStatus.setDescription('The status of the entry.')
radBridgeIPXSapInfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 7), )
if mibBuilder.loadTexts: radBridgeIPXSapInfTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInfTable.setDescription('The Sap interface table.')
radBridgeIPXSapInfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 7, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeIPXSapInfIfIndex"))
if mibBuilder.loadTexts: radBridgeIPXSapInfEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInfEntry.setDescription('Each entry corresponds to one ifindex.')
radBridgeIPXSapInfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIPXSapInfIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInfIfIndex.setDescription('This value of Ifindex is same as radBridgeIPXIfIndex in the IPX Interface Table.')
radBridgeIPXSapInfBcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapInfBcastUpdate.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInfBcastUpdate.setDescription('The SAP periodic update interval, in seconds. Zero value corresponds to infinite interval.')
radBridgeIPXSapInfAgeMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 5, 3, 7, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeIPXSapInfAgeMultiplier.setStatus('current')
if mibBuilder.loadTexts: radBridgeIPXSapInfAgeMultiplier.setDescription('The holding multiplier for information received in SAP periodic updates. Zero value corresponds to infinite aging time.')
class GenAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(12, 12)
    fixedLength = 12

newMasking = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 6))
maskingMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingMaxEntries.setStatus('current')
if mibBuilder.loadTexts: maskingMaxEntries.setDescription('The maximum number of entries in the masking table.')
maskingCurrentEntries = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingCurrentEntries.setStatus('current')
if mibBuilder.loadTexts: maskingCurrentEntries.setDescription('The number of entries in the mask table.')
maskingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3), )
if mibBuilder.loadTexts: maskingTable.setStatus('current')
if mibBuilder.loadTexts: maskingTable.setDescription('This is the new masking scheme. Mask tables enable definition of forwarding restrictions and control of message flow in the internetwork. Each entry in this table defines a mask statement and an action defined by maskingOperation.')
maskingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1), ).setIndexNames((0, "RAD-MIB", "maskingType"), (0, "RAD-MIB", "maskingIfIndex"), (0, "RAD-MIB", "maskingIndex"))
if mibBuilder.loadTexts: maskingEntry.setStatus('current')
if mibBuilder.loadTexts: maskingEntry.setDescription('Defines the contents of each line in the mask table.')
maskingType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2), ("compress", 3), ("priority", 4), ("loadSharing", 5), ("facs", 6), ("codConnect", 7), ("codDisconnect", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingType.setStatus('current')
if mibBuilder.loadTexts: maskingType.setDescription('Defines the type of mask entry. ')
maskingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingIfIndex.setStatus('current')
if mibBuilder.loadTexts: maskingIfIndex.setDescription('Specifies the ifIndex of the interface to which the mask is applied.')
maskingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingIndex.setStatus('current')
if mibBuilder.loadTexts: maskingIndex.setDescription('An index to the masking table. This number should not be greater than maskingMaxEntries')
maskingProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3), ("sna", 4), ("netbios", 5), ("apple", 6), ("dec", 7), ("all", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingProtocolType.setStatus('current')
if mibBuilder.loadTexts: maskingProtocolType.setDescription('The base protocol for masking. IPX, IP, others.')
maskingSmartMaskOID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maskingSmartMaskOID.setStatus('current')
if mibBuilder.loadTexts: maskingSmartMaskOID.setDescription('A reference to a specific Smart mask table (old radBridgeMaskTable) which enables a more specific mask type. If this information is not available, its value should be set to the OBJECT IDENTIFIER { 0 0 }. ')
maskingFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("all", 2), ("broadcast", 3), ("multicast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingFrameType.setStatus('current')
if mibBuilder.loadTexts: maskingFrameType.setDescription('Enables the user to decide about frame type * all frame * just broadcast * just multicast.')
maskingFrameTypeCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingFrameTypeCondition.setStatus('current')
if mibBuilder.loadTexts: maskingFrameTypeCondition.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingFrameType the packet contains data that matches the content of maskingFrameType. fa lse - Condition is valid if at the position specified by maskingFrameType the packet contains data that does not match the content of maskingFrameType.')
maskingSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 8), GenAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSourceAddress.setStatus('current')
if mibBuilder.loadTexts: maskingSourceAddress.setDescription("The source address is according to the maskingMacOrNet and maskingProtocolType variables. In case of 'MAC' enter 6 bytes (48 bit) of source address. In case of 'NET' if the maskingProtocolType is IP, this is the IP address if the maskingProtocolType is IPX, this is the IPX address (nnnnmmmmmmss) nnnn - IPX net address mmmmmm - Node address (Mac) ss - IPX socket In case of 'Apple' nn - net address (4 nibbles) ss - socket (4 nibbles).")
maskingSourceActiveBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 9), GenAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSourceActiveBits.setStatus('current')
if mibBuilder.loadTexts: maskingSourceActiveBits.setDescription("Specifies the positions of the wild card characters (*) in the maskingSourceAddress field. Only the 1's bit will be taken in considerations.")
maskingSourceMacOrNet = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("macAddress", 1), ("netAddress", 2), ("ipRange", 3), ("appleAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSourceMacOrNet.setStatus('current')
if mibBuilder.loadTexts: maskingSourceMacOrNet.setDescription("The variable maskingSourceAddress and maskingSourceActiveBits will be treated as MAC, or NET address. - If maskingProtocolType = 'all', 'sna', 'netbios', dec or 'unknown', the maskingSourceMacOrNet can be macAddress only! - If maskingProtocolType = 'ip' the maskingSourceMacOrNet can be macAddress or netAddress or appleAddress. - If maskingProtocolType = 'ipx', the maskingSourceMacOrNet can be either macAddress or netAddress. - If maskingProtocolType = 'apple', the maskingSourceMacOrNet can be either macAddress or appleAddress.")
maskingSourceCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSourceCondition.setStatus('current')
if mibBuilder.loadTexts: maskingSourceCondition.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingSourceAddress (in conjunction with maskingSourceActiveBits) the packet contains data that matches the content of maskingSourceAddress. false - Condition is valid if at the position specified by maskingSourceAddress (in conjunction with maskingSourceActiveBits) the packet contains data that does not match the content of maskingSourceAddress.')
maskingDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 12), GenAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingDestAddress.setStatus('current')
if mibBuilder.loadTexts: maskingDestAddress.setDescription("If maskingFrameType = broadcast or multicast, this object is NOT APPLICABLE. If maskingFrameType = all or unknown, this object is applicable. The destination address is according to the maskingMacOrNet and maskingProtocolType variables. In case of 'MAC' enter 6 bytes (48 bit) of source address. In case of 'NET' if the maskingProtocolType is IP, this is the IP address if the maskingProtocolType is IPX, this is the IPX address (nnnnmmmmmmss) nnnn - IPX net address mmmmmm - Node address (Mac) ss - IPX socket. In case of 'Apple' nn - net address (4 nibbles) ss - socket (4 nibbles). The IPX socket entered here has priority over the value of maskingLowLevelProt, when it is ipxRip, ipxSap or ipxSpx, unless the entered IPX socket is don't care. ")
maskingDestActiveBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 13), GenAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingDestActiveBits.setStatus('current')
if mibBuilder.loadTexts: maskingDestActiveBits.setDescription("If maskingFrameType = broadcast or multicast, this object is NOT APPLICABLE. If maskingFrameType = all or unknown, this object is applicable. Specifies the positions of the wild card characters (*) in the maskingDestAddress field. Only the 1's bit will be taken in considerations.")
maskingDestMacOrNet = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("macAddress", 1), ("netAddress", 2), ("ipRange", 3), ("appleAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingDestMacOrNet.setStatus('current')
if mibBuilder.loadTexts: maskingDestMacOrNet.setDescription("If maskingFrameType = broadcast or multicast, this object is NOT APPLICABLE. If maskingFrameType = all or unknown, this object is applicable. - If maskingProtocolType = 'all', 'sna', 'netbios', dec or 'unknown', the maskingDestMacOrNet can be macAddress only! - If maskingProtocolType = 'ip' the maskingDestMacOrNet can be macAddress or netAddress or appleAddress. - If maskingProtocolType = 'ipx', the maskingDestMacOrNet can be either macAddress or netAddress. - If maskingProtocolType = 'apple', the maskingDestMacOrNet can be either macAddress or appleAddress. The variable maskingDestAddress and maskingDestActiveBits will be treated as MAC, or NET address. ")
maskingDestCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingDestCondition.setStatus('current')
if mibBuilder.loadTexts: maskingDestCondition.setDescription('If maskingFrameType = broadcast or multicast, this object is NOT APPLICABLE. If maskingFrameType = all or unknown, this object is applicable. Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingDestAddress (in conjunction with maskingDestActiveBits) the packet contains data that matches the content of maskingDestAddress. false - Condition is valid if at the position specified by maskingDestAddress (in conjunction with maskingDestActiveBits) the packet contains data that does not match the content of maskingDestAddress.')
maskingLowLevelProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 1), ("ipxRip", 2), ("ipxSap", 3), ("ipxSpx", 4), ("ipUdp", 5), ("ipTcp", 6), ("ipIcmp", 7), ("ipxNcp", 8), ("ipxWan", 9), ("ipxEco", 10), ("ipxErr", 11), ("ipxPep", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingLowLevelProt.setStatus('current')
if mibBuilder.loadTexts: maskingLowLevelProt.setDescription("This field is set in conjunction with the maskingProtocolType variable. This variable specifies the low level protocol. The IPX socket entered in maskingDestAddress has priority over the value of maskingLowLevelProt, when it is ipxRip, ipxSap or ipxSpx, unless the entered IPX socket is don't care.")
maskingLowLevelProtCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingLowLevelProtCondition.setStatus('current')
if mibBuilder.loadTexts: maskingLowLevelProtCondition.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingLowLevelProt the packet contains data that matches the content of maskingLowLevelProt. false - Condition is valid if at the position specified by maskingLowLevelProt the packet contains data that does not match the content of maskingLowLevelProt.')
maskingHighLevelProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingHighLevelProt.setStatus('current')
if mibBuilder.loadTexts: maskingHighLevelProt.setDescription("This field is set in connection to the maskingProtocolType variable. This variable specifies the high level protocols (application). As for today it supports just IP protocol stack. The object's value is a sum of the following instances values (selected by user): none (0), -- don't care ftp (1), ftpC (2), telnet (4), smtp (8), tftp (16), snmp (32), snmpTrap (64), ipRip (128), www (256), email (512), dns (1024), For Apple Protocol only: rtmp (2048), nbp (4096), atp (8192), aep (16384), zip (32768), adsp (65536), pap (131072), asp (262144) Example: if ftp(1), snmp(32) and snmpTrap(64) instances were selected, the value should be 97 (=1+32+64).")
maskingHighLevelProtCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingHighLevelProtCondition.setStatus('current')
if mibBuilder.loadTexts: maskingHighLevelProtCondition.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingHighLevelProt the packet contains data that matches the content of maskingHighLevelProt. false - Condition is valid if at the position specified by maskingHighLevelProt the packet contains data that does not match the content of maskingHighLevelProt.')
maskingPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingPortNum.setStatus('current')
if mibBuilder.loadTexts: maskingPortNum.setDescription("The port number is the same as in high level protocol. It specifies the dest. port in IP case or the dest. socket in case of IPX & apple protocols. IP - This object is applicable only if none (0) value was selected in maskingHighLevelProt. IPX - This object is applicable only if the socket entered in maskingDestAddress is 'don't care'(00) AND maskingLowLevelProt is NOT ipxRip or ipxSap. Apple - This option is applicable only if the socket entered in maskingDestAddress is 'don't care'(00).")
maskingPortNumCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingPortNumCondition.setStatus('current')
if mibBuilder.loadTexts: maskingPortNumCondition.setDescription('Specifies the logical condition of the mask pattern: true - Condition is valid if at the position specified by maskingPortNum the packet contains data that matches the content of maskingPortNum. false - Condition is valid if at the position specified by maskingPortNum the packet contains data that does not match the content of maskingPortNum. This object is applicable only when maskingPortNum is applicable.')
maskingOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("block", 1), ("forward", 2), ("route", 3), ("forward-route", 4), ("high-priority", 5), ("noOp", 6), ("delete", 7), ("smartMask", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingOperation.setStatus('current')
if mibBuilder.loadTexts: maskingOperation.setDescription("The type of action to be taken if the frame meets the conditions of the mask. noOp = disabled (mask remains on list, but is not active) delete = mask is removed from the list. smartMask = the operation and destination of the mask will be determined by the objects of the Smart Table (old masking table: radBridgeMaskTable). If maskingType is codConnect, the 'block' value is NOT allowed. If maskingType is codDisconnect, the 'forward' value is NOT allowed.")
maskingSrcPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSrcPortNum.setStatus('current')
if mibBuilder.loadTexts: maskingSrcPortNum.setDescription("The source port number. For IP: No Condition. For IPX: This object is applicable only if the socket entered in maskingSourceAddress is don't care (00) and maskingLowLevelProt is NOT ipxRip or ipxSap. For Apple:This object is applicable only if the socket entered in maskingSourceAddress is don't care (00). ")
maskingSrcPortNumCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 6, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maskingSrcPortNumCondition.setStatus('current')
if mibBuilder.loadTexts: maskingSrcPortNumCondition.setDescription("The same as 'maskingPortNumCondition'. Relates to source port.")
radBridgePerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 7))
radBridgeCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1), )
if mibBuilder.loadTexts: radBridgeCurrentTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTable.setDescription('The RAD Bridge Current table.')
radBridgeCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeCurrentIndex"))
if mibBuilder.loadTexts: radBridgeCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentEntry.setDescription('An entry in the RAD Bridge Current table.')
radBridgeCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentIndex.setDescription('The index of the Bridge interface or Bridge Port. It may be ifIndex.')
radBridgeCurrentIngressFilteringDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentIngressFilteringDiscardedFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentIngressFilteringDiscardedFrames.setDescription('The counter associated with the number of Discarded Frames upon Ingress Filtering, encountered by a Bridge interface in the current 15 minute interval.')
radBridgeCurrentFrameTypeDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentFrameTypeDiscardedFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentFrameTypeDiscardedFrames.setDescription('The counter associated with the number of Discarded Frames upon Frame Type and Tagging Mismatch, encountered by a Bridge interface in the current 15 minute interval.')
radBridgeCurrentRxCorrectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectFrames.setDescription('The counter associated with the number of Received Correct Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentRxCorrectBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectBytes.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectBytes.setDescription('The counter associated with the number of Received Correct Bytes, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentRxCorrectBytesHCOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectBytesHCOverflow.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentRxCorrectBytesHCOverflow.setDescription('The counter associated with the number of times the associated radBridgeCurrentRxCorrectBytes counter has overflowed.')
radBridgeCurrentRxBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentRxBcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentRxBcastFrames.setDescription('The counter associated with the number of Received Broadcast Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentRxMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentRxMcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentRxMcastFrames.setDescription('The counter associated with the number of Received Multicast Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentTxCorrectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectFrames.setDescription('The counter associated with the number of Transmitted Correct Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentTxCorrectBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectBytes.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectBytes.setDescription('The counter associated with the number of Transmitted Correct Bytes, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentTxCorrectBytesHCOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectBytesHCOverflow.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxCorrectBytesHCOverflow.setDescription('The counter associated with the number of times the associated radBridgeCurrentTxCorrectBytes counter has overflowed.')
radBridgeCurrentTxBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxBcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxBcastFrames.setDescription('The counter associated with the number of Transmitted Broadcast Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentTxMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxMcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxMcastFrames.setDescription('The counter associated with the number of Transmitted Multicast Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeCurrentTxDropFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeCurrentTxDropFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeCurrentTxDropFrames.setDescription('The counter associated with the number of Transmitted Dropped Frames, encountered by a Bridge Port in the current 15 minute interval.')
radBridgeIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2), )
if mibBuilder.loadTexts: radBridgeIntervalTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTable.setDescription('The RAD Bridge Interval table.')
radBridgeIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeIntervalIndex"), (0, "RAD-MIB", "radBridgeIntervalNumber"))
if mibBuilder.loadTexts: radBridgeIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalEntry.setDescription('An entry in the RAD Bridge Interval table.')
radBridgeIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalIndex.setDescription('The index of the bridge interface or Bridge Port. It may be ifIndex.')
radBridgeIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals exist).')
radBridgeIntervalIngressFilteringDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalIngressFilteringDiscardedFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalIngressFilteringDiscardedFrames.setDescription('The counter associated with the number of Discarded Frames upon Ingress Filtering, encountered by a Bridge interface in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalFrameTypeDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalFrameTypeDiscardedFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalFrameTypeDiscardedFrames.setDescription('The counter associated with the number of Discarded Frames upon Frame Type and Tagging Mismatch, encountered by a Bridge interface in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalRxCorrectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectFrames.setDescription('The counter associated with the number of Received Correct Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalRxCorrectBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectBytes.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectBytes.setDescription('The counter associated with the number of Received Correct Bytes, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalRxCorrectBytesHCOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectBytesHCOverflow.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalRxCorrectBytesHCOverflow.setDescription('The counter associated with the number of times the associated radBridgeIntervalRxCorrectBytes counter has overflowed.')
radBridgeIntervalRxBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalRxBcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalRxBcastFrames.setDescription('The counter associated with the number of Received Broadcast Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalRxMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalRxMcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalRxMcastFrames.setDescription('The counter associated with the number of Received Multicast Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalTxCorrectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectFrames.setDescription('The counter associated with the number of Transmitted Correct Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalTxCorrectBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectBytes.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectBytes.setDescription('The counter associated with the number of Transmitted Correct Bytes, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalTxCorrectBytesHCOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectBytesHCOverflow.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxCorrectBytesHCOverflow.setDescription('The counter associated with the number of times the associated radBridgeIntervalTxCorrectBytes counter has overflowed.')
radBridgeIntervalTxBcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxBcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxBcastFrames.setDescription('The counter associated with the number of Transmitted Broadcast Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalTxMcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxMcastFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxMcastFrames.setDescription('The counter associated with the number of Transmitted Multicast Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgeIntervalTxDropFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 7, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeIntervalTxDropFrames.setStatus('current')
if mibBuilder.loadTexts: radBridgeIntervalTxDropFrames.setDescription('The counter associated with the number of Transmitted Dropped Frames, encountered by a Bridge Port in one of the previous 96, individual 15 minute, intervals.')
radBridgePortBaseVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 8))
radBridgePortBaseVlanTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1), )
if mibBuilder.loadTexts: radBridgePortBaseVlanTable.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanTable.setDescription('A table containing static configuration information for each VLAN configured into the device by management. All entries are permanent and will be restored after the device is reset.')
radBridgePortBaseVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgePortBaseVlanCnfgIdx"), (0, "RAD-MIB", "radBridgePortBaseVlanIdx"))
if mibBuilder.loadTexts: radBridgePortBaseVlanEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanEntry.setDescription('Static information for a VLAN configured into the device by (local or network) management.')
radBridgePortBaseVlanCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: radBridgePortBaseVlanCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanCnfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer. 255=Temporary Cnfg (when relevant, Set is done only to this configuration). For Agents that support only one configuration, this object will be constant=1. ')
radBridgePortBaseVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: radBridgePortBaseVlanIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanIdx.setDescription('Index of the port based VLAN.')
radBridgePortBaseVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortBaseVlanName.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanName.setDescription('An administratively assigned string, which may be used to identify the the port based VLAN.')
radBridgePortBaseVlanEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 4), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortBaseVlanEgressPorts.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanEgressPorts.setDescription('The set of ports which are permanently assigned to the egress list for this port based VLAN by management. The default value of this object is a string of zeros.')
radBridgePortBaseVlanVirtualGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 5), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortBaseVlanVirtualGroups.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanVirtualGroups.setDescription('The set of Virtual Groups which are permanently assigned to this port based VLAN by management. (read Virtual Group instead of port in PortList Textual Convention) The default value of this object is a string of zeros.')
radBridgePortBaseVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortBaseVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanRowStatus.setDescription('This object enable user to create/delete entries in this table.')
radBridgePortBaseVlanMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortBaseVlanMng.setStatus('current')
if mibBuilder.loadTexts: radBridgePortBaseVlanMng.setDescription('This object allows user to enable/disable management traffic on this VLAN. disable - only non-management data is allowed. enable - mixture of management traffic 0with other types of data is allowed.')
radBridgePortVlanMemberTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2), )
if mibBuilder.loadTexts: radBridgePortVlanMemberTable.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberTable.setDescription('The Bridge Ports-VLAN Membership table. This table enables the user to assign: - Several VLANs to a Port. - Several Ports to a VLAN.')
radBridgePortVlanMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2, 1), ).setIndexNames((0, "RAD-MIB", "radBridgePortVlanMemberBridgeIdx"), (0, "RAD-MIB", "radBridgePortVlanMemberPortIdx"), (0, "RAD-MIB", "radBridgePortVlanMemberVlanId"))
if mibBuilder.loadTexts: radBridgePortVlanMemberEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberEntry.setDescription('An entry in the Bridge Ports-VLANs Memebership table.')
radBridgePortVlanMemberBridgeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgePortVlanMemberBridgeIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberBridgeIdx.setDescription('This object indicates the Bridge Index.')
radBridgePortVlanMemberPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgePortVlanMemberPortIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberPortIdx.setDescription("This object indicates the Bridge's Port Index. For some cases, it can be used as the Port ofIndex.")
radBridgePortVlanMemberVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgePortVlanMemberVlanId.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberVlanId.setDescription('This object indicates the VLAN ID.')
radBridgePortVlanMemberRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 8, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgePortVlanMemberRowStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgePortVlanMemberRowStatus.setDescription('This object enables the user to create/delete entries in this table.')
radBridgeGenCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 9))
radBridgeGenFlowTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1), )
if mibBuilder.loadTexts: radBridgeGenFlowTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowTable.setDescription('A table containing static configuration information for Bridge configured into the device by (local or network) management. All entries are permanent and will be restored after the device is reset.')
radBridgeGenFlowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeGenFlowCnfgIdx"), (0, "RAD-MIB", "radBridgeGenFlowIdx"))
if mibBuilder.loadTexts: radBridgeGenFlowEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowEntry.setDescription('Static information for a Bridge configured into the device by management.')
radBridgeGenFlowCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: radBridgeGenFlowCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowCnfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer. 255=Temporary Cnfg (when relevant Set is done only to this configuration). For Agents that support only one configuration, this object will be constant=1. This object can be used to carry additional indexing (e.g port index) when needed.')
radBridgeGenFlowIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: radBridgeGenFlowIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowIdx.setDescription('For Agent having more than one bridge, this index may be used as bridge index ')
radBridgeGenFlowRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowRowStatus.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowRowStatus.setDescription('This object enable user to create/delete entries in this table.')
radBridgeGenFlowFloodOrBcastMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowFloodOrBcastMaxRate.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowFloodOrBcastMaxRate.setDescription('This object controls maximum Flooding or Broadcast Rate: Max number of multicast along with unknown or flooded unicast frames allowed to enter any port. The number can be presented either as percentage of bandwidth, or bandwidth in Kbps. Once the limit is exceeded, any multicast or flooded frame entering from the port is discarded For RIC-155, and FCD-155 valid values are 3% , 6%, 12% and 100% = No Limit')
radBridgeGenFlowQosMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("vlanTag", 2), ("dscp", 3), ("dscpAndVlanTag", 4), ("vlanTagAndDscp", 5), ("none", 6), ("tos", 7), ("perPort", 8), ("ipPrecedence", 9), ("dsField", 10), ("vlanTagAndTos", 11), ("tosAndVlanTag", 12), ("vlanTagAndIpPrecedence", 13), ("ipPrecedenceAndVlanTag", 14), ("vlanTagAndDsField", 15), ("dsFieldAndVlanTag", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowQosMode.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowQosMode.setDescription('This object controls Quality of Service mode. User may select which field(s) (in case of fields - which one has precedence) will affect prioritization of data between egress queues.')
radBridgeGenFlowSchedulingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("wfq", 2), ("sp", 3), ("atmCos", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowSchedulingMode.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowSchedulingMode.setDescription('This object controls which scheduling mode is used: Weighted Fair Queuing (WFQ) scheme, Strict Priority (SP) or ATM CoS')
radBridgeGenFlowBasicClassification = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("none", 2), ("port", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowBasicClassification.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowBasicClassification.setDescription('This object defines whether Classification based on Port should be taken into account (either as default, or in addition to other classifications).')
radBridgeGenFlowMulticastTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowMulticastTrafficClass.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowMulticastTrafficClass.setDescription('The Traffic Class the received Multicast frame is mapped to.')
radBridgeGenFlowBroadcastTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowBroadcastTrafficClass.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowBroadcastTrafficClass.setDescription('The Traffic Class the received Broadcast frame is mapped to.')
radBridgeGenFlowUnkownUnicastTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeGenFlowUnkownUnicastTrafficClass.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenFlowUnkownUnicastTrafficClass.setDescription('The Traffic Class the received Unkonwn Unicast frame is mapped to.')
radBridgeDot1qVlanStaticTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 2), )
if mibBuilder.loadTexts: radBridgeDot1qVlanStaticTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeDot1qVlanStaticTable.setDescription('A table containing static configuration information for each VLAN configured into the device by (local or network) management. All entries are permanent and will be restored after the device is reset.')
radBridgeDot1qVlanStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 2, 1), )
dot1qVlanStaticEntry.registerAugmentions(("RAD-MIB", "radBridgeDot1qVlanStaticEntry"))
radBridgeDot1qVlanStaticEntry.setIndexNames(*dot1qVlanStaticEntry.getIndexNames())
if mibBuilder.loadTexts: radBridgeDot1qVlanStaticEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeDot1qVlanStaticEntry.setDescription('Static information for a VLAN configured into the device by (local or network) management.')
radBridgeDot1qVlanTaggedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 2, 1, 1), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeDot1qVlanTaggedPorts.setStatus('current')
if mibBuilder.loadTexts: radBridgeDot1qVlanTaggedPorts.setDescription('The set of ports which should transmit egress packets for this VLAN as tagged.')
radBridgeDot1qVlanUnmodifiedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 2, 1, 2), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeDot1qVlanUnmodifiedPorts.setStatus('current')
if mibBuilder.loadTexts: radBridgeDot1qVlanUnmodifiedPorts.setDescription('The set of ports which should transmit egress packets for this VLAN as unmodified.')
radBridgeDot1qVlanSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radBridgeDot1qVlanSplitHorizon.setStatus('current')
if mibBuilder.loadTexts: radBridgeDot1qVlanSplitHorizon.setDescription("When 'enable (3)', packets having this VLAN will not be switched back to other bridge ports which are members of this VLAN.")
radBridgeStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 10))
radBridgeInvBasePortTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 10, 1), )
if mibBuilder.loadTexts: radBridgeInvBasePortTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeInvBasePortTable.setDescription('An inversed table to dot1dBasePortTable from RFC1493 with reduced information. This table index is known to the NMS and this way the needed information can be received by just one Get command, instead of searching the entire dot1dBasePortTable (where it is an attribute). ')
radBridgeInvBasePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 10, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeInvBasePortIfIndex"))
if mibBuilder.loadTexts: radBridgeInvBasePortEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeInvBasePortEntry.setDescription('The bridge port number for each bridge port interface index.')
radBridgeInvBasePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeInvBasePortIfIndex.setStatus('current')
if mibBuilder.loadTexts: radBridgeInvBasePortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in MIB-II, for the interface corresponding to this Bridge port.')
radBridgeInvBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeInvBasePort.setStatus('current')
if mibBuilder.loadTexts: radBridgeInvBasePort.setDescription('The Bridge port number.')
radBridgeStp = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 11))
radBridgeStpCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1), )
if mibBuilder.loadTexts: radBridgeStpCnfgTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgTable.setDescription('STP Configuration table. STP=Spanning Tree Protocol. It includes STP configurable parameters that in BRIDGE-MIB are scalars, while we need them per card/bridge/interface and per different configurations.')
radBridgeStpCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeStpCnfgIdx1"), (0, "RAD-MIB", "radBridgeStpCnfgIdx2"))
if mibBuilder.loadTexts: radBridgeStpCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgEntry.setDescription('An entry in the radBridgeStpCnfgTable.')
radBridgeStpCnfgIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: radBridgeStpCnfgIdx1.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgIdx1.setDescription('This object indicates the Index of the Agent Configuration the following objects refer to. For Agents that support more than one configuration: 255=Temporary Cnfg ; Set can be done only to this configuration. For Agents that support only one configuration, this object will be constant=1.')
radBridgeStpCnfgIdx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: radBridgeStpCnfgIdx2.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgIdx2.setDescription('For Agents having the table objects per Card/Bridge/Interface this will be the index of the Card/Bridge/Interface used.')
radBridgeStpCnfgForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 3), Timeout().subtype(subtypeSpec=ValueRangeConstraint(400, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeStpCnfgForwardDelay.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgForwardDelay.setDescription('The value that the bridge of radBridgeStpCnfgIdx2 uses for Forward Delay when this bridge is acting as the root. Note that the range for this parameter is related to the value of radBridgeStpCnfgMaxAge (according to 802.1D-1990 for the similar scalars of BRIDGE-MIB). The granularity of this timer is specified by 802.1D-1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
radBridgeStpCnfgMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 4), Timeout().subtype(subtypeSpec=ValueRangeConstraint(600, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeStpCnfgMaxAge.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgMaxAge.setDescription('The value that the bridge of radBridgeStpCnfgIdx2 uses for MaxAge when this bridge is acting as the root. Note that the range for this parameter is related to the value of radBridgeStpCnfgHelloTime (according to 802.1D-1990 for the similar scalars of BRIDGE-MIB). The granularity of this timer is specified by 802.1D-1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
radBridgeStpCnfgHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 5), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeStpCnfgHelloTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgHelloTime.setDescription('The value that the bridge of radBridgeStpCnfgIdx2 uses for Hello Time when this bridge is acting as the root. The granularity of this timer is specified by 802.1D-1990 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
radBridgeStpCnfgPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeStpCnfgPriority.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID, per radBridgeStpCnfgIdx2 instance.')
radBridgeStpCnfgStpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("stp", 2), ("rstp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeStpCnfgStpVersion.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpCnfgStpVersion.setDescription('This object determines the STP version used: stp - usual Spanning Tree Protocol. rstp - Rapid Spanning Tree Protocol.')
radBridgeStpStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2), )
if mibBuilder.loadTexts: radBridgeStpStatTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatTable.setDescription('STP Status table. STP=Spanning Tree Protocol. It includes STP status parameters that in BRIDGE-MIB are scalars, while we need them per card/bridge/interface. For devices that have several configurations, this table is for Status of the Active configuration.')
radBridgeStpStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeStpStatIdx"))
if mibBuilder.loadTexts: radBridgeStpStatEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatEntry.setDescription('An entry in the radBridgeStpStatTable.')
radBridgeStpStatIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: radBridgeStpStatIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatIdx.setDescription('For Agents having the table objects per Card/Bridge/Interface this will be the index of the Card/Bridge/Interface used.')
radBridgeStpStatForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 2), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeStpStatForwardDelay.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in each of the Listening and Learning states, which precede the Forwarding state. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. [Note that this value is the one that this bridge is currently using, in contrast to radBridgeStpCnfgForwardDelay which is the value that this bridge would start using if/when this bridge were to become the root.]')
radBridgeStpStatMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 3), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeStpStatMaxAge.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
radBridgeStpStatHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 4), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeStpStatHelloTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
radBridgeStpStatDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeStpStatDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
radBridgeStpStatRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 11, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radBridgeStpStatRootCost.setStatus('current')
if mibBuilder.loadTexts: radBridgeStpStatRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
radBridgeForwardingMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("transparent", 2), ("filter", 3), ("filterTagged", 4), ("transparentTagged", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeForwardingMode.setStatus('current')
if mibBuilder.loadTexts: radBridgeForwardingMode.setDescription('This object determines the Bridge Forwarding Mode: transparent - Forward all frames received (not dependent on VLAN). filter - Filter frames received according to MAC Address. filterTagged = Filter frames received according to VLAN. transparentTagged = VLAN aware + Transparent.')
radBridgePort = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4, 1, 13))
radBridgePortCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1), )
if mibBuilder.loadTexts: radBridgePortCnfgTable.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgTable.setDescription('The Bridge Port Configuration Table.')
radBridgePortCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1), ).setIndexNames((0, "RAD-MIB", "radBridgePortCnfgIdx"), (0, "RAD-MIB", "radBridgePortCnfgPrtIdx"))
if mibBuilder.loadTexts: radBridgePortCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgEntry.setDescription('An entry in the table.')
radBridgePortCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: radBridgePortCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgIdx.setDescription('The first index of the table. It can serve for Configuration index, Bridge index or other.')
radBridgePortCnfgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: radBridgePortCnfgPrtIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgPrtIdx.setDescription('This object indicates the Bridge Port index.')
radBridgePortCnfgMaxMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgMaxMacAddr.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgMaxMacAddr.setDescription('This object indicates the maximum number of total MAC Addresses (static and learned) supported by this Bridge Port.')
radBridgePortCnfgMngFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgMngFlow.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgMngFlow.setDescription('This object indicates whether this Bridge Port is dedicated for management flow.')
radBridgePortCnfgMcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flooding", 1), ("forwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgMcastMode.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgMcastMode.setDescription("This object indicates this Bridge Port's Multicast Mode: flooding (1) - flood multicast MAC addresses forwarding (2) - forward multicast MAC addresses to the subnet indicated.")
radBridgePortCnfgDefaultVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgDefaultVpi.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgDefaultVpi.setDescription("This object indicates the VPI of this Bridge Port's Default VCL. An incoming frame with priority that is not assigned to any VCL will be transferred to the Default VCL.")
radBridgePortCnfgDefaultVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgDefaultVci.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgDefaultVci.setDescription("This object indicates the VCI of this Bridge Port's Default VCL. An incoming frame with priority that is not assigned to any VCL will be transferred to the Default VCL.")
radBridgePortCnfgStatVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgStatVlanId.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgStatVlanId.setDescription('This object indicates the selected VlanId of the bridge port on which statistics are being collected. 0=no Statistics collected for VLAN on this bridge port.')
radBridgePortCnfgIngressMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgIngressMtu.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgIngressMtu.setDescription('The size of the largest packet which can be received on the interface, specified in octets.')
radBridgePortCnfgEgressMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgEgressMtu.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgEgressMtu.setDescription('The size of the largest packet which can be sent on the interface, specified in octets.')
radBridgePortCnfgDot1x = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 13, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgePortCnfgDot1x.setStatus('current')
if mibBuilder.loadTexts: radBridgePortCnfgDot1x.setDescription('This feature is currently supported via the variable ethIfTable.ethDot1xEnable. Determnines if the Port-Based Network Access Protocol (IEEE-802.1x)is enabled for the bridge Port.')
radDot1qPortVlanTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3), )
if mibBuilder.loadTexts: radDot1qPortVlanTable.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortVlanTable.setDescription('A table containing control and status information for VLAN configuration per port.')
radDot1qPortVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1), )
dot1dBasePortEntry.registerAugmentions(("RAD-MIB", "radDot1qPortVlanEntry"))
radDot1qPortVlanEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: radDot1qPortVlanEntry.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortVlanEntry.setDescription('Information controlling VLAN configuration for a port. This is indexed by dot1dBasePort.')
radDot1qPortStacking = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("unmodify", 2), ("tag", 3), ("stack", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortStacking.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortStacking.setDescription('This object indicates the port stacking operation: unmodify (2) = Do not add Tag. tag (3) = Add Tag to Untagged Frames. stack (4) = Add Tag to all Frames.')
radDot1qPortCopyOriginVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortCopyOriginVlanPriority.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortCopyOriginVlanPriority.setDescription('This object indicates whether use the original VLAN Priority of the frame, as the priority of the VLAN added by this port.')
radDot1qPortDefaultVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortDefaultVlanPriority.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortDefaultVlanPriority.setDescription('Default VLAN Frame priority of the VLAN added by this port.')
radDot1qPortTagStripping = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortTagStripping.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortTagStripping.setDescription('This object indicates whether remove a tag from the frame on this port, frame with double tag will remain with one tag and frame with one tag will remain untagged.')
radDot1qPortEgressTagHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("none", 2), ("stacking", 3), ("stripping", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortEgressTagHandling.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortEgressTagHandling.setDescription('This object indicates how is the Egress VLAN Tag processed. It is mainly for use with Double Tagging.')
radDot1qPortIngressTagHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("none", 2), ("stacking", 3), ("stripping", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortIngressTagHandling.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortIngressTagHandling.setDescription('This object indicates how is the Ingress VLAN Tag processed. It is mainly for use with Double Tagging.')
radDot1qPortReplaceVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortReplaceVlanPriority.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortReplaceVlanPriority.setDescription("This object indicates whether for each received tagged frame on this Bridge Port - VLAN Priority will be replaced by another Priority. no(2) = no repacement yes(3) = VLAN Priority will be replaced For Egate-100: When value is 'yes', the original Priority is replaced by the Default Priority.")
radDot1qPortVlanEthType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortVlanEthType.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortVlanEthType.setDescription('This object indicates the Ethernet Type. For some devices, it is applicable only when radDot1qPortStacking = stack.')
radDot1qPortVlanCnodeLevel1Agent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radDot1qPortVlanCnodeLevel1Agent.setStatus('current')
if mibBuilder.loadTexts: radDot1qPortVlanCnodeLevel1Agent.setDescription('Specify if a Level 1 cNode agent is enabled or not for the bridge port.')
radBridgeGenCfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4), )
if mibBuilder.loadTexts: radBridgeGenCfgTable.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenCfgTable.setDescription('A table containing Bridge configuration parameters.')
radBridgeGenCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1), ).setIndexNames((0, "RAD-MIB", "radBridgeGenCfgIdx"), (0, "RAD-MIB", "radBridgeGenCfgIdx2"))
if mibBuilder.loadTexts: radBridgeGenCfgEntry.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenCfgEntry.setDescription('Describes an entry in the radBridgeGenCfgTable.')
radBridgeGenCfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: radBridgeGenCfgIdx.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenCfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer. 255=Temporary Cnfg. For Agents that support only one Configuration, this object will be constant=1. ')
radBridgeGenCfgIdx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 2), Integer32())
if mibBuilder.loadTexts: radBridgeGenCfgIdx2.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenCfgIdx2.setDescription('For Agents having more than one bridge, this index may be used as bridge index ')
radBridgeGenCfgBridgeAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 255))).clone(namedValues=NamedValues(("deleteLanTab", 7), ("noOp", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeGenCfgBridgeAction.setStatus('current')
if mibBuilder.loadTexts: radBridgeGenCfgBridgeAction.setDescription('This variable enables the operator to perform one of the specified actions on the tables maintained by the Bridge. After performing the action, Agent will automatically Set the value of this variable to noOp(255).')
radBridgeAgingTimeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeAgingTimeSec.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: radBridgeAgingTimeSec.setStatus('current')
if mibBuilder.loadTexts: radBridgeAgingTimeSec.setDescription('This variable duplicates scalar object dot1dTpAgingTimeThe of BRIDGE-MIB with configuration index and Bridge index. It defines the timeout period in seconds for aging out dynamically learned forwarding information. 802.1D-1990 recommends a default of 300 seconds.')
radBridgeMngVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMngVlanId.setStatus('current')
if mibBuilder.loadTexts: radBridgeMngVlanId.setDescription('This variable indicates the VLAN ID used for remote management traffic. 0 = Not Applicable.')
radBridgeLoopDetectVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeLoopDetectVlanId.setStatus('current')
if mibBuilder.loadTexts: radBridgeLoopDetectVlanId.setDescription('This variable indicates the VLAN ID used for Loop Detection packets. Valid values: 1 - 4095: VLAN ID 0 - Means that the Loop Detection is Disabled.')
radBridgeSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enabled", 3), ("vlanBased", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeSplitHorizon.setStatus('current')
if mibBuilder.loadTexts: radBridgeSplitHorizon.setDescription("This object configure 'split horizon' switching between bridge Ports. - disable - normal (VLAN aware) bridge behavior. - enable - all packets, regardless their VLAN, coming from user side are blocked from being switched back to other user side bridge ports. - vlanBased - split horizon behavior is applicable only for specific VLANs, according to radBridgeDot1qVlanSplitHorizon.")
radBridgeEthType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 4, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeEthType.setStatus('current')
if mibBuilder.loadTexts: radBridgeEthType.setDescription('Value of Ethertype field in Ethernet frame. This field indicates which protocol is being transported in an ethernet frame.')
radBridgeAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("infinite", 2), ("finite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeAgingTime.setStatus('current')
if mibBuilder.loadTexts: radBridgeAgingTime.setDescription('This variable defines whether the Aging Time will be finite or infinite. When selecting the finite (3) value, the exact time will be determined by another variable of the standard MIB (ex. 1493.dot1dTpAgingTime). or by radBridgeAgingTime below.')
radBridgeMngFlow = MibScalar((1, 3, 6, 1, 4, 1, 164, 4, 1, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radBridgeMngFlow.setStatus('current')
if mibBuilder.loadTexts: radBridgeMngFlow.setDescription('This variable defines whether the Management Flow is passed through the bridge (enable) or not (disable).')
wanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1))
muxHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2))
chasWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 1))
agnWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2))
mdlWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3))
prtWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4))
mapWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 5))
diverseIfWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6))
statAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1))
cnfgAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2))
cmprAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3))
alrBuffGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4))
agnFlipDb = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5))
agnSa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 6))
agnListDecoding = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7))
agnSystemDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8))
agnVoiceSwitching = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9))
agnSigProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10))
agnSystemTs = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11))
systemVoice = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12))
statMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1))
cnfgMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2))
cmprMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3))
statPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1))
cnfgPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2))
cmprPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3))
agnMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 1))
mdlMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2))
prtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3))
statPrtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1))
cnfgPrtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2))
statisPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3))
prtFrStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1))
prtCrStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2))
prtDlciStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3))
prtT1Statis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4))
prtClCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1))
prtPh1MlCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2))
prtPhPlCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3))
prtLs2Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4))
prtHs4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7))
prtHsiCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8))
prtPVc4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9))
prtHsrCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10))
prtMbeCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11))
prtTreCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12))
prtLs6Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13))
prtVc3Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14))
prtVcPbxCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15))
prtIsdnCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16))
prtLogicalCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17))
prtFrPlusCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18))
prtMl4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19))
prtAcmCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20))
prtE2Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21))
prtLanWanCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22))
chasVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasVersion.setStatus('current')
if mibBuilder.loadTexts: chasVersion.setDescription('An ASCII string for description and display of the agent chassis version.')
chasTotalNoOfSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfSlt.setStatus('current')
if mibBuilder.loadTexts: chasTotalNoOfSlt.setDescription('This entry indicates the number of physical slots in the chassis.')
chasTotalNoOfIoSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfIoSlt.setStatus('current')
if mibBuilder.loadTexts: chasTotalNoOfIoSlt.setDescription('This entry indicates the total number of physical IO slots in the chassis, (not all slots hardware should be occupied and active) .')
chasTotalNoOfPsSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfPsSlt.setStatus('current')
if mibBuilder.loadTexts: chasTotalNoOfPsSlt.setDescription('This entry indicates the number of physical Power Supply slots in the chassis.')
chasTotalNoOfClSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfClSlt.setStatus('current')
if mibBuilder.loadTexts: chasTotalNoOfClSlt.setDescription('This entry indicates the number of physical Common Logic slots in the chassis.')
agnSDateFormat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ddMMYYYY", 1), ("mmDDYYYY", 2), ("yyyyDDMM", 3), ("yyyyMMDD", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSDateFormat.setStatus('current')
if mibBuilder.loadTexts: agnSDateFormat.setDescription('This entry indicates the date and time format used for the agnSDateAndTimeCmd and for the alarm history report.')
agnSDateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSDateCmd.setStatus('current')
if mibBuilder.loadTexts: agnSDateCmd.setDescription('This entry indicates the current date as it is known by the agent using its own real-time clock. The format would be as specified by the agnSDateFormat. This parameter can be set for time synchronization between the NMS and the Agent.')
agnSTimeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSTimeCmd.setStatus('current')
if mibBuilder.loadTexts: agnSTimeCmd.setDescription('This entry indicates the current time as it is known by the agent using its own real-time clock. This parameter can be set for time synchronization between the NMS and the Agent.')
agnSActiveCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSActiveCnfg.setStatus('current')
if mibBuilder.loadTexts: agnSActiveCnfg.setDescription('This entry specifies the unique identifier of the configuration, that is currently active and running.')
agnSEditCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEditCnfg.setStatus('current')
if mibBuilder.loadTexts: agnSEditCnfg.setDescription('This entry indicates the unique identifier of the configuration that is currently loaded into the tmp working space for manipulation and update operations. Value of 255 means no config. is under editing process.')
agnSLastCnfgFlipTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSLastCnfgFlipTime.setStatus('current')
if mibBuilder.loadTexts: agnSLastCnfgFlipTime.setDescription('This entry indicates the Date & Time of the last flip to the current configuration at the agent.')
agnSLastCnfgFlipCause = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSLastCnfgFlipCause.setStatus('current')
if mibBuilder.loadTexts: agnSLastCnfgFlipCause.setDescription("This entry describes the flip's cause.")
agnSEditBy = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("snmp", 2), ("terCon1", 3), ("terCon2", 4), ("terInbandCon1", 5), ("terInbandCon2", 6), ("lcd", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEditBy.setStatus('current')
if mibBuilder.loadTexts: agnSEditBy.setDescription('This entry indicates which MMI application is working on the edited config. The editing phase starts at the first modify operation and ends after an update(load) operation.')
agnSClkSrc = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("internal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSClkSrc.setStatus('current')
if mibBuilder.loadTexts: agnSClkSrc.setDescription('This entry indicates the source of the system clock.')
agnSAlrStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrStatus.setStatus('current')
if mibBuilder.loadTexts: agnSAlrStatus.setDescription('Indicates the alarm state in the agent level, i.e. lower level (card/port) alarms not included. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSAlrStatusAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrStatusAll.setStatus('current')
if mibBuilder.loadTexts: agnSAlrStatusAll.setDescription('Indicates the alarm state of the entire agent, i.e. including card and port alarms status. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSMaskedAlrStat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaskedAlrStat.setStatus('current')
if mibBuilder.loadTexts: agnSMaskedAlrStat.setDescription('Indicates the alarm state in the agent level,[ i.e. lower level (card/port) alarms not included] including Masked alarms. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSMaskedAlrStatAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaskedAlrStatAll.setStatus('current')
if mibBuilder.loadTexts: agnSMaskedAlrStatAll.setDescription('Indicates the alarm state of the entire agent, i.e. including card and port alarms status,including Masked alarms. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSTstStatAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSTstStatAll.setStatus('current')
if mibBuilder.loadTexts: agnSTstStatAll.setDescription('on(3) - when there is at least one test in progress in one of the agent cards, otherwise the value will be off(2).')
agnSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15), )
if mibBuilder.loadTexts: agnSAlrTable.setStatus('current')
if mibBuilder.loadTexts: agnSAlrTable.setDescription('List of agent related alarms and indications for alarms at system level.')
agnSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1), ).setIndexNames((0, "RAD-MIB", "agnSAlrIdx"))
if mibBuilder.loadTexts: agnSAlrEntry.setStatus('current')
if mibBuilder.loadTexts: agnSAlrEntry.setDescription('An entry in table.')
agnSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrIdx.setStatus('current')
if mibBuilder.loadTexts: agnSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
agnSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCodeDescription.setStatus('current')
if mibBuilder.loadTexts: agnSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm . The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
agnSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCode.setStatus('current')
if mibBuilder.loadTexts: agnSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at system level.')
agnSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrSeverity.setStatus('current')
if mibBuilder.loadTexts: agnSAlrSeverity.setDescription('The severity of the alarm.')
agnSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrState.setStatus('current')
if mibBuilder.loadTexts: agnSAlrState.setDescription('State of the alarm.')
agnSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCounter.setStatus('current')
if mibBuilder.loadTexts: agnSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
agnSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrMask.setStatus('current')
if mibBuilder.loadTexts: agnSAlrMask.setDescription('Alarm mask : on/off.')
agnSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrInvert.setStatus('current')
if mibBuilder.loadTexts: agnSAlrInvert.setDescription('Alarm invert : on/off.')
agnSClearAlrCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSClearAlrCmd.setStatus('current')
if mibBuilder.loadTexts: agnSClearAlrCmd.setDescription('Setting this attribute to ON, enforce a clear operation on all the agent(general) events. General alarms are alarms which are not specific to a card or port. The clear operation will not be applied for masked/inverted alarms.')
agnSClearAllAlrCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSClearAllAlrCmd.setStatus('current')
if mibBuilder.loadTexts: agnSClearAllAlrCmd.setDescription('Setting this attribute to ON, enforce a clear operation on all MUX alarm events at the levels of agent, slots and ports. The clear operation will not be applied for masked/inverted alarms.')
agnSSanityCheckStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("fail", 2), ("warning", 3), ("ok", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSSanityCheckStatus.setStatus('current')
if mibBuilder.loadTexts: agnSSanityCheckStatus.setDescription('Upon completion of the Sanity check process on the TmpCnfg this attribute will be set to: FAIL(2) - when there is at least one error encountered and possibly some warnings. WARNING(3) - when there are only warnings. otherwise, the value will be OK(4). The value will be UNKNOWN(1) if changes were made in the TmpCnfg following the last Sanity check.')
agnSNoOfSanityCheckErr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSNoOfSanityCheckErr.setStatus('current')
if mibBuilder.loadTexts: agnSNoOfSanityCheckErr.setDescription('This entry indicates the number of errors/warnings discovered by the last SanityCheck process.')
agnSErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20), )
if mibBuilder.loadTexts: agnSErrListTable.setStatus('current')
if mibBuilder.loadTexts: agnSErrListTable.setDescription('List of errors and warnings found during Sanity Check process.')
agnSErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1), ).setIndexNames((0, "RAD-MIB", "agnSErrIdx"))
if mibBuilder.loadTexts: agnSErrListEntry.setStatus('current')
if mibBuilder.loadTexts: agnSErrListEntry.setDescription('An entry in table.')
agnSErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSErrIdx.setStatus('current')
if mibBuilder.loadTexts: agnSErrIdx.setDescription("Unique number to identify an entry in the error list table. The maximum entry value cannot exceed the value of 'agnSNoOfSanityCheckErr'. ")
agnSErrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSErrDescription.setStatus('current')
if mibBuilder.loadTexts: agnSErrDescription.setDescription('This attribute is a full text description of the sanity check error including error code, slot and port numbers related to the code .')
agnSMaxNoOfCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaxNoOfCnfg.setStatus('current')
if mibBuilder.loadTexts: agnSMaxNoOfCnfg.setDescription('Maximum number of configurations that can be defined and stored in the MUX. If the mux has a large capacity, the maximum will be limited to 254.')
agnSCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22), )
if mibBuilder.loadTexts: agnSCnfgTable.setStatus('current')
if mibBuilder.loadTexts: agnSCnfgTable.setDescription('This table contains an entry per configuration. It indicates if the configuration is valid.')
agnSCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1), ).setIndexNames((0, "RAD-MIB", "agnSEntryIdx"))
if mibBuilder.loadTexts: agnSCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: agnSCnfgEntry.setDescription('An entry in table.')
agnSEntryIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEntryIdx.setStatus('current')
if mibBuilder.loadTexts: agnSEntryIdx.setDescription('Unique number to identify an entry in the configuration table.')
agnSEntryIsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEntryIsValid.setStatus('current')
if mibBuilder.loadTexts: agnSEntryIsValid.setDescription('This attribute indicates whether the specific configuration is valid in the MUX . Value of NO indicates: no such configuration in the MUX. ')
agnCSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSanityCheckCmd.setStatus('current')
if mibBuilder.loadTexts: agnCSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the TmpCnfg. Upon completion the value will automatically be changed to off(2).')
agnCSaveCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: agnCSaveCnfgIdxCmd.setDescription('This attribute specifies the Id of the target RealCnfg to which the TmpCnfg should be transferred. Upon set command the MUX will initiate the Sanity-Check process first. If successful, the actual transfer will be performed. If warnings are detected, the user will have to perform the command again to confirm the operation. Setting this object a second time to the same value without performing any change in the database, will cause the result: agnSSanityCheckStatus = unknown')
agnCLoadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCLoadCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: agnCLoadCnfgIdxCmd.setDescription('This attribute specifies the Id of the source Cnfg to be loaded into the TmpCnfg. Upon set operation the actual transfer will be initiated. The operation is valid only on Valid configurations (agnSEntryIsValid)')
agnCClkSrcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4), )
if mibBuilder.loadTexts: agnCClkSrcTable.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..100) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
agnCClkSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1), ).setIndexNames((0, "RAD-MIB", "agnCClkCnfgIdx"), (0, "RAD-MIB", "agnCClkSrcIdx"))
if mibBuilder.loadTexts: agnCClkSrcEntry.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcEntry.setDescription('An entry in table.')
agnCClkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCClkCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCClkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..100) being accessed and Idx 255 relates to the TmpCnfg.')
agnCClkSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCClkSrcIdx.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcIdx.setDescription('An index to the table. There are only two entries to this table. Index 1 points to the Master clock parameters and Index 2 points to the Fallback clock parameters')
agnCClkSrcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("rxClk", 2), ("adaptive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcMode.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcMode.setDescription('The source of the nodal timing.')
agnCClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcSlt.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcSlt.setDescription("This entry is valid only when we are working in rxClk mode. For an invalid entry, the return value will be '7fff'h.")
agnCClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcPrt.setStatus('current')
if mibBuilder.loadTexts: agnCClkSrcPrt.setDescription("This entry is valid only when we are working in rxClk or adaptive mode. For an invalid entry, the return value will be '7fff'h. - For rxClk mode, the values can be: exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , exPrt5 (5) , exPrt6 (6) , exPrt7 (7) , exPrt8 (8) , exPrt9 (9) , exPrt10 (10) , exPrt11 (11) , exPrt12 (12) , notApplicable (100), inPrt1 (101) , inPrt2 (102) , inPrt3 (103) , inPrt4 (104) - For adaptive mode, the value will be the ifIndex of the selected IP Bundle.")
agnCDeleteCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCDeleteCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: agnCDeleteCnfgIdxCmd.setDescription('Setting this attribute will delete the requested DB from the NVRAM .')
agnCDefaultCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCDefaultCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: agnCDefaultCnfgIdxCmd.setDescription('Setting this attribute will define the desired working configuration when no conditions of the Flip DB Table are fulfilled and no Net GO command was issued. This command will be accepted only if the Configuration number exists (agnSEntryIsValid=yes).')
agnCnfgDataTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7), )
if mibBuilder.loadTexts: agnCnfgDataTable.setStatus('current')
if mibBuilder.loadTexts: agnCnfgDataTable.setDescription('This table contains data about the agent configurations. The table will support only data about valid configurations of the agent.')
agnCnfgDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1), ).setIndexNames((0, "RAD-MIB", "agnCnfgIdx"))
if mibBuilder.loadTexts: agnCnfgDataEntry.setStatus('current')
if mibBuilder.loadTexts: agnCnfgDataEntry.setDescription('An entry in table.')
agnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCnfgIdx.setDescription("This object indicates the Idx of the agent' Cnfg the following objects refer. 255=Temporary Cnfg (Set is done only to this configuration).")
agnCnfgDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgDesc.setStatus('current')
if mibBuilder.loadTexts: agnCnfgDesc.setDescription('This object is a description of the Configuration, entered by user, to enhance Cnfg recognition.')
agnCnfgUpdDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdDate.setStatus('current')
if mibBuilder.loadTexts: agnCnfgUpdDate.setDescription('This object indicates the date when last update of this configuration was performed, as it is known by the agent using its own real-time clock. The format would be as specified by the agnSDateFormat. When update is performed, the agent should save the date.')
agnCnfgUpdTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdTime.setStatus('current')
if mibBuilder.loadTexts: agnCnfgUpdTime.setDescription('This object indicates the time when last update of this configuration was performed, as it is known by the agent using its own real-time clock. When update is performed, the agent should save the time.')
agnCnfgUpdMnger = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdMnger.setStatus('current')
if mibBuilder.loadTexts: agnCnfgUpdMnger.setDescription('This object indicates the IP Address of the Manager who performed the last update of this configuration. When update is performed, the agent should save the IP Address of the Manager who commanded the update. That will enable a manager to know if he performed the last update, or another manager did.')
agnCnfgAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8))
agnCnfgAlrFilterWindow = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterWindow.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrFilterWindow.setDescription("Window of time, in seconds. During this Window, the alarms filter is performed. Same Window for all agent alarms that need filtering. Upon end of the Window, the state of the alarm is updated and a new Window starts. If no alarm needs filtering, this object's value will not be used.")
agnCnfgAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2), )
if mibBuilder.loadTexts: agnCnfgAlrTable.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrTable.setDescription("This table enables the user to set attributes to each alarm. Setting for a non-existing entry agnCnfgAlrMask, agnCnfgAlrInvert or agnCnfgAlrFilter to 'yes'(or yesAndSave for Mask) will add this new entry to the table. Setting for an existing entry agnCnfgAlrMask/ agnCnfgAlrInvert/agnCnfgAlrFilter (one or more) to 'no' (noAndSave for Mask) so that ALL these objects' values are 'no' , will delete this entry from the table. For agnCnfgAlrMask, only if [(last saved value=noAndSave) AND (new value is 'no' or 'noAndSave')] the object's value is considered 'no' for deleting the entry. For some products (like MP, MPH, Vmux2100) the Active Alarms are always part of the table and cannot be removed even if their Mask/Invert/Filter are No.")
agnCnfgAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnCnfgAlrCode"), (0, "RAD-MIB", "agnCnfgAlrSlot"), (0, "RAD-MIB", "agnCnfgAlrPort"))
if mibBuilder.loadTexts: agnCnfgAlrEntry.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrEntry.setDescription('An entry in table.')
agnCnfgAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrCode.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrCode.setDescription('The alarm code. The following attributes refer this code.')
agnCnfgAlrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 200, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("all", 200), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrSlot.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrSlot.setDescription('The alarm slot. The following attributes apply for the alarm code and slot selected. all = the attributes apply to all slots. notApplicable = the selected alarm is for system level. For the Vmux2100 Main Board clA (3) is used.')
agnCnfgAlrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrPort.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrPort.setDescription("The alarm port. The following attributes apply for the alarm code,slot and port selected. 200 = all = the attributes apply to all ports of the selected slot. When selected Slot is 'all', only 'all' or 'notApplicable' are valid Port selections. notApplicable = the selected alarm is for system or card level. =255 for MP =100 for DXC - For MP: - valid cards' ports are: exPrt1(1)..exPrt16(16) inPrt1(101)..inPrt48 (148) - IP Bundles - For DXC, the port index will include the Slot, as for all DXC tables: [(IO Slot+10)&n] ; n=odd for external ports n=even for internal ports.")
agnCnfgAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no", 1), ("noAndSave", 2), ("yes", 3), ("yesAndSave", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrMask.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrMask.setDescription("An attribute defining the desired Mask state of an alarm . no - unmask (this command is not saved in agent's common database) noAndSave - unmask ; this command is saved in agent's common database yes - mask (this command is not saved in agent's common database) yesAndSave - mask ; this command is saved in agent's common database. Commands that are not saved, will be lost upon power-up or selected card removal. ")
agnCnfgAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrInvert.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrInvert.setDescription('An attribute defining the desired Invert state of an alarm . no - not inverted. yes - inverted. For MP, it is not applicable for alarms that are currently OFF.')
agnCnfgAlrFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilter.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrFilter.setDescription('An attribute defining if Filter is desired for the alarm . no - no filter. yes - filter activate. This filter is activated within a window of time defined by agnCnfgAlrFilterWindow. Its purpose is to avoid frequent changes of an alarm between ON/OFF states.')
agnCnfgAlrFilterSet = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterSet.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrFilterSet.setDescription('This is a top threshold causing the alarm that passes it, to be declared Set (ON) at the end of the respective window of time. - For alarms defined by default as state alarms (minor,major) this value will be in [%]. - For alarms defined by default as events, this value will be an integer meaning how many times this event should appear at least, during the window in order to be considered ON. The maximum value will be 255. This value should be greater than the one of agnCnfgAlrFilterReset. Agents that do not support Alarms Filter, will return 0.')
agnCnfgAlrFilterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterReset.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrFilterReset.setDescription('This is a bottom threshold causing the alarm that does not pass it, to be declared Reset (ON) at the end of the respective window of time. - For alarms defined by default as state alarms (minor,major) this value will be in [%]. - For alarms defined by default as events, this value will be an integer meaning how many times this event should appear at most, during the window, in order to be considered OFF. This value should be less than the one of agnCnfgAlrFilterSet. Agents that do not support Alarms Filter, will return 0.')
agnCnfgAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrSeverity.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrSeverity.setDescription('An attribute defining desired severity of an alarm code per slot/port ')
agnCnfgAlrReportTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3), )
if mibBuilder.loadTexts: agnCnfgAlrReportTable.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrReportTable.setDescription('This table enables the user to configure the desired Alarm Reports according to alarms severity.')
agnCnfgAlrReportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1), ).setIndexNames((0, "RAD-MIB", "agnCnfgAlrReportType"))
if mibBuilder.loadTexts: agnCnfgAlrReportEntry.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrReportEntry.setDescription('An entry in table.')
agnCnfgAlrReportType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("trap", 1), ("buffer", 2), ("relay", 3), ("alrLedOn", 4), ("alrLedBlink", 5), ("relay2", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrReportType.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrReportType.setDescription("The alarm report type. trap - traps will be sent only for alarms having the selected On/Off severity or higher. buffer - only alarms having the selected On/Off severity and higher, will be reported to the buffer. relay - relay contact will be activated only for alarms having the selected On severity or higher. For products having 2 relays, this is the R1 Relay. alrLedOn/alrLedBlink - user should select a higher severity (ReportOn) for alrLedBlink than for alrLedOn (Blinking Led means a more severe alarm than steady ON Led). alrLedOn - MTCL-1 Alarm Led will be ON only when agnSAlrStatusAll equals the selected severity or higher, but lower severity than that selected for 'alrLedBlink'. For products having 2 LEDs, this is the Minor LED. alrLedBlink - MTCL-1 Alarm Led will Blink only when agnSAlrStatusAll equals the selected severity or higher. For products having 2 LEDs, this is the Major LED. relay2 - relay 2 contact will be activated only for alarms having the selected On severity or higher. This is the R2 Relay.")
agnCnfgAlrStartReportOn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noReport", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrStartReportOn.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrStartReportOn.setDescription('This object specifies the severity from which alarms will be reported. Alarms having this severity or higher, will be reported. This object specifies the report severity only for alarms that turn to ON state. noReport - no Report at all (for any severity).')
agnCnfgAlrStartReportOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("noReport", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrStartReportOff.setStatus('current')
if mibBuilder.loadTexts: agnCnfgAlrStartReportOff.setDescription("This object specifies the severity from which alarms will be reported. Alarms having this severity or higher, will be reported. This object specifies the report severity only for alarms that turn to OFF state. notApplicable - for 'relay','alrLedOn','alrLedBlink', 'relay2' report types, in MP. noReport - no Report at all (for any severity).")
agnCOffsetCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("u1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCOffsetCmd.setStatus('current')
if mibBuilder.loadTexts: agnCOffsetCmd.setDescription('An object defining special user request. notApplicable - is RO value for products that do not support this object. normal - nothing special u1 - user 1 - for all Voice cards, the DISPLAYED Tx and Rx Levels will have the following Offsets: - 2 Wires port: Tx Level: the base value (for 0dBm) = 0 Rx Level: the base value (for 0dBm) = -2 - 4 Wires port: Tx Level: the base value (for 0dBm) = -16 Rx Level: the base value (for 0dBm) = 7 The MIB and application DB will use the values without Offset.')
agnCT1E1RingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10), )
if mibBuilder.loadTexts: agnCT1E1RingTable.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingTable.setDescription('Configuration of all T1/E1 Ring ML cards and ports. The write operation into the table objects is valid only for the TmpCnfg. A Slot/Port that does not participate in the T1/E1 Ring, will not exist in this table. A ML port that exists in this table, cannot exist at the same time in the IO Redundancy table (sysCRdnTable).')
agnCT1E1RingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1), ).setIndexNames((0, "RAD-MIB", "agnCT1E1RingCnfgIdx"), (0, "RAD-MIB", "agnCT1E1RingPrimeSlot"), (0, "RAD-MIB", "agnCT1E1RingPrimePort"))
if mibBuilder.loadTexts: agnCT1E1RingEntry.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingEntry.setDescription('An Entry in table agnCT1E1RingTable')
agnCT1E1RingCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCT1E1RingCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
agnCT1E1RingPrimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCT1E1RingPrimeSlot.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingPrimeSlot.setDescription('The slot number of the Primary card of the Ring Pair.')
agnCT1E1RingPrimePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCT1E1RingPrimePort.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingPrimePort.setDescription('The port number in the Primary Card. For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 ')
agnCT1E1RingSecSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingSecSlot.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingSecSlot.setDescription('The slot number of the Secondary card of the Ring Pair.')
agnCT1E1RingSecPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingSecPort.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingSecPort.setDescription('The port number in the Secondary Card. For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 ')
agnCT1E1RingRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingRecTime.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingRecTime.setDescription('T1/E1 Ring Recovery Time (sec). Valid Values: 1..99, 65535. 65535=NA.')
agnCT1E1RingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingRowStatus.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingRowStatus.setDescription('This parameter allows NMS to create/delete entries of this table. The only possible supported RowStatus vaules are active (1) and destroy (6).')
agnCT1E1RingWTR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingWTR.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingWTR.setDescription('T1/E1 Ring Wait to Restore (sec). Valid Values: 0..999, 65535. 65535=NA. When the value <> 65535, the value of agnCT1E1RingRecTime must be 65535.')
agnCT1E1RingDualFailDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnCT1E1RingDualFailDetection.setStatus('current')
if mibBuilder.loadTexts: agnCT1E1RingDualFailDetection.setDescription('T1/E1 Ring - Dual Failure Detection enable/disable.')
agnCMainExitPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("eth", 2), ("e1T1SerialLink", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCMainExitPort.setStatus('current')
if mibBuilder.loadTexts: agnCMainExitPort.setDescription('An object defining the Main Exit Port for the Data of the device. In the Vmux-120 Device the Data can Exit via one of the 2 existing ports: 1. Ethernet port (2) 2. A port that can be E1 or T1 or a Serial Link (3).')
agnCBuMlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12), )
if mibBuilder.loadTexts: agnCBuMlTable.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlTable.setDescription('Configuration for Primary, Secondary and Third Link. These are used for Link Backup.')
agnCBuMlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1), ).setIndexNames((0, "RAD-MIB", "agnCBuMlCnfgIdx"), (0, "RAD-MIB", "agnCBuMlRole"))
if mibBuilder.loadTexts: agnCBuMlEntry.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlEntry.setDescription('An Entry in table agnCBuMlTable')
agnCBuMlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 1), Integer32())
if mibBuilder.loadTexts: agnCBuMlCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlCnfgIdx.setDescription('This object indicates the Index of the Configuration database (1..255) being accessed. Index of 255 relates to the Temporary Configuration.')
agnCBuMlRole = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("primary", 2), ("secondary", 3), ("third", 4), ("fourth", 5))))
if mibBuilder.loadTexts: agnCBuMlRole.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlRole.setDescription('The Role of the Link. Primary Link is the Link that should usually work. If the Primary Link fails, the data will go through the Secondary Link. If both Primary and Secondary Links fail, the data will go through the Third Link, provided it is up.')
agnCBuMlType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 2), ("e1T1a", 3), ("e1T1b", 4), ("eth", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlType.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlType.setDescription('The Type of the Link. For E1/T1 the Link can be Link A - e1T1a or Link B - e1T1b.')
agnCBuMlDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlDefaultGateway.setDescription("Default Gateway's IP Address.")
agnCBuMlSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlSubnetMask.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlSubnetMask.setDescription('The Link subnet mask.')
agnCBuMlOamFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlOamFrequency.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlOamFrequency.setDescription('Time in sec. between 2 OAM packets.')
agnCBuMlOamTimeoutCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlOamTimeoutCycles.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlOamTimeoutCycles.setDescription('No. of cycles the Link will send OAM packets without receiving a response from the remote Link before switching to the Backup Link.')
agnCBuMlWaitToRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 12, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCBuMlWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: agnCBuMlWaitToRestore.setDescription('This object defines traffic recovery time (in milliseconds) of the link after its recovery. This object is applicable only when Recovery Mode is revertive.')
agnCQ50Table = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13), )
if mibBuilder.loadTexts: agnCQ50Table.setStatus('current')
if mibBuilder.loadTexts: agnCQ50Table.setDescription('Table for the device Q50 parameters. Q50 is a Signaling protocol used between PBX devices. It is possible to control the initiation of calls using Q.50. This is useful for devices when there is a congestion.')
agnCQ50Entry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1), ).setIndexNames((0, "RAD-MIB", "agnCQ50CnfgIdx"))
if mibBuilder.loadTexts: agnCQ50Entry.setStatus('current')
if mibBuilder.loadTexts: agnCQ50Entry.setDescription('An Entry in table agnCQ50Table')
agnCQ50CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1, 1), Integer32())
if mibBuilder.loadTexts: agnCQ50CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCQ50CnfgIdx.setDescription('This object indicates the Index of the Configuration database (1..255) being accessed. Index of 255 relates to the Temporary Configuration.')
agnCQ50StopCallsThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCQ50StopCallsThresh.setStatus('current')
if mibBuilder.loadTexts: agnCQ50StopCallsThresh.setDescription('This object indicates the Bandwidth Threshold percent (%) above which new Calls from the PBX will be disabled.')
agnCQ50DiscardPktThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCQ50DiscardPktThresh.setStatus('current')
if mibBuilder.loadTexts: agnCQ50DiscardPktThresh.setDescription('This object indicates the Bandwidth Threshold percent (%) above which voice packets will be discarded. Usually, the value selected should be higher than the value of agnCQ50StopCallsThresh.')
agnCQ50BlockNewModemVbdCallsThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCQ50BlockNewModemVbdCallsThresh.setStatus('current')
if mibBuilder.loadTexts: agnCQ50BlockNewModemVbdCallsThresh.setDescription('This object indicates the Modem VBD Calls Threshold percent (%) above which new modem calls will be rejected.')
agnCQ50BlockNewModemRelayCallsThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 13, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCQ50BlockNewModemRelayCallsThresh.setStatus('current')
if mibBuilder.loadTexts: agnCQ50BlockNewModemRelayCallsThresh.setDescription('This object indicates the Modem Relay Calls Threshold percent (%) above which new modem calls will be rejected.')
agnCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1), )
if mibBuilder.loadTexts: agnCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnCmprTable.setDescription('A table.')
agnCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnCmprTypIdx"), (0, "RAD-MIB", "agnCmprCnfgIdx"), (0, "RAD-MIB", "agnCmprVersion"))
if mibBuilder.loadTexts: agnCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnCmprEntry.setDescription('An entry in table.')
agnCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprTypIdx.setStatus('current')
if mibBuilder.loadTexts: agnCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
agnCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
agnCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprVersion.setStatus('current')
if mibBuilder.loadTexts: agnCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCmprObj.setStatus('current')
if mibBuilder.loadTexts: agnCmprObj.setDescription('This attribute is the compressed information itself.')
agnDlciCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2), )
if mibBuilder.loadTexts: agnDlciCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprTable.setDescription('A table.')
agnDlciCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnDlciCmprCnfgIdx"), (0, "RAD-MIB", "agnDlciCmprVersion"), (0, "RAD-MIB", "agnDlciCmprDlciIdx"))
if mibBuilder.loadTexts: agnDlciCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprEntry.setDescription('An entry in table.')
agnDlciCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
agnDlciCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprVersion.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnDlciCmprDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprDlciIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprDlciIdx.setDescription('This attribute indicates a unique identifier of the Dlci, the compressed information relates to. The values are between 16 - 991.')
agnDlciCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciCmprObj.setStatus('current')
if mibBuilder.loadTexts: agnDlciCmprObj.setDescription('This attribute is the compressed information itself.')
agnAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3), )
if mibBuilder.loadTexts: agnAlarmsCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnAlarmsCmprTable.setDescription('A table.')
agnAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1), ).setIndexNames((0, "RAD-MIB", "agnAlarmsCmprVersion"), (0, "RAD-MIB", "agnAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: agnAlarmsCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnAlarmsCmprEntry.setDescription('An entry in table.')
agnAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprVersion.setStatus('current')
if mibBuilder.loadTexts: agnAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprAlarmIdx.setStatus('current')
if mibBuilder.loadTexts: agnAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
agnAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprObj.setStatus('current')
if mibBuilder.loadTexts: agnAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
agnAlrBufCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4), )
if mibBuilder.loadTexts: agnAlrBufCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnAlrBufCmprTable.setDescription('A table.')
agnAlrBufCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1), ).setIndexNames((0, "RAD-MIB", "agnAlrBufCmprVersion"), (0, "RAD-MIB", "agnAlrBufCmprAlarmIdx"))
if mibBuilder.loadTexts: agnAlrBufCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnAlrBufCmprEntry.setDescription('An entry in table.')
agnAlrBufCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprVersion.setStatus('current')
if mibBuilder.loadTexts: agnAlrBufCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnAlrBufCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprAlarmIdx.setStatus('current')
if mibBuilder.loadTexts: agnAlrBufCmprAlarmIdx.setDescription('A unique number to identify an entry in the history alarms buffer of the agent.')
agnAlrBufCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprObj.setStatus('current')
if mibBuilder.loadTexts: agnAlrBufCmprObj.setDescription('This attribute is the compressed information itself.')
agnSCmprErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5), )
if mibBuilder.loadTexts: agnSCmprErrListTable.setStatus('current')
if mibBuilder.loadTexts: agnSCmprErrListTable.setDescription('A table.')
agnSCmprErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1), ).setIndexNames((0, "RAD-MIB", "agnSCmprErrVersion"), (0, "RAD-MIB", "agnSCmprErrIdx"))
if mibBuilder.loadTexts: agnSCmprErrListEntry.setStatus('current')
if mibBuilder.loadTexts: agnSCmprErrListEntry.setDescription('An entry in table.')
agnSCmprErrVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrVersion.setStatus('current')
if mibBuilder.loadTexts: agnSCmprErrVersion.setDescription('The version of the compressed data ')
agnSCmprErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrIdx.setStatus('current')
if mibBuilder.loadTexts: agnSCmprErrIdx.setDescription("Unique number to identify an entry in the errors list table. The maximum entry value cannot exceed the value of 'agnSNoOfSanityCheckErr'. ")
agnSCmprErrObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrObj.setStatus('current')
if mibBuilder.loadTexts: agnSCmprErrObj.setDescription('This attribute is a full text description of the error, including: error code, slot and port numbers related to the code .')
agnTsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6), )
if mibBuilder.loadTexts: agnTsCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprTable.setDescription('A table.')
agnTsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1), ).setIndexNames((0, "RAD-MIB", "agnTsCmprVerIdx"), (0, "RAD-MIB", "agnTsCmprCnfgIdx"), (0, "RAD-MIB", "agnTsCmprSlotIdx"), (0, "RAD-MIB", "agnTsCmprPortIdx"), (0, "RAD-MIB", "agnTsCmprPduIdx"))
if mibBuilder.loadTexts: agnTsCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprEntry.setDescription('An entry in table.')
agnTsCmprVerIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprVerIdx.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprVerIdx.setDescription('This object indicates the version of the internal format of the Compressed data.')
agnTsCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprCnfgIdx.setDescription('This object indicates the configuration to which the Compressed information is related. 255=temporary configuration. Set can be performed only to the temporary configuration.')
agnTsCmprSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprSlotIdx.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprSlotIdx.setDescription('This object indicates the Slot to which the Compressed information is related. For MP-2100: IO-1..IO-12 = (5).. (16) For DXC-30 : IO-1..IO-15 = (5).. (19). NA=255.')
agnTsCmprPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprPortIdx.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprPortIdx.setDescription("This object indicates the Port within the Slot, to which the Compressed information is related. For Port Index see each product's spec.")
agnTsCmprPduIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprPduIdx.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprPduIdx.setDescription('This object indicates the PDU index within the same port. That provides for the case when one PDU is not sufficient for all TS Assignment data of the same port.')
agnTsCmprData = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTsCmprData.setStatus('current')
if mibBuilder.loadTexts: agnTsCmprData.setDescription('This object is the compressed information itself. It provides information about all TSs of a port.')
agnXCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7), )
if mibBuilder.loadTexts: agnXCmprTable.setStatus('current')
if mibBuilder.loadTexts: agnXCmprTable.setDescription('A table.')
agnXCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1), ).setIndexNames((0, "RAD-MIB", "agnXCmprTypIdx"), (0, "RAD-MIB", "agnXCmprVersion"), (0, "RAD-MIB", "agnXCmprIdx3"), (0, "RAD-MIB", "agnXCmprIdx4"), (0, "RAD-MIB", "agnXCmprIdx5"), (0, "RAD-MIB", "agnXCmprIdx6"), (0, "RAD-MIB", "agnXCmprIdx7"))
if mibBuilder.loadTexts: agnXCmprEntry.setStatus('current')
if mibBuilder.loadTexts: agnXCmprEntry.setDescription('An entry in table.')
agnXCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprTypIdx.setStatus('current')
if mibBuilder.loadTexts: agnXCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred. One of the types is V5.1 Variant data.')
agnXCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprVersion.setStatus('current')
if mibBuilder.loadTexts: agnXCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data.')
agnXCmprIdx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx3.setStatus('current')
if mibBuilder.loadTexts: agnXCmprIdx3.setDescription('3rd index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant, this attribute indicates the configuration to which the Compressed information is related. 255=temporary configuration. Set can be performed only to the temporary configuration.')
agnXCmprIdx4 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx4.setStatus('current')
if mibBuilder.loadTexts: agnXCmprIdx4.setDescription('4th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates a unique number of the slot position where the card is inserted. Valid values: psA(1),psB(2),clA(3),clB(4),io1(5)..io12(16); notApplicable=255.')
agnXCmprIdx5 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx5.setStatus('current')
if mibBuilder.loadTexts: agnXCmprIdx5.setDescription('5th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates a unique identifier of the port the compressed information relates to. Valid values: exPrt1 (1) .. exPrt12 (12) , inPrt1 (101) .. inPrt48 (148).')
agnXCmprIdx6 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx6.setStatus('current')
if mibBuilder.loadTexts: agnXCmprIdx6.setDescription('6th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates the Variant index. Valid values are: 0..127, 255 (= temp cnfg).Set can be performed only to the temporary configuration.')
agnXCmprIdx7 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx7.setStatus('current')
if mibBuilder.loadTexts: agnXCmprIdx7.setDescription('7th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute is not needed. Therefore, its value will be always 255=notApplicable.')
agnXCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnXCmprObj.setStatus('current')
if mibBuilder.loadTexts: agnXCmprObj.setDescription('This attribute is the compressed information itself.')
agnLinkMapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1), )
if mibBuilder.loadTexts: agnLinkMapTable.setStatus('current')
if mibBuilder.loadTexts: agnLinkMapTable.setDescription('A table.')
agnLinkMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "mapLinkId"))
if mibBuilder.loadTexts: agnLinkMapEntry.setStatus('current')
if mibBuilder.loadTexts: agnLinkMapEntry.setDescription('An entry in table.')
mapLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkId.setStatus('current')
if mibBuilder.loadTexts: mapLinkId.setDescription('A unique identifier of the link')
mapLinkSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("clA", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkSltIdx.setStatus('current')
if mibBuilder.loadTexts: mapLinkSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries clA(3), io6(10)..io12(16) are not valid.')
mapLinkPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkPrtIdx.setStatus('current')
if mibBuilder.loadTexts: mapLinkPrtIdx.setDescription('This attribute indicates a unique port number. ')
mapLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkStatus.setStatus('current')
if mibBuilder.loadTexts: mapLinkStatus.setDescription('This attribute indicates the status of the link between the two muxes')
alrBufTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1), )
if mibBuilder.loadTexts: alrBufTable.setStatus('current')
if mibBuilder.loadTexts: alrBufTable.setDescription('A table.')
alrBufEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "alrBufIdx"))
if mibBuilder.loadTexts: alrBufEntry.setStatus('current')
if mibBuilder.loadTexts: alrBufEntry.setDescription('An entry in table.')
alrBufIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufIdx.setStatus('current')
if mibBuilder.loadTexts: alrBufIdx.setDescription('This attribute indicates a unique number to identify this entry')
alrBufDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufDescription.setStatus('current')
if mibBuilder.loadTexts: alrBufDescription.setDescription('This entry is a unique text description of the alarm in the buffer. The alarm description includes the following information: alarm code, slot id, card type, channel id , alarm text, alarm status, masked flag and event counter')
alrBufCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufCode.setStatus('current')
if mibBuilder.loadTexts: alrBufCode.setDescription('A code identifying the alarm of an entry in the alarm buffer table.')
alrBufSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufSlot.setStatus('current')
if mibBuilder.loadTexts: alrBufSlot.setDescription("The slot number this alarm refers to. When the alarm refers to a system alarm, the value will be 'notApplicable(255)'.")
alrBufPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufPort.setStatus('current')
if mibBuilder.loadTexts: alrBufPort.setDescription('The port number this alarm refers to. If the port number is irrelevant to this alarm (if it is a system/card level alarm) the value will be 9999.')
alrBufSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufSeverity.setStatus('current')
if mibBuilder.loadTexts: alrBufSeverity.setDescription('The severity of the alarm.')
alrBufState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufState.setStatus('current')
if mibBuilder.loadTexts: alrBufState.setDescription('State of the alarm (On/Off).')
alrBufferClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alrBufferClearCmd.setStatus('current')
if mibBuilder.loadTexts: alrBufferClearCmd.setDescription("Setting this attribute to ON, will enforce a clear operation on the Alarms Buffer. Upon completion, the value will automatically change to off(2). For MP-2100/2200, this command will not really erase the Alarm Buffer, but is only an ACK of seeing the Buffer. It marks a pointer of the last entry's alrBufIdx, in order to allow view of new alarms entered after this pointer (alrBufIdxUponLastAck).")
alrBufIdxUponLastAck = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufIdxUponLastAck.setStatus('current')
if mibBuilder.loadTexts: alrBufIdxUponLastAck.setDescription('This attribute indicates the value of alrBufIdx for the last existing entry of alrBufTable, when alrBufferClearCmd was last Set to on(3). That will enable a user to see only Alarms that entered the alrBufTable after last Set of alrBufferClearCmd, by GetNext of alrBufDescription with this index.')
agnCAgendaTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1), )
if mibBuilder.loadTexts: agnCAgendaTable.setStatus('current')
if mibBuilder.loadTexts: agnCAgendaTable.setDescription('This table devides the week days into categories needed for DB flip consideration.')
agnCAgendaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnCAgendaCnfgIdx"), (0, "RAD-MIB", "agnCAgendaDayIdx"))
if mibBuilder.loadTexts: agnCAgendaEntry.setStatus('current')
if mibBuilder.loadTexts: agnCAgendaEntry.setDescription('An entry in table.')
agnCAgendaCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCAgendaCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCAgendaCnfgIdx.setDescription('Active or Temporary Agenda Table. Both configurations can be read but only the Temporary can be written to.')
agnCAgendaDayIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("sunday", 1), ("monday", 2), ("tuesday", 3), ("wednesday", 4), ("thursday", 5), ("friday", 6), ("saturday", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCAgendaDayIdx.setStatus('current')
if mibBuilder.loadTexts: agnCAgendaDayIdx.setDescription('Day of week')
agnCAgendaDayCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullWorkday", 1), ("partialWorkday", 2), ("weekend", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCAgendaDayCategory.setStatus('current')
if mibBuilder.loadTexts: agnCAgendaDayCategory.setDescription('The Category of the Day ')
agnCFlipNetEventsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2), )
if mibBuilder.loadTexts: agnCFlipNetEventsTable.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventsTable.setDescription('This table holds the Net Events the MUX should trace')
agnCFlipNetEventsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnCFlipNetEventsCnfgIdx"), (0, "RAD-MIB", "agnCFlipNetEventIdx"))
if mibBuilder.loadTexts: agnCFlipNetEventsEntry.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventsEntry.setDescription('An entry in table.')
agnCFlipNetEventsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipNetEventsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventsCnfgIdx.setDescription('Active or Temporary Net Events Table. Both configurations can be read but only the Temporary can be written to.')
agnCFlipNetEventIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipNetEventIdx.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventIdx.setDescription('Entry within the table')
agnCFlipNetEventActive = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventActive.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventActive.setDescription('Indicates if the entry is valid. In order to Add/Modify parameters of an entry, this object should be set to Yes. In order to delete an entry, this object should be Set to No.')
agnCFlipNetEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("time", 1), ("linkDown", 2), ("congestion", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventType.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventType.setDescription('The Net Event type ')
agnCFlipNetEventNo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventNo.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventNo.setDescription('The Net Event No. (Bit Index)')
agnCFlipNetEventSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventSlot.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventSlot.setDescription('The slot to which the net event relates . Not applicable for time event')
agnCFlipNetEventPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventPort.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventPort.setDescription('The port within the relevant slot. Valid values: - extPrt1(1)..exPrt16(16) - notApplicable(100) - inPrt1(101)..inPrt84(184)')
agnCFlipNetEventISD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventISD.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventISD.setDescription('The time in seconds since the Net Event was reported as ON until it is considered as ON. Not relevant for time events.')
agnCFlipNetEventOSD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventOSD.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventOSD.setDescription('The time in seconds since the net event was reported as OFF until it is considered as OFF. Not relevant for time events.')
agnCFlipNetEventDayType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("fullWorkday", 2), ("partialWorkday", 3), ("weekend", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventDayType.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventDayType.setDescription('The time event relates to all days defined in this category in the agnCAgendaTable. Applicable only for time event')
agnCFlipNetEventStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventStartTime.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventStartTime.setDescription('The time event will be activated at this time. The format is hh:mm.')
agnCFlipNetEventEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventEndTime.setStatus('current')
if mibBuilder.loadTexts: agnCFlipNetEventEndTime.setDescription('The time event will be deactivated at this time. The format is hh:mm.')
agnCFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3), )
if mibBuilder.loadTexts: agnCFlipTable.setStatus('current')
if mibBuilder.loadTexts: agnCFlipTable.setDescription('The DB Flip Decisions Table')
agnCFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1), ).setIndexNames((0, "RAD-MIB", "agnCFlipCnfgIdx"), (0, "RAD-MIB", "agnCFlipIdx"))
if mibBuilder.loadTexts: agnCFlipEntry.setStatus('current')
if mibBuilder.loadTexts: agnCFlipEntry.setDescription('An entry in table.')
agnCFlipCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnCFlipCnfgIdx.setDescription('Active or Temporary Flip Decisions Table. Both configurations can be read but only the Temporary can be written to.')
agnCFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipIdx.setStatus('current')
if mibBuilder.loadTexts: agnCFlipIdx.setDescription('Entry number within the table')
agnCFlipActive = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipActive.setStatus('current')
if mibBuilder.loadTexts: agnCFlipActive.setDescription('Indicates if the entry is valid. In order to Add/Modify parameters of an entry this object should be Set to Yes. In order to delete an entry, this object should be Set to No.')
agnCFlipLogicalExp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipLogicalExp.setStatus('current')
if mibBuilder.loadTexts: agnCFlipLogicalExp.setDescription("A logical expression composed of events numbers (which were configured in the 'AgnCFlipNetEvantsTable') and logical operators ('|', '&', '!', '(', ')') between them. e.g - (1 & !2) | (121 & 230)")
agnCFlipDbNo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDbNo.setStatus('current')
if mibBuilder.loadTexts: agnCFlipDbNo.setDescription('The ID of the required DB ')
agnCFlipDiscardDe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDiscardDe.setStatus('current')
if mibBuilder.loadTexts: agnCFlipDiscardDe.setDescription('Indicates whether the Mux should start discarding all DE. (MP3000 Only).')
agnFlipDbControls = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4))
agnCFlipDbSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDbSanityCheckCmd.setStatus('current')
if mibBuilder.loadTexts: agnCFlipDbSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the Temp Flip Db and automatically be changed to off(2).')
agnCSaveFlipDbCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveFlipDbCmd.setStatus('current')
if mibBuilder.loadTexts: agnCSaveFlipDbCmd.setDescription("Setting this attribute to on(3) will initiate the process of Sanity check on the Temp Flip Db and if it is OK, it will save the Flip Db in the NVRAM, activating the new Flip DB . If check detects errors, the save will not be performed. Afterwards, the object's value will change automatically to off(2).")
agnCSaveNetCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveNetCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: agnCSaveNetCnfgIdxCmd.setDescription("This attribute specifies the Id of the target NVRAM Cnfg to which the TmpCnfg should be transferred. Upon set command the MUX will initiate the Sanity-Check process first. If successful, the actual transfer will be performed. If warnings are detected, the user will have to perform the command again to confirm the operation. Setting this object a second time to the same value without performing any change in the database, will cause the result: agnSSanityCheckStatus = unknown. This attribute doesn't cause actual Flip.")
agnCSaveNetFlipDbCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveNetFlipDbCmd.setStatus('current')
if mibBuilder.loadTexts: agnCSaveNetFlipDbCmd.setDescription('Setting this attribute to on(3) will save the Temp Flip DB Into the NVRAM without actual flip.')
agnCNetGoCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetGoCmd.setStatus('current')
if mibBuilder.loadTexts: agnCNetGoCmd.setDescription("Setting this attribute to On will broadcast a 'GO' command to the network. When a Mux receives a 'GO' command it issues a delay for 'agnCNetDelay' seconds and then activates the DB which was pre-defined by one of the commands : 'agnCSaveNetCnfgIdxCmd' or 'agnCSaveNetFlipDbCmd'.")
agnCNetDelay = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetDelay.setStatus('current')
if mibBuilder.loadTexts: agnCNetDelay.setDescription("This attribute determines the period of time in seconds that takes for a message to be transferred over all the network. After a 'GO' command the MUX issues a delay of 'agnCNetDelay' before activating the appropriate DB. The delay will be applied only after performing agnCSaveFlipDbCmd.")
agnCNetEventsBcast = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetEventsBcast.setStatus('current')
if mibBuilder.loadTexts: agnCNetEventsBcast.setDescription('This object determines if the Net Events will be Broadcasted to other Muxes of the Net or not. disabled - Net Events will NOT be Broadcasted enabled - Net Events will be Broadcasted. Default=disabled. The value will be applied only after performing agnCSaveFlipDbCmd.')
agnCNetEventsBcastInterval = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetEventsBcastInterval.setStatus('current')
if mibBuilder.loadTexts: agnCNetEventsBcastInterval.setDescription('When agnCNetEventsBcast is enabled, this object determines the interval of time in seconds, between two consecutive Net Events transferred over the network. Default=40 sec. The interval will be applied only after performing agnCSaveFlipDbCmd.')
agnSaSwchStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSaSwchStatus.setStatus('current')
if mibBuilder.loadTexts: agnSaSwchStatus.setDescription("This object indicates the status of the switches on the stand-alone unit. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits: bit 0 NMS (LSB) bit 1 Terminal '1' = forces the DCE to be terminal with Rate=9600bps, Data bits=8, Stop bits=1 bit 2 Xray bit 3 SW-Load '1' = when SW is loaded bit 4 DBS Default of all bits=0 When the status of these switches is unknown, the value of this object is 255.")
agnListDecodingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1), )
if mibBuilder.loadTexts: agnListDecodingTable.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingTable.setDescription('A decoding table . For each type of list, a description is given for each existing code.')
agnListDecodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnListDecodingType"), (0, "RAD-MIB", "agnListDecodingCode"))
if mibBuilder.loadTexts: agnListDecodingEntry.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingEntry.setDescription('An entry in table.')
agnListDecodingType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alr", 1), ("sanity", 2), ("counter", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingType.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingType.setDescription('The type of list the decoding data refers to. alr - Alarms list sanity - Sanity Check Error list. counter - Counter type of ifPerfCounterType ')
agnListDecodingCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingCode.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingCode.setDescription('The specific code for which decoding is needed. ')
agnListDecodingDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingDescription.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingDescription.setDescription('The description fitting the specific code and type of list required. ')
agnListDecodingDefState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingDefState.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingDefState.setDescription('This object is applicable only for agnListDecodingType=alr. It reports the default state/severity of each alarm. User can change the severity of the alarms defined by this default via the agnListDecodingSeverity object.')
agnListDecodingSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingSeverity.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingSeverity.setDescription("This object is applicable only for agnListDecodingType=alr. It enables the user to select a severity for each alarm. The severity is set per alarm code (same for all slots/ports using this code). event - can be set only for an alarm that is defined by default as 'event'. User can change the severity of the alarms defined by default as minor or major. The severity of an event may be set to another severity, but the change will actually happen only if the event threshold is active and passed the Set/ON condition. An event alarm that passed the threshold and changed its severity, will return automatically to event severity when meeting its Reset/OFF condition.")
agnListDecodingAcmRelaySlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("none", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingAcmRelaySlt.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingAcmRelaySlt.setDescription('This object indicates the ACM slot, desired for outbound relay (report) for the selected alarm. In the ?004 Unit the entries io6(10)..io12(16) are not valid. none - when agnListDecodingType=alr AND the selected alarm should not be reported by an ACM card. notApplicable - when agnListDecodingType=sanity OR when [agnListDecodingType=alr and there is no ACM card installed in the Mux].')
agnListDecodingAcmRelayPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingAcmRelayPrt.setStatus('current')
if mibBuilder.loadTexts: agnListDecodingAcmRelayPrt.setDescription('This object indicates the ACM port within the slot, desired for outbound relay (report) for the selected alarm. notApplicable - when agnListDecodingType=sanity OR when agnListDecodingAcmRelaySlt=notApplicable.')
agnDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1), )
if mibBuilder.loadTexts: agnDlciTable.setStatus('current')
if mibBuilder.loadTexts: agnDlciTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
agnDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnDlciCnfgIdx"), (0, "RAD-MIB", "agnDlciLSltIdx"), (0, "RAD-MIB", "agnDlciLPrtIdx"), (0, "RAD-MIB", "agnDlciHIdx"), (0, "RAD-MIB", "agnDlciHSltIdx"), (0, "RAD-MIB", "agnDlciHPrtIdx"), (0, "RAD-MIB", "agnDlciLIdx"))
if mibBuilder.loadTexts: agnDlciEntry.setStatus('current')
if mibBuilder.loadTexts: agnDlciEntry.setDescription('An entry in table.')
agnDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
agnDlciLSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 254, 255))).clone(namedValues=NamedValues(("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("vs", 254), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLSltIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciLSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. This is the Source Slot of the DLCI. vs=Voice Switching In the ?004 Unit the entries io6(10)..io16) are not valid. For ISDN BRI ports of MX300/30 units: io1(5) = isdn1(5) and io2(6) = isdn2(6) LSlotIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciLPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLPrtIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciLPrtIdx.setDescription('This attribute indicates a unique external or internal port number, including linkSelector or encapsulator. This is the Source Port of the DLCI. 100=noConnect (for voice switching) LPrtIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciLIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciLIdx.setDescription('This attribute indicates a unique index for each possible used DLCI(16..991). This is the Source Side of the DLCI. 0=notApplicable (for voice switching) LIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciHSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHSltIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciHSltIdx.setDescription('This attribute indicates a unique slot position In the Mux where the DLCI is routed to - Destination Slot. For ISDN BRI ports of MX300/30 units: io1(5) = isdn1(5) and io2(6) = isdn2(6) In the ?004 Unit the entries io6(10)..io16) are not valid')
agnDlciHPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHPrtIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciHPrtIdx.setDescription('This attribute indicates a unique port number where the DLCI is routed to - Destination Port.')
agnDlciHIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHIdx.setStatus('current')
if mibBuilder.loadTexts: agnDlciHIdx.setDescription('This attribute indicates a unique internal connection DLCI number where the Source DLCI is routed to - the Destination Side of the DLCI.')
agnDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc5100bps", 3), ("txBc6400bps", 4), ("txBc8300bps", 5), ("txBc9600bps", 6), ("txBc14400bps", 7), ("txBc19200bps", 8), ("txBc28800bps", 9), ("txBc32000bps", 10), ("txBc38400bps", 11), ("txBc48000bps", 12), ("txBc56000bps", 13), ("txBc57600bps", 14), ("txBc64Kbps", 15), ("txBc128Kbps", 16), ("txBc192Kbps", 17), ("txBc256Kbps", 18), ("txBc320Kbps", 19), ("txBc384Kbps", 20), ("txBc448Kbps", 21), ("txBc512Kbps", 22), ("txBc768Kbps", 23), ("txBc896Kbps", 24), ("txBc1024Kbps", 25), ("txBc1152Kbps", 26), ("txBc1280Kbps", 27), ("txBc1344Kbps", 28), ("txBc1472Kbps", 29), ("txBc1600Kbps", 30), ("txBc1728Kbps", 31), ("txBc1856Kbps", 32), ("txBc1920Kbps", 33), ("txBc1984Kbps", 34), ("txBc2048Kbps", 35), ("txBc16000bps", 36), ("txBc112Kbps", 37), ("txBc168Kbps", 38), ("txBc224Kbps", 39), ("txBc336Kbps", 40), ("txBc672Kbps", 41), ("txBc1536Kbps", 42), ("txBc1792Kbps", 43))).clone('full')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciTxBc.setStatus('current')
if mibBuilder.loadTexts: agnDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line or at the port receive line.')
agnDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe5100bps", 3), ("txBe6400bps", 4), ("txBe8300bps", 5), ("txBe9600bps", 6), ("txBe14400bps", 7), ("txBe19200bps", 8), ("txBe28800bps", 9), ("txBe32000bps", 10), ("txBe38400bps", 11), ("txBe48000bps", 12), ("txBe56000bps", 13), ("txBe57600bps", 14), ("txBe64Kbps", 15), ("txBe128Kbps", 16), ("txBe192Kbps", 17), ("txBe256Kbps", 18), ("txBe320Kbps", 19), ("txBe384Kbps", 20), ("txBe448Kbps", 21), ("txBe512Kbps", 22), ("txBe768Kbps", 23), ("txBe896Kbps", 24), ("txBe1024Kbps", 25), ("txBe1152Kbps", 26), ("txBe1280Kbps", 27), ("txBe1344Kbps", 28), ("txBe1472Kbps", 29), ("txBe1600Kbps", 30), ("txBe1728Kbps", 31), ("txBe1856Kbps", 32), ("txBe1920Kbps", 33), ("txBe1984Kbps", 34), ("txBe2048Kbps", 35), ("txBe16000bps", 36), ("txBe112Kbps", 37), ("txBe168Kbps", 38), ("txBe224Kbps", 39), ("txBe336Kbps", 40), ("txBe672Kbps", 41), ("txBe1536Kbps", 42), ("txBe1792Kbps", 43))).clone('zero')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciTxBe.setStatus('current')
if mibBuilder.loadTexts: agnDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line or at the port receive line.')
agnDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc5100bps", 3), ("rxBc6400bps", 4), ("rxBc8300bps", 5), ("rxBc9600bps", 6), ("rxBc14400bps", 7), ("rxBc19200bps", 8), ("rxBc28800bps", 9), ("rxBc32000bps", 10), ("rxBc38400bps", 11), ("rxBc48000bps", 12), ("rxBc56000bps", 13), ("rxBc57600bps", 14), ("rxBc64Kbps", 15), ("rxBc128Kbps", 16), ("rxBc192Kbps", 17), ("rxBc256Kbps", 18), ("rxBc320Kbps", 19), ("rxBc384Kbps", 20), ("rxBc448Kbps", 21), ("rxBc512Kbps", 22), ("rxBc768Kbps", 23), ("rxBc896Kbps", 24), ("rxBc1024Kbps", 25), ("rxBc1152Kbps", 26), ("rxBc1280Kbps", 27), ("rxBc1344Kbps", 28), ("rxBc1472Kbps", 29), ("rxBc1600Kbps", 30), ("rxBc1728Kbps", 31), ("rxBc1856Kbps", 32), ("rxBc1920Kbps", 33), ("rxBc1984Kbps", 34), ("rxBc2048Kbps", 35), ("rxBc16000bps", 36), ("rxBc112Kbps", 37), ("rxBc168Kbps", 38), ("rxBc224Kbps", 39), ("rxBc336Kbps", 40), ("rxBc672Kbps", 41), ("rxBc1536Kbps", 42), ("rxBc1792Kbps", 43))).clone('full')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciRxBc.setStatus('current')
if mibBuilder.loadTexts: agnDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line or at the port transmit line.')
agnDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe5100bps", 3), ("rxBe6400bps", 4), ("rxBe8300bps", 5), ("rxBe9600bps", 6), ("rxBe14400bps", 7), ("rxBe19200bps", 8), ("rxBe28800bps", 9), ("rxBe32000bps", 10), ("rxBe38400bps", 11), ("rxBe48000bps", 12), ("rxBe56000bps", 13), ("rxBe57600bps", 14), ("rxBe64Kbps", 15), ("rxBe128Kbps", 16), ("rxBe192Kbps", 17), ("rxBe256Kbps", 18), ("rxBe320Kbps", 19), ("rxBe384Kbps", 20), ("rxBe448Kbps", 21), ("rxBe512Kbps", 22), ("rxBe768Kbps", 23), ("rxBe896Kbps", 24), ("rxBe1024Kbps", 25), ("rxBe1152Kbps", 26), ("rxBe1280Kbps", 27), ("rxBe1344Kbps", 28), ("rxBe1472Kbps", 29), ("rxBe1600Kbps", 30), ("rxBe1728Kbps", 31), ("rxBe1856Kbps", 32), ("rxBe1920Kbps", 33), ("rxBe1984Kbps", 34), ("rxBe2048Kbps", 35), ("rxBe16000bps", 36), ("rxBe112Kbps", 37), ("rxBe168Kbps", 38), ("rxBe224Kbps", 39), ("rxBe336Kbps", 40), ("rxBe672Kbps", 41), ("rxBe1536Kbps", 42), ("rxBe1792Kbps", 43))).clone('zero')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciRxBe.setStatus('current')
if mibBuilder.loadTexts: agnDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line or at the port transmit line.')
agnDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciPriority.setStatus('current')
if mibBuilder.loadTexts: agnDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 7 is the highest priority.')
agnDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciStatus.setStatus('current')
if mibBuilder.loadTexts: agnDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
agnDlciSpoofing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciSpoofing.setStatus('current')
if mibBuilder.loadTexts: agnDlciSpoofing.setDescription('This object refers to sending of RIP messages: - yes : RIP messages will be sent ONLY if there is a change in the Net. - no : RIP messages will be always sent. This object is relevant only when one side of the DLCI is a CL-NMS interface. Default=no. ')
agnDlciFunnelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3), ("source", 4), ("destination", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciFunnelEnable.setStatus('current')
if mibBuilder.loadTexts: agnDlciFunnelEnable.setDescription('This object selects Funnel activation: - disabled: Funnel operation will be disabled. The agnDlciTxBe and agnDlciTxBc values are not used for funneling. - enabled : Funnel operation will be enabled both for Source and Destination of the DLCI. The agnDlciTxBe and agnDlciTxBc values are used for funneling calculations. - source: Funnel operation will be enabled only for the Source of the DLCI. - destination:Funnel operation will be enabled only for the Destination of the DLCI. This object is relevant only for an encapsulating DLCI. In case of a Link Selector DLCI, the agnDlciTxBe and agnDlciTxBc values are used for bandwidth of Link Selector. Default=disabled. ')
agnDlciRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("rip", 2), ("rip2", 3), ("none", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciRoutingProtocol.setStatus('current')
if mibBuilder.loadTexts: agnDlciRoutingProtocol.setDescription('This object is relevant only when one side of the DLCI is a CL-NMS interface. It defines which Routing Protocol will be used for management via CL-NMS port. notApplicable will be used for all slots but CL. rip is a proprietary rip protocol. Default=rip. ')
agnDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnDlciRowStatus.setStatus('current')
if mibBuilder.loadTexts: agnDlciRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set agnRowStatus.255.id2.id3.id4.id5.id6.id7 = active(1). For destroying a row, the NMS should set: agnRowStatus.255.id2.id3.id4.id5.id6.id7 = destroy(6). Only rows with status active(1) are relevant. The only possible supported RowStatus vaules are active (1) and destroy (6).')
agnVoiceSwConfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1), )
if mibBuilder.loadTexts: agnVoiceSwConfTable.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfTable.setDescription('MXcess Configuration for Voice Switching.')
agnVoiceSwConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnVoiceSwConfIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfEntry.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfEntry.setDescription('An entry in table.')
agnVoiceSwConfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfIdx.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfIdx.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfZoneId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfZoneId.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfZoneId.setDescription('1 or 2 digits, (0-9)(1-9).')
agnVoiceSwConfNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfNodeId.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfNodeId.setDescription('1, 2 or 3 digits, (1-9),(0-9),(0-9).')
agnVoiceSwConfNoOfHops = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfNoOfHops.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfNoOfHops.setDescription('Number of hops the frame will go through the net before deciding to discard the frame (like time-to-live in IP). 0 = notApplicable Default=20 .')
agnVoiceSwConfSidt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfSidt.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfSidt.setDescription('SIDT: Short Inter Digit Timeout used as timer (in sec.) between digits after routing is completed. The timeout indicates end of dialing and the call can then be setup. 0 = notApplicable Default=2 sec.')
agnVoiceSwConfLidt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfLidt.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfLidt.setDescription('LIDT: Long Inter Digit Timeout used as timer between digits before routing is completed. If no digits were dialed and LIDT expired then the user will get an error tone and the call will be disconnected. 0 = notApplicable Default=15 sec.')
agnVoiceSwConfDialPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("staticDialPlan", 2), ("staticDialPlanPlus", 3), ("flexDialPlan", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfDialPlan.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfDialPlan.setDescription('This is the Dialing Plan method that will be used in the Voice Switching. Static Dialing Plan - Routing is defined by the current device Zone and Node ID in the Network. Static Dialing Plan Plus - Includes the Static Dialing Plan but contains an addition of defining the number of dialed digits. Flexible Dialing Plan - Routing is defined in a flexible form. In this plan the user can configure the extension number of a local voice channel, Route a call to a remote destination and enter the Number of Digits for a specific dial prefix.')
agnVoiceSwConfRtTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2), )
if mibBuilder.loadTexts: agnVoiceSwConfRtTable.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtTable.setDescription('Routing Table for Voice Switching.')
agnVoiceSwConfRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnVoiceSwConfRtDbId"), (0, "RAD-MIB", "agnVoiceSwConfRtIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfRtEntry.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtEntry.setDescription('An entry in table.')
agnVoiceSwConfRtDbId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfRtDbId.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtDbId.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfRtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfRtIdx.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtIdx.setDescription(' The Index of the row.')
agnVoiceSwConfRtDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtDigits.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtDigits.setDescription(" Dialed digits: Series of digits 0...9, '*', '#' or '%'. The '*' and '#' can have many uses according to the user's decision. For example, they can be used as part of the Dialed Number, they exist on the phone number panel. '*' can also be used instead of a series of numbers. The '%' means any digits (wildcard) and is used without a series of digits. When the agnVoiceSwConfRtAction is del (7), the series of digits that are configured via this MIB object will be deleted from the prefix of the dialed number.")
agnVoiceSwConfRtAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("notApplicable", 1), ("zone", 2), ("node", 3), ("shortDialing", 4), ("in", 5), ("hgr", 6), ("del", 7), ("rep", 8), ("pri", 9), ("bri", 10), ("numDigDP", 11), ("route", 12), ("ext", 13))).clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtAction.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtAction.setDescription(' Action that the system should perform for the digits: agnVoiceSwConfRtDigits. The action that is allowed depends on the Dialing Plan. Here is the list of the allowed actions: For Static Dialing Plan - zone, node, in, shortDialing, hgr, del, rep For Static Dialing Plan Plus - zone, node, in, shortDialing, hgr, del, rep, numDigDP For Flexible Dialing Plan - hgr, del, rep, numDigDP, route, ext')
agnVoiceSwConfRtData = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtData.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtData.setDescription(' This field is relevant for actions hgr(6), and rep(8), numDigDP(11) and contains the following information: For hgr - the number of the Hunt Group. For rep - the number of digits to be replaced with. For numDigDP - the number of digits collected before establishing the call. 0 indicates no defined length. In this case SIDT will be used.')
agnVoiceSwConfRtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255))).clone('noConnect')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtSlot.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtSlot.setDescription(' Routing Slot- Relevant for actions zone(2), node(3), shortDialing(4), route(12), ext(13).')
agnVoiceSwConfRtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtPort.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtPort.setDescription(' Routing Port- Relevant for actions zone(2), node(3), shortDialing(4), route(12), ext(13). 100=noConnect (for non-routing case).')
agnVoiceSwConfRtDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 8), Integer32().clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtDlci.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtDlci.setDescription(' Routing DLCI- Relevant for actions zone(2), node(3), shortDialing(4), route(12), ext(13). Valid values: 0=notApplicable (for non-routing case). 1, 16..991 ')
agnVoiceSwConfRtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtRowStatus.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtRowStatus.setDescription(' Status of the row for creating/deleting entries in the table. The only possible supported RowStatus vaules are active (1), notInService (2), notReady(3), createAndGo(4), createAndWait(5) and destroy(6).')
agnVoiceSwConfRtMaxCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtMaxCalls.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtMaxCalls.setDescription('Maximum no. of simultaneous voice calls that are allowed in the direction defined by the current entry. Default=0 (No Limit).')
agnVoiceSwConfRtPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agnVoiceSwConfRtPriority.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfRtPriority.setDescription('This attribute indicates a unique priority of the Voice Switching Route. 1 is the lowest priority and 7 is the highest priority. 0 means N/A ')
agnVoiceSwConfHGTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5), )
if mibBuilder.loadTexts: agnVoiceSwConfHGTable.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGTable.setDescription('Table of Hunt Groups.')
agnVoiceSwConfHGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1), ).setIndexNames((0, "RAD-MIB", "agnVoiceSwConfHGdbIdx"), (0, "RAD-MIB", "agnVoiceSwConfHGIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfHGEntry.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGEntry.setDescription('An entry in table.')
agnVoiceSwConfHGdbIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfHGdbIdx.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGdbIdx.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfHGIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfHGIdx.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGIdx.setDescription("For Vmux-300 devices - This object represents a combination of - Hunt Group number and Extension number OR - Port number and Extension number. For other devices (e.g. MXcess, MP-2100H) - There may be up to 10 Hunt Groups per MXcess. That's the index of the hunt group relevant to this row.")
agnVoiceSwConfHGConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGConnect.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGConnect.setDescription('This attribute indicates whether the hunt group should be considered in any of the mux algorithms.')
agnVoiceSwConfHGExt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGExt.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGExt.setDescription('This is the extension number of the hunt group. 0 is for not valid. The allowed range is 10 - 99.')
agnVoiceSwConfHGExtString = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 5), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGExtString.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGExtString.setDescription('This is the extension string of the hunt group. This string is a combination of digits, * and #.')
agnVoiceSwConfHGUserParams = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 6), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGUserParams.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGUserParams.setDescription("This object indicates the User's parameters.")
agnVoiceSwConfHGStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGStatus.setStatus('current')
if mibBuilder.loadTexts: agnVoiceSwConfHGStatus.setDescription('This object enables the user to create/delete entries in this table. Its usage for values (1)..(6) should be identical to RowStatus SYNTAX. notApplicable(255) - should be used when the table is static (i.e. whenever create/delete entries is not allowed).')
agnSigProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1), )
if mibBuilder.loadTexts: agnSigProfileTable.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileTable.setDescription('- For products supporting more than one configuration, the write operation into the Table is valid only to the TmpCnfg entry. - For products that do not support configurations, the write operation into the Table will be to agnSigProfileCnfgIdx=1. The table includes signaling profile parameters for Legacy Profiles.')
agnSigProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1), ).setIndexNames((0, "RAD-MIB", "agnSigProfileCnfgIdx"), (0, "RAD-MIB", "agnSigProfileIdx"), (0, "RAD-MIB", "agnSigProfileRxTx"))
if mibBuilder.loadTexts: agnSigProfileEntry.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileEntry.setDescription('An entry in table.')
agnSigProfileCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. For products supporting more than one configuration,the write operation is valid only to the TmpCnfg. For Gmux2000 the range limitation (1..255) was discarded since the Idx is computed as: <IO Card No.> x 1000 + 255.')
agnSigProfileIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileIdx.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileIdx.setDescription('This attribute indicates the Signaling Profile (1..5). For MP-104/204, only Profile=1 will exist.')
agnSigProfileRxTx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileRxTx.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileRxTx.setDescription('This attribute indicates if the following objects refer to: Rx or Tx translation. Rx : ML->IO Tx : IO->ML . For MP-104/204, that means: Rx : Signaling to FXS CH Tx : Signaling to E1 Link. ')
agnSigProfileABCD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSigProfileABCD.setStatus('current')
if mibBuilder.loadTexts: agnSigProfileABCD.setDescription('For MP-2100/MP-2200 and for MP-104/204 from R2: This object represents 6 parameters, by 3 Octets : Busy Code-MSB nibble, - applicable only for Rx translation Idle Code- nibble, - applicable only for Rx translation D Bit Code- nibble, C Bit Code- nibble, B Bit Code- nibble, A Bit Code-LSB nibble. Each of Busy and Idle Code nibble will have the valid values: 0000 .. FFFF. Each of A,B,C,D Bit Code nibble represents: 0 hex = 0000 = 0 1 hex = 0001 = 1 2 hex = 0010 = A bit 3 hex = 0011 = B bit 4 hex = 0100 = C bit 5 hex = 0101 = D bit 6 hex = 0110 = A bit inverse 7 hex = 0111 = B bit inverse 8 hex = 1000 = C bit inverse 9 hex = 1001 = D bit inverse A-F hex - not used (invalid values) For MP-104/204 R1: This object represents 3 parameters, by 2 Octets : Bit 1 = Bit A - OFF Hook for Tx ; Ring for Rx (LSB) Bit 2 = Bit B - OFF Hook for Tx ; Ring for Rx Bit 3 = Bit C - OFF Hook for Tx ; Ring for Rx Bit 4 = Bit D - OFF Hook for Tx ; Ring for Rx Bit 5 = Bit A - ON Hook for Tx ; Idle for Rx Bit 6 = Bit B - ON Hook for Tx ; Idle for Rx Bit 7 = Bit C - ON Hook for Tx ; Idle for Rx Bit 8 = Bit D - ON Hook for Tx ; Idle for Rx Bit 9 = Bit A - OOS State for both Tx and Rx Bit 10 = Bit B - OOS State for both Tx and Rx Bit 11 = Bit C - OOS State for both Tx and Rx Bit 12 = Bit D - OOS State for both Tx and Rx Bit 13 = Spare (always 0) Bit 14 = Spare (always 0) Bit 15 = Spare (always 0) Bit 16 = Spare (always 0) (MSB) When the object is not applicable, the Octet String will have 0 bytes.')
agnSigProfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2), )
if mibBuilder.loadTexts: agnSigProfTable.setStatus('current')
if mibBuilder.loadTexts: agnSigProfTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry. This is the general table of signaling profiles.')
agnSigProfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2, 1), ).setIndexNames((0, "RAD-MIB", "agnSigProfCnfgIdx"), (0, "RAD-MIB", "agnSigProfIdx"))
if mibBuilder.loadTexts: agnSigProfEntry.setStatus('current')
if mibBuilder.loadTexts: agnSigProfEntry.setDescription('An entry in table.')
agnSigProfCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: agnSigProfCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
agnSigProfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfIdx.setStatus('current')
if mibBuilder.loadTexts: agnSigProfIdx.setDescription('This attribute indicates the Signaling Profile (1..5).')
agnSigProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSigProfName.setStatus('current')
if mibBuilder.loadTexts: agnSigProfName.setDescription('Profile Name given by user.')
agnSigProfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("legacy", 2), ("r2Cas", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSigProfType.setStatus('current')
if mibBuilder.loadTexts: agnSigProfType.setDescription('Profile Type. legacy - usual signaling. The parameters for the Legacy Profiles are detailed in the agnSigProfileTable, above. r2Cas - R2 signaling. The parameters for the R2 Profiles are detailed in the r2 ProfileCnfg tables (belong to r2If). ')
systemVoiceTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1), )
if mibBuilder.loadTexts: systemVoiceTable.setStatus('current')
if mibBuilder.loadTexts: systemVoiceTable.setDescription('General Parameters for voice - system level.')
systemVoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1), ).setIndexNames((0, "RAD-MIB", "systemVoiceConfIdx"))
if mibBuilder.loadTexts: systemVoiceEntry.setStatus('current')
if mibBuilder.loadTexts: systemVoiceEntry.setDescription('An entry in table.')
systemVoiceConfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemVoiceConfIdx.setStatus('current')
if mibBuilder.loadTexts: systemVoiceConfIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed - Active or Temporary Configurations. Idx 255 relates to the temporary TmpCnfg. All configurations can be read but only the Temporary can be written to.')
systemVoiceNationalTone = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notApplicable", 1), ("usa", 2), ("australia", 3), ("brazil", 4), ("canada", 5), ("france", 6), ("germany", 7), ("israel", 8), ("mexico", 9), ("portugal", 10), ("russia", 11), ("spain", 12), ("unitedKingdom", 13), ("czech", 14), ("china", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceNationalTone.setStatus('current')
if mibBuilder.loadTexts: systemVoiceNationalTone.setDescription('Tone Characteristics (Amplitude, Frequency, delays etc.). These characteristics are defined according to the country.')
systemVoicePacketRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoicePacketRate.setStatus('current')
if mibBuilder.loadTexts: systemVoicePacketRate.setDescription('This object indicates the G.729 and G.711 Coders transmitted Packet Rate in milliseconds.')
systemVoiceFaxSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("faxRelayT38", 3), ("vbdPassThrou", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceFaxSupport.setStatus('current')
if mibBuilder.loadTexts: systemVoiceFaxSupport.setDescription('This object allows the user to Disable/Enable Fax support.')
systemVoiceFaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6))).clone(namedValues=NamedValues(("notConnected", 1), ("r4800bps", 2), ("r9600bps", 4), ("r14400bps", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceFaxRate.setStatus('current')
if mibBuilder.loadTexts: systemVoiceFaxRate.setDescription('This object indicates the Fax Rate limit. It is irrelevant when Fax support is NA or disabled.')
systemVoiceModemSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("vbdV152", 3), ("vbdPassThrou", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceModemSupport.setStatus('current')
if mibBuilder.loadTexts: systemVoiceModemSupport.setDescription('This object allows the user to Disable/Enable Modem support.')
systemVoiceCoderAndRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("g711aLAW", 5), ("g711uLAW", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceCoderAndRate.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderAndRate.setDescription('This object indicates the Coder and Rate for the Voice Compression.')
systemVoiceEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceEchoCanceler.setStatus('current')
if mibBuilder.loadTexts: systemVoiceEchoCanceler.setDescription('This object indicates the Echo Canceler activation.')
systemVoiceTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceTxGain.setStatus('current')
if mibBuilder.loadTexts: systemVoiceTxGain.setDescription('This object indicates the Transmit Gain (volume) in dB.')
systemVoiceDtmfRelayMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rfc2833", 1), ("sipInfo", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceDtmfRelayMethod.setStatus('current')
if mibBuilder.loadTexts: systemVoiceDtmfRelayMethod.setDescription('This object indicates the DTMF Relay Method that is used to transmit DTMF tones. rfc2833(1) - inband DTMF relay according to RFC-2833. sipInfo(2) - out of band DTMF relay using SIP INFO method.')
systemVoiceDtmfRelayRxPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceDtmfRelayRxPayloadType.setStatus('current')
if mibBuilder.loadTexts: systemVoiceDtmfRelayRxPayloadType.setDescription('This object indicates the Rx Payload Type for DTMF relay RTP packets. It is relevant only when DTMF Relay Method is RFC-2833.')
systemVoiceDtmfRelayPayloadTypeNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceDtmfRelayPayloadTypeNeg.setStatus('current')
if mibBuilder.loadTexts: systemVoiceDtmfRelayPayloadTypeNeg.setDescription('This object indicates whether Payload Type Negotiation is used (according to RFC-2833) or not. It is relevant only when DTMF Relay Method is RFC-2833.')
systemVoiceDtmfRelayTxPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 1, 1, 13), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceDtmfRelayTxPayloadType.setStatus('current')
if mibBuilder.loadTexts: systemVoiceDtmfRelayTxPayloadType.setDescription('This object indicates the Tx Payload Type for DTMF relay RTP packets. It is relevant only when the Payload Type Negotiation is disabled.')
systemVoiceCoderTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 2), )
if mibBuilder.loadTexts: systemVoiceCoderTable.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderTable.setDescription('Voice Coders table.')
systemVoiceCoderEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 2, 1), ).setIndexNames((0, "RAD-MIB", "systemVoiceCoderConfIdx"), (0, "RAD-MIB", "systemVoiceCoderPriority"))
if mibBuilder.loadTexts: systemVoiceCoderEntry.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderEntry.setDescription('An entry in Voice Coders table.')
systemVoiceCoderConfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: systemVoiceCoderConfIdx.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderConfIdx.setDescription('The first index of the table. This object might represent the Configuration Index (1..100) being accessed; Index=255 relates to the TmpCnfg. For devices with multiple configurations, Set is permitted to TmpCnfg(255) only. Not-Applicable = 1.')
systemVoiceCoderPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: systemVoiceCoderPriority.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderPriority.setDescription("This object indicates the Coder's Priority.")
systemVoiceCoderCoderAndRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("notApplicable", 1), ("g7231r6300BPS", 2), ("g7231r5300BPS", 3), ("g729A8KBPS", 4), ("g711aLAW", 5), ("g711uLAW", 6), ("none", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemVoiceCoderCoderAndRate.setStatus('current')
if mibBuilder.loadTexts: systemVoiceCoderCoderAndRate.setDescription('This object indicates the Coder and Rate for the Voice Compression.')
mdlSInstTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1), )
if mibBuilder.loadTexts: mdlSInstTable.setStatus('current')
if mibBuilder.loadTexts: mdlSInstTable.setDescription('A table.')
mdlSInstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlSInstSltIdx"))
if mibBuilder.loadTexts: mdlSInstEntry.setStatus('current')
if mibBuilder.loadTexts: mdlSInstEntry.setDescription('An entry in table.')
mdlSInstSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSInstSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlSInstSltIdx.setDescription('A unique number to identify a slot position in the mux. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid. For the Vmux2100 Main Board clA (3) is used.')
mdlSInstCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 10, 11, 17, 20, 21, 22, 23, 24, 25, 26, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264, 265, 266, 267, 271, 272, 273, 281, 282, 283, 284, 285, 286), SingleValueConstraint(291, 292, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("acm", 9), ("ps60W", 10), ("ps100W", 11), ("ps", 17), ("cl1", 20), ("clEth", 21), ("cl2", 22), ("cl2Eth", 23), ("cl3", 24), ("cl3Eth", 25), ("cl1Clk", 26), ("mPh1", 31), ("mPh3", 32), ("mPh1T1DSU", 33), ("mPh1T1CSU", 34), ("mPh1E1DSU", 35), ("mPh1E1LTU", 36), ("mtmlFT1", 37), ("mtmlFE1", 38), ("mtmlH4E1", 39), ("mtmlH4E12W", 40), ("mtmlH4T1", 41), ("mtmlH4T12W", 42), ("mtHsh4E1", 43), ("mtHsh4E12W", 44), ("mtHsh4T1", 45), ("mtHsh4T12W", 46), ("mtmlH2E1", 47), ("mtmlH2E12W", 48), ("mtmlH2T1", 49), ("mtmlH2T12W", 50), ("hsh2E1", 51), ("hsh2E12W", 52), ("hsh2T1", 53), ("hsh2T12W", 54), ("mlIp", 55), ("mtml4Ip", 56), ("ml20N1", 57), ("ml20N2", 58), ("mPl6", 60), ("mPl3", 61), ("vf24T1", 62), ("vf30E1", 63), ("vf48T1", 64), ("vf60E1", 65), ("ml2E1", 68), ("ml4E1", 69), ("ml2T1", 70), ("ml4T1", 71), ("mPv4", 72), ("vc16A", 73), ("vc8EandM", 74), ("vc8Fxo", 75), ("vc8Fxs", 76), ("vc16EandM", 77), ("vc16Fxo", 78), ("vc16Fxs", 79), ("vf3EandM", 80), ("vf3Fxs", 81), ("vf3Fxo", 82), ("vfPbx", 83), ("vfPbxT1", 84), ("vfPbxE1", 85), ("mtMlE2S", 86), ("mtMlE2D", 87), ("mtMlF2T1", 88), ("mtMlF2E1", 89), ("mtMlT1Fiber", 90), ("mtMlE1Fiber", 91), ("mtMlT1FiberFb", 92), ("mtMlE1FiberFb", 93), ("mtmlHE1", 94), ("mtmlH1E1", 95), ("mtmlHSE1", 96), ("ml20", 97), ("mtMl4T1", 98), ("mtMl4E1", 99), ("mtMl1T1DSU", 100), ("mtMl1T1CSU", 101), ("mtMl1E1DSU", 102), ("mtMl1E1LTU", 103), ("mtMl1T1DSUfb", 104), ("mtMl1T1CSUfb", 105), ("mtMl1E1DSUfb", 106), ("mtMl1E1LTUfb", 107), ("mtMl2T1", 108), ("mtMl2E1", 109), ("ls2CcittX50", 110), ("ls2CcittX58", 111), ("ls2ATandTSdm", 112), ("ls2ACcittX50", 113), ("ls2ACcittX58", 114), ("ls2AATandTSdm", 115), ("ls2A2Ts", 116), ("ls2M", 117), ("mtMlT1", 118), ("mtMlE1", 119), ("hs2", 120), ("hs3", 121), ("hsq", 122), ("hs703", 123), ("hsQM", 124), ("hsqN", 125), ("hs6", 126), ("hs12", 127), ("hsDp", 128), ("hsp", 129), ("hs4T1", 130), ("hs4E1", 131), ("hs4", 132), ("hsEth", 133), ("ml8T1", 134), ("ml8E1", 135), ("vc2E1", 136), ("vc4E1", 137), ("vc2T1", 138), ("vc4T1", 139), ("vc2EandM", 140), ("vc2Fxs1Plar", 141), ("vc2Fxo1", 142), ("vc2Fxs2", 143), ("vc2Fxo2", 144), ("vc2Fxs3", 145), ("vc2Fxo3", 146), ("vc26EandM", 147), ("mtvc2", 148), ("vc2R2Fxs", 149), ("hsu", 150), ("mbeA", 151), ("mbeB", 152), ("mbeU", 153), ("tre", 154), ("hsuI", 155), ("hsr", 156), ("hss", 157), ("hsu1", 158), ("ls12", 159), ("ls6", 160), ("ls6V1EandM", 161), ("ls6V1Fxo", 162), ("ls6V1Fxs", 163), ("ls6V2EandM", 164), ("ls6V2Fxo", 165), ("ls6V2Fxs", 166), ("ls6VfEandM", 167), ("ls6VfFxo", 168), ("ls6VfFxs", 169), ("vc3EandM", 170), ("vc3Fxo", 171), ("vc3Fxs", 172), ("vcPbx", 173), ("vcPbxT1", 174), ("vcPbxE1", 175), ("vc6EandM", 176), ("vc6Fxo", 177), ("vc6Fxs", 178), ("vcq", 179), ("ls6n", 180), ("mhs1V36", 181), ("mhs1V35", 182), ("mhs1G703", 183), ("mhs1DDS", 184), ("mhs3", 185), ("mhs1X21", 186), ("mhs1V24", 187), ("mhs4", 188), ("mhsE1Hs", 189), ("mhsT1Hs", 190), ("mhsHyE1Hs", 191), ("mhsHyT1Hs", 192), ("mlfHybE1Hs", 193), ("mlfHybT1Hs", 194), ("mhs2e1", 195), ("mhs2t1", 196), ("mhsHy2e1", 197), ("mhsHy2t1", 198), ("mlfHybE12", 199), ("mls6", 200), ("mls3", 201), ("mlHybAtmE1", 202), ("mlHybAtmT1", 203), ("mlfHybT12", 204), ("mvc8", 205), ("mvc8PbxE1", 206), ("mvc8PbxT1Dsu", 207), ("mvc8PbxT1Csu", 208), ("mvc8PbxE1Slave", 209), ("mvc4", 210), ("mvc4PbxE1", 211), ("mvc4PbxT1Dsu", 212), ("mvc4PbxT1Csu", 213), ("mvc4PbxE1Slave", 214), ("mvc4PbxT1Slave", 215), ("mvc8PbxT1Slave", 216), ("mvc8ExtAnalog", 217), ("mvcE1", 218), ("mvcT1", 219), ("mhsS", 220), ("mhsU", 221), ("mhsPriE1", 222), ("mhsPriT1", 223), ("hsEthSwitch", 224), ("mPriE1FramerCcs", 225), ("mPriT1FramerCcs", 226), ("mPriE1SlaveCcs", 227), ("mPriT1SlaveCcs", 228), ("mDualBri", 229), ("vc12EandM", 230), ("vc12Fxo", 231), ("vc12Fxs", 232), ("vc6aEandM", 233), ("vc6aFxo", 234), ("vc6aFxs", 235), ("vc6AgFxo", 236), ("vc6AgFxs", 237), ("vc6a4LB", 238), ("vid", 239), ("hsu12", 240), ("hsu6", 241), ("hss12", 242), ("hss6", 243), ("hsDp3", 244), ("hsDp6", 245), ("hsf1", 246), ("mhsHyE1", 247), ("mhsHyT1", 248), ("mhsIp", 249), ("mlIpHs", 250), ("mlHybIpE1", 251), ("mlHybIpT1", 252), ("mvg1Lan", 253), ("mvg2Lan", 254), ("vc4Fxs", 255), ("vc4EandM", 256), ("vc4Fxo", 257), ("hsf2", 258), ("mvgSwitch4Lan", 260), ("msl4E1W2", 261), ("msl4E1W4", 262), ("msl8E1W2", 263), ("msl4E1W2Eth", 264), ("msl8E1W2Eth", 265), ("asmi54cE1AndEth", 266), ("asmi54cT1AndEth", 267), ("hs6N", 271), ("hs12N", 272), ("hsNRZ", 273), ("evc2E1", 281), ("evc4E1", 282), ("evc2T1", 283), ("evc4T1", 284), ("vc2E1Pri", 285), ("vc4E1Pri", 286)) + NamedValues(("vc4OmniEandM", 291), ("vc4OmniWestern", 292), ("clx1", 301), ("clx1GbE", 302), ("clx1S155", 303), ("clx1S155GbE", 304), ("ml8T1Eth", 305), ("ml8E1Eth", 306), ("op106cEth", 307), ("op108cEth", 308), ("op106cEthT1", 309), ("op108cEthE1", 310), ("op108cEthE1Unbal", 311), ("mpw1", 312), ("vfs24T1", 321), ("vfs30E1", 322), ("vfs48T1", 323), ("vfs60E1", 324), ("mm4E1", 325), ("mm4T1", 326), ("mm8E1", 327), ("mm8T1", 328), ("mm12E1", 329), ("mm12T1", 330), ("mm16E1", 331), ("mm16T1", 332)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSInstCardType.setStatus('current')
if mibBuilder.loadTexts: mdlSInstCardType.setDescription('This attribute indicates the type of card installed in the specific slot position. Only PS cards are possible in the PS slots. Only CL cards are possible in the CL slots. Only IO cards are possible in the IO slots.')
mdlSHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwVersion.setStatus('current')
if mibBuilder.loadTexts: mdlSHwVersion.setDescription('This attribute indicates the Hardware version of the installed card in the specific slot position.')
mdlSSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSwVersion.setStatus('current')
if mibBuilder.loadTexts: mdlSSwVersion.setDescription('This attribute indicates the Software version of the installed card in the specific slot position.')
mdlSAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrStatus.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrStatus.setDescription('Indicates the alarm state at module level, i.e. lower level (port alarms) status is not included. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSAlrStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrStatusAll.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrStatusAll.setDescription('Indicates the alarm state in the module-all level, i.e. lower level (port alarms) included. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSMaskedAlrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSMaskedAlrStat.setStatus('current')
if mibBuilder.loadTexts: mdlSMaskedAlrStat.setDescription('Indicates the alarm state at module level, [i.e. lower level (port alarms) status is not included],including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSMaskedAlrStatAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSMaskedAlrStatAll.setStatus('current')
if mibBuilder.loadTexts: mdlSMaskedAlrStatAll.setDescription('Indicates the alarm state in the module-all level, i.e. lower level (port alarms) included, including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSTstStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSTstStatusAll.setStatus('current')
if mibBuilder.loadTexts: mdlSTstStatusAll.setDescription('This attribute will be set to on(3) when there is at least one test in progress on a channel of the card, otherwise the value will be off(2).')
mdlSClearAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSClearAlrCmd.setStatus('current')
if mibBuilder.loadTexts: mdlSClearAlrCmd.setDescription('Setting this command to ON, enforces a clear of all the alarms in the given slot, excluding alarms of port level. The clear operation will not be applied for masked/inverted alarms.')
mdlSClearAllAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSClearAllAlrCmd.setStatus('current')
if mibBuilder.loadTexts: mdlSClearAllAlrCmd.setDescription('Setting this command to ON, enforces a clear of all the alarms in the given slot, including all its ports alarms. The clear operation will not be applied for masked/inverted alarms.')
mdlSTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSTemperature.setStatus('current')
if mibBuilder.loadTexts: mdlSTemperature.setDescription('Temperature of the card, in Celsius degrees.')
mdlSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2), )
if mibBuilder.loadTexts: mdlSAlrTable.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrTable.setDescription('The list of card agent alarms ; includes also an alarm indicating existence of alarms on its ports if there are any.')
mdlSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "mdlSAlrSltIdx"), (0, "RAD-MIB", "mdlSAlrIdx"))
if mibBuilder.loadTexts: mdlSAlrEntry.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrEntry.setDescription('An entry in table.')
mdlSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrIdx.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive.')
mdlSAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrSltIdx.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io12(16) are not valid. For the Vmux2100 Main Board clA (3) is used.')
mdlSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCodeDescription.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm . The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
mdlSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCode.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at card level.')
mdlSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrSeverity.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrSeverity.setDescription('The severity of the alarm.')
mdlSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrState.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrState.setDescription('State of the alarm.')
mdlSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCounter.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
mdlSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrMask.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrMask.setDescription('Alarm mask : on/off.')
mdlSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrInvert.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrInvert.setDescription('Alarm invert : on/off.')
mdlCPrgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1), )
if mibBuilder.loadTexts: mdlCPrgTable.setStatus('current')
if mibBuilder.loadTexts: mdlCPrgTable.setDescription('A table.')
mdlCPrgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlCCnfgIdx"), (0, "RAD-MIB", "mdlCSltIdx"))
if mibBuilder.loadTexts: mdlCPrgEntry.setStatus('current')
if mibBuilder.loadTexts: mdlCPrgEntry.setDescription('An entry in table.')
mdlCCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..100) being referred. Value 255 specifies the TmpCnfg ')
mdlCSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
mdlCPrgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 63, 64, 65, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264, 265, 266, 267, 271, 272, 273, 281, 282, 283, 284), SingleValueConstraint(285, 286, 291, 292, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 321, 322, 323, 324))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("acm", 9), ("ps48x60W", 10), ("ps48x100W", 11), ("ps110x60W", 12), ("ps110x100W", 13), ("ps220x60W", 14), ("ps220x100W", 15), ("ps180W", 16), ("ps", 17), ("cl1", 20), ("clEth", 21), ("cl2", 22), ("cl2Eth", 23), ("cl3", 24), ("cl3Eth", 25), ("cl1Clk", 26), ("mPh1", 31), ("mPh3", 32), ("mPh1T1DSU", 33), ("mPh1T1CSU", 34), ("mPh1E1DSU", 35), ("mPh1E1LTU", 36), ("mtmlFT1", 37), ("mtmlFE1", 38), ("mtmlH4E1", 39), ("mtmlH4E12W", 40), ("mtmlH4T1", 41), ("mtmlH4T12W", 42), ("mtHsh4E1", 43), ("mtHsh4E12W", 44), ("mtHsh4T1", 45), ("mtHsh4T12W", 46), ("mtmlH2E1", 47), ("mtmlH2E12W", 48), ("mtmlH2T1", 49), ("mtmlH2T12W", 50), ("hsh2E1", 51), ("hsh2E12W", 52), ("hsh2T1", 53), ("hsh2T12W", 54), ("mlIp", 55), ("mtml4Ip", 56), ("ml20N1", 57), ("ml20N2", 58), ("mPl6", 60), ("vf24T1", 62), ("vf30E1", 63), ("vf48T1", 64), ("vf60E1", 65), ("ml2E1", 68), ("ml4E1", 69), ("ml2T1", 70), ("ml4T1", 71), ("vc16A", 73), ("vc8EandM", 74), ("vc8Fxo", 75), ("vc8Fxs", 76), ("vc16EandM", 77), ("vc16Fxo", 78), ("vc16Fxs", 79), ("vf3EandM", 80), ("vf3Fxs", 81), ("vf3Fxo", 82), ("vfPbx", 83), ("vfPbxT1", 84), ("vfPbxE1", 85), ("mtMlE2S", 86), ("mtMlE2D", 87), ("mtMlF2T1", 88), ("mtMlF2E1", 89), ("mtMlT1Fiber", 90), ("mtMlE1Fiber", 91), ("mtMlT1FiberFb", 92), ("mtMlE1FiberFb", 93), ("mtmlHE1", 94), ("mtmlH1E1", 95), ("mtmlHSE1", 96), ("ml20", 97), ("mtMl4T1", 98), ("mtMl4E1", 99), ("mtMl1T1DSU", 100), ("mtMl1T1CSU", 101), ("mtMl1E1DSU", 102), ("mtMl1E1LTU", 103), ("mtMl1T1DSUfb", 104), ("mtMl1T1CSUfb", 105), ("mtMl1E1DSUfb", 106), ("mtMl1E1LTUfb", 107), ("mtMl2T1", 108), ("mtMl2E1", 109), ("ls2CcittX50", 110), ("ls2CcittX58", 111), ("ls2ATandTSdm", 112), ("ls2ACcittX50", 113), ("ls2ACcittX58", 114), ("ls2AATandTSdm", 115), ("ls2A2Ts", 116), ("ls2M", 117), ("mtMlT1", 118), ("mtMlE1", 119), ("hs2", 120), ("hs3", 121), ("hsq", 122), ("hs703", 123), ("hsQM", 124), ("hsqN", 125), ("hs6", 126), ("hs12", 127), ("hsDp", 128), ("hsp", 129), ("hs4T1", 130), ("hs4E1", 131), ("hsEth", 133), ("ml8T1", 134), ("ml8E1", 135), ("vc2E1", 136), ("vc4E1", 137), ("vc2T1", 138), ("vc4T1", 139), ("vc2EandM", 140), ("vc2Fxs1Plar", 141), ("vc2Fxo1", 142), ("vc2Fxs2", 143), ("vc2Fxo2", 144), ("vc2Fxs3", 145), ("vc2Fxo3", 146), ("vc26EandM", 147), ("mtvc2", 148), ("vc2R2Fxs", 149), ("hsu", 150), ("mbeA", 151), ("mbeB", 152), ("mbeU", 153), ("tre", 154), ("hsuI", 155), ("hsr", 156), ("hss", 157), ("hsu1", 158), ("ls12", 159), ("ls6", 160), ("ls6V1EandM", 161), ("ls6V1Fxo", 162), ("ls6V1Fxs", 163), ("ls6V2EandM", 164), ("ls6V2Fxo", 165), ("ls6V2Fxs", 166), ("ls6VfEandM", 167), ("ls6VfFxo", 168), ("ls6VfFxs", 169), ("vc3EandM", 170), ("vc3Fxo", 171), ("vc3Fxs", 172), ("vcPbx", 173), ("vcPbxT1", 174), ("vcPbxE1", 175), ("vc6EandM", 176), ("vc6Fxo", 177), ("vc6Fxs", 178), ("vcq", 179), ("ls6n", 180), ("mhs1V36", 181), ("mhs1V35", 182), ("mhs1G703", 183), ("mhs1DDS", 184), ("mhs3", 185), ("mhs1X21", 186), ("mhs1V24", 187), ("mhs4", 188), ("mhsE1Hs", 189), ("mhsT1Hs", 190), ("mhsHyE1Hs", 191), ("mhsHyT1Hs", 192), ("mlfHybE1Hs", 193), ("mlfHybT1Hs", 194), ("mhs2e1", 195), ("mhs2t1", 196), ("mhsHy2e1", 197), ("mhsHy2t1", 198), ("mlfHybE12", 199), ("mls6", 200), ("mls3", 201), ("mlHybAtmE1", 202), ("mlHybAtmT1", 203), ("mlfHybT12", 204), ("mvc8", 205), ("mvc8PbxE1", 206), ("mvc8PbxT1Dsu", 207), ("mvc8PbxT1Csu", 208), ("mvc8PbxE1Slave", 209), ("mvc4", 210), ("mvc4PbxE1", 211), ("mvc4PbxT1Dsu", 212), ("mvc4PbxT1Csu", 213), ("mvc4PbxE1Slave", 214), ("mvc4PbxT1Slave", 215), ("mvc8PbxT1Slave", 216), ("mvc8ExtAnalog", 217), ("mvcE1", 218), ("mvcT1", 219), ("mhsS", 220), ("mhsU", 221), ("mhsPriE1", 222), ("mhsPriT1", 223), ("hsEthSwitch", 224), ("mPriE1FramerCcs", 225), ("mPriT1FramerCcs", 226), ("mpriE1SlaveCcs", 227), ("mpriT1SlaveCcs", 228), ("mDualBri", 229), ("vc12EandM", 230), ("vc12Fxo", 231), ("vc12Fxs", 232), ("vc6aEandM", 233), ("vc6aFxo", 234), ("vc6aFxs", 235), ("vc6AgFxo", 236), ("vc6AgFxs", 237), ("vc6a4LB", 238), ("vid", 239), ("hsu12", 240), ("hsu6", 241), ("hss12", 242), ("hss6", 243), ("hsDp3", 244), ("hsDp6", 245), ("hsf1", 246), ("mhsHyE1", 247), ("mhsHyT1", 248), ("mhsIp", 249), ("mlIpHs", 250), ("mlHybIpE1", 251), ("mlHybIpT1", 252), ("mvg1Lan", 253), ("mvg2Lan", 254), ("vc4Fxs", 255), ("vc4EandM", 256), ("vc4Fxo", 257), ("hsf2", 258), ("mvgSwitch4Lan", 260), ("msl4E1W2", 261), ("msl4E1W4", 262), ("msl8E1W2", 263), ("msl4E1W2Eth", 264), ("msl8E1W2Eth", 265), ("asmi54cE1AndEth", 266), ("asmi54cT1AndEth", 267), ("hs6N", 271), ("hs12N", 272), ("hsNRZ", 273), ("evc2E1", 281), ("evc4E1", 282), ("evc2T1", 283), ("evc4T1", 284)) + NamedValues(("vc2E1Pri", 285), ("vc4E1Pri", 286), ("vc4OmniEandM", 291), ("vc4OmniWestern", 292), ("clx1", 301), ("clx1GbE", 302), ("clx1S155", 303), ("clx1S155GbE", 304), ("ml8T1Eth", 305), ("ml8E1Eth", 306), ("op106cEth", 307), ("op108cEth", 308), ("op106cEthT1", 309), ("op108cEthE1", 310), ("op108cEthE1Unbal", 311), ("mpw1", 312), ("vfs24T1", 321), ("vfs30E1", 322), ("vfs48T1", 323), ("vfs60E1", 324)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCPrgCardType.setStatus('current')
if mibBuilder.loadTexts: mdlCPrgCardType.setDescription('This attribute indicates the type of card assigned to the specific slot in the common configuration. This object is identical in all the configurations (1..100). Only the TmpCnf(255) may have different value. The write operation is valid only to the TmpCnfg entry.')
mdlCNoOfExternPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfExternPrt.setStatus('current')
if mibBuilder.loadTexts: mdlCNoOfExternPrt.setDescription('Number of external ports in the programmed card of the specific slot position')
mdlCNoOfInternPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfInternPrt.setStatus('current')
if mibBuilder.loadTexts: mdlCNoOfInternPrt.setDescription('Number of internal ports in the programmed card of the specific slot position.')
mdlCWorkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("standAlone", 2), ("integrated", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCWorkMode.setStatus('current')
if mibBuilder.loadTexts: mdlCWorkMode.setDescription('Working mode of the card. The user may configure the card to work in a stand alone mode or integrated with the device. Example for use in MHS-IP cards: - standAlone - in this mode, the router works so that data is received via the LAN (Eth) port and is transmitted via the WAN (HS) external port without going through the MPH device. - integrated - in this mode, the router works so that it is integrated in the MPH and routes DLCIs into the device.')
mdlCDhcpClientEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCDhcpClientEnable.setStatus('current')
if mibBuilder.loadTexts: mdlCDhcpClientEnable.setDescription('Enable/Disable the feature of DHCP Client for the selected card.')
mdlCRdnExists = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCRdnExists.setStatus('current')
if mibBuilder.loadTexts: mdlCRdnExists.setDescription("This object indicates whether any port of the programmed card is configured to be part of a Redundancy/APS pair. If at least one port of the programmed card is configured to be part of a Redundancy/APS pair, the value will be 'yes'. Otherwise, it will be 'no'.")
mdlCInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCInterfaces.setStatus('current')
if mibBuilder.loadTexts: mdlCInterfaces.setDescription("Octet string which indicates 'present' interfaces in card. Each '0' bit stands for non-present interface. Each '1' bit stands for present interface. For ASMi54C card of LRS-102 and MP-4100 notPresent interfaces may be: - SHDSL Line ID with no wire pairs assigned to it (does not exist in ifTable) - PCS without SHDSL Line binded to it, (exist in ifTable, with ifOperStatus= notPresent) - External DS1 when its LIU is used by an Internal DS1 of the same card - Internal DS1 when single bearer is not TDM. In each octet, MS bit represents port 1 and LS bit represents port 8 MSB LSB 1 0 0 0 1 0 0 0 -- Example: Port # 1 and 5 are present. Port 1 2 3 4 5 6 7 8 1st Octet (MSB octet) represents SDHSL Lines 2nd Octet represents PCS 3rd Octet represents External DS1 4th Octet represents Internal DS1 5th and 6th Octets are reserved for future Internal DS1. For OP-108/106 cards of LRS-102 and MP-4100 notPresent interfaces may be: - External DS1 when its 'associated' Int-DS1 port is connected to another card - Internal DS1 when its 'associated' Ext-DS1 port is connected to another card (Both may be 'present' when inter-connected). 1st Octet represents External DS1 2nd Octet represents Internal DS1 Bit representation, same as for ASMi-54C card. ")
mdlCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1), )
if mibBuilder.loadTexts: mdlCmprTable.setStatus('current')
if mibBuilder.loadTexts: mdlCmprTable.setDescription('A table.')
mdlCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlCmprTypIdx"), (0, "RAD-MIB", "mdlCmprCnfgIdx"), (0, "RAD-MIB", "mdlCmprVersion"), (0, "RAD-MIB", "mdlCmprSltIdx"))
if mibBuilder.loadTexts: mdlCmprEntry.setStatus('current')
if mibBuilder.loadTexts: mdlCmprEntry.setDescription('An entry in table.')
mdlCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprTypIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
mdlCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
mdlCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprVersion.setStatus('current')
if mibBuilder.loadTexts: mdlCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
mdlCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
mdlCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCmprObj.setStatus('current')
if mibBuilder.loadTexts: mdlCmprObj.setDescription('This attribute is the compressed information itself.')
mdlAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2), )
if mibBuilder.loadTexts: mdlAlarmsCmprTable.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprTable.setDescription('A table.')
mdlAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "mdlAlarmsCmprVersion"), (0, "RAD-MIB", "mdlAlarmsCmprAlarmSlot"), (0, "RAD-MIB", "mdlAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: mdlAlarmsCmprEntry.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprEntry.setDescription('An entry in table.')
mdlAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprVersion.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
mdlAlarmsCmprAlarmSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmSlot.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmSlot.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid.')
mdlAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmIdx.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
mdlAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlAlarmsCmprObj.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
prtSInstTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1), )
if mibBuilder.loadTexts: prtSInstTable.setStatus('current')
if mibBuilder.loadTexts: prtSInstTable.setDescription('A table.')
prtSInstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtSInstSltIdx"), (0, "RAD-MIB", "prtSInstPrtIdx"))
if mibBuilder.loadTexts: prtSInstEntry.setStatus('current')
if mibBuilder.loadTexts: prtSInstEntry.setDescription('An entry in table.')
prtSInstSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtSInstSltIdx.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted. In the ?004 Unit the entries io6(10)..io(16) are not valid. For the Vmux2100 Main Board clA (3) is used.')
prtSInstPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtSInstPrtIdx.setDescription("This attribute indicates a unique number to identify a port in a specific card. The valid ports depend on the installed card: the valid external ports (interfaces) are (1..mdlCNoOfExternPrt) if any, and the valid internal ports are (101..100+mdlCNoOfInternPrt) if any. Generally, for MP-2100/2200: exPrt1 (1) .. exPrt16 (16),inPrt1(101) .. inPrt48 (148) For the Vmux-2100 device: This index will have values of 1...4 for the physical ports & values of ifIndex for the bundles. For other products, see product's spec.")
prtSInstPrtType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("external", 2), ("internal", 3), ("highSpeedV35", 4), ("highSpeedV24", 5), ("highSpeedV36", 6), ("highSpeedX21", 7), ("highSpeedG703", 8), ("highSpeedDDS", 9), ("lowSpeed", 10), ("voice", 11), ("cl", 12), ("isdns", 13), ("isdnu", 14), ("ethernet", 15), ("voiceS0", 16), ("voiceU", 17), ("voiceQsigS", 18), ("voiceQsigU", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstPrtType.setStatus('current')
if mibBuilder.loadTexts: prtSInstPrtType.setDescription("This attribute describes the type of the designated port. In MX 3000 only external & internal options are used. All the other options are only for MX 30/300 which need special handling. In order to support interface types in MX 3000, return an ascii string for prtSInterfaceType in this table or support the general RAD value of physicalConnector. External port - is a port with a physical connector. Internal port - might be of two types: a) A composite port which collects a few external ports data into a common bandwidth (usually routed through DS1 link) b) A port which gets only part of the external ports (usually a few DS0's) The following types are used when all ports are external/ internal and the connector/interface type is necessary (for example, stand-alone units): High Speed port types Low Speed port types Voice port types, CL port types. ISDN Voice in MX 30/300 Phase 4: voiceS0 (16), voiceU (17) should be used. ISDN Voice in MX 30/300 Phase 5: voiceQsigS(18), voiceQsigU (19) should be used.")
prtSInstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstIfIndex.setStatus('current')
if mibBuilder.loadTexts: prtSInstIfIndex.setDescription("This attribute indicates the unique interface number assigned to the port. The specific interface of this attribute is the same as the interface identified by the value of ifindex in MIB-II.If there is no interface for the specific prtIdx the value will be '7fffffff'h.")
prtSActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("notUsed", 2), ("offLine", 3), ("onLine", 4), ("offLineRedundancy", 5), ("onLineRedundancy", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSActiveStatus.setStatus('current')
if mibBuilder.loadTexts: prtSActiveStatus.setDescription('This attribute describes the activity status of the port. unknown(1) indicates that the information is not supported. notUsed(2) indicates that the ch is not connected according to the active config. offLine(3) indicates that the ch is down (not working) because of any problem. onLine(4) indicates that the ch is up (working) offLineRedundancy(5) indicates that the ch is down, because it is redundant port. onLineRedundancy(6) indicates that the ch is up, and it is the active link')
prtSAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrStatus.setStatus('current')
if mibBuilder.loadTexts: prtSAlrStatus.setDescription('Indicates the alarm state in the port(ch) agent level. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
prtSMaskedAlrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSMaskedAlrStat.setStatus('current')
if mibBuilder.loadTexts: prtSMaskedAlrStat.setDescription('Indicates the alarm state in the port(ch) agent level, including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
prtSClearAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSClearAlrCmd.setStatus('current')
if mibBuilder.loadTexts: prtSClearAlrCmd.setDescription('Setting this attribute to on(3) enforces a clear operation of the alarm status events in the given port. The clear operation will not be applied for masked/inverted alarms.')
prtSTestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSTestMask.setStatus('current')
if mibBuilder.loadTexts: prtSTestMask.setDescription("This is a mask which indicates which tests from the 'prtSTstCmd' list are allowed for the requested port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- local-loop 1 remote-loop 2 loc-and-rem-main-loops 3 remote-analog-loop 4 remote-digital-loop 5 rem-loop-on-ext-unit 6 bert 7 tone-injection 8 dlci local-loop 9 all dlci local-loop 10 dlci remote-loop 11 all dlci remote-loop 12 bert-and-rem-loop-on-rem-unit 13 rem-loop-on-rem-unit 14 block 15 backward-tone-inject 16 llb 17 rlb 18 ft1Enable 21 lbbd 22 --for 2B+D lb1 23 --for B1 lb2 24 --for B2 llb-on-rem-unit 25 bert-on-rem-unit 26 bert-on-rem-and-llb-on-rem-unit 27 local-and-bert-on-rem-unit 28 local-loop-on-rem-unit 29 localBert 30 --towards IO ports test-per-TS 31 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtSTstCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36))).clone(namedValues=NamedValues(("none", 1), ("localLoop", 2), ("remoteLoop", 3), ("locAndRemMainLoops", 4), ("remoteAnalogLoop", 5), ("remoteDigitalLoop", 6), ("remLoopOnExtUnit", 7), ("bert", 8), ("toneInjection", 9), ("dlciLocalLoop", 10), ("allDlciLocalLoop", 11), ("dlciRemoteLoop", 12), ("allDlciRemoteLoop", 13), ("extInitLocalLoop", 14), ("bertAndRemLoopOnRemUnit", 15), ("remLoopOnRemUnit", 16), ("block", 17), ("backwardToneInject", 18), ("llb", 19), ("rlb", 20), ("ft1Enable", 21), ("lbbd", 22), ("lb1", 23), ("lb2", 24), ("llbOnRemUnit", 25), ("bertOnRemUnit", 26), ("bertOnRemAndLlbOnRemUnit", 27), ("localAndBertOnRemUnit", 28), ("localLoopOnRemUnit", 29), ("localBert", 30), ("testPerTS", 31), ("csuLoopAndBert", 32), ("dsuLoopAndBert", 33), ("remoteOcuLoopAndBert", 34), ("remoteCsuLoopAndBert", 35), ("remoteDsuLoopAndBert", 36)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSTstCmd.setStatus('current')
if mibBuilder.loadTexts: prtSTstCmd.setDescription("Setting this attribute to any of the above values will initiate a test on the specific port if the operation is legal. If the operation is not legal, the mux will ignore the operation. testPerTS(31) - when this test is selected, the selection of tests for each TS is done via the prtExPh1MlTsTest object. If a test time out is needed, the test will be set with a default timeout of 2 minutes until the user will set the parameter 'prtSTstDuration' to the required time out. If no time out is needed , the test will be set with infinite timeout until the user will set the parameter 'prtSTstDuration' to the required time out.")
prtSTstDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSTstDuration.setStatus('current')
if mibBuilder.loadTexts: prtSTstDuration.setDescription("This attribute indicates the maximum duration of executing a test on the specific port. This entry applies to all the test operations. The resolution will be a minute, and the maximum duration is limited to 30 minutes. For Vmux devices, the values are in seconds. A zero value specifies no time limitation. When the test isn't active, the agent initiates this object to 2 when the duration is needed and to 0 if its not required. The user should set this parameter after setting the 'prtSTstCmd' parameter.")
prtSBertClrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSBertClrCmd.setStatus('current')
if mibBuilder.loadTexts: prtSBertClrCmd.setDescription('Setting this attribute initiates bert count clear operation. It is valid only when bert test is active on the specific port.')
prtSBertTstRslt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSBertTstRslt.setStatus('current')
if mibBuilder.loadTexts: prtSBertTstRslt.setDescription('This attribute indicates the number of Bit Error Rate indicated during the BERT operation. It is valid only when bert test is active on the specific port.')
prtSInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInterfaceType.setStatus('current')
if mibBuilder.loadTexts: prtSInterfaceType.setDescription('This attribute indicates a unique HW interface type of the selected port.')
prtSParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSParamStatus.setStatus('current')
if mibBuilder.loadTexts: prtSParamStatus.setDescription("This object indicates Status of parameters specific to the selected port. - For a port that has no special status or is supported by prtSExHsfStatTable - 1 Octet: 00hex - For VC-6, VC-6A, VC-6AG, VC-6A/4LB, VC-12, VC-12/6, external ports - 1 Octet : Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 1: Tx Signaling '1'=On ; '0'=Off Bit 0 (LSB): Rx Signaling '1'=On ; '0'=Off - For VC-2/R2(FXS) external ports - 1 Octet : Bit - 7 6 5 4 3 2 1 0 |_| |_________| Call Call State Direction Bit 7 (MSB) and Bit 6 : Call Direction 00 - Incoming 01 - Outgoing Bit 5..Bit 0: Call State 000000 - Idle 000001 - Seized 000010 - Both-Way Conflict 000011 - Seizure Ack 000100 - Answered 000101 - Clear Backward 000110 - Clear Forward 000111 - Blocked 001000 - Fault 001001 - Fault 3 001010 - Fault 4 001011 - Fault 5 001100 - Fault 6 001101 - Fault 7 - For ML-20 external port - 3 Octets : - 1 MS Octet will represent the Real Rate used: Bit - 7 6 5 4 3 2 1 0 |___| |_______| spare Rate Valid values: 0..31, meaning 0..31x64Kbps Invalid values: 32..255. - 2 LS Octets will represent the Status of 7 Control Signals: Signal - --- CTS DSR DCD RJ TM DTR RTS Bit - 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 Octet - 2 3 (LS) '---' will always have the value 00 Rest of the Signals (2 bits each) can have the following values: 00=NA ; 01=unused ; 10=Off ; 11=On - For ML-H/E1, ML-H/1/E1, ML-H/S/E1 internal port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |___________| spare Mode of Operation Mode of Operation: '1'=Central ; '0'=Remote - For ACM external port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |_________| spare Alarm State Alarm State: according to bits 1,0: 00=NA ; 01=unused ; 10=Off ; 11=On - For HS-U/1 external port - 1 Octet Bit 7 6 5 4 3 2 1 0 LSB |________| |__| |__| spare modem sync modem: 00 = other sync: 00 = not sync 01 = unknown 01 = sync 10 = ASMi-31/2 10 = reserved 11 = reserved 11 = reserved - For MTML-2/4 external ports, ML-8 externalports, ML-IP (MTML-IP) internal ports and MTML-E2 internal ports - 1 Octet : Bit 7 6 5 4 3 2 1 0 LSB | BERT State BERT State (Bit 0): 0 = OFF (BERT is not running on this port or any of its TSs/Bits) 1 = ON (BERT is running on this port OR on one of its TSs/Bits) - For ML-20N external ports - 4 Octets - 1 MS Octet will represent the Actual Link Rate: Bit - 7 6 5 4 3 2 1 0 |_| |_________| spare Rate Valid values: 0..34, meaning: 0..32 = (0..32)x64Kbps 33 = Invalid Rate 34 = not applicable (when Rate is not Auto) 35 = 0 Kbps Invalid values: 36..255. - 2 middle Octets will represent the Status of 4 Control Signals: - LS Octet - Bits 3-0: RTS/C (Command, for X.21 interface) Bits 7-4: DCD/I (Indication for X.21 interface) - MS Octet - Bits 3-0: DTR Bits 7-4: DSR Each 4 Bits are divided as follows: - 2 MS bits: DCE - 2 LS bits: DTE For each 2 bits (DCE/DTE): 00=NA ; 01=unused ; 10=Off ; 11=On. - LS Octet: (as for MTML-2): Bit 7 6 5 4 3 2 1 0 LSB | BERT State BERT State (Bit 0): 0 = OFF (BERT is not running on this port or any of its TSs/Bits) 1 = ON (BERT is running on this port OR on one of its TSs/Bits) - For MP-2100/2200 MSL-4/E1, MSL-8/E1 External ports - 3 Octets - MS octet: far-end modem channel interface - Middle octet: Material (plastic/metal), far-end modem type, synchronization with far-end modem - LS octet: BERT state (at port/TS/Bit level) - MS octet: 0000 0000 = no interface 0000 0001 = db15 (X21) 0000 0010 = IR-IP 0000 0011 = IR-ETH-Q 0000 0100 = V35 0000 0101 = ETH-RJ45 0000 0110 = G703 0000 0111 = db25 (RS530) 0000 1000 = ETH-BNC 0000 1001 = E1(Balanced) 0000 1010 = E1(Unbalanced) 0000 1011 = IR-ETH-QN Rest of the combinations: reserved - Middle octet: Bit 7 6 5 4 3 2 1 0 LSB | |___________| |__| Box material modem sync Box material modem: 00000 = other sync: 00 = not sync (for ASMi-52 SA) 00001 = unknown 01 = sync 0=metal 00010 = reserved 10 = reserved 1=plastic 00011 = reserved 11 = reserved 00100 = reserved 00101 = reserved 00110 = ASMi-52 SA/2W/Slave 00111 = ASMi-52 SA/2W/Master 01000 = ASMi-52/CQ card of LRS-24 01001 = ASMi-52/CD card of LRS-24 01010 = D16GSDSL card of DXC-3000 01011 = LRS-52 01100 = FCD-IP 01101 = FCD-IPM 01110 = D8SL card of DXC-30 01111 = ASMi-52A 10000 = MP card (SHDSL) 10001 = ASMi-52L Rest = reserved - LS Octet: (as for MTML-2): Bit 7 6 5 4 3 2 1 0 LSB | BERT State BERT State (Bit 0): 0 = OFF (BERT is not running on this port or any of its TSs) 1 = ON (BERT is running on this port OR on one of its TSs) - For MP-4100 MSL card Links - 4 Octets - MS octet: far-end modem DTE2 interface (same as for MP-2100 MSL cards) - after MS octet: far-end modem DTE1 interface (same as for MP-2100 MSL cards) - before LS octet: Material (plastic/metal), far-end modem type, synchronization with far-end modem (same as for MP-2100 MSL cards) - LS octet: BERT state (at port/TS/Bit level)- same as for MP-2100 MSL cards - For MP-4100, LRS-102 OP-108/106 Links - 3 Octets - MS octet: far-end PS type and state - Middle octet: synchronization with far-end device - LS octet: BERT state (at port/TS level) - same as for MP-2100 MSL cards - MS octet: Bit 7 6 5 4 3 2 1 0 LSB |__| |__| |__| |__| PS-A PS-A PS-B PS-B PS Type PS State PS Type PS State 00=None 00=None 01=AC-DC 01=OK 10=DC 10=Fail - Middle octet: Bit 7 6 5 4 3 2 1 0 LSB |__| sync: 00 = not sync 01 = sync 10 = reserved 11 = reserved Rest = reserved ")
prtSTestMaskXp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSTestMaskXp.setStatus('current')
if mibBuilder.loadTexts: prtSTestMaskXp.setDescription("This is an Expanded test mask of the prtSTestMask object. The prtSTestMask object reached its maximum, being an Integer with 32 bits. This object indicates which tests from the 'prtSTstCmdXP' list are allowed for the selected port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- local-loop 1 remote-loop 2 loc-and-rem-main-loops 3 remote-analog-loop 4 remote-digital-loop 5 rem-loop-on-ext-unit 6 bert 7 tone-injection 8 dlci local-loop 9 all dlci local-loop 10 dlci remote-loop 11 all dlci remote-loop 12 bert-and-rem-loop-on-rem-unit 13 rem-loop-on-rem-unit 14 block 15 backward-tone-inject 16 llb 17 rlb 18 ft1Enable 21 lbbd 22 --for 2B+D lb1 23 --for B1 lb2 24 --for B2 llb-on-rem-unit 25 bert-on-rem-unit 26 bert-on-rem-and-llb-on-rem-unit 27 local-and-bert-on-rem-unit 28 local-loop-on-rem-unit 29 localBert 30 --towards IO ports test-per-TS 31 csuLoopAndBert 32 dsuLoopAndBert 33 remoteOcuLoopAndBert 34 remoteCsuLoopAndBert 35 remoteDsuLoopAndBert 36 e.g : If the return value is 00000003 hex -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtSRdnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRdn", 1), ("offline", 2), ("online", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSRdnStatus.setStatus('current')
if mibBuilder.loadTexts: prtSRdnStatus.setDescription('Redundancy Status of this port. noRdn - this port is not part of a Redundancy pair/group. offline - this port is offline from Redundancy point of view. online - this port is online from Redundancy point of view.')
prtSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2), )
if mibBuilder.loadTexts: prtSAlrTable.setStatus('current')
if mibBuilder.loadTexts: prtSAlrTable.setDescription('The list of port agent alarms.')
prtSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtSAlrSltIdx"), (0, "RAD-MIB", "prtSAlrPrtIdx"), (0, "RAD-MIB", "prtSAlrIdx"))
if mibBuilder.loadTexts: prtSAlrEntry.setStatus('current')
if mibBuilder.loadTexts: prtSAlrEntry.setDescription('An entry in table.')
prtSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrIdx.setStatus('current')
if mibBuilder.loadTexts: prtSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive')
prtSAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtSAlrSltIdx.setDescription('This attribute indicates a unique identifier of the slot where the card is inserted. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io12(16) are not valid. For the Vmux2100 Main Board clA (3) is used.')
prtSAlrPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtSAlrPrtIdx.setDescription("This attribute indicates a unique identifier of the port the alarm applies to. All the values are valid. No alarms exist for a port which does not exist. Valid valuesfor MP-2100/2200: exPrt1 (1) .. exPrt16 (16) , inPrt1 (101) .. inPrt48 (148), IP Bundles. For other products, see product's spec.")
prtSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCodeDescription.setStatus('current')
if mibBuilder.loadTexts: prtSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm. The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
prtSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCode.setStatus('current')
if mibBuilder.loadTexts: prtSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at port level.')
prtSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrSeverity.setStatus('current')
if mibBuilder.loadTexts: prtSAlrSeverity.setDescription('The severity of the alarm.')
prtSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrState.setStatus('current')
if mibBuilder.loadTexts: prtSAlrState.setDescription('State of the alarm.')
prtSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCounter.setStatus('current')
if mibBuilder.loadTexts: prtSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
prtSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrMask.setStatus('current')
if mibBuilder.loadTexts: prtSAlrMask.setDescription('Alarm mask : on/off.')
prtSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrInvert.setStatus('current')
if mibBuilder.loadTexts: prtSAlrInvert.setDescription('Alarm invert : on/off.')
prtSAlrCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 17, 20, 26, 62, 63, 64, 65, 74, 75, 76, 77, 78, 79, 134, 135, 156, 159, 180, 224, 240, 241, 255, 256, 257, 261, 263, 264, 265, 266, 267, 271, 272, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 321, 322, 323, 324))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("ps", 17), ("cl1", 20), ("cl1Clk", 26), ("vf24T1", 62), ("vf30E1", 63), ("vf48T1", 64), ("vf60E1", 65), ("vc8EandM", 74), ("vc8Fxo", 75), ("vc8Fxs", 76), ("vc16EandM", 77), ("vc16Fxo", 78), ("vc16Fxs", 79), ("ml8T1", 134), ("ml8E1", 135), ("hsr", 156), ("ls12", 159), ("ls6n", 180), ("hsEthSwitch", 224), ("hsu12", 240), ("hsu6", 241), ("vc4Fxs", 255), ("vc4EandM", 256), ("vc4Fxo", 257), ("msl4E1W2", 261), ("msl8E1W2", 263), ("msl4E1W2Eth", 264), ("msl8E1W2Eth", 265), ("asmi54cE1AndEth", 266), ("asmi54cT1AndEth", 267), ("hs6N", 271), ("hs12N", 272), ("clx1", 301), ("clx1GbE", 302), ("clx1S155", 303), ("clx1S155GbE", 304), ("ml8T1Eth", 305), ("ml8E1Eth", 306), ("op106cEth", 307), ("op108cEth", 308), ("op106cEthT1", 309), ("op108cEthE1", 310), ("op108cEthE1Unbal", 311), ("mpw1", 312), ("vfs24T1", 321), ("vfs30E1", 322), ("vfs48T1", 323), ("vfs60E1", 324)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCardType.setStatus('current')
if mibBuilder.loadTexts: prtSAlrCardType.setDescription('This attribute indicates the type of card installed in the specific slot position. The enumeration is according to mdlSInstCardType.')
prtFrStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1), )
if mibBuilder.loadTexts: prtFrStatisTable.setStatus('current')
if mibBuilder.loadTexts: prtFrStatisTable.setDescription('This table is applicable only for an active port running an FR protocol .')
prtFrStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtFrStatisSltIdx"), (0, "RAD-MIB", "prtFrStatisPrtIdx"), (0, "RAD-MIB", "prtFrStatisInvIdx"))
if mibBuilder.loadTexts: prtFrStatisEntry.setStatus('current')
if mibBuilder.loadTexts: prtFrStatisEntry.setDescription('An entry in table.')
prtFrStatisSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrStatisSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtFrStatisPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrStatisPrtIdx.setDescription('This attribute indicates a unique port number.')
prtFrStatisInvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentInv", 1), ("last", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisInvIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrStatisInvIdx.setDescription('The Interval of 15 min. for which the following statistics counters are applicable.')
prtFrTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: prtFrTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement interval. This object is applicable mainly for the current interval. For other interval: - if data is available: value will be 899. - if data is not available: value will be 0.')
prtFrRxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxTotalFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrRxTotalFrames.setDescription('The total number of frames received by this port during the selected interval.')
prtFrTxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxTotalFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrTxTotalFrames.setDescription('The total number of frames sent by this port during the selected interval.')
prtFrRxTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxTotalBytes.setStatus('current')
if mibBuilder.loadTexts: prtFrRxTotalBytes.setDescription('The total number of bytes received by this port during the selected interval.')
prtFrTxTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxTotalBytes.setStatus('current')
if mibBuilder.loadTexts: prtFrTxTotalBytes.setDescription('The total number of bytes sent by this port during the selected interval.')
prtFrRxMngFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxMngFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrRxMngFrames.setDescription('The management number of frames received by this port during the selected interval.')
prtFrTxMngFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxMngFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrTxMngFrames.setDescription('The management number of frames sent by this port during the selected interval.')
prtFrRxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDeFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrRxDeFrames.setDescription('The number of De frames received by this port during the selected interval.')
prtFrTxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDeFrames.setStatus('current')
if mibBuilder.loadTexts: prtFrTxDeFrames.setDescription('The number of De frames sent by this port during the selected interval.')
prtFrRxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDcrdCongDeFr.setStatus('current')
if mibBuilder.loadTexts: prtFrRxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, received by this port during the selected interval.')
prtFrTxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDcrdCongDeFr.setStatus('current')
if mibBuilder.loadTexts: prtFrTxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, sent by this port during the selected interval.')
prtFrRxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDcrdCongAllFr.setStatus('current')
if mibBuilder.loadTexts: prtFrRxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, received by this port during the selected interval.')
prtFrTxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDcrdCongAllFr.setStatus('current')
if mibBuilder.loadTexts: prtFrTxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, sent by this port during the selected interval.')
prtFrRxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxFecn.setStatus('current')
if mibBuilder.loadTexts: prtFrRxFecn.setDescription('Number of frames received by this port during the selected interval, indicating forward congestion.')
prtFrTxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxFecn.setStatus('current')
if mibBuilder.loadTexts: prtFrTxFecn.setDescription('Number of frames sent by this port during the selected interval, indicating forward congestion.')
prtFrRxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBecn.setStatus('current')
if mibBuilder.loadTexts: prtFrRxBecn.setDescription('Number of frames received by this port during the selected interval, indicating backward congestion.')
prtFrTxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBecn.setStatus('current')
if mibBuilder.loadTexts: prtFrTxBecn.setDescription('Number of frames sent by this port during the selected interval, indicating backward congestion.')
prtFrRxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBeViol.setStatus('current')
if mibBuilder.loadTexts: prtFrRxBeViol.setDescription('Number of data frames received by this port during the selected interval, exceeding the Burst Excess value.')
prtFrTxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBeViol.setStatus('current')
if mibBuilder.loadTexts: prtFrTxBeViol.setDescription('Number of data frames sent by this port during the selected interval, exceeding the Burst Excess value.')
prtFrRxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBcViol.setStatus('current')
if mibBuilder.loadTexts: prtFrRxBcViol.setDescription('Number of data frames received by this port during the selected interval, exceeding the Burst Committed value.')
prtFrTxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBcViol.setStatus('current')
if mibBuilder.loadTexts: prtFrTxBcViol.setDescription('Number of data frames sent by this port during the selected interval, exceeding the Burst Committed value.')
prtCrStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1), )
if mibBuilder.loadTexts: prtCrStatisTable.setStatus('current')
if mibBuilder.loadTexts: prtCrStatisTable.setDescription('This table is applicable only for an active port running a CR protocol .')
prtCrStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtCrStatisSltIdx"), (0, "RAD-MIB", "prtCrStatisPrtIdx"), (0, "RAD-MIB", "prtCrStatisInvIdx"))
if mibBuilder.loadTexts: prtCrStatisEntry.setStatus('current')
if mibBuilder.loadTexts: prtCrStatisEntry.setDescription('An entry in table.')
prtCrStatisSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtCrStatisSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtCrStatisPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtCrStatisPrtIdx.setDescription('This attribute indicates a unique port number.')
prtCrStatisInvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentInv", 1), ("last", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisInvIdx.setStatus('current')
if mibBuilder.loadTexts: prtCrStatisInvIdx.setDescription('The Interval of 15 min. for which the following statistics counters are applicable.')
prtCrTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: prtCrTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement interval. This object is applicable mainly for the current interval. For other interval: - if data is available: value will be 899. - if data is not available: value will be 0.')
prtCrRxTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrRxTotalCells.setStatus('current')
if mibBuilder.loadTexts: prtCrRxTotalCells.setDescription('The total number of cells received by this port during the selected interval.')
prtCrTxTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTxTotalCells.setStatus('current')
if mibBuilder.loadTexts: prtCrTxTotalCells.setDescription('The total number of cells sent by this port during the selected interval.')
prtCrRxDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrRxDataCells.setStatus('current')
if mibBuilder.loadTexts: prtCrRxDataCells.setDescription('The number of Data Cells received by this port during the selected interval.')
prtCrTxDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTxDataCells.setStatus('current')
if mibBuilder.loadTexts: prtCrTxDataCells.setDescription('The number of Data Cells sent by this port during the selected interval.')
prtDlciStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1), )
if mibBuilder.loadTexts: prtDlciStatisTable.setStatus('current')
if mibBuilder.loadTexts: prtDlciStatisTable.setDescription('This table is applicable only for an active port running an FR, FR+ or CR protocol, with valid DLCIs .')
prtDlciStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtDlciSltIdx"), (0, "RAD-MIB", "prtDlciPrtIdx"), (0, "RAD-MIB", "prtDlciIdx"))
if mibBuilder.loadTexts: prtDlciStatisEntry.setStatus('current')
if mibBuilder.loadTexts: prtDlciStatisEntry.setDescription('An entry in table.')
prtDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciPrtIdx.setDescription('This attribute indicates a unique port number.')
prtDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciIdx.setDescription('This attribute indicates a unique DLCI index for each valid DLCI (16..991). ')
prtDlciRxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDeFrames.setStatus('current')
if mibBuilder.loadTexts: prtDlciRxDeFrames.setDescription('The number of De frames received by this DLCI.')
prtDlciTxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDeFrames.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxDeFrames.setDescription('The number of De frames sent by this DLCI.')
prtDlciRxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDcrdCongDeFr.setStatus('current')
if mibBuilder.loadTexts: prtDlciRxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, received by this DLCI.')
prtDlciTxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDcrdCongDeFr.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, sent by this DLCI.')
prtDlciRxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDcrdCongAllFr.setStatus('current')
if mibBuilder.loadTexts: prtDlciRxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, received by this DLCI.')
prtDlciTxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDcrdCongAllFr.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, sent by this DLCI.')
prtDlciTxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxFecn.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxFecn.setDescription('Number of frames sent by this DLCI, indicating forward congestion.')
prtDlciTxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBecn.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxBecn.setDescription('Number of frames sent by this DLCI, indicating backward congestion.')
prtDlciRxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxBeViol.setStatus('current')
if mibBuilder.loadTexts: prtDlciRxBeViol.setDescription('Number of data frames received by this DLCI, exceeding the Burst Excess value.')
prtDlciTxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBeViol.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxBeViol.setDescription('Number of data frames sent by this DLCI, exceeding the Burst Excess value.')
prtDlciRxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxBcViol.setStatus('current')
if mibBuilder.loadTexts: prtDlciRxBcViol.setDescription('Number of data frames received by this DLCI, exceeding the Burst Committed value.')
prtDlciTxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBcViol.setStatus('current')
if mibBuilder.loadTexts: prtDlciTxBcViol.setDescription('Number of data frames sent by this DLCI, exceeding the Burst Committed value.')
prtT1FdlMsgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1), )
if mibBuilder.loadTexts: prtT1FdlMsgTable.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsgTable.setDescription("This table is applicable for a T1 interface with 'esf' LineType .")
prtT1FdlMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtT1FdlMsgSltIdx"), (0, "RAD-MIB", "prtT1FdlMsgPrtIdx"), (0, "RAD-MIB", "prtT1FdlMsgFdlTxRx"))
if mibBuilder.loadTexts: prtT1FdlMsgEntry.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsgEntry.setDescription('An entry in table.')
prtT1FdlMsgSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsgSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtT1FdlMsgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsgPrtIdx.setDescription('This attribute indicates a unique port number. MTML-1/T1 modules have just one external interface.')
prtT1FdlMsgFdlTxRx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgFdlTxRx.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsgFdlTxRx.setDescription('The Fdl tx/rx reference of the Fdl message.')
prtT1FdlMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsg.setStatus('current')
if mibBuilder.loadTexts: prtT1FdlMsg.setDescription('FDL message.')
prtExTsSplitTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1), )
if mibBuilder.loadTexts: prtExTsSplitTable.setStatus('current')
if mibBuilder.loadTexts: prtExTsSplitTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry, except prtExTsBitTest that will be written directly to the Active Configuration.')
prtExTsSplitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExTsCnfgIdx"), (0, "RAD-MIB", "prtExTsSltIdx"), (0, "RAD-MIB", "prtExTsPrtIdx"), (0, "RAD-MIB", "prtExTsIdx"), (0, "RAD-MIB", "prtExTsBit"))
if mibBuilder.loadTexts: prtExTsSplitEntry.setStatus('current')
if mibBuilder.loadTexts: prtExTsSplitEntry.setDescription('An entry in table.')
prtExTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - for stand-alone units.')
prtExTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTsPrtIdx.setDescription("This attribute indicates a unique port number. Most ML cards have only one external interface. inPrt1 - for MTML-H/E1 cards. For other products' index see their specification.")
prtExTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines, time slot 16 is not valid for data, it is dedicated to multiframe synchronization bits and voice signaling.')
prtExTsBit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsBit.setStatus('current')
if mibBuilder.loadTexts: prtExTsBit.setDescription('This attribute indicates a unique Bit within the time slot. The valid Bits are: 1..8. 255=NA.')
prtExTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTsIConSlot.setStatus('current')
if mibBuilder.loadTexts: prtExTsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - for stand-alone units.')
prtExTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTsIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExTsIConPrt.setDescription("This attribute indicates the internally (In Mux) connected/routed port. For other products' index see their specification.")
prtExTsBitTest = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 30, 255))).clone(namedValues=NamedValues(("none", 1), ("remoteBert", 8), ("localBert", 30), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTsBitTest.setStatus('current')
if mibBuilder.loadTexts: prtExTsBitTest.setDescription('This attribute indicates a test to be activated on the selected Bit. It is applicable only when prtExPh1MlTsTest=split(254). none - no test is applied for the selected Bit. notApplicable - when prtExPh1MlTsTest is NOT split(254).')
prtExTsTxSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsTxSignaling.setStatus('current')
if mibBuilder.loadTexts: prtExTsTxSignaling.setDescription("Link - Tx Signaling per TS, for TSs having TS Type=Voice (agnTsType=voice(2)). It monitors what is sent to Link for the selected TS, for A,B,C,D Signaling Bits. Bit 1= LSB Bit 8= MSB Bit 1-2 = A Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 3-4 = B Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 5-6 = C Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 7-8 = D Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA")
prtExTsRxSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsRxSignaling.setStatus('current')
if mibBuilder.loadTexts: prtExTsRxSignaling.setDescription("Link - Rx Signaling per TS, for TSs having TS Type=Voice (agnTsType=voice(2)). It monitors what is received from Link for the selected TS, for A,B,C,D Signaling Bits. Bit 1= LSB Bit 8= MSB Bit 1-2 = A Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 3-4 = B Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 5-6 = C Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 7-8 = D Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA")
prtExTsTxIoSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsTxIoSignaling.setStatus('current')
if mibBuilder.loadTexts: prtExTsTxIoSignaling.setDescription("IO - Tx Signaling per TS, for TSs having TS Type=Voice (agnTsType=voice(2)). It monitors what is sent to IO port for the selected TS, for A,B,C,D Signaling Bits. Bit 1= LSB Bit 8= MSB Bit 1-2 = A Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 3-4 = B Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 5-6 = C Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 7-8 = D Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA")
prtExTsRxIoSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsRxIoSignaling.setStatus('current')
if mibBuilder.loadTexts: prtExTsRxIoSignaling.setDescription("IO - Rx Signaling per TS, for TSs having TS Type=Voice (agnTsType=voice(2)). It monitors what is received from IO port for the selected TS, for A,B,C,D Signaling Bits. Bit 1= LSB Bit 8= MSB Bit 1-2 = A Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 3-4 = B Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 5-6 = C Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA Bit 7-8 = D Signaling Bit: 00='0' ; 01='1' ; 10=not used ; 11=NA")
prtCnfgAgenda = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2))
prtAgendaBehaviourTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1), )
if mibBuilder.loadTexts: prtAgendaBehaviourTable.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtAgendaBehaviourEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtAgendaBehaviourCnfgIdx"), (0, "RAD-MIB", "prtAgendaBehaviourSltIdx"), (0, "RAD-MIB", "prtAgendaBehaviourPrtIdx"))
if mibBuilder.loadTexts: prtAgendaBehaviourEntry.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourEntry.setDescription('An entry in table.')
prtAgendaBehaviourCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtAgendaBehaviourSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourSltIdx.setDescription('This parameter should be: - slot number for MX3000 - 255 = N/A for MX300/30. ')
prtAgendaBehaviourPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourPrtIdx.setDescription('This parameter should be: - port number for MX300/30 - 100 = N/A for MX3000. ')
prtAgendaBehaviourOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAgendaBehaviourOnOff.setStatus('current')
if mibBuilder.loadTexts: prtAgendaBehaviourOnOff.setDescription('Setting this command to on(3) enables the agenda function at module (3000) or port (300/30) level.')
prtCnfgAgendaTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2), )
if mibBuilder.loadTexts: prtCnfgAgendaTable.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaTable.setDescription('This table allows the user to schedule the time a session is active per week basis.')
prtCnfgAgendaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtCnfgAgendaCnfgIdx"), (0, "RAD-MIB", "prtCnfgAgendaSltIdx"), (0, "RAD-MIB", "prtCnfgAgendaPrtIdx"), (0, "RAD-MIB", "prtCnfgAgendaDayIdx"), (0, "RAD-MIB", "prtCnfgAgendaSesId"))
if mibBuilder.loadTexts: prtCnfgAgendaEntry.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaEntry.setDescription('An entry in table.')
prtCnfgAgendaCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtCnfgAgendaSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaSltIdx.setDescription('This attribute is equal to: -slot number for MX3000 -255 = N/A for MX300/30')
prtCnfgAgendaPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaPrtIdx.setDescription('This attribute is equal to: - port number for MX300/30 - port number for MX3000. For example 1-4 in MHS-4 cards. - 100 = N/A for MX3000 when not used.')
prtCnfgAgendaDayIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6), ("sunday", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaDayIdx.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaDayIdx.setDescription('This attribute for which day of the week this row applies.')
prtCnfgAgendaSesId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaSesId.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaSesId.setDescription('The user may define 4 different active intervals per day.')
prtCnfgAgendaFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(86400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCnfgAgendaFrom.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaFrom.setDescription('Start from time interval in seconds.')
prtCnfgAgendaTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(86400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCnfgAgendaTo.setStatus('current')
if mibBuilder.loadTexts: prtCnfgAgendaTo.setDescription('To time interval in seconds.')
prtGenCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3), )
if mibBuilder.loadTexts: prtGenCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgTable.setDescription('This table allows the user to configure general port parameters.')
prtGenCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtGenCnfgIdx"), (0, "RAD-MIB", "prtGenCnfgSltIdx"), (0, "RAD-MIB", "prtGenCnfgPrtIdx"))
if mibBuilder.loadTexts: prtGenCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgEntry.setDescription('An entry in table.')
prtGenCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtGenCnfgSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtGenCnfgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgPrtIdx.setDescription('This attribute indicates a unique external or internal port number. For MP: exPrt1 (1) .. exPrt16 (16) , notApplicable(100), inPrt1 (101) .. inPrt84 (184) ')
prtGenCnfgLinkToSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgLinkToSlot.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgLinkToSlot.setDescription('This attribute indicates the slot of the ML card to which the IO port is mapped.')
prtGenCnfgLinkToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgLinkToPort.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgLinkToPort.setDescription('This attribute indicates the port in the prtGenCnfgLinkToSlot of the ML card to which the IO port is mapped. For MP: exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , exPrt5 (5) , exPrt6 (6) , exPrt7 (7) , exPrt8 (8) , inPrt1 (101) , inPrt2 (102) , inPrt3 (103) , inPrt4 (104) , inPrt5 (105) , inPrt6 (106) , inPrt7 (107) , inPrt8 (108) , inPrt9 (109), inPrt10 (110), inPrt11 (111), inPrt12 (112), inPrt13 (113), inPrt14 (114), inPrt15 (115), inPrt16 (116), inPrt17 (117), inPrt18 (118), inPrt19 (119), inPrt20 (120), inPrt21 (121), inPrt22 (122), inPrt23 (123), inPrt24 (124), inPrt25 (125), inPrt26 (126), inPrt27 (127), inPrt28 (128), inPrt29 (129), inPrt30 (130), inPrt31 (131), inPrt32 (132), inPrt33 (133), inPrt34 (134), inPrt35 (135), inPrt36 (136), inPrt37 (137), inPrt38 (138), inPrt39 (139), inPrt40 (140), inPrt41 (141), inPrt42 (142), inPrt43 (143), inPrt44 (144), inPrt45 (145), inPrt46 (146), inPrt47 (147), inPrt48 (148), inPrt49 (149), inPrt50 (150), inPrt51 (151), inPrt52 (152), inPrt53 (153), inPrt54 (154), inPrt55 (155), inPrt56 (156), inPrt57 (157), inPrt58 (158), inPrt59 (159), inPrt60 (160), inPrt61 (161), inPrt62 (162), inPrt63 (163), inPrt64 (164), inPrt65 (165), inPrt66 (166), inPrt67 (167), inPrt68 (168), inPrt69 (169), inPrt70 (170), inPrt71 (171), inPrt72 (172), inPrt73 (173), inPrt74 (174), inPrt75 (175), inPrt76 (176), inPrt77 (177), inPrt78 (178), inPrt79 (179), inPrt80 (180), inPrt81 (181), inPrt82 (182), inPrt83 (183), inPrt84 (184), notApplicable (255) ')
prtGenCnfgPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgPortId.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgPortId.setDescription('IO Port Id for V5.1 use. This object is applicable only for part of the PSTN and ISDN IO ports. Generally, 0 is a valid value. Nevertheless, for ports that do not support this object, the value will be: notApplicable= 0')
prtGenCnfgBusConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("partial", 2), ("full", 3), ("partialCD", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgBusConnection.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgBusConnection.setDescription("This object indicates the support of the card regarding Bus Connection. Same value for all ports of the card. partial = 2 Buses (AB) full = 4 Buses (ABCD) partial CD = 2 Buses CD Actually the support depends on the card's HW. But, since CL has to assign data on Buses even when the card is not installed, this object has to be configured. If the actual card installed will not match the value configured, an Alarm will be issued.")
prtGenCnfgInbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgInbandMng.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgInbandMng.setDescription('This object indicates whether Inband Management is used over the link.')
prtGenCnfgInbandMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("none", 1), ("rip2", 2), ("proprietaryRip", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgInbandMngRoutProt.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgInbandMngRoutProt.setDescription('This object indicates the Inband Mng Routing Protocol of the port.')
prtGenCnfgProtectionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("secondary", 2), ("primary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgProtectionMode.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgProtectionMode.setDescription('This object indicates the Protection Mode of the port. notApplicable- when Bus Protection Point=No. For VC-4/Omni card this object is supported RO.')
prtGenCnfgConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgConnect.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtGenCnfgSignalingType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("legacy", 3), ("abcd", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgSignalingType.setStatus('current')
if mibBuilder.loadTexts: prtGenCnfgSignalingType.setDescription('This object selects the Type of Signaling used by the port.')
prtCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1), )
if mibBuilder.loadTexts: prtCmprTable.setStatus('current')
if mibBuilder.loadTexts: prtCmprTable.setDescription('A table.')
prtCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtCmprTypIdx"), (0, "RAD-MIB", "prtCmprCnfgIdx"), (0, "RAD-MIB", "prtCmprVersion"), (0, "RAD-MIB", "prtCmprSltIdx"), (0, "RAD-MIB", "prtCmprPrtIdx"))
if mibBuilder.loadTexts: prtCmprEntry.setStatus('current')
if mibBuilder.loadTexts: prtCmprEntry.setDescription('An entry in table.')
prtCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprTypIdx.setStatus('current')
if mibBuilder.loadTexts: prtCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
prtCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
prtCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprVersion.setStatus('current')
if mibBuilder.loadTexts: prtCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
prtCmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtCmprPrtIdx.setDescription('This attribute indicates a unique identifier of the port the compressed information relates to. Valid values: exPrt1 (1) .. exPrt16 (16) , inPrt1 (101) .. inPrt48 (148).')
prtCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCmprObj.setStatus('current')
if mibBuilder.loadTexts: prtCmprObj.setDescription('This attribute is the compressed information itself.')
prtCmprStatisticObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprStatisticObj.setStatus('current')
if mibBuilder.loadTexts: prtCmprStatisticObj.setDescription('This attribute is the compressed statistics information itself.')
prtDlciCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2), )
if mibBuilder.loadTexts: prtDlciCmprTable.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprTable.setDescription('A table.')
prtDlciCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtDlciCmprCnfgIdx"), (0, "RAD-MIB", "prtDlciCmprVersion"), (0, "RAD-MIB", "prtDlciCmprSltIdx"), (0, "RAD-MIB", "prtDlciCmprPrtIdx"), (0, "RAD-MIB", "prtDlciCmprDlciIdx"))
if mibBuilder.loadTexts: prtDlciCmprEntry.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprEntry.setDescription('An entry in table.')
prtDlciCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
prtDlciCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprVersion.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtDlciCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the module is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
prtDlciCmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprPrtIdx.setDescription('This attribute indicates a unique identifier of the port the compressed information relates to. All the values are valid.')
prtDlciCmprDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprDlciIdx.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprDlciIdx.setDescription('This attribute indicates a unique identifier of the Dlci the compressed information relates to. The values are between 16 - 991.')
prtDlciCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDlciCmprObj.setStatus('current')
if mibBuilder.loadTexts: prtDlciCmprObj.setDescription('This attribute is the compressed information itself.')
prtAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3), )
if mibBuilder.loadTexts: prtAlarmsCmprTable.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprTable.setDescription('A table.')
prtAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtAlarmsCmprVersion"), (0, "RAD-MIB", "prtAlarmsCmprAlarmSlot"), (0, "RAD-MIB", "prtAlarmsCmprAlarmPort"), (0, "RAD-MIB", "prtAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: prtAlarmsCmprEntry.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprEntry.setDescription('An entry in table.')
prtAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprVersion.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtAlarmsCmprAlarmSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmSlot.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmSlot.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid. For Stand-alone units, notApplicable(255) will appear.')
prtAlarmsCmprAlarmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmPort.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmPort.setDescription('This attribute indicates a unique identifier of the port the alarm applies to. All the values are valid. No alarms exist for a non-existing port. IP Bundles are considered a port too, for this matter.')
prtAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmIdx.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
prtAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprObj.setStatus('current')
if mibBuilder.loadTexts: prtAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
prtSExHsfStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6), )
if mibBuilder.loadTexts: prtSExHsfStatTable.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfStatTable.setDescription('A table.')
prtSExHsfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1), ).setIndexNames((0, "RAD-MIB", "prtSExHsfSltIdx"), (0, "RAD-MIB", "prtSExHsfPrtIdx"))
if mibBuilder.loadTexts: prtSExHsfStatEntry.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfStatEntry.setDescription('An entry in table.')
prtSExHsfSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtSExHsfPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfPrtIdx.setDescription('This attribute indicates a unique port number. ')
prtSExHsfInterfaceTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("v35", 2), ("rs422", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfInterfaceTyp.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfInterfaceTyp.setDescription('This attribute indicates a unique interface type of a selected port.')
prtSExHsfRts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("notActive", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfRts.setStatus('current')
if mibBuilder.loadTexts: prtSExHsfRts.setDescription('This attribute indicates a unique RTS control signal state.')
prtIsdnStatusTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16), )
if mibBuilder.loadTexts: prtIsdnStatusTable.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusTable.setDescription("This table contains ISDN Statistics parameters that do not appear in the standard MIBs or for agents that don't support the standard Index of Call Set Up Time.")
prtIsdnStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtIsdnStatusEntry.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusEntry.setDescription("Entries for ISDN Statistics parameters that do not appear in the standard MIBs or for agents that don't support the standard Index of Call Set Up Time.")
prtIsdnStatusDspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("voice", 2), ("idle", 3), ("fax", 4), ("vbd", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusDspMode.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusDspMode.setDescription('The DSP can be in one of the following Modes: Voice, Idle, Fax, Voice Band Data (VBD)- Modem.')
prtIsdnStatusCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("present", 2), ("overlapReceive", 3), ("incoming", 4), ("receive", 5), ("initiated", 6), ("overlapSend", 7), ("outGoingProceed", 8), ("callDeliver", 9), ("active", 10), ("disconnectIndicate", 11), ("releaseRequest", 12), ("disconnectReq", 13), ("notActive", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusCallState.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusCallState.setDescription('The state that the current call is in.')
prtIsdnStatusCallingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusCallingNumber.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusCallingNumber.setDescription('This is the local Number (ISDN Address) associated with this entry.')
prtIsdnStatusCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusCalledNumber.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusCalledNumber.setDescription('This is the remote Number (ISDN Address) associated with this entry.')
prtIsdnStatusCalledIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusCalledIP.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusCalledIP.setDescription('This is the remote IP Address associated with this entry.')
prtIsdnStatusCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("incoming", 2), ("outgoing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnStatusCallDirection.setStatus('current')
if mibBuilder.loadTexts: prtIsdnStatusCallDirection.setDescription('Attribute indicating the Direction of the Call. The value of notApplicable will be used for example when prtIsdnStatusCallState = notActive(14).')
cnfgMdlMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1))
mdlPbxFramerCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1))
mdlPbxFramerCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1), )
if mibBuilder.loadTexts: mdlPbxFramerCnfgTable.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFramerCnfgTable.setDescription('This table contains parameters relevant to a module belonging to a digital voice system, except mdlPbxFraEnhEcho which is relevant also for analog cards.')
mdlPbxFramerCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlPbxFraCnfgIdx"), (0, "RAD-MIB", "mdlPbxFraSltIdx"))
if mibBuilder.loadTexts: mdlPbxFramerCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFramerCnfgEntry.setDescription('An entry in table.')
mdlPbxFraCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPbxFraCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
mdlPbxFraSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPbxFraSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraSltIdx.setDescription('The slot relevant to this module.')
mdlPbxFraEnhEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("ms16", 3), ("ms32", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraEnhEcho.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraEnhEcho.setDescription('Refers to external ports of an analogue module and to the internal ports of the other mvc4 types of modules. ms16(3) means that the four voice ports have enhanced echo of 16ms. ms32(4) means that the two first ports have enhanced echo of 32 ms while the last two ports have no enhanced echo.')
mdlPbxFraTSGroupAss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("group1", 1), ("group2", 2), ("group3", 3), ("group4", 4), ("group5", 5), ("group6", 6), ("group7", 7), ("group8", 8), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraTSGroupAss.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraTSGroupAss.setDescription('In case of T1 modules: group1=(1,2,3,4), ...., group6=(21,22,23,24) while in case of E1 modules: - If prtExPh1MlLineType=g732sE1 or g732sE1CRC: group1=(1,2,3,4),..,group4=(13,14,15,17), group5=(18,19,20,21),...,group7=(26,27,28,29) group8=(30,31). - If prtExPh1MlLineType=g732nE1 or g732nE1CRC: group1=(1,2,3,4),..,group4=(13,14,15,16), group5=(17,18,19,20),...,group7=(25,26,27,28) group8=(29,30,31).')
mdlPbxFraSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("tieTrunk", 2), ("tieInvert", 3), ("casTrans", 4), ("userDefined", 5), ("ccsTrans", 6), ("noSignaling", 7))).clone('casTrans')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalMode.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraSignalMode.setDescription('Refers to the signaling mode of the Framer module. tieTrunk(2), tieInvert(3), casTrans(4) are standard coding of the signaling protocol. casTrans(4) is Channel Associated Signaling (the signaling is within the channels time slot). ccsTrans(6) is Transparent Common Channel Signaling (the signaling is not within the channels time slot - a TS for signaling is used). userDefined(5) allows the user to define the signaling protocol he wants. In this case, the next two MIB fields are relevant.')
mdlPbxFraSignalVector = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 6), OctetString().clone(hexValue="0000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalVector.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraSignalVector.setDescription('In the case of mdlPbxFraSignalMode = userDefined(5), this field defines the A,B,C Bits. D bit is supplied for future versions. Bit 1 = Bit A ON Hook - Local Bit 2 = Bit B ON Hook - Local Bit 3 = Bit C ON Hook - Local Bit 4 = Bit D ON Hook - Local Bit 5 = Bit A OFF Hook - Local Bit 6 = Bit B OFF Hook - Local Bit 7 = Bit C OFF Hook - Local Bit 8 = Bit D OFF Hook - Local Bit 9 = Bit A ON Hook - Remote Bit 10 = Bit B ON Hook - Remote Bit 11 = Bit C ON Hook - Remote Bit 12 = Bit D ON Hook - Remote Bit 13 = Bit A OFF Hook - Remote Bit 14 = Bit B OFF Hook - Remote Bit 15 = Bit C OFF Hook - Remote Bit 16 = Bit D OFF Hook - Remote In conjunction with the Mask, mdlPbxFraSignalMask, it is possible to compute the signal mode.')
mdlPbxFraSignalMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 7), OctetString().clone(hexValue="ffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalMask.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraSignalMask.setDescription("In the case of mdlPbxFraSignalMode = userDefined(5), this field defines the 'don't care' A,B,C Bits. D bit is supplied for future versions. Bit 1 = Bit A ON Hook - Local Bit 2 = Bit B ON Hook - Local Bit 3 = Bit C ON Hook - Local Bit 4 = Bit D ON Hook - Local Bit 5 = Bit A OFF Hook - Local Bit 6 = Bit B OFF Hook - Local Bit 7 = Bit C OFF Hook - Local Bit 8 = Bit D OFF Hook - Local Bit 9 = Bit A ON Hook - Remote Bit 10 = Bit B ON Hook - Remote Bit 11 = Bit C ON Hook - Remote Bit 12 = Bit D ON Hook - Remote Bit 13 = Bit A OFF Hook - Remote Bit 14 = Bit B OFF Hook - Remote Bit 15 = Bit C OFF Hook - Remote Bit 16 = Bit D OFF Hook - Remote.")
mdlPbxFraFramerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraFramerSlot.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraFramerSlot.setDescription('Slot where is sitting the Framer.')
mdlPbxFraSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("endToEnd", 2), ("localTermination", 3))).clone('endToEnd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignaling.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraSignaling.setDescription('Signaling - describes the way the signaling ABCD bits pass from the local extension to the remote extension and vice-versa. endToEnd = the signaling ABCD bits pass without change from local to remote extension. localTermination = the signaling ABCD bits received from the local extension are translated to different ON Hook/OFF Hook bit values and then passed to remote extension. This is relevant when the Local and Remote ON Hook/OFF Hook values are different.')
mdlPbxFraTransSigTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraTransSigTs.setStatus('current')
if mibBuilder.loadTexts: mdlPbxFraTransSigTs.setDescription('This is the Time Slot that is used for Transparent CCS signaling. The values of this TS are 1-24 for T1 & 1-31 for E1. The default for E1 is 16 & for T1 it is 24. If no signaling is used then the TS should be 255 (None).')
mdlProtIpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2), )
if mibBuilder.loadTexts: mdlProtIpTable.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpTable.setDescription('This table contains Protected IP Addresses for ML-IP cards when working in IP Ring Mode.')
mdlProtIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "mdlProtIpCnfgIdx"), (0, "RAD-MIB", "mdlProtIpSlotIdx"), (0, "RAD-MIB", "mdlProtIpAddress"))
if mibBuilder.loadTexts: mdlProtIpEntry.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpEntry.setDescription('An entry in table.')
mdlProtIpCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlProtIpCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg being accessed. Idx 255 relates to the TmpCnfg. For Agents having several configuration, Write operation is allowed only to the Temporary Configuration.')
mdlProtIpSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlProtIpSlotIdx.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpSlotIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the 2104 Unit the entries io6(10)..io16) are not valid.')
mdlProtIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlProtIpAddress.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpAddress.setDescription('A Protected IP address.')
mdlProtIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mdlProtIpRowStatus.setStatus('current')
if mibBuilder.loadTexts: mdlProtIpRowStatus.setDescription('This parameter allows creating/deleting entries of this table.')
statMdlMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2))
mdlStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mdlStatTable.setStatus('current')
if mibBuilder.loadTexts: mdlStatTable.setDescription('A table.')
mdlStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlStatSltIdx"))
if mibBuilder.loadTexts: mdlStatEntry.setStatus('current')
if mibBuilder.loadTexts: mdlStatEntry.setDescription('An entry in table.')
mdlStatSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlStatSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlStatSltIdx.setDescription('A unique number to identify a slot position in the mux. In the 2104 Unit the entries psB(2),clB(4),io6(10)..io12(16) are not valid.')
mdlStatHostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlStatHostIP.setStatus('current')
if mibBuilder.loadTexts: mdlStatHostIP.setDescription('The host interface IP address when DHCP Client=Yes. This object is relevant only when DHCP Client=Yes ')
mdlStatHostMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlStatHostMask.setStatus('current')
if mibBuilder.loadTexts: mdlStatHostMask.setDescription('The host interface subnet mask when DHCP Client=Yes. This object is relevant only when DHCP Client=Yes ')
mdlStatDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 2, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlStatDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: mdlStatDefaultGateway.setDescription("Default Gateway's IP Address when DHCP Client=Yes. This object is relevant only when DHCP Client=Yes ")
prtExClCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1), )
if mibBuilder.loadTexts: prtExClCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExClCnfgTable.setDescription('A table.')
prtExClCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExClCnfgIdx"), (0, "RAD-MIB", "prtExClSltIdx"), (0, "RAD-MIB", "prtExClPrtIdx"))
if mibBuilder.loadTexts: prtExClCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExClCnfgEntry.setDescription('All the entries at this table are identical (have the same value) for all the configurations (1..100) except the TmpCnfg. The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExClCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExClCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg.')
prtExClSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExClSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. Because the second Cl is only for redundancy, all the parameters are identical in the two modules, i.e. change of any parameter in one module will change automatically the value of the other module.. In the ?004 Unit the entry clB(4) is not valid.')
prtExClPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExClPrtIdx.setDescription('This attribute indicates a unique port number. ')
prtExClUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("nmsSlip", 3), ("nmsPpp", 4), ("muxSlip", 5), ("muxPpp", 6), ("terminal", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClUsage.setStatus('current')
if mibBuilder.loadTexts: prtExClUsage.setDescription('This attribute indicates what is the usage of the port.')
prtExClRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("r300Bps", 1), ("r1200Bps", 2), ("r2400Bps", 3), ("r4800Bps", 4), ("r9600Bps", 5), ("r19200Bps", 6), ("r38400Bps", 7), ("r57600Bps", 8), ("r115200Bps", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClRate.setStatus('current')
if mibBuilder.loadTexts: prtExClRate.setDescription('This attribute indicates the operation rate of the port.')
prtExClDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7Bits", 1), ("dataBits8Bits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClDataBits.setStatus('current')
if mibBuilder.loadTexts: prtExClDataBits.setDescription('This attribute indicates the number of data bits in async frame')
prtExClParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd", 1), ("even", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClParity.setStatus('current')
if mibBuilder.loadTexts: prtExClParity.setDescription('This attribute indicates if the parity operation mode in async frame')
prtExClStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopBits1Bit", 1), ("stopBits1dot5Bits", 2), ("stopBits2Bits", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClStopBits.setStatus('current')
if mibBuilder.loadTexts: prtExClStopBits.setDescription('This attribute indicates the minimum number of stop bits in the tx async frame')
prtExClRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("rip2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClRoutingProtocol.setStatus('current')
if mibBuilder.loadTexts: prtExClRoutingProtocol.setDescription("This attribute indicates the routing protocol of the port. When prtExClUsage is nmsSlip or nmsPpp - all values are applicable . Else - only 'none' is applicable.")
prtExClEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClEnabled.setStatus('current')
if mibBuilder.loadTexts: prtExClEnabled.setDescription("This attribute indicates if Ethernet port of CL is enabled or not for management. It is applicable only on the ETH port of the CL, when the MP includes an ML-IP card. disabled - will happen when there is Inband Management via the ML-IP link/s enabled - will happen when ML-IP link/s is not used for Inband Management, but CL's ETH port .")
prtExPh1MlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1), )
if mibBuilder.loadTexts: prtExPh1MlCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlCnfgTable.setDescription('- For products supporting more than one configuration, the write operation into the Table is valid only to the TmpCnfg entry. - For products that do not support configurations, the write operation into the Table will be to prtExPh1MlCnfgIdx=1.')
prtExPh1MlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExPh1MlCnfgIdx"), (0, "RAD-MIB", "prtExPh1MlSltIdx"), (0, "RAD-MIB", "prtExPh1MlPrtIdx"))
if mibBuilder.loadTexts: prtExPh1MlCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlCnfgEntry.setDescription('An entry in table.')
prtExPh1MlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPh1MlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid. For the Vmux2100 Main Board notApplicable (1) is used.')
prtExPh1MlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("exPrt13", 13), ("exPrt14", 14), ("exPrt15", 15), ("exPrt16", 16), ("exPrt17", 17), ("exPrt18", 18), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112), ("inPrt13", 113), ("inPrt14", 114), ("inPrt15", 115), ("inPrt16", 116), ("inPrt17", 117), ("inPrt18", 118), ("inPrt19", 119), ("inPrt20", 120), ("inPrt21", 121), ("inPrt22", 122), ("inPrt23", 123), ("inPrt24", 124), ("inPrt25", 125), ("inPrt26", 126), ("inPrt27", 127), ("inPrt28", 128), ("inPrt29", 129), ("inPrt30", 130), ("inPrt31", 131), ("inPrt32", 132), ("inPrt33", 133), ("inPrt34", 134), ("inPrt35", 135), ("inPrt36", 136), ("inPrt37", 137), ("inPrt38", 138), ("inPrt39", 139), ("inPrt40", 140), ("inPrt41", 141), ("inPrt42", 142), ("inPrt43", 143), ("inPrt44", 144), ("inPrt45", 145), ("inPrt46", 146), ("inPrt47", 147), ("inPrt48", 148), ("inPrt49", 149), ("inPrt50", 150), ("inPrt51", 151), ("inPrt52", 152), ("inPrt53", 153), ("inPrt54", 154), ("inPrt55", 155), ("inPrt56", 156), ("inPrt57", 157), ("inPrt58", 158), ("inPrt59", 159), ("inPrt60", 160), ("inPrt61", 161), ("inPrt62", 162), ("inPrt63", 163), ("inPrt64", 164), ("inPrt65", 165), ("inPrt66", 166), ("inPrt67", 167), ("inPrt68", 168), ("inPrt69", 169), ("inPrt70", 170), ("inPrt71", 171), ("inPrt72", 172), ("inPrt73", 173), ("inPrt74", 174), ("inPrt75", 175), ("inPrt76", 176), ("inPrt77", 177), ("inPrt78", 178), ("inPrt79", 179), ("inPrt80", 180), ("inPrt81", 181), ("inPrt82", 182), ("inPrt83", 183), ("inPrt84", 184)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlPrtIdx.setDescription("This attribute indicates a unique port number. MP-2100/2200: MTML-1/E1 and MTML-1/T1 cards have only one external interface. inPrt1, inPrt2 - for MTML-H/2E1 and HSH cards. inPrt1..inPrt4 - for MTML-E2 and MSL-4 cards. exPrt2..exPrt4 - for MTML-4 cards and others exPrt1..exPrt8 - for ML-8 cards. inPrt1..inPrt8 - for MSL-8 and VF-30 card family. MP-104/204: only exPrt3 (3) is applicable. MP-4100: intPrt1...intPrt84 - for CLX cards. For other products' index see their specification.")
prtExPh1MlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlConnect.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the card considerations because it may indicate that the module has only one physical interface.')
prtExPh1MlLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 101))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7), ("g732unframed", 8), ("e1Unframed", 9), ("framed", 101)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlLineType.setDescription("This attribute is the line type parameter for T1/E1 interface. The user should select only the values which are relevant to the specific port: (2),(3), (8) - for T1 port (4)..(7), (9) - for E1 port. (101) framed - This value does not exist in standard MIB and is used for a non-standard E1 port that doesn't has real framer. Note: for old devices, g732unframed(8) was used as E1 Unframed. That was because at the time this value did not exist in the standard MIB (RFC-1406), so we added it in private MIB. Now that it was added to standard MIB, private MIB was updated as well. This parameter has the same values as dsx1LineType in DS1 MIB (RFC-3895). The parameters in dsx1LineType are: other (1) esfT1 dsx1ESF (2) sfT1 dsx1D4 (3) g732nE1 dsx1E1 (4) g732nE1CRC dsx1E1-CRC (5) g732sE1 dsx1E1-MF (6) g732sE1CRC dsx1E1-MF-CRC (7) g732unframed dsx1Unframed (8) --from RFC-3895 e1Unframed dsx1E1Unframed (9) --from RFC-3895 ")
prtExPh1MlLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("b7T1", 1), ("b8zsT1", 2), ("transT1", 3), ("hdb3E1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineCode.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlLineCode.setDescription('This attribute is the line code parameter used for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 line code parameters for MPH.1/T1 E1 line code parameters for MPH.1/E1. This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExPh1MlLineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("lenFcc68", 7), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineLen.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlLineLen.setDescription('This attribute is the line length parameter used only for T1/DSU interfaces. lenXXXpXXXft = len-XXX-XXXft.')
prtExPh1MlRestoreTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRestoreTime.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRestoreTime.setDescription('The time passing from the disappearance of the loss of synchronization condition (red alarm) to the restoration of normal service. The options 1secFast(2) and 10sec62411(3) for E1 interfaces are proprietary implementation of the T1 standard to the E1 interface.')
prtExPh1MlTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("txGain0db", 2), ("txGain7dot5db", 3), ("txGain15db", 4), ("txGain22dot5db", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTxGain.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTxGain.setDescription('This attribute is the tx gain parameter used only for T1/CSU interfaces.')
prtExPh1MlRxSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("low26dBm", 2), ("high36dBm", 3), ("shortHaul", 4), ("longHaul", 5), ("low15dbm", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRxSensitivity.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRxSensitivity.setDescription('This attribute is the rx line sensitivity parameter. low26dBm, high36dBm - applicable for T1-CSU shortHaul, longHaul - applicable for MTML-4 cards low15dbm was added for vmux110/210 T1 ports.')
prtExPh1MlIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlIdleCode.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlIdleCode.setDescription('Determines the code for transmission in empty time slots. Type value(00-FFH), Excluding 0H,8H,10H,12H,21H,24H,42H,49H, 84H,92H')
prtExPh1MlTdmTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("linkA", 1), ("linkB", 2), ("none", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTdmTrunk.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTdmTrunk.setDescription('This attribute indicates whether the port is used to transfer TDM cards data and through which Bus.')
prtExPh1MlClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("internalLocal", 1), ("loopBackLocal", 2), ("nodalTiming", 3), ("loopBackFromLink", 4), ("loopBackFromChannel", 5), ("loopbackFromSystem", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlClkMode.setDescription('Defines the clock operation mode of the T1/E1 interface. Ports that are connected to the TDM Buses must be in nodalTiming(3) clock mode. ')
prtExPh1MlMfClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcSlt.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcSlt.setDescription("This attribute indicates whether the port Tx multiframe is synchronized with Rx multiframe of another port and the slot position of that port. This operation is required in order to bypass signaling of PCM voice channels. Its value is always local(2) when the port isn't connected to any TDM bus. When it's value is local(2) there is no meaning to 'prtExPh1MlMfClkSrcPrt' parameter. In the ?004 Unit the entries io6(10)..io16) are not valid")
prtExPh1MlMfClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 101, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("inPrt1", 101), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcPrt.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcPrt.setDescription('A unique number to identify a port position in the mux. It has no effect when the prtExPh1MlMfClkSrcSlt selected is Local. inPrt1 - for MTML-H/E1 cards.')
prtExPh1MlFdlType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("response", 2), ("command", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlFdlType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlFdlType.setDescription("A unique number to identify the side of the FDL operation. Normal: 'response' for the user side and 'command' for the PTT side. Applicable only when working with ESF-T1 link")
prtExPh1MlInbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("off", 2), ("fdlOrTs0", 3), ("dedicatedTs", 4), ("dedicatedPpp", 5), ("dedicatedFr", 6), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMng.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlInbandMng.setDescription('A unique number to identify an Inband management over the link.')
prtExPh1MlInbandMngRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("r4k", 2), ("r8k", 3), ("r12k", 4), ("r16k", 5), ("r32k", 6), ("r64k", 7), ("r20k", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMngRate.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlInbandMngRate.setDescription('A unique number to identify the rate of the Inband management (Kbps). E1 port - it is not applicable when prtExPh1MlInbandMng selected is off. T1 port - it is not applicable when prtExPh1MlInbandMng selected is off OR fdlOrTs0.')
prtExPh1MlRedundType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("dualCableAIS", 2), ("yCable", 3), ("dualCableParallelTx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRedundType.setDescription("This object determines the ML redundancy type: none - no ML redundacy dualCableAIS - each ML card is connected by a separate dualCableParallelTx cable to the other MUX (two cables connect two MUXes). There are two types of dual redundancy. yCable - Y cable is connected to both ML cards (one cable connects two MUXes). Default=none When only one ML card exists, the type can be only 'none'. The value should be the same for both ML slots.")
prtExPh1MlRedundSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundSlot.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRedundSlot.setDescription("This object indicates the slot containing the redundacy ML card, coupled with the current ML (prtExPh1MlSltIdx). When prtExPh1MlRedundType=none (no ML redundancy) this object will be 'notApplicable'. In the ?004 Unit the entries io6(10)..io12(16) are not valid When value is not 'none', it should be mutual to the redundant ML slot.")
prtExPh1MlRedundPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101, 102, 103, 104, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundPort.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRedundPort.setDescription("This object indicates the redundacy ML port, coupled with the current ML port (prtExPh1MlPrtIdx). When prtExPh1MlRedundType=none (no ML redundancy) this object will be 'notApplicable'. When value is not 'none', it should be mutual to the redundant ML port. inPrt1 - for MTML-H/E1 cards. inPrt1..inPrt4 - for MTML-E2 cards. exPrt2..exPrt4 - for MTML-4 cards.")
prtExPh1MlRedundRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundRecTime.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlRedundRecTime.setDescription('Redundancy Recovery Time (sec). After switching the ML card to the current (prtExPh1MlSltIdx), the next ML switch can be performed only after a minimum time, indicated by this object.')
prtExPh1MlInbandMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("rip2", 2), ("proprietary", 3), ("proprietaryNoNmsTx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMngRoutProt.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlInbandMngRoutProt.setDescription('This attribute indicates the Inband Mng routing protocol of the port.')
prtExPh1MlIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("csu", 2), ("dsu", 3), ("ltu", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlIfType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlIfType.setDescription('Interface type of the port. For T1 - csu, dsu are the valid values For E1 - dsu, ltu are the valid values.')
prtExPh1MlMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("br56", 2), ("br64", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlMultiplier.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlMultiplier.setDescription('The data rate of each TS. The multiplier values can be 56 kbps or 64 kbps.')
prtExPh1MlSupportedTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlSupportedTS.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlSupportedTS.setDescription('Number of Supported Time Slots by the agent. For Vmux-110 there is HW that supports less than 31/24 Time Slots for the E1/T1 port.')
prtExPh1MlImpedance = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unbalanced", 2), ("balanced", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlImpedance.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlImpedance.setDescription('The Line Impedance. For T1 (always balanced), impedance is 100 ohm. For E1: - balanced = 120 ohm - unbalanced = 75 ohm.')
prtExPh1MlQ50BwControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("annexA", 3), ("annexB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlQ50BwControl.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlQ50BwControl.setDescription('This object enables configuration of Q.50 Bandwidth Control on the port. If the bandwidth exceeds a certain threshold it is possible to disable new calls in the PBX via Q.50 protocol. Q.50 supports only E1 ports with Line Types: E1-MF (G.732S), E1-CRC-MF(G.732SCRC ) It does not support T1 ports. Annex A - the basic type of Q.50 which focuses only on the bandwidth control. Can use one of the following pairs of signaling bits: A&B or C&D. Annex B - Expansion of Annex A which includes also call release messages and Maintenance Messages. Uses A&B bits only.')
prtExPh1MlQ50SignalPair = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("aAndB", 2), ("cAndD", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlQ50SignalPair.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlQ50SignalPair.setDescription('Q.50 Signaling bits Pair that is currently in use: A&B bits or C&D bits. For Annex B it will always be: aAndB (2).')
prtExPh1MlInternalSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInternalSwitch.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlInternalSwitch.setDescription('This parameter shows whether the data will be transferred from one port to the other port within the same group of 2 ports. The default value is: Enable. Disable value might be necessary for security implementations or for ring applications. For Vmux-2100 device this parameter is used on the Channelized Cards. Both ports in each group should have the same value for this parameter.')
prtExPh1MlSigService = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("advanced", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlSigService.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlSigService.setDescription('Signaling Service given by this link. notApplicable - for T1 links normal - usual Signaling advanced - V5 Signaling. ')
prtExPh1MlFragmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlFragmentSize.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlFragmentSize.setDescription('This parameter indicates the maximum number of bytes permitted in a packet send over the Link. Exceeding this size will cause packet fragmentation.')
prtExPh1MlTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2), )
if mibBuilder.loadTexts: prtExPh1MlTsTable.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry, except prtExPh1MlTsTest that will be written directly to the Active Configuration.')
prtExPh1MlTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtExPh1MlTsCnfgIdx"), (0, "RAD-MIB", "prtExPh1MlTsSltIdx"), (0, "RAD-MIB", "prtExPh1MlTsPrtIdx"), (0, "RAD-MIB", "prtExPh1MlTsIdx"))
if mibBuilder.loadTexts: prtExPh1MlTsEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsEntry.setDescription('An entry in table.')
prtExPh1MlTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPh1MlTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid. For the Vmux2100 Main Board notApplicable (255) is used.')
prtExPh1MlTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("exPrt13", 13), ("exPrt14", 14), ("exPrt15", 15), ("exPrt16", 16), ("exPrt17", 17), ("exPrt18", 18), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112), ("inPrt13", 113), ("inPrt14", 114), ("inPrt15", 115), ("inPrt16", 116), ("inPrt17", 117), ("inPrt18", 118), ("inPrt19", 119), ("inPrt20", 120)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsPrtIdx.setDescription('This attribute indicates a unique port number. MPH.1/E1 and MPH.1/T1 cards have only one external interface. exPrt2 - for ME1-2, MT1-2 and mhsPri cards. exPrt3, exPrt4 - for mhsPri cards. inPrt1 - for MTML-H/E1 cards.')
prtExPh1MlTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtExPh1MlTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("unknown", 1), ("noConnect", 2), ("split", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConSlot.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io16) are not valid. split - will be used when the Src TS is connected to more than one slot OR more than one port (each needing less than a whole TS).')
prtExPh1MlTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsIConPrt.setDescription('This attribute indicates the internally (In Mux) connected/routed port. For MP, the values will be: { exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , exPrt5 (5) , exPrt6 (6) , exPrt7 (7) , exPrt8 (8) , exPrt9 (9) , exPrt10 (10) , exPrt11 (11) , exPrt12 (12) , noConnect (100), inPrt1 (101) , inPrt2 (102) , inPrt3 (103) , inPrt4 (104) , inPrt5 (105) , inPrt6 (106) , inPrt7 (107) , inPrt8 (108) , inPrt9 (109) , inPrt10 (110) , inPrt11 (111) , inPrt12 (112) } For other products see specific values at spec.')
prtExPh1MlTsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConTs.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsIConTs.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated to multiframe synchronization and voice signaling.')
prtExPh1MlTsExt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsExt.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsExt.setDescription("A pointer to an extension of this table: prtExTsSplitTable. - If prtExPh1MlTsIConSlot='split', its value should be set to the OBJECT IDENTIFIER of the prtExTsSplitTable, with its relevant CnfgIdx, SltIdx, PrtIdx, TsIdx and 1st TsBit. - If prtExPh1MlTsIConSlot is not 'split', its value should be set to the OBJECT IDENTIFIER { 0 0 }. ")
prtExPh1MlTsTest = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 9, 18, 30, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("localLoop", 2), ("remoteLoop", 3), ("remoteBert", 8), ("localToneInjection", 9), ("remoteToneInjection", 18), ("localBert", 30), ("split", 254), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsTest.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsTest.setDescription('This attribute indicates a test to be activated on the selected TS. It is applicable only when prtSTstCmd=testPerTS(31). notApplicable - when prtSTstCmd is NOT testPerTS(31). none - no test is applied for the selected TS. split - when the tests are per Bit of the selected TS.')
prtExPh1MlTsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("data", 3), ("voice", 4), ("cas", 5), ("ss7", 6), ("transparent", 7), ("data2", 8), ("data3", 9), ("data4", 10), ("ss7n2", 11), ("hdlcV2Compatible", 12), ("subCh1", 13), ("subCh2", 14), ("subCh3", 15), ("subCh4", 16), ("subCh5", 17), ("subCh6", 18), ("subCh7", 19), ("subCh8", 20), ("trau", 21), ("qmux", 22), ("dynamic", 23), ("signaling", 24), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsType.setDescription('The Time Slot Type. Transparent - means that the Time Slot will be Rx/Tx as is without processing it. If the device requires more than 1 unique data or ss7 Time Slot, options with numbers can be used like: data...data4. Each numbered Type can go to a different destination. ss7n2 - means the 2nd group of ss7 Time Slots. data2,data3, data4 mean group 2,3,4 of Data Time Slots. subCh1...subCh8 mean Sub Channel 1...8, respectively. trau, qmux, dynamic, signaling - are used by GSM devices.')
prtExPh1MlTsBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsBundle.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsBundle.setDescription('The number of the bundle containing this Time Slot. If no bundle exists for this TS or the bundle number is irrelevant, the value will be 0.')
prtExPh1MlTsTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsTestDuration.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsTestDuration.setDescription("This attribute indicates the maximum duration of executing a test on the specific TS. This entry applies to all the test operations. For the Vmux2100 the values are: 0 - 60 seconds. A zero value specifies no time limitation. When the test isn't active, the agent initiates this object to 2 when the duration is needed and to 0 if its not required. The user should set this parameter after setting the 'prtExPh1MlTsTest' parameter.")
prtExPh1MlTsSubChType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("hdlc", 1), ("transparent", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsSubChType.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsSubChType.setDescription('The Time Slot Sub-Channel Type. This variable is relevant only when Time-Slot Type is SubCh (e.g. prtExPh1MlTsType = subCh1...subCh8).')
prtExPh1MlTsSubChMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsSubChMask.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsSubChMask.setDescription('The Sub-Channel Type Mask. This variable is relevant only when Time-Slot Type is SubCh (e.g. prtExPh1MlTsType = subCh1...subCh8).')
prtExPh1MlTsChRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("r16Kbps", 2), ("r32Kbps", 3), ("r64Kbps", 4), ("r8Kbps", 5), ("auto", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsChRate.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsChRate.setDescription('The Rate of the Signaling Channel. notApplicable(1) when TS Type is other than Signaling or Transparent')
prtExPh1MlTsByteReversal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsByteReversal.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsByteReversal.setDescription('Byte Reversal. This variable defines whether the LSB or MSB is transmitted first. no(2) - MSB is transmitted first yes(3) - LSB is transmitted first.')
prtExPh1MlTsSigProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("p1", 3), ("p2", 4), ("p3", 5), ("p4", 6), ("p5", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsSigProfile.setStatus('current')
if mibBuilder.loadTexts: prtExPh1MlTsSigProfile.setDescription('This object indicates the Signaling Profile of the port. It is applicable only when prtMl4SigProfile=perTS. p1 = profile 1 p2 = profile 2 p3 = profile 3 p4 = profile 4 p5 = profile 5 ')
prtInPh1MlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3), )
if mibBuilder.loadTexts: prtInPh1MlCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInPh1MlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtInPh1MlCnfgIdx"), (0, "RAD-MIB", "prtInPh1MlSltType"), (0, "RAD-MIB", "prtInPh1MlPrtIdx"))
if mibBuilder.loadTexts: prtInPh1MlCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCnfgEntry.setDescription('An entry in table.')
prtInPh1MlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtInPh1MlSltType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlSltType.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlSltType.setDescription('This attribute indicates a unique slot position where the card is inserted. For ISDN BRI port of MX300/30: io1(5) = isdn1(5) and io2(6) = isdn2(6) In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtInPh1MlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlPrtIdx.setDescription('This attribute indicates a unique port number. MPH.1/E1 and MPH.1/T1 cards have three internal interfaces. MX3000 modules may have up to 50 internal ports.')
prtInPh1MlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlConnect.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInPh1MlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 100))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("r32x56eq1792Kbps", 63), ("r32x64eq2048Kbps", 64), ("r1x1dot5eq1dot5M", 65), ("r2x1dot5eq3M", 66), ("r3x1dot5eq4dot5M", 67), ("r4x1dot5eq6M", 68), ("r5x1dot5eq7dot5M", 69), ("r6x1dot5eq9M", 70), ("r7x1dot5eq10dot5M", 71), ("r8x1dot5eq12M", 72), ("r1x2Meq2M", 73), ("r2x2Meq4M", 74), ("r3x2Meq6M", 75), ("r4x2Meq8M", 76), ("r5x2Meq10M", 77), ("r6x2Meq12M", 78), ("r7x2Meq14M", 79), ("r8x2Meq16M", 80), ("noRate", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlRate.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlRate.setDescription('This attribute indicates the port speed. ')
prtInPh1MlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("fr", 1), ("frPlus", 2), ("pCellRelay", 3), ("hdlcSdlc", 4), ("transparentHdlc", 5), ("ciscoBridgedEth", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlProtocol.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlProtocol.setDescription('This attribute indicates the applied protocol.')
prtInPh1MlConnectionTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("sameNetManaged", 1), ("sameNetNotMana", 2), ("user", 3), ("otherNet", 4), ("pubNet", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlConnectionTyp.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlConnectionTyp.setDescription('This attribute indicates the link connection type. It is required for three reasons: FR/CR Inband management operation (LMI,CLMM...). CIR check. NMS network management. SameNetManaged - indicates network internal line. SameNetNotMana - indicates network internal line, but the remote mux is not managed by the nms. User - User to Network Interface. OtherNet - Network To Network Interfce. PubNet - Access Mux To PubNet Interface.')
prtInPh1MlCongResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("flowControl", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCongResponse.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCongResponse.setDescription('This attribute indicates how to handle the congestion indication to/from the mux internal connection side (for example transmit/receive becn to/from the network). no - do nothing FlowControl - translate the congestion indication between the port and the internal connection port according to the definition of the prtInPh1MlFlowControl parameters. The operation is done in both directions.')
prtInPh1MlCongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCongLevel.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCongLevel.setDescription('This attribute indicates the level of delayed data in precents of the total available dynamic memory, for which the port will start to operate . The resolution of the parameter is 5 percent. Valid values: 10..70, 255. 255=notApplicable.')
prtInPh1MlTc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("tc1sec", 1), ("tc2sec", 2), ("tc3sec", 3), ("tc4sec", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlTc.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlTc.setDescription('This attribute indicates the Tc parameter which is the time period of the sliding window in which the Bc/Be are tested. The value of this parameter is identical for all the ports in the specific card. 255=notApplicable.')
prtInPh1MlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("none", 2), ("fecnBecn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFlowControl.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlFlowControl.setDescription('This attribute indicates the required flow control betweeen the port and the remote equipment.')
prtInPh1MlSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("notApplicable", 1), ("s36Byte", 2), ("s150Byte", 3), ("s264Byte", 4), ("s378Byte", 5), ("s492Byte", 6), ("s236Byte", 7), ("s472Byte", 8), ("s708Byte", 9), ("s944Byte", 10), ("s1180Byte", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlSegment.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlSegment.setDescription('This object is the Segmentation in Bytes. In protocol FR+, ISDN internals, MX 30/300 the segmentation is: 50 (2) ,158 (3) ,266 (4) ,376 (5), 484 (6) In MX 3000/4: For protocol FR+ (internal ISDN ports of MHS.S, MHS.U, MHS.E1, MHS.T1 cards) segmentation values are: 236 (7),472 (8), 708 (9), 944 (10) ,1180 (11)')
prtInPh1MlFrMngProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("lmi", 3), ("ansiT1", 4), ("annexA", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrMngProt.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlFrMngProt.setDescription('This object indicates the Frame-Relay management protocol. ansiT1 = ANSI T1.617 Annex D (this is the default value). This parameter is applicable only for FR and FR+ protocols. When prtInPh1MlConnectionTyp = sameNetManaged, this object will be RO (internally determined). ')
prtInPh1MlEnqPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlEnqPeriod.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlEnqPeriod.setDescription('This object is the Status Enquiry Period, in seconds. It determines the frequency of the Status Enquiry message as sent by the FR user side. At the FR network side, it determines the timeout for this message reception. Default = 4 seconds. This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlFullRptPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFullRptPeriod.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlFullRptPeriod.setDescription('This object is the Full Report Frequency. It determines the number of the Status Enquiry messages sent by the FR user side, before a Full Report Request is sent. The units are : Status Enquiry messages (periods). Valid values: 1 .. 255. 255 = infinite (never sent). This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlFrWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrWindowSize.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlFrWindowSize.setDescription('This object is the FR Window Size. It determines the number of samplings in the sliding window that counts the errors. This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlErrorsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlErrorsThreshold.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlErrorsThreshold.setDescription('This object is the Max Errors. It determines the number of Status Enquiry Errors that occured within the FR sliding window, before this port is considered DOWN (threshold). This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable. ')
prtInPh1MlMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1800)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlMaxIdleTime.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlMaxIdleTime.setDescription('Move to higher prioritized connected link after this period of seconds of silence on the current link. 0=Never. Never move to higher prioritized connected link. UNIT is seconds. Valid values are: 0, 1, 2, 3, 4, 5, 10, 20, 30, 40, 50, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 900, 1200, 1500, 1800. Attempt to Set an invalid value will result in getting the default value.')
prtInPh1MlBearerCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 255))).clone(namedValues=NamedValues(("notApplicable", 1), ("channelB1", 3), ("channelB2", 4), ("chB1andchB2", 5), ("none", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlBearerCh.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlBearerCh.setDescription('Defines which B (bearer) channels are used for transferring ISDN data. Default value is: none (255). anyChannel (2) is skipped because it is not in use here.')
prtInPh1MlAssociatedExCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlAssociatedExCh.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlAssociatedExCh.setDescription('This object indicates the external port associated to this internal port. At present, it is used by the Hybrid (mp2100h), MHS-4 cards which can have up to 64 dynamic internal ports associated with External ports. For ISDN cards, the value will be: notApplicable (255). The associated external of an ISDN internal port is represented by the MIB object: prtIsdnDirectoryPrtNu.')
prtInPh1MlClockEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("nrz", 2), ("nrzI", 3), ("fm0", 4), ("manchester", 5), ("diffManchester", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlClockEncoding.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlClockEncoding.setDescription('This object is the Encoding type of the Line. This parameter is applicable only for FR and FR+ protocols.')
prtInPh1MlMinSeparators = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlMinSeparators.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlMinSeparators.setDescription('Minimum number of bytes separating between two adjacent frames (HDLC item). 0 = notApplicable')
prtInPh1MlCcittCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("crc16", 2), ("crc32", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCcittCrc.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlCcittCrc.setDescription('This object indicates how many Bits are used for CRC (HDLC item).')
prtInPh1MlFrameSeparator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("idles", 2), ("flags", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrameSeparator.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlFrameSeparator.setDescription('This object indicates what should be transferred on the line when there are no frames to pass (HDLC item). idles: mean that FF will pass on the line flags: mean that 7E will pass on the line.')
prtInPh1MlDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4), )
if mibBuilder.loadTexts: prtInPh1MlDlciTable.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInPh1MlDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1), ).setIndexNames((0, "RAD-MIB", "prtInPh1MlDlciCnfgIdx"), (0, "RAD-MIB", "prtInPh1MlDlciSltIdx"), (0, "RAD-MIB", "prtInPh1MlDlciPrtIdx"), (0, "RAD-MIB", "prtInPh1MlDlciIdx"))
if mibBuilder.loadTexts: prtInPh1MlDlciEntry.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciEntry.setDescription('An entry in table.')
prtInPh1MlDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtInPh1MlDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtInPh1MlDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 103))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciPrtIdx.setDescription('This attribute indicates a unique internal port number. MPH.1/E1 and MPH.1/T1 cards have three internal ports.')
prtInPh1MlDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciIdx.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciIdx.setDescription("This attribute indicates a unique index for each possible used dlci(16..991). When the protocol is not Multiplexing protocol, then its type is 'user' and the only valid index is 1.")
prtInPh1MlDlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciValid.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtInPh1MlDlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConSlt.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtInPh1MlDlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("clNMS", 99), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciIConPrt.setDescription('This attribute indicates a unique port id which the dlci is routed to.')
prtInPh1MlDlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConDlci.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number which the src dlci is routed to.')
prtInPh1MlDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14200bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciTxBc.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line or at the port receive line.')
prtInPh1MlDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14200bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciTxBe.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line or at the port receive line.')
prtInPh1MlDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14200bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciRxBc.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line or at the port transmit line.')
prtInPh1MlDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14200bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciRxBe.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line or at the port transmit line.')
prtInPh1MlDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciPriority.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 8 is the highest priority.')
prtInPh1MlDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciStatus.setStatus('current')
if mibBuilder.loadTexts: prtInPh1MlDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtPhMlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5), )
if mibBuilder.loadTexts: prtPhMlCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtPhMlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtPhMlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1), ).setIndexNames((0, "RAD-MIB", "prtPhMlCnfgIdx"), (0, "RAD-MIB", "prtPhMlSltIdx"), (0, "RAD-MIB", "prtPhMlPrtIdx"))
if mibBuilder.loadTexts: prtPhMlCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtPhMlCnfgEntry.setDescription('An entry in table.')
prtPhMlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtPhMlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtPhMlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtPhMlSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For the Vmux2100 Main Board notApplicable (1) is used.')
prtPhMlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtPhMlPrtIdx.setDescription('This attribute indicates a unique port number. ML-20 cards have just one external interface.')
prtPhMlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlConnect.setStatus('current')
if mibBuilder.loadTexts: prtPhMlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtPhMlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 70))).clone(namedValues=NamedValues(("r1x64eq64Kbps", 2), ("r2x64eq128Kbps", 4), ("r3x64eq192Kbps", 6), ("r4x64eq256Kbps", 8), ("r5x64eq320Kbps", 10), ("r6x64eq384Kbps", 12), ("r7x64eq448Kbps", 14), ("r8x64eq512Kbps", 16), ("r9x64eq576Kbps", 18), ("r10x64eq640Kbps", 20), ("r11x64eq704Kbps", 22), ("r12x64eq768Kbps", 24), ("r13x64eq832Kbps", 26), ("r14x64eq896Kbps", 28), ("r15x64eq960Kbps", 30), ("r16x64eq1024Kbps", 32), ("r17x64eq1088Kbps", 34), ("r18x64eq1152Kbps", 36), ("r19x64eq1216Kbps", 38), ("r20x64eq1280Kbps", 40), ("r21x64eq1344Kbps", 42), ("r22x64eq1408Kbps", 44), ("r23x64eq1472Kbps", 46), ("r24x64eq1536Kbps", 48), ("r25x64eq1600Kbps", 50), ("r26x64eq1664Kbps", 52), ("r27x64eq1728Kbps", 54), ("r28x64eq1792Kbps", 56), ("r29x64eq1856Kbps", 58), ("r30x64eq1920Kbps", 60), ("r31x64eq1984Kbps", 62), ("r32x64eq2048Kbps", 64), ("auto", 70)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlRate.setStatus('current')
if mibBuilder.loadTexts: prtPhMlRate.setDescription('This attribute indicates the configured port speed. auto - rate is adapted automatically to the attached modem rate.')
prtPhMlCAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlCAS.setStatus('current')
if mibBuilder.loadTexts: prtPhMlCAS.setDescription('This attribute indicates whether Channel Associated Signaling (CAS) is used.')
prtPhMlClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("dce", 2), ("ext-dce", 3), ("dte", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlClockMode.setStatus('current')
if mibBuilder.loadTexts: prtPhMlClockMode.setDescription('Clock mode.')
prtPhMlSatBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlSatBuffer.setStatus('current')
if mibBuilder.loadTexts: prtPhMlSatBuffer.setDescription('Satellite Buffer (+/- 256).')
prtPhMlDialProcess = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("callIn", 3), ("callOut", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlDialProcess.setStatus('current')
if mibBuilder.loadTexts: prtPhMlDialProcess.setDescription('Dial Process.')
prtPhMlSyncRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlSyncRestore.setStatus('current')
if mibBuilder.loadTexts: prtPhMlSyncRestore.setDescription('Sync Restoration time, in seconds. notApplicable=0. ')
prtPhMlBus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("busA", 2), ("busB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlBus.setStatus('current')
if mibBuilder.loadTexts: prtPhMlBus.setDescription('The TDM BUS this port is linked to.')
prtPhMlMfSyncSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("none", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlMfSyncSlot.setStatus('current')
if mibBuilder.loadTexts: prtPhMlMfSyncSlot.setDescription('This attribute indicates whether the sync is synchronized according to a certain card and the slot of this card. This operation is required in order to bypass signaling of PCM voice channels. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtPhMlClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("txClock", 2), ("rxClock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlClockSource.setStatus('current')
if mibBuilder.loadTexts: prtPhMlClockSource.setDescription('The Clock Source: TC (Tx Clock) or RC (Rx Clock) signals.')
prtPhMlErrCorrection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlErrCorrection.setStatus('current')
if mibBuilder.loadTexts: prtPhMlErrCorrection.setDescription('This object indicates if Error Correction mechanism should be applied or not. It will be applicable only if the interface HW includes the Error Correction chip.')
prtPhMlCorrectionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("random", 2), ("bursty", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlCorrectionMode.setStatus('current')
if mibBuilder.loadTexts: prtPhMlCorrectionMode.setDescription('This object is applicable only when prtPhMlErrCorrection=yes. random - enables to correct up to 3 random errors in an 23 bit frame built from 12 data bits and 11 appended parity bits. bursty - interleaving 3 frames, allows correcting bursts of 9 bit length.')
prtPhMlControlSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("ignore", 2), ("implement", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlControlSignals.setStatus('current')
if mibBuilder.loadTexts: prtPhMlControlSignals.setDescription('This object shows whether the Port will ignore or implement the control signals like DCD, CTS, DTR.')
prtPhMlInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("v35", 2), ("x21", 3), ("rs232", 4), ("rs449", 5), ("ei530", 6), ("ei530a", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlInterfaceType.setStatus('current')
if mibBuilder.loadTexts: prtPhMlInterfaceType.setDescription('The SW Configurable Interface Type.')
prtPhMlClockPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("inverted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlClockPolarity.setStatus('current')
if mibBuilder.loadTexts: prtPhMlClockPolarity.setDescription('This object indicates the clock polarity.')
prtLogicalCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1), )
if mibBuilder.loadTexts: prtLogicalCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtLogicalCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtLogicalCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtLogicalCnfgIdx"), (0, "RAD-MIB", "prtLogicalSltIdx"), (0, "RAD-MIB", "prtLogicalPrtIdx"))
if mibBuilder.loadTexts: prtLogicalCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtLogicalCnfgEntry.setDescription('An entry in table.')
prtLogicalCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtLogicalCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtLogicalSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtLogicalSltIdx.setDescription('Slot Index. For ISDN BRI Ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
prtLogicalPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtLogicalPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be an internal port number: inPrt1(101)->inPrt50(150), linkSel1(200)->linkSel50(250), encaps1(300)-> encaps50(350), huntGr1(101) -> huntGr10(110).')
prtLogicalConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtLogicalConnect.setStatus('current')
if mibBuilder.loadTexts: prtLogicalConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtLogicalFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("linkSelector", 2), ("encapsulator", 3), ("huntGroup", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtLogicalFunction.setStatus('current')
if mibBuilder.loadTexts: prtLogicalFunction.setDescription('This parameter defines the function of the relevant channel.')
prtLogicalRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtLogicalRowStatus.setStatus('current')
if mibBuilder.loadTexts: prtLogicalRowStatus.setDescription('This parameter allows the NMS to create/delete logical ports. The only possible supported RowStatus vaules are active (1) and destroy (6).')
linkSelectorCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2), )
if mibBuilder.loadTexts: linkSelectorCnfgTable.setStatus('current')
if mibBuilder.loadTexts: linkSelectorCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
linkSelectorCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1), ).setIndexNames((0, "RAD-MIB", "linkSelectorCnfgIdx"), (0, "RAD-MIB", "linkSelectorSltIdx"), (0, "RAD-MIB", "linkSelectorPrtIdx"))
if mibBuilder.loadTexts: linkSelectorCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: linkSelectorCnfgEntry.setDescription('An entry in table.')
linkSelectorCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: linkSelectorCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
linkSelectorSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorSltIdx.setStatus('current')
if mibBuilder.loadTexts: linkSelectorSltIdx.setDescription('Slot Index')
linkSelectorPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorPrtIdx.setStatus('current')
if mibBuilder.loadTexts: linkSelectorPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be internal port number: higher or equal to linkSeL1(201).')
linkSelectorMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMaxIdleTime.setStatus('current')
if mibBuilder.loadTexts: linkSelectorMaxIdleTime.setDescription('Move to higher prioritized connected link after this period of seconds of silence on the current link. 0=move immediately to higher prioritized connected link. UNIT is seconds.')
linkSelectorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("backup", 2), ("bod", 3))).clone('backup')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMode.setStatus('current')
if mibBuilder.loadTexts: linkSelectorMode.setDescription(' If the link selector is in mode: backup(2)=then the link with the lower priority will be used in case of failure of the higher priority link, bod(3)=bandwidth on demand or dynamic bandwidth allocation means that links with lower priority will be used whenever additional bandwidth is required. ')
linkSelectorRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("auto", 2), ("manual", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorRevert.setStatus('current')
if mibBuilder.loadTexts: linkSelectorRevert.setDescription(' If the link selector is in mode backup: auto(2)=return automatically to Main link when it is OK. manual(3)=stays connected to backup link.')
linkSelectorMinBUSession = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMinBUSession.setStatus('current')
if mibBuilder.loadTexts: linkSelectorMinBUSession.setDescription('Minimum duration of a backup session before returning to Main Link. Relevant in Backup Mode and when Revert is auto(2). Value 255 is for NEVER which means never return to Main Link. UNIT is minutes.')
linkSelectorPLinkTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3), )
if mibBuilder.loadTexts: linkSelectorPLinkTable.setStatus('current')
if mibBuilder.loadTexts: linkSelectorPLinkTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
linkSelectorPLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1), ).setIndexNames((0, "RAD-MIB", "pLinkCnfgIdx"), (0, "RAD-MIB", "pLinkSltIdx"), (0, "RAD-MIB", "pLinkPrtIdx"), (0, "RAD-MIB", "pLinkIdx"))
if mibBuilder.loadTexts: linkSelectorPLinkEntry.setStatus('current')
if mibBuilder.loadTexts: linkSelectorPLinkEntry.setDescription('An entry in table.')
pLinkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: pLinkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
pLinkSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkSltIdx.setStatus('current')
if mibBuilder.loadTexts: pLinkSltIdx.setDescription('Slot Index')
pLinkPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkPrtIdx.setStatus('current')
if mibBuilder.loadTexts: pLinkPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be the link selector number.')
pLinkIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkIdx.setStatus('current')
if mibBuilder.loadTexts: pLinkIdx.setDescription('This index is the row number.')
pLinkSlotNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255))).clone('noConnect')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkSlotNu.setStatus('current')
if mibBuilder.loadTexts: pLinkSlotNu.setDescription('The slot of the prioritized link. For ISDN BRI ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
pLinkPortNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 6), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkPortNu.setStatus('current')
if mibBuilder.loadTexts: pLinkPortNu.setDescription('The port of the prioritized link. Value 100 is for noConnect.')
pLinkPrioNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkPrioNu.setStatus('current')
if mibBuilder.loadTexts: pLinkPrioNu.setDescription('The priority of the prioritized link. MIN=1...., MAX=8.')
pLinkVRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 100))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("noRate", 100))).clone('noRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkVRate.setStatus('current')
if mibBuilder.loadTexts: pLinkVRate.setDescription('The rate to use with this link.')
prtExPhPlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1), )
if mibBuilder.loadTexts: prtExPhPlCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPhPlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExPhPlCnfgIdx"), (0, "RAD-MIB", "prtExPhPlSltIdx"), (0, "RAD-MIB", "prtExPhPlPrtIdx"))
if mibBuilder.loadTexts: prtExPhPlCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCnfgEntry.setDescription('An entry in table.')
prtExPhPlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExPhPlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlPrtIdx.setDescription('This attribute indicates a unique port number. In case of PH.1 card, only exPrt(1) is valid.')
prtExPhPlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlConnect.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExPhPlHRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 71, 72, 73))).clone(namedValues=NamedValues(("notApplicable", 1), ("r32KbpsNLE", 2), ("r48KbpsNLE", 3), ("r56KbpsNLE", 4), ("r64KbpsNLE", 5), ("r112KbpsNLE", 6), ("r128KbpsNLE", 7), ("r168KbpsNLE", 8), ("r192KbpsNLE", 9), ("r224KbpsNLE", 10), ("r256KbpsNLE", 11), ("r280KbpsE", 12), ("r320KbpsE", 13), ("r336KbpsNLE", 14), ("r384KbpsNLE", 15), ("r392KbpsE", 16), ("r448KbpsNLE", 17), ("r504KbpsLE", 18), ("r512KbpsE", 19), ("r560KbpsE", 20), ("r576KbpsLE", 21), ("r616KbpsE", 22), ("r640KbpsE", 23), ("r672KbpsNLE", 24), ("r704KbpsE", 25), ("r728KbpsE", 26), ("r768KbpsNLE", 27), ("r784KbpsE", 28), ("r832KbpsE", 29), ("r840KbpsE", 30), ("r896KbpsNLE", 31), ("r952KbpsE", 32), ("r960KbpsE", 33), ("r1008KbpsLE", 34), ("r1024KbpsE", 35), ("r1064KbpsE", 36), ("r1088KbpsE", 37), ("r1120KbpsE", 38), ("r1152KbpsLE", 39), ("r1176KbpsE", 40), ("r1216KbpsE", 41), ("r1232KbpsE", 42), ("r1280KbpsE", 43), ("r1288KbpsE", 44), ("r1344KbpsNLE", 45), ("r1400KbpsE", 46), ("r1408KbpsE", 47), ("r1456KbpsE", 48), ("r1472KbpsE", 49), ("r1512KbpsE", 50), ("r1536KbpsE", 51), ("r1568KbpsE", 52), ("r1600KbpsE", 53), ("r1624KbpsE", 54), ("r1664KbpsE", 55), ("r1680KbpsE", 56), ("r1728KbpsE", 57), ("r1736KbpsE", 58), ("r1792KbpsNLE", 59), ("r1856KbpsE", 60), ("r1920KbpsE", 61), ("r1984KbpsE", 62), ("r2048KbpsE", 63), ("r9d6KbpsNLE", 65), ("r14d4KbpsNLE", 66), ("r16KbpsNLE", 67), ("r19d2KbpsNLE", 68), ("r28d8KbpsNLE", 69), ("r38d4KbpsNLE", 70), ("r57d6KbpsNLE", 71), ("r115d2KbpsNLE", 72), ("r24000bps", 73)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlHRate.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlHRate.setDescription("This attribute indicates the port speed for HIGH speed cards. The card has limitations about the maximum sigma channel speeds and about the possible rates for each clock mode . N - The rate is valid for DCE and EXT-DCE Nodal clock mode. L - The rate is valid for DCE and EXT-DCE Local clock mode. E - The rate is valid for DTE External clock mode. 'r9d6KbpsNLE' means rate of 9.6 Kbps ('d'=dot). Note: Some rate attributes have been changed. As the MIB was already released with the old attributes, the names of the options were not changed. The new names + attributes are in a comment. Example: r2048KbpsE (63), -- r2048KbpsNLE")
prtExPhPlLRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("notApplicable", 1), ("r300bpsNLE", 2), ("r600bpsNLE", 3), ("r800bpsNLE", 4), ("r1200bpsNLE", 5), ("r2400bpsNLE", 6), ("r4800bpsNLE", 7), ("r9600bpsNLE", 8), ("r14400bpsLE", 9), ("r19200bpsNLE", 10), ("r28800bpsLE", 11), ("r32000bpsNLE", 12), ("r38400bpsNLE", 13), ("r48000bpsNLE", 14), ("r56000bpsNLE", 15), ("r57600bpsLE", 16), ("r64000bpsNLE", 17), ("r112000bps", 18), ("r115200bps", 19), ("r16000bpsNLE", 20), ("r100bpsNLE", 21), ("r128000bps", 22), ("r24000bps", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLRate.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlLRate.setDescription('This attribute indicates the port speed for LOW speed cards. The card has limitations about the possible rates for each clock mode. N - The rate is valid for DCE and EXT-DCE Nodal clock mode. L - The rate is valid for DCE and EXT-DCE Local clock mode. E - The rate is valid for DTE External clock mode. Note: Some rate attributes have been changed. As the MIB was already released with the old attributes, the names of the options were not changed. The new names + attributes are in a comment. Example: r57600bpsLE (16), -- r57600bpsNLE ')
prtExPhPlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("fr", 1), ("frPlus", 2), ("pCellRelay", 3), ("hdlcSdlc", 4), ("transparentHdlc", 5), ("async", 6), ("asyncReliable", 7), ("activePPP", 8), ("slip", 9), ("pppAgent", 10), ("slipAgent", 11), ("transparent", 12), ("sna", 13), ("ft1Dot2", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlProtocol.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlProtocol.setDescription('This object indicates the applied protocol.')
prtExPhPlConnectionTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("sameNetManaged", 1), ("sameNetNotMana", 2), ("user", 3), ("otherNet", 4), ("pubNet", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlConnectionTyp.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlConnectionTyp.setDescription('This attribute indicates the link connection type. It is required for three reasons: FR/CR Inband management opration (LMI,CLMM...). CIR check. NMS network management. SameNetManaged - indicates network internal line. SameNetMotMana - indicates network internal line, but the remote mux is not managed by the NMS. User - User to Network Interface. OtherNet - Network To Network Interface. PubNet - Access Mux To PubNet Interface.')
prtExPhPlClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("dte", 3), ("int", 4), ("lbt", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlClkMode.setDescription('Clock mode.')
prtExPhPlDceClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("nodalTiming", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDceClkSrc.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDceClkSrc.setDescription("This attribute indicates the source of the clock when working in dce or ext-dce clock mode. notApplicable(1) - is applied for dte(3) and lbt(5) clock modes. When clock mode is dte, the clock source is always external, therefore this object's value is notApplicable. local(2) and nodalTiming(3) - are valid in dce(1), extDce(2) or int(4) clock modes. The recommended clock source is local(2).")
prtExPhPlCongResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("no", 2), ("flowControl", 3), ("toFlowControl", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCongResponse.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCongResponse.setDescription('This attribute indicates how to handle the congestion indication to/from the mux internal connection side (for example transmit/received becn to/from the network). no - do nothing flowControl - translates the congestion indication between the port and the internal connection port according to the definition of the prtInPh1MlFlowControl parameters. The operation is done on both directions. toFlowControl- translates the backward congestion indication received from the internal connection port (normally the network side) to flow control and do nothing in the other direction.')
prtExPhPlCongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCongLevel.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCongLevel.setDescription('This attribute indicates the level of delayed data in precents of total available dynamic memory, for which the port will start to operate as congested. The resolution of the parameter is 5 percent.')
prtExPhPlTc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("tc1sec", 1), ("tc2sec", 2), ("tc3sec", 3), ("tc4sec", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlTc.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlTc.setDescription('This attribute indicates the Tc parameter which is the time period of the sliding window in which the Bc/Be are tested. The value of this parameter is identical for all the ports of a specific card .')
prtExPhPlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 2), ("fecnBecn", 3), ("xonXoff", 4), ("dtrCts", 5), ("speedReduction", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFlowControl.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlFlowControl.setDescription('This attribute indicates the required flow control betweeen the port and the remote equipment. fecnBecn - is valid only for FR, FR+ and CR protocols. xonXoff,dtrCts - are valid only for Async protocols. speedReduction - is valid only for DLC protocol when the Clock Mode is DCE and the Clock Source is Local.')
prtExPhPlDcdRts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDcdRts.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDcdRts.setDescription('Protocol may require end to end connect indication over the network. End to end link connection establishment over the FR network will be indicated to the user by using DCD or RTS control signals, depending on the clock mode: DCE or DTE respectively. The options are : - On : DCD(DCE)/RTS(DTE) will be constantly ON no matter if the End to End connection is established or not. - End to End: The DCD(DCE)/RTS(DTE) will be according to the status of the End to End connection.')
prtExPhPlDcdRtsControlPath = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDcdRtsControlPath.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDcdRtsControlPath.setDescription('Protocol may require end to end connect indication over the network. This parameter defines whether to take the user connection status (RTS(DCE)/DCD(DTE)) and forward it to the network side. - on : Transmit active connection to the network regardless the RTS/DCD control lines status. - off: Transmit active connection to the network according to the status of the RTS/DCD pin. ')
prtExPhPlDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("dataBits7Bits", 2), ("dataBits8Bits", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDataBits.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDataBits.setDescription('This attribute indicates the number of data bits in async frame. It is relevant only for Async protocols.')
prtExPhPlParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("odd", 2), ("even", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlParity.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlParity.setDescription('This attribute indicates the parity operation mode in async frame. It is relevant only for Async protocols.')
prtExPhPlStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("sb1Bit", 2), ("sb1dot5Bits", 3), ("sb2Bits", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlStopBits.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlStopBits.setDescription('This attribute indicates the minimum number of stop bits in the tx async frame. It is relevant only for Async protocols.')
prtExPhPlLXon = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLXon.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlLXon.setDescription("This attribute indicates the character used as X-On to notify receive enable. This parameter is valid only for async protocols. Valid values: 0..255. The value 256 indicates that it's not applicable ")
prtExPhPlLXoff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLXoff.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlLXoff.setDescription("This attribute indicates the character used as X-Off to notify receive disable. This parameter is valid only for async protocols. Valid values: 0..255. The value 256 indicates that it's not applicable ")
prtExPhPlFrMngProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("lmi", 3), ("ansiT1", 4), ("annexA", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrMngProt.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlFrMngProt.setDescription('This object indicates the Frame-Relay management protocol. ansiT1 = ANSI T1.617 Annex D (this is the default value). This parameter is applicable only for FR and FR+ protocols. When prtExPhPlConnectionTyp = sameNetManaged, this object will be RO (internally determined). ')
prtExPhPlEnqPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlEnqPeriod.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlEnqPeriod.setDescription('This object is the Status Enquiry Period, in seconds. It determines the frequency of the Status Enquiry message as sent by the FR user side. At the FR network side, it determines the timeout for this message reception. Default = 4 seconds. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlFullRptPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFullRptPeriod.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlFullRptPeriod.setDescription('This object is the Full Report Frequency. It determines the number of the Status Enquiry messages sent by the FR user side, before a Full Report Request is sent. The units are : Status Enquiry messages (periods). Valid values: 1 .. 255. 255 = infinite. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlFrWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrWindowSize.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlFrWindowSize.setDescription('This object is the FR Window Size. It determines the number of samplings in the sliding window that counts the errors. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlErrorsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlErrorsThreshold.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlErrorsThreshold.setDescription('This object is the Max Errors. It determines the number of Status Enquiry Errors that occured within the FR sliding window, before this port is considered DOWN (threshold). This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlPvcCreateMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlPvcCreateMsg.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlPvcCreateMsg.setDescription('This object is Update Message (if required or not). It determines whether a message of a New PVC Creation is requested or not (yes/no). Default = no. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlCllmMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCllmMsg.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCllmMsg.setDescription('This object is CLLM Message (if required or not). It determines whether to send (or not) a congestion message when the port is Rx congested. Default = no. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlProtDelayLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("s36Byte", 2), ("s150Byte", 3), ("s264Byte", 4), ("s378Byte", 5), ("s492Byte", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlProtDelayLevel.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlProtDelayLevel.setDescription('This object is the Segmentation in Bytes. In some cases, the enumerated values will mean other segmentation values than specified: Product: MX-3000 MX-3000 MX-300/MX-30 Protocol: FR+ Transparent FR+ ----------------------------------------------------- level 1 50 Bytes 44 Bytes 50 Bytes level 2 158 Bytes 155 Bytes 158 Bytes level 3 266 Bytes 266 Bytes 266 Bytes level 4 376 Bytes 377 Bytes 376 Bytes level 5 484 Bytes 488 Bytes 484 Bytes Defval=level 1 value This parameter is applicable only for FR+ and transparent protocols.')
prtExPhPlClockEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("nrz", 2), ("nrzI", 3), ("fm0", 4), ("manchester", 5), ("diffManchester", 6), ("nrzISpace", 7), ("nrzIMark", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlClockEncoding.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlClockEncoding.setDescription('This object is the Encoding type of the Line. This parameter is applicable only for FR and FR+ protocols. For MAXCESS 3000 & MP2100H: when setting to nrzI (3) the nrzI works as nrzI Mark. For MAXCESS 30/300 when setting to nrzI (3) the nrzI works as nrzI Space.')
prtExPhPlMinSeparators = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlMinSeparators.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlMinSeparators.setDescription('Minimum number of bytes separating between two adjacent frames (HDLC item). 0 = notApplicable')
prtExPhPlCcittCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("crc16", 2), ("crc32", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCcittCrc.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlCcittCrc.setDescription('This object indicates how many Bits are used for CRC (HDLC item).')
prtExPhPlFrameSeparator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("idles", 2), ("flags", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrameSeparator.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlFrameSeparator.setDescription('This object indicates what should be transferred on the line when there are no frames to pass (HDLC item). idles: mean that FF will pass on the line flags: mean that 7E will pass on the line.')
prtExPhPlIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlIdleCode.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlIdleCode.setDescription('Determines the code for transmission when there are no frames to transmit on the line. The value should be 0 to FFH.')
prtExPhPlJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlJitter.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlJitter.setDescription('Maximum variant delay of the FR network, in msec.')
prtExPhPlDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2), )
if mibBuilder.loadTexts: prtExPhPlDlciTable.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciTable.setDescription('The write operation into the Table Objects is valid only at the TmpCnfg entry.')
prtExPhPlDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtExPhPlDlciCnfgIdx"), (0, "RAD-MIB", "prtExPhPlDlciSltIdx"), (0, "RAD-MIB", "prtExPhPlDlciPrtIdx"), (0, "RAD-MIB", "prtExPhPlDlciIdx"))
if mibBuilder.loadTexts: prtExPhPlDlciEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciEntry.setDescription('An entry in table.')
prtExPhPlDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPhPlDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciPrtIdx.setDescription('This attribute indicates a unique internal port number. PH.1/E1 and PH.1/T1 cards have three internal ports. Stand-alone units may have six such ports.')
prtExPhPlDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciIdx.setDescription("This attribute indicates a unique index for each possible used dlci(16..991). When the protocol is not Multiplexing protocol, its type is 'user' and the only valid index is 1.")
prtExPhPlDlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciValid.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtExPhPlDlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConSlt.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. cl - will represent any of the CL slots. This value can be selected for multiple DLCIs of the product. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPhPlDlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("clNMS", 99), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciIConPrt.setDescription("This attribute indicates a unique port id which the dlci is routed to. clNMS - will be used for NMS SNMP messages. It can be any port of the CL card. This value will be selectable only if prtExPhPlDlciIConSlt='cl' or 'notApplicable'.")
prtExPhPlDlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConDlci.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number, the dlci is routed to.')
prtExPhPlDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14400bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciTxBc.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line (or at the port receive line).')
prtExPhPlDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14400bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciTxBe.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line (or at the port receive line).')
prtExPhPlDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14400bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciRxBc.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line (or at the port transmit line).')
prtExPhPlDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14400bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciRxBe.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line (or at the port transmit line).')
prtExPhPlDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciPriority.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 8 is the highest priority.')
prtExPhPlDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciStatus.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtExPhPlModemTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3), )
if mibBuilder.loadTexts: prtExPhPlModemTable.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemTable.setDescription('External Modem Parameters. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
prtExPhPlModemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtExPhPlModemCnfgIdx"), (0, "RAD-MIB", "prtExPhPlModemSltIdx"), (0, "RAD-MIB", "prtExPhPlModemPrtIdx"))
if mibBuilder.loadTexts: prtExPhPlModemEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemEntry.setDescription('An entry in table.')
prtExPhPlModemCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlModemSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExPhPlModemPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemPrtIdx.setDescription('This attribute indicates a unique port number. In case of PH.1 card, only exPrt(1) is valid.')
prtExPhPlModemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("relay", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemStatus.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemStatus.setDescription('This object indicates whether a Dial Up Modem is enabled on this port. Default: disable For Vmux devices this object shows whether there is Modem Relay support.')
prtExPhPlModemActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("onFirstFrame", 2), ("always", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemActivate.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemActivate.setDescription('This object indicates whether the Dial Up Modem is activated when the first frame is received or it is always activated. Default: onFirstFrame')
prtExPhPlModemMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemMaxIdleTime.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemMaxIdleTime.setDescription('Max Time allowed in Seconds without any traffic before the line is disconnected. Legal Values are: 1 sec, 2 sec .. 5 sec, 10 sec, 20 sec.. 1 min, 2 min .. 10 min, 15 min, 20 min, 25 min, 30 min. 65535 sec. means that this parameter is not applicable. Default: 1 sec.')
prtExPhPlModemTimeBtwnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemTimeBtwnCalls.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemTimeBtwnCalls.setDescription('Minimum Time in Seconds which is required after a call was disconnected. In this time no other call will be initiated from this Modem port even if there were frames transmitted to this port. This time is required for some Modems which have initializations that take a few seconds. Legal Values are: 0 sec. - 30 sec., 1-5 min. 65535 sec. means that this parameter is not applicable. Default: 0 sec')
prtExPhPlModemCallDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemCallDelay.setStatus('current')
if mibBuilder.loadTexts: prtExPhPlModemCallDelay.setDescription('Time in Seconds that the device will wait before dialing to the remote device. This feature is mostly used when there is a backup modem to the main link and the main link is down. In this case it is important to prevent the 2 devices from dialing through the backup modems to each other at the same time. It is advised to configure one side with a small call delay and the other side with a large call delay. Legal Values are: 0 - 30, 60, 120, 180, 240, 300, 600, 900, 1200, 1500, 1800 . 65535 sec. means that this parameter is not applicable. Default: 0 sec')
prtExLs2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1), )
if mibBuilder.loadTexts: prtExLs2CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExLs2CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExLs2CnfgIdx"), (0, "RAD-MIB", "prtExLs2SltIdx"), (0, "RAD-MIB", "prtExLs2PrtIdx"))
if mibBuilder.loadTexts: prtExLs2CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExLs2CnfgEntry.setDescription('An entry in table.')
prtExLs2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExLs2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs2PrtIdx.setDescription('This attribute indicates a unique port index. For the Ls2/X.58 exPrt(7)..exPrt(10) are not valid.')
prtExLs2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Connect.setStatus('current')
if mibBuilder.loadTexts: prtExLs2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs2Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("r2400bps", 2), ("r4800bps", 3), ("r9600bps", 4), ("r19200bps", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Rate.setStatus('current')
if mibBuilder.loadTexts: prtExLs2Rate.setDescription('Port rates.')
prtExLs2ClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dce", 1), ("ext-dce", 2), ("dte", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2ClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExLs2ClkMode.setDescription('This attribute indicates a unique port operation clock mode.')
prtExLs2Cts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("on", 2), ("rts-min", 3), ("rts-max", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Cts.setStatus('current')
if mibBuilder.loadTexts: prtExLs2Cts.setDescription('CTS.')
prtExLs2Dcd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("card-sync", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Dcd.setStatus('current')
if mibBuilder.loadTexts: prtExLs2Dcd.setDescription('DCD.')
prtExLs2EnvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2EnvIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs2EnvIdx.setDescription('Envelope Index. When prtInLs2EnvAssign=auto, the value is 0 (not applicable).')
prtInLs2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2), )
if mibBuilder.loadTexts: prtInLs2CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInLs2CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInLs2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtInLs2CnfgIdx"), (0, "RAD-MIB", "prtInLs2SltIdx"), (0, "RAD-MIB", "prtInLs2PrtIdx"))
if mibBuilder.loadTexts: prtInLs2CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInLs2CnfgEntry.setDescription('An entry in table.')
prtInLs2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInLs2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInLs2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs2PrtIdx.setDescription('This attribute indicates a unique internal port index.')
prtInLs2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Connect.setStatus('current')
if mibBuilder.loadTexts: prtInLs2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the module considerations because the module has only one Internal interface which is the composite channel.')
prtInLs2Group = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Group.setStatus('current')
if mibBuilder.loadTexts: prtInLs2Group.setDescription('This attribute indicates the group number of the port. LS-2 internal ports with the same group number share the same Time slot of the main link')
prtInLs2Member = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Member.setStatus('current')
if mibBuilder.loadTexts: prtInLs2Member.setDescription('This attribute indicates the group member id of the port. This parameter is for the automatic envelope assignment algorithm.')
prtInLs2LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInLs2LinkTo.setDescription('It indicates the slot of the main link card to which the LS2 card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtInLs2EnvAssign = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("auto", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2EnvAssign.setStatus('current')
if mibBuilder.loadTexts: prtInLs2EnvAssign.setDescription('Envelope assignment type.')
prtVc2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5), )
if mibBuilder.loadTexts: prtVc2CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtVc2CnfgTable.setDescription('- For products supporting more than one configuration, the write operation into the Table is valid only to the TmpCnfg entry. - For products that do not support configurations, the write operation into the Table will be to prtVc2CnfgIdx=1.')
prtVc2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1), ).setIndexNames((0, "RAD-MIB", "prtVc2CnfgIdx"), (0, "RAD-MIB", "prtVc2SltIdx"), (0, "RAD-MIB", "prtVc2PrtIdx"))
if mibBuilder.loadTexts: prtVc2CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtVc2CnfgEntry.setDescription('An entry in table.')
prtVc2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtVc2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtVc2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtVc2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. For Stand Alone products like WR: notApplicable (255)')
prtVc2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtVc2PrtIdx.setDescription("A unique identifier of the port, within the card. For MP-2100/2200 card ports, Web Ranger and FCD-IP Voice ports the values will be: exPrt1 (1) exPrt2 (2) exPrt3 (3) exPrt4 (4) exPrt5 (5) exPrt6 (6) exPrt7 (7) exPrt8 (8) exPrt9 (9) exPrt10 (10) exPrt11 (11) exPrt12 (12) exPrt13 (13) exPrt14 (14) exPrt15 (15) exPrt16 (16) For LA-240: The index for fixed voice ports will be - exPrt6 (6) exPrt7 (7) exPrt8 (8) exPrt9 (9) The index for voice card ports will be - Slot number * 100 + ch (for IO-1: 101..104, for IO-2: 201..204). For other products' index see their specification.")
prtExVc2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("v51", 4), ("v52", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Connect.setStatus('current')
if mibBuilder.loadTexts: prtExVc2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExVc2TransGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2TransGain.setStatus('current')
if mibBuilder.loadTexts: prtExVc2TransGain.setDescription('Transmit gain in dBm. For ports of MP-104/204, MP-2100/2200 VC-6A, VC-6AG, VC-8 VC-4/Omni and VC-16 cards, the units will be 0.1dBm because valid values can be in 0.5dBm steps.')
prtExVc2ReceiveGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ReceiveGain.setStatus('current')
if mibBuilder.loadTexts: prtExVc2ReceiveGain.setDescription('Receive gain in dBm. For ports of MP-104/204, MP-2100/2200 VC-6A, VC-6AG, VC-8 VC-4/Omni and VC-16 cards, the units will be 0.1dBm because valid values can be in 0.5dBm steps.')
prtExVc2Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Wire.setStatus('current')
if mibBuilder.loadTexts: prtExVc2Wire.setDescription('For some cards, this object is equal for all the ports in the specific card because of HW limitations. For FXO & FXS this parameter is not applicable.')
prtExVc2CodingLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aLAW", 1), ("uLAW", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CodingLaw.setStatus('current')
if mibBuilder.loadTexts: prtExVc2CodingLaw.setDescription('This attribute indicates the Method/Law for decoding/encoding the voice information. aLaw(1) is the standard Law for E1 links. uLaw(2) is the standard Law for T1 links. This object is equal for all the ports in the specific module because of HW limitations')
prtExVc2Sig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noSignaling", 1), ("robbedBitMultiFrame", 2), ("chAssociatedE1", 3), ("robbedBitFrame", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Sig.setStatus('current')
if mibBuilder.loadTexts: prtExVc2Sig.setDescription('This attribute indicates the method for decoding/encoding the signaling information(on/off hook). noSignaling (1) - not using signaling (only voice). robbedBitMultiFrame(2) - is the standard method for T1 links and proprietary method for E1 links. chAssociatedE1 (3) - is valid only for E1 G.732S links. robbedBitFrame (4) - is proprietary method implimenting 7 bit for the voice and 1 bit dedicated for signaling. For some cards, this object is equal for all the ports in the specific module because of HW limitations.')
prtExVc2Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4), ("notApplicable", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Oos.setStatus('current')
if mibBuilder.loadTexts: prtExVc2Oos.setDescription('This object is equal for all the ports in the specific card because of HW limitations')
prtExVc2LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExVc2LinkTo.setDescription('This attribute indicates the slot of the ML card to which the VC card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVc2OperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2OperMode.setStatus('current')
if mibBuilder.loadTexts: prtExVc2OperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request.')
prtExVc2SigProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("manual", 2), ("p1", 3), ("p2", 4), ("p3Fxo3S3", 5), ("reversePolarity", 6), ("meteringPulse", 7), ("p4", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SigProfile.setStatus('current')
if mibBuilder.loadTexts: prtExVc2SigProfile.setDescription('This object indicates the Signaling Profile of the port. notApplicable - for VC-2 family and when prtExVc2Sig=noSignaling(1) p1 = profile 1 p2 = profile 2 p3 = profile 3 p4 = profile 4 ')
prtExVc2CallEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("incoming", 2), ("outgoing", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CallEnable.setStatus('current')
if mibBuilder.loadTexts: prtExVc2CallEnable.setDescription('This object indicates the Enabled Call direction. notApplicable - for all cards except VC-2/R2. both - incoming + outgoing.')
prtExVc2R2Delay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("terrestrial", 2), ("satellite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2R2Delay.setStatus('current')
if mibBuilder.loadTexts: prtExVc2R2Delay.setDescription('This object indicates the R2 Delay. notApplicable - for all cards except VC-2/R2.')
prtExVc2CasStd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("r2Q422", 2), ("specialA", 3), ("specialB", 4), ("specialC", 5), ("specialD", 6), ("specialE", 7), ("specialF", 8), ("specialG", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CasStd.setStatus('current')
if mibBuilder.loadTexts: prtExVc2CasStd.setDescription('This object indicates the CAS (Channel Associated Signaling) Standard. notApplicable - for all cards except VC-2/R2.')
prtExVc2EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2EchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtExVc2EchoCanceler.setDescription('Echo canceler activation. notApplicable - for VC-2 and VC-6 cards.')
prtExVc2IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("w2Em", 2), ("w4Em", 3), ("fxo", 4), ("fxs", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2IfType.setStatus('current')
if mibBuilder.loadTexts: prtExVc2IfType.setDescription('Interface Type.')
prtExVc2Encoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("pcm", 2), ("adpcm", 3), ("linear", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Encoding.setStatus('current')
if mibBuilder.loadTexts: prtExVc2Encoding.setDescription('Voice Encoding Mode. linear - is relevant only for the ports of VC-16A card.')
prtExVc2TxBitCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 20), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2TxBitCode.setStatus('current')
if mibBuilder.loadTexts: prtExVc2TxBitCode.setDescription(' - - - For MP & FCD - - - This object represents 4 parameters, by 2 Octets : Tx D Bit Code-MSB nibble, Tx C Bit Code- nibble, Tx B Bit Code- nibble, Tx A Bit Code-LSB nibble. Each nibble: 0 hex = 0000 = Not Applicable 1 hex = 0001 = M lead 2 hex = 0010 = M lead inverse 3 hex = 0011 = Reverse Polarity 4 hex = 0100 = Metering Pulse 5 hex = 0101 = Forced 1 6 hex = 0110 = Forced 0 7-F hex - not used (invalid values) This object will be RO if prtExVc2SigProfile is NOT manual. - - - For WR II - - - This object represents the following 4 parameters by 2 Octets: 1. On/Off hook signaling transmission mode from the FXS towards the T1/E1 (MSB nibble 1). 2. Default signaling bits that are not in use (nibble 2). 3. Ring Detection signaling transmission mode from the FXO towards the T1/E1(nibble 3). 4. M (Mouth) Signaling transmission mode from the E&M towards the T1/E1(LSB nibble 4). Each nibble: --------------------------------------------------------------------------------------- Value On/Off Hook Default sig. Ring Detect. M (Mouth) --------------------------------------------------------------------------------------- 0 hex = 0000 Not Applicable Not Applicable. Not Applicable Not Applicable 1 hex = 0001 Tx A bit Values 1-3 are Tx A bit Tx A bit 2 hex = 0010 Tx A bit inverse for On/Off Hook Tx A bit inv. Tx A bit inv. 3 hex = 0011 Tx B bit A,B,A Inv,B Inv. Tx B bit Tx B bit 4 hex = 0100 Tx B bit inverse Values 4-7 are Tx B bit inv. Tx B bit inv. 5 hex = 0101 not Used-invalid for On/Off Hook not Used-invalid not Used-invalid 6 hex = 0110 not Used-invalid A, A Inverse. not Used-invalid not Used-invalid 7 hex = 0111 not Used-invalid not Used-invalid not Used-invalid 8 hex = 1000 not Used-invalid Values 8-11 are not Used-invalid not Used-invalid 9 hex = 1001 not Used-invalid for On/Off Hook not Used-invalid not Used-invalid A hex = 1010 not used-invalid B, B Inverse. not Used-invalid not Used-invalid B hex = 1011 not used-invalid The Bits order: not Used-invalid not Used-invalid C-F hex not used-invalid ABCD not Used-invalid not Used-invalid Default value: 11 11 ')
prtExVc2RxBitOutput = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2RxBitOutput.setStatus('current')
if mibBuilder.loadTexts: prtExVc2RxBitOutput.setDescription(' - - - For MP (VC-Q card only) & FCD - - - This object represents 3 parameters by 2 Octets: Spare -MSB nibble, always=0 hex E Lead Output - nibble, Reverse Polarity Output- nibble, Metering Pulse Output -LSB nibble. Each nibble: 0 hex = 0000 = Not Applicable 1 hex = 0001 = Rx A bit 2 hex = 0010 = Rx A bit inverse 3 hex = 0011 = Rx B bit 4 hex = 0100 = Rx B bit inverse 5 hex = 0101 = Rx C bit 6 hex = 0110 = Rx C bit inverse 7 hex = 0111 = Rx D bit 8 hex = 1000 = Rx D bit inverse 9 hex = 1001 = none A-F hex - not used (invalid values) This object will be RO if prtExVc2SigProfile is NOT manual. - - - For MP (VC-8, VC-16, VC-16A cards) - - - This object represents 4 parameters, by 2 Octets : Tx D Bit Code-MSB nibble, Tx C Bit Code- nibble, Tx B Bit Code- nibble, Tx A Bit Code-LSB nibble. Each nibble: 0 hex = 0000 = Not Applicable 1 hex = 0001 = not used (invalid value) 2 hex = 0010 = not used (invalid value) 3 hex = 0011 = not used (invalid value) 4 hex = 0100 = not used (invalid value) 5 hex = 0101 = Forced 1 6 hex = 0110 = Forced 0 7-F hex - not used (invalid values) This object will be RO. - - - For WR II - - - This object represents the following 2 parameters in 1 Octet: 1. On/Off hook signaling receive mode from the T1/E1 into the FXS/FXO (MSB nibble 1). 2. E (Ear) Signaling receive mode from the T1/E1 into the E&M (LSB nibble 2). Each nibble: --------------------------------------------------------------------------------------- Value On/Off Hook E (Ear) --------------------------------------------------------------------------------------- 0 hex = 0000 Not Applicable Not Applicable 1 hex = 0001 Rx A bit Rx A bit 2 hex = 0010 Rx A bit inverse Rx A bit inverse 3 hex = 0011 Rx B bit Rx B bit 4 hex = 0100 Rx B bit inverse Rx B bit inverse 5-F hex not used-invalid not Used-invalid Default value: 11 ')
prtExVc2MeterRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("r16Khz", 2), ("r12Khz", 3), ("disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2MeterRate.setStatus('current')
if mibBuilder.loadTexts: prtExVc2MeterRate.setDescription("This entry is applicable only for VC-6A/FXO, VC-6A/FXS, VC-8/FXO, VC-8/FXS, VC-16/FXO and VC-16/FXS. Meter Rate means rate of Call Meter in Public Phones, in KHz units. For some cards, the value must be the same for all card's ports.")
prtExVc2IfSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("loopStart", 2), ("groundStart", 3), ("winkStart", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2IfSignaling.setStatus('current')
if mibBuilder.loadTexts: prtExVc2IfSignaling.setDescription("This entry is applicable only for VC-6A, VC-6AG, VC-8/FXO, VC-8/FXS, VC-16/FXO and VC-16/FXS cards. Interface Analog Signaling. Must be the same for all card's ports. loopStart - for the usual trunk/phone types. groundStart - for trunks that need Ground signaling . winkStart - for trunks that need Reverse Polarity. ")
prtExVc2SeizeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SeizeAck.setStatus('current')
if mibBuilder.loadTexts: prtExVc2SeizeAck.setDescription('This parameter shows whether the device will acknowledge a seize signal (On/Off Hook). When the value is set to yes(3) & the device receives an on/off hook signal it will transmit back an on/off hook signal. When the value is set to no(2) & the device receives an on/off hook signal it will NOT transmit back an on/off hook signal. Default value for WR FXO: no(2).')
prtExVc2EandMType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("type1", 2), ("type2", 3), ("type3", 4), ("type5", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2EandMType.setStatus('current')
if mibBuilder.loadTexts: prtExVc2EandMType.setDescription('This is the signaling type on the E&M analog side. The analog signaling includes voltage, no. of pins and other parameters.')
prtExVc2RemType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("lb", 2), ("pbx", 3), ("e1", 4), ("t1", 5), ("t1D4", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2RemType.setStatus('current')
if mibBuilder.loadTexts: prtExVc2RemType.setDescription('Remote Type. Applicable for VC-6A/4LB card & for IPMUX-1E Far End Type - E1,T1(T1-ESF) or T1-D4 .')
prtExVc2ConvTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("m2", 2), ("m3", 3), ("m5", 4), ("unlimited", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ConvTime.setStatus('current')
if mibBuilder.loadTexts: prtExVc2ConvTime.setDescription('Conversation Time in minutes. Applicable for VC-6A/4LB card.')
prtExVc2SigFeedback = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SigFeedback.setStatus('current')
if mibBuilder.loadTexts: prtExVc2SigFeedback.setDescription('Signaling Feedback. Applicable for VC-8/FXO and VC-16/FXO cards.')
prtExVc2EchoCancelerModule = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("notExist", 2), ("exist", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc2EchoCancelerModule.setStatus('current')
if mibBuilder.loadTexts: prtExVc2EchoCancelerModule.setDescription('This parameter indicates whether Echo canceler module exists for this port.')
prtExVc2ReversePolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ReversePolarity.setStatus('current')
if mibBuilder.loadTexts: prtExVc2ReversePolarity.setDescription('This object Enables/Disables Reverse Polarity for this port.')
prtExVc2RingerFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("f20Hz", 2), ("f25Hz", 3), ("f50Hz", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2RingerFrequency.setStatus('current')
if mibBuilder.loadTexts: prtExVc2RingerFrequency.setDescription('This object selects the Ringer Frequency (Hz) for this port.')
prtExVc2SigService = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("advanced", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SigService.setStatus('current')
if mibBuilder.loadTexts: prtExVc2SigService.setDescription('Signaling Service. advanced - is relevant only for ports of VC-8, VC-16 FXS cards. It is used for Signaling Services of V5.1 or R2.')
prtExVc2CallerIdEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CallerIdEnable.setStatus('current')
if mibBuilder.loadTexts: prtExVc2CallerIdEnable.setDescription('This object Enables/Disables Receiving the Caller Id number from the remote side, for this port/channel.')
prtExVc2CompressMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("g726", 2), ("g727", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CompressMethod.setStatus('current')
if mibBuilder.loadTexts: prtExVc2CompressMethod.setDescription('This object is applicable only when prtExVc2Encoding=adpcm. It defines which method is used for Compression. g726 - for 4 bits (the standard method). g726 - for 3 bits. It is especially needed for T1 applications with signaling.')
prtExVc2ObMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pointToPoint", 1), ("omniBus", 2), ("pointToMultiPointSrc", 3), ("pointToMultiPointDst", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ObMode.setStatus('current')
if mibBuilder.loadTexts: prtExVc2ObMode.setDescription("This object defines the Net operation mode of the Omni-Bus card's port. pointToPoint - only 2 end-point ports talk; like any other voice card omniBus - many talk and listen. Like conference call. All can listen to all. pointToMultiPointSrc - There is one Master who can be heard by all. All can talk, but only the Master can hear all. Others can hear only the Master. This port is of the Master (Src). pointToMultiPointDst - There is one Master who can be heard by all. All can talk, but only the Master can hear all. Others can hear only the Master. This port is of a Destination (NOT Master).")
prtExVc2VAD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2VAD.setStatus('current')
if mibBuilder.loadTexts: prtExVc2VAD.setDescription('This object defines whether Voice Activation Detector (VAD) will be On or Off. off - will be usually selected when a Modem is connected to the port; not a phone. notApplicable - when prtExVc2DspMode=pointToPoint.')
prtExVc2NoiseLevelForVAD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("medium", 3), ("high", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2NoiseLevelForVAD.setStatus('current')
if mibBuilder.loadTexts: prtExVc2NoiseLevelForVAD.setDescription('This object defines the Level of Noise on the line, the Voice Activation Detector (VAD) will have to deal with. notApplicable - when prtExVc2VAD=off.')
prtExVc2WesternSigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("detector", 2), ("generator", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2WesternSigMode.setStatus('current')
if mibBuilder.loadTexts: prtExVc2WesternSigMode.setDescription('This object defines the Western Signaling Mode. detector - detects signal and passes it as is. generator - generates the signal. notApplicable - when Western HW is not installed.')
prtExVc2BusProtectionPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("first", 3), ("last", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2BusProtectionPoint.setStatus('current')
if mibBuilder.loadTexts: prtExVc2BusProtectionPoint.setDescription("This object defines if the port is Bus Protection Point or not. notApplicable - when prtExVc2DspMode=pointToPoint. When we have a chain of devices where the edge devices ports are the Bus Protection Point, user must configure one of these ports as 'first' and the other as 'last'. It does not matter which one, it just matters that they will be different.")
prtExVc2ImpedanceStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("g712", 1), ("q552ETSI", 2), ("q522Italy", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ImpedanceStandard.setStatus('current')
if mibBuilder.loadTexts: prtExVc2ImpedanceStandard.setDescription('This object defines the Standard used for Impedance. -G.712 - 600 Ohm - used in USA and other countries. -Q552/ETSI - used in some countries in Europe -Q522/Italy - used in Italy.')
prtHsfCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6), )
if mibBuilder.loadTexts: prtHsfCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtHsfCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtHsfCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1), ).setIndexNames((0, "RAD-MIB", "prtHsfCnfgIdx"), (0, "RAD-MIB", "prtHsfSltIdx"), (0, "RAD-MIB", "prtHsfPrtIdx"))
if mibBuilder.loadTexts: prtHsfCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtHsfCnfgEntry.setDescription('An entry in table.')
prtHsfCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtHsfCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relate to the TmpCnfg. ')
prtHsfSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtHsfSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtHsfPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 101, 102))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("inPrt1", 101), ("inPrt2", 102)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtHsfPrtIdx.setDescription('This attribute indicates a unique external port index. Hs2 has only two ports (exPrt1,exPrt2). Hs3 has three ports (exPrt1,exPrt2,exPrt3). Hsq and hsqN has four ports. Hs6 has six external ports. Hs12 has twelve external ports. inPrt1, inPrt2 - are relevant for VID card.')
prtExHsfConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfConnect.setStatus('current')
if mibBuilder.loadTexts: prtExHsfConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExHsfRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("r32Kbps", 63)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfRate.setStatus('current')
if mibBuilder.loadTexts: prtExHsfRate.setDescription('This attribute indicates the port speed. ')
prtExHsfClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dce", 1), ("ext-dce", 2), ("dte", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExHsfClkMode.setDescription('This attribute indicates a unique port operation clock mode.')
prtExHsfCts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfCts.setStatus('current')
if mibBuilder.loadTexts: prtExHsfCts.setDescription('This attribute indicates a unique CTS control line operation mode.')
prtExHsfFifoSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("auto", 2), ("s16bits", 3), ("s30bits", 4), ("s52bits", 5), ("s72bits", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfFifoSize.setStatus('current')
if mibBuilder.loadTexts: prtExHsfFifoSize.setDescription('Size in bits.')
prtExHsfLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsfLinkTo.setDescription('This attribute indicates a slot of Main Link module, that the port is linked to. This object is the same for all the ports in the specific card because of HW limitations. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsfOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4), ("bidirBcastRing", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfOperMode.setStatus('current')
if mibBuilder.loadTexts: prtExHsfOperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request. bidirBcastRing = Bidirectional Broadcast Ring. When this value is selected, AND RTS=On, the port opens its transmission channel.')
prtExHsfInbandLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("ft1Enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfInbandLoopback.setStatus('current')
if mibBuilder.loadTexts: prtExHsfInbandLoopback.setDescription('This object indicates if Inband Loopback from the Network should be enabled or disabled.')
prtExHsfClkPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("invert", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfClkPolarity.setStatus('current')
if mibBuilder.loadTexts: prtExHsfClkPolarity.setDescription('This object indicates the clock polarity. For FCD-M this object will be applicable only for the fixed HS port (the fixed port on the device).')
prtExHsfControlSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfControlSignal.setStatus('current')
if mibBuilder.loadTexts: prtExHsfControlSignal.setDescription('This object indicates the Control Signal according to G.797 ITU-T standard. For FCD-M this object will be applicable for the fixed HS port (the fixed port on the device) and HS-Q/N channels. Local and End to End are applicable only when channel Interface type is RS-530, else it will be Not Applicable.')
prtExHsfBcastRingSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("none", 100), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfBcastRingSrcPort.setStatus('current')
if mibBuilder.loadTexts: prtExHsfBcastRingSrcPort.setDescription('This object is applicable only when prtExHsfOperMode= bidirBcastRing. In this case, the values mean: - none - this port will be connected to ML in TSA as usual. - exPrt1.. exPrtX ; X=maximum ports of the card in focus : it means that the same TS that is assigned in TSA to this port is actually connected also to this port, for Broadcast Ring mode. Therefore, this port should NOT be connected to ML in TSA.')
prtExHs4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1), )
if mibBuilder.loadTexts: prtExHs4CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExHs4CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHs4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExHs4CnfgIdx"), (0, "RAD-MIB", "prtExHs4SltIdx"), (0, "RAD-MIB", "prtExHs4PrtIdx"))
if mibBuilder.loadTexts: prtExHs4CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExHs4CnfgEntry.setDescription('An entry in table.')
prtExHs4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHs4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExHs4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExHs4Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4Connect.setStatus('current')
if mibBuilder.loadTexts: prtExHs4Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithm. It also affects all the module considerations because the card has only one external (physical) interface.')
prtExHs4LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineType.setStatus('current')
if mibBuilder.loadTexts: prtExHs4LineType.setDescription('This attribute is the line type parameter for T1/E1 interface. The user should select only the parameters relevant to the specific card: T1 line code parameters for the HS-4/1 and E1 line code parameters for the HS-4/2. This parameter has the same values as dsx1LineType in T1/E1 MIB (RFC-1406). The parameters in dsx1LineType are: other (1) dsx1ESF (2) dsx1D4 (3) dsx1E1 (4) dsx1E1-CRC (5) dsx1E1-MF (6) dsx1E1-MF-CRC (7)')
prtExHs4LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("b7T1", 1), ("b8zsT1", 2), ("hdb3E1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineCode.setStatus('current')
if mibBuilder.loadTexts: prtExHs4LineCode.setDescription('This attribute is the line code parameter used for T1/E1 interface. The user should select only the parameters relevant to the specific card: T1 line code parameters for the MPH.1/T1 and E1 line code parameters for the MPH.1/E1. This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExHs4LineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("fcc68", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineLen.setStatus('current')
if mibBuilder.loadTexts: prtExHs4LineLen.setDescription('This attribute is the line length parameter used only for T1 interfaces. len399p533ft=len-399-533ft ')
prtExHs4RestoreT = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4RestoreT.setStatus('current')
if mibBuilder.loadTexts: prtExHs4RestoreT.setDescription('Time passing from the disappearance of the loss of synchronization condition (red alarm), to the restoration of normal service.')
prtExHs4OosSig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notsupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4OosSig.setStatus('current')
if mibBuilder.loadTexts: prtExHs4OosSig.setDescription('Out of Service signal type.')
prtExHs4OosCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notsupported", 2), ("oosCode00H", 3), ("oosCode1aH", 4), ("oosCode54H", 5), ("oosCode7eH", 6), ("oosCode7fH", 7), ("oosCode98H", 8), ("oosCode9eH", 9), ("oosCoded5H", 10), ("oosCodee4H", 11), ("oosCodeffH", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4OosCode.setStatus('current')
if mibBuilder.loadTexts: prtExHs4OosCode.setDescription('OOS Code')
prtExHs4IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4IdleCode.setStatus('current')
if mibBuilder.loadTexts: prtExHs4IdleCode.setDescription(' Type value(00 - FF HEX), excluding 0H,8H,10H,12H,21H,24H, 42H,49H,84H,92H')
prtExHs4MfClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("local", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4MfClkSrcSlt.setStatus('current')
if mibBuilder.loadTexts: prtExHs4MfClkSrcSlt.setDescription("This attribute indicates whether the port Tx is multiframe synchronized with Rx multiframe of another port and the slot position of that port. This opration is required in order to bypass signaling of PCM voice channels. When its value is Local(2) there is no meaning to 'prtExHs4MfClkSrcPrt' parameter. In the ?004 Unit the entries io6(10)..io16) are not valid")
prtExHs4MfClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 101))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("inPrt1", 101)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4MfClkSrcPrt.setStatus('current')
if mibBuilder.loadTexts: prtExHs4MfClkSrcPrt.setDescription('A unique number to identify a port position in the mux if the MultiFrame clock source is valid (YES). inPrt1 - for MTML-H/E1 cards.')
prtExHs4TsCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2), )
if mibBuilder.loadTexts: prtExHs4TsCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHs4TsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtExHs4TsCnfgIdx"), (0, "RAD-MIB", "prtExHs4TsSltIdx"), (0, "RAD-MIB", "prtExHs4TsPrtIdx"), (0, "RAD-MIB", "prtExHs4TsIdx"))
if mibBuilder.loadTexts: prtExHs4TsEntry.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsEntry.setDescription('An entry in table.')
prtExHs4TsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExHs4TsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExHs4TsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsPrtIdx.setDescription('This attribute indicates a unique port number. Hs4/T1 and Hs4/T1 cards have only one external interface.')
prtExHs4TsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines, time slot 16 is not valid for data, it is dedicated to multiframe synchronization bits and voice signaling.')
prtExHs4TsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 100))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("split", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConSlot.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io16) are not valid. split - will be used when the Src TS is connected to more than one slot OR more than one port (each needing less than a whole TS).')
prtExHs4TsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("noConnect", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsIConPrt.setDescription('This attribute indicates the internally (In Mux) connected/routed port.')
prtExHs4TsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConTs.setStatus('current')
if mibBuilder.loadTexts: prtExHs4TsIConTs.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Module and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtExHsiCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1), )
if mibBuilder.loadTexts: prtExHsiCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExHsiCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHsiCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExHsiCnfgIdx"), (0, "RAD-MIB", "prtExHsiSltIdx"), (0, "RAD-MIB", "prtExHsiPrtIdx"))
if mibBuilder.loadTexts: prtExHsiCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExHsiCnfgEntry.setDescription('An entry in table.')
prtExHsiCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsiCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHsiSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsiSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExHsiPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsiPrtIdx.setDescription("A unique port identifier within the card. For MP : 1..12 For DXC: 111 .. 2531. See DXC R6 spec for port index convention. For FCD-A, 'S' Interface external ports: 131, 141, 151, 161.")
prtExHsiConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("v51", 4), ("v52", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiConnect.setStatus('current')
if mibBuilder.loadTexts: prtExHsiConnect.setDescription("This attribute indicates whether the port should be considered in any of the mux algorithms. v51 - this port is connected to a V5.1 interface. All rest of the values will be 'notApplicable' in this case. V5 MIB will be used instead. v52 - this port is connected to a V5.2 interface. All rest of the values will be 'notApplicable' in this case. V5 MIB will be used instead.")
prtExHsiRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 255))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r128kbps", 12), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiRate.setStatus('current')
if mibBuilder.loadTexts: prtExHsiRate.setDescription('This attribute indicates the port speed.')
prtExHsiLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsiLinkTo.setDescription('It indicates the slot of the main link card to which the HS-? card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsiInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("lt", 1), ("nt", 2), ("te", 3), ("lt1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiInterface.setStatus('current')
if mibBuilder.loadTexts: prtExHsiInterface.setDescription("It indicates the interface type: lt = line termination nt = network termination te = terminal equipment. lt1 - for ASMi-31 connection (not ISDN) For MP: For HS-U/I only 'lt' and 'nt' are applicable. For HS-U/1 only 'lt' is applicable. For HS-S , only 'te' and 'nt' are applicable. For HS-U, this object is not applicable. For HS-U6, HS-U12, are applicable: 'lt'=lt-i,'nt'=nt-i, lt1. For DXC: For HS-U8, HS-U16, are applicable: 'lt'=LT-I,'nt'=NT-I, 'lt1'=LT-1.")
prtExHsiActType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("type1", 2), ("type2", 3), ("type3", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiActType.setStatus('current')
if mibBuilder.loadTexts: prtExHsiActType.setDescription('It indicates the Activation Type. Activation Type is the Synchronization type towards the PBX. It is applicable only when prtExHsiInterface=nt. notApplicable - for cards that do not support this object, or when prtExHsiInterface is NOT nt.')
prtInHsiCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2), )
if mibBuilder.loadTexts: prtInHsiCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInHsiCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry. This table is not applicable for MP-2100 HS-U card type.')
prtInHsiCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtInHsiCnfgIdx"), (0, "RAD-MIB", "prtInHsiSltIdx"), (0, "RAD-MIB", "prtInHsiPrtIdx"))
if mibBuilder.loadTexts: prtInHsiCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInHsiCnfgEntry.setDescription('An entry in table.')
prtInHsiCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInHsiCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInHsiSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInHsiSltIdx.setDescription('This object indicates a unique slot position where the card is inserted.')
prtInHsiPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInHsiPrtIdx.setDescription('A unique port identifier within the card. Valid values for MP: inPrt1 (101) .. inPrt48 (148). Valid values for DXC: 11012.. 25316. See DXC R6 spec for port index convention.')
prtInHsiConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiConnect.setStatus('current')
if mibBuilder.loadTexts: prtInHsiConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInHsiRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 100, 255))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r128kbps", 12), ("concentrated", 13), ("notConnected", 100), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiRate.setStatus('current')
if mibBuilder.loadTexts: prtInHsiRate.setDescription('This object indicates the port speed. For HS-U/I and HS-S ports: 2 bit - up to 9600bps 4 bit - 19200bps 8 bit - 38400bps .. 64kbps. concentrated - this D channel goes to a Concentration channel, that represents many channels that this value was selected for them. The Concentrated channel is an Internal D Channel of the same card. This value is applicable only for D channels, except Concentration channel itself. --for HS-S and HS-U/I cards the Concentration channel will always be: internal-13 --for MP-2200 HS-S12, HS-S6, HS-U12, HS-U6 and DXC HS-U8 and HS-U16 cards, the Concentration channel is selected via the prtInHsiConcentratedTo object. notConnected - same as prtInHsiConnect=no.')
prtInHsiConcentratedTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiConcentratedTo.setStatus('current')
if mibBuilder.loadTexts: prtInHsiConcentratedTo.setDescription('The Concentration D Channel of the prtInHsiPrtIdx port. The port always belongs to the same card as prtInHsiPrtIdx port. This object is applicable only when prtInHsiRate=concentrated. Valid values: - notApplicable: 255 - for MP-2200: HS-S12, HS-U12 cards: inPrt37 (137) .. inPrt48 (148). HS-S6, HS-U6 cards: inPrt19 (119) .. inPrt24 (124). - for DXC: HS-U8 cards: 112 .. 254 HS-U16 cards: 112 .. 258. See DXC R6 spec for port index convention.')
prtExHsrCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1), )
if mibBuilder.loadTexts: prtExHsrCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExHsrCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHsrCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExHsrCnfgIdx"), (0, "RAD-MIB", "prtExHsrSltIdx"), (0, "RAD-MIB", "prtExHsrPrtIdx"))
if mibBuilder.loadTexts: prtExHsrCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExHsrCnfgEntry.setDescription('An entry in table.')
prtExHsrCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsrCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHsrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsrSltIdx.setDescription('This object indicates a unique slot position where the card is inserted.')
prtExHsrPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExHsrPrtIdx.setDescription('A unique prt identifier within the card. Valid values: For MP: - For HS-R cards: exPrt1 (1) .. exPrt4 (4) - For HS-U/1 cards: inPrt1 (101) .. inPrt4 (104) - For HS-S12, HS-S6, HS-U12, HS-U6 cards: exPrt1 (1) .. exPrt12 (12). This MIB table is used only for LT-1 interface. For DXC: - For HS-U8, HS-U16 cards: 111 .. 2531 (See DXC R6 spec for port index convention). This MIB table is used only for LT-1 interface.')
prtExHsrConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrConnect.setStatus('current')
if mibBuilder.loadTexts: prtExHsrConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtExHsrProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("sync", 2), ("async", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrProtocol.setStatus('current')
if mibBuilder.loadTexts: prtExHsrProtocol.setDescription('This object indicates the protocol.')
prtExHsrRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 100))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r16000bps", 12), ("r32000bps", 13), ("r57600bps", 14), ("r115200bps", 15), ("r128000bps", 16), ("r7200bps", 17), ("r14400bps", 18), ("r28800bps", 19), ("notConnected", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRate.setStatus('current')
if mibBuilder.loadTexts: prtExHsrRate.setDescription('This object indicates the port speed. The 16,32,48,56,64 and 128 kbps rates are applicable only for Sync protocol. The 57.6 and 115.2 kbps rates are applicable only for Async protocol. notConnected= 0 rate.')
prtExHsrDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("d5bits", 1), ("d6bits", 2), ("d7bits", 3), ("d8bits", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrDataBits.setStatus('current')
if mibBuilder.loadTexts: prtExHsrDataBits.setDescription('Data Bits. This object is applicable for Async protocol only.')
prtExHsrParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("odd", 4), ("even", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrParity.setStatus('current')
if mibBuilder.loadTexts: prtExHsrParity.setDescription("- For HS-R card, this object indicates if the parity bit is needed or not. Therefore, the 'no' and 'yes; values are applicable. - For HS-S12, HS-U12, the parity type is selected: no, odd, even. This object is applicable for Async protocol only.")
prtExHsrStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("stopBits1Bit", 1), ("stopBits2Bits", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrStopBits.setStatus('current')
if mibBuilder.loadTexts: prtExHsrStopBits.setDescription('This object indicates the minimum number of stop bits in the tx async frame. This object is applicable for Async protocol only.')
prtExHsrCts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("on", 2), ("rts", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrCts.setStatus('current')
if mibBuilder.loadTexts: prtExHsrCts.setDescription('CTS. This object is applicable for Async protocol only.')
prtExHsrClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExHsrClkMode.setDescription('Clock mode. This object is applicable for Sync protocol only.')
prtExHsrLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsrLinkTo.setDescription('It indicates the slot of the main link card to which the HS-R card is mapped. notApplicable - for HS-U/1 internal ports. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsrDcdDsr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrDcdDsr.setStatus('current')
if mibBuilder.loadTexts: prtExHsrDcdDsr.setDescription('DCD & DSR.')
prtExHsrOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrOperMode.setStatus('current')
if mibBuilder.loadTexts: prtExHsrOperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request.')
prtExHsrRtsDtr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRtsDtr.setStatus('current')
if mibBuilder.loadTexts: prtExHsrRtsDtr.setDescription('RTS & DTR.')
prtExHsrLlbEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrLlbEnable.setStatus('current')
if mibBuilder.loadTexts: prtExHsrLlbEnable.setDescription('Enable/Disable LLB.')
prtExHsrRlbEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRlbEnable.setStatus('current')
if mibBuilder.loadTexts: prtExHsrRlbEnable.setDescription('Enable/Disable RLB.')
prtExHsrRateAdapt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("proprietary", 2), ("v110", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRateAdapt.setStatus('current')
if mibBuilder.loadTexts: prtExHsrRateAdapt.setDescription('Rate Adaptation - takes a low rate and adapts it to 64Kbps. This object specifies the means this adaptation is done by.')
prtExHsrRemoteModem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("asmi31", 2), ("asmi31s2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRemoteModem.setStatus('current')
if mibBuilder.loadTexts: prtExHsrRemoteModem.setDescription('Remote modem. asmi31s2 = ASMi-31/2 ')
prtExHsrEncapsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("bwOptimized", 2), ("latencyOptimized", 3), ("asmi31", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrEncapsMode.setStatus('current')
if mibBuilder.loadTexts: prtExHsrEncapsMode.setDescription('Low Speed encapsulation method over PCM. When Encapsulation mode is Latency optimized, only rates up to 19.2 are supported. In this case a double number of bits occupy the Time Slot. For up to 9.6 Kbps - 4 bits are occupied. For 14.4 & 19.2 Kbps - 8 bits are occupied. When Encapsulation Mode is Bandwidth Optimized: For up to 9.6 Kbps - 2 bits are occupied. For 14.4 & 19.2 Kbps - 4 bits are occupied. For higher rates - 8 bits are occupied.')
prtExMbeCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1), )
if mibBuilder.loadTexts: prtExMbeCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExMbeCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExMbeCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExMbeCnfgIdx"), (0, "RAD-MIB", "prtExMbeSltIdx"), (0, "RAD-MIB", "prtExMbePrtIdx"))
if mibBuilder.loadTexts: prtExMbeCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExMbeCnfgEntry.setDescription('An entry in table.')
prtExMbeCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbeCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExMbeCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExMbeSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbeSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExMbeSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExMbePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbePrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExMbePrtIdx.setDescription('A unique port identifier within the card.')
prtExMbeLan = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("remote", 1), ("main", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExMbeLan.setStatus('current')
if mibBuilder.loadTexts: prtExMbeLan.setDescription('This attribute indicates whether the MBE port is operated as main or remote bridge.')
prtInMbeCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2), )
if mibBuilder.loadTexts: prtInMbeCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInMbeCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInMbeCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtInMbeCnfgIdx"), (0, "RAD-MIB", "prtInMbeSltIdx"), (0, "RAD-MIB", "prtInMbePrtIdx"))
if mibBuilder.loadTexts: prtInMbeCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInMbeCnfgEntry.setDescription('An entry in table.')
prtInMbeCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbeCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInMbeCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInMbeSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbeSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInMbeSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInMbePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbePrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInMbePrtIdx.setDescription('A unique port identifier within the card.')
prtInMbeConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeConnect.setStatus('current')
if mibBuilder.loadTexts: prtInMbeConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInMbeRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("r1x64eq64Kbps", 1), ("r2x64eq128Kbps", 2), ("r3x64eq192Kbps", 3), ("r4x64eq256Kbps", 4), ("r5x64eq320Kbps", 5), ("r6x64eq384Kbps", 6), ("r7x64eq448Kbps", 7), ("r8x64eq512Kbps", 8), ("r9x64eq576Kbps", 9), ("r10x64eq640Kbps", 10), ("r11x64eq704Kbps", 11), ("r12x64eq768Kbps", 12), ("r13x64eq832Kbps", 13), ("r14x64eq896Kbps", 14), ("r15x64eq960Kbps", 15), ("r16x64eq1024Kbps", 16), ("r17x64eq1088Kbps", 17), ("r18x64eq1152Kbps", 18), ("r19x64eq1216Kbps", 19), ("r20x64eq1280Kbps", 20), ("r21x64eq1344Kbps", 21), ("r22x64eq1408Kbps", 22), ("r23x64eq1472Kbps", 23), ("r24x64eq1536Kbps", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeRate.setStatus('current')
if mibBuilder.loadTexts: prtInMbeRate.setDescription('This attribute indicates the port speed.')
prtInMbeLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInMbeLinkTo.setDescription('It indicates the slot of the main link card to which the MBE card is mapped. In the ?004 Unit the entries io6(10)..io16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExTreCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1), )
if mibBuilder.loadTexts: prtExTreCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExTreCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExTreCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExTreCnfgIdx"), (0, "RAD-MIB", "prtExTreSltIdx"), (0, "RAD-MIB", "prtExTrePrtIdx"))
if mibBuilder.loadTexts: prtExTreCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExTreCnfgEntry.setDescription('An entry in table.')
prtExTreCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTreCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTreCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExTreSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTreSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTreSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExTrePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTrePrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExTrePrtIdx.setDescription('A unique port identifier within the card.')
prtExTreLan = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("remote", 1), ("main", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTreLan.setStatus('current')
if mibBuilder.loadTexts: prtExTreLan.setDescription('This attribute indicates whether the TRE port is operated as main or remote bridge. Default=remote.')
prtExTreLanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r4M", 1), ("r16M", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTreLanRate.setStatus('current')
if mibBuilder.loadTexts: prtExTreLanRate.setDescription('This attribute indicates the Rate of the TRE port in Mbit/sec. Default-r4M.')
prtInTreCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2), )
if mibBuilder.loadTexts: prtInTreCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInTreCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInTreCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtInTreCnfgIdx"), (0, "RAD-MIB", "prtInTreSltIdx"), (0, "RAD-MIB", "prtInTrePrtIdx"))
if mibBuilder.loadTexts: prtInTreCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInTreCnfgEntry.setDescription('An entry in table.')
prtInTreCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTreCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInTreCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInTreSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTreSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInTreSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInTrePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTrePrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInTrePrtIdx.setDescription('A unique port identifier within the card.')
prtInTreConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreConnect.setStatus('current')
if mibBuilder.loadTexts: prtInTreConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInTreRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreRate.setStatus('current')
if mibBuilder.loadTexts: prtInTreRate.setDescription('This attribute indicates the port speed.')
prtInTreLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInTreLinkTo.setDescription('It indicates the slot of the main link card to which the MBE card is mapped. In the ?004 Unit the entries io6(10)..io16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExPVc4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1), )
if mibBuilder.loadTexts: prtExPVc4CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPVc4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExPVc4CnfgIdx"), (0, "RAD-MIB", "prtExPVc4SltIdx"), (0, "RAD-MIB", "prtExPVc4PrtIdx"))
if mibBuilder.loadTexts: prtExPVc4CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CnfgEntry.setDescription('An entry in table.')
prtExPVc4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExPVc4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExPVc4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101, 102, 103, 104, 105, 106, 107, 108))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4PrtIdx.setDescription('This object indicates the port number in the selected card (slot).')
prtExPVc4PrtType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("eAndM", 1), ("fxo", 2), ("fxs", 3), ("internal", 4), ("s0", 5), ("u", 6), ("sQsig", 7), ("uQsig", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4PrtType.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4PrtType.setDescription('This object indicates the type of the selected port. In Mx 30/300 phase 4: s0 & u are for Voice over ISDN. In MX 30/300 phase 5: sQsig & uQsig are used for Voice over ISDN with Qsig option. In MX MVC4 voice cards, each pair of ports 1-2, 3-4 may have a different type: E&M, FXO, FXS. In MVC4 compressed voice cards ports 1..4 have the same interface for all ports. In MVC8 compressed voice cards each group of ports 1..4, 5..8 may have a different type: E&M, FXO, FXS.')
prtExPVc4Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Connect.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExPVc4IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 1), ("eAndM4wires", 2), ("eAndM2wires", 3), ("fxoGnd", 4), ("fxoLoop", 5), ("fxsGnd", 6), ("fxsLoop", 7), ("e1Framer", 8), ("e1Slave", 9), ("t1Framer", 10), ("t1Slave", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4IfType.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4IfType.setDescription('This attribute indicates the interface type of the port. eAndM4wires and eAndM2wires - are valid only for E&M port type eAndM4wires - means 2/4 wires fxoGnd and fxoLoop - are valid only for FXO port type fxsGnd and fxsLoop - are valid only for FXS port type e1Framer, e1Slave, t1Framer, t1Slave - are applicable for the mvc4Pbx cards only.')
prtExPVc4TxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4TxGain.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4TxGain.setDescription('Transmission gain in dB.')
prtExPVc4RxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4RxGain.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4RxGain.setDescription('Reception gain in dBm.')
prtExPVc4MaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("notConnected", 1), ("r4800bps", 2), ("r7200bps", 3), ("r9600bps", 4), ("notApplicatble", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MaxRate.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4MaxRate.setDescription('Voice rate.')
prtExPVc4Tc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t1sec", 1), ("t2sec", 2), ("t3sec", 3), ("t4sec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Tc.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4Tc.setDescription("Time interval for CIR control, in seconds. The value will be the same for all cards' ports.")
prtExPVc4Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Oos.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4Oos.setDescription('Handling type, when connection is lost.')
prtExPVc4EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4EchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4EchoCanceler.setDescription('Echo canceler activation.')
prtExPVc4VarDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4VarDelay.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4VarDelay.setDescription('Maximum variant delay of the FR network, in msec.')
prtExPVc4CongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4CongLevel.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CongLevel.setDescription('This object indicates the level of delayed data in precents of total available dynamic memory, for which the port will start to operate as congested. The resolution of the parameter is 5%.')
prtExPVc4Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Wire.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4Wire.setDescription('This object indicates the wiring of the E&M port. It is applicable only for E&M card type.')
prtExPVc4ExtensionType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("forceConnect", 2), ("voiceSwitching", 3), ("transparent", 4), ("transparentPlus", 5), ("ipForceConnect", 6), ("permanentDial", 7), ("autoAccept", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4ExtensionType.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4ExtensionType.setDescription('This object indicates the type of extension relevant for this port. ipForceConnect (6) is used for automatic connection or automatic dialing when the phone is off hook (hot line). permanentDial (7) means that the call is established upon power up. The hook may be on or off. Permanent Dialing can be used when there is no signaling. autoAccept (8) means that the called party in the Permanent Dialing will accept the call from the remote side automatically upon on or off hook.')
prtExPVc4ExtensionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4ExtensionNumber.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4ExtensionNumber.setDescription('This is the extension number of this port. This field is relevant only when the extension type is voice switching and is read only if the port is member of a hunt group.')
prtExPVc4OutPulsing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4OutPulsing.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4OutPulsing.setDescription('This field indicates whether to outpulse the received digits. It is notApplicable(1) when the extension type is forceConnect(2).')
prtExPVc4HuntGroupMb = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4HuntGroupMb.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4HuntGroupMb.setDescription('This object indicates if this port belongs to an hunt group.')
prtExPVc4HuntGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4HuntGroupIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4HuntGroupIdx.setDescription('If it belongs to an hunt group, this fields indicates the index of the relevant hunt group. 0 = notApplicable ')
prtExPVc4AutoFaxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4AutoFaxMode.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4AutoFaxMode.setDescription('This object indicates if the system will switch automatically to FAX mode when detecting FAX activity. Default=Yes.')
prtExPVc4FaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notConnected", 1), ("r4800bps", 2), ("r7200bps", 3), ("r9600bps", 4), ("r12000bps", 5), ("r14400bps", 6), ("r2400bps", 7), ("vbdFax", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4FaxRate.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4FaxRate.setDescription('FAX initial rate. Default=9600 bps.')
prtExPVc4SeizeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SeizeAck.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SeizeAck.setDescription("This parameter shows whether the device will acknowledge a seize signal (On/Off Hook). When the value is set to yes(3) & the device receives an on/off hook signal it will transmit back an on/off hook signal. When the value is set to no(2) & the device receives an on/off hook signal it will NOT transmit back an on/off hook signal. Example: If Seize Ack Parameter = YES, when the MVC.4 receives a seize signal (Off Hook) from the PBX it will send an Off Hook to the PBX. The Seize Parameter is relevant for all the following cards: MVC-4 MVC-4/E1-Framer MVC-4/T1-DSU-Framer MVC-4/T1-CSU-Framer MVC-4/E1-SLAVE MVC-4/T1-SLAVE Default values: Analog FXS - No (value can't be changed). Analog FXO - Yes (value can't be changed). Analog E&M - No (values NO/YES). Digital E1/T1 Framer & Slave - No.")
prtExPVc4SignalingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("delayStart", 2), ("immediateStart", 3), ("winkStart", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SignalingProtocol.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SignalingProtocol.setDescription('The signaling protocol that will be used between the PABX & the voice port. Delay Start Protocol: the line is seized by sending an Off hook signal and after a delay, if the called party is available (On hook) DTMF (Dual Tone Multi Frequency) digits are sent towards the called party. Immediate Start Protocol: the line is seized by sending an Off Hook signal and immediately DTMF digits are sent towards the called party. Wink start protocol: the line is seized by sending an Off Hook signal and then the called party sends a short Off Hook wink signal. Now the calling party starts sending DTMF digits.')
prtExPVc4DelayStart = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DelayStart.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DelayStart.setDescription('This parameter is used only for Delay Protocol. This is the time that the calling party will wait after sending an Off hook signal and before sending DTMF digits to the called party. The delay values are 100..5000 msec in intervals of 100 msec.')
prtExPVc4WinkMinDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4WinkMinDuration.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4WinkMinDuration.setDescription('This parameter is used only for Wink Protocol. Min Duration of the Wink Signal (off hook duration from the called party). Legal values: 40..400 msec in intervals of 10 msec.')
prtExPVc4WinkMaxDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4WinkMaxDuration.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4WinkMaxDuration.setDescription('This parameter is used only for Wink Protocol. Max Duration of the Wink Signal (off hook duration from the called party). Legal values: 40..400 msec in intervals of 10 msec.')
prtExPVc4GenerateTone = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4GenerateTone.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4GenerateTone.setDescription('This parameter indicates whether the device (MX or MPH) should generate dial tones for the channel. If the value is yes (3), it generates dial tones. If the value is no (2), the connected equipment will generate dial tones. For example for some ISDN sets the dial tone is generated by the phone itself while for others sets it is generated by the MX.')
prtExPVc4CodingLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aLAW", 1), ("uLAW", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4CodingLaw.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CodingLaw.setDescription('This attribute indicates the Method/Law for decoding/encoding the voice information. aLaw(1) is the standard Law for E1 links. uLaw(2) is the standard Law for T1 links. This object is equal for all the ports in the specific module because of HW limitations')
prtExPVc4GenerateRingBack = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4GenerateRingBack.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4GenerateRingBack.setDescription('Determines whether the Ring Back tone is generated locally or from the remote end. The default is - NO (Meaning coming from the remote end). Yes means that the Ring Back Tone is generated locally. Applicable only for Force Connect.')
prtExPVc4ChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4ChannelId.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4ChannelId.setDescription('Channel Identifier. According to FRF11 each voice port that works as force connect should add a CH Id after the DLCI in the frame header. Default : 1 Applicable only for Force Connect. Not Applicable value will be 0.')
prtExPVc4PortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("line", 2), ("trunk", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4PortConnection.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4PortConnection.setDescription("Port connection determines whether the port is connected to a PABX (Trunk) or to Telephone set (Line) . It determines whether to send certain messages to the port or not. If the type is LINE then the port generates a ring back tone , if TRUNK it doesn't (The PBX does it).")
prtExPVc4CoderAndRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34))).clone(namedValues=NamedValues(("notApplicable", 1), ("g7231r6300BPS", 2), ("g7231r5300BPS", 3), ("g729A8KBPS", 4), ("g711aLAW", 5), ("g711uLAW", 6), ("g726r16KBPS", 7), ("g726r24KBPS", 8), ("g726r32KBPS", 9), ("g726r40KBPS", 10), ("g727r16KBPS", 11), ("g727r24r16KBPS", 12), ("g727r24KBPS", 13), ("g727r16r32KBPS", 14), ("g727r32r24KBPS", 15), ("g727r32KBPS", 16), ("g727r40r16KBPS", 17), ("g727r40r24KBPS", 18), ("g727r40r32KBPS", 19), ("transparent", 20), ("netcoder6400BPS", 21), ("netcoder7200BPS", 22), ("netcoder8KBPS", 23), ("netcoder8800BPS", 24), ("netcoder9600BPS", 25), ("lowBitRateR2660BPS", 26), ("amr4750BPS", 27), ("amr5150BPS", 28), ("amr5900BPS", 29), ("amr6700BPS", 30), ("amr7400BPS", 31), ("amr7950BPS", 32), ("amr10200BPS", 33), ("amr12200BPS", 34)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4CoderAndRate.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4CoderAndRate.setDescription('Coder and Rate for the Voice Compression. In MPH: Relevant for MVC-8 card only.')
prtExPVc4DestinationNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 34), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DestinationNum.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DestinationNum.setDescription('The destination phone number: 0 to 22 digits. Applicable for Auto Dial - ipForceConnect(6), Permanent Dial and Auto Accept Extension Types. Default: Null String')
prtExPVc4DtmfRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DtmfRelay.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DtmfRelay.setDescription('When DTMF RELAY is disabled, the DTMF digits (dialed by the user) are transmitted as compressed voice and in the remote unit are decompressed. When DTMF RELAY is enabled, the DTMF digits are detected at the near side and not transmitted as voice. Instead, only an indication of what digits were dialed are transmitted and in the far end the tone is regenerated.')
prtExPVc4DiscOnSilence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DiscOnSilence.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DiscOnSilence.setDescription('No. of silenced seconds after which the call will be disconected. A value of 0 means that there will be no disconnect when there is silence. Possible values: 0 - 900 sec.')
prtExPVc4DynamicJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DynamicJitter.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DynamicJitter.setDescription('The MVC8 uses two mechanisms to overcome the network delay. The first one is a static jitter buffer which holds a constant buffer of up to 300 Msec and can be controled by the JITTER parameter (prtExPVc4VarDelay). The second one is the dynamic jitter which calculates, in real time, the network delay and handles a jitter buffer dynamically. The dynamic mechanism that is implemented in MVC8, was intended to overcome network delay yet when the network bursts, the MVC8 dynamic mechanism is not able to overcome the delay. Therefore it is better not to use the dynamic jitter (DISABLE - should be the default) where bursts may occur often.')
prtExPVc4EandMType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("type1", 2), ("type2", 3), ("type3", 4), ("ssdc5", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4EandMType.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4EandMType.setDescription('This is the signaling type on the E&M analog side. The analog signaling includes voltage, no. of pins and other parameters.')
prtExPVc4Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Rate.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4Rate.setDescription('This is the Rate of the port in TS units. It is used by VF-30 card family. 0 = NA = port is not intended to be connected; therefore, no Rate.')
prtExPVc4FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4FrameSize.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4FrameSize.setDescription('Defines the maximum size in Bytes of the multiplexed frame. In some cases this must be limited to avoid IP fragmentation, which makes the multiplexing useless, and can also decrease the damage in case of frame loss. Valid range: 100..1461. notApplicable=0.')
prtExPVc4MultiplexInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 41), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MultiplexInterval.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4MultiplexInterval.setDescription('Defines the maximum amout of time (msec.) between multiplexed frames that are sent. For Vmux-400/420 devices: It defines the Payload Packetizing Interval. Valid values: 10-90 msec. notApplicable=0.')
prtExPVc4TransportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("ptp", 2), ("aal2oMpls", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4TransportProtocol.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4TransportProtocol.setDescription('Transport Protocol. ptp = point to point. aal2oMpls = AAL2 over MPLS.')
prtExPVc4MultiFreqRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MultiFreqRelay.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4MultiFreqRelay.setDescription('This object enables/disables Multi Frequency Signaling Detection.')
prtExPVc4MinPulseWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 44), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MinPulseWidth.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4MinPulseWidth.setDescription('Defines the minimum Pulse Width in msec. Valid values: 45-100 msec. notApplicable=0.')
prtExPVc4MinPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MinPowerLevel.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4MinPowerLevel.setDescription('Defines the minimum Power Level in dBm. Valid values: -1..-35 dBm.')
prtExPVc4SuperTandem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SuperTandem.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SuperTandem.setDescription('The Super Tandem feature provides end to end compression over multiple hops, solving the double compression problem detected in Voice compressing systems. The Super Tandem, when enabled, allows transmission of compressed voice between a few devices and eliminates the need to decompress an recompress it over each voice card and PBX, thus improving voice quality and reducing delay.')
prtExPVc4DestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 47), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DestIp.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DestIp.setDescription('This object defines the destination IP Address.')
prtExPVc4DestBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DestBundle.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DestBundle.setDescription('This object defines the destination Bundle at the far-end device.')
prtExPVc4SrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 49), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SrcIpAddress.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SrcIpAddress.setDescription('This object defines the Source IP Address.')
prtExPVc4SrcIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 50), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SrcIpMask.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SrcIpMask.setDescription('This object defines the Source IP Mask.')
prtExPVc4DefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 51), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DefaultGateway.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DefaultGateway.setDescription('This object defines the Default Gateway for this interface.')
prtExPVc4SigPacketInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 52), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SigPacketInterval.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4SigPacketInterval.setDescription('Defines the Signaling Packetizing Interval, which is the maximum time interval, measured in msec (milliseconds), between multiplexed signaling frames.')
prtExPVc4DlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2), )
if mibBuilder.loadTexts: prtExPVc4DlciTable.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciTable.setDescription('The write operation into the Table Objects is valid only at the TmpCnfg entry.')
prtExPVc4DlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtExPVc4DlciCnfgIdx"), (0, "RAD-MIB", "prtExPVc4DlciSltIdx"), (0, "RAD-MIB", "prtExPVc4DlciPrtIdx"))
if mibBuilder.loadTexts: prtExPVc4DlciEntry.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciEntry.setDescription('An entry in table.')
prtExPVc4DlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPVc4DlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPVc4DlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciPrtIdx.setDescription('This attribute indicates a unique internal port number. VC4 cards have four external ports.')
prtExPVc4DlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciValid.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtExPVc4DlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConSlt.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPVc4DlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciIConPrt.setDescription('This attribute indicates a unique port id which the dlci is routed to.')
prtExPVc4DlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConDlci.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number, the dlci is routed to.')
prtExPVc4DlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14400bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciTxBc.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line (or at the port receive line).')
prtExPVc4DlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14400bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciTxBe.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line (or at the port receive line).')
prtExPVc4DlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14400bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciRxBc.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line (or at the port transmit line).')
prtExPVc4DlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14400bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciRxBe.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line (or at the port transmit line).')
prtExPVc4DlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciPriority.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciPriority.setDescription('This attribute indicates a unique priority of the pvc. 6 is the lowest priority and 8 is the highest priority.')
prtExPVc4DlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciStatus.setStatus('current')
if mibBuilder.loadTexts: prtExPVc4DlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtExLs6CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1), )
if mibBuilder.loadTexts: prtExLs6CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExLs6CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs6CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExLs6CnfgIdx"), (0, "RAD-MIB", "prtExLs6SltIdx"), (0, "RAD-MIB", "prtExLs6PrtIdx"))
if mibBuilder.loadTexts: prtExLs6CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExLs6CnfgEntry.setDescription('An entry in table.')
prtExLs6CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs6SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExLs6PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6PrtIdx.setDescription('This attribute indicates a unique port index.')
prtExLs6Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Connect.setStatus('current')
if mibBuilder.loadTexts: prtExLs6Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs6Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("sync", 2), ("async", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Protocol.setStatus('current')
if mibBuilder.loadTexts: prtExLs6Protocol.setDescription('This attribute indicates the protocol. async - can be selected only for ports 1-2.')
prtExLs6Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("r300bps", 2), ("r600bps", 3), ("r1200bps", 4), ("r2400bps", 5), ("r4800bps", 6), ("r7200bps", 7), ("r8000bps", 8), ("r9600bps", 9), ("r14400bps", 10), ("r16000bps", 11), ("r19200bps", 12), ("r24000bps", 13), ("r28800bps", 14), ("r32000bps", 15), ("r38400bps", 16), ("r48000bps", 17), ("r56000bps", 18), ("r57600bps", 19), ("r64000bps", 20)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Rate.setStatus('current')
if mibBuilder.loadTexts: prtExLs6Rate.setDescription('Port rates in bps. g1 - contains the values : (2)-(6),(9),(12),(16) g2 - contains the values : (7),(10),(14),(19) g3 - contains the values : (8),(11),(13),(15),(17),(18),(20); it is not applicable when using Async protocol. Rates of pair ports (1-2, 3-4, 5-6) must be from the same group.')
prtExLs6ClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("dte1", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6ClkMode.setStatus('current')
if mibBuilder.loadTexts: prtExLs6ClkMode.setDescription('This attribute indicates a unique port operation clock mode. It is applicable for Sync protocol only .')
prtExLs6CtrlSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("local", 2), ("rts", 3), ("dtrAndRts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6CtrlSignal.setStatus('current')
if mibBuilder.loadTexts: prtExLs6CtrlSignal.setDescription('Control Signal.')
prtExLs6DataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("d6bits", 1), ("d7bits", 2), ("d8bits", 3), ("d9bits", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6DataBits.setStatus('current')
if mibBuilder.loadTexts: prtExLs6DataBits.setDescription('Data Bits. This object is applicable for Async protocol only.')
prtExLs6Cts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Cts.setStatus('current')
if mibBuilder.loadTexts: prtExLs6Cts.setDescription('This object indicates the CTS control line operation mode.')
prtExLs6LinkToInternal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 255))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6LinkToInternal.setStatus('current')
if mibBuilder.loadTexts: prtExLs6LinkToInternal.setDescription('This object indicates which internal port of the card, the external port is linked to.')
prtExLs6VCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2), )
if mibBuilder.loadTexts: prtExLs6VCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs6VCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtExLs6VCnfgIdx"), (0, "RAD-MIB", "prtExLs6VSltIdx"), (0, "RAD-MIB", "prtExLs6VPrtIdx"))
if mibBuilder.loadTexts: prtExLs6VCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VCnfgEntry.setDescription('An entry in table.')
prtExLs6VCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs6VSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExLs6VPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("exPrt7", 7), ("exPrt8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExLs6VConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VConnect.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs6VRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("r6400bps", 2), ("r7200bps", 3), ("r8000bps", 4), ("r9600bps", 5), ("r16000bps", 6), ("r24000bps", 7), ("r32000bps", 8), ("r64000bps", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VRate.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VRate.setDescription('Rate (bps) used for FAX transmission and Voice coding.')
prtExLs6VEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VEchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VEchoCanceler.setDescription('Echo canceler activation.')
prtExLs6VIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VIfType.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VIfType.setDescription('This attribute indicates the interface type of the port. w4wire - is applicable only for E&M port type.')
prtExLs6VTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VTxGain.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VTxGain.setDescription('Transmit gain in dBm. E&M - values range: -17 .. 8 FXO - values range: -16 .. 4 FXS - values range: -13 .. 8 ')
prtExLs6VRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VRxGain.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VRxGain.setDescription('Receive gain in dBm. E&M - values range: -17 .. 2 FXO - values range: -17 .. -1 FXS - values range: -17 .. 2 ')
prtExLs6VOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VOos.setStatus('current')
if mibBuilder.loadTexts: prtExLs6VOos.setDescription('Out of Service signaling mode.')
prtInLs6CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3), )
if mibBuilder.loadTexts: prtInLs6CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInLs6CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInLs6CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtInLs6CnfgIdx"), (0, "RAD-MIB", "prtInLs6SltIdx"), (0, "RAD-MIB", "prtInLs6PrtIdx"))
if mibBuilder.loadTexts: prtInLs6CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInLs6CnfgEntry.setDescription('An entry in table.')
prtInLs6CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs6CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInLs6SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs6SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtInLs6PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInLs6PrtIdx.setDescription('This attribute indicates a unique internal port index.')
prtInLs6Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6Connect.setStatus('current')
if mibBuilder.loadTexts: prtInLs6Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the module considerations because the module has only one Internal interface which is the composite channel.')
prtInLs6TandemMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noTandem", 1), ("tandemMaster", 2), ("tandemSlave", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6TandemMode.setStatus('current')
if mibBuilder.loadTexts: prtInLs6TandemMode.setDescription("This object indicates the Tandem Mode. tandemSlave - is valid only for an LS-6 card having on the (current slot-1) an LS-6 card with 'tandemMaster' mode.")
prtInLs6Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("r32Kbps", 1), ("r56Kbps", 2), ("r64Kpbs", 3), ("r128Kbps", 4), ("r256Kbps", 5), ("r384Kbps", 6), ("r192Kbps", 7), ("r512Kbps", 8), ("r768Kbps", 9), ("r14400bps", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6Rate.setStatus('current')
if mibBuilder.loadTexts: prtInLs6Rate.setDescription('Main Rate in Kbps.')
prtInLs6RemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ls6", 1), ("km2kSlave", 2), ("km2kStandalone", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6RemoteType.setStatus('current')
if mibBuilder.loadTexts: prtInLs6RemoteType.setDescription('Remote Type. notApplicable - when prtInLs6TandemMode=tandemSlave ')
prtInLs6LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInLs6LinkTo.setDescription('It indicates the slot of the main link card to which the Ls6 card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - when prtInLs6TandemMode=tandemSlave. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort. ')
prtExVc3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1), )
if mibBuilder.loadTexts: prtExVc3CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExVc3CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExVc3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExVc3CnfgIdx"), (0, "RAD-MIB", "prtExVc3SltIdx"), (0, "RAD-MIB", "prtExVc3PrtIdx"))
if mibBuilder.loadTexts: prtExVc3CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExVc3CnfgEntry.setDescription('An entry in table.')
prtExVc3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVc3CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExVc3SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVc3SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVc3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVc3PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExVc3Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Connect.setStatus('current')
if mibBuilder.loadTexts: prtExVc3Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExVc3TransGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3TransGain.setStatus('current')
if mibBuilder.loadTexts: prtExVc3TransGain.setDescription('Transmit gain in dBm.')
prtExVc3ReceiveGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3ReceiveGain.setStatus('current')
if mibBuilder.loadTexts: prtExVc3ReceiveGain.setDescription('Receive gain in dBm.')
prtExVc3Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Wire.setStatus('current')
if mibBuilder.loadTexts: prtExVc3Wire.setDescription('This object is equal for all the ports in the specific card because of HW limitations')
prtExVc3Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r9600bps", 1), ("r4800bps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Rate.setStatus('current')
if mibBuilder.loadTexts: prtExVc3Rate.setDescription('Rate in bps.')
prtExVc3EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3EchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtExVc3EchoCanceler.setDescription("Echo canceler activation. The value will be the same for all the card's external ports.")
prtInVc3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2), )
if mibBuilder.loadTexts: prtInVc3CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtInVc3CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInVc3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtInVc3CnfgIdx"), (0, "RAD-MIB", "prtInVc3SltIdx"), (0, "RAD-MIB", "prtInVc3PrtIdx"))
if mibBuilder.loadTexts: prtInVc3CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtInVc3CnfgEntry.setDescription('An entry in table.')
prtInVc3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtInVc3CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInVc3SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtInVc3SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtInVc3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtInVc3PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtInVc3Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Connect.setStatus('current')
if mibBuilder.loadTexts: prtInVc3Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInVc3Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r32000bps", 1), ("r16000bps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Rate.setStatus('current')
if mibBuilder.loadTexts: prtInVc3Rate.setDescription('Rate in bps.')
prtInVc3Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Oos.setStatus('current')
if mibBuilder.loadTexts: prtInVc3Oos.setDescription(' This object is equal for all the ports in the specific card because of HW limitations')
prtInVc3LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInVc3LinkTo.setDescription('This attribute indicates the slot of the ML card to which the VC card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1), )
if mibBuilder.loadTexts: prtExVcPbxCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExVcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtExVcPbxCnfgIdx"), (0, "RAD-MIB", "prtExVcPbxSltIdx"), (0, "RAD-MIB", "prtExVcPbxPrtIdx"))
if mibBuilder.loadTexts: prtExVcPbxCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxCnfgEntry.setDescription('An entry in table.')
prtExVcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExVcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExVcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxConnect.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtExVcPbxGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxGroup.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxGroup.setDescription('The group object links together several VC-PBX cards, concerning compression of the same input T1/E1 link time-slots. When ports of different slots have the same group, they are linked. When ports have a different group, they are not linked. For VC-PBX/T1 and E1 cards, this object is - their own IO Slot. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxTransparent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTransparent.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTransparent.setDescription('This object indicates whether the Transparent transfer of Time-Slots is required or not. Time-Slots transferred by Transparent, will not be compressed. no - applicable only for VC-PBX/T1 and VC-PBX/E1 cards yes - applicable only for VC-PBX/T1 and VC-PBX/E1 cards notApplicable - only for VC-PBX cards.')
prtExVcPbxTransSignalTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTransSignalTs.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTransSignalTs.setDescription("This object specifies the ML Time-Slot dedicated to the signaling of the PABX Transparent TSs. None = 255. When prtExVcPbxTransparent=no this object's value=None (255) When prtExVcPbxTransparent=notApplicable, this object's value=None (255). When prtExVcPbxTransparent=yes: - for VC-PBX/T1 ports, this object's valid values are 1..16 or None (255). - for VC-PBX/E1 ports, this object's value will be 16 or None (255).")
prtExVcPbxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxFrame.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxFrame.setDescription('This object is the frame parameter for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 values for the VC-PBX/T1 card. E1 values for the VC-PBX/E1 card. notApplicable - for the VC-PBX card. This parameter has the same values as dsx1LineType in T1/E1 MIB (RFC-1406). The parameters in dsx1LineType are: other (1) esfT1 dsx1ESF (2) sfT1 dsx1D4 (3) g732nE1 dsx1E1 (4) g732nE1CRC dsx1E1-CRC (5) g732sE1 dsx1E1-MF (6) g732sE1CRC dsx1E1-MF-CRC (7) ')
prtExVcPbxRestoreTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 255))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxRestoreTime.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxRestoreTime.setDescription('The time passing from the disappearance of the loss of synchronization condition (red alarm) to the restoration of normal service. The options 1secFast(2) and 10sec62411(3) for E1 interfaces are proprietary implementation of the T1 standard to the E1 interface. ccittE1 - is applicable only for VC-PBX/E1 card notApplicable - is applicable for VC-PBX card')
prtExVcPbxLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("b7zsT1", 1), ("b8zsT1", 2), ("transT1", 3), ("hdb3E1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLineCode.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxLineCode.setDescription('This object is the line code parameter used for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 line code parameters for VC-PBX/T1 E1 line code parameters for VC-PBX/E1 notApplicable - for VC-PBX This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExVcPbxLineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLineLength.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxLineLength.setDescription('This object is the line length parameter. It is applicable only for the VC-PBX/T1 card. notApplicable - for the VC-PBX and VC-PBX/E1 card. lenXXXpXXXft = len-XXX-XXXft.')
prtExVcPbxLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExVcPbxLinkTo.setDescription('This object indicates the slot of the ML card to which the VC-PBX/T1, VC-PBX/E1 card Transparent TSs are mapped. notApplicable - for VC-PBX card AND for VC-PBX/T1, VC-PBX/E1 cards, when prtExVcPbxTransparent=no . In the ?004 Unit the entries io6(10)..io12(16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxSignalOper = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("bEqA", 3), ("inverseA", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxSignalOper.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxSignalOper.setDescription('This object indicates the Signaling Operation of the VC-PBX/T1, VC-PBX/E1 external port. notApplicable - for VC-PBX card normal - all 4 signaling bits are transferred. bEqA - copy the A bit into the B bit. Applicable only for VC-PBX/T1.')
prtExVcPbxIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("notApplicable", 1), ("hff", 2), ("he4", 3), ("hd5", 4), ("h9e", 5), ("h98", 6), ("h7f", 7), ("h7e", 8), ("h54", 9), ("h1a", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxIdleCode.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxIdleCode.setDescription('Determines the code for transmission in empty time slots. notApplicable - for VC-PBX card .')
prtIn1p6VcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2), )
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtIn1p6VcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtIn1p6VcPbxCnfgIdx"), (0, "RAD-MIB", "prtIn1p6VcPbxSltIdx"), (0, "RAD-MIB", "prtIn1p6VcPbxPrtIdx"))
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgEntry.setDescription('An entry in table.')
prtIn1p6VcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtIn1p6VcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtIn1p6VcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 103, 104, 105, 106))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtIn1p6VcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxConnect.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtIn1p6VcPbxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("r4800bps", 1), ("r6400bps", 2), ("r7200bps", 3), ("r8000bps", 4), ("r9600bps", 5), ("r12800bps", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxRate.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxRate.setDescription('This object indicates the port Rate. For Normal mode (prtIn7p8VcPbxMode=normal), only part of the values are valid (constant rate). For Server mode (prtIn7p8VcPbxMode=server), all values are applicable (user can select the desired compression rate). ')
prtIn1p6VcPbxEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxEchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxEchoCanceler.setDescription('Echo canceler activation.')
prtIn1p6VcPbxPabxTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxPabxTs.setStatus('current')
if mibBuilder.loadTexts: prtIn1p6VcPbxPabxTs.setDescription('This object defines the PABX Time-Slot assigned to this internal port. For a T1 link, the valid values are: 1 .. 24. For an E1 link, the valid values are: 1 .. 31. This object is NOT applicable when prtIn1p6VcPbxConnect=no. This object is applicable for all cards of VC-PBX family. Default=the internal port index (1..6).')
prtIn7p8VcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3), )
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtIn7p8VcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtIn7p8VcPbxCnfgIdx"), (0, "RAD-MIB", "prtIn7p8VcPbxSltIdx"), (0, "RAD-MIB", "prtIn7p8VcPbxPrtIdx"))
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgEntry.setDescription('An entry in table.')
prtIn7p8VcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtIn7p8VcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtIn7p8VcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(107, 108))).clone(namedValues=NamedValues(("inPrt7", 107), ("inPrt8", 108)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtIn7p8VcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxConnect.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtIn7p8VcPbxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("server", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxMode.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxMode.setDescription('This object indicates the working mode of the port: - normal - the compressed voice will be sent to an MTML card inside the Mux. - server - the compressed voice will be sent to the Digital Voice connector, as a service to an outside user.')
prtIn7p8VcPbxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("r32Kbps", 1), ("r16Kbps", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxRate.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxRate.setDescription('This object indicates the port Main Rate. For Server mode (prtIn7p8VcPbxMode=server), the value will be notApplicable. ')
prtIn7p8VcPbxSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("aBit", 2), ("abcBit", 3), ("abcdBit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxSignalMode.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxSignalMode.setDescription('This object indicates the Signal Mode. For Server mode (prtIn7p8VcPbxMode=server), the only valid values are: - none - aBit ')
prtIn7p8VcPbxOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxOos.setStatus('current')
if mibBuilder.loadTexts: prtIn7p8VcPbxOos.setDescription(' Out of service Signaling mode.')
prtIn7p8VcPbxLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtIn7p8VcPbxLinkTo.setDescription('This object indicates the slot of the ML card to which the VC card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For Server mode (prtIn7p8VcPbxMode=server), this object is not applicable. Both ports, 7 and 8 should be linked to the same Slot. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4), )
if mibBuilder.loadTexts: prtExVcPbxTsTable.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtExVcPbxTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1), ).setIndexNames((0, "RAD-MIB", "prtExVcPbxTsCnfgIdx"), (0, "RAD-MIB", "prtExVcPbxTsSltIdx"), (0, "RAD-MIB", "prtExVcPbxTsPrtIdx"), (0, "RAD-MIB", "prtExVcPbxTsIdx"))
if mibBuilder.loadTexts: prtExVcPbxTsEntry.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsEntry.setDescription('An entry in table.')
prtExVcPbxTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExVcPbxTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExVcPbxTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 109, 110))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("inPrt9", 109), ("inPrt10", 110)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsPrtIdx.setDescription('This attribute indicates a unique port number. VCPBX/E1, VCPBX/T1, VFPBX/E1, VFPBX/T1, VF-24/T1 and VF-30 cards have only one external interface. VF-48/T1 and VF-60/E1 cards have two external interfaces. VFS cards have also internal ports.')
prtExVcPbxTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsIdx.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsIdx.setDescription('This attribute indicates a unique PABX time slot position. The valid time slots are 1..24 for T1 cards and 1..31 for E1 cards.')
prtExVcPbxTsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 11, 12, 13, 14, 15, 16, 17, 18, 41, 42, 43, 44, 45, 46, 47, 48))).clone(namedValues=NamedValues(("unused", 1), ("compressed", 2), ("transparent", 3), ("compressedCcs", 4), ("mng", 5), ("ccs1", 11), ("ccs2", 12), ("ccs3", 13), ("ccs4", 14), ("ccs5", 15), ("ccs6", 16), ("ccs7", 17), ("ccs8", 18), ("ss7n1", 41), ("ss7n2", 42), ("ss7n3", 43), ("ss7n4", 44), ("ss7n5", 45), ("ss7n6", 46), ("ss7n7", 47), ("ss7n8", 48)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsMode.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsMode.setDescription("This attribute indicates the usage, process and way of the specific PABX TS towards its destination: unused - the TS is not used (no processing, no destination). compressed - the TS is used, sent for compression to an internal port (for VF-PBX cards: 1..6 for of either the same card or a VF-PBX card of the same group). For VF-24/30/48/60 - 'compressed' represents 'compressed Voice' (to differentiate it from 'compressedCcs'). In this case, the TS is compressed by an internal port (1..8). transparent - the TS is used; no processing. It is sent directly for Bypass to a ML card the VF port/TS is linked to. compressedCcs - supported only by VF-24/30/48/60 cards. The TS is used; sent for compression to the CPU. mng - the TS is used for Management (this option is used when the external port is connected to another product that has to be managed via this dedicated TS. ccs1..ccs8 - supported only by VF-24/30/48/60 cards. Compressed TS that comes from a bundle of V5.1 or V5.2 PBX. ss7n1..ss7n8 - supported only by VF-24/30/48/60 cards. Compressed TS that comes from a bundle of V5.1 or V5.2 PBX. ss7n1 can work versus Vmux having prtExPh1MlTsType=ss7(6).")
prtExVcPbxTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsIConSlot.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsIConSlot.setDescription('For VF-PBX cards, the io1..io12 values are applicable only when prtExVcPbxTsMode=compressed. Otherwise, its value should be noConnect. For VF-24/30/48/60 cards: - when prtExVcPbxTsMode=transparent or voiceTransparent, the io1..io12 values are applicable, indicating the ML Slot this TS is connected to. - when prtExVcPbxTsMode=compressed or compressedCcs, the value will be the same as prtExVcPbxTsSltIdx, since the compression is done within the same card. - for rest of the prtExVcPbxTsMode values, the value will be: noConnect. This object indicates whether the specified compressed/transparent time slot is connected/routed internally in the Agent and to which card it is connected. For VF-PBX card, the valid selectable slots are either the current one, (prtExVcPbxTsSltIdx), or a slot containing a VF-PBX card. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 100, 101, 102, 103, 104, 105, 106, 107, 108))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsIConPrt.setDescription('This attribute indicates the port to which this TS is connected. For VF-PBX cards, only inPrt1..inPrt6 ports are valid. For VF-24/30/48/60 cards: - for prtExVcPbxTsMode=transparent or voiceTransparent, the valid ports are ML ports (exPrt1.. exPrt8, inPrt1.. inPrt8) - for prtExVcPbxTsMode=compressed or compressedCcs, the valid ports are internal ports of the same card (inPrt1..inPrt8) noConnect - when prtExVcPbxTsIConSlot=noConnect.')
prtExVcPbxTsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsIConTs.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsIConTs.setDescription('This attribute indicates the ML TS to which this TS is connected. This object is not applicable for VF-PBX cards. For VF-24/30/48/60 cards it is applicable only when prtExVcPbxTsMode=transparent or voiceTransparent. The valid time slots are 1..24 for ML T1 cards and 1..31 for ML E1 cards. notApplicable - 255. ')
prtExVcPbxTsRemPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 100))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("noConnect", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsRemPrt.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsRemPrt.setDescription('This attribute indicates the end-point port on the Remote unit. VF-24/T1 and VF-30/E1 cards have one external interface. VF-48/T1 and VF-60/E1 cards have two external interfaces. noConnect - when prtExVcPbxTsMode=unused, transparent, voiceTransparent or mng.')
prtExVcPbxTsRemTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsRemTs.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsRemTs.setDescription('This attribute indicates the end-point TS on the Remote unit. The valid time slots are 1..24 for T1 ports and 1..31 for E1 ports. notApplicable - 255.')
prtExVcPbxTsRemConnID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsRemConnID.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsRemConnID.setDescription('This attribute indicates the Connection ID with the Remote unit. notApplicable = 0.')
prtExVcPbxTsSourceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsSourceSlot.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsSourceSlot.setDescription('For VFS cards. These cards offer Compresed Voice Services for Analog Voice ports of the MP. This object indicates the Source Slot of the Analog Voice port we want to compress. io1..io12 values are applicable only when prtExVcPbxTsMode=compressed(voice). Otherwise, its value should be noConnect. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxTsSourcePrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 13), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsSourcePrt.setStatus('current')
if mibBuilder.loadTexts: prtExVcPbxTsSourcePrt.setDescription('For VFS cards. These cards offer Compresed Voice Services for Analog Voice ports of the MP. This object indicates the Source Port within the Slot of the Analog Voice Card, we want to compress. exPrt1 - exPrt16 = 1 - 16 noConnect=100 - when prtExVcPbxTsCvServiceSlot=noConnect.')
prtIsdnCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1), )
if mibBuilder.loadTexts: prtIsdnCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtIsdnCnfgTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtIsdnCnfgIdx"), (0, "RAD-MIB", "prtIsdnSltIdx"), (0, "RAD-MIB", "prtIsdnPrtIdx"))
if mibBuilder.loadTexts: prtIsdnCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtIsdnCnfgEntry.setDescription('An entry in table.')
prtIsdnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnSltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnPrtIdx.setDescription('This attribute indicates a unique port number. For MAXcess the values will be: exPrt1(1), exPrt2(2), exPrt3(3), exPrt4(4), For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnConnect.setStatus('current')
if mibBuilder.loadTexts: prtIsdnConnect.setDescription('This attribute indicates if the port is connected.')
prtIsdnSignalingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 7, 9, 10, 17, 18, 21, 255))).clone(namedValues=NamedValues(("other", 1), ("etsi", 3), ("ess4", 5), ("ess5", 6), ("dms100", 7), ("ni1", 9), ("ni2", 10), ("ins64", 17), ("ins1500", 18), ("qsig", 21), ("notApplicable", 255))).clone('etsi')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSignalingProtocol.setStatus('current')
if mibBuilder.loadTexts: prtIsdnSignalingProtocol.setDescription('This attribute fixes which signaling protocol is used at this port (D-Channel). It is equivalent to isdnSignalingProtocol in the isdn MIB.')
prtIsdnBasicRateLineTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("pointToPoint", 1), ("pointToMultipoint", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnBasicRateLineTopology.setStatus('current')
if mibBuilder.loadTexts: prtIsdnBasicRateLineTopology.setDescription('This attribute is relevant for ISDN BRI only. It is equivalent to isdnBasicRateLineTopology in the isdn MIB.')
prtIsdnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dialup", 1), ("leased", 2), ("syncLeased", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnMode.setStatus('current')
if mibBuilder.loadTexts: prtIsdnMode.setDescription('This attribute allows the user to configure the port as leased(2) in case of connection to a TDM network.')
prtIsdnFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("answerAll", 2), ("rejectAll", 3), ("selective", 4), ("callBack", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnFilter.setStatus('current')
if mibBuilder.loadTexts: prtIsdnFilter.setDescription('This attribute allows the user to configure the port: answerAll(2): accept all incoming calls, rejectAll(3): reject all incoming calls, selective(4): accept or reject according directory table. callBack (5): In this mode the ISDN Ch will reject incoming calls and will initiate call back to the rejected phone number.')
prtIsdnSimultaneousCall = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("accept", 2), ("reject", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSimultaneousCall.setStatus('current')
if mibBuilder.loadTexts: prtIsdnSimultaneousCall.setDescription('In case of simultaneous call (local,remote and remote,local): accept(2): accept the incoming call, reject(3): reject the incoming call.')
prtIsdnNumOfAbstractTerm = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnNumOfAbstractTerm.setStatus('current')
if mibBuilder.loadTexts: prtIsdnNumOfAbstractTerm.setDescription('An object for KM2100/4 agents. 255=Not Applicable When ISDN Standard = ETSI or NTT (European) the value should be 255 (NotApplicable) else If ML speed is 64Kbps value should be 1. If ML speed is 128Kbps value can be either 1 or 2 (user selection).')
prtIsdnSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("auto", 2), ("manual", 3), ("connect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSwitchMode.setStatus('current')
if mibBuilder.loadTexts: prtIsdnSwitchMode.setDescription("For KM2100. auto - The call is initiated automatically by one of the IO cards connected to KML.10(ISDN card) having ISDN Switch Mode. manual - The call is initiated by the user manually, for KML.10 having ISDN Switch Mode (via mdlSCmd). connect- The call is initiated 'immediately', for KML.10 having ISDN Switch Mode. 'immediately'- means: immediately after power-up (when product performed Reset) OR, since this value appears in the active configuration. In this case, the call can be disconnected only by power-off of the product or by changing this object to another value (or actual Remove of the KML.10 relevant card). notApplicable - For other card types.")
prtIsdnAbSide = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("aSide", 2), ("bSide", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnAbSide.setStatus('current')
if mibBuilder.loadTexts: prtIsdnAbSide.setDescription('This parameter indicates the QSIG side in layer 3. This definition is from the QSIG Standard.')
prtIsdnQsigRole = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("slave", 2), ("master", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnQsigRole.setStatus('current')
if mibBuilder.loadTexts: prtIsdnQsigRole.setDescription('This parameter indicates the QSIG side in layer 1 & 2.')
prtIsdnInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("lt", 1), ("nt", 2), ("te", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnInterface.setStatus('current')
if mibBuilder.loadTexts: prtIsdnInterface.setDescription('It indicates the interface type: lt = line termination nt = network termination te = terminal equipment.')
prtIsdnCallMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("initiate", 2), ("listen", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnCallMode.setStatus('current')
if mibBuilder.loadTexts: prtIsdnCallMode.setDescription('This object indicates the acceptance of incoming calls. Initiate - Callout Listen - Callin. ')
prtIsdnCallBackTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnCallBackTimeout.setStatus('current')
if mibBuilder.loadTexts: prtIsdnCallBackTimeout.setDescription("This object is applicable only if 'prtIsdnFilter' is 'CallBack' and determines how long to wait from receiving the incoming call until initiating the call back call. The vaules range should be '1..20 sec' and the default 10 sec.")
prtIsdnEndpointTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2), )
if mibBuilder.loadTexts: prtIsdnEndpointTable.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnEndpointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtIsdnEndpointCnfgIdx"), (0, "RAD-MIB", "prtIsdnEndpointSltIdx"), (0, "RAD-MIB", "prtIsdnEndpointPrtIdx"), (0, "RAD-MIB", "prtIsdnEndpointIdx"))
if mibBuilder.loadTexts: prtIsdnEndpointEntry.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointEntry.setDescription('An entry in table.')
prtIsdnEndpointCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnEndpointSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointSltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. In ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnEndpointPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointPrtIdx.setDescription('This attribute indicates a unique port number. For MAXcess the values will be: exPrt1(1), exPrt2(2), exPrt3(3), exPrt4(4), For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnEndpointIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("atei1", 1), ("atei2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointIdx.setDescription('Since more than one endpoint may be defined per isdn entity, this field is a simple index. It corresponds to isdnEndpointIdx in the isdn MIB.')
prtIsdnEndpointTeiType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2), ("notApplicable", 255)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnEndpointTeiType.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointTeiType.setDescription('The type of TEI (Terminal Endpoint Identifier) used for this Terminal Endpoint. In case of dynamic(1), the TEI value is selected by the switch. In case of static(2), a valid TEI value has to be entered in the isdnEndpointTeiValue object. interface type as well as the Terminal Endpoint type. static(2). On Basic Rate interfaces the default value is dynamic(1) for isdn(63) Terminal Endpoints. It corresponds to isdnEndpointTeiType in the isdn MIB.')
prtIsdnEndpointTeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnEndpointTeiValue.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointTeiValue.setDescription('When the TEI Type is static, the value of the TEI should be between 0 and 63. Else, it is not selectable by user. 255 = notApplicable. It corresponds to isdnEndpointTeiValue in the isdn MIB')
prtIsdnEndpointSpid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 7), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnEndpointSpid.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointSpid.setDescription('The Service profile IDentifier (SPID) information for this Terminal Endpoint. It is is composed of 9-20 numeric characters. It corresponds to isdnEndpointSpid in the isdn MIB.')
prtIsdnEndpointBearerCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("anyChannel", 2), ("channelB1", 3), ("channelB2", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnEndpointBearerCh.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointBearerCh.setDescription('This is the selected dialing channel. anyChannel - the system selects the dialing channel.')
prtIsdnEndpointRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnEndpointRowStatus.setStatus('current')
if mibBuilder.loadTexts: prtIsdnEndpointRowStatus.setDescription('This field indicates whether to consider this endpoint or not. The only possible supported RowStatus vaules are active (1) and destroy (6).')
prtIsdnDirectoryTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3), )
if mibBuilder.loadTexts: prtIsdnDirectoryTable.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnDirectoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtIsdnDirectoryCnfgIdx"), (0, "RAD-MIB", "prtIsdnDirectorySltIdx"), (0, "RAD-MIB", "prtIsdnDirectoryPrtIdx"))
if mibBuilder.loadTexts: prtIsdnDirectoryEntry.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryEntry.setDescription('An entry in table.')
prtIsdnDirectoryCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectoryCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnDirectorySltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectorySltIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectorySltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. For MX300/30 ports: io1(5) = isdn1(5) and io2(6) = isdn2(6). In ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnDirectoryPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectoryPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryPrtIdx.setDescription('For MAXcess this is the internal port number: 101, 102,.... For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnDirectoryLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr.setDescription('This is the local address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters) ')
prtIsdnDirectoryLocalSubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr.setDescription('This is the local subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr.setDescription('This is the remote address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters)')
prtIsdnDirectoryRemoteSubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr.setDescription('This is the remote subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryPrtNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 8), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryPrtNu.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryPrtNu.setDescription('This is the external port number connected to this entry.')
prtIsdnDirectoryTeiId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 9), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryTeiId.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryTeiId.setDescription('This is the abstract terminal id if relevant, connected to this entry.')
prtIsdnDirectoryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryRowStatus.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryRowStatus.setDescription('This is the status for the row. It allows to know whether to consider this row or not. The only possible supported RowStatus vaules are active (1) and destroy (6).')
prtIsdnDirectoryLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr2.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr2.setDescription('This is the second local address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters)')
prtIsdnDirectoryLocalSubAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr2.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr2.setDescription('This is the second local subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr2.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr2.setDescription('This is the second remote address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank(20 characters) ')
prtIsdnDirectoryRemoteSubAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr2.setStatus('current')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr2.setDescription('This is the second remote subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters) ')
prtFrPlusCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1), )
if mibBuilder.loadTexts: prtFrPlusCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtFrPlusCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtFrPlusCnfgIdx"), (0, "RAD-MIB", "prtFrPlusSltIdx"), (0, "RAD-MIB", "prtFrPlusPrtIdx"))
if mibBuilder.loadTexts: prtFrPlusCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusCnfgEntry.setDescription('An entry in table.')
prtFrPlusCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtFrPlusSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusSltIdx.setDescription('Slot Index. For ISDN BRI Ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
prtFrPlusPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be: - for ISDN cards: inPrt1(101)->inPrt50(150) - for MHS1 card : exPrt1(1) - for MHS3, MLS3 cards: exPrt1(1)->exPrt3(3) - for MLS6 cards: exPrt1(1)->exPrt6(6).')
prtFrPlusNotSegmentedPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtFrPlusNotSegmentedPriorities.setStatus('current')
if mibBuilder.loadTexts: prtFrPlusNotSegmentedPriorities.setDescription("This parameter is relevant only for FR+ protocol and asks the MXcess NOT to segment data with specified priorities: from LSB: bit 1 is for priority 1, bit 2 is for priority 2, .... till bit 7 for priority 7. - a priority selected to be segmented : its bit will be '0' - a priority not to be segmented : its bit will be '1' Default is 00000000; i.e, segment all priorities.")
prtMl4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1), )
if mibBuilder.loadTexts: prtMl4CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtMl4CnfgTable.setDescription('This is an extension table for MTML-4 card parameters.')
prtMl4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtMl4CnfgIdx"), (0, "RAD-MIB", "prtMl4SltIdx"), (0, "RAD-MIB", "prtMl4PrtIdx"))
if mibBuilder.loadTexts: prtMl4CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtMl4CnfgEntry.setDescription('An entry in table.')
prtMl4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtMl4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtMl4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtMl4SltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
prtMl4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112), ("inPrt13", 113), ("inPrt14", 114), ("inPrt15", 115), ("inPrt16", 116), ("inPrt17", 117), ("inPrt18", 118), ("inPrt19", 119), ("inPrt20", 120), ("inPrt21", 121), ("inPrt22", 122), ("inPrt23", 123), ("inPrt24", 124), ("inPrt25", 125), ("inPrt26", 126), ("inPrt27", 127), ("inPrt28", 128), ("inPrt29", 129), ("inPrt30", 130), ("inPrt31", 131), ("inPrt32", 132), ("inPrt33", 133), ("inPrt34", 134), ("inPrt35", 135), ("inPrt36", 136), ("inPrt37", 137), ("inPrt38", 138), ("inPrt39", 139), ("inPrt40", 140), ("inPrt41", 141), ("inPrt42", 142), ("inPrt43", 143), ("inPrt44", 144), ("inPrt45", 145), ("inPrt46", 146), ("inPrt47", 147), ("inPrt48", 148), ("inPrt49", 149), ("inPrt50", 150), ("inPrt51", 151), ("inPrt52", 152), ("inPrt53", 153), ("inPrt54", 154), ("inPrt55", 155), ("inPrt56", 156), ("inPrt57", 157), ("inPrt58", 158), ("inPrt59", 159), ("inPrt60", 160), ("inPrt61", 161), ("inPrt62", 162), ("inPrt63", 163), ("inPrt64", 164), ("inPrt65", 165), ("inPrt66", 166), ("inPrt67", 167), ("inPrt68", 168), ("inPrt69", 169), ("inPrt70", 170), ("inPrt71", 171), ("inPrt72", 172), ("inPrt73", 173), ("inPrt74", 174), ("inPrt75", 175), ("inPrt76", 176), ("inPrt77", 177), ("inPrt78", 178), ("inPrt79", 179), ("inPrt80", 180), ("inPrt81", 181), ("inPrt82", 182), ("inPrt83", 183), ("inPrt84", 184)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtMl4PrtIdx.setDescription('This attribute indicates a unique port number.')
prtMl4SigProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("p1", 3), ("p2", 4), ("p3", 5), ("p4", 6), ("p5", 7), ("perTS", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4SigProfile.setStatus('current')
if mibBuilder.loadTexts: prtMl4SigProfile.setDescription('This object indicates the Signaling Profile of the port. none - when the Frame is G732N (no MF) or Unframed. p1 = profile 1 p2 = profile 2 p3 = profile 3 p4 = profile 4 p5 = profile 5 perTS = when Signaling Profile is selected per TS.')
prtMl4CGA = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("trans", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4CGA.setStatus('current')
if mibBuilder.loadTexts: prtMl4CGA.setDescription("This object selects the method used to signal the CGA state to the other end, through the main link. 'none' - non-transparent mode. When one of the links (main) will be in Out Of Service state, both 'Data/Voice Oos' and 'Oos' will be transmitted to the other end. 'trans' - when one of the links (main) will be in Out Of Service state, 'Data/Voice Oos' will be transmitted to the other end. 'full' - fully-transparent mode. When one of the links (main) will be in Out Of Service state, neither 'Data/Voice Oos' nor 'Oos' will be transmitted to the other end.")
prtMl4Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4Oos.setStatus('current')
if mibBuilder.loadTexts: prtMl4Oos.setDescription("'idle' = '0' = on-hook, idle state 'busy' = '1' = off-hook, busy state 'forcedIdle' = SP = both A and B signaling bits are forced to '0' during out-of-service periods. 'forcedBusy' = MK = both A and B signaling bits are forced to '1' during out-of-service periods. 'busyIdle' = MK_SP = A and B bits are forced to '1' for 2.5 seconds; then they are switched to '0' until out-of-service condition disappears. 'idleBusy' = SP_MK = A and B bits are forced to '0' for 2.5 seconds; then they are switched to '1' until out-of-service condition disappears. - for T1: '0'=0 ; '1'=1 - for E1: '0'=1 ; '1'=0 ")
prtMl4VoiceOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4VoiceOos.setStatus('current')
if mibBuilder.loadTexts: prtMl4VoiceOos.setDescription('Voice Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtMl4DataOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4DataOos.setStatus('current')
if mibBuilder.loadTexts: prtMl4DataOos.setDescription('Data Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtMl4Service = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("leasedLine", 2), ("v51", 3), ("v52Master", 4), ("v52Slave", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4Service.setStatus('current')
if mibBuilder.loadTexts: prtMl4Service.setDescription('Link Service. leasedLine - usual TDM interface. v51 - V5.1 interface. v52Master - V5.2 Link to Local Exchange. v52Slave - a ML that is transferred to the v52Master.')
prtMl4IpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4IpAddress.setStatus('current')
if mibBuilder.loadTexts: prtMl4IpAddress.setDescription('IP Address of the port.')
prtMl4IpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4IpMask.setStatus('current')
if mibBuilder.loadTexts: prtMl4IpMask.setDescription('IP subnet mask of the port.')
prtMl4SignalingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("cas", 2), ("ccs", 3), ("robbedBit", 4), ("other", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4SignalingMode.setStatus('current')
if mibBuilder.loadTexts: prtMl4SignalingMode.setDescription('Refers to the signaling mode of the port (or framer module). notApplicable(1)- means that no framer is needed for this port (no signaling), or that this object is not relevant. cas(2) means Channel Associated Signaling. Used for E1 Links. ccs(3) is the Common Channel Signaling (the signaling is not within the channels time slot - a TS for signaling is used). robbedBit(4) is a method implementing 7 bits for the voice and 1 bit dedicated for signaling. Used for T1 Links. other (5)- Signaling generally exists though not specifically according to one of the values listed ; this port uses a framer in this case.')
prtMl4EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4EchoCanceler.setStatus('current')
if mibBuilder.loadTexts: prtMl4EchoCanceler.setDescription('Echo canceler activation.')
prtMl4OosErrorSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("framing", 3), ("bpv", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4OosErrorSource.setStatus('current')
if mibBuilder.loadTexts: prtMl4OosErrorSource.setDescription('OOS (Out-of-Service) Error Source. This object is applicable for T1 ports only.')
prtMl4OosEntryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4OosEntryThreshold.setStatus('current')
if mibBuilder.loadTexts: prtMl4OosEntryThreshold.setDescription('This object defines the number of Errors per Second that determine the minimum unacceptable noise level. This value will be the Entry Threshold to the OOS (Out-of-Service) state. This object is applicable only when prtMl4OosErrorSource=framing(3) or bpv(4). 0=notApplicable.')
prtMl4OosExitThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4OosExitThreshold.setStatus('current')
if mibBuilder.loadTexts: prtMl4OosExitThreshold.setDescription('This object defines the number of consecutive Error-Free-Seconds before going from OOS state to Normal state. This value will be the Exit Threshold from the OOS (Out-of-Service) state. Units=seconds This object is applicable only when prtMl4OosErrorSource=framing(3) or bpv(4). 0=notApplicable.')
prtMl4LogicalLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 257))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4LogicalLinkId.setStatus('current')
if mibBuilder.loadTexts: prtMl4LogicalLinkId.setDescription('This object defines for a V5.2 Master ML the Logical Link Id. Valid values are: 0..256. NA=257.')
prtMl4DedicatedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4DedicatedTs.setStatus('current')
if mibBuilder.loadTexts: prtMl4DedicatedTs.setDescription('A unique number to identify Dedicated TS of the E1 port (V5.2). It is applicable only when prtMl4Service=v52Slave and prtExPh1MlInbandMng selected is dedicatedTs, dedicatedPpp or dedicatedFr. 1..31 - Dedicated TS of E1 255 - notApplicable Other values are invalid.')
prtMl4RemCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4RemCrc.setStatus('current')
if mibBuilder.loadTexts: prtMl4RemCrc.setDescription('This object indicates whether the E1 of the Remote device connected to this E1 port, will have CRC-4 or not.')
prtMl4CrossConnectLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("ds0", 2), ("ds1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4CrossConnectLevel.setStatus('current')
if mibBuilder.loadTexts: prtMl4CrossConnectLevel.setDescription('This object indicates whether the cross connect is on DS1 or DS0 (time-slots) level. When cross connect level is ds1, Destination Slot is indicated by prtGenCnfgLinkToSlot, Destination Port is indicated by prtGenCnfgLinkToPort. For Unframed Line Type, cross connect level can be either notApplicable (NC=not connected) or DS1. Otherwise, default value is ds0.')
prtMl4PppEchoFailDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4PppEchoFailDetection.setStatus('current')
if mibBuilder.loadTexts: prtMl4PppEchoFailDetection.setDescription('This object indicates whether the PPP Echo is taken into account for its Fail Detection. This object is relevant when Inband Mng between devices is Dedicated TS PPP. Default=Disable. Enable - will be selected mainly when a T1/E1 Ring exists and between 2 adjacent Ring devices there is another device or Net, that causes these Ring devices not to sense that the PPP connection between them is lost. In this case, Echo Request should be initiated by the port.')
prtAcmCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1), )
if mibBuilder.loadTexts: prtAcmCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtAcmCnfgTable.setDescription('This is a table for ACM port parameters.')
prtAcmCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtAcmCnfgIdx"), (0, "RAD-MIB", "prtAcmSltIdx"), (0, "RAD-MIB", "prtAcmPrtIdx"))
if mibBuilder.loadTexts: prtAcmCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtAcmCnfgEntry.setDescription('An entry in table.')
prtAcmCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtAcmCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtAcmSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtAcmSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
prtAcmPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtAcmPrtIdx.setDescription('This attribute indicates a unique port number.')
prtAcmConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmConnect.setStatus('current')
if mibBuilder.loadTexts: prtAcmConnect.setDescription('This attribute indicates whether the port should be connected or not. Only a connected port can perform activity.')
prtAcmActiveState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmActiveState.setStatus('current')
if mibBuilder.loadTexts: prtAcmActiveState.setDescription('This attribute indicates the Electric Active State of the port.')
prtAcmAlrString = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmAlrString.setStatus('current')
if mibBuilder.loadTexts: prtAcmAlrString.setDescription('Alarm string selected by user for the Inbound ports. This object is applicable only for the Inbound Ports: ext-5..ext-12. For the Outbound Ports (ext-1..ext-4), the size of this string will be 0.')
prtE2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1), )
if mibBuilder.loadTexts: prtE2CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtE2CnfgTable.setDescription('This is a table for E2 port parameters.')
prtE2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtE2CnfgIdx"), (0, "RAD-MIB", "prtE2SltIdx"), (0, "RAD-MIB", "prtE2PrtIdx"))
if mibBuilder.loadTexts: prtE2CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtE2CnfgEntry.setDescription('An entry in table.')
prtE2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtE2CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtE2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtE2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtE2SltIdx.setStatus('current')
if mibBuilder.loadTexts: prtE2SltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
prtE2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtE2PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtE2PrtIdx.setDescription('This attribute indicates a unique port number.')
prtE2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtE2Connect.setStatus('current')
if mibBuilder.loadTexts: prtE2Connect.setDescription('This attribute indicates whether the port should be connected or not. Only a connected port can perform activity.')
prtE2MngOnNationalBit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 21, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtE2MngOnNationalBit.setStatus('current')
if mibBuilder.loadTexts: prtE2MngOnNationalBit.setDescription('This attribute indicates whether National Bit will be used for Management or not.')
prtLanWanCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1), )
if mibBuilder.loadTexts: prtLanWanCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtLanWanCnfgTable.setDescription('This is a table for Lan-Wan port parameters.')
prtLanWanCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtLanWanCnfgIdx"), (0, "RAD-MIB", "prtLanWanSltIdx"), (0, "RAD-MIB", "prtLanWanPrtIdx"))
if mibBuilder.loadTexts: prtLanWanCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtLanWanCnfgEntry.setDescription('An entry in table.')
prtLanWanCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: prtLanWanCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtLanWanCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtLanWanSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16))))
if mibBuilder.loadTexts: prtLanWanSltIdx.setStatus('current')
if mibBuilder.loadTexts: prtLanWanSltIdx.setDescription('This object indicates a unique slot position where the module is inserted.')
prtLanWanPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: prtLanWanPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtLanWanPrtIdx.setDescription('This object indicates a unique number to identify a port in a specific card. Generally, for MP-210X/2200, the Port Index will be according to the external/internal port number: - exPrtX : X - inPrtX : 100 + X For FCD-155, refer to device specification')
prtLanWanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("bridge", 2), ("bridgeAndStp", 3), ("layer3SubnetSwitch", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanMode.setStatus('current')
if mibBuilder.loadTexts: prtLanWanMode.setDescription('This object determines the working mode of this port. For FCD155, layer3SubnetSwitch is not applicable')
prtLanWanDestIf = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanDestIf.setStatus('current')
if mibBuilder.loadTexts: prtLanWanDestIf.setDescription('This object determines the Destination Interface for the frames received by this port. - Switching Table = 100 (it means that the destination interface will be determined by the Switching Table) - inPrtX (internal-X port): 100 + X . For FCD-155 this object is not applicable =0 ')
prtLanWanEgressVlanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("unmodified", 2), ("tag", 3), ("doubleTag", 4), ("untag", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanEgressVlanMode.setStatus('current')
if mibBuilder.loadTexts: prtLanWanEgressVlanMode.setDescription('This object determines what to do with the VLAN frames that exit via the WAN side of the port. This object is not applicable when prtLanWanMode=l3SubnetSwitch(4).')
prtLanWanL2Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("ppp", 3), ("hdlc", 4), ("pppoHdlc", 5), ("mlppp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanL2Protocol.setStatus('current')
if mibBuilder.loadTexts: prtLanWanL2Protocol.setDescription('L2 Protocol. When prtLanWanMode=l3SubnetSwitch(4), the only valid value is ppp(3).')
prtLanWanStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanStpPriority.setStatus('current')
if mibBuilder.loadTexts: prtLanWanStpPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID.')
prtLanWanStpCost = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanStpCost.setStatus('current')
if mibBuilder.loadTexts: prtLanWanStpCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port. 802.1D-1990 recommends that the default value of this parameter be in inverse proportion to the speed of the attached LAN.')
prtLanWanToLanVlanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("unmodified", 2), ("tag", 3), ("doubleTag", 4), ("untag", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanToLanVlanMode.setStatus('current')
if mibBuilder.loadTexts: prtLanWanToLanVlanMode.setDescription('This object determines what to do with the VLAN frames that come from WAN side of the port and exit towards one of the LAN ports. This object is applicable only when prtLanWanDestIf=100 or 101 (Switching Table or inPrt1).')
prtLanWanVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanVlanId.setStatus('current')
if mibBuilder.loadTexts: prtLanWanVlanId.setDescription('This is the VLAN Id attached to a frame, when the relevant Vlan Mode (prtLanWanEgressVlanMode or prtLanWanToLanVlanMode) is tag or doubleTag. 0=not applicable.')
prtLanWanVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanVlanPriority.setStatus('current')
if mibBuilder.loadTexts: prtLanWanVlanPriority.setDescription('This is the VLAN Priority attached to a frame, when the relevant Vlan Mode (prtLanWanEgressVlanMode or prtLanWanToLanVlanMode) is tag or doubleTag. Valid values: 0..7 255=not applicable.')
prtLanWanMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanMtu.setStatus('current')
if mibBuilder.loadTexts: prtLanWanMtu.setDescription('The size of the largest packet which can be sent/received on the interface, specified in octets. Valid values change per device. 0=not applicable.')
prtLanWanVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 22, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("portBasedVlan", 2), ("ieee802dot1q", 3), ("ieee802dot1qTaggedOnly", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLanWanVlanType.setStatus('current')
if mibBuilder.loadTexts: prtLanWanVlanType.setDescription('This oject indicates type of VLAN this port is assigned to. Port Base Vlan parameters are defined by objects under radBridgePortBaseVlan')
muxHubEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 3, 2, 0))
if mibBuilder.loadTexts: muxHubEvents.setStatus('current')
if mibBuilder.loadTexts: muxHubEvents.setDescription('The events for .')
alarmsTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2, 0, 1)).setObjects(("RAD-MIB", "alrBufDescription"))
if mibBuilder.loadTexts: alarmsTrap.setStatus('current')
if mibBuilder.loadTexts: alarmsTrap.setDescription('This trap is sent whenever alarm occurs in the agent.')
sanityTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2, 0, 2)).setObjects(("RAD-MIB", "agnSSanityCheckStatus"), ("RAD-MIB", "agnCSaveCnfgIdxCmd"))
if mibBuilder.loadTexts: sanityTrap.setStatus('current')
if mibBuilder.loadTexts: sanityTrap.setDescription('This trap is sent after a data base update. It returns the sanity result status and the configuration no. checked. If the result is of Flip DB Sanity Check, the configuration no. sent will be 0. If the result is of Variant Sanity Check, the configuration no. sent will be 100.')
cnfgFlipTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2, 0, 3)).setObjects(("RAD-MIB", "agnSActiveCnfg"))
if mibBuilder.loadTexts: cnfgFlipTrap.setStatus('current')
if mibBuilder.loadTexts: cnfgFlipTrap.setDescription('This trap is sent upon change of the active Configuration DB. Attached, is the new active Configuration no.')
flipDbChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2, 0, 4))
if mibBuilder.loadTexts: flipDbChangeTrap.setStatus('current')
if mibBuilder.loadTexts: flipDbChangeTrap.setDescription('This trap is sent upon change of the active Flip tables (Flip DB).')
statusChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2, 0, 5)).setObjects(("RAD-MIB", "agnLed"))
if mibBuilder.loadTexts: statusChangedTrap.setStatus('current')
if mibBuilder.loadTexts: statusChangedTrap.setDescription('This trap is sent upon any change of the LEDs status.')
ds1Interface = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4))
prtDS1Events = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0))
prtDs1PerfHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1))
dsx1XCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2), )
if mibBuilder.loadTexts: dsx1XCurrentTable.setStatus('current')
if mibBuilder.loadTexts: dsx1XCurrentTable.setDescription('A list of current statistics entries. This table contains additional objects for the current table.')
dsx1XCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1), ).setIndexNames((0, "DS1-MIB", "dsx1CurrentIndex"))
if mibBuilder.loadTexts: dsx1XCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1XCurrentEntry.setDescription('An entry containing additional statistical counters applicable to a particular current table.')
dsx1CurrentLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOS.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOS.setDescription('The counter associated with the number of LOS seconds, encountered by a DS1 interface in the current 15 minute interval.')
dsx1CurrentLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOF.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOF.setDescription('The counter associated with the number of LOF seconds, encountered by a DS1 interface in the current 15 minute interval.')
dsx1CurrentLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOC.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOC.setDescription(' Loss Of Cell delineation. Counts number of cells the ATM UNI cells receiver lost cells delineation .')
dsx1CurrentAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentAIS.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentAIS.setDescription('The counter associated with the number of AIS seconds, encountered by a DS1 interface in the current 15 minute interval.')
dsx1CurrentRAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentRAI.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentRAI.setDescription('Remote Alarm Indication: Transmitted in the outgoing direction (toward the PABX) over FDL bits when the DS1 device detected an incoming Loss Of Frame. Received from the far end (PABX) over FDL when it detects a Loss of frame.')
dsx1CurrentLOMF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOMF.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOMF.setDescription('Loss of Multi-Frame sequence in E1 time slot 16.')
dsx1CurrentFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentFEBE.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentFEBE.setDescription('Far End Block Errors, as reported in the first bit of frames 13 and 15, on multiframe E1 lines with CRC4, in the current 15 minute interval.')
dsx1CurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentStatus.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentStatus.setDescription('The statuses of the current interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
dsx1CurrentBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentBPV.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentBPV.setDescription('The counter associated with the number of BPVs (Bi-Polar Violations) encountered by a DS1 interface in the current 15 minute interval.')
dsx1CurrentLOCRCMF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 10), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOCRCMF.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOCRCMF.setDescription('Loss of CRC4 Multi-Frame sequence in E1. encountered in the current 15 minute interval')
dsx1CurrentLOFC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 11), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentLOFC.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentLOFC.setDescription('Counts the number of loss of frame events measured. encountered in the current 15 minute interval')
dsx1CurrentCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 2, 1, 12), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1CurrentCRCErrors.setStatus('current')
if mibBuilder.loadTexts: dsx1CurrentCRCErrors.setDescription('Counts the number of CRC error events, encountered in the current 15 minute interval.')
dsx1XIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3), )
if mibBuilder.loadTexts: dsx1XIntervalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1XIntervalTable.setDescription(' A list of Interval entries. This table contains additional objects for the interval table.')
dsx1XIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1), ).setIndexNames((0, "DS1-MIB", "dsx1IntervalIndex"), (0, "DS1-MIB", "dsx1IntervalNumber"))
if mibBuilder.loadTexts: dsx1XIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1XIntervalEntry.setDescription('An entry containing additional statistical counters applicable to a particular interval table.')
dsx1IntervalLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 1), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOS.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOS.setDescription('The counter associated with the number of LOS seconds , encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
dsx1IntervalLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 2), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOF.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOF.setDescription('The counter associated with the number of OOF seconds, encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
dsx1IntervalLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 3), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOC.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOC.setDescription(' Loss Of Cell delineation. Counts number of cells the ATM UNI cells receiver lost cells delineation .')
dsx1IntervalAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalAIS.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalAIS.setDescription('The counter associated with the number of AIS seconds, encountered by a SONET interface in one of the previous 96, individual 15 minute, intervals.')
dsx1IntervalRAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalRAI.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalRAI.setDescription('Remote Alarm Indication: Transmitted in the outgoing direction (toward the PABX) over FDL bits when the DS1 device detected an incoming Loss Of Frame. Received from the far end (PABX) over FDL when it detects a Loss of frame.')
dsx1IntervalLOMF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOMF.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOMF.setDescription('Loss of Multi-Frame sequence in E1 time slot 16.')
dsx1IntervalFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalFEBE.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalFEBE.setDescription('Far End Block Errors, as reported in the first bit of frames 13 and 15, on multiframe E1 lines with CRC4, in one of the previous 96, individual, 15 minute intervals.')
dsx1IntervalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalStatus.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalStatus.setDescription('The statuses of the current interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
dsx1IntervalBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalBPV.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalBPV.setDescription('The counter associated with the number of BPV (Bi-Polar Violations) encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
dsx1IntervalLOCRCMF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOCRCMF.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOCRCMF.setDescription('Loss of CRC4 Multi-Frame sequence in E1.')
dsx1IntervalLOFC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 3, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1IntervalLOFC.setStatus('current')
if mibBuilder.loadTexts: dsx1IntervalLOFC.setDescription('Counts the number of loss of frame events measured in one of the previous 96, individual 15 minute, intervals.')
dsx1XTotalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 4), )
if mibBuilder.loadTexts: dsx1XTotalTable.setStatus('current')
if mibBuilder.loadTexts: dsx1XTotalTable.setDescription('A list of Total statistics entries. This table contains additional objects for the Total table.')
dsx1XTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 4, 1), ).setIndexNames((0, "DS1-MIB", "dsx1TotalIndex"))
if mibBuilder.loadTexts: dsx1XTotalEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1XTotalEntry.setDescription('An entry containing additional statistical counters applicable to a particular current table.')
dsx1TotalLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 4, 1, 1), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalLOS.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalLOS.setDescription('The counter associated with the number of LOS (Loss of Signal) seconds encountered by a DS1 interface in the previous 24 hour interval. Invalid 15 minute intervals count as 0.')
dsx1TotalBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 4, 1, 9), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalBPV.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalBPV.setDescription('The counter associated with the number of BPV (Bi-Polar Violations) encountered by a DS1 interface in the previous 24 hour interval. Invalid 15 minute intervals count as 0.')
dsx1TotalLOFC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 4, 1, 11), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TotalLOFC.setStatus('current')
if mibBuilder.loadTexts: dsx1TotalLOFC.setDescription('The counter associated with the number loss of frames encountered by a DS1 interface in the previous 24 hour interval. Invalid 15 minute intervals count as 0.')
dsx1DataStreamStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5), )
if mibBuilder.loadTexts: dsx1DataStreamStatTable.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatTable.setDescription('The DS1 Data Stream Statistics table.')
dsx1DataStreamStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1), ).setIndexNames((0, "RAD-MIB", "dsx1DataStreamStatIfIndex"), (0, "RAD-MIB", "dsx1DataStreamStatIndex"))
if mibBuilder.loadTexts: dsx1DataStreamStatEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatEntry.setDescription('An entry in the DS1 Data Stream Statistics table.')
dsx1DataStreamStatIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: dsx1DataStreamStatIfIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatIfIndex.setDescription('The index of the DS1 interface. It may be ifIndex.')
dsx1DataStreamStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 2), Integer32())
if mibBuilder.loadTexts: dsx1DataStreamStatIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatIndex.setDescription('The DS1 Data Stream Index. For Vmux - the following indices are used: 1 for Transparent 2-3 for SS71-SS72 (respectively) 4-7 for Data1-Data4 (respectively) 8 for HDLC Ph2 Compatible 9-16 for Sub-CH1-1...Sub-CH1-8 (respectively).')
dsx1DataStreamStatValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatValid.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatValid.setDescription('Indicates whether this Data Stream is valid or not. When invalid - all counters are irrelevant.')
dsx1DataStreamStatInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatInFrames.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatInFrames.setDescription('The counter associated with the number of received frames, encountered by the DS1 Data Stream.')
dsx1DataStreamStatInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatInBytes.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatInBytes.setDescription('The counter associated with the number of received bytes, encountered by the DS1 Data Stream.')
dsx1DataStreamStatInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatInDiscards.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatInDiscards.setDescription('The counter associated with the number of Discarded incoming frames, encountered by the DS1 Data Stream.')
dsx1DataStreamStatInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatInErrors.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatInErrors.setDescription('The counter associated with the number of received Errored frames, encountered by the DS1 Data Stream.')
dsx1DataStreamStatOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatOutFrames.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatOutFrames.setDescription('The counter associated with the number of transmitted frames, encountered by the DS1 Data Stream.')
dsx1DataStreamStatOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatOutBytes.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatOutBytes.setDescription('The counter associated with the number of transmitted bytes, encountered by the DS1 Data Stream.')
dsx1DataStreamStatOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatOutDiscards.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatOutDiscards.setDescription('The counter associated with the number of Discarded outgoing frames, encountered by the DS1 Data Stream.')
dsx1DataStreamStatOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1DataStreamStatOutErrors.setStatus('current')
if mibBuilder.loadTexts: dsx1DataStreamStatOutErrors.setDescription('The counter associated with the number of errored transmitted frames, encountered by the DS1 Data Stream.')
dsx1XConfigTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2), )
if mibBuilder.loadTexts: dsx1XConfigTable.setStatus('current')
if mibBuilder.loadTexts: dsx1XConfigTable.setDescription(' An extension to the DS1 Configuration table.')
dsx1XConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1), ).setIndexNames((0, "DS1-MIB", "dsx1LineIndex"))
if mibBuilder.loadTexts: dsx1XConfigEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1XConfigEntry.setDescription('An entry containing additional configuration parameters.')
dsx1IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1IdleCode.setStatus('current')
if mibBuilder.loadTexts: dsx1IdleCode.setDescription('Byte pattern of the data received/transmitted in the E1T1 framer idle timeslots. Valid range: (0 - FF HEX).')
dsx1LineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("csu", 1), ("dsu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineMode.setStatus('current')
if mibBuilder.loadTexts: dsx1LineMode.setDescription('T1 device operation mode. Valid for T1 only.')
dsx1dBTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("neg75dB", 2), ("neg15dB", 3), ("neg225dB", 4), ("zerodB", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1dBTxGain.setStatus('current')
if mibBuilder.loadTexts: dsx1dBTxGain.setDescription('Transmit line Gain for T1 CSU line mode.')
dsx1RxSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("longHaul", 2), ("shortHaul", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1RxSensitivity.setStatus('current')
if mibBuilder.loadTexts: dsx1RxSensitivity.setDescription('Low Sensitivity is considered Short Haul while High Sensitivity is considered Long Haul. The actual values depend on the LIU. Examples: - E1: -12dB is considered Short Haul ; -43dB is considered Long Haul - T1: -12dB is considered Short Haul ; -36dB is considered Long Haul.')
dsx1RestoreTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("sec1", 2), ("sec10", 3), ("immediate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1RestoreTime.setStatus('current')
if mibBuilder.loadTexts: dsx1RestoreTime.setDescription("Used to change the sync. algorithms to reduce the time required for the port to return to normal operation after a RED alarm. 'sec1' = Fast, 'sec10' = TR-6211, 'immediate' = CCITT")
dsx1TcFirstSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TcFirstSignal.setStatus('current')
if mibBuilder.loadTexts: dsx1TcFirstSignal.setDescription('Trunk conditioning signal - value to be sent as a signal during the first 2.5 seconds after alarm detection. Range is 0x0..0xF. 0xFF is a NULL value. This variable is used also for Space Signaling Code (in this case 0xFF is not NULL).')
dsx1TcSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TcSignal.setStatus('current')
if mibBuilder.loadTexts: dsx1TcSignal.setDescription('Trunk conditioning signal value after alarm detection. Range is 0x1..0xF for E1, and 0x0..0xF for T1. This variable is used also for Space Signaling Code (E1 and T1).')
dsx1TcPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TcPattern.setStatus('current')
if mibBuilder.loadTexts: dsx1TcPattern.setDescription('Trunk conditioning data pattern to be sent upon a DS0 fail. Range is 0x0..0xFF. This variable used also for Out of Service Code.')
dsx1Scramble = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("notActive", 2), ("active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1Scramble.setStatus('current')
if mibBuilder.loadTexts: dsx1Scramble.setDescription('Scrambling is an operation that randomizes the bits of the payload of the ATM cell by a polynom. This operation helps with the error detection mechanism of the HEC. Not applicable for E1. active - will scramble/descramble the payload ATM cell notActive - will not scramble/descramble. ')
dsx1LineAdaptiveTimingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LineAdaptiveTimingMode.setStatus('current')
if mibBuilder.loadTexts: dsx1LineAdaptiveTimingMode.setDescription('Enables end to end clock synchronization. Default value - off.')
dsx1TxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2), ("throughTiming", 3), ("adaptive", 4), ("system", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TxClockSource.setStatus('current')
if mibBuilder.loadTexts: dsx1TxClockSource.setDescription("The source of Transmit Clock. 'loopTiming' indicates that the recovered receive clock is used as the transmit clock. 'localTiming' indicates that a local clock source is used or when an external clock is attached to the box containing the interface. 'throughTiming' indicates that recovered receive clock from another interface is used as the transmit clock. 'adaptive' indicates that the clock is recovered according to the received data flow rate. 'system' indicates that the system clock is used as the transmit clock.")
dsx1AisEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1AisEnable.setStatus('current')
if mibBuilder.loadTexts: dsx1AisEnable.setDescription('Enable/ disable AIS transmit when Ethernet cable (for TDMoIP) is out (disconnected).')
dsx1TsEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1TsEchoCancel.setStatus('current')
if mibBuilder.loadTexts: dsx1TsEchoCancel.setDescription("This parameter defines for each TS whether Echo-Cancellation is on. Each bit represents one TS as follow: First octet bit'0' = TS#1, bit'7' = TS#8, .. 2nd octet bit'0' = TS#9,.., 4th octet bit'7' = TS#32. Octets and bits order is from left to right: [31,30,..24] [23..16] [15..8] [7..0] MSB LSB MSB LSB MSB LSB MSB LSB For each bit values are: 0 - Echo-Cancellation off. 1 - Echo-Cancellation on.")
dsx1EchoCancelerModule = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("notExist", 2), ("exist", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1EchoCancelerModule.setStatus('current')
if mibBuilder.loadTexts: dsx1EchoCancelerModule.setDescription('This parameter indicates whether echo-cancellation module exists for this line.')
dsx1PortFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("uni", 2), ("ces", 3), ("ima", 4), ("cesPsn", 5), ("abis", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1PortFunction.setStatus('current')
if mibBuilder.loadTexts: dsx1PortFunction.setDescription('This object determines the ATM Mode over the physical port. uni - The port will function as an ATM UNI. ces - The port will function as a CES. ima - The port will function as an IMA-ATM. cesPsn - The port will function as a CES-PSN. abis - The port will function as an Abis.')
dsx1PortMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("r56", 2), ("r64", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1PortMultiplier.setStatus('current')
if mibBuilder.loadTexts: dsx1PortMultiplier.setDescription('This object determines the data rate of each TS (Kbps units). This parameter is applicable for T1 only.')
dsx1LeasedLine = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1LeasedLine.setStatus('current')
if mibBuilder.loadTexts: dsx1LeasedLine.setDescription('This parameter defines whether Line mode is regular (non Leased Line mode) or transparent (Leased Line mode).')
dsx1CsuLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("transparent", 3), ("remote", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1CsuLoop.setStatus('current')
if mibBuilder.loadTexts: dsx1CsuLoop.setDescription('This parameter defines where the CSU loop will be done: local - locally (by IPmux) towards the TDM device transparent - transferred to Remote Device that will send it to its connected TDM device. remote - Remote Device will close the loop towards the Local Device.')
dsx1ClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1ClockSource.setStatus('current')
if mibBuilder.loadTexts: dsx1ClockSource.setDescription('This entry specifies the source from which the clock will be taken. Refer to device specification for source Index')
dsx1OosSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("space", 2), ("mark", 3), ("spaceMark", 4), ("markSpace", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1OosSignal.setStatus('current')
if mibBuilder.loadTexts: dsx1OosSignal.setDescription(" This parameter defines the value to be sent as a signal after alarm detection: 'Space' = both A and B signaling bits are forced to '0' during out-of-service periods. 'Mark' = both A and B signaling bits are forced to '1' during out-of-service periods. 'spaceMark' = A and B bits are forced to '0' for 2.5 seconds; then they are switched to '1' until out-of-service condition disappears. 'markSpace' = A and B bits are forced to '1' for 2.5 seconds; then they are switched to '0' until out-of-service condition disappears. - '0'= 0 for T1, 1 for E1, or user defined value for Space - '1'= 1 for T1, 0 for E1, or user defined value for Mark.")
dsx1BundleNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1BundleNextIndex.setStatus('current')
if mibBuilder.loadTexts: dsx1BundleNextIndex.setDescription('This parameter indicates the Next free Bundle Index for this DS1 port.')
dsx1CRC6CalcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("jtG704", 1), ("ituG704", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1CRC6CalcMode.setStatus('current')
if mibBuilder.loadTexts: dsx1CRC6CalcMode.setDescription('This object determines the CRC6 Calculation mode. jtG704 =JT-G704 = the Japanese standard ituG704=ITU-G704 = the International standard This parameter is applicable for J1 only.')
dsx1SendUponFail = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("oosCode", 2), ("ais", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1SendUponFail.setStatus('current')
if mibBuilder.loadTexts: dsx1SendUponFail.setDescription('This object determines which notification will be sent to the other side upon fail of another interface. In Ipmux14 the notification is sent upon failure of the Ethernet link.')
ds1LocalMultiframeAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 1)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1LocalMultiframeAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: ds1LocalMultiframeAlarmTrap.setDescription('This trap indicates near end (Local) Loss of Multiframe Alignment, of the user E1 interface.')
ds1RemoteMultiframeAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 2)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1RemoteMultiframeAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: ds1RemoteMultiframeAlarmTrap.setDescription('This trap indicates that the far end (remote) unit, connected to the user E1 interface, reports Loss of Multiframe Alignment.')
ds1LinkFrameSlipTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 3)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1LinkFrameSlipTrap.setStatus('current')
if mibBuilder.loadTexts: ds1LinkFrameSlipTrap.setDescription('This trap indicates that a Frame Slip occurred at the user DS1 interface. This usually indicates timing problems (incorrect selection of timing reference), on the user DS1 link.')
ds1BpvErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 4)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1BpvErrorTrap.setStatus('current')
if mibBuilder.loadTexts: ds1BpvErrorTrap.setDescription('This trap indicates a Bipolar Violation (BPV) error has been detected at the user DS1 interface.')
ds1ExcessiveBpvTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 5)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveBpvTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveBpvTrap.setDescription('This trap indicates excessive number of Bipolar Violation errors (BPV) detected by the user DS1 interface')
ds1Crc4ErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 6)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1Crc4ErrorTrap.setStatus('current')
if mibBuilder.loadTexts: ds1Crc4ErrorTrap.setDescription('This trap indicates that a frame with CRC-4 error has been detected at the user DS1 interface.')
ds1ExcessiveErrorRatioTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 7)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveErrorRatioTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveErrorRatioTrap.setDescription('This trap indicates that the error rate, detected at the user DS1 interface, on the frame synchronization bits is high, as defined by ITU-T Rec. G.732.')
ds1RemoteSyncLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 8)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1RemoteSyncLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1RemoteSyncLossTrap.setDescription('This trap indicates that the far-end (remote) unit, connected to user DS1 interface, reports Loss of Frame Alignment (Sync Loss).')
ds1LocalSyncLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 9)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1LocalSyncLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1LocalSyncLossTrap.setDescription('This trap indicates near end (Local) Loss of Frame Alignment failure (Sync Loss), of the user DS1 interface')
ds1AisSyncLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 10)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1AisSyncLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1AisSyncLossTrap.setDescription('This trap indicates near end (Local) Loss of Frame Alignment (Sync Loss), caused by the reception of AIS at the user DS1 interface.')
ds1AisTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 11)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1AisTrap.setStatus('current')
if mibBuilder.loadTexts: ds1AisTrap.setDescription('This trap indicates AIS being received at the user DS1 interface.')
ds1NetworkRemoteLoopTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 12)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1NetworkRemoteLoopTrap.setStatus('current')
if mibBuilder.loadTexts: ds1NetworkRemoteLoopTrap.setDescription('This trap indicates that a remote loopback has been activated, on the local uplink interface.')
ds1RemoteLoopTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 13)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1RemoteLoopTrap.setStatus('current')
if mibBuilder.loadTexts: ds1RemoteLoopTrap.setDescription('This trap indicates that a remote loopback has been activated, on the local user port.')
ds1LocalLoopTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 14)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1LocalLoopTrap.setStatus('current')
if mibBuilder.loadTexts: ds1LocalLoopTrap.setDescription('This trap indicates that a local loopback has been activated on the user port.')
ds1ExcessiveFrameSlipTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 15)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveFrameSlipTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveFrameSlipTrap.setDescription('This trap indicates that the number of Frame Slips detected at the user DS1 interface, during the last minute exceeds threshold. For LA-110, threshold value is 10. This usually indicates timing problems (incorrect selection of timing reference) on the user DS1.')
ds1ExcessiveCrc4ErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 16)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveCrc4ErrorTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveCrc4ErrorTrap.setDescription('This trap indicates that the error rate detected on the CRC-4 bits at the user DS1 interface, is high.')
ds1ExcessiveLocalMfAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 17)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveLocalMfAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveLocalMfAlarmTrap.setDescription('This trap indicates that the number of local Loss of Multiframe Alignment events, detected at the user E1 interface during the last minute exceeds threshold. For LA-110, threshold value is 10.')
ds1ExcessiveRemoteMfAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 18)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveRemoteMfAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveRemoteMfAlarmTrap.setDescription('This trap indicates that the number of Loss of multiframe alignment events reported by the remote unit connected to the user E1 interface during the last minute exceeds threshold. For LA-110, threshold value is 10.')
ds1ExcessiveRemoteSyncLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 19)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveRemoteSyncLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveRemoteSyncLossTrap.setDescription('This trap indicates that the number of far end (remote) Loss of Synchronization alarms, reported by the user DS1 interface during the last minute, exceeds threshold. For LA-110, threshold value is 10.')
ds1ExcessiveLocalSyncLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 20)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1ExcessiveLocalSyncLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1ExcessiveLocalSyncLossTrap.setDescription('This trap indicates that the number of Loss of local Synchronization alarms reported by the user DS1 interface during the last minute, exceeds threshold. For LA-110, threshold value is 10.')
ds1SignalLossTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 4, 0, 21)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: ds1SignalLossTrap.setStatus('current')
if mibBuilder.loadTexts: ds1SignalLossTrap.setDescription('This trap indicates Signal Loss. (possible reason - cable disconnection. etc.)')
ds3Interface = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3))
prtDs3PerfHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1))
prtSDs3IfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 1), )
if mibBuilder.loadTexts: prtSDs3IfTable.setStatus('current')
if mibBuilder.loadTexts: prtSDs3IfTable.setDescription('The DS3 interface table.')
prtDs3IfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtDs3IfEntry.setStatus('current')
if mibBuilder.loadTexts: prtDs3IfEntry.setDescription('An entry in the DS3 interface table.')
prtDs3IfTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IfTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: prtDs3IfTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the near end current error- measurement period.')
prtDs3IfValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IfValidIntervals.setStatus('current')
if mibBuilder.loadTexts: prtDs3IfValidIntervals.setDescription('The number of previous near end intervals for which valid data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15 minute near end intervals since the interface has been online.')
prtDs3CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2), )
if mibBuilder.loadTexts: prtDs3CurrentTable.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentTable.setDescription('The DS3 Current table.')
prtDs3CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtDs3CurrentEntry.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentEntry.setDescription('An entry in the DS3 Current table.')
prtDs3CurrentLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentLOS.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentLOS.setDescription('The counter associated with the number of LOS seconds, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentOOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentOOF.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentOOF.setDescription('The counter associated with the number of OOF seconds, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentLOC.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentLOC.setDescription('The counter associated with the number of LOC seconds, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentAIS.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentAIS.setDescription('The counter associated with the number of AIS seconds, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentRDI.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentRDI.setDescription('The counter associated with the number of RDI seconds, encountered by a DS3 interface.')
prtDs3CurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentUAS.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentUAS.setDescription('The counter associated with the number of UAS, encountered by a SONET interface.')
prtDs3CurrentBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentBIP.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentBIP.setDescription('The counter associated with the number of BIP errors, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentFEBE.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentFEBE.setDescription('The counter associated with the number of FEBE errors, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentSLM = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentSLM.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentSLM.setDescription('The counter associated with the number of SLM seconds, encountered by an E3 (only ) interface in the current 15 minute interval.')
prtDs3CurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentSES.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentSES.setDescription('The counter associated with the number of SES encountered by a E3 interface in the current 15 minute interval.')
prtDs3CurrentES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentES.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentES.setDescription(' The number of Errored Seconds, encountered by a DS3 interface in the current 15 minute interval.')
prtDs3CurrentBitParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentBitParity.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentBitParity.setDescription('Bit Parity Error counter. Relevant to T3 only.')
prtDs3CurrentPlcpLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentPlcpLOF.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentPlcpLOF.setDescription('The counter associated with the number of LOF seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals. This counter is relevant for plcpInternal(5) or plcpExternal(6) configuration If frame types only.')
prtDs3CurrentPlcpRAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentPlcpRAI.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentPlcpRAI.setDescription('Receiving Yellow/Remote Alarm Indication. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3CurrentPlcpBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentPlcpBIP.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentPlcpBIP.setDescription(' The counter associated with the number of BIP errors, encountered by a DS3 interface in the current 15 minute interval. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3CurrentPlcpFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentPlcpFEBE.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentPlcpFEBE.setDescription(' The counter associated with the number of FEBE errors, encountered by a DS3 interface in the current 15 minute interval. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3CurrentBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentBPV.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentBPV.setDescription(' Number of BPVs (Bi-Polar Violations) , encountered by a DS3 interface in the current 15 minute interval. This object is relevant only for Electrical Line of Fomi-E3/T3.')
prtDs3CurrentLCE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentLCE.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentLCE.setDescription(' Number of LCE (Link Code Errors) encountered by a DS3 interface in the current 15 minute interval. This object is relevant only for Optical Links of Fomi-E3/T3.')
prtDs3CurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 2, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3CurrentStatus.setStatus('current')
if mibBuilder.loadTexts: prtDs3CurrentStatus.setDescription('The statuses of the current interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
prtDs3IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3), )
if mibBuilder.loadTexts: prtDs3IntervalTable.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalTable.setDescription('The DS3 Interval table.')
prtDs3IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "prtDs3IntervalNumber"))
if mibBuilder.loadTexts: prtDs3IntervalEntry.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalEntry.setDescription('An entry in the DS3 Interval table.')
prtDs3IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalNumber.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
prtDs3IntervalLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalLOS.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalLOS.setDescription('The counter associated with the number of LOS seconds , encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalOOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalOOF.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalOOF.setDescription('The counter associated with the number of OOF seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalLOC.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalLOC.setDescription('The counter associated with the number of LOC seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalAIS.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalAIS.setDescription('The counter associated with the number of AIS seconds, encountered by a SONET interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalRDI.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalRDI.setDescription('The counter associated with the number of RDI seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalUAS.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalUAS.setDescription('The counter associated with the number of UAS, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalBIP.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalBIP.setDescription('The counter associated with the number of BIP errors, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalFEBE.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalFEBE.setDescription('The counter associated with the number of FEBE errors, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalSLM = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalSLM.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalSLM.setDescription('The counter associated with the number of SLM seconds, encountered by an E3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalSES.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalSES.setDescription('The counter associated with the number of SES encountered by a E3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalES.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalES.setDescription(' The number of Errored Seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals.')
prtDs3IntervalBitParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalBitParity.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalBitParity.setDescription('Bit Parity Error counter. Relevant to T3 only.')
prtDs3IntervalPlcpLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalPlcpLOF.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalPlcpLOF.setDescription('The counter associated with the number of LOF seconds, encountered by a DS3 interface in one of the previous 96, individual 15 minute, intervals. This counter is relevant for plcpInternal(5) or plcpExternal(6) configuration If frame types only.')
prtDs3IntervalPlcpRAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalPlcpRAI.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalPlcpRAI.setDescription('Receiving Yellow/Remote Alarm Indication. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3IntervalPlcpBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalPlcpBIP.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalPlcpBIP.setDescription(' The counter associated with the number of BIP errors, encountered by a DS3 interface in the current 15 minute interval. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3IntervalPlcpFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalPlcpFEBE.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalPlcpFEBE.setDescription(' The counter associated with the number of FEBE errors, encountered by a DS3 interface in the current 15 minute interval. This counter is relevant for PLCP (external/internal) frame types only.')
prtDs3IntervalBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalBPV.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalBPV.setDescription(' Number of BPVs (Bi-Polar Violations) , encountered by a DS3 interface in the specified 15 minute interval. This object is relevant only for Electrical Line of Fomi-E3/T3.')
prtDs3IntervalLCE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalLCE.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalLCE.setDescription(' Number of LCE (Link Code Errors) encountered by a DS3 interface in the specified 15 minute interval. This object is relevant only for Optical Links of Fomi-E3/T3.')
prtDs3IntervalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 3, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3IntervalStatus.setStatus('current')
if mibBuilder.loadTexts: prtDs3IntervalStatus.setDescription('The statuses of the current interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
prtDs3TotalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4), )
if mibBuilder.loadTexts: prtDs3TotalTable.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalTable.setDescription(' A list of Total entries.')
prtDs3TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtDs3TotalEntry.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalEntry.setDescription('An entry of Total table.')
prtDs3TotalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3TotalUAS.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalUAS.setDescription('Number of UASs (Unavailable Seconds) , encountered by a DS3 interface in the previous 96 intervals. Invalid 15 minute intervals count as 0.')
prtDs3TotalBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3TotalBPV.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalBPV.setDescription('Number of BPVs (Bi-Polar Violations) , encountered by a DS3 interface in the previous 96 intervals. Invalid 15 minute intervals count as 0.')
prtDs3TotalLCE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3TotalLCE.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalLCE.setDescription('Number of LCE (Link Code Errors) encountered by a DS3 interface in the previous 96 intervals. Invalid 15 minute intervals count as 0.')
prtDs3TotalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 1, 4, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDs3TotalSES.setStatus('current')
if mibBuilder.loadTexts: prtDs3TotalSES.setDescription('Number of SES (Severely Errored Seconds) encountered by a DS3 interface in the previous 96 intervals. Invalid 15 minute intervals count as 0.')
dsx3XConfigTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 2), )
if mibBuilder.loadTexts: dsx3XConfigTable.setStatus('current')
if mibBuilder.loadTexts: dsx3XConfigTable.setDescription('An extension to the DS3 Configuration table.')
dsx3XConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 2, 1), )
dsx3ConfigEntry.registerAugmentions(("RAD-MIB", "dsx3XConfigEntry"))
dsx3XConfigEntry.setIndexNames(*dsx3ConfigEntry.getIndexNames())
if mibBuilder.loadTexts: dsx3XConfigEntry.setStatus('current')
if mibBuilder.loadTexts: dsx3XConfigEntry.setDescription('An entry containing additional configuration parameters.')
dsx3AisEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx3AisEnable.setStatus('current')
if mibBuilder.loadTexts: dsx3AisEnable.setDescription('Enable/ disable AIS transmit when Ethernet (for TDMoIP) line is disconnected.')
dsx3TxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2), ("throughTiming", 3), ("system", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx3TxClockSource.setStatus('current')
if mibBuilder.loadTexts: dsx3TxClockSource.setDescription("The source of Transmit Clock. loopTiming indicates that the recovered receive clock is used as the transmit clock. localTiming indicates that a local clock source is used or that an external clock is attached to the box containing the interface. throughTiming indicates that transmit clock is derived from the recovered receive clock of another DS3 interface. 'system' indicates that the system clock is used as the transmit clock.")
dsx3MappingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 3), )
if mibBuilder.loadTexts: dsx3MappingTable.setStatus('current')
if mibBuilder.loadTexts: dsx3MappingTable.setDescription("The DS3/E3 mapping table associates DS3/E3 channels with logical or physical interfaces. For example, consider a DS3 device with 16 T1's and 1 VCG. There are 28 logical/internal channels, numbered 1 through 28 but only 17 are actually connected. We might describe the allocation of channels, in the dsx3MappingTable, as follows: dsx3MappingIfIndex.1. 1 = 1001 dsx3MappingIfIndex.1.15 = 1015 dsx3MappingIfIndex.1. 2 = 1002 dsx3MappingIfIndex.1.16 = 1016 dsx3MappingIfIndex.1. 3 = 1003 dsx3MappingIfIndex.1.17 = 1017 dsx3MappingIfIndex.1. 4 = 1004 dsx3MappingIfIndex.1.18 = 0 dsx3MappingIfIndex.1. 5 = 1005 dsx3MappingIfIndex.1.19 = 0 dsx3MappingIfIndex.1. 6 = 1006 dsx3MappingIfIndex.1.20 = 0 dsx3MappingIfIndex.1. 7 = 1007 dsx3MappingIfIndex.1.21 = 0 dsx3MappingIfIndex.1. 8 = 1008 dsx3MappingIfIndex.1.22 = 0 dsx3MappingIfIndex.1. 9 = 1009 dsx3MappingIfIndex.1.23 = 0 dsx3MappingIfIndex.1.10 = 1010 dsx3MappingIfIndex.1.24 = 0 dsx3MappingIfIndex.1.11 = 1011 dsx3MappingIfIndex.1.25 = 0 dsx3MappingIfIndex.1.12 = 1012 dsx3MappingIfIndex.1.26 = 0 dsx3MappingIfIndex.1.13 = 1013 dsx3MappingIfIndex.1.27 = 0 dsx3MappingIfIndex.1.14 = 1014 dsx3MappingIfIndex.1.28 = 0 Note that in the case above all channels are mapped to one T3 port with ifIndex = 1. The Channels 1...28 are represented via the 2nd index. The values of 1001...1016 are the T1 interface ifIndexes. The value of 1017 is the ifIndex of the VCG. Unconnected channels have a value of 0. ")
dsx3MappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 3, 1), ).setIndexNames((0, "RAD-MIB", "dsx3MappingDs3Index"), (0, "RAD-MIB", "dsx3MappingNumber"))
if mibBuilder.loadTexts: dsx3MappingEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dsx3MappingEntry.setDescription('An entry in the DS3 mapping table.')
dsx3MappingDs3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: dsx3MappingDs3Index.setStatus('current')
if mibBuilder.loadTexts: dsx3MappingDs3Index.setDescription('The index value which uniquely identifies the DS3/E3 interface to which this entry is applicable. This value is also equal to dsx3LineIndex used in dsx3ConfigEntry. For RICi-16 this is the ifIndex of the T3 interface.')
dsx3MappingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: dsx3MappingNumber.setStatus('current')
if mibBuilder.loadTexts: dsx3MappingNumber.setDescription('The channel number for this entry. For RICi-16 this is the channel number 1...28.')
dsx3MappingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 3, 3, 1, 3), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx3MappingIfIndex.setStatus('current')
if mibBuilder.loadTexts: dsx3MappingIfIndex.setDescription('An index value that uniquely identifies a logical or physical interface mapped to a DS3/E3 channel. If no interface is currently using a channel, the value should be zero. If a single interface occupies more than one channel, that ifIndex value will be found in multiple channels. For RICi-16 this is the ifIndex of the T1 or VCG interface.')
atmNte = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3))
atmNtePrt = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 2))
atmNtePrtConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1))
atmNteEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 12, 3, 0))
if mibBuilder.loadTexts: atmNteEvents.setStatus('current')
if mibBuilder.loadTexts: atmNteEvents.setDescription('The events for RAD ATM products.')
atmNteConfIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1), )
if mibBuilder.loadTexts: atmNteConfIfTable.setStatus('current')
if mibBuilder.loadTexts: atmNteConfIfTable.setDescription('The Physical interface configuration table.')
atmNteConfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmNteConfIfEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteConfIfEntry.setDescription('An entry in the Physical interface configuration table. The ifIndex is of the lowest physical layer.')
atmConfIfTransmitClk = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("internal", 2), ("external", 3), ("loopback", 4), ("adaptive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfTransmitClk.setStatus('current')
if mibBuilder.loadTexts: atmConfIfTransmitClk.setDescription('The transmit clock of the port.')
atmConfIfLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("internal", 2), ("external", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfLoopback.setStatus('current')
if mibBuilder.loadTexts: atmConfIfLoopback.setDescription('Interface Loopback.')
atmConfIfFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("other", 1), ("sonet", 2), ("sdh", 3), ("direct", 4), ("plcpInternal", 5), ("plcpExternal", 6), ("e3", 7), ("ethCrcTrans", 8), ("ethCrcNotTrans", 9), ("directNoScrmbling", 10), ("plcpInternalNoScrmbling", 11), ("plcpExternalNoScrmbling", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfFrameType.setStatus('current')
if mibBuilder.loadTexts: atmConfIfFrameType.setDescription('The frame type. Valid values for a 155M interface: sonet(2), sdh(3). Valid values for a T3 interface: direct(4), plcpInternal(5), plcpExternal(6), directNoScrmbling(10), plcpInternalNoScrmbling(11), plcpExternalNoScrmbling(12). Valid values for Ethernet interface: ethCrcTrans (8), ethCrcNotTrans(9). (DS1 interfaces frame type is specified in the DSX1 mib).')
atmConfIfCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("notApplicable", 1), ("sc13m-155", 2), ("st13s-155", 3), ("st13l-155", 4), ("utp-155", 5), ("cx-bnc-155", 6), ("e3", 7), ("t3", 8), ("e1", 9), ("e1-ltu", 10), ("fc13l-155", 11), ("fc13lh-155", 12), ("fc15lh-155", 13), ("fc13l-e3", 14), ("fc13lh-e3", 15), ("fc15lh-e3", 16), ("fc13l-t3", 17), ("fc13lh-t3", 18), ("fc15lh-t3", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConfIfCardType.setStatus('deprecated')
if mibBuilder.loadTexts: atmConfIfCardType.setDescription('The card type.')
atmConfAtmIfVpiVciLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("bits15", 2), ("bits17", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConfAtmIfVpiVciLimit.setStatus('current')
if mibBuilder.loadTexts: atmConfAtmIfVpiVciLimit.setDescription('The limit on the sum of the VPI+VCI bits for this interface.')
atmConfIfHwFeatures = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfHwFeatures.setStatus('current')
if mibBuilder.loadTexts: atmConfIfHwFeatures.setDescription('HW features command.')
atmConfIfOutputRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfOutputRate.setStatus('current')
if mibBuilder.loadTexts: atmConfIfOutputRate.setDescription('This parameter indicates the output rate in cells/sec, which is supported per port. Successfully setting this parameter is dependent on all other ports values calculations, which are described in the NMS SRS.')
atmConfIfInputRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfInputRate.setStatus('current')
if mibBuilder.loadTexts: atmConfIfInputRate.setDescription('This parameter indicates the input rate in cells/sec, which is supported per port. Successfully setting this parameter is dependent on all other ports values calculations, which are described in the NMS SRS.')
atmConfAlarmForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfAlarmForwarding.setStatus('current')
if mibBuilder.loadTexts: atmConfAlarmForwarding.setDescription('Enables Path AIS Alarm forwarding upon a failure detection. The following might be considered as a failure: LOS, LOF, LOC, SLM, LOP, Path AIS and Line AIS. disable(2) - will not forward an alarm upon a failure on this port. enable(3) - will forward an alarm upon a failure on this port.')
atmConfIfAllocatedBw = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConfIfAllocatedBw.setStatus('current')
if mibBuilder.loadTexts: atmConfIfAllocatedBw.setDescription('Total VC Bandwidth Allocation.')
atmConfIfLowerVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfLowerVpi.setStatus('current')
if mibBuilder.loadTexts: atmConfIfLowerVpi.setDescription('The Lower possible VPI.')
atmConfIfOamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("segmentTermination", 2), ("endToEndTermination", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfOamMode.setStatus('current')
if mibBuilder.loadTexts: atmConfIfOamMode.setDescription("OAM support Mode, which determines the interface's location in a segment wise.")
atmConfIfOamFailureInd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 2), ("ais", 3), ("rdi", 4), ("aisAndRdi", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfIfOamFailureInd.setStatus('current')
if mibBuilder.loadTexts: atmConfIfOamFailureInd.setDescription('This object allows user to define the type of indication (if any) that will be created upon a LB cell failure, for all VCs on which OAM loopback traffic is activated. disabled(2) - no indication will be created. ais(3) - will cause Tx of AIS. rdi(4) - will cause Tx of RDI. aisAndRdi(5) - will cause Tx of AIS & RDI. For LA-110, indication will be sent only for VCs with atmConfVcLoopbackFailureInd <> disabled')
atmNteAlarmIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2), )
if mibBuilder.loadTexts: atmNteAlarmIfTable.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmIfTable.setDescription('The interface Alarm table.')
atmNteAlarmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmNteAlarmIfEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmIfEntry.setDescription('An entry in the interface Alarm table.')
atmInterfaceActiveAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceActiveAlarms.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceActiveAlarms.setDescription('A Bit String of the active alarms on this interface. An up bit (1) means there is an active alarm of this type. A down bit (0) means there is no such alarm. The meaning of the bits is as follows: 1 - LOS 2 - LOF 3 - Line AIS (SONET)/ PLCP LOF (DS3) 4 - LOP 5 - Path AIS 6 - SLM 7 - LCD 8 - Line RDI (SONET)/ PLCP Yellow (DS3) 9 - Path RDI (SONET)/ RDI (DS3) 10 - Section BIP (SONET)/ P1/P2 (DS3) > Threshold 11 - Line BIP (SONET)/ PLCP BIP (DS3) > Threshold 12 - Line FEBE (SONET)/ PLCP FEBE (DS3) > Threshold 13 - Path BIP > Threshold 14 - Path FEBE > Threshold 15 - HW Failure ')
atmThresholdSectionBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdSectionBIP.setStatus('current')
if mibBuilder.loadTexts: atmThresholdSectionBIP.setDescription('When Section BIPs are greater than this threshold, an active alarm is raised. N/A for ds3/e3 interface.')
atmThresholdLineBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdLineBIP.setStatus('current')
if mibBuilder.loadTexts: atmThresholdLineBIP.setDescription('When Line BIPs are greater than this threshold, an active alarm is raised. N/A for ds3/e3 interface.')
atmThresholdLineFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdLineFEBE.setStatus('current')
if mibBuilder.loadTexts: atmThresholdLineFEBE.setDescription('When Line FEBEs are greater than this threshold, an active alarm is raised. N/A for ds3/e3 interface.')
atmThresholdPathBIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdPathBIP.setStatus('current')
if mibBuilder.loadTexts: atmThresholdPathBIP.setDescription('When Path BIPs are greater than this threshold, an active alarm is raised.')
atmThresholdPathFEBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdPathFEBE.setStatus('current')
if mibBuilder.loadTexts: atmThresholdPathFEBE.setDescription('When Path FEBEs are greater than this threshold, an active alarm is raised.')
atmThresholdErroredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmThresholdErroredCells.setDescription('When Errored Cells are greater than this threshold, an active alarm is raised.')
atmThresholdLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdLostCells.setStatus('current')
if mibBuilder.loadTexts: atmThresholdLostCells.setDescription('When Lost Cells are greater than this threshold, an active alarm is raised.')
atmThresholdMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmThresholdMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmThresholdMisinsertedCells.setDescription('When Misinserted Cells are greater than this threshold, an active alarm is raised.')
atmInterfaceAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceAlarmStatus.setDescription('The variable is on(3) when there is any active alarm on this interface.')
atmInterfaceMaskAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaskAlarms.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMaskAlarms.setDescription('A Bit String of alarms mask on this interface. An up bit (1) means that the respective alarm is masked. A down bit (0) means no mask. The mask is supported for the following alarms: 1 - LOS ')
atmNteConfVpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3), )
if mibBuilder.loadTexts: atmNteConfVpTable.setStatus('current')
if mibBuilder.loadTexts: atmNteConfVpTable.setDescription('The ATM VP configuration table. The table is an extension to the atmVplTable of RFC-1695.')
atmNteConfVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmNteConfVpEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteConfVpEntry.setDescription('An entry in the ATM VP configuration table. ifIndex of the ATM layer.')
atmConfVpPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("police", 2), ("monitor", 3), ("shaping", 4), ("policingAndShaping", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpPolicing.setStatus('current')
if mibBuilder.loadTexts: atmConfVpPolicing.setDescription('Policing method desired for this VPL.')
atmConfVpCCAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 2), ("down", 3), ("source", 4), ("sink", 5), ("listenToActivationCells", 6), ("originateActivationCells", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpCCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmConfVpCCAdminStatus.setDescription('up(2) - Activate Continuity Check (CC). down(3) - Deactivate CC. source(4) - Activate OAM CC(Continuity Check) of local agent ( start sending Oam cells to the remote side ). sink(5) - Activate CC of remote agent ( start receiving Oam cells from remote side ). listenToActivationCells (6) - Passive listener till gets an activation request originateActivationCells(7) - Sands Activation cell according to atmConfVcCCDirection.')
atmConfVpLoopbackAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("up", 2), ("down", 3), ("llid", 4), ("segment", 5), ("endToEnd", 6), ("segmentLlid", 7), ("endToEndLlid", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpLoopbackAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmConfVpLoopbackAdminStatus.setDescription('up(2) - Start loopback OAM cells. down(3) - Stop sending loopback OAM cells. For ace2002: up(2) - Transmitting LB cells with llid all ones (i.e. FFFF..FF) down(3) - Not transmitting LB cells. llid(4) - Transmitting LB cells with llid indicated in the address field. segment(5) - Transmitting Segment LB cells with llid all ones. endToEnd(6) - Transmitting End to End LB cells with llid all ones. segmentLlid(7) - Transmitting Segment LB cells with llid indicated in the address field. endToEndLlid(8) - Transmitting LB cells with llid indicated in the address field. This parameter value might be in conflict with atmConfVpOamSupport value, since this parameter is for LB, while atmConfVpOamSupport is for any other OAM cells.')
atmConfVpLoopbackSinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpLoopbackSinkAddress.setStatus('current')
if mibBuilder.loadTexts: atmConfVpLoopbackSinkAddress.setDescription('Destination address. For ace101: 2 bytes are used. For ace2002: 16 bytes are used.')
atmConfVpCongestionControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpCongestionControl.setStatus('current')
if mibBuilder.loadTexts: atmConfVpCongestionControl.setDescription('Each bit indicates a selection of one option as the following description. All combinations are possible and legal. The codes are: 1 - EPD 2 - CLP 4 - EFCI')
atmConfVpCCDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5))).clone(namedValues=NamedValues(("both", 2), ("source", 4), ("sink", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpCCDirection.setStatus('current')
if mibBuilder.loadTexts: atmConfVpCCDirection.setDescription('both(2) - Agent send OAM CC cells and check received OAM CC cells source(4)- Agent send OAM CC cells. sink(5) - Agent checks received OAM CC cells.')
atmConfVpCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConfVpCreationTime.setStatus('current')
if mibBuilder.loadTexts: atmConfVpCreationTime.setDescription('A date-time in which the VP was created.')
atmConfVpOamSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("intermediate", 1), ("segmentTermination", 2), ("endToEndTermination", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpOamSupport.setStatus('current')
if mibBuilder.loadTexts: atmConfVpOamSupport.setDescription('OAM support mode, which determines the device location in a segment wise.')
atmConfVpCCOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("initial", 1), ("source", 4), ("sink", 5), ("both", 8), ("timeout", 9), ("denied", 10), ("conflict", 11), ("manual", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmConfVpCCOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmConfVpCCOperStatus.setDescription(' initial(1) - The CC activation process is not started. source(4) - Agent sends OAM CC cells. sink(5) - Agent checks received OAM CC cells. both (8) - OAM CC of local and remote agents activation. timeout (9) - Timeout occured on receiving answer from the remote agent. denied (10) - CC activation process rejected by remote agent. conflict (11) - local and remote sides requested activation simultaneously. manual (12) - OAM CC of local agent activated manually. ')
atmConfVpLoopbackTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpLoopbackTraffic.setStatus('current')
if mibBuilder.loadTexts: atmConfVpLoopbackTraffic.setDescription("This parameter has both command and status meanings: off(2) - Set to 'Off' will Stop traffic loop. Getting this value means that the loop is not running. on (3) - Set to 'On' will start traffic loop. Getting this value means that the loop is currently running.")
atmConfVpLoopbackFailureInd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("disabled", 2), ("segmentAis", 3), ("segmentRdi", 4), ("segmentAisAndRdi", 5), ("endToEndAis", 6), ("endToEndRdi", 7), ("endToEndAisAndRdi", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpLoopbackFailureInd.setStatus('current')
if mibBuilder.loadTexts: atmConfVpLoopbackFailureInd.setDescription('This object allows user to define the Indication that will be created upon a LB cell failure. disabled(2) - no indication will be created. segmentAis(3) - will cause Tx of a segment AIS. segmentRdi(4) - will cause Tx of a segment RDI. segmentAisAndRdi(5) - will cause Tx of a segment AIS & RDI. endToEndAis(6) - will cause Tx of an End to End AIS. endToEndRdi(7) - will cause Tx of an End to End RDI. endToEndAisAndRdi(8) - will cause Tx of an End to End AIS & RDI. Default: disabled(2).')
atmConfVpLoopbackFailureThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpLoopbackFailureThreshold.setStatus('current')
if mibBuilder.loadTexts: atmConfVpLoopbackFailureThreshold.setDescription('The number of the LB failures before starting transmission of the Indication defined by atmConfVcLoopbackFailureInd. Range: 1..16. Default: 1.')
atmConfVpOamDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("downStream", 2), ("upStream", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpOamDirection.setStatus('current')
if mibBuilder.loadTexts: atmConfVpOamDirection.setDescription('The direction of OAM cell insertion. downStream(2) - The OAM cell will be inserted in downStream. upStream(3) - The OAM cell will be inserted in upStream.')
atmConfVpOamDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpOamDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmConfVpOamDescrIndex.setDescription("This parameter indicates the VPL's OAM Descriptor index, according to the OAM Descriptor Configuration Table.")
atmConfVpConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notConnected", 1), ("mng", 2), ("bridgePort", 3), ("ds0Bundle", 4), ("atm", 5), ("pw", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmConfVpConnected.setStatus('current')
if mibBuilder.loadTexts: atmConfVpConnected.setDescription('This object indicates whether this VP is connected and if connected, what is it connected to.')
atmNteAlarmVpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 5), )
if mibBuilder.loadTexts: atmNteAlarmVpTable.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmVpTable.setDescription('The ATM VP Alarm table.')
atmNteAlarmVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmNteVpAlarmVpi"))
if mibBuilder.loadTexts: atmNteAlarmVpEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmVpEntry.setDescription('An entry in the ATM VP Alarm table. ifIndex of the ATM layer.')
atmNteVpAlarmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteVpAlarmVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteVpAlarmVpi.setDescription('The VPI on which there is an active alarm.')
atmNteVpActiveAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteVpActiveAlarms.setStatus('current')
if mibBuilder.loadTexts: atmNteVpActiveAlarms.setDescription('A Bit String of the active alarms on this VP. An up bit (1) means there is an active alarm of this type. A down bit (0) means there is no such alarm. The meaning of the bits is as follows: 1 - VP AIS 2 - VP Loss Of Continuity 3 - VP RDI Reception 4 - VP Errored Cells > Threshold 5 - VP Lost Cells > Threshold 6 - VP Misinserted Cells > Threshold 9 - VP Loopback Failure ')
atmNteAlarmVcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 6), )
if mibBuilder.loadTexts: atmNteAlarmVcTable.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmVcTable.setDescription('The ATM VC Alarm table.')
atmNteAlarmVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmNteVcAlarmVpi"), (0, "RAD-MIB", "atmNteVcAlarmVci"))
if mibBuilder.loadTexts: atmNteAlarmVcEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmVcEntry.setDescription('An entry in the ATM VC Alarm table. ifIndex of the ATM layer.')
atmNteVcAlarmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteVcAlarmVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteVcAlarmVpi.setDescription('The VPI of the VC on which there is an active alarm.')
atmNteVcAlarmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteVcAlarmVci.setStatus('current')
if mibBuilder.loadTexts: atmNteVcAlarmVci.setDescription('The VCI of the VC on which there is an active alarm.')
atmNteVcActiveAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteVcActiveAlarms.setStatus('current')
if mibBuilder.loadTexts: atmNteVcActiveAlarms.setDescription('A Bit String of the active alarms on this VC. An up bit (1) means there is an active alarm of this type. A down bit (0) means there is no such alarm. The meaning of the bits is as follows: 1 - VC AIS 2 - VC Loss Of Continuity 3 - VC RDI 4 - VC Errored Cells > Threshold 5 - VC Lost Cells > Threshold 6 - VC Misinserted Cells > Threshold 7 - Tx VC AIS 8 - Tx VC RDI 9 - VC Loopback Failure ')
atmGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2))
atmPerfHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 1))
atmIfPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1))
atmIfDataTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1), )
if mibBuilder.loadTexts: atmIfDataTable.setStatus('current')
if mibBuilder.loadTexts: atmIfDataTable.setDescription('The ATM interface Data table.')
atmIfDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmIfDataEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfDataEntry.setDescription('An entry in the ATM interface Data table.')
atmIfTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: atmIfTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the near end current error- measurement period.')
atmIfValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfValidIntervals.setStatus('current')
if mibBuilder.loadTexts: atmIfValidIntervals.setDescription('The number of previous near end intervals for which valid data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15 minute near end intervals since the interface has been online.')
atmIfTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfTxCells.setDescription('The counter associated with the total number of transmitted cells, encountered by an ATM interface.')
atmIfRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfRxCells.setDescription('The counter associated with the total number of received cells, encountered by an ATM interface.')
atmIfUncorrectedHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfUncorrectedHecs.setStatus('current')
if mibBuilder.loadTexts: atmIfUncorrectedHecs.setDescription('The counter associated with the total number of cells with uncorrected HEC errors, encountered by an ATM interface.')
atmIfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2), )
if mibBuilder.loadTexts: atmIfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentTable.setDescription('The ATM interface Current table.')
atmIfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmIfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentEntry.setDescription('An entry in the ATM interface Current table.')
atmIfCurrentTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCurrentTxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentTxCells.setDescription('The counter associated with the number of transmitted cells, encountered by an ATM interface in the current 15 minute interval.')
atmIfCurrentRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCurrentRxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentRxCells.setDescription('The counter associated with the number of received cells, encountered by an ATM interface in the current 15 minute interval.')
atmIfCurrentCorrectedHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCurrentCorrectedHecs.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentCorrectedHecs.setDescription('The counter associated with the number of cells with corrected HEC errors, encountered by an ATM interface in the current 15 minute interval.')
atmIfCurrentUncorrectedHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCurrentUncorrectedHecs.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentUncorrectedHecs.setDescription('The counter associated with the number of cells with uncorrected HEC errors, encountered by an ATM interface in the current 15 minute interval.')
atmIfCurrentHecErrorSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCurrentHecErrorSeconds.setStatus('current')
if mibBuilder.loadTexts: atmIfCurrentHecErrorSeconds.setDescription('The counter associated with the number of seconds with HEC errors, encountered by an ATM interface in the current 15 minute interval.')
atmIfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3), )
if mibBuilder.loadTexts: atmIfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalTable.setDescription('The ATM interface Interval table.')
atmIfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmIfIntervalNumber"))
if mibBuilder.loadTexts: atmIfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalEntry.setDescription('An entry in the ATM interface Interval table.')
atmIfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmIfIntervalTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalTxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalTxCells.setDescription('The counter associated with the number of transmitted cells , encountered by an ATM interface in one of the previous 96, individual 15 minute, intervals.')
atmIfIntervalRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalRxCells.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalRxCells.setDescription('The counter associated with the number of received cells, encountered by an ATM interface in one of the previous 96, individual 15 minute, intervals.')
atmIfIntervalCorrectedHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalCorrectedHecs.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalCorrectedHecs.setDescription('The counter associated with the number of cells with corrected HEC errors, encountered by an ATM interface in one of the previous 96, individual 15 minute, intervals.')
atmIfIntervalUncorrectedHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalUncorrectedHecs.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalUncorrectedHecs.setDescription('The counter associated with the number of cells with uncorrected HEC errors, encountered by an ATM interface in one of the previous 96, individual 15 minute, intervals.')
atmIfIntervalHecErrorSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIntervalHecErrorSeconds.setStatus('current')
if mibBuilder.loadTexts: atmIfIntervalHecErrorSeconds.setDescription('The counter associated with the number of seconds with HEC errors, encountered by an ATM interface in one of the previous 96, individual 15 minute, intervals.')
atmPvcPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2))
atmVpPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1))
atmVpCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1), )
if mibBuilder.loadTexts: atmVpCurrentTable.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTable.setDescription('The ATM VP Current table.')
atmVpCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVpCurrentVpi"))
if mibBuilder.loadTexts: atmVpCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentEntry.setDescription('An entry in the ATM VP Current table.')
atmVpCurrentVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentVpi.setDescription('The VPI of the VPL.')
atmVpCurrentRxCellsClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentRxCellsClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentRxCellsClp01.setDescription('The counter associated with the number of transmitted cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentRxCellsClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentRxCellsClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentRxCellsClp0.setDescription('The counter associated with the number of received cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentGcra0Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentGcra0Violations.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentGcra0Violations.setDescription('The counter associated with the number of cells violating GCRA0, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentGcra1Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentGcra1Violations.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentGcra1Violations.setDescription('The counter associated with the number of cells violating GCRA1, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentRxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentRxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentRxAIS.setDescription('The counter associated with the number of received AIS cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentTxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentTxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTxAIS.setDescription('The counter associated with the number of transmitted AIS cells, encountered by the VPL of this ATM interface in the current 15 minute interval. Not Supported in the first phase.')
atmVpCurrentRxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentRxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentRxRDI.setDescription('The counter associated with the number of received RDI cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentTxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentTxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTxRDI.setDescription('The counter associated with the number of transmitted RDI cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentContinuityLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentContinuityLoss.setDescription('The counter associated with the number of loss of continuity cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentUAS.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentSES.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentSES.setDescription('The counter associated with the number of Severerly Errored Seconds, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpCurrentCDC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentCDC.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentCDC.setDescription('Amount of cells dropped in the current 15 minute interval of the VP connection.')
atmVpCurrentTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVpCurrentClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 and discarded by the traffic policing entity.')
atmVpCurrentTotalCellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VPL. This includes both CLP=0 and CLP=1 cells.')
atmVpCurrentClp0CellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VPL.')
atmVpCurrentTaggedOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentTaggedOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentTaggedOuts.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1 and transmitted by this VPL.')
atmVpCurrentPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentPCR.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentPCR.setDescription('The maximum traffic rate encountered in the last interval of the VP connection (monitored once a second).')
atmVpCurrentSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentSCR.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentSCR.setDescription('The average traffic rate during the last interval of the VP connection.')
atmVpCurrentMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentMCR.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentMCR.setDescription('MCR - The minimum traffic rate encountered in the last interval of the VP connection (monitored once a second).')
atmVpCurrentShaperTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentShaperTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentShaperTotalDiscards.setDescription('The total number of cells (CLP0 and CLP1) discarded due to congestion by the traffic shaper.')
atmVpCurrentShaperClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentShaperClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentShaperClp0Discards.setDescription('The total number of CLP0 cells discarded due to congestion by the traffic shaper.')
atmVpCurrentShaperClp1Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 1, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCurrentShaperClp1Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpCurrentShaperClp1Discards.setDescription('The total number of CLP1 cells discarded due to congestion by the traffic shaper.')
atmVpPMCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2), )
if mibBuilder.loadTexts: atmVpPMCurrentTable.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentTable.setDescription('The ATM VP Current table for Performance Management.')
atmVpPMCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVpPMCurrentVpi"), (0, "RAD-MIB", "atmVpPMCurrentDir"))
if mibBuilder.loadTexts: atmVpPMCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentEntry.setDescription('An entry in the ATM VP Current table for Performance Management.')
atmVpPMCurrentVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentVpi.setDescription('The VPI of the VPL.')
atmVpPMCurrentDir = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("forward", 2), ("backward", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentDir.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentDir.setDescription('The direction of performance management.')
atmVpPMCurrentTxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentTxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentTxClp01.setDescription('The counter associated with the number of transmitted CLP 0+1 cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentTxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentTxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentTxClp0.setDescription('The counter associated with the number of transmitted CLP 0 cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentRxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentRxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentRxClp01.setDescription('The counter associated with the number of received CLP 0+1 cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentRxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentRxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentRxClp0.setDescription('The counter associated with the number of received CLP 0 cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentErroredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentErroredCells.setDescription('The counter associated with the number of errored cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentLostCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentLostCells.setDescription('The counter associated with the number of lost cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentMisinsertedCells.setDescription('The counter associated with the number of misinserted cells, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentECB.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentECB.setDescription('The counter associated with the number of ECB, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentSECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentSECB.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentSECB.setDescription('The counter associated with the number of SECB, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentES.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentES.setDescription('The counter associated with the number of Errored Seconds, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentSES.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentSES.setDescription('The counter associated with the number of Severely Errored Seconds, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentUAS.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by the VPL of this ATM interface in the current 15 minute interval.')
atmVpPMCurrentIntervalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normal", 2), ("unacceptable", 3))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentIntervalQuality.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentIntervalQuality.setDescription(' If the number of errors per interval is superior to the atmNteUPLTCR value, the quality of service of the interval is declared as unacceptable.')
atmVpPMCurrentLastDayQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("normal", 2), ("degraded", 4))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMCurrentLastDayQuality.setStatus('current')
if mibBuilder.loadTexts: atmVpPMCurrentLastDayQuality.setDescription(' If the number of errors per 24 hours is superior to the atmNteDPLTCR value, the quality of service of the day is declared as degraded.')
atmVpIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3), )
if mibBuilder.loadTexts: atmVpIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTable.setDescription('The ATM Vp Interval table.')
atmVpIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVpIntervalVpi"), (0, "RAD-MIB", "atmVpIntervalNumber"))
if mibBuilder.loadTexts: atmVpIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalEntry.setDescription('An entry in the ATM Vp Interval table.')
atmVpIntervalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalVpi.setDescription('The VPI of the VPL.')
atmVpIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmVpIntervalRxCellsClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalRxCellsClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalRxCellsClp01.setDescription('The counter associated with the number of transmitted cells , encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalRxCellsClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalRxCellsClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalRxCellsClp0.setDescription('The counter associated with the number of received cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalGcra0Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalGcra0Violations.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalGcra0Violations.setDescription('The counter associated with the number of cells violating GCRA0, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalGcra1Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalGcra1Violations.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalGcra1Violations.setDescription('The counter associated with the number of cells violating GCRA1, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalRxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalRxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalRxAIS.setDescription('The counter associated with the number of received AIS cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalTxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalTxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTxAIS.setDescription('The counter associated with the number of transmitted AIS cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals. Not supported in the first phase.')
atmVpIntervalRxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalRxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalRxRDI.setDescription('The counter associated with the number of received RDI cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalTxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalTxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTxRDI.setDescription('The counter associated with the number of transmitted RDI cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalContinuityLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalContinuityLoss.setDescription('The counter associated with the number of Continuity Loss cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalUAS.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalSES.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalSES.setDescription('The counter associated with the number of Severerly Errored Seconds, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalCDC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalCDC.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalCDC.setDescription('Amount of cells dropped in the 15 minute interval of the VP connection.')
atmVpIntervalTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVpIntervalClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 an discarded by the traffic policing entity.')
atmVpIntervalTotalCellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VPL. This includes both CLP=0 and CLP=1 cells.')
atmVpIntervalClp0CellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VPL.')
atmVpIntervalTaggedOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalTaggedOuts.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalTaggedOuts.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1 and transmitted by this VPL.')
atmVpIntervalPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalPCR.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalPCR.setDescription('The maximum traffic rate encountered in the last interval of the VP connection (monitored once a second) encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalSCR.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalSCR.setDescription('The average traffic rate during the last interval of the VP connection , encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalMCR.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalMCR.setDescription('MCR - The minimum traffic rate encountered in the last interval of the VP connection (monitored once a second) encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpIntervalShaperTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalShaperTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalShaperTotalDiscards.setDescription('The total number of cells (CLP0 and CLP1) discarded due to congestion by the traffic shaper.')
atmVpIntervalShaperClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalShaperClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalShaperClp0Discards.setDescription('The total number of CLP0 cells discarded due to congestion by the traffic shaper.')
atmVpIntervalShaperClp1Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 3, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpIntervalShaperClp1Discards.setStatus('current')
if mibBuilder.loadTexts: atmVpIntervalShaperClp1Discards.setDescription('The total number of CLP1 cells discarded due to congestion by the traffic shaper.')
atmVpPMIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4), )
if mibBuilder.loadTexts: atmVpPMIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalTable.setDescription('The ATM Vp Interval table for Performance Management.')
atmVpPMIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVpPMIntervalVpi"), (0, "RAD-MIB", "atmVpPMIntervalDir"), (0, "RAD-MIB", "atmVpPMIntervalNumber"))
if mibBuilder.loadTexts: atmVpPMIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalEntry.setDescription('An entry in the ATM Vp Interval table for Performance Management.')
atmVpPMIntervalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalVpi.setDescription('The VPI of the VPL.')
atmVpPMIntervalDir = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("forward", 2), ("backward", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalDir.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalDir.setDescription('The direction of performance management.')
atmVpPMIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmVpPMIntervalTxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalTxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalTxClp01.setDescription('The counter associated with the number of transmitted CLP 0+1 cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalTxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalTxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalTxClp0.setDescription('The counter associated with the number of transmitted CLP 0 cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalRxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalRxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalRxClp01.setDescription('The counter associated with the number of received CLP 0+1 cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalRxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalRxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalRxClp0.setDescription('The counter associated with the number of received CLP 0 cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalErroredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalErroredCells.setDescription('The counter associated with the number of Errored cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalLostCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalLostCells.setDescription('The counter associated with the number of Lost cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalMisinsertedCells.setDescription('The counter associated with the number of Misinserted cells, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalECB.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalECB.setDescription('The counter associated with the number of ECBs encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalSECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalSECB.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalSECB.setDescription('The counter associated with the number of SECBs encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalES.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalES.setDescription('The counter associated with the number of Errored Seconds, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalSES.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalSES.setDescription('The counter associated with the number of Severely Errored Seconds, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalUAS.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by an ATM interface/VP in one of the previous 96, individual 15 minute, intervals.')
atmVpPMIntervalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normal", 2), ("unacceptable", 3))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalQuality.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalQuality.setDescription(' If the number of errors per interval is superior to the atmNteUPLTCR value, the quality of service of the interval is declared as unacceptable.')
atmVpPMIntervalLastDayQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("normal", 2), ("degraded", 4))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMIntervalLastDayQuality.setStatus('current')
if mibBuilder.loadTexts: atmVpPMIntervalLastDayQuality.setDescription(' If the number of errors per 24 hours is superior to the atmNteDPLTCR value, the quality of service of the day is declared as degraded.')
atmVpQoSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 5), )
if mibBuilder.loadTexts: atmVpQoSTable.setStatus('current')
if mibBuilder.loadTexts: atmVpQoSTable.setDescription('The VP QoS table.')
atmVpQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"), (0, "RAD-MIB", "atmVpQoSPeriodRef"))
if mibBuilder.loadTexts: atmVpQoSEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpQoSEntry.setDescription('.')
atmVpQoSPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpQoSPeriodRef.setStatus('current')
if mibBuilder.loadTexts: atmVpQoSPeriodRef.setDescription('This object is an index that specifies which period of time, the next 2 objects refer to. currentPeriod - the period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. lastPeriod - the period between last two commands of systemResetAllStatsCmd. - If only one command occurred since Start-up: the period between Start-up and last command. - If no command occurred since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
atmVpQoSElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpQoSElapsedTime.setStatus('current')
if mibBuilder.loadTexts: atmVpQoSElapsedTime.setDescription('Elapsed Time in seconds. - for atmVpQoSPeriodRef = currentPeriod: The period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. - for atmVpQoSPeriodRef = lastPeriod: The value of atmVpQoSElapsedTime when last systemResetAllStatsCmd was received.')
atmVpQoSUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpQoSUAS.setStatus('current')
if mibBuilder.loadTexts: atmVpQoSUAS.setDescription('Number of Unavailable Seconds for the reference period (atmVpQoSPeriodRef).')
atmVpPMQoSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6), )
if mibBuilder.loadTexts: atmVpPMQoSTable.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSTable.setDescription('The PM VP QoS table.')
atmVpPMQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"), (0, "RAD-MIB", "atmVpPMQoSDirection"), (0, "RAD-MIB", "atmVpPMQoSPeriodRef"))
if mibBuilder.loadTexts: atmVpPMQoSEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSEntry.setDescription('.')
atmVpPMQoSDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("forward", 2), ("backward", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMQoSDirection.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSDirection.setDescription('The direction of performance management.')
atmVpPMQoSPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMQoSPeriodRef.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSPeriodRef.setDescription('This object is an index that specifies which period of time, the next 5 objects refer to. currentPeriod - the period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. lastPeriod - the period between last two commands of systemResetAllStatsCmd. - If only one command occurred since Start-up: the period between Start-up and last command. - If no command occurred since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
atmVpPMQoSCLR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMQoSCLR.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSCLR.setDescription('Cell Loss Ratio counter for the reference period (atmVpPMQoSPeriodRef)- defined in accordance with I.356 , in %. The value will be multipuled by 100.')
atmVpPMQoSCER = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMQoSCER.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSCER.setDescription('Cell Error Ratio counter for the reference period (atmVpPMQoSPeriodRef) defined in accordance with I.356 , in %. The value will be multipuled by 100.')
atmVpPMQoSCMR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 6, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPMQoSCMR.setStatus('current')
if mibBuilder.loadTexts: atmVpPMQoSCMR.setDescription('Cell Misinsertion Ratio counter for the reference period (atmVpPMQoSPeriodRef) defined in accordance with I.356 , cells/sec .')
atmVpShaperStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7), )
if mibBuilder.loadTexts: atmVpShaperStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperStatTable.setDescription('The ATM VP shaper statistics table.')
atmVpShaperStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVpShaperStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperStatEntry.setDescription('An entry in the ATM VP shaper statistics table.')
atmVpShaperDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperDiscarded.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperDiscarded.setDescription('The number of Cells that were discarded in the shaper on that VPC due to buffer overflow. This counter counts till it reaches its MAX value (20 bits) and then rolls over.')
atmVpShaperOccupation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperOccupation.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperOccupation.setDescription('The number of Cells that are currently stored in the buffer. This parameter is limited to 20 bits.')
atmVpShaperMaxOccupation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperMaxOccupation.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperMaxOccupation.setDescription('The Maximum number of Cells that were stored in the buffer, since this VP was activated. This parameter is limited to 20 bits.')
atmVpShaperLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("empty", 1), ("full", 2), ("below", 3), ("above", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperLevel.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperLevel.setDescription('The occupation of the buffer according to a predefined threshold. empty - buffer is Empty full - buffer is Full below - buffer is Below the threshold above - buffer is Above the threshold. This is also the trigger to start EPD\\PPD mechanism, if set for the VPC.')
atmVpShaperEpdDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperEpdDropped.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperEpdDropped.setDescription('The number of Cells that were dropped in the shaper on that VPC due to EPD\\PPD mechanism in the last second. This parameter is limited to 24 bits. Applicable for a EPD/PPD VP only.')
atmVpShaperTotalEpdDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpShaperTotalEpdDropped.setStatus('current')
if mibBuilder.loadTexts: atmVpShaperTotalEpdDropped.setDescription('The Total number of Cells that were dropped in the shaper on that VPC due to EPD\\PPD mechanism in the last 15 minutes. This counter automatically reset itself every 15 minutes. Applicable for a EPD/PPD VP only.')
atmVcPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2))
atmVcCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1), )
if mibBuilder.loadTexts: atmVcCurrentTable.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTable.setDescription('The ATM VC Current table.')
atmVcCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVcCurrentVpi"), (0, "RAD-MIB", "atmVcCurrentVci"))
if mibBuilder.loadTexts: atmVcCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentEntry.setDescription('An entry in the ATM VC Current table.')
atmVcCurrentVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentVpi.setDescription('The VPI of the VCL.')
atmVcCurrentVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentVci.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentVci.setDescription('The VCI of the VCL.')
atmVcCurrentRxCellsClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentRxCellsClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentRxCellsClp01.setDescription('The counter associated with the number of transmitted cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentRxCellsClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentRxCellsClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentRxCellsClp0.setDescription('The counter associated with the number of received cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentGcra0Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentGcra0Violations.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentGcra0Violations.setDescription('The counter associated with the number of cells violating GCRA0, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentGcra1Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentGcra1Violations.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentGcra1Violations.setDescription('The counter associated with the number of cells violating GCRA1, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentRxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentRxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentRxAIS.setDescription('The counter associated with the number of received AIS cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentTxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentTxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTxAIS.setDescription('The counter associated with the number of transmitted AIS cells, encountered by the VCL of this ATM interface in the current 15 minute interval. Not Supported in the first phase.')
atmVcCurrentRxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentRxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentRxRDI.setDescription('The counter associated with the number of received RDI cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentTxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentTxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTxRDI.setDescription('The counter associated with the number of transmitted RDI cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentContinuityLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentContinuityLoss.setDescription('The counter associated with the number of loss of continuity cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentUAS.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentSES.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentSES.setDescription('The counter associated with the number of Severerly Errored Seconds, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcCurrentCDC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentCDC.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentCDC.setDescription('Amount of cells dropped in the current 15 minute interval of the VC connection.')
atmVcCurrentTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVcCurrentClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 an discarded by the traffic policing entity.')
atmVcCurrentTotalCellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VPL. This includes both CLP=0 and CLP=1 cells.')
atmVcCurrentClp0CellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VPL.')
atmVcCurrentTaggedOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentTaggedOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentTaggedOuts.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1 and transmitted by this VPL.')
atmVcCurrentPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentPCR.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentPCR.setDescription('The maximum traffic rate encountered in the last interval of the VC connection (monitored once a second).')
atmVcCurrentSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentSCR.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentSCR.setDescription('The average traffic rate during the last interval of the VC connection.')
atmVcCurrentMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentMCR.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentMCR.setDescription('MCR - The minimum traffic rate encountered in the last interval of the VC connection (monitored once a second).')
atmVcCurrentShaperTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentShaperTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentShaperTotalDiscards.setDescription('The total number of cells (CLP0 and CLP1) discarded due to congestion by the traffic shaper.')
atmVcCurrentShaperClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentShaperClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentShaperClp0Discards.setDescription('The total number of CLP0 cells discarded due to congestion by the traffic shaper.')
atmVcCurrentShaperClp1Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCurrentShaperClp1Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcCurrentShaperClp1Discards.setDescription('The total number of CLP1 cells discarded due to congestion by the traffic shaper.')
atmVcPMCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2), )
if mibBuilder.loadTexts: atmVcPMCurrentTable.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentTable.setDescription('The ATM VC Current table for Performance Management.')
atmVcPMCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVcPMCurrentVpi"), (0, "RAD-MIB", "atmVcPMCurrentVci"), (0, "RAD-MIB", "atmVcPMCurrentDir"))
if mibBuilder.loadTexts: atmVcPMCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentEntry.setDescription('An entry in the ATM VC Current table for Performance Management.')
atmVcPMCurrentVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentVpi.setDescription('The VPI of the VCL.')
atmVcPMCurrentVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentVci.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentVci.setDescription('The VCI of the VCL.')
atmVcPMCurrentDir = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentDir.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentDir.setDescription('The direction of Performance Management.')
atmVcPMCurrentTxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentTxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentTxClp01.setDescription('The counter associated with the number of transmitted CLP 0+1 cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentTxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentTxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentTxClp0.setDescription('The counter associated with the number of transmitted CLP 0 cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentRxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentRxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentRxClp01.setDescription('The counter associated with the number of received CLP 0+1 cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentRxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentRxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentRxClp0.setDescription('The counter associated with the number of received CLP 0 cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentErroredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentErroredCells.setDescription('The counter associated with the number of errored cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentLostCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentLostCells.setDescription('The counter associated with the number of lost cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentMisinsertedCells.setDescription('The counter associated with the number of misinserted cells, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentECB.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentECB.setDescription('The counter associated with the number of ECBs encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentSECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentSECB.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentSECB.setDescription('The counter associated with the number of SECBs encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentES.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentES.setDescription('The counter associated with the number of Errored Seconds, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentSES.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentSES.setDescription('The counter associated with the number of Severely Errored Seconds, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentUAS.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentUAS.setDescription('The counter associated with the number of Severely Errored Seconds, encountered by the VCL of this ATM interface in the current 15 minute interval.')
atmVcPMCurrentIntervalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normal", 2), ("unacceptable", 3))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentIntervalQuality.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentIntervalQuality.setDescription(' If the number of errors per interval is superior to the atmNteUPLTCR value, the quality of service of the interval is declared as unacceptable.')
atmVcPMCurrentLastDayQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("normal", 2), ("degraded", 4))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMCurrentLastDayQuality.setStatus('current')
if mibBuilder.loadTexts: atmVcPMCurrentLastDayQuality.setDescription(' If the number of errors per 24 hours is superior to the atmNteDPLTCR value, the quality of service of the day is declared as degraded.')
atmVcIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3), )
if mibBuilder.loadTexts: atmVcIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTable.setDescription('The ATM Vc Interval table.')
atmVcIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVcIntervalVpi"), (0, "RAD-MIB", "atmVcIntervalVci"), (0, "RAD-MIB", "atmVcIntervalNumber"))
if mibBuilder.loadTexts: atmVcIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalEntry.setDescription('An entry in the ATM Vc Interval table.')
atmVcIntervalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalVpi.setDescription('The VPI of the VCL.')
atmVcIntervalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalVci.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalVci.setDescription('The VCI of the VCL.')
atmVcIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmVcIntervalRxCellsClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalRxCellsClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalRxCellsClp01.setDescription('The counter associated with the number of transmitted cells , encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalRxCellsClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalRxCellsClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalRxCellsClp0.setDescription('The counter associated with the number of received cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalGcra0Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalGcra0Violations.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalGcra0Violations.setDescription('The counter associated with the number of cells violating GCRA0, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalGcra1Violations = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalGcra1Violations.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalGcra1Violations.setDescription('The counter associated with the number of cells violating GCRA1, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalRxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalRxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalRxAIS.setDescription('The counter associated with the number of received AIS cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalTxAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalTxAIS.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTxAIS.setDescription('The counter associated with the number of transmitted AIS cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals. Not supported in the first phase.')
atmVcIntervalRxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalRxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalRxRDI.setDescription('The counter associated with the number of received RDI cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalTxRDI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalTxRDI.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTxRDI.setDescription('The counter associated with the number of transmitted RDI cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalContinuityLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalContinuityLoss.setDescription('The counter associated with the number of Continuity Loss cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalUAS.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalSES.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalSES.setDescription('The counter associated with the number of Severerly Errored Seconds, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalCDC = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalCDC.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalCDC.setDescription('Amount of cells dropped in the 15 minute interval of the VC connection.')
atmVcIntervalTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVcIntervalClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 an discarded by the traffic policing entity.')
atmVcIntervalTotalCellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VPL. This includes both CLP=0 and CLP=1 cells.')
atmVcIntervalClp0CellOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VPL.')
atmVcIntervalTaggedOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalTaggedOuts.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalTaggedOuts.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1 and transmitted by this VPL.')
atmVcIntervalPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalPCR.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalPCR.setDescription('The maximum traffic rate encountered in the last interval of the VC connection (monitored once a second) encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalSCR.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalSCR.setDescription('The average traffic rate during the last interval of the VC connection, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalMCR.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalMCR.setDescription('MCR - The minimum traffic rate encountered in the last interval of the VC connection (monitored once a second) encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcIntervalShaperTotalDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalShaperTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalShaperTotalDiscards.setDescription('The total number of cells (CLP0 and CLP1) discarded due to congestion by the traffic shaper.')
atmVcIntervalShaperClp0Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalShaperClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalShaperClp0Discards.setDescription('The total number of CLP0 cells discarded due to congestion by the traffic shaper.')
atmVcIntervalShaperClp1Discards = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 3, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcIntervalShaperClp1Discards.setStatus('current')
if mibBuilder.loadTexts: atmVcIntervalShaperClp1Discards.setDescription('The total number of CLP1 cells discarded due to congestion by the traffic shaper.')
atmVcPMIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4), )
if mibBuilder.loadTexts: atmVcPMIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalTable.setDescription('The ATM Vc Interval table for Performance Management.')
atmVcPMIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "atmVcPMIntervalVpi"), (0, "RAD-MIB", "atmVcPMIntervalVci"), (0, "RAD-MIB", "atmVcPMIntervalDir"), (0, "RAD-MIB", "atmVcPMIntervalNumber"))
if mibBuilder.loadTexts: atmVcPMIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalEntry.setDescription('An entry in the ATM Vc Interval table for Performance Management.')
atmVcPMIntervalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalVpi.setDescription('The VPI of the VCL.')
atmVcPMIntervalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalVci.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalVci.setDescription('The VCI of the VCL.')
atmVcPMIntervalDir = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("forward", 2), ("backward", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalDir.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalDir.setDescription('The direction of Performance Management.')
atmVcPMIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmVcPMIntervalTxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalTxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalTxClp01.setDescription('The counter associated with the number of transmitted CLP 0+1 cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalTxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalTxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalTxClp0.setDescription('The counter associated with the number of transmitted CLP 0 cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalRxClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalRxClp01.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalRxClp01.setDescription('The counter associated with the number of received CLP 0+1 cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalRxClp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalRxClp0.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalRxClp0.setDescription('The counter associated with the number of received CLP 0 cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalErroredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalErroredCells.setDescription('The counter associated with the number of Errored cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalLostCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalLostCells.setDescription('The counter associated with the number of Lost cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalMisinsertedCells.setDescription('The counter associated with the number of Misinserted cells, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalECB.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalECB.setDescription('The counter associated with the number of ECBs encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalSECB = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalSECB.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalSECB.setDescription('The counter associated with the number of SECBs encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalES.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalES.setDescription('The counter associated with the number of Errored Seconds, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalSES.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalSES.setDescription('The counter associated with the number of Severely Errored Seconds, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalUAS.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalUAS.setDescription('The counter associated with the number of Unavailable Seconds, encountered by an ATM interface/VC in one of the previous 96, individual 15 minute, intervals.')
atmVcPMIntervalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normal", 2), ("unacceptable", 3))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalQuality.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalQuality.setDescription(' If the number of errors per interval is superior to the atmNteUPLTCR value, the quality of service of the interval is declared as unacceptable.')
atmVcPMIntervalLastDayQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("normal", 2), ("degraded", 4))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMIntervalLastDayQuality.setStatus('current')
if mibBuilder.loadTexts: atmVcPMIntervalLastDayQuality.setDescription(' If the number of errors per 24 hours is superior to the atmNteDPLTCR value, the quality of service of the day is declared as degraded.')
atmVcQoSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 6), )
if mibBuilder.loadTexts: atmVcQoSTable.setStatus('current')
if mibBuilder.loadTexts: atmVcQoSTable.setDescription('The ATM VP QoS table.')
atmVcQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "RAD-MIB", "atmVcQoSPeriodRef"))
if mibBuilder.loadTexts: atmVcQoSEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcQoSEntry.setDescription('An entry in the ATM VP table.')
atmVcQoSPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcQoSPeriodRef.setStatus('current')
if mibBuilder.loadTexts: atmVcQoSPeriodRef.setDescription('This object is an index that specifies which period of time, the next 2 objects refer to. currentPeriod - the period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. lastPeriod - the period between last two commands of systemResetAllStatsCmd. - If only one command occurred since Start-up: the period between Start-up and last command. - If no command occurred since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
atmVcQoSElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcQoSElapsedTime.setStatus('current')
if mibBuilder.loadTexts: atmVcQoSElapsedTime.setDescription('Elapsed Time in seconds. - for atmVcQoSPeriodRef = currentPeriod: The period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. - for atmVcQoSPeriodRef = lastPeriod: The value of atmVcQoSElapsedTime when last systemResetAllStatsCmd was received.')
atmVcQoSUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcQoSUAS.setStatus('current')
if mibBuilder.loadTexts: atmVcQoSUAS.setDescription('Number of Unavailable Seconds for the reference period (atmVcQoSPeriodRef).')
atmVcPMQoSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7), )
if mibBuilder.loadTexts: atmVcPMQoSTable.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSTable.setDescription('The PM VC QoS table.')
atmVcPMQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "RAD-MIB", "atmVcPMQoSDirection"), (0, "RAD-MIB", "atmVcPMQoSPeriodRef"))
if mibBuilder.loadTexts: atmVcPMQoSEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSEntry.setDescription('An entry in the VC PM QoS table.')
atmVcPMQoSDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("forward", 2), ("backward", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMQoSDirection.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSDirection.setDescription('The direction of performance management.')
atmVcPMQoSPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMQoSPeriodRef.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSPeriodRef.setDescription('This object is an index that specifies which period of time, the next 5 objects refer to. currentPeriod - the period since last systemResetAllStatsCmd received or since Start-up (if no systemResetAllStatsCmd was received since Start-up) until now. lastPeriod - the period between last two commands of systemResetAllStatsCmd. - If only one command occurred since Start-up: the period between Start-up and last command. - If no command occurred since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
atmVcPMQoSCLR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMQoSCLR.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSCLR.setDescription('Cell Loss Ratio counter for the reference period (atmVcPMQoSPeriodRef)- defined in accordance with I.356 , in %. The value will be multipuled by 100.')
atmVcPMQoSCER = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMQoSCER.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSCER.setDescription('Cell Error Ratio counter for the reference period (atmVcPMQoSPeriodRef) defined in accordance with I.356 , in %. The value will be multipuled by 100.')
atmVcPMQoSCMR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPMQoSCMR.setStatus('current')
if mibBuilder.loadTexts: atmVcPMQoSCMR.setDescription('Cell Miss-insertion Ratio counter for the reference period (atmVcPMQoSPeriodRef) defined in accordance with I.356 , cells/sec .')
atmVcShaperStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8), )
if mibBuilder.loadTexts: atmVcShaperStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperStatTable.setDescription('The ATM VC shaper statistics table.')
atmVcShaperStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVcShaperStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperStatEntry.setDescription('An entry in the ATM VC shaper statistics table.')
atmVcShaperDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperDiscarded.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperDiscarded.setDescription('The number of Cells that were discarded in the shaper on that VCC due to buffer overflow. This counter counts till it reaches its MAX value (20 bits) and then rolls over.')
atmVcShaperOccupation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperOccupation.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperOccupation.setDescription('The number of Cells that are currently stored in the buffer. This parameter is limited to 20 bits.')
atmVcShaperMaxOccupation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperMaxOccupation.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperMaxOccupation.setDescription('The Maximum number of Cells that were stored in the buffer, since this VC was activated. This parameter is limited to 20 bits.')
atmVcShaperLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("empty", 1), ("full", 2), ("below", 3), ("above", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperLevel.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperLevel.setDescription('The occupation of the buffer according to a predefined threshold. empty - buffer is Empty full - buffer is Full below - buffer is Below the threshold above - buffer is Above the threshold. This is also the trigger to start EPD\\PPD mechanism, if set for the VCC.')
atmVcShaperEpdDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperEpdDropped.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperEpdDropped.setDescription('The number of Cells that were dropped in the shaper on that VCC due to EPD\\PPD mechanism in the last second. This parameter is limited to 24 bits. Applicable for a EPD/PPD VC only.')
atmVcShaperTotalEpdDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 2, 2, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcShaperTotalEpdDropped.setStatus('current')
if mibBuilder.loadTexts: atmVcShaperTotalEpdDropped.setDescription('The Total number of Cells that were dropped in the shaper on that VPC due to EPD\\PPD mechanism in the last 15 minutes. This counter automatically reset itself every 15 minutes. Applicable for a EPD/PPD VC only.')
atmIntervalDateTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 3), )
if mibBuilder.loadTexts: atmIntervalDateTable.setStatus('current')
if mibBuilder.loadTexts: atmIntervalDateTable.setDescription('The agent will keep in this group the date & time corresponding to each interval.')
atmIntervalDateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 3, 1), ).setIndexNames((0, "RAD-MIB", "atmIntervalDateInterval"))
if mibBuilder.loadTexts: atmIntervalDateEntry.setStatus('current')
if mibBuilder.loadTexts: atmIntervalDateEntry.setDescription('The date & time for the given interval.')
atmIntervalDateInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntervalDateInterval.setStatus('current')
if mibBuilder.loadTexts: atmIntervalDateInterval.setDescription(' The interval number defining this entry.')
atmIntervalDateDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntervalDateDate.setStatus('current')
if mibBuilder.loadTexts: atmIntervalDateDate.setDescription('The date corresponding to this interval.')
atmIntervalDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 1, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntervalDateTime.setStatus('current')
if mibBuilder.loadTexts: atmIntervalDateTime.setDescription('The time corresponding to this interval.')
atmNteSys = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1))
atmNteSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1))
atmNteManagerTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1), )
if mibBuilder.loadTexts: atmNteManagerTable.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerTable.setDescription('The Manager Table includes all the NMSs that receive traps from this agent. A single manager can receive traps on more than one PVC. The agent will set implicitly the correct ifIndex, VPI, VCI values to all relevant entries in the table when the user changes them for one of the PVCs.')
atmNteManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmNteManagerIP"), (0, "RAD-MIB", "atmNteManagerPvc"))
if mibBuilder.loadTexts: atmNteManagerEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerEntry.setDescription('A single manager and the PVC for receiving traps.')
atmNteManagerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteManagerIP.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerIP.setDescription('The IP address of the NMS.')
atmNteManagerPvc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteManagerPvc.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerPvc.setDescription('A PVC index. The range is 1..8. There are four PVCs on the User Port and four PVCs on the Network Port. The default VPI, VCI values are specified below.')
atmNteManagerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerIfIndex.setDescription('The ATM interface index of the management port.')
atmNteManagerVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerVpi.setDescription('The VPI of the management VCL. Default: 0.')
atmNteManagerVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerVci.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerVci.setDescription('The VCI of the management VCL. Defaults: 32,33,34,35.')
atmNteManagerTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerTrapMask.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerTrapMask.setDescription("The value of this attribute determines the type of traps the agent should mask and not send to this NMS. The value is differently determined for different products. There are mainly two methods: - an integer number, specifying the traps' severity. - a sum of 2**n, where n is a bit assigned to a certain masked trap group. User should consult the product specification, to find out the method employed.")
atmNteManagerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerRowStatus.setDescription('Creation/Deletion of rows in the table.')
atmNteManagerNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerNextHop.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerNextHop.setDescription('This parameter is relevant to Ethernet out of band host only (PVC=10). The Next Hop IP address of the entry route.')
atmNteManagerVlanSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerVlanSupport.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerVlanSupport.setDescription('VLAN support (Tagging). no - No support to VLAN. yes - 4 VLAN bytes will be added to the frame.')
atmNteManagerVlanIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerVlanIdentifier.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerVlanIdentifier.setDescription('VLAN ID. Range is 0..4095.')
atmNteManagerVlanFramePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerVlanFramePriority.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerVlanFramePriority.setDescription('VLAN Frame priority.Range is 0..7.')
atmNteManagerAlarmTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 12), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerAlarmTrapMask.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerAlarmTrapMask.setDescription('The value of this object determines the alarm traps that the agent should mask and not send to this NMS. The value is an Octet String, where each bit is assigned to a certain trap. If the bit = 1, the trap will be masked. If the bit = 0, the trap will not be masked. More details on the masked traps exist in the product specification. For products that do not mask specific traps, the value of the bits will be 0.')
atmNteManagerConfigPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 1, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteManagerConfigPorts.setStatus('current')
if mibBuilder.loadTexts: atmNteManagerConfigPorts.setDescription('This variable defines from which port/s this manager can configure the device. For IPmux 11 the value of this variable will be according to the ports combination: Network =1 User1=2 User2=4 (For Example: All ports = 7).')
atmNteUPLTCR = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteUPLTCR.setStatus('current')
if mibBuilder.loadTexts: atmNteUPLTCR.setDescription('The Unacceptable ES Limit threshold for Performance Management.')
atmNteDPLTCR = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteDPLTCR.setStatus('current')
if mibBuilder.loadTexts: atmNteDPLTCR.setDescription('The Degraded ES Limit threshold for Performance Management.')
atmNteSysLogClearAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteSysLogClearAll.setStatus('current')
if mibBuilder.loadTexts: atmNteSysLogClearAll.setDescription('Setting the variable to clear(3) removes all entries in the Log Buffer of the agent. The agent will immediately reset the variable to off(2).')
atmNteUSESLTCR = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteUSESLTCR.setStatus('current')
if mibBuilder.loadTexts: atmNteUSESLTCR.setDescription('The Unacceptable SES Limit threshold for Performance Management.')
atmNteDSESLTCR = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteDSESLTCR.setStatus('current')
if mibBuilder.loadTexts: atmNteDSESLTCR.setDescription('The Degraded ES Limit threshold for Performance Management.')
atmNteProtection = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 8))
atmNteProtectionMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("mspOn", 2), ("pathOn", 3), ("mspUniOn", 4), ("mspOneToN", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteProtectionMode.setStatus('current')
if mibBuilder.loadTexts: atmNteProtectionMode.setDescription('Protection Mode. MspOn - Multiplex section protection. pathOn - High order path protection. mspUniOn - Multiplex section Uni-directional protection. mspOneToN - Multiplex section protection.')
atmNteProtectionWorkingLink = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("trunk1", 2), ("trunk2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteProtectionWorkingLink.setStatus('current')
if mibBuilder.loadTexts: atmNteProtectionWorkingLink.setDescription('Selects the working link when atmNteProtectionMode is off.')
atmNteProtectionSwitchLink = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("forceSwitch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteProtectionSwitchLink.setStatus('current')
if mibBuilder.loadTexts: atmNteProtectionSwitchLink.setDescription('ForceSwitch - will force Switching from the working link to the backup link. Afterwards the agent will set atmNteProtectionSwitchLink back to off(1). atmNteProtectionMode must be either mspOn or pathOn.')
atmNteConfOam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9))
atmNteConfOamSupport = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("intermediate", 1), ("segmentTermination", 2), ("endToEndTermination", 3), ("vpEndToEndVcSegment", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfOamSupport.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamSupport.setDescription('OAM support mode, which determines the device location in a segment wise.')
atmNteConfOamTransmission = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 2))
atmNteConfOamAIS = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("user", 2), ("network", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfOamAIS.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamAIS.setDescription("Defines if a F4 segment OAM cell is transmitted due to problems in the other port, i.e. physical layer alarm or F4 defect. This is valid only when the ACE101 has ATM UNI interfaces in both sides and is configured for 'Non-Intrusive' mode. none - AIS is not sent to any of the ports. user - F4 AIS will be sent toward the user when defect is detected in the network port. network - F4 AIS will be sent toward the network when defect is detected in the user port. both - F4 AIS will be sent toward the network when defect is detected in the user port and toward the user when defect is detected in the network port.")
atmNteConfOamRDI = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("user", 2), ("network", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfOamRDI.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamRDI.setDescription('Defines if an F4 OAM RDI cell is transmitted due to physical layer problems in the port (in addition to F4 RDI cells transmitted due to ATM layer problems). The type of F4 RDI (Segment or End-to-End) is according to the ACE-101 OAM mode. For example, If it is enabled for Network port, then physical layer defect will initiate the transmission of F4 RDI cell back to the trunk.')
atmNteConfOamAddressing = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 3))
atmNteConfLoopbackAddMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfLoopbackAddMode.setStatus('current')
if mibBuilder.loadTexts: atmNteConfLoopbackAddMode.setDescription('Loopback addressing mode. on - will enable loopback addressing. off - will disable loopback addressing.')
atmNteConfLoopbackSourceAdd = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfLoopbackSourceAdd.setStatus('current')
if mibBuilder.loadTexts: atmNteConfLoopbackSourceAdd.setDescription(' Loopback source address. This field is relevant when atmNteConfOamAddMode is on.')
atmNteConfOamIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 4), )
if mibBuilder.loadTexts: atmNteConfOamIfTable.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamIfTable.setDescription('OAM support per ATM interface.')
atmNteConfOamIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmNteConfOamIfEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamIfEntry.setDescription('.')
atmNteConfOamIfAisRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfOamIfAisRdi.setStatus('current')
if mibBuilder.loadTexts: atmNteConfOamIfAisRdi.setDescription('This parameter controls the generation of F4/F5 AIS and RDI due to lower order problems such as physical layer problems. For AIS: Defines if F4/F5 AIS cell is transmitted due to problems such as physical layer alarm or F4/F5 defect. This is applicable for all ports . off - Problems in this port will not trigger F4/F5 AIS transmition to the ajacent port (e.g. from USER to NETWORK) of a VPC/VCC. on - Problems in this port will trigger F4/F5 AIS transmition to the ajacent port (e.g. from USER to NETWORK) of a VPC/VCC. For RDI: Defines if F4/F5 RDI cell will be transmitted due to physical layer problems in that port (in addition to F4/F5 RDI cells transmitted due to ATM layer problems). For example, If it is enabled for Network port, then physical layer defect will initiate the transmission of F4/F5 RDI cell back to the trunk. The type of F4/F5 (Segment or End-to-End) is according to the configuration of the VPC/VCC.')
atmNteConfCAC = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 10))
atmNteConfCACMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConfCACMode.setStatus('current')
if mibBuilder.loadTexts: atmNteConfCACMode.setDescription('CAC support mode. For ACE2002, the following are the applicable values: disable(1), enable(2), 10 - 1000.')
atmNteHostIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11), )
if mibBuilder.loadTexts: atmNteHostIfTable.setStatus('current')
if mibBuilder.loadTexts: atmNteHostIfTable.setDescription('Host IP interface table.')
atmNteHostIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1), ).setIndexNames((0, "RAD-MIB", "atmNteHostPvcIndex"))
if mibBuilder.loadTexts: atmNteHostIfEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteHostIfEntry.setDescription('.')
atmNteHostPvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteHostPvcIndex.setStatus('current')
if mibBuilder.loadTexts: atmNteHostPvcIndex.setDescription('A PVC index. The range is 1..10.')
atmNteHostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostIP.setStatus('current')
if mibBuilder.loadTexts: atmNteHostIP.setDescription('The host interface IP address.')
atmNteHostMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostMask.setStatus('current')
if mibBuilder.loadTexts: atmNteHostMask.setDescription('The host interface subnet mask.')
atmNteHostAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostAtmIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmNteHostAtmIfIndex.setDescription('ATM interface index. Will be 1 for user port, and 2 for network port.')
atmNteHostVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteHostVpi.setDescription('VPI of the PVC connected to that host interface.')
atmNteHostVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostVci.setStatus('current')
if mibBuilder.loadTexts: atmNteHostVci.setDescription('VCI of the PVC connected to that host interface.')
atmNteHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmNteHostRowStatus.setDescription('Creation/Deletion of rows in the table.')
atmNteHostRdnVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostRdnVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteHostRdnVpi.setDescription('The VPI of the redundant management VCL. This parameter is applicable only if atmNteRdnManagement=enable(3). ')
atmNteHostRdnVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostRdnVci.setStatus('current')
if mibBuilder.loadTexts: atmNteHostRdnVci.setDescription('The VCI of the redundant management VCL. This parameter is applicable only if atmNteRdnManagement=enable(3). ')
atmNteHostDefaultNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 10), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostDefaultNextHop.setStatus('current')
if mibBuilder.loadTexts: atmNteHostDefaultNextHop.setDescription('The host interface Default Next Hop address. This address will be used as default next hop for every Bundle mapped to this Host.')
atmNteHostVlanTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostVlanTagging.setStatus('current')
if mibBuilder.loadTexts: atmNteHostVlanTagging.setDescription('VLAN Tag support. no - No support to VLAN. yes - 4 VLAN bytes will be added to each frame connected to this Host.')
atmNteHostDefaultVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostDefaultVlanID.setStatus('current')
if mibBuilder.loadTexts: atmNteHostDefaultVlanID.setDescription('Default VLAN ID of this Host.')
atmNteHostDefaultVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 11, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmNteHostDefaultVlanPriority.setStatus('current')
if mibBuilder.loadTexts: atmNteHostDefaultVlanPriority.setDescription('Default VLAN priority for this Host.')
atmNteShaperMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("group", 2), ("aggregate", 3), ("vpInbandMng", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteShaperMode.setStatus('current')
if mibBuilder.loadTexts: atmNteShaperMode.setDescription('Shaper Mode. vpInbandMng - Vcc within a Vp for management.')
atmNteOutputRate = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteOutputRate.setStatus('current')
if mibBuilder.loadTexts: atmNteOutputRate.setDescription('Aggregate shaping output rate in Cells per Seconds units. Default value is the Network port rate.')
atmNteTosMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteTosMode.setStatus('current')
if mibBuilder.loadTexts: atmNteTosMode.setDescription('TOS Mode.')
atmNteTosMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteTosMask.setStatus('current')
if mibBuilder.loadTexts: atmNteTosMask.setDescription('This parameter determines the seqence of bits that will be used for TOS. For ACE101 this parameter is applicable only if atmNteTosMode = enable. Valid only for IP-TOS process.')
atmNteTosHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteTosHighPriority.setStatus('current')
if mibBuilder.loadTexts: atmNteTosHighPriority.setDescription('Priorities options are High or Low. High priority will be represented by bit = 1. Low priority will be represented by bit = 0. Each TOS value will be represented by the bit location. For example, the string for TOS 2, 9, 15 with High priority, will be: |0000 0000|... ...|0000 0000|1000 0010|0000 0100| ...98 7654 3210 (Bit #) 8 ... 3 2 1 (Byte #).')
atmNtePlugAndPlayActivity = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("offline", 2), ("online", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNtePlugAndPlayActivity.setStatus('current')
if mibBuilder.loadTexts: atmNtePlugAndPlayActivity.setDescription('Activity control for Manager Plug And Play. disable - disable the feature. offline - Automatic learn IP address into offline memory. online - Automatic learn IP address into online memory. ')
atmNteSlotUsage = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("user", 2), ("network", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteSlotUsage.setStatus('current')
if mibBuilder.loadTexts: atmNteSlotUsage.setDescription('Applicable to ace2002. Slot 2 might be configured as user slot or as network slot.')
atmNteConnectionsMaxNumber = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("max1024", 2), ("max2048", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteConnectionsMaxNumber.setStatus('current')
if mibBuilder.loadTexts: atmNteConnectionsMaxNumber.setDescription('The MAX number of connections supported by system. Setting this parameter will affect the number of MAX intervals supported. This parameter will affect the system only after reset. Changing this parameter from high value to a low value, will be accepted by agent only if the actual used connection <= the desired connection Max number. Applicable to ace2002. ')
atmNteDefaultVpi = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteDefaultVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteDefaultVpi.setDescription('Default Vpi for management.')
atmNteDefaultVci = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteDefaultVci.setStatus('current')
if mibBuilder.loadTexts: atmNteDefaultVci.setDescription('Default Vci for management.')
atmNteReservedVpi = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteReservedVpi.setStatus('current')
if mibBuilder.loadTexts: atmNteReservedVpi.setDescription('Internal use VPI, where shaperMode=vpInbandMng.')
atmNteRdnManagement = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteRdnManagement.setStatus('current')
if mibBuilder.loadTexts: atmNteRdnManagement.setDescription('The redundancy management status.')
atmNtePlugAndPlayIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 24), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNtePlugAndPlayIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmNtePlugAndPlayIfIndex.setDescription('The ifIndex of the Plug and Play VCC.')
atmNteLoopbackTimeout = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteLoopbackTimeout.setStatus('current')
if mibBuilder.loadTexts: atmNteLoopbackTimeout.setDescription('The Loopback state timeout in minutes. A value of zero means no timeout (for ever). Default is 5 min.')
atmNteOamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26), )
if mibBuilder.loadTexts: atmNteOamTable.setStatus('current')
if mibBuilder.loadTexts: atmNteOamTable.setDescription('This table is a static table, which is created by agent once upon initialization. The created entries are actually, only the supported OAM features. This table enables addition of new features by adding new entries rather than adding scalar parameters. An OAM feature is defined by the indexes values combination.')
atmNteOamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26, 1), ).setIndexNames((0, "RAD-MIB", "atmNteOamMode"), (0, "RAD-MIB", "atmNteOamCellType"), (0, "RAD-MIB", "atmNteOamLevel"))
if mibBuilder.loadTexts: atmNteOamEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteOamEntry.setDescription('An entry in the OAM table. Each entry in this table will indicate a special OAM.')
atmNteOamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("endToEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteOamMode.setStatus('current')
if mibBuilder.loadTexts: atmNteOamMode.setDescription('The OAM cell path. endToEnd(1) - the entire path.')
atmNteOamCellType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aisAndRdi", 1), ("loopback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteOamCellType.setStatus('current')
if mibBuilder.loadTexts: atmNteOamCellType.setDescription('This object indicates a unique Indication Signal. aisAndRdi(1) - Alarm Indication Signal (AIS) and Remote Defect Indication (RDI) cell. loopback(2) - Loopback cell.')
atmNteOamLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("f5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteOamLevel.setStatus('current')
if mibBuilder.loadTexts: atmNteOamLevel.setDescription('The level of the OAM cell. -- f4 (2) - VP level, f5 (3) - VC level.')
atmNteOamEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 26, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteOamEnable.setStatus('current')
if mibBuilder.loadTexts: atmNteOamEnable.setDescription('This parameter determines if the specified OAM cells will be enabled.')
atmNteDefaultLoopbackThreshold = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteDefaultLoopbackThreshold.setStatus('current')
if mibBuilder.loadTexts: atmNteDefaultLoopbackThreshold.setDescription('The Default OAM Loopback Failure Threshold value that will be used for configuration.')
atmNteMaxBurstSize = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: atmNteMaxBurstSize.setDescription('The Maximum allowed burst size (cell units). This object is applicable for each Physical port.')
atmNteGranularityFactor = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteGranularityFactor.setStatus('current')
if mibBuilder.loadTexts: atmNteGranularityFactor.setDescription('This parameter affects the granularity of the guaranteed Rate (SCR+MCR) in spaced connection (cell/sec units). It is also defines the minimum guaranteed rate in spaced connection.')
atmNteTotalInputRate = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteTotalInputRate.setStatus('current')
if mibBuilder.loadTexts: atmNteTotalInputRate.setDescription('This parameter indicates the total input rate of the device in cells/sec.')
atmNteTotalOutputRate = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteTotalOutputRate.setStatus('current')
if mibBuilder.loadTexts: atmNteTotalOutputRate.setDescription('This parameter indicates the total output rate of the device in cells/sec.')
atmAlarmForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32), )
if mibBuilder.loadTexts: atmAlarmForwardingTable.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingTable.setDescription('The Alarm Forwarding Mechanism will be operated for this table entries.')
atmAlarmForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1), ).setIndexNames((0, "RAD-MIB", "atmAlarmForwardingFailPort"), (0, "RAD-MIB", "atmAlarmForwardingToPort"))
if mibBuilder.loadTexts: atmAlarmForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingEntry.setDescription('Each entry in this table is a pair of ports that the Alarm Forwarding Mechanism is determined for.')
atmAlarmForwardingFailPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 1), Integer32())
if mibBuilder.loadTexts: atmAlarmForwardingFailPort.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingFailPort.setDescription('An Index of the port on which a fail occurs.')
atmAlarmForwardingToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 2), Integer32())
if mibBuilder.loadTexts: atmAlarmForwardingToPort.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingToPort.setDescription('An Index of the port that will be affected upon the failure of the atmAlarmForwardingFailPort.')
atmAlarmForwardingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmAlarmForwardingRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingRowStatus.setDescription('Creation/Deletion of rows in the table.')
atmAlarmForwardingFailureLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 4), Bits().clone(namedValues=NamedValues(("physical", 0), ("atm", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmAlarmForwardingFailureLevel.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingFailureLevel.setDescription('This parameter determines the level of failure that will operate the Alarm Forwarding Mechanism.')
atmAlarmForwardingRecoveryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmAlarmForwardingRecoveryMode.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingRecoveryMode.setDescription('This parameter determines the Recovery Mode. manual - The user should stop the RDI transmission by using the atmAlarmForwardingRecoveryCommand. automatic - The RDI transmission will be automatically stopped upon atmAlarmForwardingFailPort recovery.')
atmAlarmForwardingRecoveryCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmAlarmForwardingRecoveryCommand.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingRecoveryCommand.setDescription("This parameter is a command. It is applicable when atmAlarmForwardingRecoveryMode = manual. on - Will stop the RDI transmission. After setting to 'On' the agent will set this parameter back to 'Off'.")
atmAlarmForwardingTimeFilterWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 32, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmAlarmForwardingTimeFilterWindow.setStatus('current')
if mibBuilder.loadTexts: atmAlarmForwardingTimeFilterWindow.setDescription('This parameter determines the Time Filter Window, meaning: how much time (in seconds) should the alarm exist in order to start the Alarm Forwarding operation.')
atmSysConfigCellTest = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33))
atmSysConfigCellTestPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestPort.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestPort.setDescription('An Index of the port on which the cell test will be sent.')
atmSysConfigCellTestVpi = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestVpi.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestVpi.setDescription('The VPI on which the cell test will be sent.')
atmSysConfigCellTestVci = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestVci.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestVci.setDescription('The VCI on which the cell test will be sent.')
atmSysConfigCellTestPti = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user", 1), ("oamSegment", 2), ("oamEndToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestPti.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestPti.setDescription('The cell type.')
atmSysConfigCellTestClp = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clp0", 1), ("clp1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestClp.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestClp.setDescription('The type of the Cell.')
atmSysConfigCellTestOamType = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ais", 1), ("rdi", 2), ("cc", 3), ("lb", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestOamType.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestOamType.setDescription('The OAM type of the Cell. This object is applicable if atmSysConfigCellTestPti = oamSegment/oamEndToEnd .')
atmSysConfigCellTestPayload = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestPayload.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestPayload.setDescription('The payload of the cell. For OAM cell the payload is set automatically to 6A.')
atmSysConfigCellTestQuantity = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestQuantity.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestQuantity.setDescription('Quantity of cells to send.')
atmSysConfigCellTestSendCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 33, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("send", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSysConfigCellTestSendCmd.setStatus('current')
if mibBuilder.loadTexts: atmSysConfigCellTestSendCmd.setDescription('Setting the variable to send(3) perfroms cell test. The agent will immediately reset the variable to off(2).')
atmVpCrossConnectExtenTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 34), )
if mibBuilder.loadTexts: atmVpCrossConnectExtenTable.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectExtenTable.setDescription('An extension to the ATM VP Cross Connect table (RFC2515 - atmVpCrossConnectTable).')
atmVpCrossConnectExtenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 34, 1), )
atmVpCrossConnectEntry.registerAugmentions(("RAD-MIB", "atmVpCrossConnectExtenEntry"))
atmVpCrossConnectExtenEntry.setIndexNames(*atmVpCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVpCrossConnectExtenEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectExtenEntry.setDescription('An entry in the table.')
atmVpCrossConnectName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 34, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectName.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectName.setDescription("The Connection's name.")
atmVcCrossConnectExtenTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 35), )
if mibBuilder.loadTexts: atmVcCrossConnectExtenTable.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectExtenTable.setDescription('An extension to the ATM VC Cross Connect table (RFC2515 - atmVcCrossConnectTable).')
atmVcCrossConnectExtenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 35, 1), )
atmVcCrossConnectEntry.registerAugmentions(("RAD-MIB", "atmVcCrossConnectExtenEntry"))
atmVcCrossConnectExtenEntry.setIndexNames(*atmVcCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVcCrossConnectExtenEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectExtenEntry.setDescription('An entry in the table.')
atmVcCrossConnectName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 35, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectName.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectName.setDescription("The Connection's name.")
atmNteQosMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("multipleVc", 2), ("singleVc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteQosMode.setStatus('current')
if mibBuilder.loadTexts: atmNteQosMode.setDescription('This variable defines the QoS Mode. disable(1) - QoS is disabled. multipleVc(2) - QoS is enabled and multiple VCs can be bound per bridge port. singleVc(3) - QoS is enabled and only single VC can be bound per bridge port.')
atmTrafficDescrParamXTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 38), )
if mibBuilder.loadTexts: atmTrafficDescrParamXTable.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamXTable.setDescription('An Augment to ATM Traffic Descriptor Parameter Table (atmTrafficDescrParamTable in ATM-MIB; RFC-2515).')
atmTrafficDescrParamXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 38, 1), )
atmTrafficDescrParamEntry.registerAugmentions(("RAD-MIB", "atmTrafficDescrParamXEntry"))
atmTrafficDescrParamXEntry.setIndexNames(*atmTrafficDescrParamEntry.getIndexNames())
if mibBuilder.loadTexts: atmTrafficDescrParamXEntry.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamXEntry.setDescription('An entry in the table.')
atmTrafficDescrParamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 1, 38, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scheduling", 1), ("schedulingAndShaping", 2), ("policing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParamMode.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamMode.setDescription('The Mode of the Traffic Descriptor.')
atmNteSysInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2))
atmNteIdTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1), )
if mibBuilder.loadTexts: atmNteIdTable.setStatus('current')
if mibBuilder.loadTexts: atmNteIdTable.setDescription('The IDs of the cards and of the system.')
atmNteIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmNteIdIndex"))
if mibBuilder.loadTexts: atmNteIdEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteIdEntry.setDescription('.')
atmNteIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteIdIndex.setStatus('current')
if mibBuilder.loadTexts: atmNteIdIndex.setDescription('An Index of the Unit ID table. The following units have IDs in this table: 1 - System 2 - ATM Board 3 - User Card 4 - Trunk 1 card 5 - Trunk 2 card 6 - Shaper 7 - Clock Unit 8 - Slot 1 card 9 - Slot 2 card 10 - Slot 3 card 11 - Slot 4 card 12 - Fan1 13 - Fan2 14 - Control Unit.')
atmNteUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteUnitId.setStatus('current')
if mibBuilder.loadTexts: atmNteUnitId.setDescription('The ID of the Unit. For index = 6, the id will describe the validity of a shaper in the system: 0 - Shaper Not exist 1 - Shaper exist. For index = 7, the id will describe the validity of a clock in the system: 0 - Clock Not exist 1 - Clock exist. 2- Clock exist but failed. For index = 12,13 the id will describe the functionality of a FAN1 : 0 - OK 1 - Failed.')
atmNteUnitVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteUnitVersion.setStatus('current')
if mibBuilder.loadTexts: atmNteUnitVersion.setDescription('Hardware and Software version of the module.')
atmNteCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 249, 250, 251, 252, 253, 254, 255))).clone(namedValues=NamedValues(("notApplicable", 1), ("sc13mR155", 2), ("st13sR155", 3), ("st13lR155", 4), ("utpR155", 5), ("cxBncR155", 6), ("e3", 7), ("t3", 8), ("e1", 9), ("e1Ltu", 10), ("fc13lR155", 11), ("fc13lhR155", 12), ("fc15lhR155", 13), ("fc13lE3", 14), ("fc13lhE3", 15), ("fc15lhE3", 16), ("fc13lT3", 17), ("fc13lhT3", 18), ("fc15lhT3", 19), ("t1", 20), ("eth", 21), ("ethE1CesBnc", 22), ("ethE1CesRj45", 23), ("ethT1CesRj45", 24), ("e1CesRj45", 25), ("e1CesBnc", 26), ("t1CesRj45", 27), ("e14Ces", 28), ("e14CesRj45", 29), ("t14CesRj45", 30), ("hdlc4port", 31), ("hdlcE14CesBnc", 32), ("hdlcE14CesRj45", 33), ("hdlcT14CesRj45", 34), ("e1Rj45", 35), ("e1Bnc", 36), ("ethE14CesBnc", 37), ("ethE14CesRj45", 38), ("ethT14CesRj45", 39), ("hdlc1portHssi", 40), ("hdlcHssiE14CesBnc", 41), ("hdlcHssiE14CesRj45", 42), ("hdlcHssiT14CesRj45", 43), ("e14ImaRj45", 44), ("e14ImaBnc", 45), ("t14ImaRj45", 46), ("ethE3CesBnc", 47), ("ethT3CesBnc", 48), ("smSf1R155", 49), ("smSf2R155", 50), ("sc13sR155", 51), ("sc13lR155", 52), ("utp25", 53), ("sc13lhR155", 54), ("sc15lhR155", 55), ("sc13ljR155", 56), ("sc13lhjR155", 57), ("sc15lhjR155", 58), ("e18Ces", 59), ("e18CesRj45", 60), ("t18CesRj45", 61), ("sc13mR622", 62), ("sc13lR622", 73), ("sc13lhR622", 74), ("sc15lhR622", 75), ("fr4Port", 76), ("t3j", 77), ("fr1Port", 78), ("hdlc1Port", 79), ("sc13mR155D", 80), ("sc13lR155D", 81), ("fc13lR155D", 82), ("st13lR155D", 83), ("sc13lhR155D", 84), ("fc13lhR155D", 85), ("st13lhR155D", 86), ("e18ImaBnc", 87), ("e18ImaRj45", 88), ("t18ImaRj45", 89), ("lanUtpE", 90), ("lanLc13lE", 91), ("lanLc13mE", 92), ("e14ImaRj45CfgMode", 93), ("e14ImaBncCfgMode", 94), ("t14ImaRj45CfgMode", 95), ("sc13mR155R", 96), ("sc13lR155R", 97), ("fc13lR155R", 98), ("st13lR155R", 99), ("sc13lhR155R", 100), ("fc13lhR155R", 101), ("st13lhR155R", 102), ("fEthUtpD", 103), ("fEthSmD", 104), ("fEthMmD", 105), ("e14CesRj45Unbal", 106), ("sc13mR155n", 107), ("sc13lR155n", 108), ("sc13lhR155n", 109), ("sc15lhR155n", 110), ("fc13lR155n", 111), ("fc13lhR155n", 112), ("fc15lhR155n", 113), ("st13lR155n", 114), ("lanUtp", 115), ("lanLc13l", 116), ("lanLc13m", 117), ("e1FrHdlc", 118), ("e1FrHdlcUnbal", 119), ("t1FrHdlc", 120), ("channelizedT3", 121), ("fc15lhR155D", 122), ("sc15lhR155D", 123), ("smSf1R155D", 124), ("smSf2R155D", 125), ("smSf3R155D", 126), ("fc15lhR155R", 127), ("sc15lhR155R", 128), ("smSf1R155R", 129), ("smSf2R155R", 130), ("smSf3R155R", 131), ("st13lhR155n", 132), ("smSf1R155n", 133), ("smSf2R155n", 134), ("smSf3R155n", 135), ("t18CesNg", 136), ("e18CesUnbalNg", 137), ("e18CesBalNg", 138), ("t14CesNg", 139), ("e14CesUnbalNg", 140), ("e14CesBalNg", 141), ("t18ImaUniNg", 142), ("e18ImaUniUnbalNg", 143), ("e18ImaUniBalNg", 144), ("t14ImaUniNg", 145), ("e14ImaUniUnbalNg", 146), ("e14ImaUniBalNg", 147), ("t1Ces", 148), ("e1CesUnbal", 149), ("e1CesBal", 150), ("switchedLan", 151), ("channelizedSts1", 152), ("st13mR155", 153), ("st13lhR155", 154), ("st15lhR155", 155), ("gigabitEthUtp", 156), ("gigabitEthSfp", 157), ("fastEthUtp", 158), ("fourStm1oc3SingleGbe", 159), ("main8Atm155TwoEth", 249), ("mainChannelized155", 250), ("main", 251), ("control", 252), ("fan", 253), ("unknown", 254), ("empty", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteCardType.setStatus('current')
if mibBuilder.loadTexts: atmNteCardType.setDescription('The card type.')
atmNteCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("notActive", 2), ("active", 3), ("inProgress", 4), ("empty", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteCardStatus.setStatus('current')
if mibBuilder.loadTexts: atmNteCardStatus.setDescription('Status of the card in the selected slot. notActive - Connections are in NotReady state. No configuration is available for the card. The access to the card HW is blocked. This state is relevant for an extracted card, and for a case in which the card was deactivated. active - The module installed and functions. A card that in this state can be configured. inProgress - The status during proccessing of a command from atmNteCardCmd. empty - No information is valid for the selected slot. This status is relevant to a case in which the card configaration was deleted, or in case in which a slot was empty since the device startup.')
atmNteCardCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("deleteConfig", 2), ("deactivate", 3), ("activate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteCardCmd.setStatus('current')
if mibBuilder.loadTexts: atmNteCardCmd.setDescription('Command on the card that is installed in the selected slot. The commands are applicable according to the value of atmNteCardStatus. See the specification document for details. deleteConfig - Deletes the card configuration. deactivate - All the connections state will be changed to NotReady. The card configuration will be blocked. activate - Does the same as done upon card insertion: Initiates the relevant parameters, activates the physical layer, ATM layer and logical layer.')
atmNteProgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(159, 249, 250, 251, 252, 253, 255, 1001, 1002, 1003))).clone(namedValues=NamedValues(("fourStm1oc3SingleGbe", 159), ("main8Atm155TwoEth", 249), ("mainChannelized155", 250), ("main", 251), ("control", 252), ("fan", 253), ("empty", 255), ("atm155", 1001), ("eth", 1002), ("channelized155", 1003)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteProgCardType.setStatus('current')
if mibBuilder.loadTexts: atmNteProgCardType.setDescription('The programmed card type.')
atmSysPSunits = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysPSunits.setStatus('current')
if mibBuilder.loadTexts: atmSysPSunits.setDescription('The number of power supply units.')
atmSysPSunitsInUse = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("ps1", 2), ("ps2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysPSunitsInUse.setStatus('current')
if mibBuilder.loadTexts: atmSysPSunitsInUse.setDescription('The main power supply in this unit.')
atmSysFanUnits = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysFanUnits.setStatus('current')
if mibBuilder.loadTexts: atmSysFanUnits.setDescription('The number of fan units.')
atmSysNetPrts = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysNetPrts.setStatus('current')
if mibBuilder.loadTexts: atmSysNetPrts.setDescription('The number of network ports.')
atmSysNetPrtInUse = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("trunk1", 2), ("trunk2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysNetPrtInUse.setStatus('current')
if mibBuilder.loadTexts: atmSysNetPrtInUse.setDescription('The network port in use.')
atmNteBridgingMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accessOnly", 1), ("accessAndSwitching", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteBridgingMode.setStatus('current')
if mibBuilder.loadTexts: atmNteBridgingMode.setDescription('Bridging mode can be one of the following: ATM <> Ethernet - Bridging is between the Ethernet port and the ATM port (there is no bridging between VCs). ATM <> Ethernet + ATM - Bridging is done both between the Ethernet port and the ATM port and also between VCs.')
atmSysStats = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8))
atmSysCurrentCdc = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysCurrentCdc.setStatus('current')
if mibBuilder.loadTexts: atmSysCurrentCdc.setDescription('Seconds in which cells dropped was occured in the current 15 minutes interval.')
atmSysIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8, 2), )
if mibBuilder.loadTexts: atmSysIntervalTable.setStatus('current')
if mibBuilder.loadTexts: atmSysIntervalTable.setDescription('The system level Interval table.')
atmSysIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8, 2, 1), ).setIndexNames((0, "RAD-MIB", "atmSysIntervalNumber"))
if mibBuilder.loadTexts: atmSysIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: atmSysIntervalEntry.setDescription('.')
atmSysIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: atmSysIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
atmSysIntervalCdc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 8, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSysIntervalCdc.setStatus('current')
if mibBuilder.loadTexts: atmSysIntervalCdc.setDescription('Seconds in which cells dropped was occured in 15 minutes interval.')
atmNteEventType = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("ps1NotActive", 3), ("ps1Active", 4), ("ps2NotActive", 5), ("ps2Active", 6), ("heatAlarmOff", 7), ("heatAlarmOn", 8), ("inputAlarm1Off", 9), ("inputAlarm1On", 10), ("inputAlarm2Off", 11), ("inputAlarm2On", 12), ("inputAlarm3Off", 13), ("inputAlarm3On", 14), ("inputAlarm4Off", 15), ("inputAlarm4On", 16), ("fan1Ok", 17), ("fan1Fail", 18), ("fan2Ok", 19), ("fan2Fail", 20), ("invalidLogin", 21), ("validLogin", 22), ("powerFailure", 23), ("writeToFlashFailure", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteEventType.setStatus('current')
if mibBuilder.loadTexts: atmNteEventType.setDescription('This parameter identifies the event. On - the problem exist. Off - the problem not exist. InvalidLogin - Invalid login on local console. CorrectLogin - Successful login operation.')
atmNteIntervalMaxNumber = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteIntervalMaxNumber.setStatus('current')
if mibBuilder.loadTexts: atmNteIntervalMaxNumber.setDescription('The MAX number of connections intervals supported by system. This parameter value is a function of atmNteConnectionsMaxNumber parameter. This parameter should affect the threshold values selected by user. Applicable to ace2002.')
atmNteAlarmType = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("ais", 2), ("rdi", 3), ("continuityLoss", 4), ("loopback", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteAlarmType.setStatus('current')
if mibBuilder.loadTexts: atmNteAlarmType.setDescription('This object specifies the type of the alarm.')
atmNteLevel = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("vp", 2), ("vc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteLevel.setStatus('current')
if mibBuilder.loadTexts: atmNteLevel.setDescription('This object specifies the ATM level.')
atmNteConnectionsNumber = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteConnectionsNumber.setStatus('current')
if mibBuilder.loadTexts: atmNteConnectionsNumber.setDescription('This object specifies a quantity of connections.')
atmNteTotalLb = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteTotalLb.setStatus('current')
if mibBuilder.loadTexts: atmNteTotalLb.setDescription('This parameter counts the total number of end-points that were configured with Loopback (LB).')
atmNteTotalCc = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteTotalCc.setStatus('current')
if mibBuilder.loadTexts: atmNteTotalCc.setDescription('This parameter counts the total number of end-points that were configured with Continuity Check (CC).')
atmNteTotalPm = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 3, 1, 2, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmNteTotalPm.setStatus('current')
if mibBuilder.loadTexts: atmNteTotalPm.setDescription('This parameter counts the total number of end-points that were configured with PM.')
atmNteLoopback = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2))
atmLoopbackVpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1), )
if mibBuilder.loadTexts: atmLoopbackVpTable.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpTable.setDescription('This table contains parameters for an OAM VP loopback test.')
atmLoopbackVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmLoopbackVpIfIndex"), (0, "RAD-MIB", "atmLoopbackVpVpi"))
if mibBuilder.loadTexts: atmLoopbackVpEntry.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpEntry.setDescription('An entry in table atmLoopbackVpTable.')
atmLoopbackVpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIfIndex.setDescription('The interface index of the ATM layer.')
atmLoopbackVpVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpVpi.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpVpi.setDescription('The VPI of the OAM VPL.')
atmLoopbackVpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noActive", 1), ("inProgress", 2), ("failed", 3), ("endSuccessfully", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpOperStatus.setDescription('-noActive(1) means that the loopback test has not been activated for this VP. -inProgress(2) means that the test has been activated and there is currently no problem. -failed(3) means there was problem during the test or after having stopped it -endSuccessfully(4) means that the test was stopped and all was OK.')
atmLoopbackVpCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpCDV.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpCDV.setDescription('Cell Delay Variation for this sampling.')
atmLoopbackVpAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpAverageDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpAverageDelay.setDescription(' Average delay without including lost cells.')
atmLoopbackVpMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpMaxDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpMaxDelay.setDescription('Maximum delay without including lost cells.')
atmLoopbackVpMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpMinDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpMinDelay.setDescription('Minimum delay.')
atmLoopbackVpErrSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpErrSessions.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpErrSessions.setDescription('Errored Sessions. Will be updated once in 5 seconds.')
atmLoopbackVcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2), )
if mibBuilder.loadTexts: atmLoopbackVcTable.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcTable.setDescription('This table contains parameters for an OAM VC loopback test.')
atmLoopbackVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "atmLoopbackVcIfIndex"), (0, "RAD-MIB", "atmLoopbackVcVpi"), (0, "RAD-MIB", "atmLoopbackVcVci"))
if mibBuilder.loadTexts: atmLoopbackVcEntry.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcEntry.setDescription('An entry in table.')
atmLoopbackVcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIfIndex.setDescription('The interface index of the ATM layer.')
atmLoopbackVcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcVpi.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcVpi.setDescription('The VPI of the OAM VCL.')
atmLoopbackVcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcVci.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcVci.setDescription('The VCI of the OAM VCL.')
atmLoopbackVcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noActive", 1), ("inProgress", 2), ("failed", 3), ("endSuccessfully", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcOperStatus.setDescription('-noActive(1) means that the loopback test has not been activated for this VP. -inProgress(2) means that the test has been activated and there is currently no problem. -failed(3) means there was problem during the test or after having stopped it -endSuccessfully(4) means that the test was stopped and all was OK.')
atmLoopbackVcCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcCDV.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcCDV.setDescription('Cell Delay Variation for this sampling.')
atmLoopbackVcAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcAverageDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcAverageDelay.setDescription(' Average delay without including lost cells.')
atmLoopbackVcMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcMaxDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcMaxDelay.setDescription('The maximum delay without including lost cells.')
atmLoopbackVcMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcMinDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcMinDelay.setDescription('The minimum delay.')
atmLoopbackVcErrSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcErrSessions.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcErrSessions.setDescription('Errored Sessions. Will be updated once in 5 seconds.')
atmLoopbackVpIvlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3), )
if mibBuilder.loadTexts: atmLoopbackVpIvlTable.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlTable.setDescription('This table contains parameters for an OAM VP loopback test, according interval number.')
atmLoopbackVpIvlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "atmLoopbackVpIvlIfIndex"), (0, "RAD-MIB", "atmLoopbackVpIvlVpi"), (0, "RAD-MIB", "atmLoopbackVpIvlIvl"))
if mibBuilder.loadTexts: atmLoopbackVpIvlEntry.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlEntry.setDescription('An entry in table.')
atmLoopbackVpIvlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlIfIndex.setDescription('The interface index of the ATM layer.')
atmLoopbackVpIvlVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlVpi.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlVpi.setDescription('The VPI of the OAM VPL.')
atmLoopbackVpIvlIvl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlIvl.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlIvl.setDescription('The relevant interval number.')
atmLoopbackVpIvlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noActive", 1), ("inProgress", 2), ("failed", 3), ("endSuccessfully", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlOperStatus.setDescription('-noActive(1) means that the loopback test has not been activated for this VP during this interval. -inProgress(2) has no meaning for an ended interval. -failed(3) means there was problem during the test or after having stopped it -endSuccessfully(4) means that the test was OK.')
atmLoopbackVpIvlCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlCDV.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlCDV.setDescription('Cell Delay Variation for this interval.')
atmLoopbackVpIvlAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlAverageDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlAverageDelay.setDescription(' Average delay without including lost cells for this interval.')
atmLoopbackVpIvlMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlMaxDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlMaxDelay.setDescription('The maximum delay without including lost cells for this interval.')
atmLoopbackVpIvlMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlMinDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlMinDelay.setDescription('The minimum delay for this interval.')
atmLoopbackVpIvlErrSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVpIvlErrSessions.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVpIvlErrSessions.setDescription('Errored Sessions. Will be updated once in 5 seconds.')
atmLoopbackVcIvlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4), )
if mibBuilder.loadTexts: atmLoopbackVcIvlTable.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlTable.setDescription('This table contains parameters for an OAM VC loopback test.')
atmLoopbackVcIvlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1), ).setIndexNames((0, "RAD-MIB", "atmLoopbackVcIvlIfIndex"), (0, "RAD-MIB", "atmLoopbackVcIvlVpi"), (0, "RAD-MIB", "atmLoopbackVcIvlVci"), (0, "RAD-MIB", "atmLoopbackVcIvlIvl"))
if mibBuilder.loadTexts: atmLoopbackVcIvlEntry.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlEntry.setDescription('An entry in table.')
atmLoopbackVcIvlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlIfIndex.setDescription('The interface index of the ATM layer.')
atmLoopbackVcIvlVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlVpi.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlVpi.setDescription('The VPI of the OAM VCL.')
atmLoopbackVcIvlVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlVci.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlVci.setDescription('The VCI of the OAM VCL.')
atmLoopbackVcIvlIvl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlIvl.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlIvl.setDescription('The relevant interval number.')
atmLoopbackVcIvlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noActive", 1), ("inProgress", 2), ("failed", 3), ("endSuccessfully", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlOperStatus.setDescription('-noActive(1) means that the loopback test has not been activated for this VC during this interval. -inProgress(2) has no meaning per interval. -failed(3) means there was problem for this test during this interval. -endSuccessfully(4) means that the test was OK.')
atmLoopbackVcIvlCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlCDV.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlCDV.setDescription('Cell Delay Variation for this interval.')
atmLoopbackVcIvlAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlAverageDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlAverageDelay.setDescription(' Average delay without including lost cells.')
atmLoopbackVcIvlMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlMaxDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlMaxDelay.setDescription('The maximum delay without including lost cells.')
atmLoopbackVcIvlMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlMinDelay.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlMinDelay.setDescription('The minimum delay.')
atmLoopbackVcIvlErrSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 2, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLoopbackVcIvlErrSessions.setStatus('current')
if mibBuilder.loadTexts: atmLoopbackVcIvlErrSessions.setDescription('Errored Sessions. Will be updated once in 5 seconds.')
atmNtePM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3))
atmVpPmTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1), )
if mibBuilder.loadTexts: atmVpPmTable.setStatus('current')
if mibBuilder.loadTexts: atmVpPmTable.setDescription('This table contains parameters for VP performance monitoring.')
atmVpPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmVpPmIfIndex"), (0, "RAD-MIB", "atmVpPmVpi"))
if mibBuilder.loadTexts: atmVpPmEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpPmEntry.setDescription('An entry in table.')
atmVpPmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPmIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVpPmIfIndex.setDescription('The interface index of the ATM layer.')
atmVpPmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpPmVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpPmVpi.setDescription('The VPI of the Performance Monitoring VPL.')
atmVpPmAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 2), ("down", 3), ("listenToActivationCells", 4), ("originateActivationCells", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpPmAdminStatus.setDescription('up(2) - Activate PM. down(3) - Deactivate PM. listenToActivationCells(4) - . originateActivationCells(5) - .')
atmVpPmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("source", 2), ("destination", 3), ("bidirectional", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmDirection.setStatus('current')
if mibBuilder.loadTexts: atmVpPmDirection.setDescription('The direction of PM.')
atmVpPmBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmBlockSize.setStatus('current')
if mibBuilder.loadTexts: atmVpPmBlockSize.setDescription('Valid block sizes (in cells): 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768.')
atmVpPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpPmRowStatus.setDescription('Creation/Deletion of rows in the table.')
atmVpPmSink = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("fwd", 2), ("fwdAndBwdReport", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmSink.setStatus('current')
if mibBuilder.loadTexts: atmVpPmSink.setDescription('off (1) - Deactivate PM. fwd (2) - Activate Forward PM only. fwdAndBwdReport(3) - Activate Forward PM and Backward reporting.')
atmVpPmSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("fwd", 2), ("fwdAndBwdReport", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpPmSource.setStatus('current')
if mibBuilder.loadTexts: atmVpPmSource.setDescription('off (1) - Deactivate PM. fwd (2) - Activate Forward PM only. fwdAndBwdReport(3) - Activate Forward PM and Backward reporting.')
atmVcPmTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2), )
if mibBuilder.loadTexts: atmVcPmTable.setStatus('current')
if mibBuilder.loadTexts: atmVcPmTable.setDescription('This table contains parameters for VC performance monitoring.')
atmVcPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "atmVcPmIfIndex"), (0, "RAD-MIB", "atmVcPmVpi"), (0, "RAD-MIB", "atmVcPmVci"))
if mibBuilder.loadTexts: atmVcPmEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcPmEntry.setDescription('An entry in table.')
atmVcPmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPmIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVcPmIfIndex.setDescription('The interface index of the ATM layer.')
atmVcPmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPmVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcPmVpi.setDescription('The VPI of the Performance Monitoring VCL.')
atmVcPmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcPmVci.setStatus('current')
if mibBuilder.loadTexts: atmVcPmVci.setDescription('The VCI of the PM VCL.')
atmVcPmAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 2), ("down", 3), ("listenToActivationCells", 4), ("originateActivationCells", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcPmAdminStatus.setDescription('up(2) - Activate PM. down(3) - Deactivate PM. listenToActivationCells(4) - . originateActivationCells(5) - .')
atmVcPmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("source", 2), ("destination", 3), ("bidirectional", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmDirection.setStatus('current')
if mibBuilder.loadTexts: atmVcPmDirection.setDescription('The direction of PM.')
atmVcPmBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmBlockSize.setStatus('current')
if mibBuilder.loadTexts: atmVcPmBlockSize.setDescription('Valid block sizes (in cells): 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768.')
atmVcPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcPmRowStatus.setDescription('Creation/Deletion of rows in the table.')
atmVcPmSink = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("fwd", 2), ("fwdAndBwdReport", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmSink.setStatus('current')
if mibBuilder.loadTexts: atmVcPmSink.setDescription('off (1) - Deactivate PM. fwd (2) - Activate Forward PM only. fwdAndBwdReport(3) - Activate Forward PM and Backward reporting.')
atmVcPmSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("fwd", 2), ("fwdAndBwdReport", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcPmSource.setStatus('current')
if mibBuilder.loadTexts: atmVcPmSource.setDescription('off (1) - Deactivate PM. fwd (2) - Activate Forward PM only. fwdAndBwdReport(3) - Activate Forward PM and Backward reporting.')
atmNteMdl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 3))
atmNteMdlConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1))
atmNteMdlConfigTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1, 1), )
if mibBuilder.loadTexts: atmNteMdlConfigTable.setStatus('current')
if mibBuilder.loadTexts: atmNteMdlConfigTable.setDescription('Module configuration table.')
atmNteMdlConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmNteMdlSlotIndex"))
if mibBuilder.loadTexts: atmNteMdlConfigEntry.setStatus('current')
if mibBuilder.loadTexts: atmNteMdlConfigEntry.setDescription('There is an entry in this table just for those modules that have parameters that are relevant to module level only.')
atmNteMdlSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmNteMdlSlotIndex.setStatus('current')
if mibBuilder.loadTexts: atmNteMdlSlotIndex.setDescription('The slot number.')
atmNteMdlPrtCpuSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("equal", 2), ("port1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteMdlPrtCpuSharing.setStatus('current')
if mibBuilder.loadTexts: atmNteMdlPrtCpuSharing.setDescription('This object lets the user decide what will be the CPU sharing between the ports of the module. This object is applicable for modules in which the same CPU handles the traffic of all ports. equal - All ports will have the same CPU resource. port1 - Port 1 will have higher priority than the other ports.')
atmNteMdlInputPriorityMechanism = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 3, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmNteMdlInputPriorityMechanism.setStatus('current')
if mibBuilder.loadTexts: atmNteMdlInputPriorityMechanism.setDescription('This object allows the user to Enable/Disable the Input priority mechanism. This object is applicable for modules with more than one port, in which the total ports input may be greater than the port output. disabled - all LAN VCCs will be transmitted through the same queue (queue 1). Upon congestion frames will be dropped randomly. enabled - the user should configure each port/connection priority. Upon congestion frames will be dropped according to priority.')
atmGenSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 2))
atmGenSysGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1))
atmGenSysSelfTestTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 1), )
if mibBuilder.loadTexts: atmGenSysSelfTestTable.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSelfTestTable.setDescription('A table containing the results of the initial testing of the device.')
atmGenSysSelfTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "atmGenSysSelfTestIndex"))
if mibBuilder.loadTexts: atmGenSysSelfTestEntry.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSelfTestEntry.setDescription('An entry in table.')
atmGenSysSelfTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysSelfTestIndex.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSelfTestIndex.setDescription('A running index for the table.')
atmGenSysSelfTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysSelfTestResult.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSelfTestResult.setDescription('The results of the initial testing of the device.')
atmGenSysSelfTestModule = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysSelfTestModule.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSelfTestModule.setDescription('The name of module on which the test was performed.')
atmGenSysLogClearAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenSysLogClearAll.setStatus('current')
if mibBuilder.loadTexts: atmGenSysLogClearAll.setDescription('Setting the variable to clear(3) removes all entries in the Log Buffer of the agent. The agent will immediately reset the variable to off(2).')
atmGenSysLogTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 3), )
if mibBuilder.loadTexts: atmGenSysLogTable.setStatus('current')
if mibBuilder.loadTexts: atmGenSysLogTable.setDescription('A copy of the log buffer.')
atmGenSysLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 3, 1), ).setIndexNames((0, "RAD-MIB", "atmGenSysLogIndex"))
if mibBuilder.loadTexts: atmGenSysLogEntry.setStatus('current')
if mibBuilder.loadTexts: atmGenSysLogEntry.setDescription('An entry in table.')
atmGenSysLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysLogIndex.setStatus('current')
if mibBuilder.loadTexts: atmGenSysLogIndex.setDescription('The index of the log buffer.')
atmGenSysLogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(80, 80)).setFixedLength(80)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysLogMessage.setStatus('current')
if mibBuilder.loadTexts: atmGenSysLogMessage.setDescription('The log buffer entry message text.')
atmGenSysSetDefaultConfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmGenSysSetDefaultConfg.setStatus('current')
if mibBuilder.loadTexts: atmGenSysSetDefaultConfg.setDescription('When set to on(3), the agent will set all the configuration parameters to their default values. The variable is then reset to off(2) by the agent. The agent must be reset for the default configuration to apply.')
atmGenSysCxRefTable = MibTable((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 5), )
if mibBuilder.loadTexts: atmGenSysCxRefTable.setStatus('current')
if mibBuilder.loadTexts: atmGenSysCxRefTable.setDescription('A Cross Reference table. The table maintains an index of an object which is also the table index, and a counter that indicates how many times this object was referenced. When using this table for more than one referenced table, which uses the same range of indexes, then the index should be shifted by a unique offset per table. In ACE2002 this table is used for TD and for FR Desc. Thus, the index for FR Descriptor is: FR Descriptor index + offset. The offset is described in the ACE2002 NMS SRS.')
atmGenSysCxRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 5, 1), ).setIndexNames((0, "RAD-MIB", "atmGenSysCxRefIndex"))
if mibBuilder.loadTexts: atmGenSysCxRefEntry.setStatus('current')
if mibBuilder.loadTexts: atmGenSysCxRefEntry.setDescription('The entries will be added by the agent upon an entry addition in the referenced tables (TD table, FR Descriptor etc.)')
atmGenSysCxRefIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysCxRefIndex.setStatus('current')
if mibBuilder.loadTexts: atmGenSysCxRefIndex.setDescription('The index specifies an entry in the table of the object.')
atmGenSysCxRefCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 12, 2, 2, 1, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmGenSysCxRefCounter.setStatus('current')
if mibBuilder.loadTexts: atmGenSysCxRefCounter.setDescription('The counter counts the number of references that have been made to the object .')
atmAceStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 164, 12, 3, 0, 1)).setObjects(("RAD-MIB", "agnLed"), ("RAD-MIB", "agnIndication"))
if mibBuilder.loadTexts: atmAceStatusChange.setStatus('current')
if mibBuilder.loadTexts: atmAceStatusChange.setDescription('The trap is sent every time there is a change in the state of one of the LEDs.')
atmAceAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 12, 3, 0, 2)).setObjects(("RAD-MIB", "atmInterfaceAlarmStatus"))
if mibBuilder.loadTexts: atmAceAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmTrap.setDescription('The trap is sent whenever there is a transition from a no alarm state to a state with at least one active alarm. An active alarm state exists if: 1) The atmInterfaceActiveAlarms vector is different than 0. 2) The atmNteAlarmVpTable contains entries. 3) The atmNteAlarmVcTable contains entries. The trap is also sent when a transition into the no alarm state occurs. The second variable will be atmInterfaceActiveAlarms to indicate the kind of the alarm. The trap is not sent more than once in a 10 second interval.')
atmAceModuleChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 12, 3, 0, 3)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmAceModuleChangeTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceModuleChangeTrap.setDescription('The trap is sent every time a module is changed (Hot swapping). The second variable will be atmNteCardType to indicate the type of card that was inserted. The value empty(255) indicates that a card was taken out.')
atmAceRedundancyTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 12, 3, 0, 4)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmAceRedundancyTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceRedundancyTrap.setDescription('The trap is sent upon change in link as a result of redundancy. The ifIndex parameter indicates the current active link.')
atmAceModuleMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 12, 3, 0, 5))
if mibBuilder.loadTexts: atmAceModuleMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceModuleMismatchTrap.setDescription('The trap is sent upon starting or stopping of a module mismatch state. A possible mismatch is when the inserted module is other than the programmed one.')
atmAceSystemTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 6)).setObjects(("RAD-MIB", "atmNteEventType"), ("RAD-MIB", "agnLed"), ("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: atmAceSystemTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceSystemTrap.setDescription('This trap alerts of major problems in the device.')
atmAceAlarmForwardingTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 7)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"))
if mibBuilder.loadTexts: atmAceAlarmForwardingTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmForwardingTrap.setDescription('This trap is sent upon starting or stopping Alarm Forwarding Mechanism.')
atmAceDateAndTimeRequest = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 8))
if mibBuilder.loadTexts: atmAceDateAndTimeRequest.setStatus('current')
if mibBuilder.loadTexts: atmAceDateAndTimeRequest.setDescription("This trap is sent upon restart. Upon recieving this trap the NMS will set the device's date and time. This trap's purpose is to fix a problem in ACE2002, ACE-2002E, ACE-202. The problem is that the Date and Time is stored in the NVRAM, and when the NVRAM's battery is empty, the device loses this information.")
atmAceAlarmLOS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 16)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLOS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLOS.setDescription('This trap indicates Loss Of Signal.')
atmAceAlarmLOF = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 17)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLOF.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLOF.setDescription('This trap indicates Loss Of Frame.')
atmAceAlarmLCD = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 18)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLCD.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLCD.setDescription('This trap indicates Loss of Cell Delineation.')
atmAceAlarmSLM = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 19)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmSLM.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmSLM.setDescription('This trap indicates Signal Line Mismatch.')
atmAceAlarmLOP = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 20)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLOP.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLOP.setDescription('This trap indicates Loss of Pointer.')
atmAceAlarmLineAIS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 21)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLineAIS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLineAIS.setDescription('This trap indicates Line AIS.')
atmAceAlarmPathAIS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 22)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPathAIS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPathAIS.setDescription('This trap indicates Path AIS.')
atmAceAlarmLineRDI = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 23)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLineRDI.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLineRDI.setDescription('This trap indicates Line RDI.')
atmAceAlarmPathRDI = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 24)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPathRDI.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPathRDI.setDescription('This trap indicates Path RDIand Path RAI(Yellow) for DS1 interfaces.')
atmAceAlarmSectionBIP = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 25)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmSectionBIP.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmSectionBIP.setDescription('This trap indicates Section Bit Interleave Parity.')
atmAceAlarmLineBIP = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 26)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLineBIP.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLineBIP.setDescription('This trap indicates Line Bit Interleave Parity.')
atmAceAlarmPathBIP = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 27)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPathBIP.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPathBIP.setDescription('This trap indicates Path Bit Interleave Parity.')
atmAceAlarmLineFEBE = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 28)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmLineFEBE.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmLineFEBE.setDescription('This trap indicates Line Far End Block Error.')
atmAceAlarmPathFEBE = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 29)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPathFEBE.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPathFEBE.setDescription('This trap indicates Path Far End Block Error.')
atmAceAlarmPlcpLOF = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 30)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPlcpLOF.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPlcpLOF.setDescription('This trap indicates T3 PLCP Loss Of Frame.')
atmAceAlarmPlcpYELLOW = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 31)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPlcpYELLOW.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPlcpYELLOW.setDescription('This trap indicates T3 Plcp Yellow.')
atmAceAlarmPlcpBIP = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 32)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPlcpBIP.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPlcpBIP.setDescription('This trap indicates T3 Plcp Bit Interleave Parity.')
atmAceAlarmPlcpFEBE = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 33)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPlcpFEBE.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPlcpFEBE.setDescription('This trap indicates T3 Plcp Far End Block Error.')
atmAceAlarmPlcpP1P2 = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 34)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmPlcpP1P2.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmPlcpP1P2.setDescription('This trap indicates T3 Plcp Parity errors in P1/P2 bytes.')
atmAceAlarmUAS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 35)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmUAS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmUAS.setDescription('This trap is sent upon UAS start or end per port.')
atmAceAlarmCluster = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 36)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("RAD-MIB", "atmNteAlarmType"), ("RAD-MIB", "atmNteLevel"))
if mibBuilder.loadTexts: atmAceAlarmCluster.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmCluster.setDescription('This trap is sent upon atmNteAlarmType start or end, for a cluster of VPs/VCs (according to atmNteLevel) with the same alarm on the same physical port. This trap replaces sending the same alarm for a big quantity (the quantity described in the product specification document) of VPs/VCs in order to prevent flooding the NMS and the network with traps.')
atmAceHwFailure = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 37)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceHwFailure.setStatus('current')
if mibBuilder.loadTexts: atmAceHwFailure.setDescription('This trap is sent upon HW failure per port.')
atmAceUnavailableBwTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 38)).setObjects(("RAD-MIB", "alarmSeverity"), ("IF-MIB", "ifAlias"), ("RAD-MIB", "atmConfIfInputRate"), ("RAD-MIB", "atmConfIfOutputRate"))
if mibBuilder.loadTexts: atmAceUnavailableBwTrap.setStatus('current')
if mibBuilder.loadTexts: atmAceUnavailableBwTrap.setDescription('This trap is sent when Bandwidth allocation is > max possible value for the installed card. For ACE2002 this trap will be sent for the following cases: Card insertion - if the total Input and/or Output Bandwidth is over allocated, then the specific card rate will be set to 0 and this trap will be sent with the Input/Output rates values. Upgrade from former version - when an over allocated Bandwidth is detected, this trap will be sent with atmConfIfInputRate=atmConfIfOutputRate=0xFFFFFFFF.')
atmAceAlarmVpContinuityLoss = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 40)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpContinuityLoss.setDescription('This trap indicates Loss of Continuity Check on a VP Connection.')
atmAceAlarmVpAISReception = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 41)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpAISReception.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpAISReception.setDescription('This trap indicates AIS Reception on a VP Connection.')
atmAceAlarmVpRDIReception = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 42)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpRDIReception.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpRDIReception.setDescription('This trap indicates RDI Reception on a VP Connection.')
atmAceAlarmVpErroredCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 43)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpErroredCells.setDescription('This trap indicates Errored Cells on a VP Connection reported by PM.')
atmAceAlarmVpLostCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 44)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpLostCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpLostCells.setDescription('This trap indicates Lost Cells on a VP Connection reported by PM.')
atmAceAlarmVpMisinsertedCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 45)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpMisinsertedCells.setDescription('This trap indicates Misinserted Cells on a VP Connection reported by PM.')
atmAceAlarmVpUAS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 46)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpUAS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpUAS.setDescription('This trap is sent upon UAS start or end per VP.')
atmAceAlarmVpLoopback = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 47)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpLoopback.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpLoopback.setDescription('This trap is sent upon OAM LoopBack fail status per VP.')
atmAceAlarmVpGCRAViolation = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 48)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVpGCRAViolation.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVpGCRAViolation.setDescription('This trap indicates GCRA violation on a VP Connection reported by UPC device.')
atmAceAlarmVcContinuityLoss = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 56)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcContinuityLoss.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcContinuityLoss.setDescription('This trap indicates Loss of Continuity Check on a VC Connection.')
atmAceAlarmVcAISReception = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 57)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcAISReception.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcAISReception.setDescription('This trap indicates AIS Reception on a VC.')
atmAceAlarmVcRDIReception = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 58)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcRDIReception.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcRDIReception.setDescription('This trap indicates RDI Reception on a VC Connection.')
atmAceAlarmVcErroredCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 59)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcErroredCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcErroredCells.setDescription('This trap indicates Errored Cells on a VC Connection reported by PM.')
atmAceAlarmVcLostCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 60)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcLostCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcLostCells.setDescription('This trap indicates Lost Cells on a VC Connection reported by PM.')
atmAceAlarmVcMisinsertedCells = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 61)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcMisinsertedCells.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcMisinsertedCells.setDescription('This trap indicates Misinserted Cells on a VC Connection reported by PM.')
atmAceAlarmVcUnexpectedCell = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 62)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcUnexpectedCell.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcUnexpectedCell.setDescription('This trap indicates an unexpected cell from user or network port.')
atmAceAlarmVcUAS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 63)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcUAS.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcUAS.setDescription('This trap is sent upon UAS start or end per VC.')
atmAceAlarmVcLoopback = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 64)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcLoopback.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcLoopback.setDescription('This trap is sent upon OAM LoopBack fail status per VC.')
atmAceAlarmVcGCRAViolation = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 0, 65)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: atmAceAlarmVcGCRAViolation.setStatus('current')
if mibBuilder.loadTexts: atmAceAlarmVcGCRAViolation.setDescription('This trap indicates GCRA violation on a VC Connection reported by UPC device.')
ip2If = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7))
ip2IfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1), )
if mibBuilder.loadTexts: ip2IfTable.setStatus('current')
if mibBuilder.loadTexts: ip2IfTable.setDescription('Channels Configuration Table.')
ip2IfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "ip2IfChannelIndex"))
if mibBuilder.loadTexts: ip2IfEntry.setStatus('current')
if mibBuilder.loadTexts: ip2IfEntry.setDescription('Application layer configuration per link')
ip2IfChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfChannelIndex.setStatus('current')
if mibBuilder.loadTexts: ip2IfChannelIndex.setDescription('The channel index, which is actualy the bundle ID.')
ip2IfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfRowStatus.setStatus('current')
if mibBuilder.loadTexts: ip2IfRowStatus.setDescription('This parameter allows NMS to create/delete entries of this table.')
ip2IfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("down", 2), ("up", 3), ("disabled", 4), ("remoteFail", 5), ("localFail", 6), ("unavailable", 7), ("validationFail", 8), ("standby", 9), ("tdmFail", 10), ("hwMismatch", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfOperStatus.setStatus('current')
if mibBuilder.loadTexts: ip2IfOperStatus.setDescription('The actual link status. remoteFail - No Rx. localFail - No Tx. unavailable - No echo replay or replay with invalid code or when connection is in Test state. valiodationFail - Connection is in not valid state. standby - offline (can be in pre-sync mode). tdmFail - oper status is down cause of failure in the tdm. hwMismatch - the bundle exists on a card that is not installed or has a different type than the programmed card.')
ip2IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("down", 2), ("up", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ip2IfAdminStatus.setDescription('The desired state of the link.')
ip2IfDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfDestAddr.setStatus('current')
if mibBuilder.loadTexts: ip2IfDestAddr.setDescription('The destination IP address.')
ip2IfNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 6), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfNextHop.setStatus('current')
if mibBuilder.loadTexts: ip2IfNextHop.setDescription('The next hop to which the frame should be sent. Default value - 0.0.0.0. Upon setting the default value the frame is sent to the default Gateway.')
ip2IfDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfDestPort.setStatus('current')
if mibBuilder.loadTexts: ip2IfDestPort.setDescription('The destination Bundle at the far-end device.')
ip2IfMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 8), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMacAddr.setStatus('current')
if mibBuilder.loadTexts: ip2IfMacAddr.setDescription('The Destination MAC address of the next hop or destination station.')
ip2IfJitterBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfJitterBuffer.setStatus('current')
if mibBuilder.loadTexts: ip2IfJitterBuffer.setDescription('The maximum cell arrival jitter in 10 usec that the reassembly process will tolerate in the cell stream, without producing errors on the CBR service interface. For KM2100: KML.11 - The range that will be used is 3...300 msec in steps of 1 msec. For Vmux: The range that will be used is 20...100 msec in steps of 10 msec.')
ip2IfTos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfTos.setStatus('current')
if mibBuilder.loadTexts: ip2IfTos.setDescription('The TOS (Type of Service) value: 0..255. In Vmux-2100/110 devices versions 3.1 and up, in Vmux-210 and in Vmux-4x0: LSB 8 bits - 00 00 00 XX will be used for Signaling packets TOS. Next 8 bits - 00 00 XX 00 will be used for Media packets TOS. Next 16 bits - will be 0. XX = Hex values: 0..FF For mixed packets, TOS of Media Packets will be used. Signaling packets are for example: Keep alive packets and ABCD signaling bits. Media packets are for example: voice, fax, HDLC, payload packets.')
ip2IfTDMBytesInFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfTDMBytesInFrame.setStatus('current')
if mibBuilder.loadTexts: ip2IfTDMBytesInFrame.setDescription('The number of TDM bytes to be placed in a single IP frame payload. For ip2IfTDMoIpMode = cesOverPsn this parameter indicates the number of IP frames, calculated as: 1440/<Number of Timeslots>.')
ip2IfVlanSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVlanSupport.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanSupport.setDescription('VLAN support (Tagging). no - No support to VLAN. yes - 4 VLAN bytes will be added to the frame.')
ip2IfVlanIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVlanIdentifier.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanIdentifier.setDescription('VLAN ID.')
ip2IfVlanFramePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVlanFramePriority.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanFramePriority.setDescription('VLAN Frame priority.')
ip2IfExitPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("notApplicable", 1), ("ext1", 2), ("ext2", 3), ("auto", 4), ("card2Ext1", 5), ("card2Ext2", 6), ("ext5", 7), ("ext7", 8), ("ext6", 9), ("prt17", 10), ("prt18", 11), ("prt19", 12), ("prt20", 13), ("prtE1T1B", 14), ("prtEthUser", 15), ("card3Ext1", 16), ("card3Ext2", 17), ("card3Ext3", 18), ("card3Ext4", 19), ("card4Ext1", 20), ("card4Ext2", 21), ("card4Ext3", 22), ("card4Ext4", 23), ("card1Ext3", 24), ("card1Ext4", 25), ("card1Ext5", 26), ("card1Ext6", 27), ("card1Ext7", 28), ("card1Ext8", 29), ("card2Ext3", 30), ("card2Ext4", 31), ("card2Ext5", 32), ("card2Ext6", 33), ("card2Ext7", 34), ("card2Ext8", 35)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfExitPort.setStatus('current')
if mibBuilder.loadTexts: ip2IfExitPort.setDescription('This object determines to which external port the traffic will be sent. auto - the device will decide automatically the exit port. If there is an option for Tx via more than one ETH card then use ext1 (1) and ext2(2) for ETH card #1 (ex. LAN1 or Ggabit-ETH1) and use card2Ext1(5) and card2Ext2(6) for card #2 (ex. LAN1 or Ggabit-ETH1). In Vmux-110/210 ext5 is used for ETH-NET, ext 6 is used for E1/T1 link and ext7 is used for Serial Link. In Vmux-2100 Main Board: ext 5 is used for ETH-NET, ext 6 is used for E1/T1 link A, prtE1T1B is used for E1/T1 link B and prtEthUser is used for ETH-User. prt17(10) - prt20(13) values were added in order to support Gmux2000 VMX Card.')
ip2IfVoiceOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 16), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVoiceOos.setStatus('current')
if mibBuilder.loadTexts: ip2IfVoiceOos.setDescription('Voice Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
ip2IfDataOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 17), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfDataOos.setStatus('current')
if mibBuilder.loadTexts: ip2IfDataOos.setDescription('Data Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
ip2IfBundleUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfBundleUsage.setStatus('current')
if mibBuilder.loadTexts: ip2IfBundleUsage.setDescription('The Bundle Resource usage in Kbps.')
ip2IfOAM = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 19), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfOAM.setStatus('current')
if mibBuilder.loadTexts: ip2IfOAM.setDescription('This parameter determine the OAM configuration. The LSB (Bit 0 the most right one) is used for OAM connectivity. Values: 0 = disable, 1= enable.')
ip2IfTDMoIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notApplicable", 1), ("static", 2), ("dynamicLES", 3), ("dynamicCAS", 4), ("cesOverIp", 5), ("voiceOverMpls", 6), ("hdlc", 7), ("voIpComprHeader", 8), ("voMplsComprHeader", 9), ("satop", 10), ("cesOverPsn", 11), ("hdlcOverPsn", 12)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfTDMoIpMode.setStatus('current')
if mibBuilder.loadTexts: ip2IfTDMoIpMode.setDescription('The TDMoIP Mode configuration. Static- means TS can Tx any time. dynamicLES - means TS can Tx only when line is enabled according to LES protocol. dynamicCAS - means TS can Tx only when line is enabled according to CAS protocol. cesOverIp - use for information that this bundle is used for CES Over IP. voiceOverMpls - Voice over Multi Protocol Label Switching. hdlc - High Level Data Link. voIpComprHeader - indicates proprietary compressed IP header packets. voMplsComprHeader - indicates proprietary compressed MPLS header packets.')
ip2IfTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: ip2IfTimeElapsed.setDescription("The number of seconds that have elapsed since the beginning of the current error-measurement period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
ip2IfValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfValidIntervals.setStatus('current')
if mibBuilder.loadTexts: ip2IfValidIntervals.setDescription('The number of previous intervals for which data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15 minute intervals since the interface has been online. ')
ip2IfFarEndType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("e1", 2), ("t1Esf", 3), ("t1D4", 4), ("fxs", 5), ("serialLink", 6), ("t1Unframed", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfFarEndType.setStatus('current')
if mibBuilder.loadTexts: ip2IfFarEndType.setDescription('This object defines the type of the Far-End device. This data is important for signaling and DS0 format. For Vmux: e1 (2) value is used for a PBX in the Far End. fxs (5) is used for Phone. Other values are not used. ')
ip2IfRdnState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("primary", 3), ("secondary", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfRdnState.setStatus('current')
if mibBuilder.loadTexts: ip2IfRdnState.setDescription('This object defines the role this bundle plays in the redundancy scheme: none(2) - means this bundle is not part of redundancy pair. primary/ secondary - means this bundle is not part of redundancy pair, and that is the primary bundle or the secondary bunle. ')
ip2IfSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 25), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfSourceAddr.setStatus('current')
if mibBuilder.loadTexts: ip2IfSourceAddr.setDescription('Source IP Address of the bundle.')
ip2IfBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 26), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfBandWidth.setStatus('current')
if mibBuilder.loadTexts: ip2IfBandWidth.setDescription("Defines the Bandwidth of the bundle. For TDM bundles - it is the Number of Time Slots in The Bundle. - For T1 the value will be: 1..24 - For E1 the value will be: 1..31 - For T3 the value will be: 1..84 - For E3 the value will be: 1..63 This parameter is required for devices like Emux where the bandwidth of the bundles is unknown. The bundles that are received should be transmitted without any change in the bandwidth. It is the user's responsibility to enter the correct bandwidth. For Ethernet bundles - it is the bandwidth, measured in Kbps.")
ip2IfMeasuredSilence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfMeasuredSilence.setStatus('current')
if mibBuilder.loadTexts: ip2IfMeasuredSilence.setDescription('This object shows the percentage of Silence that was measured by the device for the current bundle in the transmitted payload. Relevant values: 0..100, 255. Default value is 50. 0 means that there is no silence on the line. 100 means that there is only silence. In this case, there might be no traffic. 255 - value for not applicable or unknown.')
ip2IfPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("data", 2), ("voice", 3), ("voiceAndCas", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfPayloadType.setStatus('current')
if mibBuilder.loadTexts: ip2IfPayloadType.setDescription('This object defines the TDMoIP payload type.')
ip2IfProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("v1", 2), ("v2", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: ip2IfProtocolVersion.setDescription('This object defines the TDMoIP protocol Version.')
ip2IfTdmBackUpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 30), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfTdmBackUpNextHop.setStatus('current')
if mibBuilder.loadTexts: ip2IfTdmBackUpNextHop.setDescription('Defines the TDM bundle default router in case there was a switch from the Primary Link (for example an ETH port) to a TDM backup Link like E1, T1 or Serial Link. This parameter is relevant only when a Backup Link is configured. When a Backup Link is not configured the value will be: 0.0.0.0')
ip2IfOosTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfOosTxEnable.setStatus('current')
if mibBuilder.loadTexts: ip2IfOosTxEnable.setDescription('This object defines whether OOS will be Transmitted. Note that for IPmux1000 the Lbit is always sent, but the OOS will be sent according to user selection in this parameter.')
ip2IfConnCheckPktFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 32), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfConnCheckPktFrequency.setStatus('current')
if mibBuilder.loadTexts: ip2IfConnCheckPktFrequency.setDescription('Time in sec. between 2 Bundle Connectivity Check packets. Valid values: 0..60. 0 = Not Applicable.')
ip2IfConnPktTimeOutCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 33), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfConnPktTimeOutCycles.setStatus('current')
if mibBuilder.loadTexts: ip2IfConnPktTimeOutCycles.setDescription('No. of cycles the agent will send Bundle Connectivity packets without receiving a response from the remote device before declaring that the bundle connection to the remote side is down - Time Out. Valid values: 0..5. 0 = Not Applicable.')
ip2IfMfRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMfRelay.setStatus('current')
if mibBuilder.loadTexts: ip2IfMfRelay.setDescription('Multi Frequency Signaling Detection.')
ip2IfTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 35), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfTxGain.setStatus('current')
if mibBuilder.loadTexts: ip2IfTxGain.setDescription('Transmit gain in dBm.')
ip2IfSuperTandem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfSuperTandem.setStatus('current')
if mibBuilder.loadTexts: ip2IfSuperTandem.setDescription('The Super Tandem feature provides end to end compression over multiple hops, solving the double compression problem detected in Voice compressing systems. The Super Tandem allows transmission of compressed voice between a few Vmux 2100 hubs, and eliminates the need to decompress an recompress it over each voice card and PBX, thus improving voice quality and reducing delay.')
ip2IfSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 37), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfSrcPort.setStatus('current')
if mibBuilder.loadTexts: ip2IfSrcPort.setDescription('The source Bundle at the local device, this parameter used for cases where there is no match between ip2IfChannelIndex and the Source Bundle ID.')
ip2IfModemCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("relay", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfModemCalls.setStatus('current')
if mibBuilder.loadTexts: ip2IfModemCalls.setDescription('This MIB object shows whether Modem Calls are enabled via the bundle. relay option (3) means that the bundle will send to the network only modulated data.')
ip2IfMinPulseWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 39), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMinPulseWidth.setStatus('current')
if mibBuilder.loadTexts: ip2IfMinPulseWidth.setDescription('Indicates the minimum width in milliseconds of the MF (Multi Frequency) tone transmitted by the switch. Valid values: 45-300 msec. notApplicable=0.')
ip2IfMinPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 40), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMinPowerLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfMinPowerLevel.setDescription('Indicates the minimum power level in dBm of the MF (Multi Frequency) tone transmitted by the switch. Valid values: -1...-35 dBm.')
ip2IfEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfEchoCanceler.setStatus('current')
if mibBuilder.loadTexts: ip2IfEchoCanceler.setDescription('Echo canceler activation.')
ip2IfCodingLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aLAW", 1), ("uLAW", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCodingLaw.setStatus('current')
if mibBuilder.loadTexts: ip2IfCodingLaw.setDescription('This attribute indicates the Method/Law for decoding/encoding the voice information. aLaw(1) is the standard Law for E1 links. uLaw(2) is the standard Law for T1 links.')
ip2IfCustomToneDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCustomToneDetect.setStatus('current')
if mibBuilder.loadTexts: ip2IfCustomToneDetect.setDescription('Custom Tone Detection (COT) is a Control operation of a 2Khz tone detector. This tone is sent between PBX devices in order to check that the line status is OK. When the COT is enabled the device will not compress/decompress the tone. In this case, if the tone is initiated by the local PBX, the Device runs a 2Khz detector tone and once detected by the Remote Device, if the COT is enabled in the Remote Device, the Remote Device will generate a 2khz tone to the remote PBX.')
ip2IfCallerIdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 44), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCallerIdDelay.setStatus('current')
if mibBuilder.loadTexts: ip2IfCallerIdDelay.setDescription('Time in msec between CLID (Caller ID) signal detection on the line and CLID signal transmission. The CLID must be sent between ringing signals and the value of the delay is used for synchronizing the CLID transmission with the ringing signals transmission. Valid values: 0 - 3000 msec.')
ip2IfConnectivityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("ping", 2), ("oam", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfConnectivityMode.setStatus('current')
if mibBuilder.loadTexts: ip2IfConnectivityMode.setDescription('This MIB object shows whether to send Pings or OAM frames over the bundle.')
ip2IfClockSourceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfClockSourceEnable.setStatus('current')
if mibBuilder.loadTexts: ip2IfClockSourceEnable.setDescription('This MIB object defines whether this bundle can be a clock source.')
ip2IfNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("ip", 2), ("mplsEth", 3), ("mac", 4), ("ipComprHeader", 5), ("mplsComprHeader", 6), ("udp", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfNetworkType.setStatus('current')
if mibBuilder.loadTexts: ip2IfNetworkType.setDescription('This MIB object defines the network over which the Bundle PSN (Packet Switching Network)is transported. In Gmux2000: ipComprHeader indicates proprietary compressed IP header packets. mplsComprHeader indicates proprietary compressed MPLS header packets.')
ip2IfMplsRxLabelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMplsRxLabelEnable.setStatus('current')
if mibBuilder.loadTexts: ip2IfMplsRxLabelEnable.setDescription('This MIB object defines whether there is user defined inner (Rx.) label for this Bundle.')
ip2IfMplsRxLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 49), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMplsRxLabel.setStatus('current')
if mibBuilder.loadTexts: ip2IfMplsRxLabel.setDescription('This MIB object defines the MPLS Rx. Label for this Bundle.')
ip2IfMplsTxLabelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMplsTxLabelEnable.setStatus('current')
if mibBuilder.loadTexts: ip2IfMplsTxLabelEnable.setDescription('This MIB object defines whether there is user defined outer (Tx.) label for this Bundle.')
ip2IfMplsTxLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 51), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMplsTxLabel.setStatus('current')
if mibBuilder.loadTexts: ip2IfMplsTxLabel.setDescription('This MIB object defines the MPLS Tx. Label for this Bundle.')
ip2IfMplsTxExpBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMplsTxExpBits.setStatus('current')
if mibBuilder.loadTexts: ip2IfMplsTxExpBits.setDescription('The MPLS Network priority (EXP bits) used for this bundle.')
ip2IfMfcSpoofing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMfcSpoofing.setStatus('current')
if mibBuilder.loadTexts: ip2IfMfcSpoofing.setDescription('This MIB object defines whether the MFC (Multi Frequency Compelled) protocol spoofing will exist in the bundle. When the MFC Spoofing is used, the Local and Remote PBXs will send MFC Signaling to each other. The Vmuxes between the PBXs will send proprietary signaling to each other. They will however create and send MFC tones to their local PBX. The PBXs will not know that the actual signaling was not sent from a PBX but from a Vmux.')
ip2IfToneAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 54), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfToneAckInterval.setStatus('current')
if mibBuilder.loadTexts: ip2IfToneAckInterval.setDescription('Time Interval in milli seconds from the time a Vmux sends tone/s to a local PBX until it receives an acknowledgement from this PBX. Valid values: 60...400 in steps of 20.')
ip2IfNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("ipAddress", 2), ("macAddress", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfNextHopType.setStatus('current')
if mibBuilder.loadTexts: ip2IfNextHopType.setDescription('This MIB object defines the Bundle next Hop Address Type.')
ip2IfNoiseLevelForVAD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("low", 2), ("high", 3), ("off", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfNoiseLevelForVAD.setStatus('current')
if mibBuilder.loadTexts: ip2IfNoiseLevelForVAD.setDescription('This object defines the Level of Noise on the line, the Voice Activation Detector (VAD) will have to handle.')
ip2IfClockPreferences = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("accurateness", 2), ("constantDelay", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfClockPreferences.setStatus('current')
if mibBuilder.loadTexts: ip2IfClockPreferences.setDescription('The Clock preferences: accurateness (2) = Accurate clock is more important than Constant Delay. constantDelay (3)= Constant Delay is more important than Accurate clock .')
ip2IfConnectionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tdmOIpCe", 2), ("tdmOIpCv", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfConnectionMode.setStatus('current')
if mibBuilder.loadTexts: ip2IfConnectionMode.setDescription('The Connection Mode: tdmOIpCe (2) = TDMOiP (CE) = Circuit Emulation. tdmOIpCv (3)= TDMOiP (CV) = Compressed Voice.')
ip2IfRingBack = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfRingBack.setStatus('current')
if mibBuilder.loadTexts: ip2IfRingBack.setDescription('Enables or disable Ring Back.')
ip2IfReversePolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfReversePolarity.setStatus('current')
if mibBuilder.loadTexts: ip2IfReversePolarity.setDescription('Enables or disable Reverse polarity synthesis.')
ip2IfPulseMeter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfPulseMeter.setStatus('current')
if mibBuilder.loadTexts: ip2IfPulseMeter.setDescription('Enables or disable Pulse metering synthesis.')
ip2IfPulseMeterFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("rate12Khz", 2), ("rate16Khz", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfPulseMeterFreq.setStatus('current')
if mibBuilder.loadTexts: ip2IfPulseMeterFreq.setDescription('Frequency of synthesized pulse metering for this bundle.')
ip2IfPulseMeterPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 63), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfPulseMeterPeriod.setStatus('current')
if mibBuilder.loadTexts: ip2IfPulseMeterPeriod.setDescription('Duration of synthesized pulse metering. current values are: 100-250.')
ip2IfOnHookDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfOnHookDetect.setStatus('current')
if mibBuilder.loadTexts: ip2IfOnHookDetect.setDescription('Enables or disable immediate reaction to On-Hook bits from network in Ringing.')
ip2IfComfortNoiseGen = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfComfortNoiseGen.setStatus('current')
if mibBuilder.loadTexts: ip2IfComfortNoiseGen.setDescription('Enable or disable Comfort Noise Generation (CNG). When this parameter is enabled and no voice payload exists on the line for some time period during the call (moments of silence), the device will generate a soft background noise which assures the user that the connection is still alive (CNG). When this parameter is disabled and no voice payload exists on the line, absolute silence will be heard (Comfort Noise will not be generated).')
ip2IfExitChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 66), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfExitChannel.setStatus('current')
if mibBuilder.loadTexts: ip2IfExitChannel.setDescription('The channelized bundle that the voice bundle exits through. In Gmux2000 it is the ifIndex of the Channelized Bundle (sub-channel) that the Voice Bundle exits through. The ifIndex contains the Slot+Prt+Channelized Bundle No.')
ip2IfMaxVBDModemCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 67), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMaxVBDModemCalls.setStatus('current')
if mibBuilder.loadTexts: ip2IfMaxVBDModemCalls.setDescription('Maximum VBD modem calls for this bundle.')
ip2IfMaxRelayModemCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 68), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMaxRelayModemCalls.setStatus('current')
if mibBuilder.loadTexts: ip2IfMaxRelayModemCalls.setDescription('Maximum Relay modem calls for this bundle.')
ip2IfCustomToneFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("f1780Hz", 2), ("f2000Hz", 3), ("f1780Plus2000Hz", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCustomToneFrequency.setStatus('current')
if mibBuilder.loadTexts: ip2IfCustomToneFrequency.setDescription('This is the frequency of the Custom Tone that is sent between PBXs in order to check that the line status is OK. When the Custom Tone Detection is enabled the device will not compress/decompress this tone. The custom tone that is received from the local PBX will be sent to the remote PBX with the same frequency it was received. When the Custom Tone Frequency is f1780Plus2000Hz (4), the device will not compress/decompress any tone with frequencies of 1780Hz or 2000 Hz.')
ip2IfVadMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("proprietary", 2), ("internalITUT", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVadMethod.setStatus('current')
if mibBuilder.loadTexts: ip2IfVadMethod.setDescription('Voice Activity Detection (VAD) method. proprietary (2) - non standard VAD based only on power measurement. It is very sensitive to background noise. internalITUT (3) - standard ITU-T VAD. It is a robust method.')
ip2IfRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 71), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfRxGain.setStatus('current')
if mibBuilder.loadTexts: ip2IfRxGain.setDescription('Receive gain in dBm.')
ip2IfCallerIDType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("bellcoreType1", 2), ("v23", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCallerIDType.setStatus('current')
if mibBuilder.loadTexts: ip2IfCallerIDType.setDescription('Caller ID Type used by the DSP for this bundle. Bellcore type is used by the American method. V.23 type is used by the European method.')
ip2IfPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("ipAddress", 2), ("macAddress", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: ip2IfPeerAddrType.setDescription('This MIB object defines the peer Address Type.')
ip2IfVbdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("r64KbpsIn5msecIntervalsG711", 2), ("r64KbpsIn10msecIntervalsG711", 3), ("r32KbpsG726", 4), ("r24KbpsG726", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVbdRate.setStatus('current')
if mibBuilder.loadTexts: ip2IfVbdRate.setDescription('Voice Band Data (VBD) rate for this bundle.')
ip2IfDtmfDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfDtmfDetection.setStatus('current')
if mibBuilder.loadTexts: ip2IfDtmfDetection.setDescription('Enable/Disable DTMF (Dual Tone Multi Frequency) detectors for this bundle.')
ip2IfNlpCutoffLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 76), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfNlpCutoffLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfNlpCutoffLevel.setDescription('Non Linear Processor (NLP) Cutoff Level for this bundle. This parameter is used by the echo canceller. It is the maximum absolute linear PCM amplitude of the near-end signal that will cause the NLP module to be active and to mute low level residual echo & noisy surroundings.')
ip2IfDtdErlRatioCutoffQ3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 77), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfDtdErlRatioCutoffQ3.setStatus('current')
if mibBuilder.loadTexts: ip2IfDtdErlRatioCutoffQ3.setDescription('The DTD ERL cutoff level is used in order to determine whether the near-end is talking or not. This parameter is used by the echo canceller when echo exists and there is voice with low volume on the line. DTD means Double Talk Detection. ERL means Echo Return Loss. It is the power difference [dB] between the far-end signal to the echo returned. The cutoff level is calculated for the value entering Q.3. This value will be divided by 2^3=8 in order to get the linear ratio.')
ip2IfCASRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCASRedundancy.setStatus('current')
if mibBuilder.loadTexts: ip2IfCASRedundancy.setDescription('Enable/Disable CAS signaling redundancy. This parameter is useful when there are problems with the network and applicable only for CAS signaling: E1-MF (G.732S) or E1-CRC-MF (G.732SCRC ). enable (3) - means that each packet containing CAS signaling will be triplicated into 3 packets. disable (2)- No redundancy will exist. Only 1 packet containing CAS will be transmitted.')
ip2IfBundleSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 79), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("delaySensitive", 2), ("dataSensitive", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfBundleSensitivity.setStatus('current')
if mibBuilder.loadTexts: ip2IfBundleSensitivity.setDescription('Denotes if the bundle is sensitive to delay in the network, or is sensitive to data errors in the network. Voice bundles are sensitive to delay; Non-voice bundles are sensitive to data errors.')
ip2IfOAMBundleIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("bundleNumber", 2), ("vccvCtrlWord", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfOAMBundleIdent.setStatus('current')
if mibBuilder.loadTexts: ip2IfOAMBundleIdent.setDescription('Denotes if an OAM bundle is identified according to the Bundle Number (0x3fff), or according to the value of the first nibble in the VCCV control word sent in the frame. controlWord - applicable only when ip2IfProtocolVersion = v2(2). When ip2IfProtocolVersion = v1(1), only bundleNumber is applicable.')
ip2IfMaxTxQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 81), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMaxTxQueue.setStatus('current')
if mibBuilder.loadTexts: ip2IfMaxTxQueue.setDescription('Max Tx Queue buffer size, measured in msec (milliseconds). Low buffer size may cause the buffer to overflow and discard packets in case of burst of packets on the network. High buffer size allows to store this burst and not lose packets.')
ip2IfMaxGprsTxQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 82), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfMaxGprsTxQueue.setStatus('current')
if mibBuilder.loadTexts: ip2IfMaxGprsTxQueue.setDescription('Max GPRS Tx Queue buffer size, measured in msec (milliseconds). Low buffer size may cause the buffer to overflow and discard packets in case of burst of packets on the network. High buffer size allows to store this burst and not lose packets.')
ip2IfV23HD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfV23HD.setStatus('current')
if mibBuilder.loadTexts: ip2IfV23HD.setDescription('This parameter shows whether V.23 Half Duplex Modem Protocol is enabled on the bundle.')
ip2IfModemProtocolMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 84), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfModemProtocolMode.setStatus('current')
if mibBuilder.loadTexts: ip2IfModemProtocolMode.setDescription('This octet string contains the mode of each Modem Protocol used on the bundle. For each protocol one octet will be used. Octet #1 will be used for V.22 Protocol. Octet #2, #3, #4... are reserved for future protocols. Octet #1 values: 0 - Not Applicable 1 - VBD: Voice Band Data. 2 - Relay: Pulse Code Modulated (PCM) data is sent via the bundle. For V.22: This MIB object is relevant only when ip2IfModemCalls = relay (4).')
ip2IfCdisCngDetectionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 85), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCdisCngDetectionTime.setStatus('current')
if mibBuilder.loadTexts: ip2IfCdisCngDetectionTime.setDescription('When working with CDIS (Call DIScrimination method) or CNG (Comfort Noise Generation): The time in msec that the device will detect 1100Hz & 2100Hz signals on the line before switching to modem or fax. For Vmux: the values will be in steps of 10 msec.')
ip2IfSuperTandemBitMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 86), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfSuperTandemBitMask.setStatus('current')
if mibBuilder.loadTexts: ip2IfSuperTandemBitMask.setDescription('This MIB object enables controlling the Time Slot/Channel rate. Valid values: 1 - FF HEX Each BIT represents 1/8 of the TS. Example: 7E (0111 1110) means that 6/8 of the TS (the center ones) are masked and data will be Tx/Rx only through them. This MIB object is relevant only when Super Tandem is enabled.')
ip2IfVbdSwitchbackTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 87), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfVbdSwitchbackTime.setStatus('current')
if mibBuilder.loadTexts: ip2IfVbdSwitchbackTime.setDescription('Time in msec required for the DSP to switch back from VBD (Voice Band Data) to Voice. For Vmux: the values will be in steps of 30 msec. ')
ip2IfCallerIdTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 88), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCallerIdTxGain.setStatus('current')
if mibBuilder.loadTexts: ip2IfCallerIdTxGain.setDescription('The gain value in dBm units used for transmitting the Caller ID signal on the bundle. ')
ip2IfCallerIdRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 89), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCallerIdRxGain.setStatus('current')
if mibBuilder.loadTexts: ip2IfCallerIdRxGain.setDescription('The gain value in dBm units of the Caller ID signal received on the bundle.')
ip2IfUdpMuxMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("srcPort", 2), ("destPort", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfUdpMuxMethod.setStatus('current')
if mibBuilder.loadTexts: ip2IfUdpMuxMethod.setDescription("This parameter determines according to which field the multiplexing is made: srcPort (2) - multiplexing according to the UDP Source Port (Dest=0x085e). This should be the default value, for backwards compatibility. destPort (3) - multiplexing according to the UDP Destination Port (standard multiplexing). The UDP Source and Destination ports' range is determined according to ip2IfUdpMuxMethod value: For srcPort (2) the range is 1-7000 For destPort (3) the range is 49152-65535.")
ip2IfCallerIdDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfCallerIdDetection.setStatus('current')
if mibBuilder.loadTexts: ip2IfCallerIdDetection.setDescription('Enable/Disable Caller ID Detection for this bundle.')
ip2IfWap = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 1, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ip2IfWap.setStatus('current')
if mibBuilder.loadTexts: ip2IfWap.setDescription('Enable/Disable WAP (Wireless Application Protocol) for this bundle. WAP allows users to access the internet from wireless devices.')
ip2IfTDMFrameBytes = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfTDMFrameBytes.setStatus('current')
if mibBuilder.loadTexts: ip2IfTDMFrameBytes.setDescription('The number of TDM bytes to be placed in a single IP frame payload.')
ip2IfTosValue = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfTosValue.setStatus('current')
if mibBuilder.loadTexts: ip2IfTosValue.setDescription('The TOS value to write in the IP frame.')
ip2IfVlanTagging = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfVlanTagging.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanTagging.setDescription('VLAN support. no - No support to VLAN. yes - 4 VLAN bytes will be added to the frame.')
ip2IfVlanID = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfVlanID.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanID.setDescription('VLAN ID.')
ip2IfVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfVlanPriority.setStatus('current')
if mibBuilder.loadTexts: ip2IfVlanPriority.setDescription('Frame priority.')
ip2IfStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7), )
if mibBuilder.loadTexts: ip2IfStatTable.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTable.setDescription('Channels (Bundles) Statistics Table.')
ip2IfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1), ).setIndexNames((0, "RAD-MIB", "ip2IfStatChIndex"))
if mibBuilder.loadTexts: ip2IfStatEntry.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatEntry.setDescription('IP Statistics per bundle')
ip2IfStatChIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatChIndex.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatChIndex.setDescription('The channel index, which is actualy the bundle ID.')
ip2IfStatSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatSeqErrors.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatSeqErrors.setDescription("Number of events that the sequence number of an incoming Frame causes a transition from the 'sync' state to the 'out of sequence' state.")
ip2IfStatBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatBufUnderflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatBufUnderflows.setDescription('Number of events that the buffer underflows. This records the count of the number of events the Receive (Eth to TDM) buffer underflows. In the case of a continuous underflow caused by a loss of Frame flow, a single buffer underflow should be counted.')
ip2IfStatBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatBufOverflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatBufOverflows.setDescription('Number of events that the buffer overflows. This records the count of the number of events the Receive (Eth to TDM) buffer overflows.')
ip2IfStatTxOnTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxOnTimeInterval.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxOnTimeInterval.setDescription('Number of frames that were transmitted due to time interval elapse. The user can choose to Tx the Frame when it reaches the Max size or when the packetizing time interval elapses. The packetizing time interval is the interval in msec that it takes to build a Max. size frame.')
ip2IfStatTxOnMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxOnMaxSize.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxOnMaxSize.setDescription('Number of frames that were transmitted due to reaching max. frame size. The user can choose to Tx the Frame when it reaches the Max size or when the packetizing time interval elapses.')
ip2IfStatRxSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRxSignaling.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRxSignaling.setDescription('Number of signaling frames that were received.')
ip2IfStatRxVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRxVoice.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRxVoice.setDescription('Number of voice frames that were received.')
ip2IfStatRxHdlc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRxHdlc.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRxHdlc.setDescription('Number of HDLC frames that were received.')
ip2IfStatTxSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxSignaling.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxSignaling.setDescription('Number of signaling frames that were transmitted.')
ip2IfStatTxVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxVoice.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxVoice.setDescription('Number of voice frames that were transmitted.')
ip2IfStatTxHdlc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxHdlc.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxHdlc.setDescription('Number of HDLC frames that were transmitted.')
ip2IfStatRdnFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRdnFlip.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRdnFlip.setDescription('Number of redundancy flips occured. This parameter counts only flips from this bundle to the other bundle in the redundancy couple.')
ip2IfFarEndTdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfFarEndTdmStatus.setStatus('current')
if mibBuilder.loadTexts: ip2IfFarEndTdmStatus.setDescription('This variable indicates the Status of the Far-End TDM Line. It contains failure state information. The variable is a bit map represented as a sum, therefore, it can represent multiple failures simultaneously. The farEndTdmNoDefect must be set if and only if no other flag is set. The various bit positions are: 1 farEndTdmNoDefect 2 farEndTdmAIS Alarm Indication Signal 4 farEndTdmRDI Remote Defect Indication')
ip2IfStatPsnTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatPsnTxFrames.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatPsnTxFrames.setDescription('Number of frames that were transmitted to PSN.')
ip2IfStatPsnRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatPsnRxFrames.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatPsnRxFrames.setDescription('Number of frames that were recieved from PSN.')
ip2IfStatMinJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatMinJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatMinJittBufLevel.setDescription('The Minimum jitter buffer level (in msec).')
ip2IfStatMaxJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatMaxJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatMaxJittBufLevel.setDescription('The Maximum jitter buffer level (in msec).')
ip2IfStatRecommendedJittBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRecommendedJittBufSize.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRecommendedJittBufSize.setDescription('The Recommended jitter buffer Size (in msec). 0= not applicable.')
ip2IfStatPsnSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatPsnSeqErrors.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatPsnSeqErrors.setDescription('Number of times that the sequence number of an incoming Frame indicates Loss of Frame or Out of order occured in PSN.')
ip2IfStatPsnReorderFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatPsnReorderFrames.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatPsnReorderFrames.setDescription('Number of times that Frames had been reordered in PSN.')
ip2IfStatMinRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatMinRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatMinRoundTripDelay.setDescription('The minimum Round Trip delay (in msec). 0= not applicable.')
ip2IfStatMaxRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatMaxRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatMaxRoundTripDelay.setDescription('The maximum Round Trip delay (in msec). 0= not applicable.')
ip2IfStatAvrRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatAvrRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatAvrRoundTripDelay.setDescription('The avarage Round Trip delay (in msec). 0= not applicable.')
ip2IfStatFrameTrackDupDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatFrameTrackDupDrop.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatFrameTrackDupDrop.setDescription('The number of packets dropped due to being duplicated. (duplicated packet means a packet that has the same sequential number as a packet being received previously).')
ip2IfStatFrameTrackMissing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatFrameTrackMissing.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatFrameTrackMissing.setDescription('The number of packets that are missing. (Missing packet means an expected packet- according to the current sequential number - that was not received).')
ip2IfStatFrameTrackLongSerMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatFrameTrackLongSerMiss.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatFrameTrackLongSerMiss.setDescription('The longest series of consecutive missing sequential numbers. Missing sequential numbers represent missing packets that was expected to be received successively.')
ip2IfStatTxMeasuredSilence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatTxMeasuredSilence.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatTxMeasuredSilence.setDescription('This object shows the percentage of Silence that was measured by the device for the current bundle in the transmitted payload. Relevant values: 0..100, 255. Default value is 50. 0 means that there is no silence on the line. 100 means that there is only silence. In this case, there might be no traffic. 255 - value for not applicable or unknown.')
ip2IfStatRxMeasuredSilence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRxMeasuredSilence.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRxMeasuredSilence.setDescription('This object shows the percentage of Silence that was measured by the device for the current bundle in the received payload. Relevant values: 0..100, 255. Default value is 50. 0 means that there is no silence on the line. 100 means that there is only silence. In this case, there might be no traffic. 255 - value for not applicable or unknown.')
ip2IfStatHdlcCrcErr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcCrcErr.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcCrcErr.setDescription('This counter indicates the number of received HDLC frames with CRC errors.')
ip2IfStatHdlcAlignErr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcAlignErr.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcAlignErr.setDescription('This counter indicates the number of received HDLC frames with alignment errors.')
ip2IfStatHdlcOversize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcOversize.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcOversize.setDescription('This counter indicates the number of received HDLC frames longer than 1470.')
ip2IfStatHdlcUndersize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcUndersize.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcUndersize.setDescription('This counter indicates the number of received HDLC frames shorter than 4.')
ip2IfStatHdlcAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcAbort.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcAbort.setDescription('This counter indicates the number of received HDLC frames with abort indication.')
ip2IfStatRxCorrectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatRxCorrectFrames.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatRxCorrectFrames.setDescription('Number of received correct frames.')
ip2IfStatHdlcErroredFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 7, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfStatHdlcErroredFrames.setStatus('current')
if mibBuilder.loadTexts: ip2IfStatHdlcErroredFrames.setDescription('Number of received errored HDLC frames.')
ip2IfRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfRateLimit.setStatus('current')
if mibBuilder.loadTexts: ip2IfRateLimit.setDescription('The maximum rate permitted to transfer via the network portin Mbps.')
ip2IfPortTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9), )
if mibBuilder.loadTexts: ip2IfPortTable.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortTable.setDescription('Port Table.')
ip2IfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9, 1), ).setIndexNames((0, "RAD-MIB", "ip2IfPortIndex"))
if mibBuilder.loadTexts: ip2IfPortEntry.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortEntry.setDescription('Application layer configuration per Port')
ip2IfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfPortIndex.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortIndex.setDescription('The Port index, which is actualy the ifIndex.')
ip2IfPortUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfPortUsage.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortUsage.setDescription('This parameter indicates the usage of the port (percents).')
ip2IfPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("dontMask", 2), ("mask", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfPortMask.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortMask.setDescription("This parameter defines whether Agent will mask port's alarms and statistics or not.")
ip2IfPortTotalThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfPortTotalThroughput.setStatus('current')
if mibBuilder.loadTexts: ip2IfPortTotalThroughput.setDescription('This parameter indicates the total Throughput of the port in bps.')
ip2IfCurrentStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10), )
if mibBuilder.loadTexts: ip2IfCurrentStatTable.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatTable.setDescription('Channels (Bundles) Current Statistics Table.')
ip2IfCurrentStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1), ).setIndexNames((0, "RAD-MIB", "ip2IfChannelIndex"))
if mibBuilder.loadTexts: ip2IfCurrentStatEntry.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatEntry.setDescription('IP Current Statistics per bundle')
ip2IfCurrentStatSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatSeqErrors.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatSeqErrors.setDescription("Number of seconds that the sequence number of an incoming Frame causes a transition from the 'sync' state to the 'out of sequence' state in the current interval.")
ip2IfCurrentStatBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatBufUnderflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatBufUnderflows.setDescription('Number of seconds that the buffer underflows in the current interval. This records the count of the number of seconds the Receive (Eth to TDM) buffer underflows in the current interval. In the case of a continuous underflow caused by a loss of Frame flow, a single buffer underflow should be counted.')
ip2IfCurrentStatBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatBufOverflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatBufOverflows.setDescription('Number of seconds that the buffer overflows in the current interval. This records the count of the number of seonds the Receive (Eth to TDM) buffer overflows in the current interval.')
ip2IfCurrentStatMaxDelayVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatMaxDelayVar.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatMaxDelayVar.setDescription('The maximum deviation from the center of the buffer (in msec) for the current interval.')
ip2IfCurrentStatMinJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatMinJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatMinJittBufLevel.setDescription('The Minimum jitter buffer level (in msec) for the current interval.')
ip2IfCurrentStatMaxJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatMaxJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatMaxJittBufLevel.setDescription('The Maximum jitter buffer level (in msec) for the current interval.')
ip2IfCurrentStatTxErrFrameSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfCurrentStatTxErrFrameSec.setStatus('current')
if mibBuilder.loadTexts: ip2IfCurrentStatTxErrFrameSec.setDescription('The number of seconds in which errored frames were transmitted during the current interval. The error may be one of the following: CRC error, Alignment error, Oversized frame, Undersized frame, Aborted frame.')
ip2IfIntervalStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11), )
if mibBuilder.loadTexts: ip2IfIntervalStatTable.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatTable.setDescription('Channels (Bundles) Interval Statistics Table.')
ip2IfIntervalStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1), ).setIndexNames((0, "RAD-MIB", "ip2IfChannelIndex"), (0, "RAD-MIB", "ip2IfIntervalStatIndex"))
if mibBuilder.loadTexts: ip2IfIntervalStatEntry.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatEntry.setDescription('IP Interval Statistics per bundle')
ip2IfIntervalStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatIndex.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatIndex.setDescription('The Interval index, which is actualy the Interval number.')
ip2IfIntervalStatSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatSeqErrors.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatSeqErrors.setDescription("Number of seconds that the sequence number of an incoming Frame causes a transition from the 'sync' state to the 'out of sequence' state in the selected interval.")
ip2IfIntervalStatBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatBufUnderflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatBufUnderflows.setDescription('Number of seconds that the buffer underflows in the selected interval. This records the count of the number of seconds the Receive (Eth to TDM) buffer underflows in the selected interval. In the case of a continuous underflow caused by a loss of Frame flow, a single buffer underflow should be counted.')
ip2IfIntervalStatBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatBufOverflows.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatBufOverflows.setDescription('Number of seconds that the buffer overflows in the selected interval. This records the count of the number of seconds the Receive (Eth to TDM) buffer overflows in the selected interval.')
ip2IfIntervalStatMaxDelayVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatMaxDelayVar.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatMaxDelayVar.setDescription("The maximum size of the buffer (in 10's of usec) in the selected interval.")
ip2IfIntervalStatMinJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatMinJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatMinJittBufLevel.setDescription('The Minimum jitter buffer level (in msec) for the selected interval.')
ip2IfIntervalStatMaxJittBufLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatMaxJittBufLevel.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatMaxJittBufLevel.setDescription('The Maximum jitter buffer level (in msec) for the selected interval.')
ip2IfIntervalStatTxErrFrameSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip2IfIntervalStatTxErrFrameSec.setStatus('current')
if mibBuilder.loadTexts: ip2IfIntervalStatTxErrFrameSec.setDescription('The number of seconds in which errored frames were transmitted during the selected interval. The error may be one of the following: CRC error, Alignment error, Oversized frame, Undersized frame, Aborted frame.')
ip2IfLogEvents = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("all", 2), ("oneMinStep", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfLogEvents.setStatus('current')
if mibBuilder.loadTexts: ip2IfLogEvents.setDescription('This parameter defines whether all Jitter Buffer and Sequence Number events will enter to Log File, or enter those events to Log file in one minute steps.')
ip2IfEthSwitchMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unTagged", 2), ("tagged", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip2IfEthSwitchMode.setStatus('current')
if mibBuilder.loadTexts: ip2IfEthSwitchMode.setDescription('This parameter defines whether Eth Switch is in VLAN Tagged mode.')
alarmStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 5)).setObjects(("RAD-MIB", "atmInterfaceAlarmStatus"))
if mibBuilder.loadTexts: alarmStatusTrap.setStatus('current')
if mibBuilder.loadTexts: alarmStatusTrap.setDescription('The trap is sent whenever there is a transition from a no alarm state to a state with at least one active alarm.')
systemTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 6)).setObjects(("RAD-MIB", "atmNteEventType"), ("RAD-MIB", "agnLed"), ("RAD-MIB", "alarmSeverity"))
if mibBuilder.loadTexts: systemTrap.setStatus('current')
if mibBuilder.loadTexts: systemTrap.setDescription('This trap alerts of major problems in the device.')
alarmLOS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 7)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: alarmLOS.setStatus('current')
if mibBuilder.loadTexts: alarmLOS.setDescription('This trap indicates Loss Of Signal.')
alarmLOF = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 8)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: alarmLOF.setStatus('current')
if mibBuilder.loadTexts: alarmLOF.setDescription('This trap indicates Loss Of Frame.')
channelOperStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 9)).setObjects(("RAD-MIB", "ip2IfOperStatus"))
if mibBuilder.loadTexts: channelOperStatusTrap.setStatus('current')
if mibBuilder.loadTexts: channelOperStatusTrap.setDescription('This trap is sent upon any change in one or more channels.')
alarmAIS = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 10)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: alarmAIS.setStatus('current')
if mibBuilder.loadTexts: alarmAIS.setDescription('This trap indicates AIS.')
alarmRDI = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 11)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: alarmRDI.setStatus('current')
if mibBuilder.loadTexts: alarmRDI.setDescription('This trap indicates RDI.')
alarmFEBE = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 12)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: alarmFEBE.setStatus('current')
if mibBuilder.loadTexts: alarmFEBE.setDescription('This trap indicates FEBE.')
localConnStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 13)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: localConnStatusTrap.setStatus('current')
if mibBuilder.loadTexts: localConnStatusTrap.setDescription('This trap is sent upon a change in Local connectivity of Bundle connection.')
remoteConnStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 14)).setObjects(("RAD-MIB", "alarmSeverity"), ("RAD-MIB", "alarmState"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: remoteConnStatusTrap.setStatus('current')
if mibBuilder.loadTexts: remoteConnStatusTrap.setDescription('This trap is sent upon a change in Remote connectivity of Bundle connection.')
bundleConnectionStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 0, 15)).setObjects(("IF-MIB", "ifAlias"), ("RAD-MIB", "ip2IfOperStatus"))
if mibBuilder.loadTexts: bundleConnectionStatusTrap.setStatus('current')
if mibBuilder.loadTexts: bundleConnectionStatusTrap.setDescription('This trap is sent upon any change in the connectivity status of a Bundle (ip2IfOperStatus). The ifAlias index is the ifIndex of the bundle that its status has been changed.')
broadbandIf = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8))
bdbandConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1))
prtPhyPerfHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2))
prtBdbandIndTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1), )
if mibBuilder.loadTexts: prtBdbandIndTable.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIndTable.setDescription('The Indication Signal table.')
prtBdbandIndEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtBdbandCnfgIdx"), (0, "RAD-MIB", "prtBdbandIdx"), (0, "RAD-MIB", "prtBdbandIndSig"), (0, "RAD-MIB", "prtBdbandIndEvent"))
if mibBuilder.loadTexts: prtBdbandIndEntry.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIndEntry.setDescription('An entry in the Indication Signal table.')
prtBdbandCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBdbandCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtBdbandCnfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer. 255=Temporary Cnfg (when relevant, Set is done only to this configuration). For Agents that support only one configuration, this object will be constant=1. ')
prtBdbandIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBdbandIdx.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIdx.setDescription("This object indicates a unique port or interface number. For numbering, see product's spec. For some products, the numbering can equal ifIndex.")
prtBdbandIndSig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ais", 1), ("rdi", 2), ("aisAndRdi", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBdbandIndSig.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIndSig.setDescription('This object indicates a unique Indication Signal. ais(1) = AIS = Alarm Indication Signal. rdi(2) = RDI = Remote Defect Indication.')
prtBdbandIndEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("slm", 2), ("fail", 3), ("eed", 4), ("pathTrace", 5), ("lom", 6), ("lop", 7), ("slu", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBdbandIndEvent.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIndEvent.setDescription('This object indicates a unique Event that can cause the Indication Signal. slm(2) = SLM = Signal Label Mismatch eed(4) = EED = Excessive Error Defect pathTrace(5) = the end-to-end source/destination of information is wrong. lom(6) = LOM = Loss of Multiframe. lop(7) = LOP = Loss of Pointer. slu(8) = SLU = Signal Label Unequipped.')
prtBdbandIndSigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtBdbandIndSigEnable.setStatus('current')
if mibBuilder.loadTexts: prtBdbandIndSigEnable.setDescription('This object allows user to define if the event specified by prtBdbandIndEvent will cause creation of the Indication Signal specified by prtBdbandIndSig or not. disable - will not enable causing the signal enable - will enable causing the signal. ')
prtBdbandRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prtBdbandRowStatus.setStatus('current')
if mibBuilder.loadTexts: prtBdbandRowStatus.setDescription('Creation/Deletion of rows in the table.')
prtPhyConfigTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 2), )
if mibBuilder.loadTexts: prtPhyConfigTable.setStatus('current')
if mibBuilder.loadTexts: prtPhyConfigTable.setDescription('The Phy Config table. Used now for Phy25.6 Mbps.')
prtPhyConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtPhyConfigEntry.setStatus('current')
if mibBuilder.loadTexts: prtPhyConfigEntry.setDescription('An entry in the Phy Config table. ')
prtPhyTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: prtPhyTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement period.')
prtPhyValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyValidIntervals.setStatus('current')
if mibBuilder.loadTexts: prtPhyValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 96 unless the interface was brought online within the last 24 hours, in which case the value will be the number of complete 15 minute since the interface has been online.')
prtPhyCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1), )
if mibBuilder.loadTexts: prtPhyCurrentTable.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentTable.setDescription('The 25.6 Mbps Section/Line Current table.')
prtPhyCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prtPhyCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentEntry.setDescription('An entry in the 25.6 Mbps Line Current table. ifIndex of the line 25.6 Mbps layer of type 25.6 Mbps.')
prtPhyCurrentLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentLOS.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentLOS.setDescription('The counter associated with the number of Loss Of Sync seconds, encountered by a 25.6 Mbps interface in the current 15 minute interval.')
prtPhyCurrentLSV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentLSV.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentLSV.setDescription('The counter associated with the number of Line symbol violation seconds, encountered by a 25.6 Mbps interface in the current 15 minute interval.')
prtPhyCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentUAS.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentUAS.setDescription('The counter associated with the number of UAS encountered by a 25.6 Mbps interface in the current 15 minute interval.')
prtPhyCurrentSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentSES.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentSES.setDescription('The counter associated with the number of SES encountered by a 25.6 Mbps interface in the current 15 minute interval.')
prtPhyCurrentES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentES.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentES.setDescription('The number of Errored Seconds, encountered by a 25.6 Mbps interface in the current 15 minute interval.')
prtPhyCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentStatus.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentStatus.setDescription('The statuses of the current interval: 0 - O.K. 1 - The link has been switched by a redundancy mechanism. 2 - Module is in/out. 4 - Empty - card is out.')
prtPhyCurrentLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyCurrentLOF.setStatus('current')
if mibBuilder.loadTexts: prtPhyCurrentLOF.setDescription('The number of Loss of Frames, encountered by an interface in the current 15 minute interval.')
prtPhyIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2), )
if mibBuilder.loadTexts: prtPhyIntervalTable.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalTable.setDescription('The Line Interval table.')
prtPhyIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "prtPhyIntervalNumber"))
if mibBuilder.loadTexts: prtPhyIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalEntry.setDescription('An entry in the 25.6 Mbps Line Interval table. ifIndex of the line 25.6 Mbps layer of type 25.6 Mbps.')
prtPhyIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
prtPhyIntervalLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalLOS.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalLOS.setDescription('The counter associated with the number of Loss Of Sync seconds , encountered by a 25.6 Mbps interface in one of the previous 96, individual 15 minute intervals.')
prtPhyIntervalLSV = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalLSV.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalLSV.setDescription('The counter associated with the number of line symbol violation seconds , encountered by a 25.6 Mbps interface in one of the previous 96, individual 15 minute intervals.')
prtPhyIntervalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalUAS.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalUAS.setDescription('The counter associated with the number of UAS encountered by a 25.6 Mbps interface in one of the previous 96, individual 15 minute intervals.')
prtPhyIntervalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalSES.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalSES.setDescription('The counter associated with the number of SES encountered by a 25.6 Mbps interface in one of the previous 96, individual 15 minute intervals.')
prtPhyIntervalES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalES.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalES.setDescription('The number of Errored Seconds, encountered by a 25.6 Mbps interface in one of the previous 96, individual 15 minute intervals.')
prtPhyIntervalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalStatus.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalStatus.setDescription(' The statuses of the current interval: 0 - O.K. 1 - The link has been switched by a redundancy mechanism. 2 - Module is in/out. 4 - Empty - card is out.')
prtPhyIntervalLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 8, 2, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhyIntervalLOF.setStatus('current')
if mibBuilder.loadTexts: prtPhyIntervalLOF.setDescription('The number of Loss of Frames, encountered by an interface in one of the previous 96, individual 15 minute intervals.')
webranger = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2))
wrSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 1))
wrBraodcastCtrlCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("block", 1), ("forward", 2), ("blockLinkPropagation", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrBraodcastCtrlCmd.setStatus('current')
if mibBuilder.loadTexts: wrBraodcastCtrlCmd.setDescription('This parameter is a command to the webranger CPU. It enables blocking or forwarding broadcast frames, which may cause a trigger to a connection. block (1) - blocks the broadcast frames. forward (2) - forwards the broadcast frames. blockLinkPropagation (3) - blocks the broadcast frames to the links, tx to the LAN. ')
wrFrSelfLearningMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrFrSelfLearningMode.setStatus('current')
if mibBuilder.loadTexts: wrFrSelfLearningMode.setDescription("This parameter enables the webranger to learn the DLCi's configuration and maintanance protocol. off - will get the configuration by setting it. on - disables configuration and start self learning.")
wrGratuitousArp = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrGratuitousArp.setStatus('current')
if mibBuilder.loadTexts: wrGratuitousArp.setDescription("This parameter enables/disables the Gratuitous ARP feature. When enabled, the feature means: when receiving ARP with sender's Source IP Address that already exists in the ARP table - replace MAC Address with sender's Source MAC Address.")
wrIpRouterInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2))
wrConfigIpDhcp = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1))
wrConfigIpDNS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 2))
wrDhcpAction = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrDhcpAction.setStatus('current')
if mibBuilder.loadTexts: wrDhcpAction.setDescription('Activating (disable/enable) DHCP server operation. Since DHCP Server and DHCP Relay cannot reside in same device, DHCP Relay may be enabled (per interface), only if server action is disabled. For some devices, this object is used in order to enable/disable the DHCP Client. See device SDS.')
wrDhcpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2), )
if mibBuilder.loadTexts: wrDhcpTable.setStatus('current')
if mibBuilder.loadTexts: wrDhcpTable.setDescription('A list of DHCP entries. The number of entries is up to DHCP current entries, according to the WEBRANger model.')
wrDhcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "wrDhcpLowIpAddress"))
if mibBuilder.loadTexts: wrDhcpEntry.setStatus('current')
if mibBuilder.loadTexts: wrDhcpEntry.setDescription('DHCP parameters per entry of the DHCP table.')
wrDhcpLowIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 1), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpLowIpAddress.setStatus('current')
if mibBuilder.loadTexts: wrDhcpLowIpAddress.setDescription('DHCP Low Ip Address.')
wrDhcpHighIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpHighIpAddress.setStatus('current')
if mibBuilder.loadTexts: wrDhcpHighIpAddress.setDescription('DHCP High Ip Address.')
wrDhcpIpMaskAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpIpMaskAddress.setStatus('current')
if mibBuilder.loadTexts: wrDhcpIpMaskAddress.setDescription('IP mask Address.')
wrDhcpDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: wrDhcpDefaultGateway.setDescription("Default Gateway's IP Address.")
wrDhcpPrimaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpPrimaryDNS.setStatus('current')
if mibBuilder.loadTexts: wrDhcpPrimaryDNS.setDescription('Primary DNS.')
wrDhcpSecondaryDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 6), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpSecondaryDNS.setStatus('current')
if mibBuilder.loadTexts: wrDhcpSecondaryDNS.setDescription('Secondary DNS.')
wrDhcpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("all", 1), ("lan1", 2), ("lan2", 3), ("anyLan", 4), ("wan", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpInterface.setStatus('current')
if mibBuilder.loadTexts: wrDhcpInterface.setDescription('The IP addresse allocation is done according to the interface type from which the DHCP request arrives.')
wrDhcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpRowStatus.setStatus('current')
if mibBuilder.loadTexts: wrDhcpRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set wrDhcpRowStatus.id = active(1). For destroying a row, the NMS should set: wrDhcpStatus.id = destroy(6). Only rows with status active(1) are relevant. The only possible supported RowStatus vaules are active (1) and destroy (6).')
wrDhcpIpAddressLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpIpAddressLeaseTime.setStatus('current')
if mibBuilder.loadTexts: wrDhcpIpAddressLeaseTime.setDescription('Allocated IP Address lease time in seconds. A zero value specifies no time limitation.')
wrDhcpPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpPoolName.setStatus('current')
if mibBuilder.loadTexts: wrDhcpPoolName.setDescription('DHCP pool name - string with max length of 10 characters')
wrDhcpTftpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 11), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpTftpServerIp.setStatus('current')
if mibBuilder.loadTexts: wrDhcpTftpServerIp.setDescription('DHCP pool - TFTP-server IP Address.')
wrDhcpConfigFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 2, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrDhcpConfigFileName.setStatus('current')
if mibBuilder.loadTexts: wrDhcpConfigFileName.setDescription('TFTP-name of the configuration File Name for DHCP pool.')
dhcpPoolAllocTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3), )
if mibBuilder.loadTexts: dhcpPoolAllocTable.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocTable.setDescription("A list of DHCP Pool Allocation entries. Each entry (row) consist of a single IP Address belonging to DHCP pool whose lowest IP address is dhcpPoolAllocLowIpAddress. This IP address may be offered for leasing, or may already be leased (in use) by Host it's MacAddress is dhcpPoolAllocMacAddress. Time left for leasing period is indicated by dhcpPoolAllocTimeLeft. All posible statuses of IP address are indicated and controlled by dhcpPoolAllocFlags")
dhcpPoolAllocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1), ).setIndexNames((0, "RAD-MIB", "dhcpPoolAllocLowIpAddress"), (0, "RAD-MIB", "dhcpPoolAllocLeasingIpAddress"))
if mibBuilder.loadTexts: dhcpPoolAllocEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocEntry.setDescription('DHCP Pool Allocation parameters per entry of the DHCP Pool Allocation table.')
dhcpPoolAllocLowIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolAllocLowIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocLowIpAddress.setDescription('Lowest IP address of this pool, value eqaul to wrDhcpLowIpAddress for the pool.')
dhcpPoolAllocLeasingIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolAllocLeasingIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocLeasingIpAddress.setDescription('Single IP Address belonging to dhcp pool whose Lowest Ip Address is dhcpPoolAllocLowIpAddress. This IP address may be offered for leasing or may be leased by Host its MacAddress is dhcpPoolAllocMacAddress. All posible statuses of IP address are indicated by dhcpPoolAllocFlags ')
dhcpPoolAllocMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolAllocMacAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocMacAddress.setDescription('MAC Address to which the IP address has been leased ')
dhcpPoolAllocTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolAllocTimeLeft.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocTimeLeft.setDescription('IP address leasing time left in seconds ')
dhcpPoolAllocFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("free", 2), ("inUse", 3), ("offered", 4), ("forbidden", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolAllocFlags.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocFlags.setDescription('These flags indicates status of each IP address. User may change value to free, via dhcpPoolAllocFreeCmd ')
dhcpPoolAllocFreeCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolAllocFreeCmd.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolAllocFreeCmd.setDescription('Setting this attribute to On (3), will enforce the agent to Free this entry. The Agent will change the value of this MIB object to off(2) automatically, after performing the command. Setting this object to off(2), will do nothing')
dhcpRelayTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 4), )
if mibBuilder.loadTexts: dhcpRelayTable.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayTable.setDescription('A list of DHCP relay entries.')
dhcpRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dhcpRelayEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayEntry.setDescription('DHCP Relay parameters per entry of the DHCP relay table.')
dhcpRelayAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayAction.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayAction.setDescription('Setting this attribute to enable (3), will enable DHCP Relay action for this interface (Only if DHCP Server is disabled for device - wrDhcpAction=disable). dhcpRelayServerIpAddressaddress should not be 0.0.0.0 when enable is set')
dhcpRelayServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayServerIpAddress.setDescription('DHCP Server IP Address.')
dhcpRelayMaxHop = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 4, 1, 3), Integer32().clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayMaxHop.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayMaxHop.setDescription('Maximum number of hops till DHCP Server. upper limit is 16 hops')
wrDhcpPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("all", 2), ("outOfBand", 3), ("lan1", 4), ("lan2", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrDhcpPort.setStatus('current')
if mibBuilder.loadTexts: wrDhcpPort.setDescription('This parameter defines the port that DHCP flow will be actiavted.')
dhcpClientTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6), )
if mibBuilder.loadTexts: dhcpClientTable.setStatus('current')
if mibBuilder.loadTexts: dhcpClientTable.setDescription('A list of DHCP client entries.')
dhcpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dhcpClientEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpClientEntry.setDescription('DHCP Client parameters per entry of the DHCP Client table.')
dhcpClientAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpClientAction.setStatus('current')
if mibBuilder.loadTexts: dhcpClientAction.setDescription('This parameter default value is enable(3). Setting this attribute to disable (2), will disable DHCP Client action for this interface. This parameter can be changed to disable (2) only (it cannot be changed from disable to enable).')
dhcpClientServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpClientServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpClientServerIpAddress.setDescription('DHCP Server IP Address.')
dhcpClientLeaseExpirationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientLeaseExpirationTime.setStatus('current')
if mibBuilder.loadTexts: dhcpClientLeaseExpirationTime.setDescription('This parameter holds the time (in minutes) left until lease expiration.')
dhcpClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 6, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpClientStatus.setDescription('This parametr displays the DHCP status.')
dhcpIfClientTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 7), )
if mibBuilder.loadTexts: dhcpIfClientTable.setStatus('current')
if mibBuilder.loadTexts: dhcpIfClientTable.setDescription('DHCP client entries for each Interface.')
dhcpIfClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "dhcpIfClientIpAddress"))
if mibBuilder.loadTexts: dhcpIfClientEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpIfClientEntry.setDescription('DHCP Clients per entry of the DHCP Interface Client table.')
dhcpIfClientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 7, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpIfClientIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpIfClientIpAddress.setDescription('DHCP Client IP Address.')
dhcpIfClientRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpIfClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpIfClientRowStatus.setDescription('The row status used for creating, modifying, and deleting instances of the columnar objects in the dhcpIfClientTable. For Vmux Devices, it will be possible only to Delete instances. The addition of Clients will be done automatically by the Server according to Network messages that are sent by the Clients; not via SNMP. In order to Delete a Client, this MIB object should be set to: destroy (6).')
dhcpServerAction = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("noOp", 2), ("deleteAllClients", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpServerAction.setStatus('current')
if mibBuilder.loadTexts: dhcpServerAction.setDescription('This variable enables the operator to perform one of the specified actions on the Server. deleteAllClients (3) is an option that is used for a device functioning as a server. It will remove all the clients from all the interfaces of the device. When the operation is complete, the agent will return a noOp (2) value.')
wrDNSRelayAction = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrDNSRelayAction.setStatus('current')
if mibBuilder.loadTexts: wrDNSRelayAction.setDescription('When Enabled, device will act as a DNS Relay: whenever the device receives a DNS request from its host, it will forward it to the DNS server as if the request was initiated by the device itself. The reply from the DNS server is forwarded by the device to the host as if the device was answering the request.')
wrConfigIpxRouterInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3))
wrAutoLearnLanIpxNets = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrAutoLearnLanIpxNets.setStatus('current')
if mibBuilder.loadTexts: wrAutoLearnLanIpxNets.setDescription('Activating (disable/enable) the auto-learn operation.')
wrLanIpxNetTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 2), )
if mibBuilder.loadTexts: wrLanIpxNetTable.setStatus('current')
if mibBuilder.loadTexts: wrLanIpxNetTable.setDescription('Lan IPX nets Table.')
wrLanIpxNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "wrLanifIndex"), (0, "RAD-MIB", "wrLanIpxFrameType"))
if mibBuilder.loadTexts: wrLanIpxNetEntry.setStatus('current')
if mibBuilder.loadTexts: wrLanIpxNetEntry.setDescription('IPX Nets per frame type & LAN port. The table entries will be created by the agent')
wrLanifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrLanifIndex.setStatus('current')
if mibBuilder.loadTexts: wrLanifIndex.setDescription('LAN port ifIndex.')
wrLanIpxFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t8023", 1), ("ethernet", 2), ("t8022", 3), ("snap", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrLanIpxFrameType.setStatus('current')
if mibBuilder.loadTexts: wrLanIpxFrameType.setDescription('Frame Type')
wrIpxNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrIpxNetAddress.setStatus('current')
if mibBuilder.loadTexts: wrIpxNetAddress.setDescription('Net address per Frame Type & LAN port.')
wrDialInIpxNet = MibScalar((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrDialInIpxNet.setStatus('current')
if mibBuilder.loadTexts: wrDialInIpxNet.setDescription('Net address through a link.')
ripSapIfConfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 4), )
if mibBuilder.loadTexts: ripSapIfConfTable.setStatus('current')
if mibBuilder.loadTexts: ripSapIfConfTable.setDescription('A list of Interfaces which require separate configuration in RIP/SAP.')
ripSapIfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 4, 1), ).setIndexNames((0, "RAD-MIB", "ripSapIfConfIfIndex"))
if mibBuilder.loadTexts: ripSapIfConfEntry.setStatus('current')
if mibBuilder.loadTexts: ripSapIfConfEntry.setDescription('A Single Routing Domain in a single Subnet.')
ripSapIfConfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripSapIfConfIfIndex.setStatus('current')
if mibBuilder.loadTexts: ripSapIfConfIfIndex.setDescription('The interface ifIndex.')
ripSapIfConfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripSapIfConfMode.setStatus('current')
if mibBuilder.loadTexts: ripSapIfConfMode.setDescription('The ifIndex RIP/SAP mode.')
ripSapIfConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 3, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripSapIfConfStatus.setStatus('current')
if mibBuilder.loadTexts: ripSapIfConfStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set ripSapIfConfStatus.id1 = active(1). For destroying a row, the NMS should set: ripSapIfConfStatus.id1 = destroy(6). Only rows with status active(1) are relevant. The only possible supported RowStatus vaules are active (1) and destroy (6).')
wrInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4))
wrIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1), )
if mibBuilder.loadTexts: wrIpAddressTable.setStatus('current')
if mibBuilder.loadTexts: wrIpAddressTable.setDescription('Link IP addresses Table.')
wrIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "wrIpIfIndex"))
if mibBuilder.loadTexts: wrIpAddressEntry.setStatus('current')
if mibBuilder.loadTexts: wrIpAddressEntry.setDescription('Ip Address per Link')
wrIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrIpIfIndex.setStatus('current')
if mibBuilder.loadTexts: wrIpIfIndex.setDescription('Port interface index.')
wrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrIpAddress.setStatus('current')
if mibBuilder.loadTexts: wrIpAddress.setDescription('Link IP Address.')
wrIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrIpMask.setStatus('current')
if mibBuilder.loadTexts: wrIpMask.setDescription('Link IP mask Address.')
wrIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrIpRowStatus.setStatus('current')
if mibBuilder.loadTexts: wrIpRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set wrIpRowStatus.id1 = active(1). For destroying a row, the NMS should set: wrIpRowStatus.id1 = destroy(6). Only rows with status active(1) are relevant. The only possible supported RowStatus vaules are active (1) and destroy (6).')
wrSpoofingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2), )
if mibBuilder.loadTexts: wrSpoofingTable.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingTable.setDescription('Spoofing Table.')
wrSpoofingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "wrSpoofingIfIndex"))
if mibBuilder.loadTexts: wrSpoofingEntry.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingEntry.setDescription('Spoofing per Link')
wrSpoofingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrSpoofingIfIndex.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingIfIndex.setDescription('Port interface index.')
wrSpoofingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrSpoofingAction.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingAction.setDescription("Spoofing action is applied by bit code: enable : bit 0 set (disable: bit 0 is 0) keepAlive : bit 1 ... : bit 2 and so on. For the above example, to set spoofing to keepAlive action, the object's value will be 3 = [ 2**0 + 2**1 ] Only the Remote WEBRANger will accept this object ! ------- ")
wrSpoofingAgingStation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrSpoofingAgingStation.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingAgingStation.setDescription(" Aging time of stations list, in min. The agent 'translates' the time entered in minutes, to 10 min. resolution, as follows: 1..10 min - 10 min 11..20 min - 20 min and so on... 0 is not a valid value. Only the Remote WEBRANger will accept this object ! ---------------- ")
wrSpoofingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wrSpoofingRowStatus.setStatus('current')
if mibBuilder.loadTexts: wrSpoofingRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set wrSpoofingRowStatus.id1 = active(1). For destroying a row, the NMS should set: wrSpoofingRowStatus.id1 = destroy(6). Only rows with status active(1) are relevant. The only possible supported RowStatus vaules are active (1) and destroy (6).')
wrLanIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3), )
if mibBuilder.loadTexts: wrLanIfTable.setStatus('current')
if mibBuilder.loadTexts: wrLanIfTable.setDescription('Link IP addresses Table.')
wrLanIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3, 1), ).setIndexNames((0, "RAD-MIB", "wrLanIfIndex"))
if mibBuilder.loadTexts: wrLanIfEntry.setStatus('current')
if mibBuilder.loadTexts: wrLanIfEntry.setDescription('Ip Address per Link')
wrLanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrLanIfIndex.setStatus('current')
if mibBuilder.loadTexts: wrLanIfIndex.setDescription('Port interface index.')
wrLanBridgeRouterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 1), ("bridge", 2), ("ipRouter", 3), ("ipxRouter", 4), ("ipAndIpxRouter", 5), ("bRouter", 6), ("ipBrouter", 7), ("ipxBrouter", 8), ("ipAndIpxBrouter", 9), ("bridgeAndStp", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrLanBridgeRouterMode.setStatus('current')
if mibBuilder.loadTexts: wrLanBridgeRouterMode.setDescription("This parameter indicates whether the link is Bridge or Router and specifies the Router's type.")
wrLanIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3), ("redundancy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrLanIfState.setStatus('current')
if mibBuilder.loadTexts: wrLanIfState.setDescription("The LAN is disabled or enabled. For LAN 2 it can be also 'redundancy'.")
wrLanIfRdnTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrLanIfRdnTimeout.setStatus('current')
if mibBuilder.loadTexts: wrLanIfRdnTimeout.setDescription('LAN Redundancy Timeout in seconds. Applicable when wrLanIfState=redundancy.')
wrSyncCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 4), )
if mibBuilder.loadTexts: wrSyncCnfgTable.setStatus('current')
if mibBuilder.loadTexts: wrSyncCnfgTable.setDescription('Configuration table for Async interface.')
wrSyncCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 4, 1), ).setIndexNames((0, "RAD-MIB", "wrSyncIfIndex"))
if mibBuilder.loadTexts: wrSyncCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: wrSyncCnfgEntry.setDescription('Configuration table')
wrSyncIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wrSyncIfIndex.setStatus('current')
if mibBuilder.loadTexts: wrSyncIfIndex.setDescription('Sync interface index.')
wrSyncClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("manual", 2), ("program", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrSyncClkMode.setStatus('current')
if mibBuilder.loadTexts: wrSyncClkMode.setDescription('Clock Mode.')
wrSyncClkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("r16", 2), ("r32", 3), ("r48", 4), ("r64", 5), ("r96", 6), ("r128", 7), ("r256", 8), ("r768", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrSyncClkRate.setStatus('current')
if mibBuilder.loadTexts: wrSyncClkRate.setDescription('Clock Rate in. Rate can be changed if Clock Mode is Program only.')
wrFrCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 5), )
if mibBuilder.loadTexts: wrFrCnfgTable.setStatus('current')
if mibBuilder.loadTexts: wrFrCnfgTable.setDescription('Configuration table for Fr parameters that do not exist in RFC2115.')
wrFrCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: wrFrCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: wrFrCnfgEntry.setDescription('Configuration entry for Fr parameters that do not exist in RFC2115.')
wrFrDlciLearningMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrFrDlciLearningMode.setStatus('current')
if mibBuilder.loadTexts: wrFrDlciLearningMode.setDescription("This parameter enables the webranger to learn the DLCi's configuration and maintanance protocol for the current interface. off - the WR will read the user's configuration for this interface. on - the WR will begin self learning of the current interface's maintanance protocol and DLCIs.")
wrFrCllmMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 11, 7, 2, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrFrCllmMessages.setStatus('current')
if mibBuilder.loadTexts: wrFrCllmMessages.setDescription('This parameter enables/disables the Webranger to Tx/Rx CLLM (Consolidated Link Layer Management) messages via DLCI 1023. The CLLM messages are link layer control messages. They can be used for example in cases of congestion. The CLLM message contains a code for cause of congestion and list of all DLCIs that should act to reduce data transmission.')
dacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3))
systemDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1))
mdlDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2))
prtDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3))
genDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 4))
sysSa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1))
sysHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2))
sysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3))
sysCurrentAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4))
sysBufferAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5))
sysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6))
sysDbase = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7))
sysSaSwchStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaSwchStatus.setStatus('current')
if mibBuilder.loadTexts: sysSaSwchStatus.setDescription("This object indicates the status of the switches on the SA unit. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits. For SMODs products see modem's specification. For DXC product see the following: There are 4 switches: bit 0 SP-PAR (LSB) '1' - Default parameters bit 1 PSWRD '1' - Password=default '0' - Password=user selected bit 2 DB-INIT '1' - DB initiated with default '0' - DB initiated with NVRAM contents bit 3 PC-SP (MSB) '1' - Management by terminal only '0' - Management by NMS Example: If SP-PAR and PSWRD bits are set ('1'), the value will be 3 (2**1 + 2**0). When the status of the switches is unknown, the value of this object will be 255.")
sysSaSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaSwRevision.setStatus('current')
if mibBuilder.loadTexts: sysSaSwRevision.setDescription('This object indicates the Software revision of the system.')
sysSaHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaHwVersion.setStatus('current')
if mibBuilder.loadTexts: sysSaHwVersion.setDescription('This object indicates the Hardware version of the system.')
sysSaPorts = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaPorts.setStatus('current')
if mibBuilder.loadTexts: sysSaPorts.setDescription("This object indicates the ports that are present in the system. Each possible port is represented by a bit. The value of this object is a sum of 2**n, n=number of bits. '1' - means that the port exists '0' - means that the port does not exist For detailed bit assignment, see product's spec. Bit 0 = LSB When this object is not relevant, the value will be 0. In some cases, this object may represent ports configuration of the system AND its far-end unit.")
sysSaReadSwch = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSaReadSwch.setStatus('current')
if mibBuilder.loadTexts: sysSaReadSwch.setDescription('This object indicates wether the configuration will be read from the DIP switches on the SA (stand alone) unit. Each switch is represented by a bit. If the bit is 1: the configuration will be read from the HW switch position. If the bit is 0: the configuration will be read from the SW user configuration. The DIP switches are different in each of the RAD devices. In the Tiny Router (starting from the LSB) the following switches exist: Bit 0: WAN Loop Bit 1: LAN Full Duplex (When LAN AUI connector, it is SQE) Bit 2: PPP (When WAN 4 Wire connector, it is LONG) Bit 3: IP Learn')
sysSaBuActivePort = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("e1T1orSerial", 2), ("eth", 3), ("primary", 4), ("secondary", 5), ("third", 6), ("fourth", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaBuActivePort.setStatus('current')
if mibBuilder.loadTexts: sysSaBuActivePort.setDescription('This object shows through which port the traffic is flowing (the current Active Port) when the Backup mechanism exists. When No Backup exists in the device, the value should be: notApplicable(1).')
sysChas = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1))
chassTotalNoOfSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfSlt.setStatus('current')
if mibBuilder.loadTexts: chassTotalNoOfSlt.setDescription('This object indicates the number of physical slots in the Hub chassis.')
chassTotalNoOfIoSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfIoSlt.setStatus('current')
if mibBuilder.loadTexts: chassTotalNoOfIoSlt.setDescription('This object indicates the total number of physical IO slots in the chassis, (not all slots must be occupied and active).')
chassTotalNoOfPsSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfPsSlt.setStatus('current')
if mibBuilder.loadTexts: chassTotalNoOfPsSlt.setDescription('This object indicates the number of physical Power Supply slots in the chassis.')
chassTotalNoOfClSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfClSlt.setStatus('current')
if mibBuilder.loadTexts: chassTotalNoOfClSlt.setDescription('This object indicates the number of physical Common Logic slots in the chassis.')
chassTotalNoOfMlSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfMlSlt.setStatus('current')
if mibBuilder.loadTexts: chassTotalNoOfMlSlt.setDescription('This object indicates the number of physical Main Link slots in the chassis (Kmux).')
sysDcl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2))
sysDclTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1), )
if mibBuilder.loadTexts: sysDclTable.setStatus('current')
if mibBuilder.loadTexts: sysDclTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysDclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "sysDclCnfgIdx"))
if mibBuilder.loadTexts: sysDclEntry.setStatus('current')
if mibBuilder.loadTexts: sysDclEntry.setDescription('An entry in table.')
sysDclCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: sysDclCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg. This object is identical for all the configurations (1..255). Only the TmpCnf(255) might have a different value. For devices that work on line with NMS (no Temp configuration in NMS), Get and Set will be performed with index value of sysDclCnfgIdx = 1.')
sysDclRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclRedundancy.setStatus('current')
if mibBuilder.loadTexts: sysDclRedundancy.setDescription(' DCL redundancy desired state.')
sysDclActiveCl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("dclA", 2), ("dclB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclActiveCl.setStatus('current')
if mibBuilder.loadTexts: sysDclActiveCl.setDescription("Active desired DCL. When 'auto' is selected, the system automatically selects the active DCL.")
sysDclFlipDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclFlipDelay.setStatus('current')
if mibBuilder.loadTexts: sysDclFlipDelay.setDescription('If one DCL flip occurred and a second one should be performed, the time from the previous flip is checked. If the time is shorter than the delay specified here, the system should delay the flip operation until time reaches the specified delay. For DXC the values are 1 minute to 4 minutes (1..4). For Optimux-155-1 and Optimux-155-3 the values are: 0...60 Sec. 0 means No Delay.')
sysDclFlipUponStnClk = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclFlipUponStnClk.setStatus('current')
if mibBuilder.loadTexts: sysDclFlipUponStnClk.setDescription('This object allows user to decide (yes/no) if Agent should Flip from one DCL card to another, when there is Station Clock Fail in the Online DCL card.')
sysDclChFailThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclChFailThreshold.setStatus('current')
if mibBuilder.loadTexts: sysDclChFailThreshold.setDescription('This object indicates the number of failed channels that will trigger the redundancy procedure.')
sysDclChPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclChPriority.setStatus('current')
if mibBuilder.loadTexts: sysDclChPriority.setDescription('This object indicates the Priority for all the channels in the Main Access (Common Logic) card. Each channel is represented by 1 bit. The order of the bits in each byte is from Right to Left (LSB Bit to MSB) starting from BIT 0: 7 6 5 4 3 2 1 0 Channel no. 1 is represented by bit 0. Channel no. 2 is represented by bit 1. Channel no. n is represented by bit n-1. The value of the bit shows the priority. For bit value = 1, Priority = High. For bit value = 0, Priority = Low.')
sysDclConfigDownloadSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dclA", 2), ("dclB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclConfigDownloadSrc.setStatus('current')
if mibBuilder.loadTexts: sysDclConfigDownloadSrc.setDescription("In case of mismatch between the 2 CL card's configuration, the user can decide which card has the suitable configuration. The selected configuration will be downloaded from card A to card B if the value is dclA(2) or from card B to card A if the value is dclB(3). off(1) is used by part of the devices. In this case, after operation ends - value should be automatically set to off(1), which is the default state.")
sysDclSwDownloadSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dclA", 2), ("dclB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclSwDownloadSrc.setStatus('current')
if mibBuilder.loadTexts: sysDclSwDownloadSrc.setDescription("In case of mismatch between the 2 CL card's software, the user can decide which card has the suitable SW. The selected SW will be downloaded from card A to card B if the value is dclA(2) or from card B to card A if the value is dclB(3). off(1) is used by part of the devices. In this case, after operation ends - value should be automatically set to off(1), which is the default state.")
sysDclRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 10), Bits().clone(namedValues=NamedValues(("cnfgMismatch", 0), ("swMismatch", 1), ("cardAAbsent", 2), ("cardBAbsent", 3), ("lossOfCommunication", 4), ("hwMismatch", 5), ("cnfgUpdate", 6), ("swUpdate", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclRedundancyStatus.setStatus('current')
if mibBuilder.loadTexts: sysDclRedundancyStatus.setDescription("Bit map representing current Redundancy Status. bit 0 - Indicates mismatch between the 2 CL cards' Configuration bit 1 - Indicates mismatch between the 2 CL cards' Software. bit 2 - Indicates CL card A Absence. bit 3 - Indicates CL card B Absence. bit 4 - Indicates Loss of Communication between the 2 CL cards. bit 5 - Indicates mismatch between the 2 CL cards' Hardware. bit 6 - Indicates Configuraton update is in process. bit 7 - Indicates Software update is in process. ")
sysDclOnline = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dclA", 1), ("dclB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclOnline.setStatus('current')
if mibBuilder.loadTexts: sysDclOnline.setDescription('The active Dcl card of the agent.')
sysDclCopyDbTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3), )
if mibBuilder.loadTexts: sysDclCopyDbTable.setStatus('current')
if mibBuilder.loadTexts: sysDclCopyDbTable.setDescription('This table enables to copy a cofiguration from the Offline Dcl to the Online Dcl.')
sysDclCopyDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "sysDclCopyDbIdx"))
if mibBuilder.loadTexts: sysDclCopyDbEntry.setStatus('current')
if mibBuilder.loadTexts: sysDclCopyDbEntry.setDescription('An entry in table.')
sysDclCopyDbIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclCopyDbIdx.setStatus('current')
if mibBuilder.loadTexts: sysDclCopyDbIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed. ')
sysDclCopyDbCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclCopyDbCmd.setStatus('current')
if mibBuilder.loadTexts: sysDclCopyDbCmd.setDescription('When this command is sent to the agent, on(3), the Database specified (Db Idx), will be copied from the Offline Dcl to the Online Dcl. Afterwards the value of this object will automatically change to off(2). ')
sysDclFlipCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("flip", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclFlipCmd.setStatus('current')
if mibBuilder.loadTexts: sysDclFlipCmd.setDescription("When the 'flip(3)' command is received by Agent, it will flip (switch) between Offline Dcl and Online Dcl cards. Afterwards the value of this object will automatically change to off(2).")
sysSDateFormat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("ddMMYYYY", 1), ("mmDDYYYY", 2), ("yyyyMMDD", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSDateFormat.setStatus('current')
if mibBuilder.loadTexts: sysSDateFormat.setDescription('This object indicates the date and time format used for the sysSDateAndTimeCmd and for the alarm buffer report.')
sysSDateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSDateCmd.setStatus('current')
if mibBuilder.loadTexts: sysSDateCmd.setDescription("This object indicates the current date as it is known by the agent using its own real-time clock. The format would be as specified by the sysSDateFormat. This parameter can be set for time synchronization between the NMS and the Agent. * For KM-2100 V1 and FCD-T1/E1 - the string should contain '/' signs between day, month and year. Example: 12/08/1998. * For DXC and rest of the products - the string should contain '-' signs between day, month and year. Example: 12-08-1998. The day value will be in the range: 1..31. The month value will be in the range: 1..12. The year value will be in the range: 1996..2050 for products supporting the '-' format.")
sysSTimeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSTimeCmd.setStatus('current')
if mibBuilder.loadTexts: sysSTimeCmd.setDescription("This object indicates the current time as it is known by the agent using its own real-time clock. This parameter can be set for time synchronization between the NMS and the Agent. The string should contain ':' signs between hour, minute and second. Example: 11:05:58.")
sysSActiveCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSActiveCnfg.setStatus('current')
if mibBuilder.loadTexts: sysSActiveCnfg.setDescription('This object specifies the configuration number, that is currently active and running.')
sysSEditCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSEditCnfg.setStatus('current')
if mibBuilder.loadTexts: sysSEditCnfg.setDescription('This object indicates the unique configuration number that is currently loaded into the tmp working space for manipulation and update operations. Value of 255 means no config. is under editing process.')
sysSEditBy = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("snmp", 2), ("terCon1", 3), ("terCon2", 4), ("terInbandCon1", 5), ("terInbandCon2", 6), ("lcd", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSEditBy.setStatus('current')
if mibBuilder.loadTexts: sysSEditBy.setDescription('This entry indicates which MMI application is working on the edited config. The editing phase starts at the first modify operation and ends after a load operation.')
sysSClkSrc = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("internal", 3), ("ml", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSClkSrc.setStatus('current')
if mibBuilder.loadTexts: sysSClkSrc.setDescription('This entry indicates the source of the system clock.')
sysSAlrStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4), ("event", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrStatus.setStatus('current')
if mibBuilder.loadTexts: sysSAlrStatus.setDescription('Indicates the current alarm state only for system level. This object will be : - critical(7): when there is at least one active (ON) critical alarm . - major (3): when there is no active critical alarm, but there is at least one active (ON) major alarm . - minor (4): when there is no active major or critical alarm, but there is at least one active minor alarm. - warning (6): when there is no active major, critical or minor alarm, but there is at least one active warning alarm. - event (5): when there is no active alarm of another type, but there is at least one active event alarm. - off(2): when there is no active (ON) alarm (since last clear operation).')
sysSAlrStatusAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4), ("event", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrStatusAll.setStatus('current')
if mibBuilder.loadTexts: sysSAlrStatusAll.setDescription('Indicates the current alarm state including all levels: system, card, port. - critical(7): when there is at least one active (ON) critical alarm . - major (3): when there is no active critical alarm, but there is at least one active (ON) major alarm . - minor (4): when there is no active major or critical alarm, but there is at least one active minor alarm. - warning (6): when there is no active major, critical or minor alarm, but there is at least one active warning alarm. - event (5): when there is no active alarm of another type, but there is at least one active event alarm. - off(2): when there is no active (ON) alarm (since last clear operation).')
sysSTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSTestStatus.setStatus('current')
if mibBuilder.loadTexts: sysSTestStatus.setDescription('Indicates the current test status (for all levels: system, card, port). This attribute will be set to: - on(3): when there is at least one test in progress on the system/card/port otherwise the value will be off(2).')
sysSSanityCheckStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("fail", 2), ("warning", 3), ("ok", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSSanityCheckStatus.setStatus('current')
if mibBuilder.loadTexts: sysSSanityCheckStatus.setDescription('Upon completion of the Sanity Check process on the TmpCnfg this object will be set to: - fail(2): when there is at least one error (which is not just a warning) encountered otherwise, - warning(3): when there are only warnings otherwise, - ok(4). The value should be unknown(1), if the TmpCnfg was changed after the last Sanity check.')
sysSNoOfSanityCheckErr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSNoOfSanityCheckErr.setStatus('current')
if mibBuilder.loadTexts: sysSNoOfSanityCheckErr.setDescription('This object indicates the number of errors/warnings discovered by the last Sanity Check process.')
sysSErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13), )
if mibBuilder.loadTexts: sysSErrListTable.setStatus('current')
if mibBuilder.loadTexts: sysSErrListTable.setDescription('A table.')
sysSErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1), ).setIndexNames((0, "RAD-MIB", "sysSErrType"), (0, "RAD-MIB", "sysSErrIdx"))
if mibBuilder.loadTexts: sysSErrListEntry.setStatus('current')
if mibBuilder.loadTexts: sysSErrListEntry.setDescription('An entry in table.')
sysSErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("warning", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrType.setStatus('current')
if mibBuilder.loadTexts: sysSErrType.setDescription('The errors are recorded in the agent, in two separate lists, according to their type: error or warning.')
sysSErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrIdx.setStatus('current')
if mibBuilder.loadTexts: sysSErrIdx.setDescription("Unique index number to identify an entry in the error or warning list . The maximum value cannot exceed the value of 'sysSNoOfSanityCheckErr' (actually, the sum of the Errors list max. index and the Warning list max. index should equal the value of'sysSNoOfSanityCheckErr').")
sysSErrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrDescription.setStatus('current')
if mibBuilder.loadTexts: sysSErrDescription.setDescription('This object is a full text description of the sanity check error including error code, IO slot and port numbers related to the code .')
sysSMaxNoOfCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSMaxNoOfCnfg.setStatus('current')
if mibBuilder.loadTexts: sysSMaxNoOfCnfg.setDescription('Maximum number of configurations that can be defined and stored in the DACS agent. If the DACS agent has a large capacity, the maximum will be limited to 254.')
sysSSelfTestResult = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSSelfTestResult.setStatus('current')
if mibBuilder.loadTexts: sysSSelfTestResult.setDescription("The test is performed by the active Common Logic card. The result will be a sum of 2**n according to the following bit convention: For DXC: bit 0 Database 1 Checksum Error (LSB) bit 1 Database 2 Checksum Error bit 2 I/O Expander Error bit 3 Counter Error bit 4 Matrix DPR Error bit 5 PS-A 5 Volt Error bit 6 PS-A 12 Volt Error bit 7 PS-B 5 Volt Error bit 8 PS-B 12 Volt Error bit 9 EPROM Failure For FCD: bit 0 I/O Expander Error (LSB) bit 1 Counter Error bit 2 EPROM Failure bit 3 Illegal Sys Config bit 4 SFIFO bit 5 EPIC Failure (ISDN) bit 6 XL Flash Fail -- for MSDSL interface bit 7 XL MITEL Fail -- for MSDSL interface bit 8 XL Framer Fail -- for MSDSL interface bit 9 XL DSP Fail -- for MSDSL interface For LRS52 - refer to product's spec When a bit is ('1'), the error exists. When NO ERROR is encountered, this object's value will be 0.")
sysSRelayState = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRelayState.setStatus('current')
if mibBuilder.loadTexts: sysSRelayState.setDescription('Indicates the current state of the alarm relay. notApplicable - for agents that do not support this object.')
sysSInvertedAlr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSInvertedAlr.setStatus('current')
if mibBuilder.loadTexts: sysSInvertedAlr.setDescription('Indicates if there is any Inverted alarm at any level of the system (sys, card, port). notApplicable - for agents that do not support this object.')
sysSRdnFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18), )
if mibBuilder.loadTexts: sysSRdnFlipTable.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipTable.setDescription('This table includes all the Flip events due to I/O Redundancy since last Clear command of this table.')
sysSRdnFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1), ).setIndexNames((0, "RAD-MIB", "sysSRdnFlipIdx"))
if mibBuilder.loadTexts: sysSRdnFlipEntry.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipEntry.setDescription('An entry in table.')
sysSRdnFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipIdx.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipIdx.setDescription('Unique index number to identify an entry in the Redundancy Flip list.')
sysSRdnFlipSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipSlot.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipSlot.setDescription('The slot number from which Flip was performed.')
sysSRdnFlipPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipPort.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipPort.setDescription('The port number from which Flip was performed. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 100=notApplicable (when Redundancy is at card level).')
sysSRdnFlipCause = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipCause.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipCause.setDescription('The last cause that caused the Flip from the Slot (Port) of sysSRdnSlot, sysSRdnPort.')
sysSRdnFlipDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipDate.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipDate.setDescription('Flip event Date. The format will be the one selected by user for sysSDateFormat.')
sysSRdnFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipTime.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipTime.setDescription('Flip event Time. The format will be hh:mm:ss.')
sysSRdnFlipTableClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnFlipTableClearCmd.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipTableClearCmd.setDescription("This command, when Set to 'on', clears the Redundancy Flip table (sysSRdnFlipTable). After clear is performed, the agent will turn the value to 'off' automatically.")
sysSRdnFlipCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 20), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnFlipCmd.setStatus('current')
if mibBuilder.loadTexts: sysSRdnFlipCmd.setDescription('This object enables the user to send a command to the Agent, to Flip from a current Online IO card to its Redundant card. The value sent will be an Object Identifier of an entry in the sysCRdnTable. This entry defines the Redundant couple of Slots on which the Flip is applied. Setting this object, will cause the Agent to Flip from current Online card to its Redundant card. This manual flip command is applicable only for entries having Redundancy Mode=Y Cable. For Vmux: This command will cause flipping from Secondary or Third Link to the Primary Link. If the active link is the primary link, the agent will flip to the secondary link. The value sent will be the Object Identifier of the following Table: agnCBuMlTable. Agent will send the value 0 for Get.')
sysSBusTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21), )
if mibBuilder.loadTexts: sysSBusTable.setStatus('current')
if mibBuilder.loadTexts: sysSBusTable.setDescription('This table includes data and status about the internal DXC BUS.')
sysSBusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21, 1), ).setIndexNames((0, "RAD-MIB", "sysSBusPortIdx"))
if mibBuilder.loadTexts: sysSBusEntry.setStatus('current')
if mibBuilder.loadTexts: sysSBusEntry.setDescription('An entry in table.')
sysSBusPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSBusPortIdx.setStatus('current')
if mibBuilder.loadTexts: sysSBusPortIdx.setDescription('The DXC BUS port number: - first two digits will be: (IO slot number+10) - last one/two digits will be the Bus port number, in odd numbers: port1 = 1 port2 = 3 Example: port2 of IO slot 11 will be: 213.')
sysSBusStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("free", 1), ("physical", 2), ("virtual", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSBusStatus.setStatus('current')
if mibBuilder.loadTexts: sysSBusStatus.setDescription('The Status of sysSBusPortIdx. free - not used physical - captured by the port of the card physically installed virtual - captured virtually by another port. Example: DIM port (by Destination) or by Transparent T3/E3 port.')
sysSBusCapturePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSBusCapturePort.setStatus('current')
if mibBuilder.loadTexts: sysSBusCapturePort.setDescription("The Port that Captured the sysSBusPortIdx. - if sysSBusStatus=free, the value will be 'none'=0 - else, if sysSBusStatus=fixed, the value will be: sysSBusPortIdx - else, the value will be according to the port index that captured this Bus Port (according to DXC port index convention): - xx1, xx3, xx11, xx13, xx31, xx33, xx2..xx56(even numbers) - xx = (IO slot number+10) ")
sysSBusUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 21, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSBusUtilization.setStatus('current')
if mibBuilder.loadTexts: sysSBusUtilization.setDescription('Utilization of sysSBusPortIdx resources, in percent [%].')
sysSAlrAttrIndication = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrAttrIndication.setStatus('current')
if mibBuilder.loadTexts: sysSAlrAttrIndication.setDescription("This object indicates the status of the Alarm Attributes for the whole device. It is a sum of 2**(Bit-1). A Bit will be '1', when any alarm in the device is Filtered/Masked/Inverted (respectively). The Bit assignment is: Bit 1: Filter (LSB) Bit 2: Mask Bit 3: Invert (MSB). Examples: - Alarms are filtered and masked but not inverted: value=3 - Alarm is Inverted (not filtered or masked): value=4 - Alarm is masked (not inverted or filtered): value=2 ")
sysSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1), )
if mibBuilder.loadTexts: sysSAlrTable.setStatus('current')
if mibBuilder.loadTexts: sysSAlrTable.setDescription('List of system level current existing alarms .')
sysSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "sysSAlrIdx"))
if mibBuilder.loadTexts: sysSAlrEntry.setStatus('current')
if mibBuilder.loadTexts: sysSAlrEntry.setDescription('An entry in table.')
sysSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrIdx.setStatus('current')
if mibBuilder.loadTexts: sysSAlrIdx.setDescription('An index number of the current system alarms.')
sysSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrCode.setStatus('current')
if mibBuilder.loadTexts: sysSAlrCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
sysSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrState.setStatus('current')
if mibBuilder.loadTexts: sysSAlrState.setDescription('This object indicates the alarm Severity.')
sysSAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmMask.setStatus('current')
if mibBuilder.loadTexts: sysSAlarmMask.setDescription('Alarm Mask is : on/off.')
sysSAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmInvert.setStatus('current')
if mibBuilder.loadTexts: sysSAlarmInvert.setDescription('Alarm Invert is : on/off.')
sysSAlarmOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmOnOff.setStatus('current')
if mibBuilder.loadTexts: sysSAlarmOnOff.setDescription('Alarm state is : on/off.')
sysSAlarmCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmCounter.setStatus('current')
if mibBuilder.loadTexts: sysSAlarmCounter.setDescription('A counter - how many times the alarm occured (ON) since last clear operation or since last Reset.')
sysSAlrClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrClearCmd.setStatus('current')
if mibBuilder.loadTexts: sysSAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the system level alarms . Upon completion, the value will automatically change to off(2).')
sysSAlrClearAllCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrClearAllCmd.setStatus('current')
if mibBuilder.loadTexts: sysSAlrClearAllCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on all levels alarms . Upon completion, the value will automatically change to off(2).')
sysSAlrMaskAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrMaskAll.setStatus('current')
if mibBuilder.loadTexts: sysSAlrMaskAll.setDescription('on(3) - will cause masking of all the system level alarms. These alarms will not be sent to NMS and will not be taken into account for Alarms Status. off(2) - will unmask all system level alarms except those masked via the sysSAlrMask. ')
sysSAlrMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrMask.setStatus('current')
if mibBuilder.loadTexts: sysSAlrMask.setDescription("This object is a mask that indicates which system level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the system level will be 0. This object is applicable only when sysSAlrMaskAll=off (otherwise all system alarms are masked). Example: When Alarms having the codes 6 and 11 are masked, the value of this object will be 840 (hex).")
sysSAlrDataUpdateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrDataUpdateCmd.setStatus('current')
if mibBuilder.loadTexts: sysSAlrDataUpdateCmd.setDescription('on(3) - will cause Update of the Alarms Severity, Attributes and Report tables. off(2) - Upon completion, the value will automatically change to off(2).')
sysBufferAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1), )
if mibBuilder.loadTexts: sysBufferAlrTable.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrTable.setDescription('List of current existing alarms (of all levels).')
sysBufferAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "sysBufferAlrIdx"))
if mibBuilder.loadTexts: sysBufferAlrEntry.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrEntry.setDescription('An entry in table.')
sysBufferAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrIdx.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrIdx.setDescription('An index number of the current alarms.')
sysBufferAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrCode.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrCode.setDescription("This object indicates a code related to a specific alarm description. The list of codes and thir related descriptions will be known by the NMS (for display purpose) and will appear in the unit's user manual.")
sysBufferAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrState.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrState.setDescription('This object indicates the alarm type. minor/major/warning/critical - indicates appearance of the problem and the type. event - indicates occurence of an event. off - indicates disappearance of an alarm. ')
sysBufferAlrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 120, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("local", 20), ("psC", 21), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("remote", 120), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrSlot.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrSlot.setDescription("The slot number this alarm refers to. When the alarm refers to a system function OR the DACS agent is a stand-alone unit, the value will be 'notApplicable(255)'. local/remote - for OP-4 device.")
sysBufferAlrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrPort.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrPort.setDescription('The port number this alarm refers to. If the port number is irrelevant to this alarm (if it is a system/card level alarm) the value will be 9999.')
sysBufferAlrDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrDate.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrDate.setDescription('The date when the alarm occured. The format will be according to sysSDateFormat.')
sysBufferAlrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrTime.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrTime.setDescription('The time when the alarm occured.')
sysBufferAlrUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrUpTime.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrUpTime.setDescription('The time when the alarm occured. This parameter holds the sysUpTime value when the alarm occured.')
sysBufferAlrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrInfo.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrInfo.setDescription('This parameter includes information about the alarm (additional to the Description).')
sysBufferAlrClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBufferAlrClearCmd.setStatus('current')
if mibBuilder.loadTexts: sysBufferAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the Alarms Buffer. Upon completion, the value will automatically change to off(2).')
sysCClkSrcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1), )
if mibBuilder.loadTexts: sysCClkSrcTable.setStatus('current')
if mibBuilder.loadTexts: sysCClkSrcTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. For devices with more than one configuration: The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysCClkSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1), ).setIndexNames((0, "RAD-MIB", "sysCClkCnfgIdx"), (0, "RAD-MIB", "sysCClkSrcIdx"))
if mibBuilder.loadTexts: sysCClkSrcEntry.setStatus('current')
if mibBuilder.loadTexts: sysCClkSrcEntry.setDescription('An entry in table.')
sysCClkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCClkCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: sysCClkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg being accessed ; Idx of 255 relates to the TmpCnfg. It can be also a combination of the configuration number and the Card/Port/Other System index.')
sysCClkSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCClkSrcIdx.setStatus('current')
if mibBuilder.loadTexts: sysCClkSrcIdx.setDescription('An index in the table. There are only two entries in the table. master - refers Master clock parameters fallback - refers Fallback clock parameters')
sysCClkSrcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 255))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("rxClk", 3), ("station", 4), ("lbt", 5), ("ntr", 6), ("adaptive", 7), ("stationB", 8), ("automatic", 9), ("system", 10), ("sSubSystem", 11), ("recovered", 12), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSrcMode.setStatus('current')
if mibBuilder.loadTexts: sysCClkSrcMode.setDescription('This entry indicates the source the nodal timing is locked to. none - is an invalid option for Master clock. internal - is an invalid option for Fallback clock . station - is an invalid option for a stand-alone unit. lbt - loop-back timing ntr - Network Time Reference adaptive - clock locking is achieved by altering the clock according to the data load system - irrelevant when sysCClkCnfgIdx refers to System Clock. sSubSystem - SONET/SDH Sub System. recovered - clock recovery. notApplicable - for ML source of Kmux or ML Timing combinations when Master/Fallback clock are not applicable.')
sysCClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSrcPrt.setStatus('current')
if mibBuilder.loadTexts: sysCClkSrcPrt.setDescription('This entry is valid only when working in rxClk mode (for IPmux1000 this entry will be valid whe working in LBT mode). For ACE2002 in case of invalid entry the return value will be 0. For other products in case of invalid entry the return value will be 9999. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The SP ports will be numbered as follows: - SP port 1 : 1 - SP port 2 : 2 For external ports the convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For Kmux, the port will be according to : Slot*100+Ch. For ACE2002, LA140 and IPmux1000 (GMUX), the port will be ifIndex.')
sysCClkStationFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("f1544Khz", 2), ("f2048Khz", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkStationFreq.setStatus('current')
if mibBuilder.loadTexts: sysCClkStationFreq.setDescription("This entry indicates the frequency of the station clock when the source is 'station'. The value will be applicable only when the sysCClkSrcMode is 'station'. ")
sysCClkRevertiveTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkRevertiveTimeout.setStatus('current')
if mibBuilder.loadTexts: sysCClkRevertiveTimeout.setDescription('The time in seconds in which the system will monitor the higher level clock source, before decision to revert to that clock. In case the time is zero, revertive mode will be disabled.')
sysCClkStationIf = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("g703", 2), ("rs422", 3), ("g703E1Unbalanced", 4), ("g703T1", 5), ("rs422T1", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkStationIf.setStatus('current')
if mibBuilder.loadTexts: sysCClkStationIf.setDescription("This entry indicates the electrical interface connected to the station clock, when the source is 'station'. The value will be applicable only when the sysCClkSrcMode is 'station'. ")
sysCClkStationCableMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("yCable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkStationCableMode.setStatus('current')
if mibBuilder.loadTexts: sysCClkStationCableMode.setDescription("This parameter indicates whether both Station clocks get their clock from the same source (Y Cable)or each one get its clock independently. The value will be applicable only when the sysCClkSrcMode is 'station'. ")
sysCClkStationOutState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkStationOutState.setStatus('current')
if mibBuilder.loadTexts: sysCClkStationOutState.setDescription("This parameter indicates whether station clock can send its clock to another device. The value will be applicable only when the sysCClkSrcMode is 'station'. ")
sysCClkSsmBased = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSsmBased.setStatus('current')
if mibBuilder.loadTexts: sysCClkSsmBased.setDescription('This parameter indicates whether clock source will be selected based on receive clock quality, indicated in S1 byte inside SONET/SDH overhead, (encoded as SSM - Synchronization Status Messaging). It is relevant only for sysCClkSrcIdx=master. When the value is Yes, sysCClkSrcMode must be notApplicable.')
sysCClkSSubsystemSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("clA", 3), ("clB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSSubsystemSlot.setStatus('current')
if mibBuilder.loadTexts: sysCClkSSubsystemSlot.setDescription("This entry indicates the Slot from which the S Subsytem Source will be taken. The value will be applicable only when the sysCClkSrcMode is 'sSubsystem'. ")
sysCClkRecoveredID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkRecoveredID.setStatus('current')
if mibBuilder.loadTexts: sysCClkRecoveredID.setDescription("This entry indicates the Recovered Clock ID. The value will be applicable only when sysCClkSrcMode is 'recovered'.")
sysCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2), )
if mibBuilder.loadTexts: sysCnfgTable.setStatus('current')
if mibBuilder.loadTexts: sysCnfgTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1), ).setIndexNames((0, "RAD-MIB", "sysCnfgIdx"))
if mibBuilder.loadTexts: sysCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: sysCnfgEntry.setDescription('An entry in table.')
sysCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: sysCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg. For Gmux2000 the range limitation (1..255) was discarded since the Idx is computed as: <IO Card No.> x 1000 + 255.')
sysCMatrixMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("bidirectional", 2), ("unidirectional", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCMatrixMode.setStatus('current')
if mibBuilder.loadTexts: sysCMatrixMode.setDescription('Indicates the TS Matrix Mode: bidirectional - TS Assignment Matrix is symmetric. unidirectional - TS Assignment Matrix can be asymmetric. notApplicable - for agents that do not support this feature.')
sysCIsdnFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("te", 2), ("nt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCIsdnFormat.setStatus('current')
if mibBuilder.loadTexts: sysCIsdnFormat.setDescription('ISDN format. This parameter controls the operation mode of the ISDN ports. te - ISDN timing is derived from the signal received from the equipment it is connected to. nt - timing of the transmit path is locked to the nodal timing source. notApplicable - for agents that do not support this feature.')
sysCRoutingOnEth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4), ("rip1", 5), ("rip1and2", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRoutingOnEth.setStatus('current')
if mibBuilder.loadTexts: sysCRoutingOnEth.setDescription('Mng Routing Protocol on the online CL Ethernet port, or on device Ethernet port dedicated for mangement.')
sysCAutoConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCAutoConfigEnable.setStatus('current')
if mibBuilder.loadTexts: sysCAutoConfigEnable.setDescription('This object enables user to enable/disable activating the Auto Configuration. When Auto Configuration is activated, the device learns its configuration Automatically from the Net it is connected to.')
sysCIntTsAllocMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("static", 2), ("dynamic", 3), ("staticOneToOne", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCIntTsAllocMode.setStatus('current')
if mibBuilder.loadTexts: sysCIntTsAllocMode.setDescription('This object enables user to select the mode of Internal TS Allocation. static - user has to select for each Dynamic card port, the Maximum TSs expected to be connected (including future growth). This number will be allocated to the ports, so that if number of connected TSs will grow within the limits of this Maximum TS limit, no disruption of data flow will occur for other ports. dynamic- TS allocation is done dynamically according to the connected TSs. No future reservations are done. This mode may cause data disruption on other ports/slots if user will want to change the number of connected TSs for a Dynamic card port. staticOneToOne - user has to select for each Dynamic card port, the Maximum TSs expected to be connected (including future growth). In addition, the TSs themselves cannot be higher than this defined Maximum (e.g if Maximum TSs=5 user cannot selects TSs higher than 5). This mode ensures that if number of TSs grow within the limits of this Maximum TS limit, no disruption of data flow will occur for other ports AND for the selected port itself. Default=static(2). ')
sysCBuPrimaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("noBackup", 2), ("e1T1orSerial", 3), ("eth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCBuPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: sysCBuPrimaryPort.setDescription('This object enables the user to configure a Backup mechanism. If a backup mechanism exists, it is possible to configure the primary port. The traffic will flow via the primary port when the port functionality is OK. In Vmux-2100 device the backup mechanism is relevant for the Main Board only. The primary port can be the E1/T1/Serial port or the ETH port. ')
sysCEnableLanOverTdm = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("enableAll", 2), ("enableVoiceOnly", 3), ("enableVoiceAndMng", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCEnableLanOverTdm.setStatus('current')
if mibBuilder.loadTexts: sysCEnableLanOverTdm.setDescription('This object enables/disables transferring traffic from the LAN port to the TDM port. It is possible to enable only part of the traffic on the TDM port for security reasons or in order to minimize the bandwidth .')
sysCSs7FisuSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCSs7FisuSuppression.setStatus('current')
if mibBuilder.loadTexts: sysCSs7FisuSuppression.setDescription('SS7 Suppresion is used for SS7 Spoofing. The SS7 spoofing terminates the keep alive messages from the local VMUX without sending them over the network, thus improving the bandwidth utilization. FISU means Fill in Service Unit - Keep alive that is sent when no one is talking on the line. This object enables the configuration of the SS7 Keep Alive packet % that will be discarded. Legal Values: 0 - No Suppression, 10%, 20%, 30% .. 90% Example: For a value of 10, 1 keep alive packet will be discarded out of 10 keep alive packets that were supposed to be sent over the network.')
sysCBuRecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("auto", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCBuRecMode.setStatus('current')
if mibBuilder.loadTexts: sysCBuRecMode.setDescription('Recovery Mode. This object determines if after recovery of the Primary Link (used in Vmux) it will become on-line again or not: auto - automatic. In this case, the failed Link will become on-line again after recovery, automatically. manual - In this case, the failed Link will not become on-line again after recovery but user can manually flip to this Link.')
sysCRdnTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3), )
if mibBuilder.loadTexts: sysCRdnTable.setStatus('current')
if mibBuilder.loadTexts: sysCRdnTable.setDescription('Configuration of all Redundant I/O cards and ports. The write operation into the table objects is valid only for the TmpCnfg. A Slot/Port that have no Redundancy, will not exist in this table.')
sysCRdnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1), ).setIndexNames((0, "RAD-MIB", "sysCRdnCnfgIdx"), (0, "RAD-MIB", "sysCRdnPrimeSlot"), (0, "RAD-MIB", "sysCRdnPrimePort"))
if mibBuilder.loadTexts: sysCRdnEntry.setStatus('current')
if mibBuilder.loadTexts: sysCRdnEntry.setDescription('An entry in table.')
sysCRdnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: sysCRdnCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
sysCRdnPrimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnPrimeSlot.setStatus('current')
if mibBuilder.loadTexts: sysCRdnPrimeSlot.setDescription('The slot number of the Primary card of Redundancy. The Primary card should be the card that user wishes to be the online card (usually the more important one). For some Redundancy modes the importance of the redundant cards/ports is the same. ')
sysCRdnPrimePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnPrimePort.setStatus('current')
if mibBuilder.loadTexts: sysCRdnPrimePort.setDescription('The port number. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 For IP Bundles, the value will be the Bundle ifIndex. For an IP Bundle that is in an External Device (not in this MP), the value will be: 70,000 + ifIndex of Secondary Bundle. For other products - refer to product specification. 100=notApplicable (when Redundancy is at card level).')
sysCRdnSecSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnSecSlot.setStatus('current')
if mibBuilder.loadTexts: sysCRdnSecSlot.setDescription('The slot number of the Secondary card of Redundancy matching the Primary slot.')
sysCRdnSecPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnSecPort.setStatus('current')
if mibBuilder.loadTexts: sysCRdnSecPort.setDescription('The port number. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 For IP Bundles, the value will be the Bundle ifIndex. For an IP Bundle that is in an External Device (not in this MP), the value will be: 0. For other products - refer to product specification. 100=notApplicable (when Redundancy is at card level).')
sysCRdnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("dualCableAIS", 2), ("yCable", 3), ("dualCableParallelTx", 4), ("backup", 5), ("singleSlotProtection", 6), ("onePlusOne", 7), ("oneToOne", 8), ("linkAggregation", 9), ("manual", 10)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnMode.setStatus('current')
if mibBuilder.loadTexts: sysCRdnMode.setDescription('Redundancy Mode. DXC supports: yCable(3), singleSlotProtection(6) and dualCableParallelTx(4) MP supports: yCable(3), dualCableParallelTx(4), onePlusOne(7) and oneToOne(8). (dualCableAIS and backup were planned for MP but were not implemented). backup - will be used when a port is backup of more than one port. IPmux: onePlusOne(7) and oneToOne(8) are used for Bundle redundancy.')
sysCRdnRecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("auto", 2), ("manual", 3), ("nonRevertive", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnRecMode.setStatus('current')
if mibBuilder.loadTexts: sysCRdnRecMode.setDescription('Recovery Mode. This object determines if after recovery of the failed Primary card/port it will become on-line again or not: auto - automatic . In this case, the failed card/port will become on-line again after recovery, automatically. manual - In this case, the failed card/port will not become on-line again after recovery. But, user can manually flip to this card/port. nonRevertive - same as manual, but here user CANNOT manually flip to this card/port. It will become on-line again, only if the Secondary/Backup card/port will fail.')
sysCRdnRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnRecTime.setStatus('current')
if mibBuilder.loadTexts: sysCRdnRecTime.setDescription('Redundancy Recovery Time (sec). After switching to the current online card, the next switch can be performed only after a minimum time, indicated by this object. Valid Values: 0..300, 65535. 65535=NA. This object is applicable only when sysCRdnRecMode=auto.')
sysCRdnHwSwFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("hw", 2), ("sw", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnHwSwFlip.setStatus('current')
if mibBuilder.loadTexts: sysCRdnHwSwFlip.setDescription('HW or SW decision for Redundancy Flip. This object is applicable only for sysCRdnMode=singleSlotProtection. HW - decision is by I/O card SW - decision is by CL SW.')
sysCRdnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysCRdnRowStatus.setDescription('This parameter allows NMS to create/delete entries of this table. The possible supported RowStatus values are active (1) and destroy (6). For Vmux-2100 the supported values are: active (1), createAndGo (4) and destroy (6).')
sysCRdnOnline = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnOnline.setStatus('current')
if mibBuilder.loadTexts: sysCRdnOnline.setDescription('Status - who is the Online (current) Redundancy Slot/Port. This object shows only the Online Slot/Port regarding the Redundancy. mdlSActivity or prtGenActiveStatus of the same Slot/Port may be Offline.')
sysCRdnSwitchingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("biDirectional", 2), ("uniDirectional", 3), ("linkAggregation", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnSwitchingMode.setStatus('current')
if mibBuilder.loadTexts: sysCRdnSwitchingMode.setDescription('This object defines which Self Healing Ring (SHR) SDH ring is used: Uni Directional or BiDirectional. The type of the ring is defined according to the direction of traffic flow under normal working conditions. In Bi Directional ring, the duplex traffic is on the same path and transverses the same set of nodes for both directions of transmission. In Uni Directional ring, the duplex traffic travels over opposite path (per direction) and all the node of the ring are involved. For Uni Directional SHR Protection Switching (Single Ended Switching) is controlled by one node of the SDH ring, and does not require a protocol. For Bi Directional SHR Protection Switching (Dual Ended switching) is controlled by some nodes of the ring and requires a protocol')
sysCRdnFlipUponEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnFlipUponEvent.setStatus('current')
if mibBuilder.loadTexts: sysCRdnFlipUponEvent.setDescription("This object allows user to define if Flip to the other port will be performed (or not), for certain possible events. Each event is represented by a bit. The value of the object is a sum of 2**n, according to the bits having '1' value. '1' - means that Flip should occur due to this event. Bit 0 (LSB) = SD (Signal Degraded). For IPmux: Bit 0 (LSB) = TDM Line LOS/LOF. Bit 1 = Sequence Number. Bit 2 = Jitter Buffer errors.")
sysCRdnLosOrLofTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnLosOrLofTime.setStatus('current')
if mibBuilder.loadTexts: sysCRdnLosOrLofTime.setDescription('This parameter determines how much time to wait before switching, after LOF or LOS are detected on the TDM Line. For Ipmux time is counted in msec.')
sysCRdnEventsTimeWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnEventsTimeWindow.setStatus('current')
if mibBuilder.loadTexts: sysCRdnEventsTimeWindow.setDescription('This parameter determines the time window in which to count events to trigger protection switching. For Ipmux time is counted in seconds.')
sysCRdnSequenceNumberThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnSequenceNumberThreshold.setStatus('current')
if mibBuilder.loadTexts: sysCRdnSequenceNumberThreshold.setDescription('This parameter determines the number of Sequence Number errors that should occur in the time window in order to cause switching.')
sysCRdnBufferErrorsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnBufferErrorsThreshold.setStatus('current')
if mibBuilder.loadTexts: sysCRdnBufferErrorsThreshold.setDescription('This parameter determines the number of Buffer undeflow/ overflow events occured in the time window that cause switching.')
sysCRdnBuffUnderrunTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnBuffUnderrunTime.setStatus('current')
if mibBuilder.loadTexts: sysCRdnBuffUnderrunTime.setDescription('This parameter determines how much time to wait before switching, after jitter buffer underrun. Switching occurs if no frame arrives within that time. For Ipmux time is counted in msec.')
sysCRdnPrimePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnPrimePriority.setStatus('current')
if mibBuilder.loadTexts: sysCRdnPrimePriority.setDescription('The Primary port priority. In ETX2xx/2xxA: When selecting sysCRdnMode = manual (10), this parameter determines the forced active port: low - means that the secondary port is selected to be active high - means that the primary port is selected to be active. ')
sysCRdnSecPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnSecPriority.setStatus('current')
if mibBuilder.loadTexts: sysCRdnSecPriority.setDescription('The Secondary port priority.')
sysCRdnWTR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 21), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnWTR.setStatus('current')
if mibBuilder.loadTexts: sysCRdnWTR.setDescription('Redundancy Wait to Restore (sec). Valid Values: 0..999, 65535. 65535=NA. When the value <> 65535, the value of sysCRdnRecTime must be 65535.')
sysCRdnName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 22), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnName.setStatus('current')
if mibBuilder.loadTexts: sysCRdnName.setDescription('A textual name for the redundancy group.')
sysCRdnTxDownDurationUponFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysCRdnTxDownDurationUponFlip.setStatus('current')
if mibBuilder.loadTexts: sysCRdnTxDownDurationUponFlip.setDescription('This object defines the duration (in seconds) the active port transmission is shut down after flip occurs. The transmission is shut down and then opened again (after the duration defined by this object), in order to cause the other side to flip to the new active port. 0 = no shut-down. This object is applicable only when sysCRdnMode = oneToOne(8) and mainly when each of the links of our device is connected to a different device.')
sysSRdnCmdTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 22), )
if mibBuilder.loadTexts: sysSRdnCmdTable.setStatus('current')
if mibBuilder.loadTexts: sysSRdnCmdTable.setDescription('This table includes commands used for IO Redundancy.')
sysSRdnCmdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 22, 1), ).setIndexNames((0, "RAD-MIB", "sysCRdnPrimeSlot"), (0, "RAD-MIB", "sysCRdnPrimePort"))
if mibBuilder.loadTexts: sysSRdnCmdEntry.setStatus('current')
if mibBuilder.loadTexts: sysSRdnCmdEntry.setDescription('An entry in table.')
sysSRdnEnforcedChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 22, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("noEnforcement", 2), ("primary", 3), ("secondary", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnEnforcedChannel.setStatus('current')
if mibBuilder.loadTexts: sysSRdnEnforcedChannel.setDescription('This is a command to override all switching considerations and enforce use of primary/ secondary connection only. noEnforcement - cancels the state of override and goes back to usual switching considerations. Default = noEnforcement(2).')
sysSRdnLockFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnLockFlip.setStatus('current')
if mibBuilder.loadTexts: sysSRdnLockFlip.setDescription('This is a command to lock the Redundancy flip for this redundancy couple. Default = off(2).')
sysSRdnManualFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 22, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnManualFlip.setStatus('current')
if mibBuilder.loadTexts: sysSRdnManualFlip.setDescription('This is a command to move to manual Redundancy flip mode for this redundancy couple. Default = off(2).')
sysDbaseSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseSanityCheckCmd.setStatus('current')
if mibBuilder.loadTexts: sysDbaseSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the TmpCnfg. Upon completion, the value will automatically change to off(2).')
sysDbaseDownloadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseDownloadCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: sysDbaseDownloadCnfgIdxCmd.setDescription('This attribute specifies the Id of the target RealCnfg to which the TmpCnfg should be transferred. Upon set command, the DACS agent will initiate the Sanity-Check process. If successful, the actual transfer will be performed. If there will be errors, the user will have to perform the command again after errors correction. The operation is valid only on configuration numbers that do not exceed sysSMaxNoOfCnfg.')
sysDbaseUploadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseUploadCnfgIdxCmd.setStatus('current')
if mibBuilder.loadTexts: sysDbaseUploadCnfgIdxCmd.setDescription('This attribute specifies the Id of the source Cnfg to be loaded into the TmpCnfg. Upon set operation the actual transfer will be initiated. The operation is valid only on configuration numbers that do not exceed sysSMaxNoOfCnfg.')
sysDbaseFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4), )
if mibBuilder.loadTexts: sysDbaseFlipTable.setStatus('current')
if mibBuilder.loadTexts: sysDbaseFlipTable.setDescription('Dbase Flip time and activation for every configuration.')
sysDbaseFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1), ).setIndexNames((0, "RAD-MIB", "sysDbaseFlipIdx"))
if mibBuilder.loadTexts: sysDbaseFlipEntry.setStatus('current')
if mibBuilder.loadTexts: sysDbaseFlipEntry.setDescription('An entry in table.')
sysDbaseFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDbaseFlipIdx.setStatus('current')
if mibBuilder.loadTexts: sysDbaseFlipIdx.setDescription('This attribute indicates the Idx of the Cnfg being the target Configuration.')
sysDbaseFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseFlipTime.setStatus('current')
if mibBuilder.loadTexts: sysDbaseFlipTime.setDescription('This attribute indicates the time (HH:MM) when this data base will start being used by the Tmp config.')
sysDbaseFlipActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseFlipActivation.setStatus('current')
if mibBuilder.loadTexts: sysDbaseFlipActivation.setDescription('This attribute indicates if the Dbase flip will be activated at the time specified for this configuration (enable) or not (disable). No more than one flip should be enabled for the same time.')
mdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1))
mdlCl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2))
mdlPs = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3))
mdlSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1), )
if mibBuilder.loadTexts: mdlSTable.setStatus('current')
if mibBuilder.loadTexts: mdlSTable.setDescription('A table.')
mdlSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlSSltIdx"))
if mibBuilder.loadTexts: mdlSEntry.setStatus('current')
if mibBuilder.loadTexts: mdlSEntry.setDescription('An entry in table.')
mdlSSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("psC", 20), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlSSltIdx.setDescription('A unique number to identify a slot position in the DACS. The Kilomux should use enumerated values starting with kmx. For IPmux100 use values 1-13, 20.')
mdlSCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 70, 71, 72, 80, 81, 82, 83, 90, 91, 92, 100, 101, 102, 103, 104, 110, 111, 112, 113, 114, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 280, 281, 282, 283, 284, 290, 300, 301, 302, 303, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("psAC", 10), ("psDC", 11), ("gCl1", 18), ("gCl2", 19), ("dCl", 20), ("kCl", 21), ("dcl2", 22), ("dcl2Eth", 23), ("kClEth", 24), ("dcl3", 25), ("dcl3Eth", 26), ("d4T1", 28), ("d8T1", 29), ("dT1DSU", 30), ("dT1CSU", 31), ("dE1DSU", 32), ("dE1LTU", 33), ("dE1aDSU", 34), ("dE1aLTU", 35), ("dT1F", 36), ("dE1F", 37), ("d4E1", 38), ("d8E1", 39), ("dE1Hdsl", 40), ("dT1Hdsl", 41), ("dE1HdslS", 42), ("dT1HdslS", 43), ("d16gsdsl", 44), ("d8sl", 45), ("d4slStuC", 46), ("d4slStuR", 47), ("kML1", 50), ("kML2", 51), ("kML3", 52), ("kML4", 53), ("kML5", 54), ("kML6", 55), ("kML7", 56), ("kML8", 57), ("kML10", 59), ("kMLF", 60), ("kML10New", 61), ("kML11RJ45", 62), ("kML11FO", 63), ("kLS1", 70), ("kLS1New", 71), ("kLS2", 72), ("kTRE", 80), ("kMBE", 81), ("kMBENew", 82), ("fLAN", 83), ("kai", 90), ("kdi", 91), ("kdiCH", 92), ("dHS2", 100), ("d8U", 101), ("d16U", 102), ("d4HS", 103), ("d8HS", 104), ("kHS1", 110), ("kHS2", 111), ("kHSU1", 112), ("kHSU2", 113), ("kHS703", 114), ("kVC1EM", 130), ("kVC1FXO", 131), ("kVC1FXS", 132), ("kVC1MEM", 133), ("kVC1MFXO", 134), ("kVC1MFXS", 135), ("kVC1MFXSW", 136), ("kVC2EM", 137), ("kVC2FXO", 138), ("kVC2FXS", 139), ("kVC2s1EM", 140), ("kVC2s1FXO", 141), ("kVC2s1FXS", 142), ("kVC3EM", 143), ("kVC3FXO", 144), ("kVC3FXS", 145), ("kVC3S0", 146), ("kVF1EM", 170), ("kVF1FXO", 171), ("kVF1FXS", 172), ("kVF3EM", 173), ("kVF3FXO", 174), ("kVF3FXS", 175), ("kVF4EM", 176), ("kVF4FXO", 177), ("kVF4FXS", 178), ("kVF4FXSW", 179), ("kVF4S0", 180), ("kVF5PbxE1", 181), ("kVF5E1PbxSlave", 182), ("kVF5PbxT1", 183), ("kVF5T1PbxSlave", 184), ("kVF5PbxE1New", 185), ("kVF5E1PbxSlaveNew", 186), ("kVF5PbxT1New", 187), ("kVF5T1PbxSlaveNew", 188), ("kVF4FXO3", 189), ("kVF4FXS3", 190), ("kVF4NS0", 191), ("kVF6E1s16", 192), ("kVF6E1s31", 193), ("kVF6T1s12", 194), ("kVF6T1s24", 195), ("kVF8EM", 196), ("kVF8FXO", 197), ("kVF8FXS", 198), ("dimETUR", 200), ("dimV35", 201), ("dimRS422", 202), ("dimRS530", 203), ("dimHssi", 204), ("dimX21", 205), ("dim10BaseT", 206), ("dimE1", 207), ("dim100", 208), ("dt3G747", 209), ("dt3", 210), ("dt3f", 211), ("de3", 212), ("de3f", 213), ("dstm1s1", 214), ("dstm1s2", 215), ("fSTM1", 216), ("dstm1", 217), ("dstm1R", 218), ("f2stm1", 219), ("gstm1", 220), ("goc3", 221), ("gstm1D", 222), ("goc3D", 223), ("laSUB", 230), ("laVEM", 231), ("laVFXO", 232), ("laVFXS", 233), ("laV11", 234), ("laV24", 235), ("laV35", 236), ("laT1", 237), ("laT1Vxx", 238), ("laE1", 239), ("laE1Vxx", 240), ("laISDN", 241), ("laVxx", 242), ("laEth", 243), ("laISDNwBU", 244), ("laIsdnNT", 245), ("laIsdnNTwBU", 246), ("laIsdnTE", 247), ("laFXSwBU", 248), ("laFXSs", 249), ("laFXSwBUs", 250), ("laIsdnNTs", 251), ("laIsdnNTwBUs", 252), ("laIsdnTEs", 253), ("laDp", 254), ("laSdsl", 255), ("laSdslDp", 256), ("laAdslA", 257), ("laAdslADp", 258), ("laAdslB", 259), ("laAdslBDp", 260), ("laShdsl", 261), ("laShdslDp", 262), ("laT1b", 263), ("laT1bDp", 264), ("laIsdnTEwBU", 265), ("laIsdnTEwBUs", 266), ("laShdsl4w", 267), ("laShdsl4wDp", 268), ("laEthSwitch", 269), ("serverE1", 270), ("serverT1", 271), ("serverE1Pw", 272), ("serverT1Pw", 273), ("gigabitEth", 280), ("gigabitEth2", 281), ("eth2", 282), ("gigabitEth8", 283), ("eth8", 284), ("channelizedT3Pw1", 290), ("cesT128", 300), ("cesE128", 301), ("cesT1Pw28", 302), ("cesE1Pw28", 303), ("vmxE1VeDe", 310), ("vmxE1VeDi", 311), ("vmxE1ViDe", 312), ("vmxE1ViDi", 313), ("vmxT1VeDe", 314), ("vmxT1VeDi", 315), ("vmxT1ViDe", 316), ("vmxT1ViDi", 317), ("vc12E1UeNe", 318), ("vc12E1UeNi", 319), ("vc12E1UiNe", 320), ("vc12E1UiNi", 321), ("vc12T1UeNe", 322), ("vc12T1UeNi", 323), ("vc12T1UiNe", 324), ("vc12T1UiNi", 325), ("vca16E1UeNe", 326), ("vca16E1UeNi", 327), ("vca16E1UiNe", 328), ("vca16E1UiNi", 329), ("vca16T1UeNe", 330), ("vca16T1UeNi", 331), ("vca16T1UiNe", 332), ("vca16T1UiNi", 333), ("vca12E1UeNe", 334), ("vca12E1UeNi", 335), ("vca12E1UiNe", 336), ("vca12E1UiNi", 337), ("vca12T1UeNe", 338), ("vca12T1UeNi", 339), ("vca12T1UiNe", 340), ("vca12T1UiNi", 341), ("vmg16E1Ue", 342), ("vmg16E1Ui", 343), ("vmg16T1Ue", 344), ("vmg16T1Ui", 345), ("vmg12E1Ue", 346), ("vmg12E1Ui", 347), ("vmg12T1Ue", 348), ("vmg12T1Ui", 349)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSCardType.setStatus('current')
if mibBuilder.loadTexts: mdlSCardType.setDescription("This attribute indicates the type of the card installed in the specific slot position. Only PS's are possible in the PS slots. Only CL's are possible in the CL slots. Only IO modules are possible in the IO slots. Kmux card type start with the letter k. LA card type start with the letters la.")
mdlSHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwVer.setStatus('current')
if mibBuilder.loadTexts: mdlSHwVer.setDescription('This attribute indicates the Hardware version of the card installed in the specific slot position.')
mdlSSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSwVer.setStatus('current')
if mibBuilder.loadTexts: mdlSSwVer.setDescription('This attribute indicates the Software version of the card installed in the specific slot position.')
mdlSAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4), ("event", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: mdlSAlarmStatus.setDescription('Indicates the current alarm state only for card level. This object will be set to: - critical(7): when there is at least one active (ON) critical alarm . - major (3): when there is no active critical alarm, but there is at least one active (ON) major alarm . - minor (4): when there is no active major or critical alarm, but there is at least one active minor alarm. - warning (6): when there is no active major, critical or minor alarm, but there is at least one active warning alarm. - event (5): when there is no active alarm of another type, but there is at least one active event alarm. - off(2): when there is no active (ON) alarm (since last clear operation).')
mdlSAlarmStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4), ("event", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlarmStatusAll.setStatus('current')
if mibBuilder.loadTexts: mdlSAlarmStatusAll.setDescription('Indicates the current card alarm state including the lower level: card, port. This object will be set to: - critical(7): when there is at least one active (ON) critical alarm . - major (3): when there is no active critical alarm, but there is at least one active (ON) major alarm . - minor (4): when there is no active major or critical alarm, but there is at least one active minor alarm. - warning (6): when there is no active major, critical or minor alarm, but there is at least one active warning alarm. - event (5): when there is no active alarm of another type, but there is at least one active event alarm. - off(2): when there is no active (ON) alarm (since last clear operation).')
mdlSTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSTestStatus.setStatus('current')
if mibBuilder.loadTexts: mdlSTestStatus.setDescription('This attribute will be on(3) when there is at least one test running on a port of the module; otherwise the value will be off(2).')
mdlSHwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("fail", 2), ("ok", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwStatus.setStatus('current')
if mibBuilder.loadTexts: mdlSHwStatus.setDescription('This attribute will be fail(2) when a HW FAIL exists on this module (discovered by periodic self test); otherwise the value will be ok(3).')
mdlSActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("offline", 2), ("online", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSActivity.setStatus('current')
if mibBuilder.loadTexts: mdlSActivity.setDescription('notApplicable - when the slot is empty (no module) offline(1) - when the module is not active (redundant) online (2) - when the module is active .')
mdlSAlrClearCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrClearCmd.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the card level alarms . Upon completion, the value will automatically change to off(2).')
mdlSAlrClearAllCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrClearAllCmd.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrClearAllCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on card and port level alarms . Upon completion, the value will automatically change to off(2).')
mdlSAlrMaskAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrMaskAll.setStatus('current')
if mibBuilder.loadTexts: mdlSAlrMaskAll.setDescription('on(3) - will cause masking of all the card level alarms. These alarms will not be sent to NMS and will not be taken into account for Alarms Status. off(2) - will unmask all card level alarms except those masked via the mdlAlrMaskTable. ')
mdlSCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSCmd.setStatus('current')
if mibBuilder.loadTexts: mdlSCmd.setDescription("General object for any special command at card level. 0=NotApplicable, for cards that don't support this object. For KML.10(ISDN) card of KM-2100, the object will indicate Manual Call Command in Switch mode. It is applicable only when for KML.10, prtIsdnSwitchMode=manual. KML.10 valid values: '1' = noOp, will be used by agents that do not support this feature or object (old KM agents) '2' = off, Set call command mode to disconnect state. Disconnects the call. '3' = on, Set call command mode to connect state. Connects the call. For DXC IO cards, the object will be used for IO Card Reset HW command: '2' = off, this will be always the Get value for these cards. '3' = on, this is the Set command used to Reset the IO card. Upon completing the operation, the value will automatically change to off(2), by Agent. For Slots that are NOT IO Slots and for empty IO Slots, the Get value will be always '0' (NotApplicable). ")
mdlSReset = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSReset.setStatus('current')
if mibBuilder.loadTexts: mdlSReset.setDescription('Reset action to be performed on the module.')
mdlSRebuildFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSRebuildFrame.setStatus('current')
if mibBuilder.loadTexts: mdlSRebuildFrame.setDescription("Applicable only for KiloMux Main Link cards only. '2' = off, this will be always the Get value. '3' = on, this is the Set command used to Rebuild the Frame. Upon completing the operation, the value will automatically change to off(2), by Agent.")
mdlSBackupSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSBackupSwVer.setStatus('current')
if mibBuilder.loadTexts: mdlSBackupSwVer.setDescription('This attribute indicates the Backup Software version of the card installed in the specific slot position.')
mdlSSecondaryBackupSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSecondaryBackupSwVer.setStatus('current')
if mibBuilder.loadTexts: mdlSSecondaryBackupSwVer.setDescription('This attribute indicates the Secondary Backup Software version of the card installed in the specific slot position.')
mdlSPiggybackVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSPiggybackVer.setStatus('current')
if mibBuilder.loadTexts: mdlSPiggybackVer.setDescription('This attribute indicates the Piggyback version of the card installed in the specific slot position.')
mdlCTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2), )
if mibBuilder.loadTexts: mdlCTable.setStatus('current')
if mibBuilder.loadTexts: mdlCTable.setDescription('A table.')
mdlCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "mdlCConfigIdx"), (0, "RAD-MIB", "mdlCSlotIdx"))
if mibBuilder.loadTexts: mdlCEntry.setStatus('current')
if mibBuilder.loadTexts: mdlCEntry.setDescription('An entry in table.')
mdlCConfigIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCConfigIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCConfigIdx.setDescription('This object indicates the Configuration number (1..255) referred. Value of 255 specifies the TmpCnfg (Scratch).')
mdlCSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("psC", 20), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCSlotIdx.setStatus('current')
if mibBuilder.loadTexts: mdlCSlotIdx.setDescription('This object indicates a unique number of the slot position in which the module is inserted. The Kilomux should use enumerated values starting with kmx.')
mdlCProgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 70, 71, 72, 80, 81, 82, 83, 90, 91, 92, 100, 101, 102, 103, 104, 110, 111, 112, 113, 114, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 270, 271, 272, 273, 280, 281, 282, 283, 284, 290, 300, 301, 302, 303, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("psAC", 10), ("psDC", 11), ("gCl1", 18), ("gCl2", 19), ("dCl", 20), ("kCl", 21), ("dcl2", 22), ("dcl2Eth", 23), ("kClEth", 24), ("dcl3", 25), ("dcl3Eth", 26), ("d4T1", 28), ("d8T1", 29), ("dT1DSU", 30), ("dT1CSU", 31), ("dE1DSU", 32), ("dE1LTU", 33), ("dE1aDSU", 34), ("dE1aLTU", 35), ("dT1F", 36), ("dE1F", 37), ("d4E1", 38), ("d8E1", 39), ("dE1Hdsl", 40), ("dT1Hdsl", 41), ("dE1HdslS", 42), ("dT1HdslS", 43), ("d16gsdsl", 44), ("d8sl", 45), ("d4slStuC", 46), ("d4slStuR", 47), ("kML1", 50), ("kML2", 51), ("kML3", 52), ("kML4", 53), ("kML5", 54), ("kML6", 55), ("kML7", 56), ("kML8", 57), ("kML10", 59), ("kMLF", 60), ("kML10New", 61), ("kML11RJ45", 62), ("kML11FO", 63), ("kLS1", 70), ("kLS1New", 71), ("kLS2", 72), ("kTRE", 80), ("kMBE", 81), ("kMBENew", 82), ("fLAN", 83), ("kai", 90), ("kdi", 91), ("kdiCH", 92), ("dHS2", 100), ("d8U", 101), ("d16U", 102), ("d4HS", 103), ("d8HS", 104), ("kHS1", 110), ("kHS2", 111), ("kHSU1", 112), ("kHSU2", 113), ("kHS703", 114), ("kVC1EM", 130), ("kVC1FXO", 131), ("kVC1FXS", 132), ("kVC1MEM", 133), ("kVC1MFXO", 134), ("kVC1MFXS", 135), ("kVC1MFXSW", 136), ("kVC2EM", 137), ("kVC2FXO", 138), ("kVC2FXS", 139), ("kVC2s1EM", 140), ("kVC2s1FXO", 141), ("kVC2s1FXS", 142), ("kVC3EM", 143), ("kVC3FXO", 144), ("kVC3FXS", 145), ("kVC3S0", 146), ("kVF1EM", 170), ("kVF1FXO", 171), ("kVF1FXS", 172), ("kVF3EM", 173), ("kVF3FXO", 174), ("kVF3FXS", 175), ("kVF4EM", 176), ("kVF4FXO", 177), ("kVF4FXS", 178), ("kVF4FXSW", 179), ("kVF4S0", 180), ("kVF5PbxE1", 181), ("kVF5E1PbxSlave", 182), ("kVF5PbxT1", 183), ("kVF5T1PbxSlave", 184), ("kVF5PbxE1New", 185), ("kVF5E1PbxSlaveNew", 186), ("kVF5PbxT1New", 187), ("kVF5T1PbxSlaveNew", 188), ("kVF4FXO3", 189), ("kVF4FXS3", 190), ("kVF4NS0", 191), ("kVF6E1s16", 192), ("kVF6E1s31", 193), ("kVF6T1s12", 194), ("kVF6T1s24", 195), ("kVF8EM", 196), ("kVF8FXO", 197), ("kVF8FXS", 198), ("dimETUR", 200), ("dimV35", 201), ("dimRS422", 202), ("dimRS530", 203), ("dimHssi", 204), ("dimX21", 205), ("dim10BaseT", 206), ("dimE1", 207), ("dim100", 208), ("dt3G747", 209), ("dt3", 210), ("dt3f", 211), ("de3", 212), ("de3f", 213), ("dstm1s1", 214), ("dstm1s2", 215), ("fstm1", 216), ("dstm1", 217), ("dstm1R", 218), ("f2stm1", 219), ("gstm1", 220), ("goc3", 221), ("gstm1D", 222), ("goc3D", 223), ("serverE1", 270), ("serverT1", 271), ("serverE1Pw", 272), ("serverT1Pw", 273), ("gigabitEth", 280), ("gigabitEth2", 281), ("eth2", 282), ("gigabitEth8", 283), ("eth8", 284), ("channelizedT3Pw1", 290), ("cesT128", 300), ("cesE128", 301), ("cesT1Pw28", 302), ("cesE1Pw28", 303), ("vmxE1VeDe", 310), ("vmxE1VeDi", 311), ("vmxE1ViDe", 312), ("vmxE1ViDi", 313), ("vmxT1VeDe", 314), ("vmxT1VeDi", 315), ("vmxT1ViDe", 316), ("vmxT1ViDi", 317), ("vc12E1UeNe", 318), ("vc12E1UeNi", 319), ("vc12E1UiNe", 320), ("vc12E1UiNi", 321), ("vc12T1UeNe", 322), ("vc12T1UeNi", 323), ("vc12T1UiNe", 324), ("vc12T1UiNi", 325), ("vca16E1UeNe", 326), ("vca16E1UeNi", 327), ("vca16E1UiNe", 328), ("vca16E1UiNi", 329), ("vca16T1UeNe", 330), ("vca16T1UeNi", 331), ("vca16T1UiNe", 332), ("vca16T1UiNi", 333), ("vca12E1UeNe", 334), ("vca12E1UeNi", 335), ("vca12E1UiNe", 336), ("vca12E1UiNi", 337), ("vca12T1UeNe", 338), ("vca12T1UeNi", 339), ("vca12T1UiNe", 340), ("vca12T1UiNi", 341), ("vmg16E1Ue", 342), ("vmg16E1Ui", 343), ("vmg16T1Ue", 344), ("vmg16T1Ui", 345), ("vmg12E1Ue", 346), ("vmg12E1Ui", 347), ("vmg12T1Ue", 348), ("vmg12T1Ui", 349)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCProgCardType.setStatus('current')
if mibBuilder.loadTexts: mdlCProgCardType.setDescription('This object indicates the card type assigned to the specific slot in the common configuration. This object is identical for all the configurations (1..255). Only the TmpCnf(255) might have a different value. The write operation is valid only for the TmpCnfg entry.')
mdlCNoOfExtPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfExtPrt.setStatus('current')
if mibBuilder.loadTexts: mdlCNoOfExtPrt.setDescription('Number of external ports in the programmed module of the specific slot position')
mdlCNoOfIntPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfIntPrt.setStatus('current')
if mibBuilder.loadTexts: mdlCNoOfIntPrt.setDescription('Number of internal ports in the programmed module of the specific slot position.')
mdlCParam = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCParam.setStatus('current')
if mibBuilder.loadTexts: mdlCParam.setDescription("General configuration object at card level (per configuration). NotApplicable=0, for cards that don't support this object. For D8U and D16U cards of DXC, the object will indicate the port on which BERT will be performed. The port can be one of the external ports, any of its associated B1, B2, D ports or no port of the card (None=0). For port indexes see DXC R6 spec. For Gmux-2000, this parameter used for determining the Gigabit ETH exit port")
mdlAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3))
mdlAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1), )
if mibBuilder.loadTexts: mdlAlrTable.setStatus('current')
if mibBuilder.loadTexts: mdlAlrTable.setDescription('The list of card alarms. ')
mdlAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlAlrSltIdx"), (0, "RAD-MIB", "mdlAlrIdx"))
if mibBuilder.loadTexts: mdlAlrEntry.setStatus('current')
if mibBuilder.loadTexts: mdlAlrEntry.setDescription('An entry in table.')
mdlAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrIdx.setStatus('current')
if mibBuilder.loadTexts: mdlAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive')
mdlAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("psC", 20), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlAlrSltIdx.setDescription('This attribute indicates the desired slot position. The Kilomux should use enumerated values starting with kmx.')
mdlAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrCode.setStatus('current')
if mibBuilder.loadTexts: mdlAlrCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
mdlAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrState.setStatus('current')
if mibBuilder.loadTexts: mdlAlrState.setDescription('This object indicates the card alarm severity.')
mdlAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmMask.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmMask.setDescription('Alarm Mask is : on/off.')
mdlAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmInvert.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmInvert.setDescription('Alarm Invert is : on/off.')
mdlAlarmOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmOnOff.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmOnOff.setDescription('Alarm state is : on/off.')
mdlAlarmCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmCounter.setStatus('current')
if mibBuilder.loadTexts: mdlAlarmCounter.setDescription('A counter - how many times the alarm occured (ON) since last clear operation or since last Reset.')
mdlAlrMaskTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2), )
if mibBuilder.loadTexts: mdlAlrMaskTable.setStatus('current')
if mibBuilder.loadTexts: mdlAlrMaskTable.setDescription('The list of card masked alarms. ')
mdlAlrMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "mdlAlrMaskSltIdx"))
if mibBuilder.loadTexts: mdlAlrMaskEntry.setStatus('current')
if mibBuilder.loadTexts: mdlAlrMaskEntry.setDescription('An entry in table.')
mdlAlrMaskSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("psC", 20), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrMaskSltIdx.setStatus('current')
if mibBuilder.loadTexts: mdlAlrMaskSltIdx.setDescription('This attribute indicates the desired slot position. The Kilomux should use enumerated values starting with kmx.')
mdlAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlAlrMask.setStatus('current')
if mibBuilder.loadTexts: mdlAlrMask.setDescription("This object is a mask that indicates which card level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the card level will be 0. This object is applicable only when mdlSAlrMaskAll=off (otherwise all card alarms are masked). Example: When Alarm having the code 8 is masked, the value of this object will be 100 (hex).")
mdlClTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1), )
if mibBuilder.loadTexts: mdlClTable.setStatus('current')
if mibBuilder.loadTexts: mdlClTable.setDescription('A table.')
mdlClEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlClIdx"))
if mibBuilder.loadTexts: mdlClEntry.setStatus('current')
if mibBuilder.loadTexts: mdlClEntry.setDescription('An entry in table.')
mdlClIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClIdx.setStatus('current')
if mibBuilder.loadTexts: mdlClIdx.setDescription('This object indicates the Cl slot referred.')
mdlClSwchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClSwchStatus.setStatus('current')
if mibBuilder.loadTexts: mdlClSwchStatus.setDescription("This object indicates the status of the switches on the referred DCL card. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits. There are 4 switches: bit 0 SP-PAR (LSB) '1' - Default parameters bit 1 PSWRD '1' - Password=default '0' - Password=user selected bit 2 DB-INIT '1' - DB initiated with default '0' - DB initiated with NVRAM contents bit 3 PC-SP (MSB) '1' - Management by terminal only '0' - Management by NMS Example: If SP-PAR and PSWRD bits are set ('1'), the value will be 3 (2**1 + 2**0). When the status of the switches is unknown, the value of this object will be 255.")
mdlClLastFlipDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipDate.setStatus('current')
if mibBuilder.loadTexts: mdlClLastFlipDate.setDescription('Date when last flip occured. The format would be as specified by the sysSDateFormat.')
mdlClLastFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipTime.setStatus('current')
if mibBuilder.loadTexts: mdlClLastFlipTime.setDescription('Time when last flip occured.')
mdlClLastFlipCause = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipCause.setStatus('current')
if mibBuilder.loadTexts: mdlClLastFlipCause.setDescription('The cause of last flip.')
mdlPsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1), )
if mibBuilder.loadTexts: mdlPsTable.setStatus('current')
if mibBuilder.loadTexts: mdlPsTable.setDescription('A table.')
mdlPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "mdlPsIdx"))
if mibBuilder.loadTexts: mdlPsEntry.setStatus('current')
if mibBuilder.loadTexts: mdlPsEntry.setDescription('An entry in table.')
mdlPsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsIdx.setStatus('current')
if mibBuilder.loadTexts: mdlPsIdx.setDescription('This object indicates the PS card referred.')
mdlPsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsStatus.setStatus('current')
if mibBuilder.loadTexts: mdlPsStatus.setDescription('This object indicates the status of the PS card.')
mdlPsTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("f12V", 2), ("f5V", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsTestResult.setStatus('current')
if mibBuilder.loadTexts: mdlPsTestResult.setDescription('This object indicates the result of the PS card test. ok (1) - the test passed successfully. f12V (2) - 12V FAIL was detected f5V (3) - 5V FAIL was detected.')
prtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1))
prtT1E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2))
prtHS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3))
prtSP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4))
prtDim = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5))
prtI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6))
prtHdsl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7))
prtT3E3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8))
prtGenParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1), )
if mibBuilder.loadTexts: prtGenParamTable.setStatus('current')
if mibBuilder.loadTexts: prtGenParamTable.setDescription('A table.')
prtGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtGenPrtIdx"))
if mibBuilder.loadTexts: prtGenEntry.setStatus('current')
if mibBuilder.loadTexts: prtGenEntry.setDescription('An entry in table.')
prtGenPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenSlt.setStatus('current')
if mibBuilder.loadTexts: prtGenSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used. The Kilomux should use the enumerated starting with kmx.')
prtGenExtInt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("external", 2), ("internal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenExtInt.setStatus('current')
if mibBuilder.loadTexts: prtGenExtInt.setDescription("This attribute describes the type of the designated port. Exteral port is a port with a physical connector. Internal port might be of two types, one is a composite port which collects data of a few external ports into a common bandwidth (usually routed trough DS1 link); the other type is internal ports which get only part of external port data (usually a few DS0's). In the Kilomux-2100, the internal(3) value is used for composite channels or sub-channels of an ISDN Ch.")
prtGenIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenIfIndex.setStatus('current')
if mibBuilder.loadTexts: prtGenIfIndex.setDescription("This attribute indicates the unique interface number assigned to the port. The specific interface of this attribute is the same as the interface identified by the value of ifindex in MIB-II.If there is no interface for the specific prtIdx, the value will be '7fffffff'h.")
prtGenActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("notUsed", 2), ("offLine", 3), ("onLine", 4), ("offLineRedundancy", 5), ("onLineRedundancy", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenActiveStatus.setStatus('current')
if mibBuilder.loadTexts: prtGenActiveStatus.setDescription('This attribute describes the activity status of the port. unknown(1) indicates that the information is not supported. notUsed(2) indicates that the port is not connected according to the active config. offLine(3) indicates that the port is down (not working) due to any problem. onLine (4) indicates that the port is up (working) offLineRedundancy(5) indicates that the port is down because it is a redundant port. onLineRedundancy (6) indicates that this is a redundant port which is up and works as the active link.')
prtGenAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4), ("event", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenAlrStatus.setStatus('current')
if mibBuilder.loadTexts: prtGenAlrStatus.setDescription('Indicates the alarm state at port (ch) agent level. This object will be: - critical(7): when there is at least one active (ON) critical alarm . - major (3): when there is no active critical alarm, but there is at least one active (ON) major alarm . - minor (4): when there is no active major or critical alarm, but there is at least one active minor alarm. - warning (6): when there is no active major, critical or minor alarm, but there is at least one active warning alarm. - event (5): when there is no active alarm of another type, but there is at least one active event alarm. - off(2): when there is no active (ON) alarm (since last clear operation).')
prtGenTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestStatus.setStatus('current')
if mibBuilder.loadTexts: prtGenTestStatus.setDescription('This attribute will be on(3) when there is at least one test in progress (running) on the port; otherwise the value will be off(2).')
prtGenTestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestMask.setStatus('current')
if mibBuilder.loadTexts: prtGenTestMask.setDescription("This is a mask which indicates which tests from the 'prtGenTestCmd' list are allowed for the selected port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtGenTestCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTestCmd.setStatus('current')
if mibBuilder.loadTexts: prtGenTestCmd.setDescription('Setting this object to a value as detailed furter on (except 0) will initiate a test on the specific port, if the operation is allowed (according to TestMask). If the operation is not allowed, the mux will ignore the operation. The test/s requested will be set according to the respective bit: TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 e.g : If the requested value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the requested tests are : local-loop remote-loop Setting this object to stop (value=0 ; all bits are 0), will stop all the user requested tests running on the selected port; it will NOT stop the tests initiated by the system.')
prtGenTestRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestRunning.setStatus('current')
if mibBuilder.loadTexts: prtGenTestRunning.setDescription('This object indicates which tests are running currently on the selected port (initiated by user and/or by the system). If a specific test is currently running on the port, its respective bit will be SET: TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 llb 5 txInband 6 rxInband 7 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 DDS DSU loop 11 DDS CSU loop 12 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 Local DTE loop (HSSI)17 Local Line loop (HSSI)18 Remote Line loop (HSSI)19 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Network Line Loopback 24 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the running tests are : local-loop remote-loop llb (Bit 5) - can be initiated by system only! ')
prtGenType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 255))).clone(namedValues=NamedValues(("unknown", 1), ("t1", 2), ("e1", 3), ("hs", 4), ("t1Csu", 5), ("t1Dsu", 6), ("e1Ltu", 7), ("e1Dsu", 8), ("hdsl", 9), ("sp", 10), ("t1F", 11), ("e1F", 12), ("dim", 13), ("isdn", 14), ("t3", 15), ("e3", 16), ("t3f", 17), ("e3f", 18), ("idsl", 19), ("stm1", 20), ("vc4", 21), ("vc12", 22), ("msdsl", 23), ("vc11", 24), ("vc3", 25), ("soh", 26), ("eth", 27), ("shdsl", 28), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenType.setStatus('current')
if mibBuilder.loadTexts: prtGenType.setDescription('This object describes the type of the selected port. idsl - applicable for external ports of HS-U cards (of DXC) when interface is LT-1.')
prtGenInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenInterfaceType.setStatus('current')
if mibBuilder.loadTexts: prtGenInterfaceType.setDescription('This attribute indicates a unique HW interface type of the selected port. Examples: - for T1 cards: DSU, CSU - for E1 cards: DSU, LTU - for HS cards: v35, rs422, x21 etc...')
prtGenAlrClearCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noOp", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenAlrClearCmd.setStatus('current')
if mibBuilder.loadTexts: prtGenAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the port level alarms . Upon completion, the value will automatically change to off(2). noOp - will be used by agents that do not support this feature or object.')
prtGenAlrMaskAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noOp", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenAlrMaskAll.setStatus('current')
if mibBuilder.loadTexts: prtGenAlrMaskAll.setDescription('on(3) - will mask all the alarms of the selected port off(2)- will unmask all alarms of the selected port except the ones selected by the prtAlrMaskTable. noOp - will be used by agents that do not support this feature or object.')
prtGenParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenParamStatus.setStatus('current')
if mibBuilder.loadTexts: prtGenParamStatus.setDescription("This object indicates Status of parameters specific to the selected port. - For a port that has no special status or is supported by prtSExHsfStatTable - 1 Octet: 00hex - For HS cards (Dxc cards) - 1 octet: Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 0 and 1 indicates RTS control signal state: Bit 1: '1'=active ; '0'=notActive Bit 0 (LSB): '1'=unknown ; '0'=NA - For HS-U/1 external port (MP card, used in FCD-M) - 1 Octet: Bit 7 6 5 4 3 2 1 0 LSB |________| |__| |__| spare modem sync modem: 00 = other sync: 00 = not sync 01 = unknown 01 = sync 10 = ASMi-31/2 10 = reserved 11 = reserved 11 = reserved - For VC-6, VC-12, VC-12/6 external ports - 1 Octet : Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 1: Tx Signaling '1'=On ; '0'=Off Bit 0 (LSB): Rx Signaling '1'=On ; '0'=Off - For VC-2/R2(FXS) external ports - 1 Octet : Bit - 7 6 5 4 3 2 1 0 |_| |_________| Call Call State Direction Bit 7 (MSB) and Bit 6 : Call Direction 00 - Incoming 01 - Outgoing Bit 5..Bit 0: Call State 000000 - Idle 000001 - Seized 000010 - Both-Way Conflict 000011 - Seizure Ack 000100 - Answered 000101 - Clear Backward 000110 - Clear Forward 000111 - Blocked 001000 - Fault 001001 - Fault 3 001010 - Fault 4 001011 - Fault 5 001100 - Fault 6 001101 - Fault 7 - For ML-20 external port - 3 Octets : - 1 MS Octet will represent the Real Rate used: Bit - 7 6 5 4 3 2 1 0 |___| |_______| spare Rate Valid values: 0..31, meaning 0..31x64Kbps Invalid values: 32..255. - 2 LS Octets will represent the Status of 7 Control Signals: Signal - --- CTS DSR DCD RJ TM DTR RTS Bit - 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 Octet - 2 3 (LS) '---' will always have the value 00 Rest of the Signals (2 bits each) can have the following values: 00=NA ; 01=Unused ; 10=Off ; 11=On - For ML-H/E1, ML-H/1/E1, ML-H/S/E1 internal port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |___________| spare Mode of Operation Mode of Operation: '1'=Central ; '0'=Remote - For KM2100, KVF.5 cards - indicates the status of A and B signaling for each internal channel. 1 Octet: Bit - 7 6 5 4 3 2 1 0 |_____| |_| |_| spare B A Bit 0 (LSB) and Bit 1 : A status Bit 2 and Bit 3 : B status 00 - Off 01 - On 11 - Unknown - For FCD-W, NETWORK and USER ports - 1 Octet Status of Control Signals: '1'=On ; '0'=Off or when not applicable Bit - 7 6 5 4 3 2 1 0 Bit 7 (MSB) - Signal Loss (applicable only for G.703 interface) Bit 6 - CONTROL (applicable only for X.21 interface) Bit 5 - INDICATION (applicable only for X.21 interface) Bit 4 - DSR (applicable only for V.35 interface) Bit 3 - RTS (applicable only for V.35 interface) Bit 2 - CTS (applicable only for V.35 interface) Bit 1 - DTR (applicable only for V.35 interface) Bit 0 - DCD (applicable only for V.35 interface) - For DXC R6 , D8U, D16U External ports - 1 Octet Bit 7 6 5 4 3 2 1 0 LSB |________| |__| |__| spare modem sync modem: 00 = other sync: 00 = not sync 01 = unknown 01 = sync 10 = ASMi-31/2 10 = reserved 11 = reserved 11 = reserved - For DXC DE1-HDSL, DT1-HDSL, D16GSDSL, D8SL External ports - 2 Octets MSB octet: far-end modem channel interface LSB octet: Sub Link existence (Y/N), far-end modem type, synchronization with far-end modem MSB octet: 0000 0000 = no interface 0000 0001 = db15 (X21) 0000 0010 = IR-IP 0000 0011 = IR-ETH-Q 0000 0100 = V35 0000 0101 = ETH-RJ45 0000 0110 = G703 0000 0111 = db25 (RS530) 0000 1000 = ETH-BNC 0000 1001 = E1(Balanced) 0000 1010 = E1(Unbalanced) 0000 1011 = IR-ETH-QN Rest of the combinations: reserved LSB octet: Bit 7 6 5 4 3 2 1 0 LSB | |___________| |__| SL modem sync or Box material SL: modem: 00000 = other sync: 00 = not sync 0=not exist 00001 = unknown 01 = sync 1=exists 00010 = ASMi-31/2 10 = reserved 00011 = HCD-E1 11 = reserved Box material 00100 = HTU-E1 (for D8SL card): 00101 = HTU-2 0=metal 00110 = ASMi-52 SA/2W/Slave 1=plastic 00111 = ASMi-52 SA/2W/Master 01000 = ASMi-52/CQ card of LRS-24 01001 = ASMi-52/CD card of LRS-24 01010 = D16GSDSL card of DXC-3000 01011 = LRS-52 01100 = FCD 01110 = D8GSDSL card of DXC-3000 01111 = ASMi-52A Rest = reserved ")
prtGenRdnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenRdnStatus.setStatus('current')
if mibBuilder.loadTexts: prtGenRdnStatus.setDescription('This object indicates if this port is part of a redundant pair and in this case, if it is On or Off. none(1) - No redundancy or Not Applicable off (2) - the port is part of a redundant pair and it is Off from Redundancy point of view (not the port used). on (3) - the port is part of a redundant pair and it is On from Redundancy point of view (it is the port used).')
prtGenTestMaskXP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestMaskXP.setStatus('current')
if mibBuilder.loadTexts: prtGenTestMaskXP.setDescription("This is an Expanded test mask of the prtGenTestMask object. The prtGenTestMask object reached its maximum, being an Integer with 31 bits. This object indicates which tests from the 'prtGenTestCmdXP' list are allowed for the selected port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- localLoop 1 =LSB remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 Downstream-AIS 32 Upstream-AIS 33 Send-RDI 34 Test Per TS 35 e.g : If the return value is 00000003 hex -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtGenTestCmdXP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 18), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTestCmdXP.setStatus('current')
if mibBuilder.loadTexts: prtGenTestCmdXP.setDescription('This is an Expanded test command of the prtGenTestCmd object. The prtGenTestCmd object reached its maximum, being an Integer with 31 bits. Setting this object to a value as detailed furter on (except 0) will initiate a test on the specific port, if the operation is allowed (according to TestMaskXP). If the operation is not allowed, the mux will ignore the operation. The test/s requested will be set according to the respective bit: TEST BIT ----------- --- localLoop 1 =LSB remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 Downstream-AIS 32 Upstream-AIS 33 Send-RDI 34 Test Per TS 35 e.g : If the requested value is 00000003 hex -> Bits 1 & 2 are set -> the requested tests are : local-loop remote-loop Setting this object to stop (value=0 ; all bits are 0), will stop all the user requested tests running on the selected port; it will NOT stop the tests initiated by the system.')
prtGenTestRunningXP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestRunningXP.setStatus('current')
if mibBuilder.loadTexts: prtGenTestRunningXP.setDescription('This is an Expanded object of the prtGenTestRunning object. The prtGenTestRunning object reached its maximum, being an Integer with 31 bits. This object indicates which tests are running currently on the selected port (initiated by user and/or by the system). If a specific test is currently running on the port, its respective bit will be SET: TEST BIT ----------- --- localLoop 1 =LSB remoteLoop 2 bert 3 plb 4 llb 5 txInband 6 rxInband 7 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 DDS DSU loop 11 DDS CSU loop 12 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 Local DTE loop (HSSI)17 Local Line loop (HSSI)18 Remote Line loop (HSSI)19 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Network Line Loopback 24 Rem-Loop-on-Rem-Unit 25 LBBD 26 LB1 27 LB2 28 BERT-on-Rem-Unit 29 TS Remote Loop 30 LLB-on-Rem-Unit 31 Downstream-AIS 32 Upstream-AIS 33 Send-RDI 34 Test Per TS 35 e.g : If the return value is 00000003 hex -> Bits 1 & 2 are set -> the running tests are : local-loop remote-loop llb (Bit 5) - can be initiated by system only! ')
prtGenTestDurationTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2), )
if mibBuilder.loadTexts: prtGenTestDurationTable.setStatus('current')
if mibBuilder.loadTexts: prtGenTestDurationTable.setDescription('A table.')
prtGenTestDurationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtGenTestPrtIdx"), (0, "RAD-MIB", "prtGenTestIdx"))
if mibBuilder.loadTexts: prtGenTestDurationEntry.setStatus('current')
if mibBuilder.loadTexts: prtGenTestDurationEntry.setDescription('An entry in table.')
prtGenTestPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenTestPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenTestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 20, 21, 22, 23, 26, 27, 28, 30, 32, 33, 34))).clone(namedValues=NamedValues(("localLoop", 1), ("remoteLoop", 2), ("bert", 3), ("plb", 4), ("rlb", 5), ("llb", 6), ("toneInjection", 7), ("txInband", 8), ("rxInband", 9), ("remLoopOnRemUnit", 10), ("bertOnRemUnit", 11), ("llbOnRemUnit", 12), ("txPlb", 14), ("txLlb", 15), ("dteLoop", 16), ("hdslTxInband", 20), ("hdslRxInband", 21), ("monitor", 22), ("userLineLoopback", 23), ("lbbd", 26), ("lb1", 27), ("lb2", 28), ("tsRemoteLoop", 30), ("downstreamAis", 32), ("upstreamAis", 33), ("sendRdi", 34)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenTestIdx.setDescription('This attribute indicates the test, the duration refers. ')
prtGenTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTestDuration.setStatus('current')
if mibBuilder.loadTexts: prtGenTestDuration.setDescription("This attribute indicates the maximum duration of executing a test on the specific port. This entry applies to the specified test . The resolution will be a minute, and the maximum duration is limited to 30 minutes . A zero value specifies no time limitation. When the test isn't active the agent initiates this object to 2 min. when the duration is needed and to 0 if it's not required.")
prtGenTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3), )
if mibBuilder.loadTexts: prtGenTsTable.setStatus('current')
if mibBuilder.loadTexts: prtGenTsTable.setDescription("The write operation into the Table's Objects is valid only for the TmpCnfg entry (Scratch),exept some products which enable direct writing to the ActiveCnfg. This is written in the respective product's spec. ")
prtGenTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtGenTsCnfgIdx"), (0, "RAD-MIB", "prtGenTsPrtIdx"), (0, "RAD-MIB", "prtGenTsIdx"))
if mibBuilder.loadTexts: prtGenTsEntry.setStatus('current')
if mibBuilder.loadTexts: prtGenTsEntry.setDescription('An entry in table.')
prtGenTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg. ')
prtGenTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenTsPrtIdx.setDescription('This attribute indicates a unique port number. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsIdx.setStatus('current')
if mibBuilder.loadTexts: prtGenTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..25 for T1 Card (25=Fbit) 0..31 for E1 or HS Card . In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtGenTsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("voice", 2), ("data", 3), ("vcMP", 4), ("nc", 5), ("mng", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsType.setStatus('current')
if mibBuilder.loadTexts: prtGenTsType.setDescription("The type of Timeslot. If the source or destination port is an HS port,'TS Type' must be 'data'. nc - means that this TimeSlot is not connected. voice, data, vcMP - also mean that this TS is connected. mng - means that this TS is dedicated to Management (not connected to another port.")
prtGenTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsIConPrt.setStatus('current')
if mibBuilder.loadTexts: prtGenTsIConPrt.setDescription("This attribute indicates the internally (In Mux) connected port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) for a stand-alone unit, the IO slot will be considered 1. - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside ports will be for example, the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) for a stand-alone unit, the IO slot will be considered 1. - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . * noConnection - will be indicated as 10 for DXC and FCD-E1/T1. - will be indicated as 100 for FCD-E1/I and SMODs. * Split TS (same TS is Split to several ports) - 11. * notApplicable- will be indicated as 100 for LRS IMODs. All HS port's timeslots must have the same destination port.")
prtGenTsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsIConTs.setStatus('current')
if mibBuilder.loadTexts: prtGenTsIConTs.setDescription("This attribute indicates a unique time slot position. The valid time slots are 1..25 for T1 Card (25=Fbit) 0..31 for E1 (or HS) Card. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling. * For DXC: All HS port's timeslots must start with Timeslot no.1 ")
prtAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4))
prtSAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1), )
if mibBuilder.loadTexts: prtSAlarmTable.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmTable.setDescription('A table.')
prtSAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtSAlarmPrtIdx"), (0, "RAD-MIB", "prtSAlarmIdx"))
if mibBuilder.loadTexts: prtSAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmEntry.setDescription('An entry in table.')
prtSAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmIdx.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive.')
prtSAlarmPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtSAlarmCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmCode.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
prtSAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmState.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmState.setDescription('This object indicates the port alarm severity.')
prtSAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmMask.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmMask.setDescription('Alarm Mask is : on/off.')
prtSAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmInvert.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmInvert.setDescription('Alarm Invert is : on/off.')
prtSAlarmOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmOnOff.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmOnOff.setDescription('Alarm state is : on/off.')
prtSAlarmCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmCounter.setStatus('current')
if mibBuilder.loadTexts: prtSAlarmCounter.setDescription('A counter - how many times the alarm occured (ON) since last clear operation or since last Reset.')
prtAlrMaskTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2), )
if mibBuilder.loadTexts: prtAlrMaskTable.setStatus('current')
if mibBuilder.loadTexts: prtAlrMaskTable.setDescription('A table.')
prtAlrMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtAlrMaskPrtIdx"))
if mibBuilder.loadTexts: prtAlrMaskEntry.setStatus('current')
if mibBuilder.loadTexts: prtAlrMaskEntry.setDescription('An entry in table.')
prtAlrMaskPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlrMaskPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtAlrMaskPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAlrMask.setStatus('current')
if mibBuilder.loadTexts: prtAlrMask.setDescription("This object is a mask that indicates which port level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the port level will be 0. This object is applicable only when prtGenAlrMaskAll=off (otherwise all port alarms are masked). Example: When Alarms having the codes 31 and 40 are masked, the value of this object will be 10080000000 (hex).")
prtBertTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5), )
if mibBuilder.loadTexts: prtBertTable.setStatus('current')
if mibBuilder.loadTexts: prtBertTable.setDescription('This table includes the BERT parameters, counters and commands. The configurable parameters: - prtBertPattern - prtBertInjectRate - prtBertTs are not Set per configuration (same for all Configurations) but start being applied by the Agent only upon successful Update/Download operation. Therefore, Set will enter the values to the Temporary Configuration of the agent, while Get will get the values of the Active Configuration.')
prtBertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1), ).setIndexNames((0, "RAD-MIB", "prtBertPrtIdx"))
if mibBuilder.loadTexts: prtBertEntry.setStatus('current')
if mibBuilder.loadTexts: prtBertEntry.setDescription('An entry in table.')
prtBertPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtBertPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . In the MP : - first two digits will be: (IO slot number+10) - last one/two digits will be according to the external port number within the card: exPrt1 -> 1 exPrt2 -> 3 exPrt3 -> 5 exPrt4 -> 7 . ')
prtBertPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 255))).clone(namedValues=NamedValues(("p2E3m1", 1), ("p2E4m1", 2), ("p2E5m1", 3), ("p2E6m1", 4), ("p2E7m1", 5), ("p511", 6), ("p2E10m1", 7), ("p2047", 8), ("p2E15m1", 9), ("p2E17m1", 10), ("p2E18m1", 11), ("p2E20m1", 12), ("qrss", 13), ("p2E21m1", 14), ("p2E22m1", 15), ("p2E23m1", 16), ("p2E25m1", 17), ("p2E28m1", 18), ("p2E29m1", 19), ("p2E31m1", 20), ("p2E32m1", 21), ("rj011", 22), ("p63", 23), ("p1M7S", 24), ("p1S7M", 25), ("alternate", 26), ("mark", 27), ("space", 28), ("p2E11m1", 29), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertPattern.setStatus('current')
if mibBuilder.loadTexts: prtBertPattern.setDescription('This object indicates the pattern of the BERT. p2Exxm1 = 2Exx-1. pxx = pattern xx. This object is the same for all configurations. notApplicable - when this object is not supported.')
prtBertInjectRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("noError", 1), ("r10Em1", 2), ("r10Em2", 3), ("r10Em3", 4), ("r10Em4", 5), ("r10Em5", 6), ("r10Em6", 7), ("r10Em7", 8), ("single", 9), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectRate.setStatus('current')
if mibBuilder.loadTexts: prtBertInjectRate.setDescription('This object indicates the error rate injection of the BERT. r10Emx = 10E-x This object is the same for all configurations. single - single error injection. notApplicable - when this object is not supported.')
prtBertInjectErrRateCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectErrRateCmd.setStatus('current')
if mibBuilder.loadTexts: prtBertInjectErrRateCmd.setDescription('This object controls activation/deactivation of the Error Rate Injection during BERT.')
prtBertInjectSingleErrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectSingleErrCmd.setStatus('current')
if mibBuilder.loadTexts: prtBertInjectSingleErrCmd.setDescription('This object enables to initiate a Single Error Injection during BERT (on). Upon completion, the value will automatically change to off(2).')
prtBertRunTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertRunTime.setStatus('current')
if mibBuilder.loadTexts: prtBertRunTime.setDescription('This object indicates how much time (seconds) passed since BERT started to run.')
prtBertESs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertESs.setStatus('current')
if mibBuilder.loadTexts: prtBertESs.setDescription('How many Errored Seconds were detected since BERT started to run. Counter for Kmux and MP.')
prtBertSyncLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertSyncLoss.setStatus('current')
if mibBuilder.loadTexts: prtBertSyncLoss.setDescription('How many times Sync Loss was detected since BERT started to run. For some products: number of seconds in which Sync Loss occured since BERT started to run. See product specification.')
prtBertErrorBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertErrorBits.setStatus('current')
if mibBuilder.loadTexts: prtBertErrorBits.setDescription('How many Error Bits were detected since BERT started to run.')
prtBertClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertClearCounters.setStatus('current')
if mibBuilder.loadTexts: prtBertClearCounters.setDescription('Setting this object to ON, will enforce a clear operation of some BERT Counters. Upon completion, the value will automatically change to off(2).')
prtBertSyncStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("syncLoss", 2), ("sync", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertSyncStatus.setStatus('current')
if mibBuilder.loadTexts: prtBertSyncStatus.setDescription('Sync Status while BERT runs.')
prtBertTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertTs.setStatus('current')
if mibBuilder.loadTexts: prtBertTs.setDescription("This object indicates on which TSs of the selected port, BERT should be applied. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - BERT should be applied on this TS. For a T1 port, the valid raised bits ('1') are: 1..25. For an E1 port, the valid raised bits ('1') are: 1..31. Agents that do not support this feature will send SIZE 0.")
prtBertResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertResult.setStatus('current')
if mibBuilder.loadTexts: prtBertResult.setDescription('This object indicates Result of BERT for the selected port (number of error bits divided to the total number of data bits.) Applicable only if BERT is running on this port Agents that do not support this feature will send SIZE 0.')
prtBertTxBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertTxBits.setStatus('current')
if mibBuilder.loadTexts: prtBertTxBits.setDescription('How many data bits were transmitted since BERT started to run, or since last counter clear (prtBertClearCounters set to on).')
prtBertRxBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertRxBits.setStatus('current')
if mibBuilder.loadTexts: prtBertRxBits.setDescription('How many data bits were Received since BERT started to run, or since last counter clear (prtBertClearCounters set to on).')
prtBertTxErrorBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertTxErrorBits.setStatus('current')
if mibBuilder.loadTexts: prtBertTxErrorBits.setDescription('Number of injected error bits since BERT started to run, or since last counter clear (prtBertClearCounters set to on).')
prtMonTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6), )
if mibBuilder.loadTexts: prtMonTable.setStatus('current')
if mibBuilder.loadTexts: prtMonTable.setDescription("For DXC, the write operation into the Table's Objects is valid only for the TmpCnfg entry (Scratch).")
prtMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1), ).setIndexNames((0, "RAD-MIB", "prtMonCnfgIdx"), (0, "RAD-MIB", "prtMonitoringIdx"))
if mibBuilder.loadTexts: prtMonEntry.setStatus('current')
if mibBuilder.loadTexts: prtMonEntry.setDescription('An entry in table.')
prtMonCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMonCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtMonCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg. For products that do not support configurations, 1 will be always used.')
prtMonitoringIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMonitoringIdx.setStatus('current')
if mibBuilder.loadTexts: prtMonitoringIdx.setDescription('This object indicates the Monitoring Port Index. For DXC: The valid port number depends on the IO slot no., the installed card type and the port type: external, internal. * The external ports will according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The internal ports will be according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For Optimux-T3: 255 (Not Applicable) will be always used. The Monitoring port is always the Station Clock (not considered an interface).')
prtMonitoringEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoringEnable.setStatus('current')
if mibBuilder.loadTexts: prtMonitoringEnable.setDescription('This object indicates if the prtMonitoringIdx is configured as a monitoring port or not. disabled = the port is NOT configured to monitor. Setting this object to this value will cause reset (to 0) of the prtMonitoringTSs and prtMonitoredTSs objects. enabled = the port IS configured to monitor. For Optimux-T3: always enabled (RO supported).')
prtMonitoringTSs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoringTSs.setStatus('current')
if mibBuilder.loadTexts: prtMonitoringTSs.setDescription("This object indicates which TSs of the Monitoring port, the test equipment should monitor. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - this TS should be monitored. For a T1 port, the valid raised bits ('1') are: 1..24. For an E1 port, the valid raised bits ('1') are: 1..31. Default: all bits='0' Agents that do not support this feature will send SIZE 0. This object can be Set as described only if prtMonitoringEnable=enabled. ")
prtMonitoredPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoredPort.setStatus('current')
if mibBuilder.loadTexts: prtMonitoredPort.setDescription("This object indicates the MONITORED Port Index that the Monitoring port monitors. For DXC: The valid port number depends on the IO slot no., the installed card type and the port type: external, internal. * The external ports will according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The internal ports will be according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . * 100 - no port monitored For Optimux-T3: The valid channels are: 0 = no Ch monitored 1..21 or 1..28 (=CH1..CH21 or CH1..CH28) according to product's configuration.")
prtMonitoredTSs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoredTSs.setStatus('current')
if mibBuilder.loadTexts: prtMonitoredTSs.setDescription("This object indicates which TSs of the Monitored port, should be monitored. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - this TS should be monitored. For a T1 port, the valid raised bits ('1') are: 1..24. For an E1 port, the valid raised bits ('1') are: 1..31. Default: all bits='0' Agents that do not support this feature will send SIZE 0. This object can be Set as described only if prtMonitoringEnable=enabled.")
prtCfgParam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7))
prtCfgParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1), )
if mibBuilder.loadTexts: prtCfgParamTable.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry. KMUX parameters are for the cards: KMBE/New, KVF.6 family.')
prtCfgParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtCfgParamCnfgIdx"), (0, "RAD-MIB", "prtCfgParamIdx"))
if mibBuilder.loadTexts: prtCfgParamEntry.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamEntry.setDescription('An entry in table.')
prtCfgParamCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg.')
prtCfgParamIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamIdx.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamIdx.setDescription("A unique identifier of the port (within the card when applicable). - For KM-2100: Slot*100+Ch external ports: Ch=1..10 internal ports (sub-channels): Ch=11..20. - For FCD-T1/E1(L): MAIN=111, SUB=113, CH1=122, CH2=124. - For other devices, see specific device's spec. ")
prtCfgParamSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamSlt.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. In the 2104 Unit the entries kmxIO5(111)..kmxIO12(118) are not valid. notApplicable(255) - for products that do not have Slots.')
prtCfgParamOperatedMl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 103, 104))).clone(namedValues=NamedValues(("notApplicable", 1), ("kmxMlA", 103), ("kmxMlB", 104)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamOperatedMl.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamOperatedMl.setDescription('The main link for this channel. The field is relevant only for ML modes of Dual, Priority Bumping and Switched Backup.')
prtCfgParamMlAtoMlBPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamMlAtoMlBPrio.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamMlAtoMlBPrio.setDescription('ML-A to ML-B Priority. The field is relevant only for ML modes of Priority Bumping and Switched Backup.')
prtCfgParamMlBtoMlAPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamMlBtoMlAPrio.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamMlBtoMlAPrio.setDescription('ML-B to ML-A Priority. The field is relevant only for ML modes of Priority Bumping.')
prtCfgParamInbandLoopDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamInbandLoopDetection.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamInbandLoopDetection.setDescription('Inband Loop Detection. The field is relevant for FCD-T1/E1(L) ports.')
prtCfgParamInbandLoopPatternCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("rdlLoop", 2), ("userConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamInbandLoopPatternCfg.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamInbandLoopPatternCfg.setDescription('This object indicates if Inband Loop polynomial pattern will be according to RDL Loop (the standard) or User Configurated according to prtCfgParamInbandLoopActPattern and prtCfgParamInbandLoopDeactPattern.')
prtCfgParamInbandLoopActPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamInbandLoopActPattern.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamInbandLoopActPattern.setDescription("This object is a binary string of up to 8 bits. Though the syntax allows for any ASCII characters, for this object only '0' or '1' characters are valid. The string determines coefficients of the polynomial pattern sent to the port in order to Activate the Inband Loop. This object is relevant only when prtCfgParamInbandLoopPatternCfg=userConfig.")
prtCfgParamInbandLoopDeactPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamInbandLoopDeactPattern.setStatus('current')
if mibBuilder.loadTexts: prtCfgParamInbandLoopDeactPattern.setDescription("This object is a binary string of up to 8 bits. Though the syntax allows for any ASCII characters, for this object only '0' or '1' characters are valid. The string determines coefficients of the polynomial pattern sent to the port in order to Deactivate the Inband Loop. This object is relevant only when prtCfgParamInbandLoopPatternCfg=userConfig.")
prtT1E1StatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1), )
if mibBuilder.loadTexts: prtT1E1StatTable.setStatus('current')
if mibBuilder.loadTexts: prtT1E1StatTable.setDescription('T1/E1 port statistics table.')
prtT1E1StatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtT1E1SPrtIdx"))
if mibBuilder.loadTexts: prtT1E1StatEntry.setStatus('current')
if mibBuilder.loadTexts: prtT1E1StatEntry.setDescription(' An entry in the T1/E1 port statistics table.')
prtT1E1SPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1SPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1E1SPrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 .')
prtT1E1SSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1SSlt.setStatus('current')
if mibBuilder.loadTexts: prtT1E1SSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1OosCount = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1OosCount.setStatus('current')
if mibBuilder.loadTexts: prtT1E1OosCount.setDescription('This object is applicable only for an E1 active port. It provides the number of red alarm events since the last count clearing.')
prtT1E1BpvLastMin = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1BpvLastMin.setStatus('current')
if mibBuilder.loadTexts: prtT1E1BpvLastMin.setDescription('This object is applicable only for an E1 active port. It provides the number of BPV (BiPolar Violation) events detected during the last minute.')
prtT1E1BpvMax = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1BpvMax.setStatus('current')
if mibBuilder.loadTexts: prtT1E1BpvMax.setDescription('This object is applicable only for an E1 active port. It provides the maximal number of BPV (BiPolar Violation) events (per minute), detected during the worst minute.')
prtT1E1CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2), )
if mibBuilder.loadTexts: prtT1E1CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtT1E1CnfgTable.setDescription('T1/E1 port configuration table.')
prtT1E1CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtT1E1CnfgIdx"), (0, "RAD-MIB", "prtT1E1PrtIdx"))
if mibBuilder.loadTexts: prtT1E1CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtT1E1CnfgEntry.setDescription(' An entry in the T1/E1 port configuration table.')
prtT1E1CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1E1CnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtT1E1PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1E1PrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20.')
prtT1E1Slt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 103, 104, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1Slt.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Slt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("esf", 2), ("d4", 3), ("e1", 4), ("e1Crc", 5), ("e1MF", 6), ("e1CrcMF", 7), ("unframed", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineType.setStatus('current')
if mibBuilder.loadTexts: prtT1E1LineType.setDescription('This variable indicates the variety of T1/E1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. The values, in sequence, describe: TITLE: SPECIFICATION: esf Extended SuperFrame DS1 d4 AT&T D4 format DS1 - SF e1 CCITT Recommendation G.704 (Table 4a) - G732N e1Crc CCITT Recommendation G.704 (Table 4b) - G732N with CRC e1MF G.704 (Table 4a) with TS16 multiframing enabled - G732S e1CrcMF G.704 (Table 4b) with TS16 multiframing enabled - G732S with CRC unframed T1 - applicable values: (1),(2),(3),(8) E1 - applicable values: (1),(4),(5),(6),(7),(8) ')
prtT1E1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("jbzs", 1), ("b8zs", 2), ("hdb3", 3), ("zbtsi", 4), ("ami", 5), ("other", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineCode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1LineCode.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. jbzs=b7zs refers the Jammed Bit Zero Suppres- sion, in which the AT&T specification of at least one pulse every 8 bit periods is literal- ly implemented by forcing a pulse in bit 8 of each channel. Thus, only seven bits per chan- nel, or 1.344 Mbps, is available for data (used for T1). b8zs refers to the use of a specified pattern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits (used for T1). ANSI Clear Channels may use zbtsi, or Zero Byte Time Slot Interchange. E1 links, with or without CRC, use hdb3 or ami (= TRAN). amI (=TRAN) refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data.')
prtT1E1SignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("robbedBit", 2), ("bitOriented", 3), ("messageOriented", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1SignalMode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1SignalMode.setDescription("'none' indicates that no bits are reserved for signaling on this channel. 'robbedBit' indicates that T1 Robbed Bit Signaling is in use. 'bitOriented' indicates that E1 Channel Associated Signaling (CAS) is in use. 'messageOriented' indicates that Common Channel Signaling (CCS) is in use either on channel 16 of an E1 link or channel 24 of a T1.")
prtT1E1Fdl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("other", 1), ("ansi-T1-403", 2), ("att-54016", 4), ("fdl-none", 8), ("transFdl", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Fdl.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Fdl.setDescription("This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: 'other' indicates that a protocol other than one following is used. 'ansi-T1-403' refers to the FDL exchange recommended by ANSI. 'att-54016' refers to ESF FDL exchanges. 'fdl-none' indicates that the device does not use the FDL. 'transFdl' indicates transition between two ports of the same card. ")
prtT1E1FdlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("carrier", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1FdlMode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMode.setDescription(' Fdl Mode of the T1 selected port. notApplicable - will be used for an E1 port.')
prtT1E1Sync = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("tr62411", 2), ("ccitt", 3), ("fast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Sync.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Sync.setDescription("This object enables returning to normal operation, after the end of a main/sub link red alarm event, in reduced time. 'tr62411' - complies with AT&T TR-62411 (after 10 seconds). Applicable for both T1 and E1 interfaces. 'ccitt' - complies with CCITT standard. Applicable only for E1 interfaces. 'fast' - after 1 second.")
prtT1E1CGA = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("trans", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1CGA.setStatus('current')
if mibBuilder.loadTexts: prtT1E1CGA.setDescription("This object selects the method used to signal the CGA state to the other end, through the main/sub link. 'none' - non-transparent mode. When one of the links (main/sub) will be in Out Of Service state, both 'Data/Voice Oos' and 'Oos Signal' will be transmitted to the other end. 'trans' - when one of the links (main/sub) will be in Out Of Service state, 'Data/Voice Oos' will be transmitted to the other end. 'full' - fully-transparent mode. When one of the links (main/sub) will be in Out Of Service state, neither 'Data/Voice Oos' nor 'Oos Signal' will be transmitted to the other end.")
prtT1E1IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1IdleCode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1IdleCode.setDescription('This object selects the code transmitted to fill idle (unused) time slots in the main link frame. Valid range: (0 - FF HEX) .')
prtT1E1OosSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notsupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1OosSignal.setStatus('current')
if mibBuilder.loadTexts: prtT1E1OosSignal.setDescription("'idle' = '0' = on-hook, idle state 'busy' = '1' = off-hook, busy state 'forcedIdle' = SP = both A and B signaling bits are forced to '0' during out-of-service periods. 'forcedBusy' = MK = both A and B signaling bits are forced to '1' during out-of-service periods. 'busyIdle' = MK_SP = A and B bits are forced to '1' for 2.5 seconds; then they are switched to '0' until out-of-service condition disappears. 'idleBusy' = SP_MK = A and B bits are forced to '0' for 2.5 seconds; then they are switched to '1' until out-of-service condition disappears. - for T1: '0'=0 ; '1'=1 - for E1: '0'=1 ; '1'=0 ")
prtT1E1VoiceOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1VoiceOos.setStatus('current')
if mibBuilder.loadTexts: prtT1E1VoiceOos.setDescription('Voice Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtT1E1DataOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1DataOos.setStatus('current')
if mibBuilder.loadTexts: prtT1E1DataOos.setDescription('Data Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtT1E1LineLengthMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("fcc68", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineLengthMask.setStatus('current')
if mibBuilder.loadTexts: prtT1E1LineLengthMask.setDescription("This attribute is the line length mask parameter used only for T1/DSU interfaces. len400p533ft=length range: 400ft to 533ft 'fcc68' - provides compliance with the FCC 68.308 Option A output pulse mask. ")
prtT1E1TxGainMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("txGain0db", 2), ("txGain7dot5db", 3), ("txGain15db", 4), ("txGain22dot5db", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1TxGainMask.setStatus('current')
if mibBuilder.loadTexts: prtT1E1TxGainMask.setDescription('This attribute is the tx gain mask parameter (dB), used only for T1/CSU interfaces.')
prtT1E1InbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("fdlOrTs0", 3), ("dedicatedTs", 4), ("dedicatedPpp", 5), ("dedicatedFr", 6), ("internal", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMng.setStatus('current')
if mibBuilder.loadTexts: prtT1E1InbandMng.setDescription('A unique number to identify an Inband management over the link. internal - supported by KM-2100 only. It means that the management is internal to the frame. It takes part of the ML Frame bits (instead of data).')
prtT1E1InbandMngRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("r4k", 2), ("r8k", 3), ("r12k", 4), ("r16k", 5), ("r32k", 6), ("r64k", 7), ("r20k", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMngRate.setStatus('current')
if mibBuilder.loadTexts: prtT1E1InbandMngRate.setDescription('A unique number to identify the rate of the Inband management. It is required only for E1 links and is applicable only when prtExT1E1InbandMng selected is FdlOrTs0 or dedicatedTs.')
prtT1E1DedicatedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1DedicatedTs.setStatus('current')
if mibBuilder.loadTexts: prtT1E1DedicatedTs.setDescription('The value is differently determined for different products. There are two methods: 1) A unique number to identify Dedicated TS of the T1/E1 port. It is applicable only when prtExT1E1InbandMng selected is dedicatedTs. 1..24 - Dedicated TS of T1 1..31 - Dedicated TS of E1 255 - notApplicable (for agents that do not support this feature) Other values are invalid. 2) For FCD-STM, up to five TSs may be dedicated to management. This object value is the Sum (sigma) of 2**n, where n =TS-1 e.g. Time slots 3,5,7,9,11 are dedicated to management: 2** 2 +2** 4 +2** 6 +2** 8 +2**10 = 4+16+64+256+1024=1364 User should consult the product specification, to find out the method employed.')
prtT1E1InbandMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMngRoutProt.setStatus('current')
if mibBuilder.loadTexts: prtT1E1InbandMngRoutProt.setDescription("Inband Mng Routing Protocol of the port. When prtT1E1InbandMng is 'dedicatedPpp'-'proprietary' and 'rip2' are applicable. For other values - only 'proprietary' is applicable. For FCD-M and FCD-A: When prtT1E1InbandMng is 'dedicatedPpp' or 'dedicatedFr': 'None', 'proprietary' and 'rip2' are applicable. When prtT1E1InbandMng is 'fdlOrTS0' or 'dedicatedTs': 'None' and 'proprietary' are applicable. When prtT1E1InbandMng is 'off': 'None' is applicable.")
prtT1E1LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("regular", 2), ("transparent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LinkMode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1LinkMode.setDescription('regular - TSs are connected by user via TS Assignment only transparent - when a port with this Link Mode is connected to an internal T1/E1 port of a T3/E3 card, TS0, TS16 and Fbit are transparently transferred to the E3/T3 stream.')
prtT1E1Multiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("br56", 2), ("br64", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Multiplier.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Multiplier.setDescription('The data rate of each TS. The multiplier values can be 56 kbps or 64 kbps. For T1 only.')
prtT1E1RxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("rxGain12dB", 2), ("rxGain30dB", 3), ("rxGain36dB", 4), ("shortHaul", 5), ("longHaul", 6), ("rxGain20dB", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1RxGain.setStatus('current')
if mibBuilder.loadTexts: prtT1E1RxGain.setDescription('This attribute is the rx volume (dB).')
prtT1E1RAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1RAI.setStatus('current')
if mibBuilder.loadTexts: prtT1E1RAI.setDescription('Remote Alarm Signal')
prtT1E1LineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("csu", 2), ("dsu", 3), ("ltu", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineMode.setStatus('current')
if mibBuilder.loadTexts: prtT1E1LineMode.setDescription('Interface type of the port. For T1 - csu, dsu are the valid values For E1 - dsu, ltu are the valid values')
prtT1E1TS0SaBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 26), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1TS0SaBits.setStatus('current')
if mibBuilder.loadTexts: prtT1E1TS0SaBits.setDescription('This object is applicable only for E1 ports. For T1, string size will be 0. For E1, it enables user to select the use of TS0 Sa Bits 4..8, by 3 octets: The order (in hexa display): free Sa-Bit-4 Sa-Bit-5 Sa-Bit-6 Sa-Bit-7 Sa-Bit-8 |___________| |________________| |________________| MSByte LSByte Each Sa Bit will be represented by a nibble, having the following meaning: 0000 = zero 0001 = one 0010 = management 0011 = transparent the rest are reserved for future use.')
prtT1E1ConnectedTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1ConnectedTS.setStatus('current')
if mibBuilder.loadTexts: prtT1E1ConnectedTS.setDescription('This parameter indicates if there is any connected TS for this interface.')
prtT1E1Ts0SaBit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("noMng", 2), ("mng", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Ts0SaBit.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Ts0SaBit.setDescription("This parameter indicates whether to send TS 0, or not. noMng= TS 0 is looped, therefore not sent. mng= TS 0 isn't looped, therefore it is sent.")
prtT1E1SameFeCnfg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1SameFeCnfg.setStatus('current')
if mibBuilder.loadTexts: prtT1E1SameFeCnfg.setDescription('This parameter indicates whether the same E1 configuration parameters and TS assignment are set both to the local and remote device. Read-Write access is applicable only in G732N framed mode. For G732S and UNFRAMED this parameter is set by agent to YES and is Read Only. In Case of conflict during power-up between the central and remote, the value set by the central unit is the valid one.')
prtT1E1RemCrc4 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1RemCrc4.setStatus('current')
if mibBuilder.loadTexts: prtT1E1RemCrc4.setDescription('This object indicates whether the E1 of the Remote device connected to this E1 port, will have CRC-4 or not.')
prtT1E1MaxTSs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1MaxTSs.setStatus('current')
if mibBuilder.loadTexts: prtT1E1MaxTSs.setDescription('This object is applicable only for DXC D4T1, D4E1, D8T1, D8E1 external ports and D8GSL internal E1 ports. It is relevant only when sysCIntTsAllocMode=static(2). 255=not applicable If prtT1E1LineType=unframed(8), the value of this object must be 32. Else, the valid values are 0..31.')
prtT1E1EocTsConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1EocTsConfig.setStatus('current')
if mibBuilder.loadTexts: prtT1E1EocTsConfig.setDescription('This object indicates whether the use of EOC for TS Configuration is enabled or not.')
prtT1E1Role = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("sub", 2), ("main", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Role.setStatus('current')
if mibBuilder.loadTexts: prtT1E1Role.setDescription('This object indicates whether this port behaves as SUB or Main link.')
prtT1E1PppEchoFailDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1PppEchoFailDetection.setStatus('current')
if mibBuilder.loadTexts: prtT1E1PppEchoFailDetection.setDescription('This object indicates whether the PPP Echo is taken into account for its Fail Detection. This object is relevant when Inband Mng between devices is Dedicated TS PPP. Default=Disable. Enable - will be selected mainly when a T1/E1 Ring exists and between 2 adjacent Ring devices there is another device or Net, that causes these Ring devices not to sense that the PPP connection between them is lost. In this case, Echo Request should be initiated by the port.')
prtT1E1FdlMsgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3), )
if mibBuilder.loadTexts: prtT1E1FdlMsgTable.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsgTable.setDescription("This table is applicable for a T1 interface with 'esf' LineType or E1 interface, when CRC is enabled (LineType).")
prtT1E1FdlMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "prtT1E1FdlMsgPrtIdx"), (0, "RAD-MIB", "prtT1E1FdlMsgFdlType"))
if mibBuilder.loadTexts: prtT1E1FdlMsgEntry.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsgEntry.setDescription('An entry in table.')
prtT1E1FdlMsgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsgPrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 .')
prtT1E1FdlMsgFdlType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("receive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgFdlType.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsgFdlType.setDescription('The Fdl type reference of the Fdl message.')
prtT1E1FdlMsgSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgSlt.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsgSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1FdlMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsg.setStatus('current')
if mibBuilder.loadTexts: prtT1E1FdlMsg.setDescription('FDL message.')
prtHSParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1), )
if mibBuilder.loadTexts: prtHSParamTable.setStatus('current')
if mibBuilder.loadTexts: prtHSParamTable.setDescription('A table.')
prtHSParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtHSCnfgIdx"), (0, "RAD-MIB", "prtHSPrtIdx"))
if mibBuilder.loadTexts: prtHSParamEntry.setStatus('current')
if mibBuilder.loadTexts: prtHSParamEntry.setDescription('An entry in table.')
prtHSCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtHSCnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtHSPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtHSPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The inside ports will be the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtHSSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSSlt.setStatus('current')
if mibBuilder.loadTexts: prtHSSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtHSRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 200))).clone(namedValues=NamedValues(("r0x56eq0Kbps", 1), ("r1x56eq56Kbps", 2), ("r2x56eq112Kbps", 3), ("r3x56eq168Kbps", 4), ("r4x56eq224Kbps", 5), ("r5x56eq280Kbps", 6), ("r6x56eq336Kbps", 7), ("r7x56eq392Kbps", 8), ("r8x56eq448Kbps", 9), ("r9x56eq504Kbps", 10), ("r10x56eq560Kbps", 11), ("r11x56eq616Kbps", 12), ("r12x56eq672Kbps", 13), ("r13x56eq728Kbps", 14), ("r14x56eq784Kbps", 15), ("r15x56eq840Kbps", 16), ("r16x56eq896Kbps", 17), ("r17x56eq952Kbps", 18), ("r18x56eq1008Kbps", 19), ("r19x56eq1064Kbps", 20), ("r20x56eq1120Kbps", 21), ("r21x56eq1176Kbps", 22), ("r22x56eq1232Kbps", 23), ("r23x56eq1288Kbps", 24), ("r24x56eq1344Kbps", 25), ("r25x56eq1400Kbps", 26), ("r26x56eq1456Kbps", 27), ("r27x56eq1512Kbps", 28), ("r28x56eq1568Kbps", 29), ("r29x56eq1624Kbps", 30), ("r30x56eq1680Kbps", 31), ("r31x56eq1736Kbps", 32), ("r0x64eq0Kbps", 33), ("r1x64eq64Kbps", 34), ("r2x64eq128Kbps", 35), ("r3x64eq192Kbps", 36), ("r4x64eq256Kbps", 37), ("r5x64eq320Kbps", 38), ("r6x64eq384Kbps", 39), ("r7x64eq448Kbps", 40), ("r8x64eq512Kbps", 41), ("r9x64eq576Kbps", 42), ("r10x64eq640Kbps", 43), ("r11x64eq704Kbps", 44), ("r12x64eq768Kbps", 45), ("r13x64eq832Kbps", 46), ("r14x64eq896Kbps", 47), ("r15x64eq960Kbps", 48), ("r16x64eq1024Kbps", 49), ("r17x64eq1088Kbps", 50), ("r18x64eq1152Kbps", 51), ("r19x64eq1216Kbps", 52), ("r20x64eq1280Kbps", 53), ("r21x64eq1344Kbps", 54), ("r22x64eq1408Kbps", 55), ("r23x64eq1472Kbps", 56), ("r24x64eq1536Kbps", 57), ("r25x64eq1600Kbps", 58), ("r26x64eq1664Kbps", 59), ("r27x64eq1728Kbps", 60), ("r28x64eq1792Kbps", 61), ("r29x64eq1856Kbps", 62), ("r30x64eq1920Kbps", 63), ("r31x64eq1984Kbps", 64), ("r32x64eq2048Kbps", 65), ("r32x56eq1792Kbps", 66), ("r64x64eq4096Kbps", 67), ("auto", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSRate.setStatus('current')
if mibBuilder.loadTexts: prtHSRate.setDescription('This object indicates the port rate (speed). auto - rate is selected automatically by system.')
prtHSFifoSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("auto", 1), ("b32bit", 2), ("b60bit", 3), ("b104bit", 4), ("b144bit", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSFifoSize.setStatus('current')
if mibBuilder.loadTexts: prtHSFifoSize.setDescription('This object selects the size of the user data channel buffer FIFO used in the DTE2 mode. In the other modes, buffer size is automatically set by the DACS agent. Buffer FIFO size in bits, corresponds to FIFO lengths of +/-16, +/-30, +/-52, +/-72 bits.')
prtHSClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dce", 1), ("dte1", 2), ("dte2", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSClkMode.setStatus('current')
if mibBuilder.loadTexts: prtHSClkMode.setDescription('Clock Mode of the user data channel. dce - DACS operates as a DCE and provides transmit and receive clocks to the synchronous user DTE. dte1- DACS supplies the receive clock to the user equipment and accepts the user transmit clock. dte2- DACS requires transmit and receive clocks from the user equipment.')
prtHSCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("rts", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSCTS.setStatus('current')
if mibBuilder.loadTexts: prtHSCTS.setDescription('Selection of CTS line state in the user data channel. on - CTS continuously ON. rts - CTS line follows the RTS line.')
prtHSRtsState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSRtsState.setStatus('current')
if mibBuilder.loadTexts: prtHSRtsState.setDescription('RTS state of the port.')
prtHSInbandLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSInbandLoopback.setStatus('current')
if mibBuilder.loadTexts: prtHSInbandLoopback.setDescription('This object indicates if Inband Loopback from the Network should be enabled or disabled.')
prtHSInbandLoopPatternCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("rdlLoop", 2), ("userConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSInbandLoopPatternCfg.setStatus('current')
if mibBuilder.loadTexts: prtHSInbandLoopPatternCfg.setDescription('This object indicates if Inband Loop polynomial pattern will be according to RDL Loop (the standard) or User Configurated according to prtHSActivatePolyPattern and prtHSDeactivatePolyPattern.')
prtHSInbandLoopActPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSInbandLoopActPattern.setStatus('current')
if mibBuilder.loadTexts: prtHSInbandLoopActPattern.setDescription("This object is a binary string of up to 8 bits. Though the syntax allows for any ASCII characters, for this object only '0' or '1' characters are valid. The string determines coefficients of the polynomial pattern sent to the port in order to Activate the Inband Loop. This object is relevant only when prtHSInbandLoopPatternCfg=userConfig.")
prtHSInbandLoopDeactPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSInbandLoopDeactPattern.setStatus('current')
if mibBuilder.loadTexts: prtHSInbandLoopDeactPattern.setDescription("This object is a binary string of up to 8 bits. Though the syntax allows for any ASCII characters, for this object only '0' or '1' characters are valid. The string determines coefficients of the polynomial pattern sent to the port in order to Deactivate the Inband Loop. This object is relevant only when prtHSInbandLoopPatternCfg=userConfig.")
prtHSDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("linkOK", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSDCD.setStatus('current')
if mibBuilder.loadTexts: prtHSDCD.setDescription('Selection of DCD line state in the user data channel. linkOK - DCD line is ON only when active link is OK. on - DCD continuously ON.')
prtHSClkPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("invert", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSClkPolarity.setStatus('current')
if mibBuilder.loadTexts: prtHSClkPolarity.setDescription('This object indicates the clock polarity.')
prtHSInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("rs530", 2), ("v35", 3), ("rs422", 4), ("x21", 5), ("v24", 6), ("rs530a", 7), ("rs232", 8), ("rs449", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSInterfaceType.setStatus('current')
if mibBuilder.loadTexts: prtHSInterfaceType.setDescription('This object indicates the selected electrical interface type.')
prtHSUnframed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSUnframed.setStatus('current')
if mibBuilder.loadTexts: prtHSUnframed.setDescription('Unframed line for HS ports. yes - means that all TSs must be transferred, including TS0. In this case, prtHSRate must be r31x56eq1736Kbps OR r31x64eq1984Kbps.')
prtHSBertTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2), )
if mibBuilder.loadTexts: prtHSBertTable.setStatus('current')
if mibBuilder.loadTexts: prtHSBertTable.setDescription('A table.')
prtHSBertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtHSBertPrtIdx"))
if mibBuilder.loadTexts: prtHSBertEntry.setStatus('current')
if mibBuilder.loadTexts: prtHSBertEntry.setDescription('An entry in table.')
prtHSBertPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtHSBertPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The inside ports will be the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtHSBertSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertSlt.setStatus('current')
if mibBuilder.loadTexts: prtHSBertSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtHSBertCountClr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSBertCountClr.setStatus('current')
if mibBuilder.loadTexts: prtHSBertCountClr.setDescription('Setting this object (to on) initiate bert counter clear operation. Valid only when bert test is active on the specific port. (Every time a new bert test starts, the counter is automatically cleared; this command enables clearing the counter while the test is running).')
prtHSBertTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertTestResult.setStatus('current')
if mibBuilder.loadTexts: prtHSBertTestResult.setDescription('This object indicates the number of Bit Error Rate indicated during the BERT test. Active only when bert test is running on the selected port.')
prtSpCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1), )
if mibBuilder.loadTexts: prtSpCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtSpCnfgTable.setDescription('A table.')
prtSpCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtSpCnfgIdx"), (0, "RAD-MIB", "prtSpPrtIdx"))
if mibBuilder.loadTexts: prtSpCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtSpCnfgEntry.setDescription('All the entries at this table are identical(have the same value) at all the configurations(1..255) except at the TmpCnfg. - For products supporting more than one configuration, the write operation into the Table Objects is valid only at the TmpCnfg entry. - For products that do not support configurations, the write operation into the Table Objects will be to prtSpCnfgIdx=1.')
prtSpCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSpCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtSpCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtSpPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSpPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtSpPrtIdx.setDescription('This attribute indicates a unique port number of the SPor DP port. For DXC, it is the port in the active DCL card: - SP = 1 - NP ; DP = 2 For Kilomux, the port index is calculated as follows: 100*Slot+Ch. For FCD, PRBi, the SP port index=1. For Optimux-T3, the SP port index=71.')
prtSpUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("nmsSlip", 3), ("nmsPpp", 4), ("muxSlip", 5), ("muxPpp", 6), ("terminal", 7), ("dialOut", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpUsage.setStatus('current')
if mibBuilder.loadTexts: prtSpUsage.setDescription('This attribute indicates what is the usage of the port.')
prtSpRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("auto", 1), ("s300bps", 2), ("s1200bps", 3), ("s2400bps", 4), ("s4800bps", 5), ("s9600bps", 6), ("s19200bps", 7), ("s38400bps", 8), ("s57600bps", 9), ("s115200bps", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpRate.setStatus('current')
if mibBuilder.loadTexts: prtSpRate.setDescription('This attribute indicates the operation rate (speed) of the port. auto - automatic rate selection, by the agent.')
prtSpDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7", 1), ("dataBits8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDataBits.setStatus('current')
if mibBuilder.loadTexts: prtSpDataBits.setDescription('This attribute indicates the number of data bits in async frame')
prtSpParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpParity.setStatus('current')
if mibBuilder.loadTexts: prtSpParity.setDescription('This attribute indicates the parity mode in async frame')
prtSpCallOutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("all", 3), ("major", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCallOutMode.setStatus('current')
if mibBuilder.loadTexts: prtSpCallOutMode.setDescription('This attribute indicates the call-out mode. For DXC - this object is applicable only for the DP port (2).')
prtSpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpInterface.setStatus('current')
if mibBuilder.loadTexts: prtSpInterface.setDescription('This attribute indicates the supervisory port interface. dce - the DACS appears as a DCE for the port. dte - the DACS operates as a DTE, for connection via modem, for the port.')
prtSpCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCTS.setStatus('current')
if mibBuilder.loadTexts: prtSpCTS.setDescription('CTS line state. This object is applicable only for port (1) = SP')
prtSpDcdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("d0", 2), ("d10", 3), ("d50", 4), ("d100", 5), ("d200", 6), ("d300", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDcdDelay.setStatus('current')
if mibBuilder.loadTexts: prtSpDcdDelay.setDescription('DCD delay in msec. d10 = delay of 10msec. This object is applicable only for port (1) = SP')
prtSpDsr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("dtr", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDsr.setStatus('current')
if mibBuilder.loadTexts: prtSpDsr.setDescription('DSR line state. This object is applicable only for port (1) = SP')
prtSpNoOfRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpNoOfRetries.setStatus('current')
if mibBuilder.loadTexts: prtSpNoOfRetries.setDescription('For DXC - this object is applicable only for port (2) = DP. The number of dialing retries requested. Default = 0')
prtSpWaitForConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("t30sec", 2), ("t45sec", 3), ("t60sec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpWaitForConnect.setStatus('current')
if mibBuilder.loadTexts: prtSpWaitForConnect.setDescription('For DXC - this object is applicable only for port (2) = DP. Waiting time for connect, in seconds. Default = 30 sec.')
prtSpDialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("tone", 2), ("pulse", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDialMode.setStatus('current')
if mibBuilder.loadTexts: prtSpDialMode.setDescription('For DXC - this object is applicable only for port (2) = DP. Dialing mode. Default=tone')
prtSpAltNumMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAltNumMode.setStatus('current')
if mibBuilder.loadTexts: prtSpAltNumMode.setDescription('For DXC - this object is applicable only for port (2) = DP. It determines wether to use the alternate number or not. Default = no.')
prtSpPrimaryNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpPrimaryNum.setStatus('current')
if mibBuilder.loadTexts: prtSpPrimaryNum.setDescription('For DXC - this object is applicable only for port (2) = DP. It is the Primary dialing number. ')
prtSpAltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAltNum.setStatus('current')
if mibBuilder.loadTexts: prtSpAltNum.setDescription("For DXC - this object is applicable only for port (2) = DP. It is the Alternate dialing number. This number is applicable only if prtSpAltNumMode is 'yes'.")
prtSpRoutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpRoutProtocol.setStatus('current')
if mibBuilder.loadTexts: prtSpRoutProtocol.setDescription('This attribute indicates the routing protocol of the port. notApplicable - for DP.')
prtSpCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCmd.setStatus('current')
if mibBuilder.loadTexts: prtSpCmd.setDescription("SP Command. For LRS this parameter will be used for a Modem Command. Upon NMS's Get operation for devices that this parameter is notApplicable, agent will send NULL string.")
prtSpActCallOut = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("always", 2), ("linkFail", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpActCallOut.setStatus('current')
if mibBuilder.loadTexts: prtSpActCallOut.setDescription('This object indicates when to Activate Call-Out. It is used by FCD-T1/E1. always - to activate call-out always. linkFail - to activate call-out only when Link of Inband Management fails.')
prtSpAlrRelayMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("invert", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAlrRelayMode.setStatus('current')
if mibBuilder.loadTexts: prtSpAlrRelayMode.setDescription('This attribute indicates the Alarm Relay Mode. notApplicable - for DP.')
prtSpStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("stopBits1", 2), ("stopBits1dot5", 3), ("stopBits2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpStopBits.setStatus('current')
if mibBuilder.loadTexts: prtSpStopBits.setDescription('This attribute indicates number of stop bits in an async frame.')
prtDimCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1), )
if mibBuilder.loadTexts: prtDimCnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtDimCnfgTable.setDescription('A table.')
prtDimCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtDimCnfgIdx"), (0, "RAD-MIB", "prtDimIdx"))
if mibBuilder.loadTexts: prtDimCnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtDimCnfgEntry.setDescription('The write operation into the Table Objects is valid only for the TmpCnfg entry (prtDimCnfgIdx=255).')
prtDimCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDimCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtDimCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtDimIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDimIdx.setStatus('current')
if mibBuilder.loadTexts: prtDimIdx.setDescription('This attribute indicates a unique port number of the DIM card. The convention used for DXC: (IO slot number+10)*10 + 1 Example: port1 of IO slot 11 will be: 211 .')
prtDimTxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("regularTx", 2), ("broadcast", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimTxMode.setStatus('current')
if mibBuilder.loadTexts: prtDimTxMode.setDescription('Tx mode. regularTx - the links are connected to a similar outfit on the other side. In this mode, if a link fails, the transmitted bandwidth is decreased accordingly. broadcast - the links are connected to MORE than one similar outfit on the other side. In this mode, if a link fails, the transmitted bandwidth is not affected ')
prtDimPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normalClk", 2), ("inverted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimPolarity.setStatus('current')
if mibBuilder.loadTexts: prtDimPolarity.setDescription('Polarity.')
prtDimClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("extDce", 2), ("dce", 3), ("smooth", 4), ("extSmooth", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimClkMode.setStatus('current')
if mibBuilder.loadTexts: prtDimClkMode.setDescription("Clock Mode. smooth - a clock that is not 'pulsed'(has no 'gaps'). In this mode the DXC does NOT receive back the clock signal. extSmooth - same as 'smooth' but in this mode, the DXC receives back the clock signal.")
prtDimMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("t16msec", 2), ("t64msec", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimMaxDelay.setStatus('current')
if mibBuilder.loadTexts: prtDimMaxDelay.setDescription('Max Delay permitted between the links, in msec.')
prtDimMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disabled", 2), ("ts1", 3), ("dedicatedFr", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimMng.setStatus('current')
if mibBuilder.loadTexts: prtDimMng.setDescription('Use of DIM port for management. disabled - no management on DIM ts1 - 1 bit of TS1 is used for management.')
prtDimMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimMngRoutProt.setStatus('current')
if mibBuilder.loadTexts: prtDimMngRoutProt.setDescription("Mng Routing Protocol of the port. none - when prtDimMng is 'disabled'.")
prtDimDestTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2), )
if mibBuilder.loadTexts: prtDimDestTable.setStatus('current')
if mibBuilder.loadTexts: prtDimDestTable.setDescription('A table.')
prtDimDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtDestCnfgIdx"), (0, "RAD-MIB", "prtDestDimIdx"), (0, "RAD-MIB", "prtDestIdx"))
if mibBuilder.loadTexts: prtDimDestEntry.setStatus('current')
if mibBuilder.loadTexts: prtDimDestEntry.setDescription('The write operation is valid only for the TmpCnfg entry (prtDimDestCnfgIdx=255).')
prtDestCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtDestCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtDestDimIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestDimIdx.setStatus('current')
if mibBuilder.loadTexts: prtDestDimIdx.setDescription('This attribute indicates a unique port number of the DIM card. The convention used for DXC: (IO slot number+10) & 1 Example: port1 of IO slot 11 will be: 211 .')
prtDestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestIdx.setStatus('current')
if mibBuilder.loadTexts: prtDestIdx.setDescription('This attribute indicates a destination number of the DIM card. ')
prtDest = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDest.setStatus('current')
if mibBuilder.loadTexts: prtDest.setDescription('Destination port,(of a T1/E1 port), that is connected to the DIM card, for the specified Destination number. 0 = No destination port. Else: For external ports: (IO Slot+10) & 1 for port 1 (IO Slot+10) & 3 for port 2 Example: port2 of IO slot 12 will be: 223 . For internal ports : (IO Slot+10) & 2 for port 1 (IO Slot+10) & 4 for port 2 (IO Slot+10) & 6 for port 3 (IO Slot+10) & 8 for port 4, etc...')
prtDestConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestConnect.setStatus('current')
if mibBuilder.loadTexts: prtDestConnect.setDescription('Connection Status of the specified destination number. For a specified destination port, it depends both on the status of the port and on the status of the far-end port. Since this is a RO object, same value will be received for all configurations.')
prtICnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1), )
if mibBuilder.loadTexts: prtICnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtICnfgTable.setDescription('A table.')
prtICnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtICnfgIdx"), (0, "RAD-MIB", "prtIIdx"))
if mibBuilder.loadTexts: prtICnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtICnfgEntry.setDescription('An entry in table.')
prtICnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtICnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtICnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtIIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIIdx.setStatus('current')
if mibBuilder.loadTexts: prtIIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The ISDN B1, B2, D channels will be inside ports. For port index, see product specification.')
prtIRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("nc", 2), ("r2bit", 3), ("r4bit", 4), ("r8bit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIRate.setStatus('current')
if mibBuilder.loadTexts: prtIRate.setDescription('This object indicates the port rate in bits. Each TS contains 8 bits. Thus, 1 bit is equivalent to 8Kbps rate.')
prtIConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIConnect.setStatus('current')
if mibBuilder.loadTexts: prtIConnect.setDescription('D channel connection. no - disconnected yes - connected. ')
prtHdslTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1), )
if mibBuilder.loadTexts: prtHdslTable.setStatus('current')
if mibBuilder.loadTexts: prtHdslTable.setDescription('HDSL port table.')
prtHdslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtHdslIdx"))
if mibBuilder.loadTexts: prtHdslEntry.setStatus('current')
if mibBuilder.loadTexts: prtHdslEntry.setDescription('An entry in table.')
prtHdslIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslIdx.setStatus('current')
if mibBuilder.loadTexts: prtHdslIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The HDSL ports will be external. For port index, see product specification.')
prtHdslMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("central", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHdslMode.setStatus('current')
if mibBuilder.loadTexts: prtHdslMode.setDescription('This object indicates the HDSL mode.')
prtHdslRptrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("hrpt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslRptrType.setStatus('current')
if mibBuilder.loadTexts: prtHdslRptrType.setDescription('The Repeater between Near and Far modem. none - no repeater exists between the modems hrpt - HRPT repeater exists between the modems.')
prtHdslMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("notApplicable", 1), ("r192", 2), ("r256", 3), ("r320", 4), ("r384", 5), ("r448", 6), ("r512", 7), ("r576", 8), ("r640", 9), ("r768", 10), ("r896", 11), ("r1024", 12), ("r1152", 13), ("r1280", 14), ("r1536", 15), ("r1920", 16), ("r2048", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHdslMaxRate.setStatus('current')
if mibBuilder.loadTexts: prtHdslMaxRate.setDescription('Maximum Rate of the xDSL Line, in Kbps units. This object can be Set only for a Central unit.')
prtHdslLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("msdsl2w", 2), ("hdsl2w", 3), ("hdsl4w", 4), ("gDsl", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslLinkType.setStatus('current')
if mibBuilder.loadTexts: prtHdslLinkType.setDescription('The Link Type. msdsl2w - MSDSL 2 Wire hdsl2w - HDSL 2 Wire hdsl4w - HDSL 4 Wire gDsl - G.DSL ')
prtHdslCompSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslCompSwVer.setStatus('current')
if mibBuilder.loadTexts: prtHdslCompSwVer.setDescription('This object indicates the Software Version of the component (Piggyback card) supporting this interface.')
prtHdslCompHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslCompHwVer.setStatus('current')
if mibBuilder.loadTexts: prtHdslCompHwVer.setDescription('This object indicates the Hardware Version of the component (Piggyback card) supporting this interface.')
prtT3E3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1), )
if mibBuilder.loadTexts: prtT3E3CnfgTable.setStatus('current')
if mibBuilder.loadTexts: prtT3E3CnfgTable.setDescription('T3/E3 port configuration table.')
prtT3E3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtT3E3CnfgIdx"), (0, "RAD-MIB", "prtT3E3PrtIdx"))
if mibBuilder.loadTexts: prtT3E3CnfgEntry.setStatus('current')
if mibBuilder.loadTexts: prtT3E3CnfgEntry.setDescription(' An entry in the T3/E3 port configuration table.')
prtT3E3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3CnfgIdx.setStatus('current')
if mibBuilder.loadTexts: prtT3E3CnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. For DXC, write operations can be performed only on the Temp Config. For products that do not support configurations, always 1 will be used.')
prtT3E3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3PrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtT3E3PrtIdx.setDescription('This attribute indicates a unique port number. For DXC: The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The external ports convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For Optimux-T3: Link-A: 51 Link-B: 61 . ')
prtT3E3Slt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3Slt.setStatus('current')
if mibBuilder.loadTexts: prtT3E3Slt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT3E3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("len0p450ft", 2), ("len451p900ft", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3LineLength.setStatus('current')
if mibBuilder.loadTexts: prtT3E3LineLength.setDescription('This object is the length of the ds3 line in feet. It provides information for line build out circuitry if it exists and can use this object to adjust the line build out. len0p450ft = 0 - 450 feet len451p900ft = 451 - 900 feet.')
prtT3E3InbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("cBit", 3), ("cBitTxRxMng", 4), ("cBitTx", 5), ("cBitTxMng", 6), ("m13", 7), ("cdpv", 8), ("nationalBit", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3InbandMng.setStatus('current')
if mibBuilder.loadTexts: prtT3E3InbandMng.setDescription('A unique number to identify the Frame Type over the link. For Optimux-T3: only values (4), (7) are supported.')
prtT3E3AisFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unframed", 2), ("framed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3AisFrame.setStatus('current')
if mibBuilder.loadTexts: prtT3E3AisFrame.setDescription('This object is applicable only for Optimux-T3. It allows user to select whether the AIS sent will be framed or unframed.')
prtT3E3TxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3TxClockSource.setStatus('current')
if mibBuilder.loadTexts: prtT3E3TxClockSource.setDescription('Tx Clock Source.')
prtT3E3RoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3RoutProt.setStatus('current')
if mibBuilder.loadTexts: prtT3E3RoutProt.setDescription('Routing Protocol of the port. This object is applicable only for T3 ports.')
prtT3E3AisTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3AisTransmit.setStatus('current')
if mibBuilder.loadTexts: prtT3E3AisTransmit.setDescription('Indicates if AIS signal will be transmitted over the tributary E3/DS3 upon failure.')
cmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1), )
if mibBuilder.loadTexts: cmprTable.setStatus('current')
if mibBuilder.loadTexts: cmprTable.setDescription('A table.')
cmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "cmprTypeIdx"), (0, "RAD-MIB", "cmprCnfgIdx"), (0, "RAD-MIB", "cmprVersion"), (0, "RAD-MIB", "cmprSltIdx"), (0, "RAD-MIB", "cmprPrtIdx"))
if mibBuilder.loadTexts: cmprEntry.setStatus('current')
if mibBuilder.loadTexts: cmprEntry.setDescription('An entry in table.')
cmprTypeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprTypeIdx.setStatus('current')
if mibBuilder.loadTexts: cmprTypeIdx.setDescription('This object indicates the Type of the Compressed data referred (which table, which level, etc). The type is a code according to a convention between agent and NMS.')
cmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: cmprCnfgIdx.setDescription('This object indicates the configuration number the Compressed information relates to.')
cmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprVersion.setStatus('current')
if mibBuilder.loadTexts: cmprVersion.setDescription('This object indicates the version of the internal format of the Compressed data (the version of the convention used).')
cmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprSltIdx.setStatus('current')
if mibBuilder.loadTexts: cmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. When the unit is stand-alone or this object is not applicable, 255 will be used.')
cmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprPrtIdx.setStatus('current')
if mibBuilder.loadTexts: cmprPrtIdx.setDescription("This object indicates a unique identifier of the port, the compressed information relates to. For DXC - according to the order in the card of cmprSltIdx: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For FCD: see product's specification. If the port number is irrelevant to this parameter (if it is a system/card level alarm) the value will be 9999.")
cmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmprObj.setStatus('current')
if mibBuilder.loadTexts: cmprObj.setDescription('This object is the compressed information itself, according to a predefined format, both agent and NMS agreed about.')
mapLinkTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2), )
if mibBuilder.loadTexts: mapLinkTable.setStatus('current')
if mibBuilder.loadTexts: mapLinkTable.setDescription('A table.')
mapLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "mapLinkIdx"))
if mibBuilder.loadTexts: mapLinkEntry.setStatus('current')
if mibBuilder.loadTexts: mapLinkEntry.setDescription('An entry in table.')
mapLinkIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkIdx.setStatus('current')
if mibBuilder.loadTexts: mapLinkIdx.setDescription('A unique identifier of the link')
mapLinkSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkSlotIdx.setStatus('current')
if mibBuilder.loadTexts: mapLinkSlotIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
mapLinkPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkPortIdx.setStatus('current')
if mibBuilder.loadTexts: mapLinkPortIdx.setDescription('This attribute indicates a unique port number. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
mapLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkState.setStatus('current')
if mibBuilder.loadTexts: mapLinkState.setDescription('This attribute indicates the status of the link between the two muxes')
alrGenTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3), )
if mibBuilder.loadTexts: alrGenTable.setStatus('current')
if mibBuilder.loadTexts: alrGenTable.setDescription('A table.')
alrGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1), ).setIndexNames((0, "RAD-MIB", "alrGenCode"))
if mibBuilder.loadTexts: alrGenEntry.setStatus('current')
if mibBuilder.loadTexts: alrGenEntry.setDescription('An entry in table.')
alrGenCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenCode.setStatus('current')
if mibBuilder.loadTexts: alrGenCode.setDescription('This object is a unique code number, identifying a certain alarm.')
alrGenDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenDescription.setStatus('current')
if mibBuilder.loadTexts: alrGenDescription.setDescription('This entry is a unique text description, of the alarm corresponding to the specified code.')
alrGenLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("system", 2), ("card", 3), ("port", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenLevel.setStatus('current')
if mibBuilder.loadTexts: alrGenLevel.setDescription('Alarm level.')
alrGenSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("ps", 2), ("cl", 3), ("io", 4), ("clAndIo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenSlotType.setStatus('current')
if mibBuilder.loadTexts: alrGenSlotType.setDescription('Slot type that the alarm is relevant to. clAndIo - an alarm that is relevant for both CL and IO slots.')
alrGenSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alrGenSeverity.setStatus('current')
if mibBuilder.loadTexts: alrGenSeverity.setDescription('This object enables the user to select a severity for each alarm. The severity is set per alarm code (same for all slots/ports using this code).')
alrGenDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alrGenDebounce.setStatus('current')
if mibBuilder.loadTexts: alrGenDebounce.setDescription("Debounce time for each alarm code, in seconds. The meaning is, that an alarm will be 'declared' as ON (or OFF), only after it was actually ON/OFF the Debouncing time selected by user. 0 = default debounce selection (each alarm has a default value). 250 = maximum value of seconds for debounce. 253 = mask = the alarm will Never be reported. 254 = default debounce selection (each alarm has a default value). 255 = not applicable ")
alrGenDefSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenDefSeverity.setStatus('current')
if mibBuilder.loadTexts: alrGenDefSeverity.setDescription('This object reports the default severity of each alarm. User can change the severity of the alarms defined by this default via the alrGenSeverity object.')
dacsMuxEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 3, 3, 0))
if mibBuilder.loadTexts: dacsMuxEvents.setStatus('current')
if mibBuilder.loadTexts: dacsMuxEvents.setDescription('The events for DACS MUX.')
sanityCheckTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 1)).setObjects(("RAD-MIB", "sysSSanityCheckStatus"), ("RAD-MIB", "sysDbaseDownloadCnfgIdxCmd"))
if mibBuilder.loadTexts: sanityCheckTrap.setStatus('current')
if mibBuilder.loadTexts: sanityCheckTrap.setDescription('This trap is sent after a data base download attempt. It returns the sanity result status and the configuration no.checked.')
dacsMuxAlarmsTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 2))
if mibBuilder.loadTexts: dacsMuxAlarmsTrap.setStatus('current')
if mibBuilder.loadTexts: dacsMuxAlarmsTrap.setDescription('This trap is sent when an alarm occurs.')
mdlConnectTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 3)).setObjects(("RAD-MIB", "mdlSCardType"), ("RAD-MIB", "mdlSActivity"))
if mibBuilder.loadTexts: mdlConnectTrap.setStatus('current')
if mibBuilder.loadTexts: mdlConnectTrap.setDescription('This trap is sent when a card is removed.')
sysAlrStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 4)).setObjects(("RAD-MIB", "sysSAlrStatusAll"), ("RAD-MIB", "sysSAlrStatus"))
if mibBuilder.loadTexts: sysAlrStatusTrap.setStatus('current')
if mibBuilder.loadTexts: sysAlrStatusTrap.setDescription('This trap is sent upon any change in the value of any of the variables.')
sysStatusChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 5)).setObjects(("RAD-MIB", "agnLed"))
if mibBuilder.loadTexts: sysStatusChangedTrap.setStatus('current')
if mibBuilder.loadTexts: sysStatusChangedTrap.setDescription('This trap is sent when Leds status is changed.')
cnfgUpdateTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 6))
if mibBuilder.loadTexts: cnfgUpdateTrap.setStatus('current')
if mibBuilder.loadTexts: cnfgUpdateTrap.setDescription('This trap is sent upon change of the active Configuration DB.')
sysRedundancyStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 7)).setObjects(("RAD-MIB", "sysDclRedundancyStatus"))
if mibBuilder.loadTexts: sysRedundancyStatusTrap.setStatus('current')
if mibBuilder.loadTexts: sysRedundancyStatusTrap.setDescription('The trap is sent upon change in Redundancy Status.')
sysRedundancyActiveCardTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 8)).setObjects(("RAD-MIB", "sysDclOnline"))
if mibBuilder.loadTexts: sysRedundancyActiveCardTrap.setStatus('current')
if mibBuilder.loadTexts: sysRedundancyActiveCardTrap.setDescription('The trap is sent upon change of Active Main/CL Card.')
sysRedundancyActivePortTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3, 0, 9)).setObjects(("RAD-MIB", "sysCRdnOnline"))
if mibBuilder.loadTexts: sysRedundancyActivePortTrap.setStatus('current')
if mibBuilder.loadTexts: sysRedundancyActivePortTrap.setDescription('The trap is sent upon change of Active Port of Redundancy Group.')
services = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3))
wfq = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 1))
wfqTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1), )
if mibBuilder.loadTexts: wfqTable.setStatus('current')
if mibBuilder.loadTexts: wfqTable.setDescription('This table allows user to define several WFQ tables per output port. WFQ supports flows with different bandwidth requirements by giving each queue a weight that assigns it a different percentage of output port bandwidth. When Weighted Fair Queuing is used, it is possible to precisely attribute bandwidth partitioning among the queues. When there is congestion, each class (queue) is not allowed to use more bandwidth than the amount allocated to it.')
wfqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "wfqCnfgIdx"), (0, "RAD-MIB", "wfqPrtIdx"), (0, "RAD-MIB", "wfqTblIdx"), (0, "RAD-MIB", "wfqQueueIdx"))
if mibBuilder.loadTexts: wfqEntry.setStatus('current')
if mibBuilder.loadTexts: wfqEntry.setDescription('An entry in the Weighted Fair Queueing table.')
wfqCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: wfqCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: wfqCnfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer. 255=Temporary Cnfg (when relevant, Set is done only to this configuration). For Agents that support only one configuration, this object will be constant=1. ')
wfqPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: wfqPrtIdx.setStatus('current')
if mibBuilder.loadTexts: wfqPrtIdx.setDescription("This object indicates a unique port or interface number, for which Weighted Fair Queueing table is applicable . For numbering, see product's spec. For some products, the numbering can equal ifIndex. Value of 255 (not applicable) refer to system level queue")
wfqTblIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: wfqTblIdx.setStatus('current')
if mibBuilder.loadTexts: wfqTblIdx.setDescription('This object indicates which Weighted Fair Queueing (WFQ) Table is being used. There can be several tables. For FCD-155 User will select which one will be used for a virtual concatenation group.Valid values are 1,2')
wfqQueueIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 4), Integer32())
if mibBuilder.loadTexts: wfqQueueIdx.setStatus('current')
if mibBuilder.loadTexts: wfqQueueIdx.setDescription('This object indicates a queue index. For FCD-155, valid queues are 1..3. The 4th queue is not in MIB. Its weight will be RO, Calculated according to the sum of the 3 first queues.')
wfqRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wfqRowStatus.setStatus('current')
if mibBuilder.loadTexts: wfqRowStatus.setDescription('This object enables Creation/Deletion of rows in the WFQ table. For FCD-155, rows are not created nor destroyed by user.')
wfqWeightValue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('%').setMaxAccess("readcreate")
if mibBuilder.loadTexts: wfqWeightValue.setStatus('current')
if mibBuilder.loadTexts: wfqWeightValue.setDescription('This object indicates a relative weight value. User should make sure that the sum of values for all queues will not exceed 100% (sum should be BELOW 100% in order to leave some BW percentage for last queue) Note that when this attribute is being used, the wfqMinRateAbsolute attribute is NA.')
wfqSchedulingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wfqSchedulingMode.setStatus('current')
if mibBuilder.loadTexts: wfqSchedulingMode.setDescription('This object controls which scheduling mode is used: Weighted Fair Queuing (WFQ) scheme or priority Queue (Strict Priority).')
wfqMinRateAbsolute = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 8), Unsigned32()).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: wfqMinRateAbsolute.setStatus('current')
if mibBuilder.loadTexts: wfqMinRateAbsolute.setDescription('The minimum absolute rate, in kbps, that should be allocated to this queue. If the value is zero, then there is effectively no minimum rate guarantee. If the value is non-zero, then the servicing of this queue in at least this rate is assured. Note that when this attribute is being used, the wfqWeightValue attribute is NA.')
wfqMaxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 1, 1, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: wfqMaxPacketSize.setStatus('current')
if mibBuilder.loadTexts: wfqMaxPacketSize.setDescription('The size of the largest packet which can be received on this queue, specified in octets. Packets larger than this size will be discarded.')
class Dscp(TextualConvention, Integer32):
    reference = 'RFC 2474, RFC 2780'
    description = 'A Differentiated Services Code-Point that may be used for marking a traffic stream.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 63)

dscpMapping = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 2))
dscpMappingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 2, 1), )
if mibBuilder.loadTexts: dscpMappingTable.setStatus('current')
if mibBuilder.loadTexts: dscpMappingTable.setDescription('Mapping of DSCP value to a regenerated priority level.')
dscpMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "dscpMappingCnfgIdx"), (0, "RAD-MIB", "dscpMappingDscpIdx"))
if mibBuilder.loadTexts: dscpMappingEntry.setStatus('current')
if mibBuilder.loadTexts: dscpMappingEntry.setDescription('An entry in dscpMappingTable.')
dscpMappingCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: dscpMappingCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: dscpMappingCnfgIdx.setDescription('This object indicates the Idx of the Agent Cnfg the following objects refer to. 255=Temporary Cnfg (when relevant, Set is done only to this configuration). For Agents that support only one configuration, this object will be constant=1. This object can be used to carry additional indexing (e.g port index) when needed.')
dscpMappingDscpIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 2, 1, 1, 2), Dscp())
if mibBuilder.loadTexts: dscpMappingDscpIdx.setStatus('current')
if mibBuilder.loadTexts: dscpMappingDscpIdx.setDescription(' DSCP value of the incoming IP packet')
dscpMappingRegenPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dscpMappingRegenPriority.setStatus('current')
if mibBuilder.loadTexts: dscpMappingRegenPriority.setDescription('The Regenerated Priority level the incoming DSCP value is mapped to. For FCD-155, valid values are 0,1,2,3')
ifTeQos = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 3))
ifTeQosTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1), )
if mibBuilder.loadTexts: ifTeQosTable.setStatus('current')
if mibBuilder.loadTexts: ifTeQosTable.setDescription('The TE QOS Interface Table.')
ifTeQosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "ifTeQosIdx1"), (0, "RAD-MIB", "ifTeQosIdx2"), (0, "RAD-MIB", "ifTeQosIdx3"))
if mibBuilder.loadTexts: ifTeQosEntry.setStatus('current')
if mibBuilder.loadTexts: ifTeQosEntry.setDescription('An entry in the TE QOS Interface table.')
ifTeQosIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: ifTeQosIdx1.setStatus('current')
if mibBuilder.loadTexts: ifTeQosIdx1.setDescription('This object indicates the 1st Index of the table.')
ifTeQosIdx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: ifTeQosIdx2.setStatus('current')
if mibBuilder.loadTexts: ifTeQosIdx2.setDescription('This object indicates the 2nd Index of the table.')
ifTeQosIdx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: ifTeQosIdx3.setStatus('current')
if mibBuilder.loadTexts: ifTeQosIdx3.setDescription('This object indicates the 3rd Index of the table.')
ifTeQosParam = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTeQosParam.setStatus('current')
if mibBuilder.loadTexts: ifTeQosParam.setDescription("This object is used for QOS attributes of the entry's entities.")
ifTeQosParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTeQosParam2.setStatus('current')
if mibBuilder.loadTexts: ifTeQosParam2.setDescription("This object is used for 2nd group QOS attributes of the entry's entities.")
ifTeQosStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTeQosStatus.setStatus('current')
if mibBuilder.loadTexts: ifTeQosStatus.setDescription('This object is used to create, activate and destroy entries of this table.')
portQos = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 4))
prtPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1), )
if mibBuilder.loadTexts: prtPriorityTable.setStatus('current')
if mibBuilder.loadTexts: prtPriorityTable.setDescription('A table - Parameters per port per Priority .')
prtPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "prtPriorityIdx1"), (0, "RAD-MIB", "prtPriorityPrtIdx"), (0, "RAD-MIB", "prtPriorityIdx"))
if mibBuilder.loadTexts: prtPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: prtPriorityEntry.setDescription('An entry in table.')
prtPriorityIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: prtPriorityIdx1.setStatus('current')
if mibBuilder.loadTexts: prtPriorityIdx1.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg. or any other Index.')
prtPriorityPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: prtPriorityPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtPriorityPrtIdx.setDescription('This object indicates a unique Port Index. Refer to device specification for port Index.')
prtPriorityIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: prtPriorityIdx.setStatus('current')
if mibBuilder.loadTexts: prtPriorityIdx.setDescription('This object indicates the Traffic Priority Index.')
prtPriorityIngressRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPriorityIngressRateLimit.setStatus('current')
if mibBuilder.loadTexts: prtPriorityIngressRateLimit.setDescription('The maximum rate permitted at Ingress of this port with this Traffic Priority, in Kbps.')
prtQosTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2), )
if mibBuilder.loadTexts: prtQosTable.setStatus('current')
if mibBuilder.loadTexts: prtQosTable.setDescription('Port QoS (Quality of Service) table.')
prtQosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1), ).setIndexNames((0, "RAD-MIB", "prtQosIdx"), (0, "RAD-MIB", "prtQosPrtIdx"), (0, "RAD-MIB", "prtQosDirection"))
if mibBuilder.loadTexts: prtQosEntry.setStatus('current')
if mibBuilder.loadTexts: prtQosEntry.setDescription('An entry in table.')
prtQosIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: prtQosIdx.setStatus('current')
if mibBuilder.loadTexts: prtQosIdx.setDescription('The first index of the table. This attribute might indicate the Idx of the Cnfg (1..255) being accessed ; Idx of 255 relates to the TmpCnfg or any other Index.')
prtQosPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: prtQosPrtIdx.setStatus('current')
if mibBuilder.loadTexts: prtQosPrtIdx.setDescription('This object indicates a unique Port Index. Refer to device specification for port Index.')
prtQosDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("ingress", 2), ("egress", 3))))
if mibBuilder.loadTexts: prtQosDirection.setStatus('current')
if mibBuilder.loadTexts: prtQosDirection.setDescription("This object indicates the port's QoS Direction.")
prtQosRateLimitPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("bcastAndMcastAndFloodedUcast", 2), ("bcastAndMcast", 3), ("bcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtQosRateLimitPacketType.setStatus('current')
if mibBuilder.loadTexts: prtQosRateLimitPacketType.setDescription('This object indicates the Type of Packets on which Rate Limitation is applied.')
prtQosRateLimitCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtQosRateLimitCIR.setStatus('current')
if mibBuilder.loadTexts: prtQosRateLimitCIR.setDescription("This object indicates the port's CIR (Committed Information Rate) in Kbps. Value=0 represents best effort.")
prtQosRateLimitCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtQosRateLimitCBS.setStatus('current')
if mibBuilder.loadTexts: prtQosRateLimitCBS.setDescription("This object indicates the port's CBS (Committed Burst Size) in KB. Value=0 represents best effort.")
prtQosRateLimitEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtQosRateLimitEIR.setStatus('current')
if mibBuilder.loadTexts: prtQosRateLimitEIR.setDescription("This object indicates the port's EIR (Excess Information Rate) in Kbps.")
prtQosRateLimitEBS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 4, 2, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtQosRateLimitEBS.setStatus('current')
if mibBuilder.loadTexts: prtQosRateLimitEBS.setDescription("This object indicates the port's EBS (Excess Burst Size) in KB.")
prtTrafficClass = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 5))
portTrafficClassTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 5, 1), )
if mibBuilder.loadTexts: portTrafficClassTable.setStatus('current')
if mibBuilder.loadTexts: portTrafficClassTable.setDescription('Mapping of port to Traffic Class level.')
portTrafficClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "portTrafficClassIdx1"), (0, "RAD-MIB", "portTrafficClassPortIdx"))
if mibBuilder.loadTexts: portTrafficClassEntry.setStatus('current')
if mibBuilder.loadTexts: portTrafficClassEntry.setDescription('An entry in portTrafficClassTable.')
portTrafficClassIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: portTrafficClassIdx1.setStatus('current')
if mibBuilder.loadTexts: portTrafficClassIdx1.setDescription('This attribute indicates the 1st index of the table. This may be the Idx of the Cnfg(1..255) being accessed; Idx of 255 relates to the TmpCnfg, or any other Index.')
portTrafficClassPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: portTrafficClassPortIdx.setStatus('current')
if mibBuilder.loadTexts: portTrafficClassPortIdx.setDescription('This object indicates a unique Port Index. Refer to device specification for port Index.')
portTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficClass.setStatus('current')
if mibBuilder.loadTexts: portTrafficClass.setDescription('This object indicates the Traffic Class level of this port.')
serviceTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 6), )
if mibBuilder.loadTexts: serviceTable.setStatus('current')
if mibBuilder.loadTexts: serviceTable.setDescription('Table of services.')
serviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "flowIndex"), (0, "RAD-MIB", "serviceIndex"))
if mibBuilder.loadTexts: serviceEntry.setStatus('current')
if mibBuilder.loadTexts: serviceEntry.setDescription('An entry in the Service Table.')
flowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: flowIndex.setStatus('current')
if mibBuilder.loadTexts: flowIndex.setDescription('Defines the Flow ID the service is associated to.')
serviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: serviceIndex.setStatus('current')
if mibBuilder.loadTexts: serviceIndex.setDescription('Defines the Service ID - according to the CoS.')
serviceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serviceRowStatus.setStatus('current')
if mibBuilder.loadTexts: serviceRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
serviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1, 4), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serviceName.setStatus('current')
if mibBuilder.loadTexts: serviceName.setDescription('This attribute defines the service name.')
serviceBwProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 6, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serviceBwProfileId.setStatus('current')
if mibBuilder.loadTexts: serviceBwProfileId.setDescription('This variable holds the index of the Ingress BW profile assigned to that service.')
evcCosTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 7), )
if mibBuilder.loadTexts: evcCosTable.setStatus('current')
if mibBuilder.loadTexts: evcCosTable.setDescription('This table defines mapping of Ethernet Virtual Connection (EVC) ID to Class of Service (CoS) ID ')
evcCosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1), ).setIndexNames((0, "RAD-MIB", "evcCosCnfgIdx"), (0, "RAD-MIB", "evcCosEvcIdx"))
if mibBuilder.loadTexts: evcCosEntry.setStatus('current')
if mibBuilder.loadTexts: evcCosEntry.setDescription('An entry in table.')
evcCosCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: evcCosCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: evcCosCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
evcCosEvcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: evcCosEvcIdx.setStatus('current')
if mibBuilder.loadTexts: evcCosEvcIdx.setDescription('This attribute indicates EVC Id.')
evcCosRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: evcCosRowStatus.setStatus('current')
if mibBuilder.loadTexts: evcCosRowStatus.setDescription('This attribute allows to create/delete a row in this table.')
evcCosEvcName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: evcCosEvcName.setStatus('current')
if mibBuilder.loadTexts: evcCosEvcName.setDescription('A string that identifies the EVC. It should be unique in the Maintenance Domain (i.e., in the managed network) Used as MEG ID field in OAM messages.')
evcCosSpVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 7, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: evcCosSpVlanId.setStatus('current')
if mibBuilder.loadTexts: evcCosSpVlanId.setDescription('This object indicates the SP (Service Provider) VLAN used when sending an OAM message for the specified EVC.')
serviceStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 8), )
if mibBuilder.loadTexts: serviceStatTable.setStatus('current')
if mibBuilder.loadTexts: serviceStatTable.setDescription('Service statistics table.')
serviceStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "RAD-MIB", "flowIndex"), (0, "RAD-MIB", "serviceIndex"), (0, "RAD-MIB", "serviceStatDirection"))
if mibBuilder.loadTexts: serviceStatEntry.setStatus('current')
if mibBuilder.loadTexts: serviceStatEntry.setDescription('An entry in the Service Statistics Table. ')
serviceStatDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upstream", 1), ("downstream", 2))))
if mibBuilder.loadTexts: serviceStatDirection.setStatus('current')
if mibBuilder.loadTexts: serviceStatDirection.setDescription('The direction in wich the measurement is taken.')
srvForwardGreenPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardGreenPackets.setStatus('current')
if mibBuilder.loadTexts: srvForwardGreenPackets.setDescription('This attribute displays the counted number of forwarded packets that where marked Green.')
srvForwardGreenPacktesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardGreenPacktesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvForwardGreenPacktesOverflow.setDescription('This attribute displays the number of times that the forwardGreenPackets counter has overflowed.')
srvForwardYellowPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardYellowPackets.setStatus('current')
if mibBuilder.loadTexts: srvForwardYellowPackets.setDescription('This attribute displays the counted number of forwarded packets that where marked Yellow.')
srvForwardYellowPacketsOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardYellowPacketsOverflow.setStatus('current')
if mibBuilder.loadTexts: srvForwardYellowPacketsOverflow.setDescription('This attribute displays the number of times that the forwardYellowPackets counter has overflowed.')
srvDiscardGreenPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardGreenPacket.setStatus('current')
if mibBuilder.loadTexts: srvDiscardGreenPacket.setDescription('This attribute displays the counted number of discarded packets that where marked Green.')
srvDiscardGreenPacketOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardGreenPacketOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardGreenPacketOverflow.setDescription('This attribute displays the number of times that the discardGreenPacket counter has overflowed.')
srvDiscardYellowRedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowRedPackets.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowRedPackets.setDescription('This attribute displays the counted number of discarded packets that where marked Yellow or Red.')
srvDiscardYellowRedPacketsOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowRedPacketsOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowRedPacketsOverflow.setDescription('This attribute displays the number of times that the discardYellowRedPackets counter has overflowed.')
srvForwardGreenBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardGreenBytes.setStatus('current')
if mibBuilder.loadTexts: srvForwardGreenBytes.setDescription('This attribute displays the counted number of forwarded bytes that where marked Green.')
srvForwardGreenBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardGreenBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvForwardGreenBytesOverflow.setDescription('This attribute displays the number of times that the forwardGreenBytes counter has overflowed.')
srvForwardYellowBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardYellowBytes.setStatus('current')
if mibBuilder.loadTexts: srvForwardYellowBytes.setDescription('This attribute displays the counted number of forwarded bytes that where marked Yellow.')
srvForwardYellowBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvForwardYellowBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvForwardYellowBytesOverflow.setDescription('This attribute displays the number of times that the forwardYellowBytes counter has overflowed.')
srvDiscardGreenBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardGreenBytes.setStatus('current')
if mibBuilder.loadTexts: srvDiscardGreenBytes.setDescription('This attribute displays the counted number of discarded bytes that where marked Green.')
srvDiscardGreenBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardGreenBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardGreenBytesOverflow.setDescription('This attribute displays the number of times that the discardGreenBytes counter has overflowed.')
srvDiscardYellowRedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowRedBytes.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowRedBytes.setDescription('This attribute displays the counted number of discarded bytes that where marked Yellow or Red.')
srvDiscardYellowRedBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowRedBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowRedBytesOverflow.setDescription('This attribute displays the number of times that the discardYellowRedBytes counter has overflowed.')
srvResetStatsCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: srvResetStatsCmd.setStatus('current')
if mibBuilder.loadTexts: srvResetStatsCmd.setDescription('Reset statistic counters of the service.')
srvDiscardYellowPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowPackets.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowPackets.setDescription('This attribute displays the counted number of discarded packets that where marked Yellow.')
srvDiscardYellowPacketsOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowPacketsOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowPacketsOverflow.setDescription('This attribute displays the number of times that the discardYellowPackets counter has overflowed.')
srvDiscardYellowBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowBytes.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowBytes.setDescription('This attribute displays the counted number of discarded bytes that where marked Yellow.')
srvDiscardYellowBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardYellowBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardYellowBytesOverflow.setDescription('This attribute displays the number of times that the discardYellowBytes counter has overflowed.')
srvDiscardRedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardRedPackets.setStatus('current')
if mibBuilder.loadTexts: srvDiscardRedPackets.setDescription('This attribute displays the counted number of discarded packets that where marked Red.')
srvDiscardRedPacketsOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardRedPacketsOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardRedPacketsOverflow.setDescription('This attribute displays the number of times that the discardRedPackets counter has overflowed.')
srvDiscardRedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardRedBytes.setStatus('current')
if mibBuilder.loadTexts: srvDiscardRedBytes.setDescription('This attribute displays the counted number of discarded bytes that where marked Red.')
srvDiscardRedBytesOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 8, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDiscardRedBytesOverflow.setStatus('current')
if mibBuilder.loadTexts: srvDiscardRedBytesOverflow.setDescription('This attribute displays the number of times that the discardRedBytes counter has overflowed.')
mappingProfileObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 9))
flowMappingProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1), )
if mibBuilder.loadTexts: flowMappingProfileTable.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileTable.setDescription('This table holds flow mapping profiles.')
flowMappingProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1), ).setIndexNames((0, "RAD-MIB", "flowMappingProfileIndex"), (0, "RAD-MIB", "flowMappingProfilePriority"))
if mibBuilder.loadTexts: flowMappingProfileEntry.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileEntry.setDescription('Each entry in this table describes one Flow mapping profile with one of its Flow Mapping supported, according to the Priority order. The information includes a reference to a Flow Mapping index. ')
flowMappingProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: flowMappingProfileIndex.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileIndex.setDescription('A running index for the Flow Mapping Profile table.')
flowMappingProfilePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: flowMappingProfilePriority.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfilePriority.setDescription('The priority of the Mapping selected by flowMappingProfileMapIndex within the Flow Mapping Profile.')
flowMappingProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowMappingProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
flowMappingProfileNumOfMaps = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowMappingProfileNumOfMaps.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileNumOfMaps.setDescription('This attribute determines the number of the mappings associated to the Flow Mapping Profile.')
flowMappingProfileMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowMappingProfileMapIndex.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileMapIndex.setDescription('This attribute holds a reference to the mapping index. It specifies the mapping selected for the Mapping Profile for the selected Priority. When flowMappingProfileNumOfMaps=0, this attribute is not relevant.')
flowMappingProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 1, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: flowMappingProfileName.setStatus('current')
if mibBuilder.loadTexts: flowMappingProfileName.setDescription('This attribute defines the name assigned to flowMappingIndex profile.')
qosFlowMappingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2), )
if mibBuilder.loadTexts: qosFlowMappingTable.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingTable.setDescription('A table of Flow Mapping.')
qosFlowMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1), ).setIndexNames((0, "RAD-MIB", "qosFlowMappingIdx1"), (0, "RAD-MIB", "qosFlowMappingIdx2"), (0, "RAD-MIB", "qosFlowMappingIdx3"))
if mibBuilder.loadTexts: qosFlowMappingEntry.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingEntry.setDescription('Each entry in this table describes one Flow Mapping. The information includes combination (AND function) of all the classifications, as defined in the qosFlowMappingCriteria field. Classifiers are: TOS, DSCP, VLAN ID, MAC and IP source and destination addresses, IP protocol, IP Precedence, TCP and UDP source and destination ports.')
qosFlowMappingIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: qosFlowMappingIdx1.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingIdx1.setDescription(' - In case the table is accessed via flowMappingProfileTable this is a running index for the QoS Flow Mapping table. - In case the table is not accessed via flowMappingProfileTable, this will be the ifIndex of the XNI (bridge port) to which the QoS mapping applies. ')
qosFlowMappingIdx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: qosFlowMappingIdx2.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingIdx2.setDescription('An index for the QoS Flow Mapping table. - In case the table is accessed via flowMappingProfileTable the index will be fixed = 1. - In case the table is not accessed via flowMappingProfileTable, this will be the index of the Flow (EVC) to which the QoS mapping applies. ')
qosFlowMappingIdx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 3), Unsigned32())
if mibBuilder.loadTexts: qosFlowMappingIdx3.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingIdx3.setDescription('An index for the QoS Flow Mapping table. - In case the table is accessed via flowMappingProfileTable the index will be fixed = 1. - In case the table is not accessed via flowMappingProfileTable, this will be the Priority to which the QoS mapping applies. ')
qosFlowMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
qosFlowMappingCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 5), Bits().clone(namedValues=NamedValues(("ieee802dot1p", 0), ("tos", 1), ("dscp", 2), ("vlanId", 3), ("macSrcAddr", 4), ("macDestAddr", 5), ("ipSrcAddr", 6), ("ipDestAddr", 7), ("tcpSrcPort", 8), ("tcpDestPort", 9), ("udpSrcPort", 10), ("udpDestPort", 11), ("ipPrecedence", 12), ("innerIeee802dot1p", 13), ("innerVlanId", 14), ("untagged", 15)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingCriteria.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingCriteria.setDescription('This attribute determines upon which criterion the flow will be mapped.')
qosFlowMappingIeee802dot1p = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingIeee802dot1p.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingIeee802dot1p.setDescription("This attribute determines which TOS values are applicable for that flow. Each bit (0..7) represents a different 802.1 P-bit value. Setting '1' to the bit means that the corresponding 802.1 P-bit value is applicable. It is relevant only in case the ieee802dot1p bit(0) in qosFlowMappingCriteria equals 1.")
qosFlowMappingTos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingTos.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingTos.setDescription("This attribute determines which TOS values are applicable for that flow. Each bit (0..7) represents a different TOS value. Setting '1' to the bit means that the corresponding TOS value is applicable. It is relevant only in case the tos bit (1) in qosFlowMappingCriteria equals 1.")
qosFlowMappingFromDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromDscp.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromDscp.setDescription('This attribute determines the first DSCP value to compare with in a range. It is relevant only in case the dscp bit (2) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToDscp.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToDscp.setDescription('This attribute determines the first DSCP value to compare with in a range. It is relevant only in case the dscp bit (2) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromVlanId.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromVlanId.setDescription('This attribute determines the first VLAN ID value to compare with in a range. It is relevant only in case the vlanId bit (3) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToVlanId.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToVlanId.setDescription('This attribute determines the last VLAN ID value to compare with in a range. It is relevant only in case the vlanId bit (3) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 12), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromSrcMacAddr.setDescription('This attribute determines the first source MAC address to compare with in a range. It is relevant only in case the macSrcAddr bit (4) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 13), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToSrcMacAddr.setDescription('This attribute determines the last source MAC address to compare with in a range. It is relevant only in case the macSrcAddr bit (4) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 14), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromDestMacAddr.setDescription('This attribute determines the first destination MAC address to compare with in a range. It is relevant only in case the macDestAddr (5) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingToDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 15), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToDestMacAddr.setDescription('This attribute determines the last destination MAC address to compare with in a range. It is relevant only in case the macDestAddr (5) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromSrcIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 16), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromSrcIpAddr.setDescription('This attribute determines the first source IP address to compare with in a range. It is relevant only in case the ipSrcAddr (6) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingToSrcIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 17), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToSrcIpAddr.setDescription('This attribute determines the last source IP address to compare with in a range. It is relevant only in case the ipSrcAddr (6) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromDestIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 18), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromDestIpAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromDestIpAddr.setDescription('This attribute determines the first destination IP address to compare with in a range. It is relevant only in case the ipDestAddr (7) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingToDestIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 19), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToDestIpAddr.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToDestIpAddr.setDescription('This attribute determines the last destination IP address to compare with in a range. It is relevant only in case the ipDestAddr (7) bit in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromTcpSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 20), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromTcpSrcPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromTcpSrcPort.setDescription('This attribute determines the first TCP source port to compare with in a range. It is relevant only in case the tcpSrcPort bit (8) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToTcpSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 21), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToTcpSrcPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToTcpSrcPort.setDescription('This attribute determines the last TCP source port to compare with in a range. It is relevant only in case the tcpSrcPort bit (8) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromTcpDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 22), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromTcpDestPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromTcpDestPort.setDescription('This attribute determines the first TCP destination port to compare with in a range. It is relevant only in case the tcpDestPort bit (9) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToTcpDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 23), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToTcpDestPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToTcpDestPort.setDescription('This attribute determines the last TCP destination port to compare with in a range. It is relevant only in case the tcpDestPort bit (9) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromUdpSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 24), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromUdpSrcPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromUdpSrcPort.setDescription('This attribute determines the first UDP source port to compare with in a range. It is relevant only in case the udpSrcPort bit (10) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToUdpSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 25), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToUdpSrcPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToUdpSrcPort.setDescription('This attribute determines the last UDP source port to compare with in a range. It is relevant only in case the udpSrcPort bit (10) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromUdpDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 26), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromUdpDestPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromUdpDestPort.setDescription('This attribute determines the first UDP destination port to compare with in a range. It is relevant only in case the udpDestPort bit (11) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToUdpDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 27), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToUdpDestPort.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToUdpDestPort.setDescription('This attribute determines the last UDP destination port to compare with in a range. It is relevant only in case the udpDestPort bit (11) in qosFlowMappingCriteria equals 1.')
qosFlowMappingFromIpPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 28), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromIpPrecedence.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromIpPrecedence.setDescription('This attribute determines the first IpPrecedence value to compare with in a range. It is relevant only in case the IpPrecedence bit (12) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToIpPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 29), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToIpPrecedence.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToIpPrecedence.setDescription('This attribute determines the last IpPrecedence value to compare with in a range. It is relevant only in case the IpPrecedence bit (12) in qosFlowMappingCriteria equals 1.')
qosFlowMappingInnerIeee802dot1p = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 30), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingInnerIeee802dot1p.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingInnerIeee802dot1p.setDescription("This attribute determines which TOS values are applicable for that flow. Each bit (0..7) represents a different inner 802.1 P-bit value. Setting '1' to the bit means that the corresponding inner 802.1 P-bit value is applicable. It is relevant only in case the innerIeee802dot1p bit (13) in qosFlowMappingCriteria equals 1.")
qosFlowMappingFromInnerVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 31), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingFromInnerVlanId.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingFromInnerVlanId.setDescription('This attribute determines the first inner VLAN ID value to compare with in a range. It is relevant only in case the innerVlanId bit(14) in qosFlowMappingCriteria equals 1.')
qosFlowMappingToInnerVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 9, 2, 1, 32), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosFlowMappingToInnerVlanId.setStatus('current')
if mibBuilder.loadTexts: qosFlowMappingToInnerVlanId.setDescription('This attribute determines the last inner VLAN ID value to compare with in a range. It is relevant only in case the innerVlanId bit(14) in qosFlowMappingCriteria equals 1.')
cosProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 10), )
if mibBuilder.loadTexts: cosProfileTable.setStatus('current')
if mibBuilder.loadTexts: cosProfileTable.setDescription('Class of Service Profile table. Each profile holds a priority method, and a mappring function that maps the priority values (range according to the method) into CoS values.')
cosProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1), ).setIndexNames((0, "RAD-MIB", "cosProfileIndex"))
if mibBuilder.loadTexts: cosProfileEntry.setStatus('current')
if mibBuilder.loadTexts: cosProfileEntry.setDescription('A conceptual row where each row contains one CoS attributes.')
cosProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cosProfileIndex.setStatus('current')
if mibBuilder.loadTexts: cosProfileIndex.setDescription('Defines the CoS Profile ID.')
cosProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cosProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: cosProfileRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
cosProfileCosMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("ieee802dot1p", 2), ("tos", 3), ("dscp", 4), ("ipPrecedence", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cosProfileCosMethod.setStatus('current')
if mibBuilder.loadTexts: cosProfileCosMethod.setDescription('Defines the priority method upon CoS mapping is done.')
cosProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1, 4), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cosProfileName.setStatus('current')
if mibBuilder.loadTexts: cosProfileName.setDescription('This attribute defines the name assigned to CoS profile.')
cosProfileCosMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cosProfileCosMapping.setStatus('current')
if mibBuilder.loadTexts: cosProfileCosMapping.setDescription('This attribute defines the value of the CoS that is assigned for each priority. The number of the valid octets depends upon the priority method selected: Octet 0 corresponds to priority = 0 Octet 1 corresponds to priority = 1 ... Octet 63 corresponds to priority = 63. ')
queueProfileObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 3, 11))
qProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1), )
if mibBuilder.loadTexts: qProfileTable.setStatus('current')
if mibBuilder.loadTexts: qProfileTable.setDescription('This table defines the profiles for a cluster of queues. ')
qProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1), ).setIndexNames((0, "RAD-MIB", "qProfileIndex"))
if mibBuilder.loadTexts: qProfileEntry.setStatus('current')
if mibBuilder.loadTexts: qProfileEntry.setDescription('A conceptual row where each row contains one Queue Cluster attribute. ')
qProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: qProfileIndex.setStatus('current')
if mibBuilder.loadTexts: qProfileIndex.setDescription('Defines the Queue Cluster Profile ID.')
qProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: qProfileRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
qProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qProfileName.setStatus('current')
if mibBuilder.loadTexts: qProfileName.setDescription('This attribute holds the name of the Queue cluster profile.')
qProfileNumberOfInternalQ = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qProfileNumberOfInternalQ.setStatus('current')
if mibBuilder.loadTexts: qProfileNumberOfInternalQ.setDescription('This attribute holds the number of the internal queue profiles that are pointed by qInternalQProfile.')
qProfileInternalQProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 1, 1, 5), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qProfileInternalQProfile.setStatus('current')
if mibBuilder.loadTexts: qProfileInternalQProfile.setDescription('This attribute holds the indexes to the queue profiles in the qInternalProfileTable. Each couple of octets holds an index to the qInternalProfileTable.')
qInternalProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2), )
if mibBuilder.loadTexts: qInternalProfileTable.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileTable.setDescription('This table holds queue profiles.')
qInternalProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1), ).setIndexNames((0, "RAD-MIB", "qInternalProfileIndex"))
if mibBuilder.loadTexts: qInternalProfileEntry.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileEntry.setDescription('A conceptual row where each row contains one Queue attribute. ')
qInternalProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: qInternalProfileIndex.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileIndex.setDescription('Defines the Queue Profile ID.')
qInternalProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
qInternalProfileScheduling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wfq", 1), ("strict", 2), ("bestEffort", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileScheduling.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileScheduling.setDescription('This attribute determines the queue scheduling method.')
qInternalProfileWFQWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileWFQWeight.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileWFQWeight.setDescription('This attribute determines the weight that each WFQ (Weighted Fair Queue) participant gets. It is applicable only when scheduling is configured to WFQ.')
qInternalProfileQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileQueueLength.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileQueueLength.setDescription('This attribute determines the length of the queue.')
qInternalProfileWredStartDropThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileWredStartDropThresh.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileWredStartDropThresh.setDescription('This attribute determines the length that the queue (Start Value) must reach before the packets colored yellow will start being dropped by the WRED (Weighted Random Early Detection/Discard) mechanism. WRED is one the most commonly used method for congestion avoidance.')
qInternalProfileWredDropAllThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileWredDropAllThresh.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileWredDropAllThresh.setDescription('This attribute determines the length that the queue (Stop Value) must reach before the WRED (Weighted Random Early Detection) shaper mechanism stops dropping randomly, and just drops all further packets marked as yellow.')
qInternalProfileWredDropProbability = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileWredDropProbability.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileWredDropProbability.setDescription('This attribute determines the percentage of packets that are being dropped at the point when the length of the queue reaches the Stop value. So, effectively, this defines how quickly the rate of dropping packet must increase as the queue length grows from the Start Value to the Stop Value.')
qInternalProfileRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileRateLimit.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileRateLimit.setDescription('This attribute determines the Rate Limit of the queue in Kbps. Value=0 represents best effort.')
qInternalProfileShaperProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qInternalProfileShaperProfile.setStatus('current')
if mibBuilder.loadTexts: qInternalProfileShaperProfile.setDescription("This attribute defines the Shaper Profile (bwProfileIndex from bwProfileTable) assigned to this qInternalProfile. Valid range of bwProfileIndex for Shaper Profiles is 0x8000001-0x8000041. If set to '0', no profile is assigned to this qInternalProfile.")
queueGroupTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3), )
if mibBuilder.loadTexts: queueGroupTable.setStatus('current')
if mibBuilder.loadTexts: queueGroupTable.setDescription('This table defines the queue groups/blocks,their level and connections between them.')
queueGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1), ).setIndexNames((1, "RAD-MIB", "queueGroupName"), (0, "RAD-MIB", "queueGroupQBlockLevel"), (0, "RAD-MIB", "queueGroupQBlockIdx"))
if mibBuilder.loadTexts: queueGroupEntry.setStatus('current')
if mibBuilder.loadTexts: queueGroupEntry.setDescription('A conceptual row where each row contains one Queue group. ')
queueGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: queueGroupName.setStatus('current')
if mibBuilder.loadTexts: queueGroupName.setDescription('Defines the Queue Group unique name.')
queueGroupQBlockLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: queueGroupQBlockLevel.setStatus('current')
if mibBuilder.loadTexts: queueGroupQBlockLevel.setDescription('This attribute holds the Level of the Queue Block .First level is 1. NA=2^32-1.')
queueGroupQBlockIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 3), Unsigned32())
if mibBuilder.loadTexts: queueGroupQBlockIdx.setStatus('current')
if mibBuilder.loadTexts: queueGroupQBlockIdx.setDescription('This attribute holds the ID of the Queue Block. NA=2^32-1.')
queueGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: queueGroupRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
queueGroupQBlockProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupQBlockProfile.setStatus('current')
if mibBuilder.loadTexts: queueGroupQBlockProfile.setDescription('This attribute defines the Queue profile assigned to this Queue Block. This object points to qProfileIndex in qProfileTable. ')
queueGroupQBlockShaperProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupQBlockShaperProfile.setStatus('current')
if mibBuilder.loadTexts: queueGroupQBlockShaperProfile.setDescription('This attribute defines the Shaper profile assigned to this Queue Block.')
queueGroupPointToQBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupPointToQBlock.setStatus('current')
if mibBuilder.loadTexts: queueGroupPointToQBlock.setDescription('This attribute defines the Queue Block name of the next Queue Block level that is pointed by this Queue Block.')
queueGroupPointToInternalQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupPointToInternalQueue.setStatus('current')
if mibBuilder.loadTexts: queueGroupPointToInternalQueue.setDescription('This attribute defines the internal queue whithin queueGroupPointToQBlock that is pointed by this Queue Block.')
queueGroupQBlockName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 11, 3, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: queueGroupQBlockName.setStatus('current')
if mibBuilder.loadTexts: queueGroupQBlockName.setDescription('This attribute holds the name of the Queue Block.')
markingProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 3, 12), )
if mibBuilder.loadTexts: markingProfileTable.setStatus('current')
if mibBuilder.loadTexts: markingProfileTable.setDescription('Marking profile table. Each profile holds a marking function which converts CoS values to Service Provider priority values.')
markingProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1), ).setIndexNames((0, "RAD-MIB", "markingProfileIndex"))
if mibBuilder.loadTexts: markingProfileEntry.setStatus('current')
if mibBuilder.loadTexts: markingProfileEntry.setDescription('A conceptual row where each row contains one Marking attribute. ')
markingProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: markingProfileIndex.setStatus('current')
if mibBuilder.loadTexts: markingProfileIndex.setDescription('Defines the Marking Profile ID.')
markingProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: markingProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: markingProfileRowStatus.setDescription('This attribute is used to create a new row or to delete an existing row in the table.')
markingProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: markingProfileName.setStatus('current')
if mibBuilder.loadTexts: markingProfileName.setDescription('This attribute defines the unique name assigned to the Marking profile.')
markingSpVlanPBit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: markingSpVlanPBit.setStatus('current')
if mibBuilder.loadTexts: markingSpVlanPBit.setDescription('For ETX-202A : This attribute defines the value of the SP VLAN P-Bit that is assigned for each CoS: Octet 0 corresponds to CoS = 0 Octet 1 corresponds to CoS = 1 ... Octet 7 corresponds to CoS = 7. For LA-210 from V1.5 : This attribute defines the value of the SP VLAN P-Bit that is assigned for each frame according to the value of markingProfileMethod parameter : Octet 0 corresponds to value 0 of 802.1 P-bit/DSCP/TOS. Octet 1 corresponds to value 1 of 802.1 P-bit/DSCP/TOS. ... Octet 7 corresponds to value 7 of 802.1 P-bit/DSCP/TOS. Octets 8-63 correspond to DSCP values 8-63. ')
markingProfileMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 3, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("ieee802dot1p", 2), ("tos", 3), ("dscp", 4), ("ipPrecedence", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: markingProfileMethod.setStatus('current')
if mibBuilder.loadTexts: markingProfileMethod.setDescription('This attribute defines the method upon which marking is done.')
ethIf = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1))
ethIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1), )
if mibBuilder.loadTexts: ethIfTable.setStatus('current')
if mibBuilder.loadTexts: ethIfTable.setDescription('A table.')
ethIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1), ).setIndexNames((0, "RAD-MIB", "ethIfIdx"))
if mibBuilder.loadTexts: ethIfEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfEntry.setDescription('An entry in table.')
ethIfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIdx.setStatus('current')
if mibBuilder.loadTexts: ethIfIdx.setDescription('A unique index of the ethernet interface/port.')
ethMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("halfDuplex", 1), ("fullDuplex", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethMode.setStatus('current')
if mibBuilder.loadTexts: ethMode.setDescription('This object indicates the Ethernet mode of operation.')
ethBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filtered", 1), ("transparent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBridgingMode.setStatus('current')
if mibBuilder.loadTexts: ethBridgingMode.setDescription('This object indicates the bridging mode of the Ethernet interface. ')
ethEncapsulationCRCMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("withCRC", 2), ("withoutCRC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethEncapsulationCRCMode.setStatus('current')
if mibBuilder.loadTexts: ethEncapsulationCRCMode.setDescription('This object define the encapsulation type requested for the Ethernet interface. It indicates if we transfer the Ethernet frame to the other side with or without the CRC. ')
ethBackPressure = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBackPressure.setStatus('current')
if mibBuilder.loadTexts: ethBackPressure.setDescription('This parameter defines whether to enable or disable Back pressure. Back Pressure is a flow control parameter. ')
ethLimit4 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethLimit4.setStatus('current')
if mibBuilder.loadTexts: ethLimit4.setDescription('This parameter determine the Back off algorithm mode. Every 4 following collisions the Framer will be thrown out (4 times more than usuall).')
ethSkipInitReset = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("notSkip", 2), ("skip", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethSkipInitReset.setStatus('current')
if mibBuilder.loadTexts: ethSkipInitReset.setDescription('This parameter defines whether read status on reset. ')
ethMulticastBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unBlock", 2), ("block", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethMulticastBlock.setStatus('current')
if mibBuilder.loadTexts: ethMulticastBlock.setDescription('This parameter defines whether to send multicast message to WAN from LAN or not. ')
ethBroadcastBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("unBlock", 2), ("block", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBroadcastBlock.setStatus('current')
if mibBuilder.loadTexts: ethBroadcastBlock.setDescription('This parameter defines whether to send broadcast message to WAN from LAN or not.')
ethSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("s10Mbps", 2), ("s100Mbps", 3), ("s1Gbps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethSpeed.setStatus('current')
if mibBuilder.loadTexts: ethSpeed.setDescription('This parameter defines the line speed.')
ethRip2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethRip2.setStatus('current')
if mibBuilder.loadTexts: ethRip2.setDescription('This parameter defines whether to send RIP II message to WAN from LAN or not')
ethPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("fixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortPriority.setStatus('current')
if mibBuilder.loadTexts: ethPortPriority.setDescription('This parameter defines if priority is to be considered for this Port.')
ethPortMngEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3), ("localOnly", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortMngEnable.setStatus('current')
if mibBuilder.loadTexts: ethPortMngEnable.setDescription('This parameter defines whether management data can pass through this Port. localOnly (4) - Only local device can be managed via this port.')
ethFlowCtrlMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 14), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethFlowCtrlMacAddress.setStatus('current')
if mibBuilder.loadTexts: ethFlowCtrlMacAddress.setDescription('In case of flow control - transmit frame with this specific MAC address to inform the other end to stop sending frames. Default: 01.80.C2.00.00.01.')
ethRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethRateLimit.setStatus('current')
if mibBuilder.loadTexts: ethRateLimit.setDescription('This parameter defines the Rate Limit of the line, in Mbps.')
ethJumboFrameEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethJumboFrameEnable.setStatus('current')
if mibBuilder.loadTexts: ethJumboFrameEnable.setDescription('This parameter defines whether to support Jumbo Frame or not.')
ethAutoMdiXEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAutoMdiXEnable.setStatus('current')
if mibBuilder.loadTexts: ethAutoMdiXEnable.setDescription('This parameter defines whether to support automatic change between MDI and MDI[X].')
ethPortDataEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortDataEnable.setStatus('current')
if mibBuilder.loadTexts: ethPortDataEnable.setDescription('This parameter defines whether this port is enabled for data (that is not management). no(2) - management can run on this port yes(3) - both management and payload data can run on this port.')
ethIfUse = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfUse.setStatus('current')
if mibBuilder.loadTexts: ethIfUse.setDescription('This parameter defines the use of the port. 1=NET 2=USER .')
ethLineOam = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("passive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethLineOam.setStatus('current')
if mibBuilder.loadTexts: ethLineOam.setDescription('This parameter defines the working mode of 802.AH OAM mechanism.')
ethRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4), ("rip1and2", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethRoutingProtocol.setStatus('current')
if mibBuilder.loadTexts: ethRoutingProtocol.setDescription('This parameter defines the routing protocol used above ETH port.')
ethMdiXManualSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crossOver", 1), ("straightThrough", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethMdiXManualSwitch.setStatus('current')
if mibBuilder.loadTexts: ethMdiXManualSwitch.setDescription('This parameter sets the port to be MDI-X (cross-over) or MDI (straight-through). It is applicable only when ethAutoMdiXEnable = no, namely, only when the automatic MDI/MDIX crossover function is disabled.')
ethDot1xEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethDot1xEnable.setStatus('current')
if mibBuilder.loadTexts: ethDot1xEnable.setDescription('Determines if the Port-Based Network Access Protocol (IEEE-802.1x) is enabled for the Ethernet Port.')
ethPartnerRateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPartnerRateMode.setStatus('current')
if mibBuilder.loadTexts: ethPartnerRateMode.setDescription('For converters having couples of ports, where each couple contains a port with an SFP connector and a port with a RJ connector, this parameter is relevant for the SFP port. It affects Rate configuration of its partner (RJ port). manual - user can configure manually ETH parameters of RJ port (e.g Autonegotiation, Max Capability Advertised, etc...) automatic - SFP Rate will be enforced on the RJ port. In this mode, user cannot configure the Rate related parameters of the RJ port (e.g Autonegotiation, Max Capability Advertised, etc...)')
ethDot1xPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("authenticator", 1), ("supplicant", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethDot1xPortRole.setStatus('current')
if mibBuilder.loadTexts: ethDot1xPortRole.setDescription('Determine the functionality of the port in the Port-Based Network Access Protocol (IEEE-802.1x) - either Authenticator or Supplicant.')
ethIfPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2))
ethIfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1), )
if mibBuilder.loadTexts: ethIfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentTable.setDescription('The Ethernet Current table. When the index specifies the Ethernet interface (only), the counters are for an interval of 15 minutes.')
ethIfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "ethIfCurrentIndex"))
if mibBuilder.loadTexts: ethIfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentEntry.setDescription('An entry in the Ethernet Current table.')
ethIfCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentIndex.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentIndex.setDescription('The index of the Ethernet interface. It may be ifIndex. For some devices (e.g RICi-622GE), supporting several types of intervals, this index will be a concatenation of the port index and interval type. Interval type can indicate: 1 minute, 15 minutes, 1 hour, 24 hours. For the exact formula, see device specification.')
ethIfCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentStatus.setDescription('The status of the current interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
ethIfCurrentInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInFrames.setDescription('The counter associated with the number of received frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInOctets.setDescription('The counter associated with the number of received octets, encountered by the Ethernet interface in the current interval.')
ethIfCurrentAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentAlignmentErrors.setDescription('The counter associated with the number of received frames, which are not complete (The result of dividing the number of bits by 8 is not an Integer), encountered by the Ethernet interface in the current interval.')
ethIfCurrentFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentFCSErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentFCSErrors.setDescription("The counter associated with the number of received frames that didn't pass the FCS test, encountered by the Ethernet interface in the current interval.")
ethIfCurrentLengthError = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentLengthError.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentLengthError.setDescription('The counter associated with the number of received frames with length error, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutFrames.setDescription('The counter associated with the number of transmitted frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutOctets.setDescription('The counter associated with the number of transmitted octets, encountered by the Ethernet interface in the current interval.')
ethIfCurrentSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentSingleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentSingleCollisionFrames.setDescription('The counter associated with the number of successfully transmitted frames for which transmission was inhibited by exactly one collision, encountered by the Ethernet interface in the current interval.')
ethIfCurrentMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentMultipleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentMultipleCollisionFrames.setDescription('The counter associated with the number of successfully transmitted frames for which transmission was inhibited by more than one collision, encountered by the Ethernet interface in the current interval.')
ethIfCurrentDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentDeferredTransmissions.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentDeferredTransmissions.setDescription('The counter associated with the number of transmitted frames for which the first transmission attempt was delayed due to a busy media, encountered by the Ethernet interface in the current interval.')
ethIfCurrentLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentLateCollisions.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentLateCollisions.setDescription('The counter associated with the number of times that a collision was detected later than the first 64 bytes of the frame, encountered by the Ethernet interface in the current interval.')
ethIfCurrentCarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentCarrierSenseErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentCarrierSenseErrors.setDescription('The counter associated with the number of times that the carrier sense condition was lost or never asserted when attempting to transmit a frame, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInputCongestionDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInputCongestionDropped.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInputCongestionDropped.setDescription('The counter associated with the number of frames dropped due to lack of buffers in ingress pool, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutputCongestionDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutputCongestionDropped.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutputCongestionDropped.setDescription('The counter associated with the number of dropped frames due to a congestion, encountered by the Transmit direction to the Ethernet interface in the current interval.')
ethIfCurrentOverflowInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInFrames.setDescription('The number of times the associated ethIfCurrentInFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInOctets.setDescription('The number of times the associated ethIfCurrentInOctets counter has overflowed in the current interval.')
ethIfCurrentOverflowFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowFCSErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowFCSErrors.setDescription('The number of times the associated ethIfCurrentFCSErrors counter has overflowed in the current interval.')
ethIfCurrentOverflowOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutFrames.setDescription('The number of times the associated ethIfCurrentOutFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutOctets.setDescription('The number of times the associated ethIfCurrentOutOctets counter has overflowed in the current interval.')
ethIfCurrentOverflowMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowMultipleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowMultipleCollisionFrames.setDescription('The number of times the associated ethIfCurrentMultipleCollisionFrames counter has overflowed in the current interval.')
ethIfCurrentInUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInUnicastFrames.setDescription('The number of received Unicast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutUnicastFrames.setDescription('The number of transmitted Unicast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInMulticastFrames.setDescription('The number of received Multicast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutMulticastFrames.setDescription('The number of transmitted Multicast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInBroadcastFrames.setDescription('The number of received Broadcast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutBroadcastFrames.setDescription('The number of transmitted Broadcast frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInDiscardFrames.setDescription('The number of received Discarded frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutDiscardFrames.setDescription('The number of transmitted Discarded frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentInPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentInPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentInPauseFrames.setDescription('The number of received Pause frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOutPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOutPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOutPauseFrames.setDescription('The number of transmitted Pause frames, encountered by the Ethernet interface in the current interval.')
ethIfCurrentOverflowInUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInUnicastFrames.setDescription('The number of times the associated ethIfCurrentInUnicastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutUnicastFrames.setDescription('The number of times the associated ethIfCurrentOutUnicastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowInMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInMulticastFrames.setDescription('The number of times the associated ethIfCurrentInMulticastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutMulticastFrames.setDescription('The number of times the associated ethIfCurrentOutMulticastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInBroadcastFrames.setDescription('The number of times the associated ethIfCurrentInBroadcastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutBroadcastFrames.setDescription('The number of times the associated ethIfCurrentOutBroadcastFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowInDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInDiscardFrames.setDescription('The number of times the associated ethIfCurrentInDiscardFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutDiscardFrames.setDescription('The number of times the associated ethIfCurrentOutDiscardFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowInPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowInPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowInPauseFrames.setDescription('The number of times the associated ethIfCurrentInPauseFrames counter has overflowed in the current interval.')
ethIfCurrentOverflowOutPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 1, 1, 42), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfCurrentOverflowOutPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfCurrentOverflowOutPauseFrames.setDescription('The number of times the associated ethIfCurrentOutPauseFrames counter has overflowed in the current interval.')
ethIfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2), )
if mibBuilder.loadTexts: ethIfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalTable.setDescription('The Ethernet Interval table. When ethIfIntervalIndex specifies the Ethernet interface (only), the counters are for an interval of 15 minutes.')
ethIfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "ethIfIntervalIndex"), (0, "RAD-MIB", "ethIfIntervalNumber"))
if mibBuilder.loadTexts: ethIfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalEntry.setDescription('An entry in the Ethernet Interval table.')
ethIfIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalIndex.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalIndex.setDescription('The index of the Ethernet interface. It may be ifIndex. For some devices (e.g RICi-622GE), supporting several types of intervals, this index will be a concatenation of the port index and interval type. Interval type can indicate: 1 minute, 15 minutes, 1 hour, 24 hours. For the exact formula, see device specification.')
ethIfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalNumber.setDescription('The Interval Number. This number is between 1 and x, where 1 is the most recently completed interval and x is the least recently completed interval. For 15 minute intervals, usually x=96, but it can be different, depending on device capabilities.')
ethIfIntervalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalStatus.setDescription('The status of the interval: 0 - Valid. 1 - redundantLinkSwitch - the link has been switched by a redundancy mechanism. 2 - discontinuity - module was partialy out. 4 - notValid - module is out.')
ethIfIntervalInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInFrames.setDescription('The counter associated with the number of received frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInOctets.setDescription('The counter associated with the number of received octets, encountered by the Ethernet interface in the interval.')
ethIfIntervalAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalAlignmentErrors.setDescription('The counter associated with the number of received frames, which are not complete (The result of dividing the number of bits by 8 is not an Integer), encountered by the Ethernet interface in the interval.')
ethIfIntervalFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalFCSErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalFCSErrors.setDescription("The counter associated with the number of received frames that didn't pass the FCS test, encountered by the Ethernet interface in the interval.")
ethIfIntervalLengthError = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalLengthError.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalLengthError.setDescription('The counter associated with the number of received frames with length error, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutFrames.setDescription('The counter associated with the number of transmitted frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutOctets.setDescription('The counter associated with the number of transmitted octets, encountered by the Ethernet interface in the interval.')
ethIfIntervalSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalSingleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalSingleCollisionFrames.setDescription('The counter associated with the number of successfully transmitted frames for which transmission was inhibited by exactly one collision, encountered by the Ethernet interface in the interval.')
ethIfIntervalMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalMultipleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalMultipleCollisionFrames.setDescription('The counter associated with the number of successfully transmitted frames for which transmission was inhibited by more than one collision, encountered by the Ethernet interface in the interval.')
ethIfIntervalDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalDeferredTransmissions.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalDeferredTransmissions.setDescription('The counter associated with the number of transmitted frames for which the first transmission attempt was delayed due to a busy media, encountered by the Ethernet interface in the interval.')
ethIfIntervalLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalLateCollisions.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalLateCollisions.setDescription('The counter associated with the number of times that a collision was detected later than the first 64 bytes of the frame, encountered by the Ethernet interface in the interval.')
ethIfIntervalCarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalCarrierSenseErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalCarrierSenseErrors.setDescription('The counter associated with the number of times that the carrier sense condition was lost or never asserted when attempting to transmit a frame, encountered by the Ethernet interface in the interval.')
ethIfIntervalInputCongestionDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInputCongestionDropped.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInputCongestionDropped.setDescription('The counter associated with the number of dropped frames due to a congestion, encountered by the Receive direction to the Ethernet interface in the interval.')
ethIfIntervalOutputCongestionDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutputCongestionDropped.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutputCongestionDropped.setDescription('The counter associated with the number of dropped frames due to a congestion, encountered by the Transmit direction to the Ethernet interface in the interval.')
ethIfIntervalOverflowInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInFrames.setDescription('The number of times the associated ethIfIntervalInFrames counter has overflowed in the interval.')
ethIfIntervalOverflowInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInOctets.setDescription('The number of times the associated ethIfIntervalInOctets counter has overflowed in the interval.')
ethIfIntervalOverflowFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowFCSErrors.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowFCSErrors.setDescription('The number of times the associated ethIfIntervalFCSErrors counter has overflowed in the interval.')
ethIfIntervalOverflowOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutFrames.setDescription('The number of times the associated ethIfIntervalOutFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutOctets.setDescription('The number of times the associated ethIfIntervalOutOctets counter has overflowed in the interval.')
ethIfIntervalOverflowMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowMultipleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowMultipleCollisionFrames.setDescription('The number of times the associated ethIfIntervalMultipleCollisionFrames counter has overflowed in the interval.')
ethIfIntervalInUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInUnicastFrames.setDescription('The number of received Unicast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutUnicastFrames.setDescription('The number of transmitted Unicast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalInMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInMulticastFrames.setDescription('The number of received Multicast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutMulticastFrames.setDescription('The number of transmitted Multicast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInBroadcastFrames.setDescription('The number of received Broadcast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutBroadcastFrames.setDescription('The number of transmitted Broadcast frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalInDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInDiscardFrames.setDescription('The number of received Discarded frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutDiscardFrames.setDescription('The number of transmitted Discarded frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalInPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalInPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalInPauseFrames.setDescription('The number of received Pause frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOutPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOutPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOutPauseFrames.setDescription('The number of transmitted Pause frames, encountered by the Ethernet interface in the interval.')
ethIfIntervalOverflowInUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInUnicastFrames.setDescription('The number of times the associated ethIfIntervalInUnicastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutUnicastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutUnicastFrames.setDescription('The number of times the associated ethIfIntervalOutUnicastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowInMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInMulticastFrames.setDescription('The number of times the associated ethIfIntervalInMulticastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutMulticastFrames.setDescription('The number of times the associated ethIfIntervalOutMulticastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInBroadcastFrames.setDescription('The number of times the associated ethIfIntervalInBroadcastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutBroadcastFrames.setDescription('The number of times the associated ethIfIntervalOutBroadcastFrames counter has overflowed in the interval.')
ethIfIntervalOverflowInDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInDiscardFrames.setDescription('The number of times the associated ethIfIntervalInDiscardFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutDiscardFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutDiscardFrames.setDescription('The number of times the associated ethIfIntervalOutDiscardFrames counter has overflowed in the interval.')
ethIfIntervalOverflowInPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 42), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowInPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowInPauseFrames.setDescription('The number of times the associated ethIfIntervalInPauseFrames counter has overflowed in the interval.')
ethIfIntervalOverflowOutPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 2, 1, 43), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIntervalOverflowOutPauseFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfIntervalOverflowOutPauseFrames.setDescription('The number of times the associated ethIfIntervalOutPauseFrames counter has overflowed in the interval.')
ethPerformanceMode = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("countOK", 2), ("countFail", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPerformanceMode.setStatus('current')
if mibBuilder.loadTexts: ethPerformanceMode.setDescription('This object indicates whether OK or Fail statistics will be counted.')
ethIfPerfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4), )
if mibBuilder.loadTexts: ethIfPerfTable.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfTable.setDescription('The Ethernet Performance table.')
ethIfPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4, 1), ).setIndexNames((0, "RAD-MIB", "ethIfIdx"))
if mibBuilder.loadTexts: ethIfPerfEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfEntry.setDescription('An entry in the Ethernet Performance table.')
ethIfPerfInOkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfPerfInOkFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfInOkFrames.setDescription('The counter associated with the number of received OK frames, encountered by the Ethernet interface since ethPerformanceMode Set to countOK (2) or Reset Statistics was done.')
ethIfPerfOutOkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfPerfOutOkFrames.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfOutOkFrames.setDescription('The counter associated with the number of transmitted OK frames, encountered by the Ethernet interface since ethPerformanceMode Set to countOK (2) or Reset Statistics was done.')
ethIfPerfTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfPerfTotalCollisions.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfTotalCollisions.setDescription('The counter associated with the total number of collisions of any type encountered by the Ethernet interface since ethPerformanceMode Set to countOK (2) or Reset Statistics was done')
ethIfPerfInOkOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 2, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfPerfInOkOctets.setStatus('current')
if mibBuilder.loadTexts: ethIfPerfInOkOctets.setDescription('The counter associated with the number of received OK Octets, encountered by the Ethernet interface since ethPerformanceMode Set to countOK (2) or Reset Statistics was done.')
ethIfOamCfm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3))
ethIfOamCfmEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 0))
ethOamCfmDefectCondition = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 0, 1))
if mibBuilder.loadTexts: ethOamCfmDefectCondition.setStatus('current')
if mibBuilder.loadTexts: ethOamCfmDefectCondition.setDescription('This trap indicates that a MEP has a persistent defect condition.')
radMepTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1), )
if mibBuilder.loadTexts: radMepTable.setStatus('current')
if mibBuilder.loadTexts: radMepTable.setDescription('MEG End Point (MEP) configuration table associated with Maitenance Entity Group (MEG) End Point. MEP is a short name for an expanded ETH flow point that includes a compound ETH Segment flow termination function, which marks the end point of an ETH ME, and a compound ETH Diagnostic flow function.')
radMepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radOamEvcIdx"), (0, "RAD-MIB", "radMepIdx"))
if mibBuilder.loadTexts: radMepEntry.setStatus('current')
if mibBuilder.loadTexts: radMepEntry.setDescription('An entry in the table.')
radOamIdx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: radOamIdx1.setStatus('current')
if mibBuilder.loadTexts: radOamIdx1.setDescription('This object may indicate the Bridge Index or Configuration index.')
radOamEvcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: radOamEvcIdx.setStatus('current')
if mibBuilder.loadTexts: radOamEvcIdx.setDescription('This object indicates the Index of the EVC (Ethernet Virtual Circuit) that the MEP is associated to.')
radMepIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 3), Unsigned32())
if mibBuilder.loadTexts: radMepIdx.setStatus('current')
if mibBuilder.loadTexts: radMepIdx.setDescription('This object indicates the ID of the MEP being accessed.')
radMepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: radMepRowStatus.setDescription('This attribute allows to create/delete a row in this table.')
radMepLocalMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepLocalMepId.setStatus('current')
if mibBuilder.loadTexts: radMepLocalMepId.setDescription('This object indicates the local MEP ID.')
radMepRemoteMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepRemoteMepId.setStatus('current')
if mibBuilder.loadTexts: radMepRemoteMepId.setDescription('This atribute is currently implemneted at radMepCcTable, that supports multicast.')
radMepOamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disabled", 2), ("initiate", 3), ("react", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepOamMode.setStatus('current')
if mibBuilder.loadTexts: radMepOamMode.setDescription('This object determines the OAM mode of the MEP: disabled - no CC is initiated nor responded initiate - the device initiates and responds to CC react - the device does not initiate a CC, but responds to CC.')
radMepContinuityVerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disabled", 2), ("ccBased", 3), ("lbBased", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepContinuityVerMode.setStatus('current')
if mibBuilder.loadTexts: radMepContinuityVerMode.setDescription('This object determines the OAM behavior of the MEP: disabled - no CC is done cc_based - CC is done based on incoming messages lb_based - CC is done based on loopback messages.')
radMepMeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepMeLevel.setStatus('current')
if mibBuilder.loadTexts: radMepMeLevel.setDescription('At any point in a network, ME Level is used to distinguish between OAM signals belonging to different nested MEs. Maintenance Entity Levels are defined as follows: 0,1,2 are assigned to customers 3,4 are assigned to providers 5,6,7 are assigned to operators.')
radMepOamDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepOamDestAddrType.setStatus('current')
if mibBuilder.loadTexts: radMepOamDestAddrType.setDescription('This object determines if the OAM messages are sent to user defined unicast address, or to RAD proprietary multicast address.')
radMepOamDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 11), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepOamDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: radMepOamDestMacAddr.setDescription('This object determines the MAC address that OAM packets are sent to.')
radMepDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepDefaultPriority.setStatus('current')
if mibBuilder.loadTexts: radMepDefaultPriority.setDescription('This object defines the priority of the OAM messages sent when no service is defined on EVC. If a service is defined, the OAM messages will get the highest service priority existing on the EVC.')
radMepCcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("fail", 2), ("ok", 3), ("mismerge", 4), ("unexpectedMep", 5), ("unexpectedMeLevel", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepCcStatus.setStatus('current')
if mibBuilder.loadTexts: radMepCcStatus.setDescription('This object indicates the Continuity Check (CC) status.')
radMepOamProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("proprietary", 1), ("standard", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepOamProtocol.setStatus('current')
if mibBuilder.loadTexts: radMepOamProtocol.setDescription('Determines whether to use proprietary OAM mechanism, or to use the standard (IEEE 802.1ag, ITU-T Y.1731).')
radMepMdId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 15), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepMdId.setStatus('current')
if mibBuilder.loadTexts: radMepMdId.setDescription('The index of the Maintenance Domain in the radMdTable (radMdIndex).')
radMepMaFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 32))).clone(namedValues=NamedValues(("primaryVid", 1), ("charString", 2), ("unsignedInt16", 3), ("rfc2865VpnId", 4), ("icc", 32)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepMaFormat.setStatus('current')
if mibBuilder.loadTexts: radMepMaFormat.setDescription('The type (and thereby format) of the Maintenance Association Name.')
radMepMaName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 45))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepMaName.setStatus('current')
if mibBuilder.loadTexts: radMepMaName.setDescription('The Short Maintenance Association name.')
radMepSpVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 18), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepSpVlanId.setStatus('current')
if mibBuilder.loadTexts: radMepSpVlanId.setDescription('The SP (Service Provider) VLAN used when sending an OAM message.')
radMepCcInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("intervalInvalid", 0), ("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepCcInterval.setStatus('current')
if mibBuilder.loadTexts: radMepCcInterval.setDescription('Indicates the interval at which CCMs are sent by a MEP Valid only if radMepOamMode = initiate(4).')
radMepTransmitLbmDestMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 20), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmDestMacAddress.setDescription('The Target MAC Address Field to be transmitted in the Loopback Message: For unicast MAC Address this is the unicast destination MAC address. For multicast MAC Address, this variable is read-only. This address will be used if the value of radMepTransmitLbmDestIsMepId is no (2). 802.1ag clause 12.14.7.3.2:b.')
radMepTransmitLbmDestMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 21), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmDestMepId.setDescription('The MEPID of another MEP in the same MA to which the LBM is to be sent. This address will be used if the value of radMepTransmitLbmDestIsMepId is yes (3). 802.1ag clause 12.14.7.3.2:b.')
radMepTransmitLbmDestIsMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmDestIsMepId.setDescription('yes (3) indicates that MEPID of the target MEP is used for loopback transmission. no (2) indicates that unicast destination MAC address of the target MEP is used. 802.1ag clause 12.14.7.3.2:b.')
radMepTransmitLbmMassages = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmMassages.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmMassages.setDescription('The number of Loopback messages to be transmitted.')
radMepTransmitLbmVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmVlanPriority.setDescription('The priority to be used in the VLAN tag, if present, in the transmitted frame. The default value is CCM priority. 802.1ag clause 12.14.7.3.2:e')
radMepTransmitLbmVlanDropEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit to be used in the VLAN tag, if present, in the transmitted frame. 802.1ag clause 12.14.7.3.2:e')
radMepLbrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: radMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
radMepLbrInOutOfOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: radMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies received.')
radMepLbmOut = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLbmOut.setStatus('current')
if mibBuilder.loadTexts: radMepLbmOut.setDescription('Total number of Loopback Messages transmitted.')
radMepTransmitLtmTargetMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 29), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLtmTargetMacAddress.setDescription('The Target MAC Address Field to be transmitted in the Link Trace Message: A unicast destination MAC address. This address will be used if the value of radMepTransmitLtmTargetIsMepId is no (2). 802.1ag clause 12.14.7.4.2:c.')
radMepTransmitLtmTargetMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 30), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLtmTargetMepId.setDescription('The MEPID of another MEP in the same MA to which LTM is to be transmitted. This address will be used if the value of radMepTransmitLtmTargetIsMepId is yes (3). 802.1ag clause 12.14.7.4.2:c.')
radMepTransmitLtmTargetIsMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLtmTargetIsMepId.setDescription('yes (3) indicates that MEPID of the target MEP is used for Linktrace transmission. no (2) indicates that unicast destination MAC address of the target MEP is used. 802.1ag clause 12.14.7.4.2:c.')
radMepTransmitLtmTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 32), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64. The TTL field indicates the number of hops remaining to the LTM. Decremented by 1 each Linktrace Responder that handles the LTM. The value received in the LTM is returned in the LTR. If 0 on input, the LTM is not transmitted to the next hop. 802.1ag clause 12.14.7.4.2:b and 21.8.4.')
radMepTransmitLtmActivationCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepTransmitLtmActivationCmd.setStatus('current')
if mibBuilder.loadTexts: radMepTransmitLtmActivationCmd.setDescription("Activation command for starting Loop Trace. Set will be always to 'on' value. After operation was finished, Agent will turn the value to 'off'.")
ethOamService = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2))
ethOamServiceTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1), )
if mibBuilder.loadTexts: ethOamServiceTable.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceTable.setDescription('Service configuration table associated with Services running on a MEP.')
ethOamServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radOamEvcIdx"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "ethOamServiceIdx"))
if mibBuilder.loadTexts: ethOamServiceEntry.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceEntry.setDescription('An entry in the table.')
ethOamServiceIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ethOamServiceIdx.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceIdx.setDescription('This object indicates the Index of the service being accessed.')
ethOamServiceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServiceRowStatus.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceRowStatus.setDescription('This attribute allows to create/delete a row in this table.')
ethOamServicePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServicePriority.setStatus('current')
if mibBuilder.loadTexts: ethOamServicePriority.setDescription('This object determines the priority of the service. It is sent as P bits in an OAM message originated by this service.')
ethOamServicePmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServicePmEnable.setStatus('current')
if mibBuilder.loadTexts: ethOamServicePmEnable.setDescription('This object determines PM (Performance Monitoring) shall be enabled or not for the service.')
ethOamServiceFrameLossRatioThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServiceFrameLossRatioThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceFrameLossRatioThresh.setDescription('This object determines the Frame Loss ratio threshold in exponent of 1/10. That is, a value of 4 means that the threshold is 1E-4.')
ethOamServiceDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServiceDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceDelayThresh.setDescription('This object determines the delay threshold defined for this service, in measurement unit of 0.1 msec.')
ethOamServiceDelayVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServiceDelayVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceDelayVarThresh.setDescription('This object determines the delay variation threshold defined for this service, in measurement unit of 0.1 msec.')
ethOamServiceUnavailRatioThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ethOamServiceUnavailRatioThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceUnavailRatioThresh.setDescription('This object determines the Unavailability ratio threshold in exponent of 1/10. That is, a value of 4 means that the threshold is 1E-4.')
ethOamServiceTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceTxFrames.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceTxFrames.setDescription('Counts the number of frames trnasmitted by since the time the service is up.')
ethOamServiceOverflowTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceOverflowTxFrames.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceOverflowTxFrames.setDescription('The number of times the associated ethOamServiceTxFrames counter has overflowed.')
ethOamServiceFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceFrameLoss.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceFrameLoss.setDescription('Counts the number of frames lost since the time the service is up.')
ethOamServiceOverflowFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceOverflowFrameLoss.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceOverflowFrameLoss.setDescription('The number of times the associated ethOamServiceFrameLoss counter has overflowed.')
ethOamServiceFrameLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceFrameLossRatio.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceFrameLossRatio.setDescription('Indicates the ratio of the lost frames since the time the service is up. The value is the ratio multiplied by 1E10. 0xFFFFFFFF will be returned for ratio greater than 4/10 (40%).')
ethOamServiceElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceElapsedTime.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceElapsedTime.setDescription('Indicates the time elapsed in seconds since the time the service is up.')
ethOamServiceUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceUnavailSec.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceUnavailSec.setDescription('Indicates the number of unavailable seconds since the time the service is up.')
ethOamServiceUnavailRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceUnavailRatio.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceUnavailRatio.setDescription(' Indicates the ratio of the unavailable seconds since the time the service is up. The value is the ratio multiplied by 1E10. 0xFFFFFFFF will be returned for ratio greater than 4/10 (40%).')
ethOamServiceFramesAboveDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceFramesAboveDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceFramesAboveDelay.setDescription('Indicates the number of frames arrived with delay greater than the delay threshold.')
ethOamServiceOverflowFramesAboveDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceOverflowFramesAboveDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceOverflowFramesAboveDelay.setDescription('Indicates the number of times the associated ethOamServiceFramesAboveDelay counter has overflowed.')
ethOamServiceFramesAboveDelayVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceFramesAboveDelayVar.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceFramesAboveDelayVar.setDescription('Indicates the number of frames arrived with delay variation greater than the delay variation threshold.')
ethOamServiceOverflowFramesAboveDelayVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamServiceOverflowFramesAboveDelayVar.setStatus('current')
if mibBuilder.loadTexts: ethOamServiceOverflowFramesAboveDelayVar.setDescription('Indicates the number of times the associated ethOamServiceFramesAboveDelayVar counter has overflowed.')
ethOamSvcCurrentStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2), )
if mibBuilder.loadTexts: ethOamSvcCurrentStatTable.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrentStatTable.setDescription('Service Current Statistics Table.')
ethOamSvcCurrentStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radOamEvcIdx"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "ethOamServiceIdx"))
if mibBuilder.loadTexts: ethOamSvcCurrentStatEntry.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrentStatEntry.setDescription('Current Statistics per service')
ethOamSvcCurrFramesAboveDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesAboveDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesAboveDelayThresh.setDescription('Number of frames that arrived in the current interval at a delay greater than the threshold value defined for the service.')
ethOamSvcCurrFramesBelowDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesBelowDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesBelowDelayThresh.setDescription('Number of frames that arrived in the current interval at a delay lower than or equal to the threshold value defined for the service.')
ethOamSvcCurrFramesAboveDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesAboveDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesAboveDVarThresh.setDescription('Number of frames that arrived in the current interval at a delay variation greater than the threshold value defined for the service.')
ethOamSvcCurrFramesBelowDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesBelowDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesBelowDVarThresh.setDescription('Number of frames that arrived in the current interval at a delay variation lower than or equal to the threshold value defined for the service.')
ethOamSvcCurrFramesTxCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesTxCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesTxCounter.setDescription('Number of trnasmitted frames in the current interval.')
ethOamSvcCurrFramesLossCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrFramesLossCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrFramesLossCounter.setDescription('Number of lost frames in the current interval.')
ethOamSvcCurrMinRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrMinRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrMinRoundTripDelay.setDescription('The mininal value of round trip delay in the current interval. Values units are of 0.1 msec.')
ethOamSvcCurrMaxRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrMaxRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrMaxRoundTripDelay.setDescription('The maximum value of round trip delay in the current interval. Values units are of 0.1 msec.')
ethOamSvcCurrAvgRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrAvgRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrAvgRoundTripDelay.setDescription('The average round trip delay in the current interval. Values units are of 0.1 msec.')
ethOamSvcCurrMaxRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrMaxRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrMaxRoundTripDVar.setDescription('The maximum value of round trip delay variation in the current interval. Values units are of 0.1 msec.')
ethOamSvcCurrAvgRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrAvgRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrAvgRoundTripDVar.setDescription('The average round trip delay variation in the current interval. Values units are of 0.1 msec.')
ethOamSvcCurrElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrElapsedTime.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrElapsedTime.setDescription('The number of seconds that have elapsed since the beginning of the current interval.')
ethOamSvcCurrUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 2, 1, 13), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcCurrUnavailSec.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcCurrUnavailSec.setDescription('The number of seconds that the service was unavailable in the current interval.')
ethOamSvcIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3), )
if mibBuilder.loadTexts: ethOamSvcIntervalTable.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalTable.setDescription('Service Interval Statistics Table.')
ethOamSvcIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radOamEvcIdx"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "ethOamServiceIdx"), (0, "RAD-MIB", "ethOamSvcIntervalNum"))
if mibBuilder.loadTexts: ethOamSvcIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalEntry.setDescription('Interval Statistics per service')
ethOamSvcIntervalNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: ethOamSvcIntervalNum.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalNum.setDescription('The Interval index, which is actualy the Interval number, where 1 is the most recently completed 15 minute interval, and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals exist).')
ethOamSvcIntervalFramesAboveDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 2), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesAboveDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesAboveDelayThresh.setDescription('Number of frames that arrived in a delay greater than the threshold value defined for the service in the selected interval.')
ethOamSvcIntervalFramesBelowDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 3), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesBelowDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesBelowDelayThresh.setDescription('Number of frames that arrived in a delay lower than the threshold value defined for the service in the selected interval.')
ethOamSvcIntervalFramesAboveDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesAboveDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesAboveDVarThresh.setDescription('Number of frames that arrived in a delay variation greater than the threshold value defined for the service in the selected interval.')
ethOamSvcIntervalFramesBelowDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesBelowDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesBelowDVarThresh.setDescription('Number of frames that arrived in a delay variation lower than the threshold value defined for the service in the selected interval.')
ethOamSvcIntervalFramesTxCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesTxCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesTxCounter.setDescription('Number of trnasmitted frames in the selected interval.')
ethOamSvcIntervalFramesLossCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalFramesLossCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalFramesLossCounter.setDescription('Number of lost frames in the selected interval.')
ethOamSvcIntervalMinRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalMinRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalMinRoundTripDelay.setDescription('The mininal value of round trip delay in the selected interval. Values units are of 0.1 msec.')
ethOamSvcIntervalMaxRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalMaxRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalMaxRoundTripDelay.setDescription('The maximum value of round trip delay in the selected interval. Values units are of 0.1 msec.')
ethOamSvcIntervalAvgRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalAvgRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalAvgRoundTripDelay.setDescription('The average round trip delay in the selected interval. Values units are of 0.1 msec.')
ethOamSvcIntervalMaxRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalMaxRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalMaxRoundTripDVar.setDescription('The maximum value of round trip delay variation in the selected interval. Values units are of 0.1 msec.')
ethOamSvcIntervalAvgRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalAvgRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalAvgRoundTripDVar.setDescription('The average round trip delay variation in the selected interval. Values units are of 0.1 msec.')
ethOamSvcIntervalUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 3, 1, 13), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcIntervalUnavailSec.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcIntervalUnavailSec.setDescription('The number of seconds that the service was unavailable in the selected interval.')
ethOamSvcTotalTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4), )
if mibBuilder.loadTexts: ethOamSvcTotalTable.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalTable.setDescription('ETH OAM Service Total (24H) Statistics Table.')
ethOamSvcTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radOamEvcIdx"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "ethOamServiceIdx"))
if mibBuilder.loadTexts: ethOamSvcTotalEntry.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalEntry.setDescription('Total Statistics per service')
ethOamSvcTotalFramesAboveDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 1), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesAboveDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesAboveDelayThresh.setDescription('Number of frames that arrived in a delay greater than the threshold value defined for the service in the last 24H.')
ethOamSvcTotalFramesBelowDelayThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 2), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesBelowDelayThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesBelowDelayThresh.setDescription('Number of frames that arrived in a delay lower than the threshold value defined for the service in the last 24H.')
ethOamSvcTotalFramesAboveDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 3), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesAboveDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesAboveDVarThresh.setDescription('Number of frames that arrived in a delay variation greater than the threshold value defined for the service in the last 24H.')
ethOamSvcTotalFramesBelowDVarThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 4), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesBelowDVarThresh.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesBelowDVarThresh.setDescription('Number of frames that arrived in a delay variation lower than the threshold value defined for the service in the last 24H.')
ethOamSvcTotalFramesTxCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 5), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesTxCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesTxCounter.setDescription('Number of trnasmitted frames in the last 24H.')
ethOamSvcTotalFramesLossCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 6), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalFramesLossCounter.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalFramesLossCounter.setDescription('Number of lost frames in the last 24H.')
ethOamSvcTotalMinRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalMinRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalMinRoundTripDelay.setDescription('The mininal value of round trip delay in the last 24H. Values units are of 0.1 msec.')
ethOamSvcTotalMaxRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalMaxRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalMaxRoundTripDelay.setDescription('The maximum value of round trip delay in the last 24H. Values units are of 0.1 msec.')
ethOamSvcTotalAvgRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalAvgRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalAvgRoundTripDelay.setDescription('The average round trip delay in the last 24H. Values units are of 0.1 msec.')
ethOamSvcTotalMaxRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalMaxRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalMaxRoundTripDVar.setDescription('The maximum value of round trip delay variation in the last 24H. Values units are of 0.1 msec.')
ethOamSvcTotalAvgRoundTripDVar = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalAvgRoundTripDVar.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalAvgRoundTripDVar.setDescription('The average round trip delay variation in the last 24H. Values units are of 0.1 msec.')
ethOamSvcTotalUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 2, 4, 1, 12), PerfTotalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethOamSvcTotalUnavailSec.setStatus('current')
if mibBuilder.loadTexts: ethOamSvcTotalUnavailSec.setDescription('The number of seconds that the service was unavailable in the last 24H.')
radMdTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3), )
if mibBuilder.loadTexts: radMdTable.setStatus('current')
if mibBuilder.loadTexts: radMdTable.setDescription('The MaintenanceDomain table. Each row in the table represents a different maintenance domain. A Maintenance domain is described in 802.1ag (3.22) as the network or the part of the network for which faults in connectivity are to be managed. The boundary of a Maintenance Domain is defined by a set of DSAPs, each of which can become a point of connectivity to a service instance.')
radMdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3, 1), ).setIndexNames((0, "RAD-MIB", "radMdIndex"))
if mibBuilder.loadTexts: radMdEntry.setStatus('current')
if mibBuilder.loadTexts: radMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost upon reboot. It is backed up by stable storage')
radMdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: radMdIndex.setStatus('current')
if mibBuilder.loadTexts: radMdIndex.setDescription('The index to the maintenance domain table.')
radMdFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("dnsLikeName", 2), ("macAddressAndUint", 3), ("charString", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMdFormat.setStatus('current')
if mibBuilder.loadTexts: radMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
radMdName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 43))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMdName.setStatus('current')
if mibBuilder.loadTexts: radMdName.setDescription('The Maintenance Domain name. The type/format of this object is determined by the value of the radMdNameType object. Each Maintenance Domain has unique name amongst all those used or available to a service provider or operator. It facilitates easy identification of administrative responsibility for each Maintenance Domain.')
radMdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: radMdRowStatus.setDescription('This attribute allows to create/delete a row in this table. The writable columns in a row can not be changed if the row is active. All columns must have a valid value before a row can be activated.')
radMepLtrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4), )
if mibBuilder.loadTexts: radMepLtrTable.setStatus('current')
if mibBuilder.loadTexts: radMepLtrTable.setDescription('This table contains a list of Linktrace replies received by a specific MEP in response to a linktrace message. ')
radMepLtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "radMepLtrReceiveOrder"))
if mibBuilder.loadTexts: radMepLtrEntry.setStatus('current')
if mibBuilder.loadTexts: radMepLtrEntry.setDescription('The LinktraceReply table entry.')
radMepLtrReceiveOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: radMepLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: radMepLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR Transaction Identifier field value. radMepLtrReceiveOrder are assigned sequentially from 1, in the order that the Linktrace Initiator received the LTRs.')
radMepLtrTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrTtl.setStatus('current')
if mibBuilder.loadTexts: radMepLtrTtl.setDescription('TTL field value for a returned LTR.')
radMepLtrMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrMacAddr.setStatus('current')
if mibBuilder.loadTexts: radMepLtrMacAddr.setDescription('The MAC address in the header of the returned LTR.')
radMepLtrRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrRelay.setStatus('current')
if mibBuilder.loadTexts: radMepLtrRelay.setDescription('The value returned in the Relay Action field: rlyHit - the LTM reached an MP whose MAC address matches the target MAC address. rlyFdb - the Egress Port was determined by consulting the Filtering Database. rlyMpdb - the Egress Port was determined by consulting the MIP CCM Database. 802.1ag clauses 12.14.7.5.3:g and 20.36.2.5')
radMepLtrIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ingNoTlv", 1), ("ingOk", 2), ("ingDown", 3), ("ingBlocked", 4), ("ingVid", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrIngress.setStatus('current')
if mibBuilder.loadTexts: radMepLtrIngress.setDescription("The value returned in the Ingress Action Field of the LTM. ingNoTlv - no Reply Ingress TLV was returned in the LTM. ingOK - the target data frame would be passed through to the MAC Relay Entity. ingDown - the Bridge Port's MAC_Operational parameter is false. ingBlocked - the target data frame would not be forwarded if received on this port. ingVid - the ingress port is not in the members of the LTM's VID, and ingress filtering is enabled, so the target data frame would be filtered by the ingress filtering. 802.1ag clauses 12.14.7.5.3:k and 20.36.2.6")
radMepLtrIngressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 6), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: radMepLtrIngressPortIdSubtype.setDescription('The format of the Ingress Port ID. If the radMepLtrIngress object contains the value egrNoTlv(1), then the contents of this object are meaningless. 802.1ag clauses 12.14.7.5.3:m and 20.36.2.8')
radMepLtrIngressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: radMepLtrIngressPortId.setDescription('Ingress Port ID. This is an alpha-numeric string that contains a specific identifier for the port. The format of this object is determined by the value of the radMepLtrIngressPortIdSubtype object. If the radMepLtrIngress object contains the value ingNoTlv(1), then the contents of this object are meaningless. 802.1ag clauses 12.14.7.5.3:n and 20.36.2.9')
radMepLtrEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("egrNoTlv", 1), ("egrOK", 2), ("egrDown", 3), ("egrBlocked", 4), ("egrVid", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrEgress.setStatus('current')
if mibBuilder.loadTexts: radMepLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM. The value egrNoTlv(1) indicates that no Reply Egress TLV was returned in the LTM. 802.1ag clauses 12.14.7.5.3:o and 20.36.2.10')
radMepLtrEgressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 9), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: radMepLtrEgressPortIdSubtype.setDescription('The format of the egress Port ID. If the radMepLtrEgress object contains the value egrNoTlv(1), then the contents of this object are meaningless. 802.1ag clauses 12.14.7.5.3:q and 20.36.2.12')
radMepLtrEgressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: radMepLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by the value of the radMepLtrEgressPortIdSubtype object. If the radMepLtrEgress object contains the value egrNoTlv(1), then the contents of this object are meaningless. 802.1ag clauses 12.14.7.5.3:r and 20.36.2.13')
radMepCcStatusTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5), )
if mibBuilder.loadTexts: radMepCcStatusTable.setStatus('current')
if mibBuilder.loadTexts: radMepCcStatusTable.setDescription('This table contains a list of CC Status received by a specific MEP from different Remote MEPs. ')
radMepCcStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5, 1), ).setIndexNames((0, "RAD-MIB", "radOamIdx1"), (0, "RAD-MIB", "radMepIdx"), (0, "RAD-MIB", "radMepRemoteMepIdx"))
if mibBuilder.loadTexts: radMepCcStatusEntry.setStatus('current')
if mibBuilder.loadTexts: radMepCcStatusEntry.setDescription('An entry in the CC Status Table.')
radMepRemoteMepIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: radMepRemoteMepIdx.setStatus('current')
if mibBuilder.loadTexts: radMepRemoteMepIdx.setDescription('This is a running index for arriving CC messages (from different Remote MEPs) for a specific MEP ID.')
radMepCcStatusRemMepId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radMepCcStatusRemMepId.setStatus('current')
if mibBuilder.loadTexts: radMepCcStatusRemMepId.setDescription('This attribute indicates the Remote MEP ID from which the CC messages has arrived.')
radMepCcStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("fail", 2), ("ok", 3), ("mismerge", 4), ("unexpectedMep", 5), ("unexpectedMeLevel", 6), ("unexpectedPeriod", 7), ("rdi", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepCcStat.setStatus('current')
if mibBuilder.loadTexts: radMepCcStat.setDescription("This object indicates the Continuity Check (CC) status (ITU-T Y.1731, Appendix I): mismerge - A MEP detects a Mismerge condition when a CCM frame arrives with the correct MEG level, but incorrect MEG ID. unexpectedMep -A MEP detects an Unexpected MEP condition when a CCM frame arrives with the correct MEG level, the correct MEG ID, but an unexpected MEP ID, which includes the MEP's own MEP ID. unexpectedMeLevel - A MEP detects an Unexpected MEG Level condition when a CCM frame arrives with incorrect MEG Level. Incorrect MEG Level is less than the MEP's own MEG level. unexpectedPeriod - A MEP detects an Unexpected Period condition when a CCM frame arrives with a correct MEG level. a correct MEG ID, a correct MEP ID, but with the Period field value different from the MEP's own CCM transmission period. rdi - A MEP detects RDI when it receives a CCM frame with the RDI field set.")
radMepCcStatusMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 5, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radMepCcStatusMacAddr.setStatus('current')
if mibBuilder.loadTexts: radMepCcStatusMacAddr.setDescription('This object indicates the MAC Address in the CC Status message received.')
ethOamStdEtherType = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethOamStdEtherType.setStatus('current')
if mibBuilder.loadTexts: ethOamStdEtherType.setDescription('The Standard Ether Type in an OAM message. This object will be RW until a formal value will be issued for standard Ethernet Type. When such Standard will exist, this object will be supported RO to reflect the Standard value.')
ethOamStdMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 7), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethOamStdMacAddress.setStatus('current')
if mibBuilder.loadTexts: ethOamStdMacAddress.setDescription('The Standard MAC Address in an OAM message. This object will be RW until a formal value will be issued for standard MAC Address. When such Standard will exist, this object will be supported RO to reflect the Standard value.')
dot1agXCfmMdTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 8), )
if mibBuilder.loadTexts: dot1agXCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMdTable.setDescription('The Maintenance Domain table. Each row in the table represents a different maintenance association.')
dot1agXCfmMdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 8, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"))
if mibBuilder.loadTexts: dot1agXCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMdEntry.setDescription('The Maintenance Domain table entry.')
dot1agXCfmMdProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("preStandard", 1), ("standard", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agXCfmMdProtocol.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMdProtocol.setDescription(' .')
dot1agXCfmMepTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 9), )
if mibBuilder.loadTexts: dot1agXCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepTable.setDescription('The Maintenance Association End Point (MEP) table.')
dot1agXCfmMepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 9, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"))
if mibBuilder.loadTexts: dot1agXCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepEntry.setDescription('The MEP table entry ')
dot1agXCfmMepContinuityVerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("disabled", 2), ("ccBased", 3), ("lbBased", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agXCfmMepContinuityVerMode.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepContinuityVerMode.setDescription('This object determines the OAM behavior of the MEP: disabled - no Continuity Verification is done cc_based - Continuity Verification is done based on incoming CC messages lb_based - Continuity Verification is done based on loopback messages.')
dot1agXCfmMepDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agXCfmMepDestAddrType.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepDestAddrType.setDescription('This object determines if the OAM messages are sent to user defined unicast address, or to RAD proprietary multicast address.')
dot1agXCfmMepDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 9, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agXCfmMepDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepDestMacAddr.setDescription('This object determines the MAC address that OAM packets are sent to.')
dot1agXCfmMepDbTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 10), )
if mibBuilder.loadTexts: dot1agXCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepDbTable.setDescription('The MEP DB table')
dot1agXCfmMepDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 10, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: dot1agXCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepDbEntry.setDescription('The MEP Database table entry. ')
dot1agXCfmMepCcStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("fail", 2), ("ok", 3), ("mismerge", 4), ("unexpectedMep", 5), ("unexpectedMeLevel", 6), ("unexpectedPeriod", 7), ("rdi", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agXCfmMepCcStat.setStatus('current')
if mibBuilder.loadTexts: dot1agXCfmMepCcStat.setDescription("This object indicates the Continuity Check (CC) status (ITU-T Y.1731, Appendix I): mismerge - A MEP detects a Mismerge condition when a CCM frame arrives with the correct MEG level, but incorrect MEG ID. unexpectedMep -A MEP detects an Unexpected MEP condition when a CCM frame arrives with the correct MEG level, the correct MEG ID, but an unexpected MEP ID, which includes the MEP's own MEP ID. unexpectedMeLevel - A MEP detects an Unexpected MEG Level condition when a CCM frame arrives with incorrect MEG Level. Incorrect MEG Level is less than the MEP's own MEG level. unexpectedPeriod - A MEP detects an Unexpected Period condition when a CCM frame arrives with a correct MEG level. a correct MEG ID, a correct MEP ID, but with the Period field value different from the MEP's own CCM transmission period. rdi - A MEP detects RDI when it receives a CCM frame with the RDI field set.")
ethIfRing = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4))
ethIfRingEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 0))
ethIfRingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1), )
if mibBuilder.loadTexts: ethIfRingTable.setStatus('current')
if mibBuilder.loadTexts: ethIfRingTable.setDescription('Ethernet Ring Table.')
ethIfRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1), ).setIndexNames((0, "RAD-MIB", "ethIfRingIdx"))
if mibBuilder.loadTexts: ethIfRingEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfRingEntry.setDescription('An entry in the table.')
ethIfRingIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ethIfRingIdx.setStatus('current')
if mibBuilder.loadTexts: ethIfRingIdx.setDescription('This object is an Index that can indicate Slot, Ring, Cnfg etc., according to the device used. When NA, 1 will be used.')
ethIfRingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("down", 2), ("up", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfRingAdminStatus.setDescription('This object denotes the Ethernet Ring administrative status.')
ethIfRingPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingPorts.setStatus('current')
if mibBuilder.loadTexts: ethIfRingPorts.setDescription('The set of ports which are assigned to be ring members. The default value of this object is a string of zeros.')
ethIfRingOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("open", 2), ("close", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfRingOperStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfRingOperStatus.setDescription('This object indicates the Ethernet Ring operational status.')
ethIfRingKeepAliveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingKeepAliveInterval.setStatus('current')
if mibBuilder.loadTexts: ethIfRingKeepAliveInterval.setDescription('This parameter indicates the period of time (in msec.) between two consequent Keep Alive messages.')
ethIfRingKeepAliveThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingKeepAliveThresh.setStatus('current')
if mibBuilder.loadTexts: ethIfRingKeepAliveThresh.setDescription('This parameter indicates the maximum number of missed Keep Alive answer messages acceptable, after which link status will be failed.')
ethIfRingKeepAliveVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingKeepAliveVlanId.setStatus('current')
if mibBuilder.loadTexts: ethIfRingKeepAliveVlanId.setDescription('Dedicated VLAN ID for keep alive messages.')
ethIfRingMultiCastVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingMultiCastVlanId.setStatus('current')
if mibBuilder.loadTexts: ethIfRingMultiCastVlanId.setDescription('Dedicated VLAN ID for multicast messages.')
ethIfRingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfRingRowStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfRingRowStatus.setDescription('Implement creation/deletion of rings in the device.')
ethIfRingStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 4, 0, 1)).setObjects(("RAD-MIB", "ethIfRingOperStatus"))
if mibBuilder.loadTexts: ethIfRingStatusChange.setStatus('current')
if mibBuilder.loadTexts: ethIfRingStatusChange.setDescription('This trap indicates that the status of the Ethernet Ring has been changed.')
ethIfStorming = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5))
ethIfStormTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1), )
if mibBuilder.loadTexts: ethIfStormTable.setStatus('current')
if mibBuilder.loadTexts: ethIfStormTable.setDescription('Ethernet Storming Table.')
ethIfStormEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1), ).setIndexNames((0, "RAD-MIB", "ethIfStormCnfgIdx"), (0, "RAD-MIB", "ethIfStormIfIdx"), (0, "RAD-MIB", "ethIfStormDirection"), (0, "RAD-MIB", "ethIfStormPacketType"))
if mibBuilder.loadTexts: ethIfStormEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfStormEntry.setDescription('An entry in the table.')
ethIfStormCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ethIfStormCnfgIdx.setStatus('current')
if mibBuilder.loadTexts: ethIfStormCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
ethIfStormIfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: ethIfStormIfIdx.setStatus('current')
if mibBuilder.loadTexts: ethIfStormIfIdx.setDescription('A unique index of the ethernet interface/port.')
ethIfStormDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("ingress", 2), ("egress", 3))))
if mibBuilder.loadTexts: ethIfStormDirection.setStatus('current')
if mibBuilder.loadTexts: ethIfStormDirection.setDescription("This object indicates the port's Storm Direction.")
ethIfStormPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 4), Bits().clone(namedValues=NamedValues(("unknownUnicast", 0), ("broadcast", 1), ("multicast", 2))))
if mibBuilder.loadTexts: ethIfStormPacketType.setStatus('current')
if mibBuilder.loadTexts: ethIfStormPacketType.setDescription('Packet Type on which Storming operations will be performed.')
ethIfStormCtrlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfStormCtrlEnable.setStatus('current')
if mibBuilder.loadTexts: ethIfStormCtrlEnable.setDescription('This object indicates if the Storm Controling is Enabled or Disabled for the relevant entry.')
ethIfStormMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 5, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfStormMaxRate.setStatus('current')
if mibBuilder.loadTexts: ethIfStormMaxRate.setDescription('This object indicates the Maximum Rate at which Storming packets are forwarded, in Kbps.For some devices the units are PPS(Packets Per Second ) or kilobytes per second.')
ethIfOamEfm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6))
dot3OamEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 0))
dot3OamOperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 0, 1)).setObjects(("DOT3-OAM-MIB", "dot3OamOperStatus"))
if mibBuilder.loadTexts: dot3OamOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: dot3OamOperStatusChange.setDescription('This trap is sent when OAM EFM Link goes Up or Down. Up - is considered when dot3OamOperStatus value changes to operational(9) from any other value. Down - is considered when dot3OamOperStatus value changes from operational(9) to any other value.')
dot3OamPeerEvent = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 0, 2)).setObjects(("RAD-MIB", "dot3OamXPeerState"))
if mibBuilder.loadTexts: dot3OamPeerEvent.setStatus('current')
if mibBuilder.loadTexts: dot3OamPeerEvent.setDescription('This trap is sent when value of dot3OamXPeerState changes from any value to one of the following values: linkFault, dyingGasp, criticalEvent. This trap has no recovery (clearing value).')
dot3OamDescrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1), )
if mibBuilder.loadTexts: dot3OamDescrTable.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrTable.setDescription('This table supports definitions of Descriptors (profiles) of OAM EFM Links.')
dot3OamDescrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1), ).setIndexNames((0, "RAD-MIB", "dot3OamDescrId"))
if mibBuilder.loadTexts: dot3OamDescrEntry.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrEntry.setDescription('Each entry corresponds to a single OAM EFM Descriptor (profile). Each Descriptor contains a set of OAM EFM Link configuration parameters. The configuration parameters are applied to the OAM EFM Links referencing this Descriptor (see dot3OamXDescrId object). Descriptors may be created/deleted using the row creation/deletion mechanism via dot3OamDescrRowStatus. If an active entry is referenced in dot3OamXDescrId, the entry MUST remain active until all references are removed.')
dot3OamDescrId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot3OamDescrId.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrId.setDescription('This object is the unique index associated with this Descriptor (profile). Entries in this table are referenced via the object dot3OamXDescrId in dot3OamXEntry.')
dot3OamDescrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot3OamDescrRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrRowStatus.setDescription('This object controls creation/deletion of the associated entry in this table per the semantics of RowStatus. If an active entry is referenced in dot3OamXDescrId, the entry MUST remain active until all references are removed.')
dot3OamDescrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passive", 1), ("active", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot3OamDescrMode.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrMode.setDescription("This object controls the mode of OAM operation for an Ethernet-like interface referencing this Descriptor. OAM on Ethernet interfaces may be in 'active' mode or 'passive' mode. These two modes differ in that active mode provides additional capabilities to initiate monitoring activities with the remote OAM peer entity, while passive mode generally waits for the peer to initiate OAM actions with it. As an example, an active OAM entity can put the remote OAM entity in a loopback state, where a passive OAM entity cannot.")
dot3OamDescrLbRxOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ignore", 1), ("process", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot3OamDescrLbRxOperation.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrLbRxOperation.setDescription('Since OAM loopback is a disruptive operation (user traffic does not pass), this object provides a mechanism to provide control: whether received OAM loopback commands are processed or ignored, for the OAM Link referencing this Descriptor. When the value is ignore(1), received loopback commands are ignored. When the value is process(2), received loopback commands are processed. The default value is to ignore loopback commands (ignore(1)).')
dot3OamDescrRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot3OamDescrRateLimit.setStatus('current')
if mibBuilder.loadTexts: dot3OamDescrRateLimit.setDescription('This object defines how many OAM frames can be sent per second (maximum) for an OAM EFM Link referencing this Descriptor.')
dot3OamXTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 2), )
if mibBuilder.loadTexts: dot3OamXTable.setStatus('current')
if mibBuilder.loadTexts: dot3OamXTable.setDescription('This table is an extension of dot3OamTable of standard DOT3-OAM-MIB.')
dot3OamXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 2, 1), )
dot3OamEntry.registerAugmentions(("RAD-MIB", "dot3OamXEntry"))
dot3OamXEntry.setIndexNames(*dot3OamEntry.getIndexNames())
if mibBuilder.loadTexts: dot3OamXEntry.setStatus('current')
if mibBuilder.loadTexts: dot3OamXEntry.setDescription('An entry in dot3OamXTable.')
dot3OamXDescrId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3OamXDescrId.setStatus('current')
if mibBuilder.loadTexts: dot3OamXDescrId.setDescription('This object points to an entry of dot3OamDescrTable (dot3OamDescrId), which defines part of the configuration parameters for this OAM EFM Link. As long as one of the OAM EFM Links refers an entry in the dot3OamDescrTable, this entry cannot be removed. When an OAM EFM Link supports this object (RW), the standard MIB objects of: dot3OamMode (parallel to dot3OamDescrMode) and dot3OamLoopbackIgnoreRx (parallel to dot3OamDescrLbRxOperation) will be supported by Agent RO.')
dot3OamXPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("operational", 2), ("linkFault", 3), ("dyingGasp", 4), ("criticalEvent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3OamXPeerState.setStatus('current')
if mibBuilder.loadTexts: dot3OamXPeerState.setDescription("This object reports the state of the Peer of the OAM EFM Link. unknown - at the initialization of the device, or after Reset, when there is still no data about the peer's state. operational - usually after unknown state, when device senses that peer is OK. linkFault - Loss of Signal is detected by the receiver. dyingGasp - Unrecoverable condition has occurred (e.g power failure) criticalEvent - Unspecified Critical Event has occured.")
ethIfMacLayer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7))
ethIfMacLayerEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 0))
ethIfSrcMacCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1), )
if mibBuilder.loadTexts: ethIfSrcMacCtrlTable.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlTable.setDescription('This table supports source MAC addresses control parameters per interface. Source MAC control will be used mainly for security. Only packets with certain source MAC Addresses will be allowed to access the device. The source MAC addresses can be static or learned. The static addresses will be defined by the user in another table: ethIfSrcMacCtrlAddrTable. The learned addresses will exist in the ethIfSrcMacCtrlAddrTable as well.')
ethIfSrcMacCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1), ).setIndexNames((0, "RAD-MIB", "ethIfSrcMacCtrlIndex"), (0, "RAD-MIB", "ethIfSrcMacCtrlIdx2"))
if mibBuilder.loadTexts: ethIfSrcMacCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlEntry.setDescription('An entry in the table.')
ethIfSrcMacCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ethIfSrcMacCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlIndex.setDescription('The index of the MAC Layer interface supporting source MAC control feature. It may be the ifIndex of the ETH/Bridge Port.')
ethIfSrcMacCtrlIdx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: ethIfSrcMacCtrlIdx2.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlIdx2.setDescription('A second index that can be used. For example: The VLAN ID for which the source MAC control feature is supported. When this index is not in use, its value will be: 9999.')
ethIfSrcMacCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrl.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrl.setDescription('Enable or disable the source MAC control on the current interface. The device should not enable source MAC control if for the current interface there are more than ethIfSrcMacCtrlMaxPermitAddr addresses in the ethIfSrcMacCtrlAddrTable. Default value will be: disable (2).')
ethIfSrcMacCtrlMaxPermitAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlMaxPermitAddr.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlMaxPermitAddr.setDescription('This is the maximum number of permitted MAC addresses (static and learned) for the current interface.')
ethIfSrcMacCtrlCurNumPermitAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfSrcMacCtrlCurNumPermitAddr.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlCurNumPermitAddr.setDescription('This is the number of source MAC addresses currently permitted for the current interface.')
ethIfSrcMacCtrlFlushAddrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlFlushAddrCmd.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlFlushAddrCmd.setDescription("When set to on (3) this command will erase all the learned addresses and invalid addresses of the selected interface in the ethIfSrcMacCtrlAddrTable. After operation is finished, Agent will turn the value to 'off'.")
ethIfSrcMacCtrlAging = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlAging.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAging.setDescription('The timeout period in seconds for aging out dynamically learned source MAC addresses. Valid Values: 0 - disable 10-1000000')
ethIfSrcMacCtrlLocking = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("unlock", 2), ("lock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlLocking.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlLocking.setDescription('When set to lock (3) this command will lock the Source MAC Address learning. No more learned addresses will be added to the ethIfSrcMacCtrlAddrTable. When set to unlock (2) this command will unlock the Source MAC Address learning. Learned addresses will be added to the ethIfSrcMacCtrlAddrTable but the number of addresses in the table will not exceed ethIfSrcMacCtrlMaxPermitAddr. Default value is: unlock (2).')
ethIfSrcMacCtrlViolationAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("drop", 2), ("dropNotify", 3), ("shutdown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlViolationAction.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlViolationAction.setDescription('Determines the action that the device will take upon security violation. drop(2) - the violating packets will be dropped. dropNotify (3)- the violating packets will be dropped and notifications will be generated. Notifications may be for example: SNMP Traps, Syslog messages and log file new entries. shutdown (4) - the interface will be forced to shut down.')
ethIfSrcMacCtrlLastViolatingAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlLastViolatingAddr.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlLastViolatingAddr.setDescription('This object indicates the last MAC address that violated the security on the current interface. If no violation, the agent will return: 00-00-00-00-00-00 .')
ethIfSrcMacCtrlPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("shutdown", 2), ("secureActive", 3), ("secureInactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfSrcMacCtrlPortStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlPortStatus.setDescription('This object represents the operational status of the MAC Control feature on an interface. shutdown(2) - This indicates that the port is shutdown due to security violation. secureActive (3) - This indicates that the MAC Control interface security is operational and this interface is not shutdown due to security violation. secureInactive (4)- This indicates that the MAC Control is not operational.')
ethIfSrcMacCtrlAddrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2), )
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrTable.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrTable.setDescription('This table shows which MAC Addresses are permitted when the source MAC control is enabled and which non permitted MAC Addresses attempted to access the current interface. It contains static source MAC Addresses as well as learned MAC Addresses. The user can configure Static permitted source MAC Addresses via this table.')
ethIfSrcMacCtrlAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1), ).setIndexNames((0, "RAD-MIB", "ethIfSrcMacCtrlAddrIndex"), (0, "RAD-MIB", "ethIfSrcMacCtrlAddr"), (0, "RAD-MIB", "ethIfSrcMacCtrlAddrIdx3"))
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrEntry.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrEntry.setDescription('An entry in the table.')
ethIfSrcMacCtrlAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrIndex.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrIndex.setDescription('The index of the interface for which the source MAC addresses exist in this table. It may be the ifIndex of the ETH/Bridge Port.')
ethIfSrcMacCtrlAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1, 2), MacAddress())
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddr.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddr.setDescription('A unicast source MAC address that was learned or statically configured for the current interface. Packets with this source MAC address will be accepted by the device.')
ethIfSrcMacCtrlAddrIdx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1, 3), Unsigned32())
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrIdx3.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrIdx3.setDescription('A third index that can be used. For example: The VLAN ID for which the source MAC control feature is supported. When this index is not in use, its value will be: 9999.')
ethIfSrcMacCtrlAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrRowStatus.setDescription('This MIB object will be used in order to create/delete a static row or delete an address that is not allowed to access the current interface (ethIfSrcMacCtrlAddrStatus= invalid(2)). Device will add the learned addresses to this table. It will not be possible to add a new static entry to this table while the number of existing rows is equal or more than ethIfSrcMacCtrlMaxPermitAddr. When ethIfSrcMacCtrl = enabled (3), the device will add learned entries only up to ethIfSrcMacCtrlMaxPermitAddr.')
ethIfSrcMacCtrlAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5))).clone(namedValues=NamedValues(("invalid", 2), ("learned", 3), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrStatus.setStatus('current')
if mibBuilder.loadTexts: ethIfSrcMacCtrlAddrStatus.setDescription('The status of this entry. The meanings of the values are: invalid (2) - the current address is not allowed to access this interface. learned(3) - the current address was learned. mgmt (5) - the current address is static. It may exist in the MAC Table.')
ethIfMacAccessViolation = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 7, 0, 1)).setObjects(("IF-MIB", "ifDescr"), ("RAD-MIB", "ethIfSrcMacCtrlLastViolatingAddr"))
if mibBuilder.loadTexts: ethIfMacAccessViolation.setStatus('current')
if mibBuilder.loadTexts: ethIfMacAccessViolation.setDescription('This trap indicates that an Access Violation occurred.')
mibBuilder.exportSymbols("RAD-MIB", atmSysConfigCellTest=atmSysConfigCellTest, prtMl4OosExitThreshold=prtMl4OosExitThreshold, radFcd155EwAPS=radFcd155EwAPS, radTrimBrg16=radTrimBrg16, agnStationClockCard=agnStationClockCard, atmIntervalDateDate=atmIntervalDateDate, atmGenSysSelfTestResult=atmGenSysSelfTestResult, radOp4E1LNew=radOp4E1LNew, agnCFlipNetEventOSD=agnCFlipNetEventOSD, atmLoopbackVcErrSessions=atmLoopbackVcErrSessions, dsx1XCurrentTable=dsx1XCurrentTable, radKM2100=radKM2100, atmVcIntervalShaperClp1Discards=atmVcIntervalShaperClp1Discards, sysDclSwDownloadSrc=sysDclSwDownloadSrc, sysCnfgTable=sysCnfgTable, radAce2005=radAce2005, ip2IfMplsRxLabelEnable=ip2IfMplsRxLabelEnable, prtPhMlCAS=prtPhMlCAS, atmVcCurrentContinuityLoss=atmVcCurrentContinuityLoss, agnSigProfile=agnSigProfile, atmVpIntervalRxRDI=atmVpIntervalRxRDI, radAsmi52L=radAsmi52L, prtPerfElapsedTime=prtPerfElapsedTime, mdlSAlrCodeDescription=mdlSAlrCodeDescription, radOp4T1NG1=radOp4T1NG1, prtExPh1MlRxSensitivity=prtExPh1MlRxSensitivity, ifPerfHighCounterPart=ifPerfHighCounterPart, prtExHsrSltIdx=prtExHsrSltIdx, lagCnfgIdx=lagCnfgIdx, swdlStatusSubSystem=swdlStatusSubSystem, dsx1PortFunction=dsx1PortFunction, atmLoopbackVpEntry=atmLoopbackVpEntry, prtDestDimIdx=prtDestDimIdx, prtGenType=prtGenType, ifTeQosIdx3=ifTeQosIdx3, ifCreateNumber=ifCreateNumber, atmLoopbackVcIvlOperStatus=atmLoopbackVcIvlOperStatus, atmVpPMCurrentSECB=atmVpPMCurrentSECB, prtIpParamFloodedRateLimit=prtIpParamFloodedRateLimit, ip2IfComfortNoiseGen=ip2IfComfortNoiseGen, dsx1DataStreamStatTable=dsx1DataStreamStatTable, prtExPVc4MaxRate=prtExPVc4MaxRate, chasVersion=chasVersion, prtExTreLan=prtExTreLan, prtExPhPlDlciTxBc=prtExPhPlDlciTxBc, prtExPVc4HuntGroupIdx=prtExPVc4HuntGroupIdx, atmAceAlarmPlcpP1P2=atmAceAlarmPlcpP1P2, prtBertPattern=prtBertPattern, tftpTotalTimeOut=tftpTotalTimeOut, prtPhyIntervalES=prtPhyIntervalES, maskingOperation=maskingOperation, prtFrRxDcrdCongAllFr=prtFrRxDcrdCongAllFr, prtExHsrOperMode=prtExHsrOperMode, prtFrStatisPrtIdx=prtFrStatisPrtIdx, prtIn7p8VcPbxSignalMode=prtIn7p8VcPbxSignalMode, agnCnfgAlrReportEntry=agnCnfgAlrReportEntry, prtExHs4CnfgEntry=prtExHs4CnfgEntry, prtExLs6DataBits=prtExLs6DataBits, atmVpIntervalGcra0Violations=atmVpIntervalGcra0Violations, sysCMatrixMode=sysCMatrixMode, agnDlciPriority=agnDlciPriority, prtPhyCurrentLOF=prtPhyCurrentLOF, prtExPhPlModemStatus=prtExPhPlModemStatus, ethOamServiceEntry=ethOamServiceEntry, radSPS6=radSPS6, prtSAlarmInvert=prtSAlarmInvert, radRTEM=radRTEM, atmNteSysLogClearAll=atmNteSysLogClearAll, radMepTransmitLbmDestIsMepId=radMepTransmitLbmDestIsMepId, radBridgeCurrentTable=radBridgeCurrentTable, radIpMux16=radIpMux16, agnCnfgAlrTable=agnCnfgAlrTable, agnGlobalAlarmMask=agnGlobalAlarmMask, dsx1CurrentFEBE=dsx1CurrentFEBE, radBridgeIPXRipForwardType=radBridgeIPXRipForwardType, prtExVc2TransGain=prtExVc2TransGain, radBridgePortCnfgMngFlow=radBridgePortCnfgMngFlow, ip2IfCodingLaw=ip2IfCodingLaw, agnCnfgAlrReportTable=agnCnfgAlrReportTable, sysCClkSSubsystemSlot=sysCClkSSubsystemSlot, agnCLoadCnfgIdxCmd=agnCLoadCnfgIdxCmd, atmVcIntervalClp0Discards=atmVcIntervalClp0Discards, pLinkPortNu=pLinkPortNu, prtInLs2LinkTo=prtInLs2LinkTo, prtDs3IfTimeElapsed=prtDs3IfTimeElapsed, physicalConnector=physicalConnector, prtExPhPlLRate=prtExPhPlLRate, wfqSchedulingMode=wfqSchedulingMode, qProfileTable=qProfileTable, prtBdbandRowStatus=prtBdbandRowStatus, radBridgePortVlanMemberRowStatus=radBridgePortVlanMemberRowStatus, dsx1CurrentRAI=dsx1CurrentRAI, agnSigProfileEntry=agnSigProfileEntry, prtExVcPbxTsPrtIdx=prtExVcPbxTsPrtIdx, ifCreateEntityType=ifCreateEntityType, radFcdE1A=radFcdE1A, prtExTsPrtIdx=prtExTsPrtIdx, prtExTsTxIoSignaling=prtExTsTxIoSignaling, prtExHs4TsSltIdx=prtExHs4TsSltIdx, pLinkSltIdx=pLinkSltIdx, prtExHs4SltIdx=prtExHs4SltIdx, prtIsdnEndpointSltIdx=prtIsdnEndpointSltIdx, statMdlGen=statMdlGen, prtIpParamHostIP=prtIpParamHostIP, agnCurrClkPort=agnCurrClkPort, ip2IfCurrentStatMaxDelayVar=ip2IfCurrentStatMaxDelayVar, agnFunction=agnFunction, radVmux314=radVmux314, hostIP=hostIP, agnCFlipNetEventActive=agnCFlipNetEventActive, prtIpParamRingAdjacentMacAddr=prtIpParamRingAdjacentMacAddr, invNameXC=invNameXC, agnStatNoOfUploadedIntervals=agnStatNoOfUploadedIntervals, prtExPhPlClkMode=prtExPhPlClkMode, dsx1IntervalLOMF=dsx1IntervalLOMF, atmAceAlarmPlcpFEBE=atmAceAlarmPlcpFEBE, ip2IfStatMinJittBufLevel=ip2IfStatMinJittBufLevel, sysSInvertedAlr=sysSInvertedAlr, prtExHsfClkMode=prtExHsfClkMode, agnSAlrStatus=agnSAlrStatus, ip2IfConnectionMode=ip2IfConnectionMode, prtDs3IntervalBPV=prtDs3IntervalBPV, qInternalProfileWredDropAllThresh=qInternalProfileWredDropAllThresh, prtDs3IntervalLOC=prtDs3IntervalLOC, radAsmi450R768=radAsmi450R768, dsx1TotalLOFC=dsx1TotalLOFC, atmConfVpCCDirection=atmConfVpCCDirection, atmGenSysLogTable=atmGenSysLogTable, prtExVcPbxTsSltIdx=prtExVcPbxTsSltIdx, modlParamEntry=modlParamEntry, cmprSltIdx=cmprSltIdx, prtExPVc4SigPacketInterval=prtExPVc4SigPacketInterval, mdlPbxFraSignalMode=mdlPbxFraSignalMode, trapTable=trapTable, tftpError=tftpError, agnParametersValueChanged=agnParametersValueChanged, dhcpClientLeaseExpirationTime=dhcpClientLeaseExpirationTime, prtExVc2VAD=prtExVc2VAD, atmVcIntervalTotalDiscards=atmVcIntervalTotalDiscards, radMepLtrRelay=radMepLtrRelay, radOptimuxT3=radOptimuxT3, mdlSTable=mdlSTable, prtExPhPlCcittCrc=prtExPhPlCcittCrc, srvResetStatsCmd=srvResetStatsCmd, prtT1E1FdlMsgSlt=prtT1E1FdlMsgSlt, agnCFlipNetEventType=agnCFlipNetEventType, agnCSaveNetFlipDbCmd=agnCSaveNetFlipDbCmd, atmIfCurrentRxCells=atmIfCurrentRxCells, radLA110=radLA110, radBridgeMaskDest=radBridgeMaskDest, prtVc2PrtIdx=prtVc2PrtIdx, prtExPVc4FrameSize=prtExPVc4FrameSize, hostRowStatus=hostRowStatus, agnCFlipNetEventDayType=agnCFlipNetEventDayType, atmVpCurrentContinuityLoss=atmVpCurrentContinuityLoss, radBridgeIPXSapTableEntry=radBridgeIPXSapTableEntry, prtIsdnDirectoryRowStatus=prtIsdnDirectoryRowStatus, prtTestTimeout=prtTestTimeout, atmIntervalDateEntry=atmIntervalDateEntry, atmSysIntervalEntry=atmSysIntervalEntry, prtGenTestDuration=prtGenTestDuration, prtExPh1MlTsTestDuration=prtExPh1MlTsTestDuration, prtExHs4TsCnfgTable=prtExHs4TsCnfgTable, wrDhcpPoolName=wrDhcpPoolName, radFcd622=radFcd622, atmNteProtectionMode=atmNteProtectionMode, ethMulticastBlock=ethMulticastBlock, radETS4fddiSAS=radETS4fddiSAS, ethOamServiceUnavailRatio=ethOamServiceUnavailRatio, prtI=prtI, sysSRdnManualFlip=sysSRdnManualFlip, agnSNoOfSanityCheckErr=agnSNoOfSanityCheckErr, prtInPh1MlDlciStatus=prtInPh1MlDlciStatus, radBridgeCODConnectDelay=radBridgeCODConnectDelay, ethIfCurrentOutPauseFrames=ethIfCurrentOutPauseFrames, sysCRdnRowStatus=sysCRdnRowStatus, prtT3E3RoutProt=prtT3E3RoutProt, radVmux400=radVmux400, mdlAlr=mdlAlr, mdlClIdx=mdlClIdx, wfqQueueIdx=wfqQueueIdx, prtInHsiConcentratedTo=prtInHsiConcentratedTo, sysSEditBy=sysSEditBy, ifCreateEntry=ifCreateEntry, atmVpCurrentRxRDI=atmVpCurrentRxRDI, cosProfileIndex=cosProfileIndex, prtIn1p6VcPbxSltIdx=prtIn1p6VcPbxSltIdx, systemNtpGmt=systemNtpGmt, pLinkVRate=pLinkVRate, prtExLs6SltIdx=prtExLs6SltIdx, agnVoiceSwConfRtAction=agnVoiceSwConfRtAction, prtExHsrRtsDtr=prtExHsrRtsDtr, ethOamSvcIntervalFramesLossCounter=ethOamSvcIntervalFramesLossCounter, alarmState=alarmState, dot3OamPeerEvent=dot3OamPeerEvent, prtSAlrSltIdx=prtSAlrSltIdx, prtMl4IpAddress=prtMl4IpAddress, radEPR8T=radEPR8T, radMBERAS=radMBERAS, agnCFlipDbSanityCheckCmd=agnCFlipDbSanityCheckCmd, mdlAlrCode=mdlAlrCode, qInternalProfileWredDropProbability=qInternalProfileWredDropProbability, prtLanWanMode=prtLanWanMode, prtInMbeRate=prtInMbeRate, prtCmprTypIdx=prtCmprTypIdx, prtExPVc4DelayStart=prtExPVc4DelayStart, prtGenTsPrtIdx=prtGenTsPrtIdx, radFTC2UDP=radFTC2UDP, agnGroupComponentIdx=agnGroupComponentIdx, prtDs3IntervalBIP=prtDs3IntervalBIP, atmAlarmForwardingRecoveryMode=atmAlarmForwardingRecoveryMode, prtExLs6CnfgIdx=prtExLs6CnfgIdx, prtGenCnfgSltIdx=prtGenCnfgSltIdx, systemPsHotSwap=systemPsHotSwap, agnMaxNoOfConns=agnMaxNoOfConns, ethIfCurrentOverflowOutMulticastFrames=ethIfCurrentOverflowOutMulticastFrames, prtE2MngOnNationalBit=prtE2MngOnNationalBit, prtBertTable=prtBertTable, atmNteEvents=atmNteEvents, radImx64=radImx64, evcCosEvcIdx=evcCosEvcIdx, prtFrTimeElapsed=prtFrTimeElapsed, atmVcPMCurrentTable=atmVcPMCurrentTable, radBridgeCODMode=radBridgeCODMode, prtSpEntry=prtSpEntry, atmLoopbackVpIvlAverageDelay=atmLoopbackVpIvlAverageDelay, prtHSParamTable=prtHSParamTable, sysCRdnSequenceNumberThreshold=sysCRdnSequenceNumberThreshold, prtIsdnSimultaneousCall=prtIsdnSimultaneousCall, atmNteConfVpEntry=atmNteConfVpEntry, qosFlowMappingIdx3=qosFlowMappingIdx3, prtExVc3Wire=prtExVc3Wire, ethOamSvcIntervalFramesAboveDVarThresh=ethOamSvcIntervalFramesAboveDVarThresh, agnRowPointerTable=agnRowPointerTable, prtIsdnEndpointEntry=prtIsdnEndpointEntry, radBridgeIPXSapHopsToServer=radBridgeIPXSapHopsToServer, maskingSrcPortNum=maskingSrcPortNum, prtExVc2CodingLaw=prtExVc2CodingLaw, wrLanIpxNetEntry=wrLanIpxNetEntry, radMP2100=radMP2100, agnSAlrIdx=agnSAlrIdx, prtExPh1MlTsIConTs=prtExPh1MlTsIConTs, prtFrTxDeFrames=prtFrTxDeFrames, maskingIfIndex=maskingIfIndex, prtBertTxBits=prtBertTxBits, prtT1E1EocTsConfig=prtT1E1EocTsConfig, systemVoiceDtmfRelayRxPayloadType=systemVoiceDtmfRelayRxPayloadType, fileNameWithinProduct=fileNameWithinProduct, ethIfIntervalOverflowOutUnicastFrames=ethIfIntervalOverflowOutUnicastFrames, prtTestVctTxCrossPair=prtTestVctTxCrossPair, atmGenSysGen=atmGenSysGen, prtCmprPrtIdx=prtCmprPrtIdx, prtPhyValidIntervals=prtPhyValidIntervals, atmThresholdLostCells=atmThresholdLostCells)
mibBuilder.exportSymbols("RAD-MIB", atmNteTosHighPriority=atmNteTosHighPriority, agnClkSrcPortTable=agnClkSrcPortTable, xcIndex=xcIndex, mdlSCardType=mdlSCardType, prtExPh1MlFdlType=prtExPh1MlFdlType, prtExVcPbxTsIConTs=prtExVcPbxTsIConTs, prtExMbeSltIdx=prtExMbeSltIdx, prtExPh1MlSupportedTS=prtExPh1MlSupportedTS, ethIfIntervalInputCongestionDropped=ethIfIntervalInputCongestionDropped, prtSInstEntry=prtSInstEntry, ethAutoMdiXEnable=ethAutoMdiXEnable, prtIpParamTable=prtIpParamTable, radBridgeStpStatHelloTime=radBridgeStpStatHelloTime, atmIfIntervalRxCells=atmIfIntervalRxCells, radBridgeIntervalTable=radBridgeIntervalTable, sysCRdnRecTime=sysCRdnRecTime, dsx3XConfigTable=dsx3XConfigTable, prtExPVc4WinkMinDuration=prtExPVc4WinkMinDuration, prtFrRxFecn=prtFrRxFecn, agnSAlrEntry=agnSAlrEntry, lagStatForcePort=lagStatForcePort, atmSysConfigCellTestVpi=atmSysConfigCellTestVpi, prtPerfPeriodRef=prtPerfPeriodRef, agnCnfgAlrFilterReset=agnCnfgAlrFilterReset, ethEncapsulationCRCMode=ethEncapsulationCRCMode, prtIpParamDefaultGateway=prtIpParamDefaultGateway, radRBHEEvents=radRBHEEvents, prtDlciTxDcrdCongDeFr=prtDlciTxDcrdCongDeFr, sysCRdnEventsTimeWindow=sysCRdnEventsTimeWindow, wrIpRouterInfo=wrIpRouterInfo, sysBufferAlr=sysBufferAlr, prtICnfgIdx=prtICnfgIdx, srvDiscardGreenBytes=srvDiscardGreenBytes, radMP104=radMP104, ethIfRingPorts=ethIfRingPorts, prtDlciCmprCnfgIdx=prtDlciCmprCnfgIdx, atmNteConfOamAIS=atmNteConfOamAIS, ip2If=ip2If, sysCRdnLosOrLofTime=sysCRdnLosOrLofTime, agnRowPointerEntry=agnRowPointerEntry, radFEC2=radFEC2, prtICnfgTable=prtICnfgTable, ethIfSrcMacCtrlAddrTable=ethIfSrcMacCtrlAddrTable, optPrtMonitorPrtIdx=optPrtMonitorPrtIdx, prtSDs3IfTable=prtSDs3IfTable, dsx3MappingNumber=dsx3MappingNumber, atmLoopbackVpIvlTable=atmLoopbackVpIvlTable, agnCmprCnfgIdx=agnCmprCnfgIdx, radBridgeIPXSapNode=radBridgeIPXSapNode, prtBdbandIndEntry=prtBdbandIndEntry, intSwdlCmd=intSwdlCmd, prtSTstDuration=prtSTstDuration, prtFrPlusCnfg=prtFrPlusCnfg, prtTestEntry=prtTestEntry, radBridgeIPXRipTblNoOfEntries=radBridgeIPXRipTblNoOfEntries, atmVpCurrentTaggedOuts=atmVpCurrentTaggedOuts, prtBertEntry=prtBertEntry, prtIn1p6VcPbxPrtIdx=prtIn1p6VcPbxPrtIdx, radBridgeMaskOffset1=radBridgeMaskOffset1, prtT1E1InbandMngRoutProt=prtT1E1InbandMngRoutProt, systemSaveAndResetAllStatsCmd=systemSaveAndResetAllStatsCmd, hostIPMask=hostIPMask, dot3OamXEntry=dot3OamXEntry, rowInfoEntry=rowInfoEntry, agnXCmprIdx3=agnXCmprIdx3, prtPhyCurrentLSV=prtPhyCurrentLSV, radTransport=radTransport, atmVpIntervalVpi=atmVpIntervalVpi, agnClkSrcStateChangeTrap=agnClkSrcStateChangeTrap, radOamEvcIdx=radOamEvcIdx, ds1NetworkRemoteLoopTrap=ds1NetworkRemoteLoopTrap, hostParam1=hostParam1, prtMl4RemCrc=prtMl4RemCrc, atmVcShaperStatEntry=atmVcShaperStatEntry, atmNteDefaultLoopbackThreshold=atmNteDefaultLoopbackThreshold, markingProfileMethod=markingProfileMethod, prtMl4OosErrorSource=prtMl4OosErrorSource, lagDistributionMethod=lagDistributionMethod, radBridgeMngVlanId=radBridgeMngVlanId, atmVpPmEntry=atmVpPmEntry, prtExVcPbxTsIdx=prtExVcPbxTsIdx, ip2IfProtocolVersion=ip2IfProtocolVersion, ethOamServiceFrameLossRatio=ethOamServiceFrameLossRatio, radLA140=radLA140, radIpMux216=radIpMux216, qInternalProfileRateLimit=qInternalProfileRateLimit, qosFlowMappingToSrcIpAddr=qosFlowMappingToSrcIpAddr, prtSInstPrtType=prtSInstPrtType, atmNteProtection=atmNteProtection, radBridgeIPXRipInDiscards=radBridgeIPXRipInDiscards, prtExPVc4DestBundle=prtExPVc4DestBundle, ip2IfStatTxHdlc=ip2IfStatTxHdlc, agnConfigMsg=agnConfigMsg, prtMl4CnfgEntry=prtMl4CnfgEntry, radRIC622GE=radRIC622GE, radMepOamMode=radMepOamMode, prtSupervisoryDataBits=prtSupervisoryDataBits, wrFrDlciLearningMode=wrFrDlciLearningMode, agnCNetEventsBcast=agnCNetEventsBcast, atmVcQoSUAS=atmVcQoSUAS, dot1agXCfmMepEntry=dot1agXCfmMepEntry, prtExMbePrtIdx=prtExMbePrtIdx, dhcpPoolAllocEntry=dhcpPoolAllocEntry, prtExPhPlDlciRxBe=prtExPhPlDlciRxBe, ethIfIntervalFCSErrors=ethIfIntervalFCSErrors, cmprPrtGen=cmprPrtGen, ethIfRingStatusChange=ethIfRingStatusChange, dot3OamXDescrId=dot3OamXDescrId, dot1agXCfmMepTable=dot1agXCfmMepTable, radBridgeCODTrafficTriggerProtType=radBridgeCODTrafficTriggerProtType, prtCmprStatisticObj=prtCmprStatisticObj, radAce102=radAce102, prtExPhPlDlciIConDlci=prtExPhPlDlciIConDlci, alarmForwardingRecoveryCommand=alarmForwardingRecoveryCommand, atmAceModuleChangeTrap=atmAceModuleChangeTrap, radMepLtrMacAddr=radMepLtrMacAddr, radSysRtr=radSysRtr, prtExPVc4CongLevel=prtExPVc4CongLevel, serviceEntry=serviceEntry, ethOamSvcIntervalMaxRoundTripDelay=ethOamSvcIntervalMaxRoundTripDelay, agnClockSource=agnClockSource, radSTC1UDP=radSTC1UDP, lagIdx=lagIdx, agnClkCurrentRxPackets=agnClkCurrentRxPackets, agnVoiceSwConfRtRowStatus=agnVoiceSwConfRtRowStatus, prtIn1p6VcPbxPabxTs=prtIn1p6VcPbxPabxTs, qInternalProfileScheduling=qInternalProfileScheduling, radBridgeStpStatEntry=radBridgeStpStatEntry, prtPhyCurrentLOS=prtPhyCurrentLOS, atmNteQosMode=atmNteQosMode, prtExPVc4GenerateTone=prtExPVc4GenerateTone, mdlAlarmInvert=mdlAlarmInvert, sysSRdnFlipCmd=sysSRdnFlipCmd, agnListDecodingTable=agnListDecodingTable, srvDiscardRedBytes=srvDiscardRedBytes, radBridgeIPXRipTable=radBridgeIPXRipTable, sysDclEntry=sysDclEntry, prtGenParamTable=prtGenParamTable, prtHdslCompSwVer=prtHdslCompSwVer, atmVcPMIntervalVci=atmVcPMIntervalVci, ethIfIntervalOverflowOutFrames=ethIfIntervalOverflowOutFrames, ip2IfCustomToneFrequency=ip2IfCustomToneFrequency, ethOamSvcCurrFramesBelowDelayThresh=ethOamSvcCurrFramesBelowDelayThresh, prtIsdnStatusCallState=prtIsdnStatusCallState, broadbandIf=broadbandIf, radBridgeStpStatForwardDelay=radBridgeStpStatForwardDelay, agnVoiceSwConfHGIdx=agnVoiceSwConfHGIdx, prtSAlrMask=prtSAlrMask, clkSrcChangeTrap=clkSrcChangeTrap, ethIfPerfEntry=ethIfPerfEntry, atmVpPmSource=atmVpPmSource, atmVcPMIntervalErroredCells=atmVcPMIntervalErroredCells, prtExHsfClkPolarity=prtExHsfClkPolarity, linkSelectorMode=linkSelectorMode, srvForwardYellowPackets=srvForwardYellowPackets, ethIfCurrentInFrames=ethIfCurrentInFrames, modlParamIndex=modlParamIndex, agnTsCmprPortIdx=agnTsCmprPortIdx, prtIn7p8VcPbxCnfgTable=prtIn7p8VcPbxCnfgTable, qosFlowMappingFromDestMacAddr=qosFlowMappingFromDestMacAddr, prtFrRxDcrdCongDeFr=prtFrRxDcrdCongDeFr, atmNteTotalLb=atmNteTotalLb, physicalConnectorString=physicalConnectorString, ip2IfPayloadType=ip2IfPayloadType, radBridges=radBridges, radBridgeIPXSapTable=radBridgeIPXSapTable, radFomiT3=radFomiT3, atmNteDSESLTCR=atmNteDSESLTCR, alarmForwardingDirection=alarmForwardingDirection, prtExPVc4DestinationNum=prtExPVc4DestinationNum, clearDwldStatusLog=clearDwldStatusLog, ip2IfOnHookDetect=ip2IfOnHookDetect, queueGroupName=queueGroupName, prtFrTxBecn=prtFrTxBecn, ds1LocalMultiframeAlarmTrap=ds1LocalMultiframeAlarmTrap, ip2IfVbdSwitchbackTime=ip2IfVbdSwitchbackTime, mdlCmprTable=mdlCmprTable, ethIfStormCnfgIdx=ethIfStormCnfgIdx, radAce20E=radAce20E, ifCreateRowStatus=ifCreateRowStatus, radTRE8D=radTRE8D, radDXC30=radDXC30, prtDs3IntervalES=prtDs3IntervalES, prtGenTestDurationEntry=prtGenTestDurationEntry, agnClkSrcPort=agnClkSrcPort, prtExHsiRate=prtExHsiRate, atmVpIntervalUAS=atmVpIntervalUAS, ip2IfConnPktTimeOutCycles=ip2IfConnPktTimeOutCycles, prtGenAlrMaskAll=prtGenAlrMaskAll, mapLinkEntry=mapLinkEntry, prtParamDataRate=prtParamDataRate, radBridgeForwardingMode=radBridgeForwardingMode, qProfileEntry=qProfileEntry, radBridgeIntervalRxCorrectFrames=radBridgeIntervalRxCorrectFrames, ethIfSrcMacCtrlCurNumPermitAddr=ethIfSrcMacCtrlCurNumPermitAddr, prtExPhPlDcdRtsControlPath=prtExPhPlDcdRtsControlPath, agnPowerFailureTrap=agnPowerFailureTrap, prtInVc3Connect=prtInVc3Connect, ds1AisTrap=ds1AisTrap, agnCFlipNetEventStartTime=agnCFlipNetEventStartTime, ethIfIntervalOverflowOutDiscardFrames=ethIfIntervalOverflowOutDiscardFrames, systemVoiceCoderPriority=systemVoiceCoderPriority, atmVcIntervalGcra1Violations=atmVcIntervalGcra1Violations, atmNteOamLevel=atmNteOamLevel, radAsmi450R1152=radAsmi450R1152, prtTreCnfg=prtTreCnfg, atmNteAlarmVpTable=atmNteAlarmVpTable, ethIfCurrentOutFrames=ethIfCurrentOutFrames, agnNetworkInterfaceType=agnNetworkInterfaceType, prtExVcPbxTsRemPrt=prtExVcPbxTsRemPrt, mdlPbxFraFramerSlot=mdlPbxFraFramerSlot, atmNteHostDefaultVlanID=atmNteHostDefaultVlanID, mdlSInstSltIdx=mdlSInstSltIdx, radOptimux4T1=radOptimux4T1, prtExPh1MlTsPrtIdx=prtExPh1MlTsPrtIdx, ripSapIfConfTable=ripSapIfConfTable, radRiciT3=radRiciT3, prtTestMacSwapLoopVlanId=prtTestMacSwapLoopVlanId, prtBertInjectErrRateCmd=prtBertInjectErrRateCmd, atmVcPmVci=atmVcPmVci, ethIfCurrentOverflowOutPauseFrames=ethIfCurrentOverflowOutPauseFrames, prtT1E1Role=prtT1E1Role, sysCRdnPrimePriority=sysCRdnPrimePriority, sysSAlrClearAllCmd=sysSAlrClearAllCmd, radMBE8D=radMBE8D, wrBraodcastCtrlCmd=wrBraodcastCtrlCmd, systemVoiceDtmfRelayTxPayloadType=systemVoiceDtmfRelayTxPayloadType, cmprMdlGen=cmprMdlGen, sysDclCopyDbEntry=sysDclCopyDbEntry, prtGenCnfgLinkToPort=prtGenCnfgLinkToPort, fileTransfer=fileTransfer, prtHS=prtHS, radBridgeStpStatIdx=radBridgeStpStatIdx, prtT1FdlMsgSltIdx=prtT1FdlMsgSltIdx, swdlStatusIdx=swdlStatusIdx, agnDlciCnfgIdx=agnDlciCnfgIdx, radOp16E1L=radOp16E1L, prtSAlarmTable=prtSAlarmTable, radBridgePortVlanMemberBridgeIdx=radBridgePortVlanMemberBridgeIdx, sysRedundancyStatusTrap=sysRedundancyStatusTrap, ethOamSvcIntervalEntry=ethOamSvcIntervalEntry, prtDs3CurrentLCE=prtDs3CurrentLCE, atmVpShaperEpdDropped=atmVpShaperEpdDropped, ip2IfStatHdlcOversize=ip2IfStatHdlcOversize, portQos=portQos, prtDs3TotalSES=prtDs3TotalSES, radFcdT1=radFcdT1, prtDimMaxDelay=prtDimMaxDelay, prtLanWanToLanVlanMode=prtLanWanToLanVlanMode, atmVcShaperStatTable=atmVcShaperStatTable, prtExPhPlCllmMsg=prtExPhPlCllmMsg, agnDlciLSltIdx=agnDlciLSltIdx, dhcpIfClientEntry=dhcpIfClientEntry, radMepMaFormat=radMepMaFormat)
mibBuilder.exportSymbols("RAD-MIB", prtGenParamStatus=prtGenParamStatus, srvDiscardYellowBytes=srvDiscardYellowBytes, prtExPh1MlTdmTrunk=prtExPh1MlTdmTrunk, prtExPVc4DlciStatus=prtExPVc4DlciStatus, ip2IfCdisCngDetectionTime=ip2IfCdisCngDetectionTime, prtSpInterface=prtSpInterface, prtIsdnDirectoryTable=prtIsdnDirectoryTable, prtPhyIntervalUAS=prtPhyIntervalUAS, srvDiscardYellowRedBytes=srvDiscardYellowRedBytes, mdlProtIpRowStatus=mdlProtIpRowStatus, agnTrapMask=agnTrapMask, maskingType=maskingType, prtInMbeConnect=prtInMbeConnect, atmVpIntervalTxRDI=atmVpIntervalTxRDI, atmNteRdnManagement=atmNteRdnManagement, ethIfIntervalOutUnicastFrames=ethIfIntervalOutUnicastFrames, atmNteAlarmVpEntry=atmNteAlarmVpEntry, cosProfileTable=cosProfileTable, sysSTimeCmd=sysSTimeCmd, prtCrTxTotalCells=prtCrTxTotalCells, agnSpecific=agnSpecific, alarmForwardingAction=alarmForwardingAction, agnSMaxNoOfCnfg=agnSMaxNoOfCnfg, systemVoiceFaxSupport=systemVoiceFaxSupport, prtExLs6PrtIdx=prtExLs6PrtIdx, prtE2CnfgEntry=prtE2CnfgEntry, prtSpDataBits=prtSpDataBits, prtE2Connect=prtE2Connect, ip2IfNoiseLevelForVAD=ip2IfNoiseLevelForVAD, radAce3105=radAce3105, prtGenTsType=prtGenTsType, radMepTransmitLbmVlanDropEnable=radMepTransmitLbmVlanDropEnable, systemNtpServerAddressType=systemNtpServerAddressType, queueGroupPointToQBlock=queueGroupPointToQBlock, agnSCnfgEntry=agnSCnfgEntry, statisPrtGen=statisPrtGen, radAsmi54=radAsmi54, atmGenSysCxRefTable=atmGenSysCxRefTable, radAce20T=radAce20T, ip2IfFarEndType=ip2IfFarEndType, qosFlowMappingFromTcpSrcPort=qosFlowMappingFromTcpSrcPort, ifTeQosEntry=ifTeQosEntry, prtExHsrDataBits=prtExHsrDataBits, prtFrRxDeFrames=prtFrRxDeFrames, ip2IfCurrentStatBufUnderflows=ip2IfCurrentStatBufUnderflows, radSEC1UDP=radSEC1UDP, prtInPh1MlDlciCnfgIdx=prtInPh1MlDlciCnfgIdx, atmVpIntervalGcra1Violations=atmVpIntervalGcra1Violations, sysSDateCmd=sysSDateCmd, radBridgeMaskOper=radBridgeMaskOper, agnVoiceSwConfDialPlan=agnVoiceSwConfDialPlan, agnDlciCmprCnfgIdx=agnDlciCmprCnfgIdx, prtExTsSplitEntry=prtExTsSplitEntry, sysDcl=sysDcl, wrDhcpIpAddressLeaseTime=wrDhcpIpAddressLeaseTime, autoFileTransferOccurrenceRecurrence=autoFileTransferOccurrenceRecurrence, agnVoiceSwConfRtTable=agnVoiceSwConfRtTable, prtDs3CurrentSLM=prtDs3CurrentSLM, radBridgeStpCnfgEntry=radBridgeStpCnfgEntry, dot3OamXTable=dot3OamXTable, prtIsdnCnfgIdx=prtIsdnCnfgIdx, atmVcIntervalTable=atmVcIntervalTable, prtExPh1MlClkMode=prtExPh1MlClkMode, atmVcShaperEpdDropped=atmVcShaperEpdDropped, prtMl4SigProfile=prtMl4SigProfile, radSAH16Tint=radSAH16Tint, ethOamServiceDelayVarThresh=ethOamServiceDelayVarThresh, prtExClUsage=prtExClUsage, prtT1E1SameFeCnfg=prtT1E1SameFeCnfg, prtSpDsr=prtSpDsr, ip2IfValidIntervals=ip2IfValidIntervals, prtExPVc4SuperTandem=prtExPVc4SuperTandem, alrGenLevel=alrGenLevel, wrDhcpInterface=wrDhcpInterface, prtPhMlMfSyncSlot=prtPhMlMfSyncSlot, radMepOamDestMacAddr=radMepOamDestMacAddr, dhcpPoolAllocTable=dhcpPoolAllocTable, ethIfPerfInOkFrames=ethIfPerfInOkFrames, sysSAlrIdx=sysSAlrIdx, ethIf=ethIf, prtExPVc4Wire=prtExPVc4Wire, prtIsdnDirectorySltIdx=prtIsdnDirectorySltIdx, prtT1E1RemCrc4=prtT1E1RemCrc4, agnSigProfileABCD=agnSigProfileABCD, prtInLs6PrtIdx=prtInLs6PrtIdx, ethDot1xEnable=ethDot1xEnable, radIpMux2L=radIpMux2L, markingProfileTable=markingProfileTable, prtFrRxTotalBytes=prtFrRxTotalBytes, prtDs3CurrentBPV=prtDs3CurrentBPV, prtAlarmsCmprAlarmSlot=prtAlarmsCmprAlarmSlot, ethIfCurrentOverflowInFrames=ethIfCurrentOverflowInFrames, radRRTRE8=radRRTRE8, radBridgeMaskCond2=radBridgeMaskCond2, mdlCPrgTable=mdlCPrgTable, atmVcPMCurrentErroredCells=atmVcPMCurrentErroredCells, prtInPh1MlAssociatedExCh=prtInPh1MlAssociatedExCh, prtAlrMaskEntry=prtAlrMaskEntry, dsx3TxClockSource=dsx3TxClockSource, atmNteHostIfTable=atmNteHostIfTable, atmVpPMCurrentECB=atmVpPMCurrentECB, prtTestMacSwapLoopSrcAddr=prtTestMacSwapLoopSrcAddr, radBridgeIPXRipNIC=radBridgeIPXRipNIC, mdlCNoOfExtPrt=mdlCNoOfExtPrt, prtDlciRxDcrdCongDeFr=prtDlciRxDcrdCongDeFr, ethIfRing=ethIfRing, atmNteDPLTCR=atmNteDPLTCR, prtSAlrStatus=prtSAlrStatus, radMepMaName=radMepMaName, radBridgeIPXSapName=radBridgeIPXSapName, ds1ExcessiveRemoteMfAlarmTrap=ds1ExcessiveRemoteMfAlarmTrap, radBridgeCODDay=radBridgeCODDay, prtDlciStatisTable=prtDlciStatisTable, systemVoiceConfIdx=systemVoiceConfIdx, prtExPh1MlInbandMng=prtExPh1MlInbandMng, wrSyncCnfgEntry=wrSyncCnfgEntry, dsx1DataStreamStatEntry=dsx1DataStreamStatEntry, radOptimux4T1L=radOptimux4T1L, prtExPh1MlTsTest=prtExPh1MlTsTest, radVmux2200=radVmux2200, radFcdIpM=radFcdIpM, agnCnfgUpdTime=agnCnfgUpdTime, prtT1E1LineType=prtT1E1LineType, systemNtpUpdateInterval=systemNtpUpdateInterval, radSPS4=radSPS4, mdlCNoOfExternPrt=mdlCNoOfExternPrt, dsx1TotalBPV=dsx1TotalBPV, xcTable=xcTable, prtIpParamAgingTime=prtIpParamAgingTime, dsx3AisEnable=dsx3AisEnable, prtExPhPlDcdRts=prtExPhPlDcdRts, atmVcCrossConnectExtenEntry=atmVcCrossConnectExtenEntry, prtExHs4RestoreT=prtExHs4RestoreT, ethIfSrcMacCtrlAddrRowStatus=ethIfSrcMacCtrlAddrRowStatus, ethOamService=ethOamService, alrBuffGen=alrBuffGen, radETS4fddiDAS=radETS4fddiDAS, prtExLs6VPrtIdx=prtExLs6VPrtIdx, agnDlciTable=agnDlciTable, ethIfSrcMacCtrlEntry=ethIfSrcMacCtrlEntry, prtSAlrState=prtSAlrState, ip2IfMinPowerLevel=ip2IfMinPowerLevel, prtClkSrcChangeTrap=prtClkSrcChangeTrap, radAce52=radAce52, agnSCmprErrVersion=agnSCmprErrVersion, agnSigProfEntry=agnSigProfEntry, prtInLs2CnfgEntry=prtInLs2CnfgEntry, prtExLs6VSltIdx=prtExLs6VSltIdx, modlParamSwVer=modlParamSwVer, prtIRate=prtIRate, prtAlarmsCmprEntry=prtAlarmsCmprEntry, dacsMuxEvents=dacsMuxEvents, prtT3E3TxClockSource=prtT3E3TxClockSource, prtSAlrCounter=prtSAlrCounter, agnSDateFormat=agnSDateFormat, alrBufPort=alrBufPort, prtExLs6Rate=prtExLs6Rate, prtInPh1MlSegment=prtInPh1MlSegment, agnFunctionEntry=agnFunctionEntry, prtT1E1FdlMode=prtT1E1FdlMode, ethOamServiceFrameLoss=ethOamServiceFrameLoss, ip2IfPortUsage=ip2IfPortUsage, radBridgeInvBasePortIfIndex=radBridgeInvBasePortIfIndex, agnVoiceSwConfNoOfHops=agnVoiceSwConfNoOfHops, prtExPVc4RxGain=prtExPVc4RxGain, serviceBwProfileId=serviceBwProfileId, optPrtMonitorEntry=optPrtMonitorEntry, atmNteHostVci=atmNteHostVci, ip2IfSuperTandemBitMask=ip2IfSuperTandemBitMask, atmVcIntervalClp0CellOuts=atmVcIntervalClp0CellOuts, systemVoicePacketRate=systemVoicePacketRate, prtExHs4MfClkSrcSlt=prtExHs4MfClkSrcSlt, prtSupervisory=prtSupervisory, atmVpPmDirection=atmVpPmDirection, mdlCCnfgIdx=mdlCCnfgIdx, agnClkIntervalNumber=agnClkIntervalNumber, atmNteConfOamAddressing=atmNteConfOamAddressing, radMepTransmitLtmActivationCmd=radMepTransmitLtmActivationCmd, ip2IfStatHdlcUndersize=ip2IfStatHdlcUndersize, ethOamServiceOverflowFramesAboveDelay=ethOamServiceOverflowFramesAboveDelay, prtIpParamBurstSize=prtIpParamBurstSize, radBridgeIPXSap=radBridgeIPXSap, prtCrStatisInvIdx=prtCrStatisInvIdx, prtExPhPlModemPrtIdx=prtExPhPlModemPrtIdx, mngAlarmTrapMask=mngAlarmTrapMask, radTRERASa=radTRERASa, radBridgeIntervalEntry=radBridgeIntervalEntry, radMepTable=radMepTable, ip2IfTimeElapsed=ip2IfTimeElapsed, prtIsdnFilter=prtIsdnFilter, sysSBusPortIdx=sysSBusPortIdx, ethIfSrcMacCtrlAddrStatus=ethIfSrcMacCtrlAddrStatus, radSysPSEvents=radSysPSEvents, agnGroupIdx=agnGroupIdx, atmVcPmRowStatus=atmVcPmRowStatus, gfpRxTxScramble=gfpRxTxScramble, prtIsdnEndpointBearerCh=prtIsdnEndpointBearerCh, prtAcmCnfgIdx=prtAcmCnfgIdx, prtIsdnDirectoryLocalSubAddr=prtIsdnDirectoryLocalSubAddr, ip2IfRowStatus=ip2IfRowStatus, ethOamServicePmEnable=ethOamServicePmEnable, prtIn7p8VcPbxPrtIdx=prtIn7p8VcPbxPrtIdx, atmNteManagerIfIndex=atmNteManagerIfIndex, prtGenCnfgConnect=prtGenCnfgConnect, prtParamMappingMode=prtParamMappingMode, atmNteManagerIP=atmNteManagerIP, ethIfPerfTotalCollisions=ethIfPerfTotalCollisions, prtClkSrcMode=prtClkSrcMode, atmAceAlarmSectionBIP=atmAceAlarmSectionBIP, agnCT1E1RingPrimePort=agnCT1E1RingPrimePort, prtT3E3CnfgIdx=prtT3E3CnfgIdx, prtPhyPerfHistory=prtPhyPerfHistory, wrDhcpSecondaryDNS=wrDhcpSecondaryDNS, radBridgeMaskCond1=radBridgeMaskCond1, ifPerfHCCounter=ifPerfHCCounter, agnClkCurrentBufferUnderflow=agnClkCurrentBufferUnderflow, agnSErrDescription=agnSErrDescription, radLrs12F=radLrs12F, agnCClkSrcTable=agnCClkSrcTable, prtExHsrRateAdapt=prtExHsrRateAdapt, atmInterfaceAlarmStatus=atmInterfaceAlarmStatus, sysDclCnfgIdx=sysDclCnfgIdx, radBridgeMaskFrom3=radBridgeMaskFrom3, mdlPbxFraSignalMask=mdlPbxFraSignalMask, ip2IfStatTxOnTimeInterval=ip2IfStatTxOnTimeInterval, radMiricE3T3=radMiricE3T3, radOptimux155=radOptimux155, radAsmi52A=radAsmi52A, sysDclChPriority=sysDclChPriority, prtExLs6VConnect=prtExLs6VConnect, radBridgeGenCfgEntry=radBridgeGenCfgEntry, prtPh1MlCnfg=prtPh1MlCnfg, radAmc102c=radAmc102c, atmVcPMIntervalSES=atmVcPMIntervalSES, ethOamSvcCurrUnavailSec=ethOamSvcCurrUnavailSec, prtAcmActiveState=prtAcmActiveState, prtExPh1MlInbandMngRoutProt=prtExPh1MlInbandMngRoutProt, ethIfCurrentEntry=ethIfCurrentEntry, ethIfCurrentOverflowInDiscardFrames=ethIfCurrentOverflowInDiscardFrames, ip2IfIntervalStatMaxDelayVar=ip2IfIntervalStatMaxDelayVar, prtExPVc4DlciRxBe=prtExPVc4DlciRxBe, atmVpPmRowStatus=atmVpPmRowStatus, prtExPhPlFrMngProt=prtExPhPlFrMngProt, prtExPhPlDlciTxBe=prtExPhPlDlciTxBe, prtDs3PerfHistory=prtDs3PerfHistory, prtBdbandIndSig=prtBdbandIndSig, ethRateLimit=ethRateLimit, prtDS1Events=prtDS1Events, ethIfCurrentLateCollisions=ethIfCurrentLateCollisions, mdlAlarmsCmprObj=mdlAlarmsCmprObj, radTRE8=radTRE8, flowMappingProfileTable=flowMappingProfileTable, prtPhMlSyncRestore=prtPhMlSyncRestore, radBridgeIPXRipHopMetric=radBridgeIPXRipHopMetric)
mibBuilder.exportSymbols("RAD-MIB", prtInHsiRate=prtInHsiRate, prtExLs2CnfgTable=prtExLs2CnfgTable, srvDiscardGreenPacketOverflow=srvDiscardGreenPacketOverflow, agnDlciHIdx=agnDlciHIdx, radTrimBrg10=radTrimBrg10, radStarSwitchATM25L=radStarSwitchATM25L, mdlProtIpAddress=mdlProtIpAddress, ethIfUse=ethIfUse, cosProfileEntry=cosProfileEntry, prtIsdnSltIdx=prtIsdnSltIdx, atmLoopbackVcEntry=atmLoopbackVcEntry, radBridgeCODOriginateDisConnectCondition=radBridgeCODOriginateDisConnectCondition, radRouter=radRouter, radBridgePortBaseVlanEgressPorts=radBridgePortBaseVlanEgressPorts, agnSMaskedAlrStatAll=agnSMaskedAlrStatAll, prtCmprCnfgIdx=prtCmprCnfgIdx, prtExVc2EchoCancelerModule=prtExVc2EchoCancelerModule, prtExPhPlModemTable=prtExPhPlModemTable, prtExPhPlDlciValid=prtExPhPlDlciValid, dsx1CsuLoop=dsx1CsuLoop, prtCfgParam=prtCfgParam, prtExVcPbxCnfgEntry=prtExVcPbxCnfgEntry, sysCClkRecoveredID=sysCClkRecoveredID, prtDimIdx=prtDimIdx, radMepLtrTtl=radMepLtrTtl, ifCreateType=ifCreateType, atmNteUnitVersion=atmNteUnitVersion, ethRip2=ethRip2, agnXCmprEntry=agnXCmprEntry, ip2IfTxGain=ip2IfTxGain, prtExVc3PrtIdx=prtExVc3PrtIdx, atmVcCurrentTxAIS=atmVcCurrentTxAIS, dsx1LineAdaptiveTimingMode=dsx1LineAdaptiveTimingMode, dsx1XIntervalTable=dsx1XIntervalTable, prtDs3CurrentBitParity=prtDs3CurrentBitParity, ip2IfMeasuredSilence=ip2IfMeasuredSilence, atmConfVpOamDirection=atmConfVpOamDirection, prtPhyIntervalSES=prtPhyIntervalSES, prtExPh1MlSltIdx=prtExPh1MlSltIdx, lagTable=lagTable, mdlSMaskedAlrStat=mdlSMaskedAlrStat, prtExHsiCnfgEntry=prtExHsiCnfgEntry, ip2IfPortIndex=ip2IfPortIndex, ethIfStormTable=ethIfStormTable, agnCFlipIdx=agnCFlipIdx, prtExPhPlLXoff=prtExPhPlLXoff, prtT1E1OosCount=prtT1E1OosCount, atmVcPMCurrentLostCells=atmVcPMCurrentLostCells, prtExPhPlConnectionTyp=prtExPhPlConnectionTyp, atmVcPMCurrentSES=atmVcPMCurrentSES, prtExPhPlCnfgEntry=prtExPhPlCnfgEntry, agnCnfgUpdDate=agnCnfgUpdDate, prtSAlrCardType=prtSAlrCardType, prtExPhPlCongLevel=prtExPhPlCongLevel, atmGenSysCxRefEntry=atmGenSysCxRefEntry, dhcpIfClientIpAddress=dhcpIfClientIpAddress, wrIpAddressTable=wrIpAddressTable, radBridgeGenFlowBasicClassification=radBridgeGenFlowBasicClassification, atmVpPMIntervalECB=atmVpPMIntervalECB, radMepOamDestAddrType=radMepOamDestAddrType, prtInPh1MlDlciTable=prtInPh1MlDlciTable, radBridgePort=radBridgePort, agnDlciCmprVersion=agnDlciCmprVersion, cmprAgnGen=cmprAgnGen, ethOamSvcCurrFramesLossCounter=ethOamSvcCurrFramesLossCounter, radRici4E1L=radRici4E1L, agnSCmprErrObj=agnSCmprErrObj, prtInTreSltIdx=prtInTreSltIdx, radIpMux1=radIpMux1, radBridgeDot1qVlanSplitHorizon=radBridgeDot1qVlanSplitHorizon, prtParamLastResetStatsTime=prtParamLastResetStatsTime, mdlAlrTable=mdlAlrTable, radRiciE3=radRiciE3, prtMl4EchoCanceler=prtMl4EchoCanceler, atmIfIntervalHecErrorSeconds=atmIfIntervalHecErrorSeconds, radEP4T2FL=radEP4T2FL, mdlSTestStatus=mdlSTestStatus, prtGenAlrStatus=prtGenAlrStatus, radBridgeCOD=radBridgeCOD, radBridgePortCnfgDefaultVpi=radBridgePortCnfgDefaultVpi, agnChangeCnt=agnChangeCnt, agnCSanityCheckCmd=agnCSanityCheckCmd, prtExPhPlMinSeparators=prtExPhPlMinSeparators, prtInMbeCnfgIdx=prtInMbeCnfgIdx, fileName=fileName, prtCrStatisPrtIdx=prtCrStatisPrtIdx, agnClkSrcPortNetType=agnClkSrcPortNetType, atmNteTosMask=atmNteTosMask, atmTrafficDescrParamMode=atmTrafficDescrParamMode, radLrs52=radLrs52, prtDlciTxBcViol=prtDlciTxBcViol, mdlCl=mdlCl, prtInVc3SltIdx=prtInVc3SltIdx, radImx4T1=radImx4T1, radEP8T=radEP8T, atmVcPMQoSTable=atmVcPMQoSTable, statPrtMux=statPrtMux, prtIn1p6VcPbxCnfgTable=prtIn1p6VcPbxCnfgTable, prtDs3CurrentLOS=prtDs3CurrentLOS, sysSBusUtilization=sysSBusUtilization, ip2IfCASRedundancy=ip2IfCASRedundancy, dscpMappingRegenPriority=dscpMappingRegenPriority, radBridgeGenFlowUnkownUnicastTrafficClass=radBridgeGenFlowUnkownUnicastTrafficClass, prtExVc2CallEnable=prtExVc2CallEnable, radRici4T1=radRici4T1, prtExPh1MlTsBundle=prtExPh1MlTsBundle, radBridgeCODTrafficEntry=radBridgeCODTrafficEntry, gfpCnfgTable=gfpCnfgTable, mdlSTstStatusAll=mdlSTstStatusAll, radOptimux4E1Mar06=radOptimux4E1Mar06, prtPerfTimeTag=prtPerfTimeTag, agnCFlipNetEventsCnfgIdx=agnCFlipNetEventsCnfgIdx, atmAceAlarmVcRDIReception=atmAceAlarmVcRDIReception, atmLoopbackVcCDV=atmLoopbackVcCDV, radBridgeCODTimeTriggerFrom=radBridgeCODTimeTriggerFrom, wrSyncClkMode=wrSyncClkMode, sysCClkSrcPrt=sysCClkSrcPrt, optPrtCnfgIdx=optPrtCnfgIdx, prtHSRate=prtHSRate, sysCClkStationFreq=sysCClkStationFreq, ethIfOamCfm=ethIfOamCfm, radMP2104=radMP2104, prtExPh1MlImpedance=prtExPh1MlImpedance, prtExHsrProtocol=prtExHsrProtocol, prtExHsrClkMode=prtExHsrClkMode, prtExVc2MeterRate=prtExVc2MeterRate, atmNteConfCACMode=atmNteConfCACMode, radBridgeIPXRip=radBridgeIPXRip, agnFanFailureTrap=agnFanFailureTrap, radBridgeGenCfgBridgeAction=radBridgeGenCfgBridgeAction, atmVpCurrentRxCellsClp0=atmVpCurrentRxCellsClp0, prtPhyCurrentES=prtPhyCurrentES, dsx1PortMultiplier=dsx1PortMultiplier, prtDestIdx=prtDestIdx, ip2IfStatTxVoice=ip2IfStatTxVoice, qInternalProfileShaperProfile=qInternalProfileShaperProfile, radBridgeIPXSapSocket=radBridgeIPXSapSocket, prtExPVc4EandMType=prtExPVc4EandMType, alarmForwardingGroupConditions=alarmForwardingGroupConditions, prtExPVc4DlciIConPrt=prtExPVc4DlciIConPrt, prtInPh1MlMinSeparators=prtInPh1MlMinSeparators, agnCBuMlTable=agnCBuMlTable, prtSParamStatus=prtSParamStatus, prtMl4LogicalLinkId=prtMl4LogicalLinkId, prtParamPSNLayer=prtParamPSNLayer, prtT3E3AisTransmit=prtT3E3AisTransmit, ethOamSvcTotalFramesLossCounter=ethOamSvcTotalFramesLossCounter, radOptimuxXLE1=radOptimuxXLE1, radGmux2000=radGmux2000, atmVcCurrentSES=atmVcCurrentSES, ip2IfStatTxSignaling=ip2IfStatTxSignaling, prtTestCmdAndStatus=prtTestCmdAndStatus, sysSBusTable=sysSBusTable, atmVcIntervalNumber=atmVcIntervalNumber, markingProfileName=markingProfileName, licenseUpdateTrap=licenseUpdateTrap, prtExHsrCnfgIdx=prtExHsrCnfgIdx, radMepEntry=radMepEntry, radDot1qPortTagStripping=radDot1qPortTagStripping, prtExHs4TsIdx=prtExHs4TsIdx, agnCBuMlRole=agnCBuMlRole, ip2IfSrcPort=ip2IfSrcPort, ip2IfMinPulseWidth=ip2IfMinPulseWidth, prtIpParamRemoteIP=prtIpParamRemoteIP, agnDlciCmprObj=agnDlciCmprObj, mdlPbxFramerCnfg=mdlPbxFramerCnfg, agnDlciFunnelEnable=agnDlciFunnelEnable, prtDs1PerfHistory=prtDs1PerfHistory, ds1LocalLoopTrap=ds1LocalLoopTrap, prtExPhPlFullRptPeriod=prtExPhPlFullRptPeriod, prtDs3CurrentPlcpFEBE=prtDs3CurrentPlcpFEBE, maskingFrameType=maskingFrameType, atmVpQoSTable=atmVpQoSTable, rowInfoMaxNoOfRows=rowInfoMaxNoOfRows, radTransportDomainSnmpEfmOam=radTransportDomainSnmpEfmOam, prtExVc2IfType=prtExVc2IfType, agnClkIntervalTable=agnClkIntervalTable, atmVpShaperMaxOccupation=atmVpShaperMaxOccupation, sysSNoOfSanityCheckErr=sysSNoOfSanityCheckErr, radBridgeStpCnfgStpVersion=radBridgeStpCnfgStpVersion, ethIfIntervalAlignmentErrors=ethIfIntervalAlignmentErrors, optPrtMonitorLaserBias=optPrtMonitorLaserBias, wrDhcpConfigFileName=wrDhcpConfigFileName, mdlProtIpEntry=mdlProtIpEntry, atmAceAlarmPlcpBIP=atmAceAlarmPlcpBIP, prtT1Statis=prtT1Statis, hostEntry=hostEntry, radBridgeIPXSapInfBcastUpdate=radBridgeIPXSapInfBcastUpdate, ethIfIdx=ethIfIdx, dsx1CurrentLOFC=dsx1CurrentLOFC, prtInPh1MlBearerCh=prtInPh1MlBearerCh, radBridgeMngFlow=radBridgeMngFlow, agnVoiceSwConfSidt=agnVoiceSwConfSidt, radBridgeStpStatDesignatedRoot=radBridgeStpStatDesignatedRoot, mdlPbxFramerCnfgEntry=mdlPbxFramerCnfgEntry, sysBufferAlrSlot=sysBufferAlrSlot, ip2IfStatRecommendedJittBufSize=ip2IfStatRecommendedJittBufSize, radWebRanger=radWebRanger, prtExPVc4DefaultGateway=prtExPVc4DefaultGateway, prtCfgParamSlt=prtCfgParamSlt, lagLacpEnable=lagLacpEnable, atmNtePrt=atmNtePrt, ethPartnerRateMode=ethPartnerRateMode, radBridgeIntervalTxMcastFrames=radBridgeIntervalTxMcastFrames, atmAceAlarmVpMisinsertedCells=atmAceAlarmVpMisinsertedCells, atmVcQoSPeriodRef=atmVcQoSPeriodRef, atmLoopbackVpIvlEntry=atmLoopbackVpIvlEntry, sysCRdnSwitchingMode=sysCRdnSwitchingMode, mdlSHwStatus=mdlSHwStatus, agnSa=agnSa, GenAddress=GenAddress, radBridgeIPXForwarding=radBridgeIPXForwarding, sysCSs7FisuSuppression=sysCSs7FisuSuppression, prtIsdnStatusCalledIP=prtIsdnStatusCalledIP, dot1agXCfmMdEntry=dot1agXCfmMdEntry, radVmux420=radVmux420, prtInPh1MlDlciIConPrt=prtInPh1MlDlciIConPrt, atmSysIntervalTable=atmSysIntervalTable, mngIPMask=mngIPMask, ethOamSvcTotalFramesBelowDelayThresh=ethOamSvcTotalFramesBelowDelayThresh, prtExPVc4DlciSltIdx=prtExPVc4DlciSltIdx, prtExVc2Encoding=prtExVc2Encoding, atmVpCurrentRxCellsClp01=atmVpCurrentRxCellsClp01, ethOamSvcTotalMaxRoundTripDelay=ethOamSvcTotalMaxRoundTripDelay, atmAceAlarmVcErroredCells=atmAceAlarmVcErroredCells, agnCClkSrcMode=agnCClkSrcMode, radBridgeCODDisConnectMinimunFramesNumber=radBridgeCODDisConnectMinimunFramesNumber, prtCmprEntry=prtCmprEntry, mdlPsTestResult=mdlPsTestResult, systemOam=systemOam, prtCfgParamMlBtoMlAPrio=prtCfgParamMlBtoMlAPrio, atmVpCurrentClp0Discards=atmVpCurrentClp0Discards, agnGroupEntry=agnGroupEntry, sysCRdnBufferErrorsThreshold=sysCRdnBufferErrorsThreshold, mappingProfileObjects=mappingProfileObjects, agnEgressRateRange=agnEgressRateRange, radBridgeCODImplicitSwitch=radBridgeCODImplicitSwitch, qosFlowMappingToUdpDestPort=qosFlowMappingToUdpDestPort, atmVcCurrentClp0CellOuts=atmVcCurrentClp0CellOuts, prtClkSrcCnfgIdx=prtClkSrcCnfgIdx, rowInfoTableId=rowInfoTableId, ip2IfStatMaxRoundTripDelay=ip2IfStatMaxRoundTripDelay, agnCT1E1RingRecTime=agnCT1E1RingRecTime, prtInPh1MlFlowControl=prtInPh1MlFlowControl, prtPhyIntervalLOS=prtPhyIntervalLOS, systemOamDescrCCDirection=systemOamDescrCCDirection, ripSapIfConfMode=ripSapIfConfMode, intSwdlToSubSystem=intSwdlToSubSystem, atmVcPMIntervalMisinsertedCells=atmVcPMIntervalMisinsertedCells, atmIfCurrentHecErrorSeconds=atmIfCurrentHecErrorSeconds, prtGenRdnStatus=prtGenRdnStatus, prtExPVc4TransportProtocol=prtExPVc4TransportProtocol, prtT1E1CnfgIdx=prtT1E1CnfgIdx, swdlStatusStatus=swdlStatusStatus)
mibBuilder.exportSymbols("RAD-MIB", dot3OamXPeerState=dot3OamXPeerState, prtExLs2CnfgIdx=prtExLs2CnfgIdx, agnSAlrSeverity=agnSAlrSeverity, agnCT1E1RingCnfgIdx=agnCT1E1RingCnfgIdx, prtGenActiveStatus=prtGenActiveStatus, atmVcPMIntervalTxClp0=atmVcPMIntervalTxClp0, atmVcPMCurrentTxClp0=atmVcPMCurrentTxClp0, agnVoiceSwConfRtData=agnVoiceSwConfRtData, radRiciSE=radRiciSE, radBridgeMaskType=radBridgeMaskType, prtParamSignalLevel=prtParamSignalLevel, agnListDecodingAcmRelaySlt=agnListDecodingAcmRelaySlt, atmVpIntervalShaperTotalDiscards=atmVpIntervalShaperTotalDiscards, ripSapIfConfEntry=ripSapIfConfEntry, agnGroupTable=agnGroupTable, mngTrapMask=mngTrapMask, mdlCmprTypIdx=mdlCmprTypIdx, atmVcPMIntervalVpi=atmVcPMIntervalVpi, radBridgePortVlanMemberTable=radBridgePortVlanMemberTable, qosFlowMappingTable=qosFlowMappingTable, radBridgePortBaseVlanIdx=radBridgePortBaseVlanIdx, radRIC155=radRIC155, atmVpCurrentTotalCellOuts=atmVpCurrentTotalCellOuts, radOptimux155DS3=radOptimux155DS3, radAce3400PSN=radAce3400PSN, prtSAlarmCounter=prtSAlarmCounter, radBridgeMaskActiveBit2=radBridgeMaskActiveBit2, sysRedundancyActivePortTrap=sysRedundancyActivePortTrap, agnCnfgAlrMask=agnCnfgAlrMask, statPrtGen=statPrtGen, prtExLs6ClkMode=prtExLs6ClkMode, prtExTsCnfgIdx=prtExTsCnfgIdx, radGen=radGen, atmVpIntervalTotalCellOuts=atmVpIntervalTotalCellOuts, agnAlrBufCmprTable=agnAlrBufCmprTable, prtLogicalCnfgEntry=prtLogicalCnfgEntry, prtExHsrCnfgEntry=prtExHsrCnfgEntry, prtExPVc4DestIp=prtExPVc4DestIp, radRIC155GE=radRIC155GE, ip2IfMplsTxLabelEnable=ip2IfMplsTxLabelEnable, radMepTransmitLtmTtl=radMepTransmitLtmTtl, qosFlowMappingFromIpPrecedence=qosFlowMappingFromIpPrecedence, mdlMux=mdlMux, agnListDecodingDescription=agnListDecodingDescription, prtSExHsfStatEntry=prtSExHsfStatEntry, prtExMbeCnfgEntry=prtExMbeCnfgEntry, agnStatusChangeTrap=agnStatusChangeTrap, atmNteSysConfig=atmNteSysConfig, prtIpParamVlanTagging=prtIpParamVlanTagging, swdlStatusTypeIdx=swdlStatusTypeIdx, prtParamClkQualityLevel=prtParamClkQualityLevel, prtT1FdlMsgTable=prtT1FdlMsgTable, alarmForwardingEntry=alarmForwardingEntry, prtPerfBlocksPerSec=prtPerfBlocksPerSec, prtGenCnfgInbandMngRoutProt=prtGenCnfgInbandMngRoutProt, ip2IfTable=ip2IfTable, RadTransportAddressType=RadTransportAddressType, prtT1E1TxGainMask=prtT1E1TxGainMask, radMBE8=radMBE8, atmVcPMIntervalTable=atmVcPMIntervalTable, prtSpTable=prtSpTable, prtExLs6CtrlSignal=prtExLs6CtrlSignal, agnClkIntervalIndex=agnClkIntervalIndex, ethIfSrcMacCtrlAddr=ethIfSrcMacCtrlAddr, prtExPh1MlTsIConSlot=prtExPh1MlTsIConSlot, mdlSAlrStatusAll=mdlSAlrStatusAll, prtExPVc4DiscOnSilence=prtExPVc4DiscOnSilence, systemPsIndex1=systemPsIndex1, atmVpCurrentShaperTotalDiscards=atmVpCurrentShaperTotalDiscards, agnDeviceCapabilities=agnDeviceCapabilities, atmNteIdTable=atmNteIdTable, wrIpAddressEntry=wrIpAddressEntry, prtInPh1MlFullRptPeriod=prtInPh1MlFullRptPeriod, radDXC8RNew=radDXC8RNew, prtInPh1MlProtocol=prtInPh1MlProtocol, atmIfDataEntry=atmIfDataEntry, prtIsdnDirectoryTeiId=prtIsdnDirectoryTeiId, prtExPVc4DlciTxBc=prtExPVc4DlciTxBc, mdlSAlrCounter=mdlSAlrCounter, prtInPh1MlConnectionTyp=prtInPh1MlConnectionTyp, swdlStatusEntry=swdlStatusEntry, dsx1IntervalFEBE=dsx1IntervalFEBE, atmConfIfOutputRate=atmConfIfOutputRate, prtSBertClrCmd=prtSBertClrCmd, radBridgeIPXdriver=radBridgeIPXdriver, mdlSInstEntry=mdlSInstEntry, prtExHsiInterface=prtExHsiInterface, atmVpPMIntervalTxClp01=atmVpPMIntervalTxClp01, portTrafficClassTable=portTrafficClassTable, mdlSTemperature=mdlSTemperature, lag=lag, agnCFlipNetEventsEntry=agnCFlipNetEventsEntry, prtSupervisoryRate=prtSupervisoryRate, prtDlciTxFecn=prtDlciTxFecn, ifCreateIndex=ifCreateIndex, agnMux=agnMux, agnClkSrcPortCnfgIdx=agnClkSrcPortCnfgIdx, agnCBuMlCnfgIdx=agnCBuMlCnfgIdx, atmConfIfTransmitClk=atmConfIfTransmitClk, ethOamSvcTotalUnavailSec=ethOamSvcTotalUnavailSec, radOp4E1NG1=radOp4E1NG1, radBridgeIntervalTxBcastFrames=radBridgeIntervalTxBcastFrames, atmVpPMCurrentErroredCells=atmVpPMCurrentErroredCells, prtExVcPbxRestoreTime=prtExVcPbxRestoreTime, prtExVcPbxLinkTo=prtExVcPbxLinkTo, agnSigProfName=agnSigProfName, prtDacsMux=prtDacsMux, radLrs102unbal=radLrs102unbal, prtGenEntry=prtGenEntry, agnVoiceSwConfRtPort=agnVoiceSwConfRtPort, lagStatEntry=lagStatEntry, radFEC1=radFEC1, atmNteSlotUsage=atmNteSlotUsage, wrSpoofingTable=wrSpoofingTable, ifTeQosParam=ifTeQosParam, atmAceAlarmLOF=atmAceAlarmLOF, prtSupervisoryInterface=prtSupervisoryInterface, radMepLtrIngressPortIdSubtype=radMepLtrIngressPortIdSubtype, mdlPsStatus=mdlPsStatus, atmAceAlarmTrap=atmAceAlarmTrap, agnCQ50Entry=agnCQ50Entry, prtPhMlControlSignals=prtPhMlControlSignals, radHtuT1=radHtuT1, agnSEntryIsValid=agnSEntryIsValid, prtHdslEntry=prtHdslEntry, radMepCcStatusTable=radMepCcStatusTable, atmVcIntervalMCR=atmVcIntervalMCR, ethIfOamEfm=ethIfOamEfm, radFomiE3=radFomiE3, systemNtpServerAddress=systemNtpServerAddress, systemVoiceCoderTable=systemVoiceCoderTable, radPrbiT3=radPrbiT3, prtT1FdlMsgPrtIdx=prtT1FdlMsgPrtIdx, dsx1RestoreTime=dsx1RestoreTime, atmSysFanUnits=atmSysFanUnits, radBridgeMaskFrom2=radBridgeMaskFrom2, prtFrTxBeViol=prtFrTxBeViol, prtIsdnStatusCalledNumber=prtIsdnStatusCalledNumber, prtExVc2CallerIdEnable=prtExVc2CallerIdEnable, atmVpIntervalEntry=atmVpIntervalEntry, prtT1E1LineCode=prtT1E1LineCode, ip2IfWap=ip2IfWap, agnCT1E1RingSecSlot=agnCT1E1RingSecSlot, maskingTable=maskingTable, ethMdiXManualSwitch=ethMdiXManualSwitch, prtFrPlusSltIdx=prtFrPlusSltIdx, prtExPVc4CnfgIdx=prtExPVc4CnfgIdx, radVmux120=radVmux120, atmAceAlarmVcLostCells=atmAceAlarmVcLostCells, prtT1E1CnfgTable=prtT1E1CnfgTable, atmGenSysSelfTestEntry=atmGenSysSelfTestEntry, schedXTable=schedXTable, prtT1E1FdlMsgEntry=prtT1E1FdlMsgEntry, radBridgeCODCondTable=radBridgeCODCondTable, atmVcCurrentShaperClp1Discards=atmVcCurrentShaperClp1Discards, prtExPVc4DlciRxBc=prtExPVc4DlciRxBc, atmNteShaperMode=atmNteShaperMode, qosFlowMappingFromDestIpAddr=qosFlowMappingFromDestIpAddr, prtExHs4TsCnfgIdx=prtExHs4TsCnfgIdx, wfqWeightValue=wfqWeightValue, atmNtePrtConfig=atmNtePrtConfig, agnAlrBufCmprObj=agnAlrBufCmprObj, systemPsType=systemPsType, prtExPh1MlLineType=prtExPh1MlLineType, agnDlciStatus=agnDlciStatus, radETX510=radETX510, prtVc2CnfgEntry=prtVc2CnfgEntry, prtIn1p6VcPbxRate=prtIn1p6VcPbxRate, atmVcQoSTable=atmVcQoSTable, atmVpPmSink=atmVpPmSink, wfqTblIdx=wfqTblIdx, prtT1E1BpvMax=prtT1E1BpvMax, alrBufIdxUponLastAck=alrBufIdxUponLastAck, atmSysConfigCellTestClp=atmSysConfigCellTestClp, radRRTRE8D=radRRTRE8D, prtT1E1OosSignal=prtT1E1OosSignal, radBridgeIPXSapOutPackets=radBridgeIPXSapOutPackets, radHcdE1=radHcdE1, atmConfIfOamMode=atmConfIfOamMode, serviceStatTable=serviceStatTable, muxHubEvents=muxHubEvents, agnCSaveCnfgIdxCmd=agnCSaveCnfgIdxCmd, tftpStatus=tftpStatus, agnCurrClkHoldover=agnCurrClkHoldover, ifTeQosParam2=ifTeQosParam2, sysCRdnEntry=sysCRdnEntry, prtDlciCmprVersion=prtDlciCmprVersion, prtExClCnfgIdx=prtExClCnfgIdx, atmIfUncorrectedHecs=atmIfUncorrectedHecs, prtT3E3CnfgTable=prtT3E3CnfgTable, radSEC2=radSEC2, prtExVc3EchoCanceler=prtExVc3EchoCanceler, prtIsdnAbSide=prtIsdnAbSide, atmNteConfVpTable=atmNteConfVpTable, atmVpIntervalShaperClp0Discards=atmVpIntervalShaperClp0Discards, atmVcCurrentRxCellsClp0=atmVcCurrentRxCellsClp0, prtInLs6TandemMode=prtInLs6TandemMode, prtExPVc4Oos=prtExPVc4Oos, prtCnfgAgendaPrtIdx=prtCnfgAgendaPrtIdx, agnNearFarConnection=agnNearFarConnection, atmVcPMQoSCER=atmVcPMQoSCER, prtExVc2ImpedanceStandard=prtExVc2ImpedanceStandard, agnSigProfType=agnSigProfType, prtGenInterfaceType=prtGenInterfaceType, optPrtMonitorSample=optPrtMonitorSample, atmConfIfHwFeatures=atmConfIfHwFeatures, prtTestOamAvgRoundTripDelay=prtTestOamAvgRoundTripDelay, prtSExHsfSltIdx=prtSExHsfSltIdx, autoFileTransferFileName=autoFileTransferFileName, dsx1LineMode=dsx1LineMode, radBridgeIPXRipInfAgeMultiplier=radBridgeIPXRipInfAgeMultiplier, ip2IfStatRxMeasuredSilence=ip2IfStatRxMeasuredSilence, prtExPhPlDlciCnfgIdx=prtExPhPlDlciCnfgIdx, agnCnfgAlarm=agnCnfgAlarm, qosFlowMappingRowStatus=qosFlowMappingRowStatus, prtIsdnEndpointPrtIdx=prtIsdnEndpointPrtIdx, ethIfSrcMacCtrlViolationAction=ethIfSrcMacCtrlViolationAction, ip2IfStatRdnFlip=ip2IfStatRdnFlip, prtHSInbandLoopActPattern=prtHSInbandLoopActPattern, radAce101=radAce101, agnSClkSrc=agnSClkSrc, prtIsdnEndpointTeiType=prtIsdnEndpointTeiType, atmAlarmForwardingTable=atmAlarmForwardingTable, prtBertRunTime=prtBertRunTime, prtAlr=prtAlr, agnCFlipDiscardDe=agnCFlipDiscardDe, sysCRdnOnline=sysCRdnOnline, prtExPh1MlTxGain=prtExPh1MlTxGain, radMepIdx=radMepIdx, ethIfSrcMacCtrlAddrEntry=ethIfSrcMacCtrlAddrEntry, radSAH16Eext=radSAH16Eext, agnCT1E1RingSecPort=agnCT1E1RingSecPort, chasTotalNoOfIoSlt=chasTotalNoOfIoSlt, srvForwardYellowPacketsOverflow=srvForwardYellowPacketsOverflow, agnSCmprErrListTable=agnSCmprErrListTable, prtParamAlarmIndication=prtParamAlarmIndication, prtAcmSltIdx=prtAcmSltIdx, ethOamServiceOverflowFramesAboveDelayVar=ethOamServiceOverflowFramesAboveDelayVar, prtLogicalConnect=prtLogicalConnect, radFcdE1L=radFcdE1L, radBridgeDot1qVlanUnmodifiedPorts=radBridgeDot1qVlanUnmodifiedPorts, ethOamSvcCurrAvgRoundTripDelay=ethOamSvcCurrAvgRoundTripDelay, linkSelectorCnfgTable=linkSelectorCnfgTable, sysBufferAlrUpTime=sysBufferAlrUpTime, ifPerfCounterType=ifPerfCounterType, prtFrRxBcViol=prtFrRxBcViol, flipDbChangeTrap=flipDbChangeTrap, atmVpIntervalTaggedOuts=atmVpIntervalTaggedOuts, alrGenTable=alrGenTable, prtIsdnCnfgTable=prtIsdnCnfgTable, radBridgeStpStatTable=radBridgeStpStatTable, prtLanWanSltIdx=prtLanWanSltIdx, radHcd4Sa=radHcd4Sa, prtExHsfOperMode=prtExHsfOperMode)
mibBuilder.exportSymbols("RAD-MIB", prtMonCnfgIdx=prtMonCnfgIdx, radOp16E1LS=radOp16E1LS, prtExVcPbxSignalOper=prtExVcPbxSignalOper, atmAceAlarmVcUnexpectedCell=atmAceAlarmVcUnexpectedCell, mdlClLastFlipDate=mdlClLastFlipDate, agnAccess=agnAccess, prtExVc2WesternSigMode=prtExVc2WesternSigMode, maskingHighLevelProtCondition=maskingHighLevelProtCondition, ifPerfLowCounterPart=ifPerfLowCounterPart, atmVpCrossConnectExtenEntry=atmVpCrossConnectExtenEntry, prtGenCnfgInbandMng=prtGenCnfgInbandMng, mdlStatSltIdx=mdlStatSltIdx, systemOamDescrRowStatus=systemOamDescrRowStatus, prtExPVc4SignalingProtocol=prtExPVc4SignalingProtocol, dsx1DataStreamStatOutBytes=dsx1DataStreamStatOutBytes, sysSErrListTable=sysSErrListTable, ip2IfIntervalStatBufOverflows=ip2IfIntervalStatBufOverflows, prtExPh1MlTsSigProfile=prtExPh1MlTsSigProfile, radBridgeGenCfgIdx=radBridgeGenCfgIdx, agnCnfgAlrInvert=agnCnfgAlrInvert, prtExHs4TsIConTs=prtExHs4TsIConTs, atmNteLoopback=atmNteLoopback, prtMl4CrossConnectLevel=prtMl4CrossConnectLevel, atmVpQoSPeriodRef=atmVpQoSPeriodRef, prtPhMlClockSource=prtPhMlClockSource, prtExPh1MlSigService=prtExPh1MlSigService, agnSErrListTable=agnSErrListTable, maskingDestMacOrNet=maskingDestMacOrNet, radBridgePortCnfgDot1x=radBridgePortCnfgDot1x, radEP4FL=radEP4FL, maskingIndex=maskingIndex, ethIfCurrentOutUnicastFrames=ethIfCurrentOutUnicastFrames, atmPvcPerformance=atmPvcPerformance, agnAlarmBufferClear=agnAlarmBufferClear, prtExHsrDcdDsr=prtExHsrDcdDsr, atmVcCurrentTotalCellOuts=atmVcCurrentTotalCellOuts, atmLoopbackVcIfIndex=atmLoopbackVcIfIndex, ethBroadcastBlock=ethBroadcastBlock, wrDhcpDefaultGateway=wrDhcpDefaultGateway, prtGenCnfgEntry=prtGenCnfgEntry, agnSAlrCodeDescription=agnSAlrCodeDescription, atmNte=atmNte, agnTsCmprSlotIdx=agnTsCmprSlotIdx, dot3OamOperStatusChange=dot3OamOperStatusChange, wrLanIfEntry=wrLanIfEntry, intSwdlCardType=intSwdlCardType, prtExPhPlTc=prtExPhPlTc, radBridgeIPXRipInPackets=radBridgeIPXRipInPackets, prtHsrCnfg=prtHsrCnfg, mapLinkPrtIdx=mapLinkPrtIdx, prtAlarmsCmprVersion=prtAlarmsCmprVersion, atmVpPMCurrentMisinsertedCells=atmVpPMCurrentMisinsertedCells, atmAceAlarmPlcpYELLOW=atmAceAlarmPlcpYELLOW, radAce3200PSN=radAce3200PSN, prtExVcPbxLineLength=prtExVcPbxLineLength, sysDclConfigDownloadSrc=sysDclConfigDownloadSrc, prtDimClkMode=prtDimClkMode, ethLimit4=ethLimit4, ethIfIntervalOutOctets=ethIfIntervalOutOctets, atmVpCrossConnectExtenTable=atmVpCrossConnectExtenTable, agnAlarmsCmprObj=agnAlarmsCmprObj, prtExPVc4MultiplexInterval=prtExPVc4MultiplexInterval, wfqPrtIdx=wfqPrtIdx, agnDlciLPrtIdx=agnDlciLPrtIdx, radImxi4=radImxi4, systemPsStatus=systemPsStatus, atmVpShaperStatEntry=atmVpShaperStatEntry, atmVcPMIntervalECB=atmVcPMIntervalECB, atmVcShaperLevel=atmVcShaperLevel, autoFileTransferScheduling=autoFileTransferScheduling, atmLoopbackVpIvlIfIndex=atmLoopbackVpIvlIfIndex, systemTime=systemTime, atmNteOamEntry=atmNteOamEntry, radBridgeIntervalRxCorrectBytes=radBridgeIntervalRxCorrectBytes, radBridgePortCnfgDefaultVci=radBridgePortCnfgDefaultVci, atmIntervalDateInterval=atmIntervalDateInterval, atmGenSysCxRefIndex=atmGenSysCxRefIndex, schedWeekInMonth=schedWeekInMonth, wrLanIfState=wrLanIfState, sysCRdnFlipUponEvent=sysCRdnFlipUponEvent, prtIpParamProtIpEnable=prtIpParamProtIpEnable, atmLoopbackVpIvlMaxDelay=atmLoopbackVpIvlMaxDelay, qInternalProfileTable=qInternalProfileTable, agnCT1E1RingTable=agnCT1E1RingTable, dsx1XCurrentEntry=dsx1XCurrentEntry, modlParamLeds=modlParamLeds, prtCmprObj=prtCmprObj, dsx1DataStreamStatValid=dsx1DataStreamStatValid, prtExPhPlModemCnfgIdx=prtExPhPlModemCnfgIdx, atmLoopbackVcMinDelay=atmLoopbackVcMinDelay, atmNteMdl=atmNteMdl, radFEC2UDP=radFEC2UDP, agnRowPointerNoOfUsages=agnRowPointerNoOfUsages, ethIfSrcMacCtrlIndex=ethIfSrcMacCtrlIndex, radMepLtrEgressPortIdSubtype=radMepLtrEgressPortIdSubtype, markingProfileRowStatus=markingProfileRowStatus, radVmux312=radVmux312, agnStringToIndexTableId=agnStringToIndexTableId, prtInTreLinkTo=prtInTreLinkTo, atmVpIntervalMCR=atmVpIntervalMCR, atmVcCurrentShaperTotalDiscards=atmVcCurrentShaperTotalDiscards, radBridgeIPXRipDestNetwork=radBridgeIPXRipDestNetwork, agnSigProfileCnfgIdx=agnSigProfileCnfgIdx, ethPortMngEnable=ethPortMngEnable, prtExPh1MlRedundSlot=prtExPh1MlRedundSlot, mdlPbxFraTSGroupAss=mdlPbxFraTSGroupAss, prtFrRxBecn=prtFrRxBecn, radMP4100=radMP4100, sysDbaseSanityCheckCmd=sysDbaseSanityCheckCmd, prtIpParamMaxTxBandwidth=prtIpParamMaxTxBandwidth, prtLanWanCnfgIdx=prtLanWanCnfgIdx, mdlSActivity=mdlSActivity, ethIfIntervalOverflowInPauseFrames=ethIfIntervalOverflowInPauseFrames, ethOamSvcCurrAvgRoundTripDVar=ethOamSvcCurrAvgRoundTripDVar, srvForwardYellowBytes=srvForwardYellowBytes, alrBufDescription=alrBufDescription, prtExHsrLlbEnable=prtExHsrLlbEnable, ethOamSvcCurrFramesBelowDVarThresh=ethOamSvcCurrFramesBelowDVarThresh, atmAceAlarmLOS=atmAceAlarmLOS, maskingMaxEntries=maskingMaxEntries, radEGate100=radEGate100, atmVcIntervalShaperClp0Discards=atmVcIntervalShaperClp0Discards, prtExVc2RingerFrequency=prtExVc2RingerFrequency, prtBertClearCounters=prtBertClearCounters, radBridgeCODTimeTriggerStatus=radBridgeCODTimeTriggerStatus, radOamIdx1=radOamIdx1, ds1ExcessiveFrameSlipTrap=ds1ExcessiveFrameSlipTrap, ethOamServiceElapsedTime=ethOamServiceElapsedTime, atmVcPMIntervalDir=atmVcPMIntervalDir, prtParamFarEndDevice=prtParamFarEndDevice, prtAlarmsCmprAlarmIdx=prtAlarmsCmprAlarmIdx, mdlStatTable=mdlStatTable, radBridgeCODOriginateDisConnectDelay=radBridgeCODOriginateDisConnectDelay, prtPriorityIngressRateLimit=prtPriorityIngressRateLimit, radAce2E=radAce2E, ethBridgingMode=ethBridgingMode, ip2IfStatFrameTrackDupDrop=ip2IfStatFrameTrackDupDrop, wrIpIfIndex=wrIpIfIndex, prtExVc2Sig=prtExVc2Sig, atmLoopbackVcMaxDelay=atmLoopbackVcMaxDelay, radRICE1=radRICE1, webranger=webranger, prtExPVc4DlciIConDlci=prtExPVc4DlciIConDlci, prtT3E3=prtT3E3, prtIsdnMode=prtIsdnMode, prtExPVc4SltIdx=prtExPVc4SltIdx, prtExHsiLinkTo=prtExHsiLinkTo, prtExHsfLinkTo=prtExHsfLinkTo, prtHSBertTable=prtHSBertTable, radBridgeIPXSapNetwork=radBridgeIPXSapNetwork, prtFrRxBeViol=prtFrRxBeViol, sysDclActiveCl=sysDclActiveCl, agnCmprEntry=agnCmprEntry, sysSAlrTable=sysSAlrTable, ds1ExcessiveBpvTrap=ds1ExcessiveBpvTrap, atmConfIfOamFailureInd=atmConfIfOamFailureInd, radBridgeAction=radBridgeAction, prtDs3IntervalEntry=prtDs3IntervalEntry, prtPhMlClockPolarity=prtPhMlClockPolarity, prtInPh1MlDlciTxBe=prtInPh1MlDlciTxBe, ip2IfStatChIndex=ip2IfStatChIndex, radLrs102=radLrs102, radBridgeGenFlowIdx=radBridgeGenFlowIdx, atmVpPMCurrentTxClp0=atmVpPMCurrentTxClp0, radConverters=radConverters, radBridgeCODIPMask=radBridgeCODIPMask, radOpXLE1=radOpXLE1, ethIfCurrentFCSErrors=ethIfCurrentFCSErrors, radTRE1=radTRE1, prtSupervisoryDcdDelay=prtSupervisoryDcdDelay, qosFlowMappingIdx2=qosFlowMappingIdx2, atmVcPMIntervalES=atmVcPMIntervalES, agnCAgendaEntry=agnCAgendaEntry, prtInHsiConnect=prtInHsiConnect, radAmcdT1=radAmcdT1, atmNteHostRdnVci=atmNteHostRdnVci, radBridgeCODCondIfIndex=radBridgeCODCondIfIndex, agnCurrClkSsmBased=agnCurrClkSsmBased, atmTrafficDescrParamXEntry=atmTrafficDescrParamXEntry, wfqMinRateAbsolute=wfqMinRateAbsolute, maskingSourceCondition=maskingSourceCondition, prtLanWanCnfgEntry=prtLanWanCnfgEntry, agnSEditBy=agnSEditBy, atmAceAlarmVcGCRAViolation=atmAceAlarmVcGCRAViolation, ip2IfRdnState=ip2IfRdnState, prtExVc2CasStd=prtExVc2CasStd, agnVoiceSwConfRtIdx=agnVoiceSwConfRtIdx, atmVpCurrentSES=atmVpCurrentSES, ethIfCurrentOverflowInPauseFrames=ethIfCurrentOverflowInPauseFrames, prtPhMlSatBuffer=prtPhMlSatBuffer, ethIfIntervalInMulticastFrames=ethIfIntervalInMulticastFrames, radHtuE1SaV2=radHtuE1SaV2, atmNteVcAlarmVci=atmNteVcAlarmVci, prtPerfTable=prtPerfTable, atmVpCurrentShaperClp1Discards=atmVpCurrentShaperClp1Discards, ip2IfStatEntry=ip2IfStatEntry, ethIfCurrentOverflowOutUnicastFrames=ethIfCurrentOverflowOutUnicastFrames, agnListDecodingCode=agnListDecodingCode, agnClkCurrentOutOfOrderPackets=agnClkCurrentOutOfOrderPackets, prtIpParamDoubleTagVlanPriority=prtIpParamDoubleTagVlanPriority, ip2IfLogEvents=ip2IfLogEvents, ethIfIntervalOutPauseFrames=ethIfIntervalOutPauseFrames, agnCClkSrcSlt=agnCClkSrcSlt, ethFlowCtrlMacAddress=ethFlowCtrlMacAddress, atmNteHostRdnVpi=atmNteHostRdnVpi, radMP2100H=radMP2100H, radBridgePerformance=radBridgePerformance, sysBufferAlrInfo=sysBufferAlrInfo, agnDlciSpoofing=agnDlciSpoofing, atmNteHostAtmIfIndex=atmNteHostAtmIfIndex, prtExVc2IfSignaling=prtExVc2IfSignaling, prtExLs2EnvIdx=prtExLs2EnvIdx, cosProfileCosMethod=cosProfileCosMethod, ip2IfDataOos=ip2IfDataOos, muxHub=muxHub, prtExVcPbxTsRemTs=prtExVcPbxTsRemTs, radMlAtmE1=radMlAtmE1, agnCFlipEntry=agnCFlipEntry, alarmForwardingCause=alarmForwardingCause, radBridgeGenCnfg=radBridgeGenCnfg, agnSensorsStatus=agnSensorsStatus, prtExVcPbxTsIConSlot=prtExVcPbxTsIConSlot, mdlCProgCardType=mdlCProgCardType, prtIsdnDirectoryRemoteAddr2=prtIsdnDirectoryRemoteAddr2, sysDbaseUploadCnfgIdxCmd=sysDbaseUploadCnfgIdxCmd, radBridgeIPXSapTblBcastTrigUpdateInterval=radBridgeIPXSapTblBcastTrigUpdateInterval, sysBufferAlrDate=sysBufferAlrDate, radBridgeCODManualConnect=radBridgeCODManualConnect, agnUploadDataTrap=agnUploadDataTrap, xcIfIndex2=xcIfIndex2, prtTestDestinationIpAddress=prtTestDestinationIpAddress, prtExPh1MlRestoreTime=prtExPh1MlRestoreTime, radETX102A=radETX102A, physicalConnectorTable=physicalConnectorTable, prtLanWanMtu=prtLanWanMtu, ip2IfBundleUsage=ip2IfBundleUsage, atmVcPMCurrentLastDayQuality=atmVcPMCurrentLastDayQuality, dhcpClientTable=dhcpClientTable, prtT1E1RAI=prtT1E1RAI, prtExHs4OosCode=prtExHs4OosCode, ip2IfStatMaxJittBufLevel=ip2IfStatMaxJittBufLevel, prtExHsiConnect=prtExHsiConnect, ethOamSvcCurrFramesAboveDVarThresh=ethOamSvcCurrFramesAboveDVarThresh, ethIfCurrentOverflowOutFrames=ethIfCurrentOverflowOutFrames, bitMappingLocation=bitMappingLocation, prtGenPrtIdx=prtGenPrtIdx, prtHSPrtIdx=prtHSPrtIdx, radHtuE1V2=radHtuE1V2, ethIfIntervalOverflowMultipleCollisionFrames=ethIfIntervalOverflowMultipleCollisionFrames, prtMl4IpMask=prtMl4IpMask, agnListDecodingType=agnListDecodingType, dsx1CurrentLOC=dsx1CurrentLOC, agnClkCurrentEntry=agnClkCurrentEntry, agnSActiveCnfg=agnSActiveCnfg)
mibBuilder.exportSymbols("RAD-MIB", xcIfIndex1=xcIfIndex1, agnCmprVersion=agnCmprVersion, atmVpIntervalShaperClp1Discards=atmVpIntervalShaperClp1Discards, atmNteTotalPm=atmNteTotalPm, prtExLs6Connect=prtExLs6Connect, atmVpPMQoSDirection=atmVpPMQoSDirection, prtSTstCmd=prtSTstCmd, prtExVc3Connect=prtExVc3Connect, ip2IfClockPreferences=ip2IfClockPreferences, mdlSAlrState=mdlSAlrState, prtIsdnStatusDspMode=prtIsdnStatusDspMode, atmVpIntervalTable=atmVpIntervalTable, queueGroupTable=queueGroupTable, atmNteManagerVpi=atmNteManagerVpi, prtClkSrc=prtClkSrc, prtIsdnEndpointTeiValue=prtIsdnEndpointTeiValue, radBridgeCODIfIndex=radBridgeCODIfIndex, prtExHsfRate=prtExHsfRate, sysBufferAlrEntry=sysBufferAlrEntry, prtHSInbandLoopPatternCfg=prtHSInbandLoopPatternCfg, ip2IfConnectivityMode=ip2IfConnectivityMode, prtExLs6CnfgTable=prtExLs6CnfgTable, atmNteAlarmVcEntry=atmNteAlarmVcEntry, radOpt4E1C=radOpt4E1C, ip2IfStatPsnRxFrames=ip2IfStatPsnRxFrames, radBridgeIPXRipInfBcastUpdate=radBridgeIPXRipInfBcastUpdate, atmNteManagerNextHop=atmNteManagerNextHop, agnCurrClkEntry=agnCurrClkEntry, prtInTreRate=prtInTreRate, atmVcPMIntervalSECB=atmVcPMIntervalSECB, ip2IfMplsRxLabel=ip2IfMplsRxLabel, prtInTreCnfgIdx=prtInTreCnfgIdx, RadTransportAddressEfmOam=RadTransportAddressEfmOam, prtPhyIntervalNumber=prtPhyIntervalNumber, sysHub=sysHub, ethOamSvcTotalFramesBelowDVarThresh=ethOamSvcTotalFramesBelowDVarThresh, ethIfRingMultiCastVlanId=ethIfRingMultiCastVlanId, radBridgeIPXRipPolicy=radBridgeIPXRipPolicy, prtExPVc4EchoCanceler=prtExPVc4EchoCanceler, gfpVcatHeader=gfpVcatHeader, mdlClLastFlipTime=mdlClLastFlipTime, atmVcQoSElapsedTime=atmVcQoSElapsedTime, radIpMux11=radIpMux11, agnClockMonitoring=agnClockMonitoring, atmVcCrossConnectName=atmVcCrossConnectName, sysConfig=sysConfig, dot3OamDescrRateLimit=dot3OamDescrRateLimit, rowInfoIndexNext=rowInfoIndexNext, atmLoopbackVcIvlAverageDelay=atmLoopbackVcIvlAverageDelay, prtInHsiCnfgIdx=prtInHsiCnfgIdx, sysSRdnFlipTime=sysSRdnFlipTime, modlParamSwdlStatus=modlParamSwdlStatus, agnCAgendaCnfgIdx=agnCAgendaCnfgIdx, prtExTsIConSlot=prtExTsIConSlot, systemDefaultGateway=systemDefaultGateway, mdlAlrMaskEntry=mdlAlrMaskEntry, atmNteAlarmIfTable=atmNteAlarmIfTable, ethOamSvcIntervalTable=ethOamSvcIntervalTable, prtParamTable=prtParamTable, prtGenTestRunning=prtGenTestRunning, prtT1E1LineLengthMask=prtT1E1LineLengthMask, dsx1IntervalBPV=dsx1IntervalBPV, agnSAlrInvert=agnSAlrInvert, prtIn7p8VcPbxConnect=prtIn7p8VcPbxConnect, ip2IfFarEndTdmStatus=ip2IfFarEndTdmStatus, atmVcQoSEntry=atmVcQoSEntry, atmAceUnavailableBwTrap=atmAceUnavailableBwTrap, radBridgeIPXSapInPackets=radBridgeIPXSapInPackets, atmNteConfCAC=atmNteConfCAC, atmNteOamMode=atmNteOamMode, prtDestCnfgIdx=prtDestCnfgIdx, atmLoopbackVcIvlMaxDelay=atmLoopbackVcIvlMaxDelay, prtInPh1MlFrWindowSize=prtInPh1MlFrWindowSize, agnAlarmsCmprAlarmIdx=agnAlarmsCmprAlarmIdx, dscpMappingEntry=dscpMappingEntry, prtInTrePrtIdx=prtInTrePrtIdx, agnAlrBufCmprEntry=agnAlrBufCmprEntry, prtHsfPrtIdx=prtHsfPrtIdx, systemVoiceFaxRate=systemVoiceFaxRate, sysCClkSrcTable=sysCClkSrcTable, atmNteConfOamRDI=atmNteConfOamRDI, prtExVc2NoiseLevelForVAD=prtExVc2NoiseLevelForVAD, radBridgeIntervalTxCorrectFrames=radBridgeIntervalTxCorrectFrames, ds1ExcessiveLocalSyncLossTrap=ds1ExcessiveLocalSyncLossTrap, ip2IfStatRxCorrectFrames=ip2IfStatRxCorrectFrames, prtAcmPrtIdx=prtAcmPrtIdx, prtIpParamRingMode=prtIpParamRingMode, mdlProtIpTable=mdlProtIpTable, maskingSourceMacOrNet=maskingSourceMacOrNet, ip2IfCurrentStatTable=ip2IfCurrentStatTable, ethOamSvcCurrentStatTable=ethOamSvcCurrentStatTable, mdlAlrMaskTable=mdlAlrMaskTable, ip2IfStatFrameTrackMissing=ip2IfStatFrameTrackMissing, prtExPh1MlQ50SignalPair=prtExPh1MlQ50SignalPair, autoFileTransferServerIp=autoFileTransferServerIp, prtIpParamEncapProtPort=prtIpParamEncapProtPort, prtInHsiCnfgTable=prtInHsiCnfgTable, prtIn7p8VcPbxLinkTo=prtIn7p8VcPbxLinkTo, alarmLOF=alarmLOF, qProfileName=qProfileName, prtTest=prtTest, agnTrapValue=agnTrapValue, atmVcCurrentCDC=atmVcCurrentCDC, prtGenTsTable=prtGenTsTable, sysSAlrClearCmd=sysSAlrClearCmd, agnVoiceSwConfLidt=agnVoiceSwConfLidt, ip2IfVlanPriority=ip2IfVlanPriority, radFcdE1LC=radFcdE1LC, systemDate=systemDate, cnfgMdlGen=cnfgMdlGen, systemNtpCmd=systemNtpCmd, prtE2CnfgTable=prtE2CnfgTable, maskingSmartMaskOID=maskingSmartMaskOID, radFcd155EwAPS2pdh=radFcd155EwAPS2pdh, radRici4E1=radRici4E1, atmLoopbackVcVci=atmLoopbackVcVci, mdlConnectTrap=mdlConnectTrap, intSwdlEntry=intSwdlEntry, radDot1qPortVlanEthType=radDot1qPortVlanEthType, dsx1XConfigEntry=dsx1XConfigEntry, sysStatusChangedTrap=sysStatusChangedTrap, agnDlciCmprEntry=agnDlciCmprEntry, prtInPh1MlClockEncoding=prtInPh1MlClockEncoding, atmVpIntervalSCR=atmVpIntervalSCR, prtDs3CurrentBIP=prtDs3CurrentBIP, agnSigProfileRxTx=agnSigProfileRxTx, ip2IfSuperTandem=ip2IfSuperTandem, atmConfIfLowerVpi=atmConfIfLowerVpi, prtParamRxSsm=prtParamRxSsm, atmVcCurrentVpi=atmVcCurrentVpi, atmIfPerformance=atmIfPerformance, mdlSAlrInvert=mdlSAlrInvert, sysBufferAlrTime=sysBufferAlrTime, radDot1qPortEgressTagHandling=radDot1qPortEgressTagHandling, ethIfSrcMacCtrlIdx2=ethIfSrcMacCtrlIdx2, ethOamSvcIntervalFramesBelowDelayThresh=ethOamSvcIntervalFramesBelowDelayThresh, prtExPh1MlTsEntry=prtExPh1MlTsEntry, prtTestVctCmd=prtTestVctCmd, radSAH16Eint=radSAH16Eint, agnClkIntervalRxPackets=agnClkIntervalRxPackets, prtIsdnSignalingProtocol=prtIsdnSignalingProtocol, wanGen=wanGen, prtInLs6Connect=prtInLs6Connect, ethOamSvcCurrMaxRoundTripDVar=ethOamSvcCurrMaxRoundTripDVar, atmNteProgCardType=atmNteProgCardType, prtAgendaBehaviourEntry=prtAgendaBehaviourEntry, flowMappingProfileIndex=flowMappingProfileIndex, radPRBm20=radPRBm20, prtCfgParamCnfgIdx=prtCfgParamCnfgIdx, mdlPbxFraSignaling=mdlPbxFraSignaling, ip2IfStatBufUnderflows=ip2IfStatBufUnderflows, agnCnfgDataEntry=agnCnfgDataEntry, prtExPhPlDlciIdx=prtExPhPlDlciIdx, radFddi=radFddi, atmVcPmDirection=atmVcPmDirection, prtCfgParamOperatedMl=prtCfgParamOperatedMl, prtHSSlt=prtHSSlt, atmNteAlarmIfEntry=atmNteAlarmIfEntry, radRici8E1=radRici8E1, dhcpClientServerIpAddress=dhcpClientServerIpAddress, optPrtMonitorLaserTemp=optPrtMonitorLaserTemp, prtSAlrEntry=prtSAlrEntry, atmSysConfigCellTestPayload=atmSysConfigCellTestPayload, atmGenSysSetDefaultConfg=atmGenSysSetDefaultConfg, atmVpQoSElapsedTime=atmVpQoSElapsedTime, radBridgeGenFlowRowStatus=radBridgeGenFlowRowStatus, prtIsdnSwitchMode=prtIsdnSwitchMode, atmAceAlarmLineAIS=atmAceAlarmLineAIS, systemTrap=systemTrap, radSTC1=radSTC1, radBridgeCODTraffic=radBridgeCODTraffic, diverseIfWanGen=diverseIfWanGen, agnAlrBufCmprVersion=agnAlrBufCmprVersion, dhcpRelayMaxHop=dhcpRelayMaxHop, radBridgeIPXSapServerType=radBridgeIPXSapServerType, sysDbaseFlipEntry=sysDbaseFlipEntry, prtSpNoOfRetries=prtSpNoOfRetries, prtExTsIdx=prtExTsIdx, maskingDestCondition=maskingDestCondition, prtExLs6VOos=prtExLs6VOos, prtDs3CurrentUAS=prtDs3CurrentUAS, ethIfSrcMacCtrlLastViolatingAddr=ethIfSrcMacCtrlLastViolatingAddr, ethOamServiceIdx=ethOamServiceIdx, ethOamSvcTotalMaxRoundTripDVar=ethOamSvcTotalMaxRoundTripDVar, prtParamStatus=prtParamStatus, prtICnfgEntry=prtICnfgEntry, atmIfCurrentTxCells=atmIfCurrentTxCells, prtExLs2Dcd=prtExLs2Dcd, agnCnfgAlrSeverity=agnCnfgAlrSeverity, atmSysIntervalCdc=atmSysIntervalCdc, atmVcCurrentTotalDiscards=atmVcCurrentTotalDiscards, alrGenSlotType=alrGenSlotType, prtIsdnNumOfAbstractTerm=prtIsdnNumOfAbstractTerm, alrBufSeverity=alrBufSeverity, radBridgeCurrentTxDropFrames=radBridgeCurrentTxDropFrames, atmVcPMIntervalTxClp01=atmVcPMIntervalTxClp01, radMlAtmT1=radMlAtmT1, bundleConnectionStatusTrap=bundleConnectionStatusTrap, ethOamSvcIntervalFramesBelowDVarThresh=ethOamSvcIntervalFramesBelowDVarThresh, ethOamSvcTotalEntry=ethOamSvcTotalEntry, agnCBuMlEntry=agnCBuMlEntry, prtExHs4OosSig=prtExHs4OosSig, bdbandConfig=bdbandConfig, agnListDecodingAcmRelayPrt=agnListDecodingAcmRelayPrt, prtExPVc4DlciPrtIdx=prtExPVc4DlciPrtIdx, mdlCmprVersion=mdlCmprVersion, radVmux210=radVmux210, prtExPh1MlIfType=prtExPh1MlIfType, agnListDecodingEntry=agnListDecodingEntry, prtInLs2SltIdx=prtInLs2SltIdx, evcCosCnfgIdx=evcCosCnfgIdx, sysCAutoConfigEnable=sysCAutoConfigEnable, serviceIndex=serviceIndex, prtExLs2Cts=prtExLs2Cts, mdlSAlrTable=mdlSAlrTable, ds1AisSyncLossTrap=ds1AisSyncLossTrap, portVendorPartNo=portVendorPartNo, prtDs3IntervalSLM=prtDs3IntervalSLM, prtLs2Cnfg=prtLs2Cnfg, mdlCParam=mdlCParam, prtMl4Service=prtMl4Service, prtParamResetStatsCmd=prtParamResetStatsCmd, dhcpRelayServerIpAddress=dhcpRelayServerIpAddress, prtGenExtInt=prtGenExtInt, agnSCmprErrIdx=agnSCmprErrIdx, radBridgeStatus=radBridgeStatus, mapLinkSlotIdx=mapLinkSlotIdx, atmVpPMCurrentSES=atmVpPMCurrentSES, prtDs3TotalUAS=prtDs3TotalUAS, radMepLtrEntry=radMepLtrEntry, autoFileTransfer=autoFileTransfer, atmVcIntervalSES=atmVcIntervalSES, sysDclOnline=sysDclOnline, atmAlarmForwardingFailPort=atmAlarmForwardingFailPort, radBridgeIPXRipForwardingRouter=radBridgeIPXRipForwardingRouter, atmVcCurrentClp0Discards=atmVcCurrentClp0Discards, ip2IfCallerIdDelay=ip2IfCallerIdDelay, prtIsdnDirectoryCnfgIdx=prtIsdnDirectoryCnfgIdx, atmLoopbackVpVpi=atmLoopbackVpVpi, agnClkSrcPortState=agnClkSrcPortState, agnVoiceSwConfRtSlot=agnVoiceSwConfRtSlot, agnCFlipNetEventSlot=agnCFlipNetEventSlot, prtExPhPlDlciEntry=prtExPhPlDlciEntry, radAce3205=radAce3205, prtE2SltIdx=prtE2SltIdx, atmIfValidIntervals=atmIfValidIntervals, prtFrStatisEntry=prtFrStatisEntry, agnCQ50Table=agnCQ50Table, atmNteMdlConfigTable=atmNteMdlConfigTable, radOpXL16E1=radOpXL16E1, radBridgeCODCondEntry=radBridgeCODCondEntry, mdlCEntry=mdlCEntry, ethIfStormPacketType=ethIfStormPacketType, prtDlciCmprDlciIdx=prtDlciCmprDlciIdx)
mibBuilder.exportSymbols("RAD-MIB", agnSDateCmd=agnSDateCmd, mdlPbxFraTransSigTs=mdlPbxFraTransSigTs, ip2IfCustomToneDetect=ip2IfCustomToneDetect, atmNteManagerPvc=atmNteManagerPvc, prtSAlarmPrtIdx=prtSAlarmPrtIdx, qosFlowMappingToDestMacAddr=qosFlowMappingToDestMacAddr, dsx1DataStreamStatIfIndex=dsx1DataStreamStatIfIndex, mdlClSwchStatus=mdlClSwchStatus, prtParamUsage=prtParamUsage, ip2IfPeerAddrType=ip2IfPeerAddrType, prtIConnect=prtIConnect, mdlSAlrSeverity=mdlSAlrSeverity, ifPerfTable=ifPerfTable, pLinkSlotNu=pLinkSlotNu, radEPR4FL=radEPR4FL, prtIpParamP2pKeepAliveVlanPrio=prtIpParamP2pKeepAliveVlanPrio, prtFrStatisSltIdx=prtFrStatisSltIdx, queueGroupQBlockShaperProfile=queueGroupQBlockShaperProfile, systemParameter=systemParameter, sysSAlarmInvert=sysSAlarmInvert, atmAceAlarmPlcpLOF=atmAceAlarmPlcpLOF, prtDs3IfValidIntervals=prtDs3IfValidIntervals, prtTrafficClass=prtTrafficClass, dsx1CurrentCRCErrors=dsx1CurrentCRCErrors, ethOamSvcIntervalMaxRoundTripDVar=ethOamSvcIntervalMaxRoundTripDVar, sysAlrStatusTrap=sysAlrStatusTrap, wrDhcpIpMaskAddress=wrDhcpIpMaskAddress, dhcpServerAction=dhcpServerAction, mdlCNoOfInternPrt=mdlCNoOfInternPrt, sysBufferAlrState=sysBufferAlrState, radRRTRE1D=radRRTRE1D, modlParam=modlParam, agnCnfgAlrReportType=agnCnfgAlrReportType, radAce202=radAce202, prtDs3IntervalTable=prtDs3IntervalTable, radImx4E1=radImx4E1, radBridgeCurrentRxCorrectBytesHCOverflow=radBridgeCurrentRxCorrectBytesHCOverflow, prtIsdnDirectoryLocalAddr2=prtIsdnDirectoryLocalAddr2, maskingFrameTypeCondition=maskingFrameTypeCondition, atmVpPMQoSCER=atmVpPMQoSCER, ethIfSrcMacCtrlPortStatus=ethIfSrcMacCtrlPortStatus, prtIpParamMngVlanSupport=prtIpParamMngVlanSupport, wfqRowStatus=wfqRowStatus, radMepLtrIngressPortId=radMepLtrIngressPortId, prtGenTsCnfgIdx=prtGenTsCnfgIdx, ethIfOamCfmEvents=ethIfOamCfmEvents, prtE2CnfgIdx=prtE2CnfgIdx, atmLoopbackVcTable=atmLoopbackVcTable, radBridgePortCnfgPrtIdx=radBridgePortCnfgPrtIdx, schedParam=schedParam, portOptMode=portOptMode, optPrtCnfgALS=optPrtCnfgALS, radBridgeIPXSapAgingTime=radBridgeIPXSapAgingTime, prtExClRoutingProtocol=prtExClRoutingProtocol, prtInPh1MlCnfgEntry=prtInPh1MlCnfgEntry, atmNteHostIfEntry=atmNteHostIfEntry, wrDhcpPort=wrDhcpPort, radMepRemoteMepIdx=radMepRemoteMepIdx, radBridgeDot1qVlanStaticEntry=radBridgeDot1qVlanStaticEntry, prtDs3CurrentEntry=prtDs3CurrentEntry, radSysBRG=radSysBRG, radBridgeInvBasePortEntry=radBridgeInvBasePortEntry, atmThresholdLineBIP=atmThresholdLineBIP, radMepLtrIngress=radMepLtrIngress, mdlCConfigIdx=mdlCConfigIdx, prtT1E1CnfgEntry=prtT1E1CnfgEntry, radBridgePortCnfgMaxMacAddr=radBridgePortCnfgMaxMacAddr, radFEB4FDX=radFEB4FDX, atmVpIntervalContinuityLoss=atmVpIntervalContinuityLoss, atmVpPerformance=atmVpPerformance, radStarSwitchATM155=radStarSwitchATM155, cosProfileCosMapping=cosProfileCosMapping, agnSSanityCheckStatus=agnSSanityCheckStatus, prtExHsiCnfgTable=prtExHsiCnfgTable, prtMl4DataOos=prtMl4DataOos, dsx1ClockSource=dsx1ClockSource, cmprTable=cmprTable, agnSCnfgTable=agnSCnfgTable, ethIfSrcMacCtrlFlushAddrCmd=ethIfSrcMacCtrlFlushAddrCmd, atmConfVpOamDescrIndex=atmConfVpOamDescrIndex, atmNteConfOamIfEntry=atmNteConfOamIfEntry, prtInPh1MlCnfgIdx=prtInPh1MlCnfgIdx, prtSAlarmIdx=prtSAlarmIdx, prtT1E1RxGain=prtT1E1RxGain, sysCRdnTable=sysCRdnTable, prtIsdnBasicRateLineTopology=prtIsdnBasicRateLineTopology, fileTransferToSubSystems=fileTransferToSubSystems, hostParam2=hostParam2, prtGenCnfgPrtIdx=prtGenCnfgPrtIdx, ethIfIntervalMultipleCollisionFrames=ethIfIntervalMultipleCollisionFrames, wrDNSRelayAction=wrDNSRelayAction, prtDlciCmprEntry=prtDlciCmprEntry, prtSP=prtSP, ip2IfStatRxVoice=ip2IfStatRxVoice, agnClkSrcPortEntry=agnClkSrcPortEntry, ip2IfStatTxMeasuredSilence=ip2IfStatTxMeasuredSilence, evcCosEvcName=evcCosEvcName, lagStatTable=lagStatTable, ds1RemoteSyncLossTrap=ds1RemoteSyncLossTrap, radBridgeStpCnfgIdx2=radBridgeStpCnfgIdx2, atmVpQoSUAS=atmVpQoSUAS, dhcpPoolAllocFlags=dhcpPoolAllocFlags, queueGroupQBlockLevel=queueGroupQBlockLevel, ethIfIntervalOutputCongestionDropped=ethIfIntervalOutputCongestionDropped, wrFrSelfLearningMode=wrFrSelfLearningMode, radEP4TAUI=radEP4TAUI, prtExPhPlPrtIdx=prtExPhPlPrtIdx, prtInPh1MlTc=prtInPh1MlTc, prtInPh1MlCnfgTable=prtInPh1MlCnfgTable, atmAceAlarmVpContinuityLoss=atmAceAlarmVpContinuityLoss, agnCNetEventsBcastInterval=agnCNetEventsBcastInterval, radMepLtrEgressPortId=radMepLtrEgressPortId, atmNteHostPvcIndex=atmNteHostPvcIndex, ip2IfStatAvrRoundTripDelay=ip2IfStatAvrRoundTripDelay, prtExVc2OperMode=prtExVc2OperMode, agnCFlipCnfgIdx=agnCFlipCnfgIdx, prtDs3CurrentSES=prtDs3CurrentSES, wrDhcpPrimaryDNS=wrDhcpPrimaryDNS, wrAutoLearnLanIpxNets=wrAutoLearnLanIpxNets, prtHSInbandLoopback=prtHSInbandLoopback, xcAttachedIfType=xcAttachedIfType, xcAdminStatus=xcAdminStatus, agnSystemParameterChangeTrap=agnSystemParameterChangeTrap, ethIfIntervalEntry=ethIfIntervalEntry, prtBertESs=prtBertESs, prtHdslRptrType=prtHdslRptrType, radMepLbrIn=radMepLbrIn, radSysAtm=radSysAtm, maskingPortNumCondition=maskingPortNumCondition, systemPort=systemPort, prtAgendaBehaviourCnfgIdx=prtAgendaBehaviourCnfgIdx, prtCnfgAgendaFrom=prtCnfgAgendaFrom, prtCnfgAgendaSltIdx=prtCnfgAgendaSltIdx, ip2IfOAM=ip2IfOAM, prtGenTsIConTs=prtGenTsIConTs, sysSaBuActivePort=sysSaBuActivePort, atmNteIdIndex=atmNteIdIndex, agnCnfgAlrSlot=agnCnfgAlrSlot, agnAlarmsCmprTable=agnAlarmsCmprTable, qInternalProfileRowStatus=qInternalProfileRowStatus, wrSyncIfIndex=wrSyncIfIndex, prtDimCnfgTable=prtDimCnfgTable, agnt=agnt, radBridgeGenFlowFloodOrBcastMaxRate=radBridgeGenFlowFloodOrBcastMaxRate, prtExPhPlDlciRxBc=prtExPhPlDlciRxBc, radDot1qPortReplaceVlanPriority=radDot1qPortReplaceVlanPriority, ethIfIntervalOutMulticastFrames=ethIfIntervalOutMulticastFrames, radOptimux4T1Mar06=radOptimux4T1Mar06, mdlStatHostIP=mdlStatHostIP, atmVpPMCurrentES=atmVpPMCurrentES, radBridgeCODEntry=radBridgeCODEntry, sysCnfgEntry=sysCnfgEntry, prtTestOamMinRoundTripDelay=prtTestOamMinRoundTripDelay, ethIfIntervalOverflowInMulticastFrames=ethIfIntervalOverflowInMulticastFrames, atmVcPMCurrentIntervalQuality=atmVcPMCurrentIntervalQuality, ethIfRingTable=ethIfRingTable, agnSAlrMask=agnSAlrMask, ifPerfEntry=ifPerfEntry, prtCnfgAgendaCnfgIdx=prtCnfgAgendaCnfgIdx, sysCIsdnFormat=sysCIsdnFormat, radFastWay100=radFastWay100, atmLoopbackVpIvlErrSessions=atmLoopbackVpIvlErrSessions, serviceRowStatus=serviceRowStatus, prtExVc2Wire=prtExVc2Wire, ip2IfCallerIdDetection=ip2IfCallerIdDetection, prtQosTable=prtQosTable, atmVcIntervalTxRDI=atmVcIntervalTxRDI, ethIfRingAdminStatus=ethIfRingAdminStatus, sysCClkSsmBased=sysCClkSsmBased, ethIfStormMaxRate=ethIfStormMaxRate, atmVcIntervalPCR=atmVcIntervalPCR, radBridgeStpCnfgPriority=radBridgeStpCnfgPriority, prtParamClkUserQualityLevel=prtParamClkUserQualityLevel, agnVoiceSwConfHGEntry=agnVoiceSwConfHGEntry, ip2IfPortTable=ip2IfPortTable, serviceTable=serviceTable, ethIfCurrentOverflowOutDiscardFrames=ethIfCurrentOverflowOutDiscardFrames, atmSysConfigCellTestPti=atmSysConfigCellTestPti, radBridgeIntervalRxMcastFrames=radBridgeIntervalRxMcastFrames, systemVoiceDtmfRelayPayloadTypeNeg=systemVoiceDtmfRelayPayloadTypeNeg, wrConfigIpxRouterInfo=wrConfigIpxRouterInfo, prtT1E1StatEntry=prtT1E1StatEntry, ethIfRingKeepAliveVlanId=ethIfRingKeepAliveVlanId, atmNteCardStatus=atmNteCardStatus, agnCT1E1RingDualFailDetection=agnCT1E1RingDualFailDetection, ip2IfCurrentStatBufOverflows=ip2IfCurrentStatBufOverflows, radAce3100PSN=radAce3100PSN, atmVcShaperOccupation=atmVcShaperOccupation, sysDbaseFlipTime=sysDbaseFlipTime, maskingEntry=maskingEntry, radTinyRouter=radTinyRouter, prtSpStopBits=prtSpStopBits, portMfgName=portMfgName, atmAceAlarmSLM=atmAceAlarmSLM, agnFans=agnFans, prtExVc2RemType=prtExVc2RemType, mdlCDhcpClientEnable=mdlCDhcpClientEnable, atmIfCurrentEntry=atmIfCurrentEntry, radBridgePortVlanMemberEntry=radBridgePortVlanMemberEntry, radBridgeIntervalRxCorrectBytesHCOverflow=radBridgeIntervalRxCorrectBytesHCOverflow, prtExHsrStopBits=prtExHsrStopBits, atmNteHostRowStatus=atmNteHostRowStatus, radOptimux4E1V3dot5=radOptimux4E1V3dot5, ethIfCurrentOutOctets=ethIfCurrentOutOctets, atmVcPMIntervalRxClp0=atmVcPMIntervalRxClp0, radBridgePortVlanMemberPortIdx=radBridgePortVlanMemberPortIdx, radRici8E1L=radRici8E1L, atmIfIntervalUncorrectedHecs=atmIfIntervalUncorrectedHecs, dsx3MappingDs3Index=dsx3MappingDs3Index, lagRdnMethod=lagRdnMethod, ethIfCurrentOverflowInUnicastFrames=ethIfCurrentOverflowInUnicastFrames, radAce2002=radAce2002, prtIP=prtIP, prtInTreConnect=prtInTreConnect, atmNteReservedVpi=atmNteReservedVpi, prtPhMlDialProcess=prtPhMlDialProcess, atmVcCurrentTaggedOuts=atmVcCurrentTaggedOuts, qosFlowMappingEntry=qosFlowMappingEntry, systemOamCnfgIdx=systemOamCnfgIdx, prtSExHsfPrtIdx=prtSExHsfPrtIdx, mdlSInstCardType=mdlSInstCardType, rowInfoCounter=rowInfoCounter, ethOamServiceFramesAboveDelay=ethOamServiceFramesAboveDelay, ethIfMacAccessViolation=ethIfMacAccessViolation, radGmux2004=radGmux2004, prtLanWanVlanType=prtLanWanVlanType, sysSAlarmMask=sysSAlarmMask, prtClkSrcTable=prtClkSrcTable, agnDlciCmprDlciIdx=agnDlciCmprDlciIdx, radBridgeIPXSapNIC=radBridgeIPXSapNIC, prtIsdnDirectoryLocalAddr=prtIsdnDirectoryLocalAddr, mdlSClearAllAlrCmd=mdlSClearAllAlrCmd, prtExPhPlProtocol=prtExPhPlProtocol, radBridgeMaskEntry=radBridgeMaskEntry, prtTestActivationDelay=prtTestActivationDelay, radSysWanEvents=radSysWanEvents, dsx1CurrentLOS=dsx1CurrentLOS, dsx1IntervalLOFC=dsx1IntervalLOFC, bitMappingEntry=bitMappingEntry, radAce50=radAce50, ethPerformanceMode=ethPerformanceMode, ip2IfJitterBuffer=ip2IfJitterBuffer, atmNteHostDefaultVlanPriority=atmNteHostDefaultVlanPriority, prtT1E1Sync=prtT1E1Sync, alrGenDebounce=alrGenDebounce, radPRBm22=radPRBm22, radAce3402=radAce3402, agnCDefaultCnfgIdxCmd=agnCDefaultCnfgIdxCmd, alrBufState=alrBufState, mdlAlarmOnOff=mdlAlarmOnOff, wrSyncCnfgTable=wrSyncCnfgTable, prtExPVc4ChannelId=prtExPVc4ChannelId, prtExVcPbxGroup=prtExVcPbxGroup, ethIfCurrentInputCongestionDropped=ethIfCurrentInputCongestionDropped)
mibBuilder.exportSymbols("RAD-MIB", radETS4=radETS4, agnNoOfCurrentConns=agnNoOfCurrentConns, agnCBuMlOamFrequency=agnCBuMlOamFrequency, atmVpPmAdminStatus=atmVpPmAdminStatus, prtExClPrtIdx=prtExClPrtIdx, prtIsdnStatusEntry=prtIsdnStatusEntry, prtBdbandIdx=prtBdbandIdx, prtExVcPbxLineCode=prtExVcPbxLineCode, prtExTreSltIdx=prtExTreSltIdx, prtExPhPlDlciTable=prtExPhPlDlciTable, ip2IfVlanFramePriority=ip2IfVlanFramePriority, radUNT20E1=radUNT20E1, optPrtCnfgTable=optPrtCnfgTable, agnCnfgAlrFilter=agnCnfgAlrFilter, xcDescr=xcDescr, ip2IfPulseMeter=ip2IfPulseMeter, wrDhcpTftpServerIp=wrDhcpTftpServerIp, radFdsl201=radFdsl201, agnTsCmprCnfgIdx=agnTsCmprCnfgIdx, agnCnfgIdx=agnCnfgIdx, atmIntervalDateTime=atmIntervalDateTime, atmVpShaperStatTable=atmVpShaperStatTable, radBridgeStpCnfgTable=radBridgeStpCnfgTable, radWan=radWan, atmNteUSESLTCR=atmNteUSESLTCR, radFcdT1M=radFcdT1M, prtInVc3CnfgEntry=prtInVc3CnfgEntry, prtExHs4MfClkSrcPrt=prtExHs4MfClkSrcPrt, radBridgePortCnfgStatVlanId=radBridgePortCnfgStatVlanId, cnfgPrtMux=cnfgPrtMux, prtIpParamDoubleTagVlanId=prtIpParamDoubleTagVlanId, atmConfAtmIfVpiVciLimit=atmConfAtmIfVpiVciLimit, radBridgeCODTrafficTable=radBridgeCODTrafficTable, agnConfigDBChecksumError=agnConfigDBChecksumError, radBridgeIPXRipInfTable=radBridgeIPXRipInfTable, sysSa=sysSa, ip2IfVadMethod=ip2IfVadMethod, atmVpPMIntervalTxClp0=atmVpPMIntervalTxClp0, sysSClkSrc=sysSClkSrc, sysDbaseFlipIdx=sysDbaseFlipIdx, alrGenSeverity=alrGenSeverity, radBridgeCurrentRxMcastFrames=radBridgeCurrentRxMcastFrames, prtInHsiCnfgEntry=prtInHsiCnfgEntry, prtSpActCallOut=prtSpActCallOut, prtInPh1MlCongResponse=prtInPh1MlCongResponse, prtTestMacSwapLoopDataMode=prtTestMacSwapLoopDataMode, atmVpCurrentCDC=atmVpCurrentCDC, prtExHsiPrtIdx=prtExHsiPrtIdx, radBridgePortBaseVlanRowStatus=radBridgePortBaseVlanRowStatus, prtExPVc4DlciValid=prtExPVc4DlciValid, atmNteTotalCc=atmNteTotalCc, prtSpRate=prtSpRate, srvForwardYellowBytesOverflow=srvForwardYellowBytesOverflow, radAPS8=radAPS8, prtExLs6VTxGain=prtExLs6VTxGain, radHtu2Sa=radHtu2Sa, prtExHs4TsEntry=prtExHs4TsEntry, sysSBusStatus=sysSBusStatus, ip2IfTos=ip2IfTos, prtHsfCnfgIdx=prtHsfCnfgIdx, agnCOffsetCmd=agnCOffsetCmd, prtExHs4CnfgTable=prtExHs4CnfgTable, atmVcPmSink=atmVcPmSink, prtSpParity=prtSpParity, prtInLs2Connect=prtInLs2Connect, dsx1DataStreamStatOutDiscards=dsx1DataStreamStatOutDiscards, atmNteConfIfEntry=atmNteConfIfEntry, prtPerformance=prtPerformance, chassTotalNoOfClSlt=chassTotalNoOfClSlt, atmNteMaxBurstSize=atmNteMaxBurstSize, mdlSRebuildFrame=mdlSRebuildFrame, radIpMux24=radIpMux24, radBridgeCODProtocolType=radBridgeCODProtocolType, mdlSAlrIdx=mdlSAlrIdx, ip2IfCurrentStatEntry=ip2IfCurrentStatEntry, alarmForwardingRowStatus=alarmForwardingRowStatus, radBridgeInactiveArpTimeOut=radBridgeInactiveArpTimeOut, wrIpMask=wrIpMask, ethIfIntervalLengthError=ethIfIntervalLengthError, dsx1RxSensitivity=dsx1RxSensitivity, radMdEntry=radMdEntry, prtExPhPlPvcCreateMsg=prtExPhPlPvcCreateMsg, agnStringToIndexTableIndex=agnStringToIndexTableIndex, atmNteIdEntry=atmNteIdEntry, atmAceAlarmVpRDIReception=atmAceAlarmVpRDIReception, agnSEditCnfg=agnSEditCnfg, radEP4TFL=radEP4TFL, ip2IfRxGain=ip2IfRxGain, radFRmon=radFRmon, cnfgAgnGen=cnfgAgnGen, prtSTestMask=prtSTestMask, cnfgPrtGen=cnfgPrtGen, ip2IfCurrentStatTxErrFrameSec=ip2IfCurrentStatTxErrFrameSec, prtParamActUponLoopDetect=prtParamActUponLoopDetect, radAce=radAce, prtExVc2EchoCanceler=prtExVc2EchoCanceler, prtBertInjectSingleErrCmd=prtBertInjectSingleErrCmd, ethIfCurrentLengthError=ethIfCurrentLengthError, prtExPVc4DlciCnfgIdx=prtExPVc4DlciCnfgIdx, atmNteManagerVlanFramePriority=atmNteManagerVlanFramePriority, agnCnfgAlrStartReportOff=agnCnfgAlrStartReportOff, prtExVc2ReversePolarity=prtExVc2ReversePolarity, atmConfVpCCAdminStatus=atmConfVpCCAdminStatus, sysCRdnHwSwFlip=sysCRdnHwSwFlip, sysDclFlipDelay=sysDclFlipDelay, prtPhMlPrtIdx=prtPhMlPrtIdx, wrSysConfig=wrSysConfig, ethIfCurrentOutBroadcastFrames=ethIfCurrentOutBroadcastFrames, ethIfCurrentCarrierSenseErrors=ethIfCurrentCarrierSenseErrors, radMepRowStatus=radMepRowStatus, agnDlciTxBc=agnDlciTxBc, ip2IfTdmBackUpNextHop=ip2IfTdmBackUpNextHop, sysDclCopyDbTable=sysDclCopyDbTable, prtIsdnEndpointSpid=prtIsdnEndpointSpid, opticalPort=opticalPort, maskingPortNum=maskingPortNum, agnSLastCnfgFlipTime=agnSLastCnfgFlipTime, prtInVc3CnfgTable=prtInVc3CnfgTable, prtExPhPlIdleCode=prtExPhPlIdleCode, prtExPh1MlRedundRecTime=prtExPh1MlRedundRecTime, atmAceHwFailure=atmAceHwFailure, agnSigProfileIdx=agnSigProfileIdx, radLA240=radLA240, atmConfVpConnected=atmConfVpConnected, prtTestOamTxInterval=prtTestOamTxInterval, ip2IfPulseMeterPeriod=ip2IfPulseMeterPeriod, lagRowStatus=lagRowStatus, rowInfoTable=rowInfoTable, atmAceAlarmPathBIP=atmAceAlarmPathBIP, ethIfIntervalTable=ethIfIntervalTable, dsx1CurrentLOCRCMF=dsx1CurrentLOCRCMF, prtSAlrIdx=prtSAlrIdx, ip2IfIntervalStatTxErrFrameSec=ip2IfIntervalStatTxErrFrameSec, radBridgeIntervalIndex=radBridgeIntervalIndex, atmAceAlarmVcAISReception=atmAceAlarmVcAISReception, prtMonitoredPort=prtMonitoredPort, ip2IfNlpCutoffLevel=ip2IfNlpCutoffLevel, radBridgeMaskFrom1=radBridgeMaskFrom1, dsx1CurrentStatus=dsx1CurrentStatus, atmVpIntervalTotalDiscards=atmVpIntervalTotalDiscards, atmIfTimeElapsed=atmIfTimeElapsed, ethOamCfmDefectCondition=ethOamCfmDefectCondition, prtExPVc4MinPulseWidth=prtExPVc4MinPulseWidth, prtSpRoutProtocol=prtSpRoutProtocol, schedYear=schedYear, alrBufferClearCmd=alrBufferClearCmd, sysDbase=sysDbase, prtDlciStatis=prtDlciStatis, radMepMdId=radMepMdId, radMepTransmitLtmTargetIsMepId=radMepTransmitLtmTargetIsMepId, atmVcPMCurrentTxClp01=atmVcPMCurrentTxClp01, ethIfIntervalOverflowOutBroadcastFrames=ethIfIntervalOverflowOutBroadcastFrames, mdlAlrState=mdlAlrState, radRRMLBT=radRRMLBT, agnStoreCmd=agnStoreCmd, wrLanIpxFrameType=wrLanIpxFrameType, atmVcCurrentGcra0Violations=atmVcCurrentGcra0Violations, chassTotalNoOfIoSlt=chassTotalNoOfIoSlt, prtExPVc4WinkMaxDuration=prtExPVc4WinkMaxDuration, prtT1E1LineMode=prtT1E1LineMode, queueGroupPointToInternalQueue=queueGroupPointToInternalQueue, portOptWaveLength=portOptWaveLength, ethOamSvcIntervalUnavailSec=ethOamSvcIntervalUnavailSec, mdlCRdnExists=mdlCRdnExists, prtTestVctTxDistance=prtTestVctTxDistance, prtDs3IntervalRDI=prtDs3IntervalRDI, agnClkIntervalBufferUnderflow=agnClkIntervalBufferUnderflow, prtExVcPbxCnfgTable=prtExVcPbxCnfgTable, atmLoopbackVcIvlVpi=atmLoopbackVcIvlVpi, prtT1E1Ts0SaBit=prtT1E1Ts0SaBit, ethOamSvcCurrFramesTxCounter=ethOamSvcCurrFramesTxCounter, radMepCcStatusMacAddr=radMepCcStatusMacAddr, prtExLs6VCnfgTable=prtExLs6VCnfgTable, agnTsCmprTable=agnTsCmprTable, prtStatusChangeTrap=prtStatusChangeTrap, alrBufIdx=alrBufIdx, invNameXCEntry=invNameXCEntry, ip2IfChannelIndex=ip2IfChannelIndex, radRBHT=radRBHT, systemVoiceEntry=systemVoiceEntry, evcCosTable=evcCosTable, prtInVc3PrtIdx=prtInVc3PrtIdx, atmLoopbackVcIvlErrSessions=atmLoopbackVcIvlErrSessions, rtrBridge=rtrBridge, radSAHEMX=radSAHEMX, dhcpPoolAllocLowIpAddress=dhcpPoolAllocLowIpAddress, mdlSAlrClearCmd=mdlSAlrClearCmd, atmAceAlarmVpAISReception=atmAceAlarmVpAISReception, mdlProtIpSlotIdx=mdlProtIpSlotIdx, agnCClkSrcIdx=agnCClkSrcIdx, agnCClkSrcPrt=agnCClkSrcPrt, ifCreateConnectedTo=ifCreateConnectedTo, atmSysConfigCellTestPort=atmSysConfigCellTestPort, radMepTransmitLtmTargetMacAddress=radMepTransmitLtmTargetMacAddress, invNameXCIndex=invNameXCIndex, prtAcmCnfgEntry=prtAcmCnfgEntry, maskingDestAddress=maskingDestAddress, mdlStatDefaultGateway=mdlStatDefaultGateway, agnCNetDelay=agnCNetDelay, atmSysPSunitsInUse=atmSysPSunitsInUse, ethIfEntry=ethIfEntry, sysCClkStationOutState=sysCClkStationOutState, ethOamSvcTotalAvgRoundTripDelay=ethOamSvcTotalAvgRoundTripDelay, radBridgeStpStatMaxAge=radBridgeStpStatMaxAge, prtDlciCmprObj=prtDlciCmprObj, evcCosSpVlanId=evcCosSpVlanId, prtExClCnfgEntry=prtExClCnfgEntry, wrFrCnfgTable=wrFrCnfgTable, atmVcShaperMaxOccupation=atmVcShaperMaxOccupation, agnTrapDelay=agnTrapDelay, dot1agXCfmMepDbTable=dot1agXCfmMepDbTable, ethIfRingIdx=ethIfRingIdx, prtExHsfFifoSize=prtExHsfFifoSize, ethOamServiceRowStatus=ethOamServiceRowStatus, radFEB4DAS=radFEB4DAS, prtGenCnfgPortId=prtGenCnfgPortId, prtExVcPbxTsTable=prtExVcPbxTsTable, ip2IfDestPort=ip2IfDestPort, agnCmprTypIdx=agnCmprTypIdx, prtDs3TotalEntry=prtDs3TotalEntry, prtIpParamIdx=prtIpParamIdx, mdlSAlrSltIdx=mdlSAlrSltIdx, sysCClkSrcEntry=sysCClkSrcEntry, prtPhMlConnect=prtPhMlConnect, linkSelectorCnfgEntry=linkSelectorCnfgEntry, prtTestTTL=prtTestTTL, radMepCcStatusEntry=radMepCcStatusEntry, atmNteHostVlanTagging=atmNteHostVlanTagging, atmVcIntervalRxRDI=atmVcIntervalRxRDI, prtMl4SignalingMode=prtMl4SignalingMode, prtT1FdlMsgEntry=prtT1FdlMsgEntry, prtIpParamP2pKeepAliveVlanId=prtIpParamP2pKeepAliveVlanId, hostVlanId=hostVlanId, agnSigProfIdx=agnSigProfIdx, prtGenTestMask=prtGenTestMask, radFdsl101=radFdsl101, portTrafficClassEntry=portTrafficClassEntry, prtSInstIfIndex=prtSInstIfIndex, radBridgeCODTimeTriggerTable=radBridgeCODTimeTriggerTable, prtAgendaBehaviourTable=prtAgendaBehaviourTable, prtVc2CnfgIdx=prtVc2CnfgIdx, prtT1E1InbandMngRate=prtT1E1InbandMngRate, agnCurrClkSrc=agnCurrClkSrc, ip2IfModemProtocolMode=ip2IfModemProtocolMode, prtExVcPbxFrame=prtExVcPbxFrame, radIpMux12=radIpMux12, prtIpParamSlotIdx=prtIpParamSlotIdx, prtExVc2SigProfile=prtExVc2SigProfile, atmVcPMQoSDirection=atmVcPMQoSDirection, prtExLs2ClkMode=prtExLs2ClkMode, atmVcCurrentShaperClp0Discards=atmVcCurrentShaperClp0Discards, atmIfIntervalTxCells=atmIfIntervalTxCells, dhcpClientEntry=dhcpClientEntry, prtHSBertPrtIdx=prtHSBertPrtIdx)
mibBuilder.exportSymbols("RAD-MIB", radFTC1=radFTC1, prtT1E1PrtIdx=prtT1E1PrtIdx, prtIsdnDirectoryPrtNu=prtIsdnDirectoryPrtNu, prtIsdnCnfg=prtIsdnCnfg, prtQosRateLimitPacketType=prtQosRateLimitPacketType, cosProfileName=cosProfileName, radMP2100F=radMP2100F, radRTED=radRTED, prtParamInterfaceType=prtParamInterfaceType, prtClkSrcPrt=prtClkSrcPrt, prtInPh1MlErrorsThreshold=prtInPh1MlErrorsThreshold, agnActualLowRate=agnActualLowRate, prtExPhPlCnfgIdx=prtExPhPlCnfgIdx, ip2IfDtmfDetection=ip2IfDtmfDetection, sysSRdnFlipCause=sysSRdnFlipCause, sysDclRedundancy=sysDclRedundancy, portTrafficClass=portTrafficClass, radMepOamProtocol=radMepOamProtocol, radBridgeCurrentTxMcastFrames=radBridgeCurrentTxMcastFrames, trapID=trapID, prtExPhPlEnqPeriod=prtExPhPlEnqPeriod, agnCClkSrcEntry=agnCClkSrcEntry, radBridgeStpStatRootCost=radBridgeStpStatRootCost, atmLoopbackVpOperStatus=atmLoopbackVpOperStatus, prtHSCnfgIdx=prtHSCnfgIdx, radBridgeCODOriginateConnectCondition=radBridgeCODOriginateConnectCondition, systemVoiceCoderAndRate=systemVoiceCoderAndRate, radEGate20=radEGate20, mdlSSwVersion=mdlSSwVersion, maskingLowLevelProt=maskingLowLevelProt, prtT1E1TS0SaBits=prtT1E1TS0SaBits, prtBertSyncLoss=prtBertSyncLoss, ip2IfOosTxEnable=ip2IfOosTxEnable, prtDs3IntervalPlcpLOF=prtDs3IntervalPlcpLOF, atmNteConfOamTransmission=atmNteConfOamTransmission, qosFlowMappingInnerIeee802dot1p=qosFlowMappingInnerIeee802dot1p, sysBufferAlrIdx=sysBufferAlrIdx, dot1agXCfmMepCcStat=dot1agXCfmMepCcStat, agnCFlipActive=agnCFlipActive, prtExLs2Connect=prtExLs2Connect, sysCClkStationIf=sysCClkStationIf, atmGenSysLogMessage=atmGenSysLogMessage, prtBertTs=prtBertTs, qInternalProfileQueueLength=qInternalProfileQueueLength, prtCmprVersion=prtCmprVersion, radBridgeEthType=radBridgeEthType, prtExPhPlCongResponse=prtExPhPlCongResponse, prtCnfgAgendaTable=prtCnfgAgendaTable, atmSysStats=atmSysStats, sysDclRedundancyStatus=sysDclRedundancyStatus, ethIfIntervalInBroadcastFrames=ethIfIntervalInBroadcastFrames, prtT1E1=prtT1E1, prtExVc2SeizeAck=prtExVc2SeizeAck, hostIndex=hostIndex, alrGenDescription=alrGenDescription, newMasking=newMasking, prtFrTxTotalFrames=prtFrTxTotalFrames, radMepCcStatusRemMepId=radMepCcStatusRemMepId, prtExPVc4CnfgEntry=prtExPVc4CnfgEntry, autoFileTransferTable=autoFileTransferTable, atmNteManagerTable=atmNteManagerTable, radStarSwitchATM25=radStarSwitchATM25, radBridgeCODSpecificOnTrafficOIDCondition=radBridgeCODSpecificOnTrafficOIDCondition, ethIfIntervalIndex=ethIfIntervalIndex, atmVpPmIfIndex=atmVpPmIfIndex, mdlAlarmsCmprAlarmSlot=mdlAlarmsCmprAlarmSlot, ethIfCurrentOutputCongestionDropped=ethIfCurrentOutputCongestionDropped, prtInPh1MlRate=prtInPh1MlRate, atmVpPMCurrentVpi=atmVpPMCurrentVpi, prtExPVc4MultiFreqRelay=prtExPVc4MultiFreqRelay, sysCIntTsAllocMode=sysCIntTsAllocMode, radSysTerminal=radSysTerminal, radSPS3ScSL=radSPS3ScSL, prtExVc3CnfgIdx=prtExVc3CnfgIdx, radFcd155=radFcd155, mdlPsEntry=mdlPsEntry, radIMXI4=radIMXI4, agnIngressRateRange=agnIngressRateRange, radETX550=radETX550, radBridgeIPXRipTableEntry=radBridgeIPXRipTableEntry, radBridgeCurrentTxCorrectFrames=radBridgeCurrentTxCorrectFrames, prtFrStatis=prtFrStatis, prtExPh1MlCnfgEntry=prtExPh1MlCnfgEntry, alarmForwardingRecoveryTime=alarmForwardingRecoveryTime, atmVcPMCurrentVpi=atmVcPMCurrentVpi, radFcd155ES=radFcd155ES, ifCreateParams=ifCreateParams, ethIfIntervalOverflowFCSErrors=ethIfIntervalOverflowFCSErrors, radBridgeCODNumAccess=radBridgeCODNumAccess, prtSExHsfStatTable=prtSExHsfStatTable, prtGenTsEntry=prtGenTsEntry, prtDs3CurrentPlcpLOF=prtDs3CurrentPlcpLOF, radBridgeIntervalTxDropFrames=radBridgeIntervalTxDropFrames, dhcpRelayEntry=dhcpRelayEntry, agnClkIntervalLostPackets=agnClkIntervalLostPackets, prtExHsfConnect=prtExHsfConnect, prtAlarmsCmprObj=prtAlarmsCmprObj, prtExPhPlErrorsThreshold=prtExPhPlErrorsThreshold, serviceStatDirection=serviceStatDirection, radSysWan=radSysWan, sysSRelayState=sysSRelayState, agnGroupRowStatus=agnGroupRowStatus, prtExHsrCnfgTable=prtExHsrCnfgTable, atmAceAlarmVpLoopback=atmAceAlarmVpLoopback, ethIfIntervalOverflowOutMulticastFrames=ethIfIntervalOverflowOutMulticastFrames, dsx1IdleCode=dsx1IdleCode, atmVpPMIntervalES=atmVpPMIntervalES, ethOamSvcCurrFramesAboveDelayThresh=ethOamSvcCurrFramesAboveDelayThresh, prtIn1p6VcPbxConnect=prtIn1p6VcPbxConnect, radBridgeCurrentRxCorrectFrames=radBridgeCurrentRxCorrectFrames, rad=rad, mdlPsIdx=mdlPsIdx, prtInMbePrtIdx=prtInMbePrtIdx, prtExPVc4DynamicJitter=prtExPVc4DynamicJitter, ip2IfTosValue=ip2IfTosValue, prtSpCallOutMode=prtSpCallOutMode, ethSkipInitReset=ethSkipInitReset, prtAlarmsCmprAlarmPort=prtAlarmsCmprAlarmPort, atmThresholdPathBIP=atmThresholdPathBIP, prtQosPrtIdx=prtQosPrtIdx, radIpMux14=radIpMux14, prtCmprTable=prtCmprTable, radFTBDAS=radFTBDAS, atmNteLoopbackTimeout=atmNteLoopbackTimeout, ethOamSvcIntervalNum=ethOamSvcIntervalNum, agnFunctionActivation=agnFunctionActivation, ethIfCurrentInOctets=ethIfCurrentInOctets, prtExVc3CnfgTable=prtExVc3CnfgTable, prtDs3IntervalBitParity=prtDs3IntervalBitParity, prtExMbeLan=prtExMbeLan, atmLoopbackVpIvlMinDelay=atmLoopbackVpIvlMinDelay, prtDlciTxDcrdCongAllFr=prtDlciTxDcrdCongAllFr, prtDs3CurrentTable=prtDs3CurrentTable, prtIIdx=prtIIdx, atmAlarmForwardingFailureLevel=atmAlarmForwardingFailureLevel, ethIfCurrentInMulticastFrames=ethIfCurrentInMulticastFrames, atmVcPmAdminStatus=atmVcPmAdminStatus, prtAgendaBehaviourPrtIdx=prtAgendaBehaviourPrtIdx, radBridgeInvBasePort=radBridgeInvBasePort, prtExPh1MlTsSubChMask=prtExPh1MlTsSubChMask, prtInPh1MlFrameSeparator=prtInPh1MlFrameSeparator, prtParamIdx=prtParamIdx, radBridgePortCnfgTable=radBridgePortCnfgTable, prtLanWanStpPriority=prtLanWanStpPriority, atmNteConfOamSupport=atmNteConfOamSupport, dhcpIfClientRowStatus=dhcpIfClientRowStatus, sysCClkSrcMode=sysCClkSrcMode, sysBufferAlrClearCmd=sysBufferAlrClearCmd, mdlSCmd=mdlSCmd, agnVoiceSwConfIdx=agnVoiceSwConfIdx, prtHSClkPolarity=prtHSClkPolarity, portDdmSupport=portDdmSupport, prtMl4VoiceOos=prtMl4VoiceOos, atmVcPMCurrentECB=atmVcPMCurrentECB, sysDbaseFlipActivation=sysDbaseFlipActivation, agnTsCmprData=agnTsCmprData, prtAlrMask=prtAlrMask, prtIn7p8VcPbxCnfgIdx=prtIn7p8VcPbxCnfgIdx, pLinkPrioNu=pLinkPrioNu, prtFrTxBcViol=prtFrTxBcViol, prtExClSltIdx=prtExClSltIdx, prtInPh1MlDlciRxBc=prtInPh1MlDlciRxBc, chassTotalNoOfPsSlt=chassTotalNoOfPsSlt, atmVcPMCurrentSECB=atmVcPMCurrentSECB, radSuperLan=radSuperLan, prtGenCnfgTable=prtGenCnfgTable, atmGenSysSelfTestModule=atmGenSysSelfTestModule, radOp4T1LNew=radOp4T1LNew, atmVpPMIntervalQuality=atmVpPMIntervalQuality, atmNteOamEnable=atmNteOamEnable, ethIfRingRowStatus=ethIfRingRowStatus, radBridgeMaskActiveBit1=radBridgeMaskActiveBit1, prtSTestMaskXp=prtSTestMaskXp, markingProfileEntry=markingProfileEntry, intSwdlFlashIdx=intSwdlFlashIdx, prtExHsrRlbEnable=prtExHsrRlbEnable, prtHSParamEntry=prtHSParamEntry, agnClkCurrentTable=agnClkCurrentTable, prtPhMlCnfgTable=prtPhMlCnfgTable, prtLogicalFunction=prtLogicalFunction, hostVlanPriority=hostVlanPriority, prtExVcPbxSltIdx=prtExVcPbxSltIdx, prtSExHsfInterfaceTyp=prtSExHsfInterfaceTyp, ethRoutingProtocol=ethRoutingProtocol, radRiciT1=radRiciT1, ethIfRingKeepAliveInterval=ethIfRingKeepAliveInterval, radFcdIP=radFcdIP, mdlSClearAlrCmd=mdlSClearAlrCmd, radEthAccess=radEthAccess, wfqCnfgIdx=wfqCnfgIdx, radBridgeGenFlowBroadcastTrafficClass=radBridgeGenFlowBroadcastTrafficClass, prtMl4SltIdx=prtMl4SltIdx, atmNteOutputRate=atmNteOutputRate, mdlAlrIdx=mdlAlrIdx, mdlSAlrMaskAll=mdlSAlrMaskAll, radVmux425=radVmux425, systemPsIndex2=systemPsIndex2, prtSupervisoryStopBits=prtSupervisoryStopBits, atmAceAlarmLCD=atmAceAlarmLCD, radSEC2UDP=radSEC2UDP, atmVcCurrentEntry=atmVcCurrentEntry, atmVpIntervalPCR=atmVpIntervalPCR, atmAlarmForwardingEntry=atmAlarmForwardingEntry, radSPS3Sc2S=radSPS3Sc2S, prtInMbeSltIdx=prtInMbeSltIdx, atmNteAlarmType=atmNteAlarmType, systemInterface=systemInterface, prtIsdnStatusCallingNumber=prtIsdnStatusCallingNumber, prtExLs6VRxGain=prtExLs6VRxGain, wrIpRowStatus=wrIpRowStatus, ethIfIntervalOverflowInFrames=ethIfIntervalOverflowInFrames, ip2IfBundleSensitivity=ip2IfBundleSensitivity, modlParamTable=modlParamTable, prtInHsiSltIdx=prtInHsiSltIdx, agnVoiceSwConfRtEntry=agnVoiceSwConfRtEntry, prtT1E1FdlMsg=prtT1E1FdlMsg, prtCnfgAgendaDayIdx=prtCnfgAgendaDayIdx, ethIfCurrentInBroadcastFrames=ethIfCurrentInBroadcastFrames, ethIfSrcMacCtrlAddrIdx3=ethIfSrcMacCtrlAddrIdx3, prtSupervisoryParity=prtSupervisoryParity, prtExHs4IdleCode=prtExHs4IdleCode, ip2IfModemCalls=ip2IfModemCalls, radMepLbrInOutOfOrder=radMepLbrInOutOfOrder, radAtm=radAtm, radFcdT1LC=radFcdT1LC, prtExHsrConnect=prtExHsrConnect, prtExPhPlModemEntry=prtExPhPlModemEntry, prtSMaskedAlrStat=prtSMaskedAlrStat, prtPVc4Cnfg=prtPVc4Cnfg, radLrs16=radLrs16, prtExVc2ObMode=prtExVc2ObMode, dsx1dBTxGain=dsx1dBTxGain, prtExVcPbxTsRemConnID=prtExVcPbxTsRemConnID, radBridgeGenFlowCnfgIdx=radBridgeGenFlowCnfgIdx, prtFrPlusPrtIdx=prtFrPlusPrtIdx, atmConfIfAllocatedBw=atmConfIfAllocatedBw, prtHSInbandLoopDeactPattern=prtHSInbandLoopDeactPattern, atmGenSystem=atmGenSystem, prtPerfUAS=prtPerfUAS, wrDhcpRowStatus=wrDhcpRowStatus, atmTrafficDescrParamXTable=atmTrafficDescrParamXTable, ethSpeed=ethSpeed, ethOamServiceUnavailRatioThresh=ethOamServiceUnavailRatioThresh, dsx1CurrentLOMF=dsx1CurrentLOMF, ip2IfStatRxSignaling=ip2IfStatRxSignaling, ethIfIntervalLateCollisions=ethIfIntervalLateCollisions, ethIfSrcMacCtrlTable=ethIfSrcMacCtrlTable, prtPerfSES=prtPerfSES, maskingSrcPortNumCondition=maskingSrcPortNumCondition, prtExVc2TxBitCode=prtExVc2TxBitCode, radMiniCVS=radMiniCVS, atmVpPMIntervalTable=atmVpPMIntervalTable, atmVcPMCurrentES=atmVcPMCurrentES, radVmux110=radVmux110)
mibBuilder.exportSymbols("RAD-MIB", agnIndication=agnIndication, alrBufSlot=alrBufSlot, atmVpIntervalClp0CellOuts=atmVpIntervalClp0CellOuts, prtSActiveStatus=prtSActiveStatus, prtExPhPlDataBits=prtExPhPlDataBits, prtGenIfIndex=prtGenIfIndex, sysSRdnFlipPort=sysSRdnFlipPort, prtPerfIdx=prtPerfIdx, ip2IfIntervalStatBufUnderflows=ip2IfIntervalStatBufUnderflows, pLinkCnfgIdx=pLinkCnfgIdx, prtBertResult=prtBertResult, prtPriorityIdx1=prtPriorityIdx1, prtPhMlErrCorrection=prtPhMlErrCorrection, ifCreateConnectionPointer=ifCreateConnectionPointer, atmPerfHistory=atmPerfHistory, prtExLs6Protocol=prtExLs6Protocol, atmVcPMIntervalNumber=atmVcPMIntervalNumber, prtIpParamConfigIdx=prtIpParamConfigIdx, autoFileTransferEntry=autoFileTransferEntry, agnVoiceSwConfRtMaxCalls=agnVoiceSwConfRtMaxCalls, atmLoopbackVpIvlIvl=atmLoopbackVpIvlIvl, systemPsEntry=systemPsEntry, atmAceAlarmPathAIS=atmAceAlarmPathAIS, sysSErrDescription=sysSErrDescription, prtDestConnect=prtDestConnect, atmNteEventType=atmNteEventType, prtInLs6CnfgEntry=prtInLs6CnfgEntry, prtParamPhantom=prtParamPhantom, ds1BpvErrorTrap=ds1BpvErrorTrap, mngTrapIpTable=mngTrapIpTable, mdlSReset=mdlSReset, prtLogicalPrtIdx=prtLogicalPrtIdx, ethJumboFrameEnable=ethJumboFrameEnable, radFcdW=radFcdW, systemModule=systemModule, systemOamTimeoutCycles=systemOamTimeoutCycles, prtFrPlusNotSegmentedPriorities=prtFrPlusNotSegmentedPriorities, atmVpPMQoSTable=atmVpPMQoSTable, ethOamServiceDelayThresh=ethOamServiceDelayThresh, radBridgeIntervalTxCorrectBytesHCOverflow=radBridgeIntervalTxCorrectBytesHCOverflow, agnCnfgDataTable=agnCnfgDataTable, atmSysConfigCellTestVci=atmSysConfigCellTestVci, prtExLs6VRate=prtExLs6VRate, markingSpVlanPBit=markingSpVlanPBit, atmVpPMCurrentRxClp0=atmVpPMCurrentRxClp0, ip2IfClockSourceEnable=ip2IfClockSourceEnable, prtSRdnStatus=prtSRdnStatus, atmVpPMCurrentDir=atmVpPMCurrentDir, atmSysPSunits=atmSysPSunits, atmVcIntervalRxCellsClp01=atmVcIntervalRxCellsClp01, enrollmentTrap=enrollmentTrap, radBridgeAgingTimeSec=radBridgeAgingTimeSec, prtSAlarmOnOff=prtSAlarmOnOff, prtInVc3CnfgIdx=prtInVc3CnfgIdx, prtSupervisoryIndex=prtSupervisoryIndex, mdlAlrSltIdx=mdlAlrSltIdx, atmVcCurrentGcra1Violations=atmVcCurrentGcra1Violations, prtMonitoringEnable=prtMonitoringEnable, radBridgeIPXSapInfAgeMultiplier=radBridgeIPXSapInfAgeMultiplier, radBridgeDot1qVlanTaggedPorts=radBridgeDot1qVlanTaggedPorts, atmSysConfigCellTestSendCmd=atmSysConfigCellTestSendCmd, agnCQ50StopCallsThresh=agnCQ50StopCallsThresh, radBridgeMaskIfIndex=radBridgeMaskIfIndex, prtBertPrtIdx=prtBertPrtIdx, atmVpPMIntervalRxClp0=atmVpPMIntervalRxClp0, ip2IfMaxTxQueue=ip2IfMaxTxQueue, prtIpParamMngVlanPriority=prtIpParamMngVlanPriority, prtPerfBBE=prtPerfBBE, intSwdlSwDate=intSwdlSwDate, radSEC1=radSEC1, prtExHs4LineCode=prtExHs4LineCode, atmVcCurrentTable=atmVcCurrentTable, atmAceAlarmLOP=atmAceAlarmLOP, chasTotalNoOfSlt=chasTotalNoOfSlt, atmVcShaperDiscarded=atmVcShaperDiscarded, ds1RemoteMultiframeAlarmTrap=ds1RemoteMultiframeAlarmTrap, linkSelectorMaxIdleTime=linkSelectorMaxIdleTime, atmVcPmTable=atmVcPmTable, prtHSBertCountClr=prtHSBertCountClr, atmVcIntervalEntry=atmVcIntervalEntry, atmNteConfOam=atmNteConfOam, prtVc2SltIdx=prtVc2SltIdx, atmVcIntervalVci=atmVcIntervalVci, prtPhyCurrentStatus=prtPhyCurrentStatus, ip2IfNextHop=ip2IfNextHop, prtExPhPlModemSltIdx=prtExPhPlModemSltIdx, systemOamDescrLoopbackOperation=systemOamDescrLoopbackOperation, prtPerfSaveAndResetCmd=prtPerfSaveAndResetCmd, ethBackPressure=ethBackPressure, prtParamTxClk=prtParamTxClk, mdlSHwVersion=mdlSHwVersion, agnCT1E1RingWTR=agnCT1E1RingWTR, prtIn7p8VcPbxSltIdx=prtIn7p8VcPbxSltIdx, radBridgeMaskNum=radBridgeMaskNum, agnCnfgAlrFilterWindow=agnCnfgAlrFilterWindow, sysCRdnRecMode=sysCRdnRecMode, agnDriverSwMismatch=agnDriverSwMismatch, atmVcPMIntervalRxClp01=atmVcPMIntervalRxClp01, sysBufferAlrPort=sysBufferAlrPort, prtIsdnQsigRole=prtIsdnQsigRole, prtDlciSltIdx=prtDlciSltIdx, agnManagerConfigPorts=agnManagerConfigPorts, radBridgeCODTimeTriggerTo=radBridgeCODTimeTriggerTo, radSPS9=radSPS9, prtParamClkSrc=prtParamClkSrc, radBridgeCurrentTxBcastFrames=radBridgeCurrentTxBcastFrames, prtExClDataBits=prtExClDataBits, atmAceAlarmCluster=atmAceAlarmCluster, atmVcPmEntry=atmVcPmEntry, sysSRdnCmdTable=sysSRdnCmdTable, prtBertErrorBits=prtBertErrorBits, prtHSBertSlt=prtHSBertSlt, ethOamSvcIntervalFramesAboveDelayThresh=ethOamSvcIntervalFramesAboveDelayThresh, ethPortDataEnable=ethPortDataEnable, radBridgeCODTrafficTriggerStatus=radBridgeCODTrafficTriggerStatus, invNameXCType=invNameXCType, agnCmprTable=agnCmprTable, chassTotalNoOfSlt=chassTotalNoOfSlt, sysSAlrState=sysSAlrState, ethIfCurrentMultipleCollisionFrames=ethIfCurrentMultipleCollisionFrames, intSwdlSlotFileMismatch=intSwdlSlotFileMismatch, prtExHsfControlSignal=prtExHsfControlSignal, ethIfIntervalNumber=ethIfIntervalNumber, radBridgeMaskCond3=radBridgeMaskCond3, radHtuE1Sa=radHtuE1Sa, ip2IfStatPsnSeqErrors=ip2IfStatPsnSeqErrors, mdlPbxFraCnfgIdx=mdlPbxFraCnfgIdx, prtHdslIdx=prtHdslIdx, dsx1DataStreamStatInFrames=dsx1DataStreamStatInFrames, radIpMux8=radIpMux8, ethIfCurrentOutDiscardFrames=ethIfCurrentOutDiscardFrames, atmLoopbackVcIvlVci=atmLoopbackVcIvlVci, prtExTsSltIdx=prtExTsSltIdx, sanityTrap=sanityTrap, dsx1IntervalLOS=dsx1IntervalLOS, agnSystemDlci=agnSystemDlci, atmVpPMIntervalDir=atmVpPMIntervalDir, mdlAlarmsCmprAlarmIdx=mdlAlarmsCmprAlarmIdx, radUNT20Ric=radUNT20Ric, agnCurrClkTable=agnCurrClkTable, genBridge=genBridge, atmLoopbackVpMaxDelay=atmLoopbackVpMaxDelay, radBridgeIntervalRxBcastFrames=radBridgeIntervalRxBcastFrames, prtQosIdx=prtQosIdx, radSysLA=radSysLA, prtTestMacSwapLoopDirection=prtTestMacSwapLoopDirection, prtDs3IntervalFEBE=prtDs3IntervalFEBE, prtGenCnfgLinkToSlot=prtGenCnfgLinkToSlot, atmNteManagerVlanIdentifier=atmNteManagerVlanIdentifier, sysSSelfTestResult=sysSSelfTestResult, agnAlrBufCmprAlarmIdx=agnAlrBufCmprAlarmIdx, radMepCcInterval=radMepCcInterval, radBridgeLoopDetectVlanId=radBridgeLoopDetectVlanId, systemVoiceCoderEntry=systemVoiceCoderEntry, atmVpPMIntervalUAS=atmVpPMIntervalUAS, prtExPVc4DtmfRelay=prtExPVc4DtmfRelay, prtTestVctRxDistance=prtTestVctRxDistance, prtDs3IntervalLCE=prtDs3IntervalLCE, prtDimCnfgEntry=prtDimCnfgEntry, ip2IfVoiceOos=ip2IfVoiceOos, radDXC10A=radDXC10A, dscpMappingDscpIdx=dscpMappingDscpIdx, ethOamSvcTotalFramesAboveDelayThresh=ethOamSvcTotalFramesAboveDelayThresh, agnVoiceSwConfZoneId=agnVoiceSwConfZoneId, prtDlciCmprPrtIdx=prtDlciCmprPrtIdx, atmLoopbackVpAverageDelay=atmLoopbackVpAverageDelay, agnCFlipNetEventIdx=agnCFlipNetEventIdx, ip2IfVlanID=ip2IfVlanID, wfqTable=wfqTable, radRBHTEvents=radRBHTEvents, radBridgeIntervalFrameTypeDiscardedFrames=radBridgeIntervalFrameTypeDiscardedFrames, alarmStatusTrap=alarmStatusTrap, agnDlciLIdx=agnDlciLIdx, prtExPhPlClockEncoding=prtExPhPlClockEncoding, queueGroupEntry=queueGroupEntry, prtExPVc4ExtensionType=prtExPVc4ExtensionType, radOp4E1=radOp4E1, radETX102H=radETX102H, prtClCnfg=prtClCnfg, agnCurrClkQualification=agnCurrClkQualification, radVmux404=radVmux404, prtExPVc4DlciEntry=prtExPVc4DlciEntry, dhcpRelayAction=dhcpRelayAction, radMdRowStatus=radMdRowStatus, prtFrPlusCnfgEntry=prtFrPlusCnfgEntry, dsx1TcSignal=dsx1TcSignal, prtQosRateLimitEIR=prtQosRateLimitEIR, prtT1E1DataOos=prtT1E1DataOos, prtMl4Oos=prtMl4Oos, atmVpCurrentClp0CellOuts=atmVpCurrentClp0CellOuts, radMdTable=radMdTable, queueGroupQBlockIdx=queueGroupQBlockIdx, ethIfIntervalInDiscardFrames=ethIfIntervalInDiscardFrames, radAce3600=radAce3600, radBridgeDot1qVlanStaticTable=radBridgeDot1qVlanStaticTable, prtHSClkMode=prtHSClkMode, atmNteBridgingMode=atmNteBridgingMode, atmAceAlarmVpLostCells=atmAceAlarmVpLostCells, prtExPhPlLXon=prtExPhPlLXon, serviceStatEntry=serviceStatEntry, ethIfIntervalOverflowInBroadcastFrames=ethIfIntervalOverflowInBroadcastFrames, mdlPs=mdlPs, prtInVc3Rate=prtInVc3Rate, mdlAlarmsCmprVersion=mdlAlarmsCmprVersion, sysStatus=sysStatus, agnClkIntervalOutOfOrderPackets=agnClkIntervalOutOfOrderPackets, prtT1E1ConnectedTS=prtT1E1ConnectedTS, radBridgePortBaseVlan=radBridgePortBaseVlan, pLinkIdx=pLinkIdx, sysSBusCapturePort=sysSBusCapturePort, wrLanIpxNetTable=wrLanIpxNetTable, prtExLs6Cts=prtExLs6Cts, ethIfIntervalOutDiscardFrames=ethIfIntervalOutDiscardFrames, agnCnfgUpdMnger=agnCnfgUpdMnger, systemVoiceTxGain=systemVoiceTxGain, prtIsdnConnect=prtIsdnConnect, sysSAlrCode=sysSAlrCode, agnDeviceView=agnDeviceView, agnXCmprIdx4=agnXCmprIdx4, radAsmi450R1152Sa=radAsmi450R1152Sa, atmVpIntervalCDC=atmVpIntervalCDC, successfulLogin=successfulLogin, prtHs4Cnfg=prtHs4Cnfg, prtAlrMaskTable=prtAlrMaskTable, flowIndex=flowIndex, prtHSDCD=prtHSDCD, radBridgeCODTotalConnecTime=radBridgeCODTotalConnecTime, ethIfIntervalOutFrames=ethIfIntervalOutFrames, radImx2T1E1=radImx2T1E1, radMP204=radMP204, lagPortMembers=lagPortMembers, prtDs3CurrentPlcpRAI=prtDs3CurrentPlcpRAI, ip2IfStatSeqErrors=ip2IfStatSeqErrors, portIdx=portIdx, dhcpClientStatus=dhcpClientStatus, mdlClLastFlipCause=mdlClLastFlipCause, prtGenTsIdx=prtGenTsIdx, prtSpPrtIdx=prtSpPrtIdx, ethDot1xPortRole=ethDot1xPortRole, agnClkSrcPortType=agnClkSrcPortType, sysSRdnLockFlip=sysSRdnLockFlip, queueProfileObjects=queueProfileObjects, ethIfStormCtrlEnable=ethIfStormCtrlEnable, prtInMbeCnfgEntry=prtInMbeCnfgEntry, mdlSHwVer=mdlSHwVer, prtPriorityPrtIdx=prtPriorityPrtIdx, agnXCmprTable=agnXCmprTable, prtSInstTable=prtSInstTable, prtCfgParamTable=prtCfgParamTable, dsx1CurrentAIS=dsx1CurrentAIS, prtFrTxDcrdCongDeFr=prtFrTxDcrdCongDeFr, maskingDestActiveBits=maskingDestActiveBits, agnAlarmBufferOverflow=agnAlarmBufferOverflow, prtInPh1MlDlciIConSlt=prtInPh1MlDlciIConSlt)
mibBuilder.exportSymbols("RAD-MIB", mdlCSltIdx=mdlCSltIdx, ethIfIntervalOverflowInUnicastFrames=ethIfIntervalOverflowInUnicastFrames, hostVlanTagging=hostVlanTagging, systemResetAllStatsCmd=systemResetAllStatsCmd, sysCRdnMode=sysCRdnMode, radBridgeCurrentFrameTypeDiscardedFrames=radBridgeCurrentFrameTypeDiscardedFrames, atmConfVpLoopbackFailureThreshold=atmConfVpLoopbackFailureThreshold, radBridgePortBaseVlanTable=radBridgePortBaseVlanTable, atmVcShaperTotalEpdDropped=atmVcShaperTotalEpdDropped, ip2IfExitPort=ip2IfExitPort, radBridgeGenFlowMulticastTrafficClass=radBridgeGenFlowMulticastTrafficClass, mdlStatHostMask=mdlStatHostMask, alarmAIS=alarmAIS, prtPhyIntervalStatus=prtPhyIntervalStatus, agnClkCurrentLostPackets=agnClkCurrentLostPackets, prtCfgParamInbandLoopPatternCfg=prtCfgParamInbandLoopPatternCfg, ethOamServiceOverflowFrameLoss=ethOamServiceOverflowFrameLoss, agnFunctionTable=agnFunctionTable, atmVpShaperOccupation=atmVpShaperOccupation, prtSupervisoryRoutProtocol=prtSupervisoryRoutProtocol, wrSpoofingAgingStation=wrSpoofingAgingStation, prtT1FdlMsgFdlTxRx=prtT1FdlMsgFdlTxRx, prtExHs4TsIConPrt=prtExHs4TsIConPrt, ethIfMacLayerEvents=ethIfMacLayerEvents, dsx1DataStreamStatIndex=dsx1DataStreamStatIndex, prtInLs6CnfgTable=prtInLs6CnfgTable, atmLoopbackVcIvlIvl=atmLoopbackVcIvlIvl, prtT1E1Multiplier=prtT1E1Multiplier, prtT3E3LineLength=prtT3E3LineLength, prtAcmCnfgTable=prtAcmCnfgTable, prtT1E1InbandMng=prtT1E1InbandMng, ethIfIntervalStatus=ethIfIntervalStatus, dot1agXCfmMepDestAddrType=dot1agXCfmMepDestAddrType, maskingSourceAddress=maskingSourceAddress, ethOamServicePriority=ethOamServicePriority, unknown=unknown, prtDs3TotalTable=prtDs3TotalTable, atmLoopbackVcVpi=atmLoopbackVcVpi, radBridgePortCnfgIngressMtu=radBridgePortCnfgIngressMtu, linkSelectorPrtIdx=linkSelectorPrtIdx, prtQosDirection=prtQosDirection, prtPhyIntervalLSV=prtPhyIntervalLSV, prtExHs4TsIConSlot=prtExHs4TsIConSlot, prtInLs6SltIdx=prtInLs6SltIdx, prtExVcPbxTsIConPrt=prtExVcPbxTsIConPrt, atmNteHostDefaultNextHop=atmNteHostDefaultNextHop, prtFrPlusCnfgTable=prtFrPlusCnfgTable, radFcdIsdn=radFcdIsdn, prtExPh1MlTsChRate=prtExPh1MlTsChRate, atmVcPmSource=atmVcPmSource, prtDimDestTable=prtDimDestTable, prtExPh1MlTsType=prtExPh1MlTsType, atmVpCurrentPCR=atmVpCurrentPCR, systemVoiceModemSupport=systemVoiceModemSupport, agnCnfgAlrPort=agnCnfgAlrPort, radBridgeGenFlowQosMode=radBridgeGenFlowQosMode, wrIpxNetAddress=wrIpxNetAddress, agnSLastCnfgFlipCause=agnSLastCnfgFlipCause, prtExLs6LinkToInternal=prtExLs6LinkToInternal, serviceName=serviceName, agnLed=agnLed, alarmForwardingRecoveryMode=alarmForwardingRecoveryMode, agnListDecoding=agnListDecoding, prtExPhPlDceClkSrc=prtExPhPlDceClkSrc, atmVpShaperLevel=atmVpShaperLevel, radBridgeMaskPat3=radBridgeMaskPat3, prtExPhPlStopBits=prtExPhPlStopBits, prtInTreCnfgTable=prtInTreCnfgTable, radSysCnvrtr=radSysCnvrtr, systemTiming=systemTiming, evcCosEntry=evcCosEntry, radMepTransmitLbmVlanPriority=radMepTransmitLbmVlanPriority, agnSAlrStatusAll=agnSAlrStatusAll, qInternalProfileWFQWeight=qInternalProfileWFQWeight, prtPerfES=prtPerfES, prtExTsSplitTable=prtExTsSplitTable, dsx1DataStreamStatInBytes=dsx1DataStreamStatInBytes, mdlSSltIdx=mdlSSltIdx, prtHSCTS=prtHSCTS, prtPhMlRate=prtPhMlRate, dhcpPoolAllocMacAddress=dhcpPoolAllocMacAddress, prtDs3CurrentStatus=prtDs3CurrentStatus, prtDlciStatisEntry=prtDlciStatisEntry, atmVpShaperTotalEpdDropped=atmVpShaperTotalEpdDropped, wrLanIfIndex=wrLanIfIndex, systemOamDescrMode=systemOamDescrMode, sysSRdnFlipSlot=sysSRdnFlipSlot, mdlCNoOfIntPrt=mdlCNoOfIntPrt, prtMonitoringIdx=prtMonitoringIdx, ifTeQosTable=ifTeQosTable, radAPS24=radAPS24, alarmFEBE=alarmFEBE, agnSendTrapParameter=agnSendTrapParameter, mdlPbxFraEnhEcho=mdlPbxFraEnhEcho, alarmSeverity=alarmSeverity, agnAlarmsCmprVersion=agnAlarmsCmprVersion, prtExPVc4IfType=prtExPVc4IfType, radMepTransmitLtmTargetMepId=radMepTransmitLtmTargetMepId, atmAceRedundancyTrap=atmAceRedundancyTrap, alarmForwardingDelay=alarmForwardingDelay, trapEntry=trapEntry, prtInHsiPrtIdx=prtInHsiPrtIdx, radSysAtmEvents=radSysAtmEvents, atmVcIntervalRxCellsClp0=atmVcIntervalRxCellsClp0, prtCnfgAgendaSesId=prtCnfgAgendaSesId, radBridgePortBaseVlanName=radBridgePortBaseVlanName, prtLogicalRowStatus=prtLogicalRowStatus, prtExVc3TransGain=prtExVc3TransGain, atmConfIfFrameType=atmConfIfFrameType, alarmRDI=alarmRDI, prtInPh1MlDlciPriority=prtInPh1MlDlciPriority, srvDiscardYellowRedPacketsOverflow=srvDiscardYellowRedPacketsOverflow, radBridgeIntervalTxCorrectBytes=radBridgeIntervalTxCorrectBytes, ip2IfReversePolarity=ip2IfReversePolarity, prtExPVc4SrcIpAddress=prtExPVc4SrcIpAddress, radBridgeGenFlowTable=radBridgeGenFlowTable, agnVoiceSwConfHGTable=agnVoiceSwConfHGTable, dot3OamDescrTable=dot3OamDescrTable, prtBertCounter=prtBertCounter, prtDs3IntervalPlcpFEBE=prtDs3IntervalPlcpFEBE, dsx1XTotalTable=dsx1XTotalTable, atmVcPMQoSCMR=atmVcPMQoSCMR, agnDlciHSltIdx=agnDlciHSltIdx, portTrafficClassIdx1=portTrafficClassIdx1, radMepCcStat=radMepCcStat, prtDim=prtDim, sysChas=sysChas, prtExPVc4Rate=prtExPVc4Rate, mdlPsTable=mdlPsTable, wrDhcpLowIpAddress=wrDhcpLowIpAddress, radMiricE1T1=radMiricE1T1, radSAH16Text=radSAH16Text, atmIfCurrentTable=atmIfCurrentTable, agnClkSrcPortRowStatus=agnClkSrcPortRowStatus, atmConfVpOamSupport=atmConfVpOamSupport, radMepSpVlanId=radMepSpVlanId, ifCreateEntityIdx=ifCreateEntityIdx, fileServerIP=fileServerIP, agnSErrListEntry=agnSErrListEntry, agnXCmprTypIdx=agnXCmprTypIdx, sanityCheckTrap=sanityCheckTrap, agnClkSrcPortSrcIdx=agnClkSrcPortSrcIdx, prtE2PrtIdx=prtE2PrtIdx, atmNteManagerRowStatus=atmNteManagerRowStatus, prtBdbandIndTable=prtBdbandIndTable, agnSAlrCode=agnSAlrCode, prtIpParamKeepAliveInterval=prtIpParamKeepAliveInterval, prtIpParamTos=prtIpParamTos, agnFlipDbControls=agnFlipDbControls, sysDclFlipCmd=sysDclFlipCmd, agnStationClkFailureTrap=agnStationClkFailureTrap, mdlAlrEntry=mdlAlrEntry, prtT1E1SPrtIdx=prtT1E1SPrtIdx, prtExPhPlDlciPrtIdx=prtExPhPlDlciPrtIdx, wrFrCllmMessages=wrFrCllmMessages, bitMappingTable=bitMappingTable, genDacsMux=genDacsMux, srvDiscardGreenPacket=srvDiscardGreenPacket, systemOamEntry=systemOamEntry, radBridgeCODTimeTriggerNum=radBridgeCODTimeTriggerNum, autoFileTransferTimeRecurrence=autoFileTransferTimeRecurrence, agnCounterChange=agnCounterChange, prtAcmConnect=prtAcmConnect, prtPriorityEntry=prtPriorityEntry, services=services, ip2IfNetworkType=ip2IfNetworkType, prtT1E1SSlt=prtT1E1SSlt, atmVcCurrentRxRDI=atmVcCurrentRxRDI, ethIfCurrentOverflowInMulticastFrames=ethIfCurrentOverflowInMulticastFrames, ethOamStdEtherType=ethOamStdEtherType, prtExPh1MlQ50BwControl=prtExPh1MlQ50BwControl, prtExPhPlDlciSltIdx=prtExPhPlDlciSltIdx, prtCfgParamEntry=prtCfgParamEntry, ethPortPriority=ethPortPriority, radBridgePortCnfgIdx=radBridgePortCnfgIdx, prtParamClkWaveShape=prtParamClkWaveShape, chasWanGen=chasWanGen, prtExVc3Rate=prtExVc3Rate, queueGroupQBlockName=queueGroupQBlockName, prtPhMlCnfgIdx=prtPhMlCnfgIdx, ethIfPerfInOkOctets=ethIfPerfInOkOctets, systemOamDescrLoopbackDestAddr=systemOamDescrLoopbackDestAddr, ip2IfEthSwitchMode=ip2IfEthSwitchMode, prtExPh1MlTsIConPrt=prtExPh1MlTsIConPrt, radETX102=radETX102, prtInPh1MlFrMngProt=prtInPh1MlFrMngProt, prtSpDcdDelay=prtSpDcdDelay, agnHwVersion=agnHwVersion, sysSMaxNoOfCnfg=sysSMaxNoOfCnfg, flowMappingProfileNumOfMaps=flowMappingProfileNumOfMaps, prtFrStatisTable=prtFrStatisTable, atmNtePM=atmNtePM, cosProfileRowStatus=cosProfileRowStatus, prtExPhPlConnect=prtExPhPlConnect, prtDs3IntervalOOF=prtDs3IntervalOOF, prtIpParamVlanSupport=prtIpParamVlanSupport, prtFrRxMngFrames=prtFrRxMngFrames, prtHSInterfaceType=prtHSInterfaceType, prtPriorityTable=prtPriorityTable, agnSaSwchStatus=agnSaSwchStatus, radBridgeCODTimeIfIndex=radBridgeCODTimeIfIndex, radRRFTBSAS=radRRFTBSAS, prtIn7p8VcPbxMode=prtIn7p8VcPbxMode, prtHsfSltIdx=prtHsfSltIdx, prtIsdnStatusCallDirection=prtIsdnStatusCallDirection, atmNteConnectionsNumber=atmNteConnectionsNumber, ip2IfSourceAddr=ip2IfSourceAddr, prtExHs4LineLen=prtExHs4LineLen, prtIn1p6VcPbxCnfgIdx=prtIn1p6VcPbxCnfgIdx, ip2IfRateLimit=ip2IfRateLimit, dacsMuxAlarmsTrap=dacsMuxAlarmsTrap, dscpMappingTable=dscpMappingTable, qosFlowMappingFromTcpDestPort=qosFlowMappingFromTcpDestPort, atmVpShaperDiscarded=atmVpShaperDiscarded, wrSpoofingRowStatus=wrSpoofingRowStatus, prtIpParamLimitPacketType=prtIpParamLimitPacketType, prtMonTable=prtMonTable, sysBufferAlrCode=sysBufferAlrCode, atmNteProtectionSwitchLink=atmNteProtectionSwitchLink, prtExTsRxIoSignaling=prtExTsRxIoSignaling, prtHdslTable=prtHdslTable, markingProfileIndex=markingProfileIndex, sysSRdnFlipTableClearCmd=sysSRdnFlipTableClearCmd, wrDhcpAction=wrDhcpAction, prtVc2CnfgTable=prtVc2CnfgTable, radMdIndex=radMdIndex, sysCurrentAlr=sysCurrentAlr, atmVcCurrentTxRDI=atmVcCurrentTxRDI, alrBufTable=alrBufTable, ethIfIntervalSingleCollisionFrames=ethIfIntervalSingleCollisionFrames, mdlSMaskedAlrStatAll=mdlSMaskedAlrStatAll, qosFlowMappingIdx1=qosFlowMappingIdx1, ethIfRingEntry=ethIfRingEntry, radVmux320=radVmux320, prtHsfCnfgEntry=prtHsfCnfgEntry, prtBertInjectRate=prtBertInjectRate, prtExPhPlDlciPriority=prtExPhPlDlciPriority, ip2IfIntervalStatMinJittBufLevel=ip2IfIntervalStatMinJittBufLevel, atmVpPMIntervalNumber=atmVpPMIntervalNumber, prtPhMlCorrectionMode=prtPhMlCorrectionMode, radSPS12=radSPS12, radMLBT=radMLBT, radDot1qPortCopyOriginVlanPriority=radDot1qPortCopyOriginVlanPriority, agnXCmprIdx5=agnXCmprIdx5, sysCClkCnfgIdx=sysCClkCnfgIdx, prtT1E1FdlMsgPrtIdx=prtT1E1FdlMsgPrtIdx, atmVcPerformance=atmVcPerformance, radMepLbmOut=radMepLbmOut, prtT1E1IdleCode=prtT1E1IdleCode, radBridgePortBaseVlanCnfgIdx=radBridgePortBaseVlanCnfgIdx, maskingSourceActiveBits=maskingSourceActiveBits, prtIn1p6VcPbxEchoCanceler=prtIn1p6VcPbxEchoCanceler, ip2IfRingBack=ip2IfRingBack, radBridgeCODAnswerConnectCondition=radBridgeCODAnswerConnectCondition)
mibBuilder.exportSymbols("RAD-MIB", ip2IfMplsTxLabel=ip2IfMplsTxLabel, prtT3E3CnfgEntry=prtT3E3CnfgEntry, atmAlarmForwardingToPort=atmAlarmForwardingToPort, ip2IfMfRelay=ip2IfMfRelay, qInternalProfileEntry=qInternalProfileEntry, agnCSaveNetCnfgIdxCmd=agnCSaveNetCnfgIdxCmd, prtIpParamEncapsulationProt=prtIpParamEncapsulationProt, systemVoiceDtmfRelayMethod=systemVoiceDtmfRelayMethod, prtExTreCnfgIdx=prtExTreCnfgIdx, ip2IfPulseMeterFreq=ip2IfPulseMeterFreq, prtLanWanVlanPriority=prtLanWanVlanPriority, lagRecoveryMode=lagRecoveryMode, agnCClkCnfgIdx=agnCClkCnfgIdx, ethOamSvcIntervalFramesTxCounter=ethOamSvcIntervalFramesTxCounter, chasTotalNoOfClSlt=chasTotalNoOfClSlt, prtLanWanVlanId=prtLanWanVlanId, prtExPhPlHRate=prtExPhPlHRate, radETX201=radETX201, interfacePerformance=interfacePerformance, sysCRdnSecPriority=sysCRdnSecPriority, ethOamSvcTotalAvgRoundTripDVar=ethOamSvcTotalAvgRoundTripDVar, prtExPh1MlTsByteReversal=prtExPh1MlTsByteReversal, systemTimeElapsed=systemTimeElapsed, atmConfVpCCOperStatus=atmConfVpCCOperStatus, ip2IfEntry=ip2IfEntry, prtDimDestEntry=prtDimDestEntry, prtInPh1MlDlciPrtIdx=prtInPh1MlDlciPrtIdx, qosFlowMappingToInnerVlanId=qosFlowMappingToInnerVlanId, xcIndexNext=xcIndexNext, sysDclCopyDbIdx=sysDclCopyDbIdx, alarmLOS=alarmLOS, prtExVc2CompressMethod=prtExVc2CompressMethod, atmVpQoSEntry=atmVpQoSEntry, prtSInstSltIdx=prtSInstSltIdx, sysCEnableLanOverTdm=sysCEnableLanOverTdm, ethIfIntervalOverflowOutPauseFrames=ethIfIntervalOverflowOutPauseFrames, gfp=gfp, maskingHighLevelProt=maskingHighLevelProt, prtIsdnEndpointCnfgIdx=prtIsdnEndpointCnfgIdx, cnfgFlipTrap=cnfgFlipTrap, mdlWanGen=mdlWanGen, prtExPVc4AutoFaxMode=prtExPVc4AutoFaxMode, atmVcCurrentUAS=atmVcCurrentUAS, sysSRdnFlipTable=sysSRdnFlipTable, prtHdslMaxRate=prtHdslMaxRate, ethIfIntervalDeferredTransmissions=ethIfIntervalDeferredTransmissions, prtMl4PrtIdx=prtMl4PrtIdx, prtInTreCnfgEntry=prtInTreCnfgEntry, prtExLs6VIfType=prtExLs6VIfType, radFTC1UDP=radFTC1UDP, ethIfPerformance=ethIfPerformance, atmVpCurrentVpi=atmVpCurrentVpi, sysSAlrStatusAll=sysSAlrStatusAll, prtGen=prtGen, dot1agXCfmMdProtocol=dot1agXCfmMdProtocol, prtExPh1MlFragmentSize=prtExPh1MlFragmentSize, agnLinkMapTable=agnLinkMapTable, prtSAlrTable=prtSAlrTable, atmVpPMQoSCLR=atmVpPMQoSCLR, sysSRdnFlipDate=sysSRdnFlipDate, radMdFormat=radMdFormat, prtExHsfCts=prtExHsfCts, agnListDecodingSeverity=agnListDecodingSeverity, mdlCmprObj=mdlCmprObj, prtInPh1MlDlciValid=prtInPh1MlDlciValid, dsx1TotalLOS=dsx1TotalLOS, atmLoopbackVpIvlCDV=atmLoopbackVpIvlCDV, atmVpPmVpi=atmVpPmVpi, radMX3004=radMX3004, prtExHsrEncapsMode=prtExHsrEncapsMode, portTrafficClassPortIdx=portTrafficClassPortIdx, radFPS4=radFPS4, prtDs3IntervalLOS=prtDs3IntervalLOS, prtExTreCnfgTable=prtExTreCnfgTable, atmGenSysLogIndex=atmGenSysLogIndex, atmNteIntervalMaxNumber=atmNteIntervalMaxNumber, systemClearTablesCmd=systemClearTablesCmd, prtPerfEntry=prtPerfEntry, agnMonitorModeCmd=agnMonitorModeCmd, radBridgeMaskTable=radBridgeMaskTable, radBridgeIPXSapInfEntry=radBridgeIPXSapInfEntry, agnCQ50CnfgIdx=agnCQ50CnfgIdx, agnCQ50BlockNewModemRelayCallsThresh=agnCQ50BlockNewModemRelayCallsThresh, radTMA=radTMA, prtExPVc4TxGain=prtExPVc4TxGain, ip2IfIntervalStatMaxJittBufLevel=ip2IfIntervalStatMaxJittBufLevel, sysCRdnCnfgIdx=sysCRdnCnfgIdx, alarmForwardingToPort=alarmForwardingToPort, mdlCmprCnfgIdx=mdlCmprCnfgIdx, qosFlowMappingIeee802dot1p=qosFlowMappingIeee802dot1p, prtClkSrcIdx=prtClkSrcIdx, atmInterfaceMaskAlarms=atmInterfaceMaskAlarms, radOp4T1=radOp4T1, atmNteConnectionsMaxNumber=atmNteConnectionsMaxNumber, sysDclTable=sysDclTable, prtParamLineLength=prtParamLineLength, wrSpoofingEntry=wrSpoofingEntry, sysCRdnBuffUnderrunTime=sysCRdnBuffUnderrunTime, prtIpParamMng=prtIpParamMng, qosFlowMappingToDscp=qosFlowMappingToDscp, systemOamDescrXcCounter=systemOamDescrXcCounter, localConnStatusTrap=localConnStatusTrap, cmprEntry=cmprEntry, qInternalProfileIndex=qInternalProfileIndex, radETX202A=radETX202A, prtDimMngRoutProt=prtDimMngRoutProt, prtCfgParamInbandLoopDetection=prtCfgParamInbandLoopDetection, optPrtMonitorTable=optPrtMonitorTable, prtSInterfaceType=prtSInterfaceType, prtExLs6VCnfgEntry=prtExLs6VCnfgEntry, dsx1XConfigTable=dsx1XConfigTable, dot1agXCfmMepDestMacAddr=dot1agXCfmMepDestMacAddr, radFPS8c=radFPS8c, agnCBuMlSubnetMask=agnCBuMlSubnetMask, prtExVc2ConvTime=prtExVc2ConvTime, atmIfCurrentCorrectedHecs=atmIfCurrentCorrectedHecs, radMepDefaultPriority=radMepDefaultPriority, ethOamServiceFramesAboveDelayVar=ethOamServiceFramesAboveDelayVar, agnDlciRoutingProtocol=agnDlciRoutingProtocol, prtInLs2Member=prtInLs2Member, ethIfCurrentIndex=ethIfCurrentIndex, atmGenSysLogClearAll=atmGenSysLogClearAll, prtAgendaBehaviourSltIdx=prtAgendaBehaviourSltIdx, radTransportDomains=radTransportDomains, prtFrRxTotalFrames=prtFrRxTotalFrames, atmVcIntervalTaggedOuts=atmVcIntervalTaggedOuts, atmNteVpAlarmVpi=atmNteVpAlarmVpi, prtExHs4Connect=prtExHs4Connect, sysSAlrEntry=sysSAlrEntry, prtExPVc4MinPowerLevel=prtExPVc4MinPowerLevel, radKM2104=radKM2104, dsx1DataStreamStatOutFrames=dsx1DataStreamStatOutFrames, mdlSSecondaryBackupSwVer=mdlSSecondaryBackupSwVer, srvForwardGreenPacktesOverflow=srvForwardGreenPacktesOverflow, atmNteUnitId=atmNteUnitId, mdlAlrMaskSltIdx=mdlAlrMaskSltIdx, ip2IfIntervalStatSeqErrors=ip2IfIntervalStatSeqErrors, prtSAlarmCode=prtSAlarmCode, ethIfSrcMacCtrlLocking=ethIfSrcMacCtrlLocking, prtExVcPbxTsEntry=prtExVcPbxTsEntry, radBridgeMaskPat1=radBridgeMaskPat1, sysSSanityCheckStatus=sysSSanityCheckStatus, prtFrTxDcrdCongAllFr=prtFrTxDcrdCongAllFr, alrGenCode=alrGenCode, atmConfVpLoopbackTraffic=atmConfVpLoopbackTraffic, prtMl4OosEntryThreshold=prtMl4OosEntryThreshold, atmVpCrossConnectName=atmVpCrossConnectName, prtInPh1MlSltType=prtInPh1MlSltType, prtTestTable=prtTestTable, radDot1qPortStacking=radDot1qPortStacking, atmVpIntervalClp0Discards=atmVpIntervalClp0Discards, ip2IfCallerIdRxGain=ip2IfCallerIdRxGain, prtParam=prtParam, prtPhyCurrentEntry=prtPhyCurrentEntry, sysSAlrDataUpdateCmd=sysSAlrDataUpdateCmd, radBridgeIPXRipOutPackets=radBridgeIPXRipOutPackets, prtExPhPlFlowControl=prtExPhPlFlowControl, prtExVc2Oos=prtExVc2Oos, dsx1OosSignal=dsx1OosSignal, mdlCTable=mdlCTable, prtT1E1FdlMsgFdlType=prtT1E1FdlMsgFdlType, atmConfIfInputRate=atmConfIfInputRate, ethIfCurrentStatus=ethIfCurrentStatus, sysSAlrAttrIndication=sysSAlrAttrIndication, radStarSwitch=radStarSwitch, prtHsiCnfg=prtHsiCnfg, prtExPh1MlMultiplier=prtExPh1MlMultiplier, prtExClStopBits=prtExClStopBits, mapLinkId=mapLinkId, prtDs3TotalLCE=prtDs3TotalLCE, prtIsdnDirectoryRemoteAddr=prtIsdnDirectoryRemoteAddr, atmVcPMCurrentMisinsertedCells=atmVcPMCurrentMisinsertedCells, atmNteConfOamIfTable=atmNteConfOamIfTable, dsx1LeasedLine=dsx1LeasedLine, radOptimux4E1=radOptimux4E1, gfpPayloadFcs=gfpPayloadFcs, radFDX100=radFDX100, prtExVcPbxCnfgIdx=prtExVcPbxCnfgIdx, prtExVc3ReceiveGain=prtExVc3ReceiveGain, prtIsdnCnfgEntry=prtIsdnCnfgEntry, radOptimux4E1L=radOptimux4E1L, atmVpIntervalSES=atmVpIntervalSES, atmLoopbackVcAverageDelay=atmLoopbackVcAverageDelay, atmThresholdPathFEBE=atmThresholdPathFEBE, ip2IfStatTxOnMaxSize=ip2IfStatTxOnMaxSize, radBridgeStp=radBridgeStp, atmVcPMCurrentUAS=atmVcPMCurrentUAS, prtInMbeCnfgTable=prtInMbeCnfgTable, atmIfDataTable=atmIfDataTable, optPrtMonitorRxPower=optPrtMonitorRxPower, atmAlarmForwardingRecoveryCommand=atmAlarmForwardingRecoveryCommand, prtAlrMaskPrtIdx=prtAlrMaskPrtIdx, ip2IfTDMBytesInFrame=ip2IfTDMBytesInFrame, ip2IfPortTotalThroughput=ip2IfPortTotalThroughput, dhcpIfClientTable=dhcpIfClientTable, atmNteManagerConfigPorts=atmNteManagerConfigPorts, ethOamStdMacAddress=ethOamStdMacAddress, prtInLs2EnvAssign=prtInLs2EnvAssign, mapWanGen=mapWanGen, agnSelfTestResultChangeTrap=agnSelfTestResultChangeTrap, prtInLs6CnfgIdx=prtInLs6CnfgIdx, atmAceAlarmForwardingTrap=atmAceAlarmForwardingTrap, atmVpIntervalTxAIS=atmVpIntervalTxAIS, prtSBertTstRslt=prtSBertTstRslt, ip2IfStatRxHdlc=ip2IfStatRxHdlc, dsx3MappingIfIndex=dsx3MappingIfIndex, prtDs3CurrentRDI=prtDs3CurrentRDI, ip2IfDestAddr=ip2IfDestAddr, prtSpCnfgEntry=prtSpCnfgEntry, ethIfIntervalCarrierSenseErrors=ethIfIntervalCarrierSenseErrors, agnCT1E1RingEntry=agnCT1E1RingEntry, prtPhyConfigTable=prtPhyConfigTable, radBridgeIPXRipInfEntry=radBridgeIPXRipInfEntry, pLinkPrtIdx=pLinkPrtIdx, channelOperStatusTrap=channelOperStatusTrap, agnClkCurrentIndex=agnClkCurrentIndex, mdlCmprEntry=mdlCmprEntry, atmVcPMIntervalLastDayQuality=atmVcPMIntervalLastDayQuality, prtExTsBitTest=prtExTsBitTest, qProfileInternalQProfile=qProfileInternalQProfile, ip2IfStatHdlcAlignErr=ip2IfStatHdlcAlignErr, prtInPh1MlConnect=prtInPh1MlConnect, atmVpIntervalRxCellsClp0=atmVpIntervalRxCellsClp0, prtDlciRxBeViol=prtDlciRxBeViol, ethOamServiceOverflowTxFrames=ethOamServiceOverflowTxFrames, mdlAlarmCounter=mdlAlarmCounter, prtLogicalCnfgTable=prtLogicalCnfgTable, wfqMaxPacketSize=wfqMaxPacketSize, radOp1550=radOp1550, radBridgeGenFlowEntry=radBridgeGenFlowEntry, prtMonitoringTSs=prtMonitoringTSs, radVOIP=radVOIP, agnSystemTs=agnSystemTs, prtIpParamMediaRate=prtIpParamMediaRate, prtLs6Cnfg=prtLs6Cnfg, mngSnmpTrapUdpPort=mngSnmpTrapUdpPort, radHcdE1Sa=radHcdE1Sa, atmVpPMCurrentIntervalQuality=atmVpPMCurrentIntervalQuality, ifTeQosIdx2=ifTeQosIdx2, prtHsfCnfgTable=prtHsfCnfgTable, sysSaPorts=sysSaPorts, atmVpPMQoSCMR=atmVpPMQoSCMR, sysSDateFormat=sysSDateFormat, schedXEntry=schedXEntry, prtLanWanStpCost=prtLanWanStpCost, prtIpParamKeepAliveThresh=prtIpParamKeepAliveThresh, prtIsdnEndpointIdx=prtIsdnEndpointIdx, radMepTransmitLbmDestMepId=radMepTransmitLbmDestMepId, wrLanIfRdnTimeout=wrLanIfRdnTimeout, atmVpCurrentEntry=atmVpCurrentEntry, radRingMonitor=radRingMonitor, radBridgeIPX=radBridgeIPX, radLrs12B=radLrs12B, ethOamServiceFrameLossRatioThresh=ethOamServiceFrameLossRatioThresh)
mibBuilder.exportSymbols("RAD-MIB", atmNteDefaultVpi=atmNteDefaultVpi, prtCrRxDataCells=prtCrRxDataCells, xModemFileTransferStatusTrap=xModemFileTransferStatusTrap, modlChangeTrap=modlChangeTrap, atmAceAlarmUAS=atmAceAlarmUAS, prtIpParamRateLimit=prtIpParamRateLimit, agnCFlipNetEventsTable=agnCFlipNetEventsTable, sysSBusEntry=sysSBusEntry, radAce3100=radAce3100, prtIsdnInterface=prtIsdnInterface, dsx1DataStreamStatInDiscards=dsx1DataStreamStatInDiscards, atmLoopbackVcIvlTable=atmLoopbackVcIvlTable, ripSapIfConfStatus=ripSapIfConfStatus, mdlSPiggybackVer=mdlSPiggybackVer, ip2IfCallerIdTxGain=ip2IfCallerIdTxGain, sysCRoutingOnEth=sysCRoutingOnEth, prtDest=prtDest, agnTsCmprPduIdx=agnTsCmprPduIdx, radOptimuxXL16E1=radOptimuxXL16E1, agnDlciHPrtIdx=agnDlciHPrtIdx, prtExPhPlProtDelayLevel=prtExPhPlProtDelayLevel, invNameXCTable=invNameXCTable, prtFrPlusCnfgIdx=prtFrPlusCnfgIdx, prtPhyConfigEntry=prtPhyConfigEntry, ethIfCurrentInUnicastFrames=ethIfCurrentInUnicastFrames, atmNteManagerAlarmTrapMask=atmNteManagerAlarmTrapMask, srvForwardGreenPackets=srvForwardGreenPackets, prtTestMacSwapLoopDestAddr=prtTestMacSwapLoopDestAddr, prtAcmCnfg=prtAcmCnfg, mdlSInstTable=mdlSInstTable, dsx1DataStreamStatOutErrors=dsx1DataStreamStatOutErrors, systemVoiceCoderConfIdx=systemVoiceCoderConfIdx, atmNteProtectionWorkingLink=atmNteProtectionWorkingLink, qosFlowMappingToTcpDestPort=qosFlowMappingToTcpDestPort, radMP2104VoIP=radMP2104VoIP, qosFlowMappingFromSrcIpAddr=qosFlowMappingFromSrcIpAddr, radSPS3=radSPS3, prtT3E3Slt=prtT3E3Slt, atmSysConfigCellTestOamType=atmSysConfigCellTestOamType, prtExVcPbxIdleCode=prtExVcPbxIdleCode, mngIP=mngIP, prtExVc3CnfgEntry=prtExVc3CnfgEntry, agnLinkMapEntry=agnLinkMapEntry, agnCFlipDbNo=agnCFlipDbNo, mdlClEntry=mdlClEntry, systems=systems, atmAceDateAndTimeRequest=atmAceDateAndTimeRequest, ip2IfStatMinRoundTripDelay=ip2IfStatMinRoundTripDelay, ethOamSvcIntervalAvgRoundTripDVar=ethOamSvcIntervalAvgRoundTripDVar, ethIfIntervalOverflowOutOctets=ethIfIntervalOverflowOutOctets, prtExHs4TsPrtIdx=prtExHs4TsPrtIdx, prtDs3CurrentLOC=prtDs3CurrentLOC, mdlCPrgCardType=mdlCPrgCardType, prtExHsrCts=prtExHsrCts, dsx1XIntervalEntry=dsx1XIntervalEntry, srvDiscardRedPackets=srvDiscardRedPackets, ds1LinkFrameSlipTrap=ds1LinkFrameSlipTrap, atmVpPMQoSEntry=atmVpPMQoSEntry, systemOamDescrTable=systemOamDescrTable, wrSpoofingIfIndex=wrSpoofingIfIndex, prtBdbandCnfgIdx=prtBdbandCnfgIdx, sysSErrType=sysSErrType, prtLogicalSltIdx=prtLogicalSltIdx, sysSAlrMaskAll=sysSAlrMaskAll, ethIfSrcMacCtrlMaxPermitAddr=ethIfSrcMacCtrlMaxPermitAddr, intSwdlObjIdx=intSwdlObjIdx, radAce2002E=radAce2002E, fileTransferProtocol=fileTransferProtocol, prtFrTxTotalBytes=prtFrTxTotalBytes, xcBitMapping=xcBitMapping, ethOamSvcTotalTable=ethOamSvcTotalTable, prtExPh1MlMfClkSrcSlt=prtExPh1MlMfClkSrcSlt, sysCClkRevertiveTimeout=sysCClkRevertiveTimeout, ip2IfIntervalStatIndex=ip2IfIntervalStatIndex, prtTestVctRxResult=prtTestVctRxResult, radBridgeIntervalIngressFilteringDiscardedFrames=radBridgeIntervalIngressFilteringDiscardedFrames, prtCfgParamMlAtoMlBPrio=prtCfgParamMlAtoMlBPrio, prtSAlrCodeDescription=prtSAlrCodeDescription, atmLoopbackVpErrSessions=atmLoopbackVpErrSessions, prtExPh1MlLineCode=prtExPh1MlLineCode, prtExPhPlModemMaxIdleTime=prtExPhPlModemMaxIdleTime, agnTelnetAccess=agnTelnetAccess, radBridgeStpCnfgForwardDelay=radBridgeStpCnfgForwardDelay, chasTotalNoOfPsSlt=chasTotalNoOfPsSlt, prtInLs2Group=prtInLs2Group, atmConfVpLoopbackAdminStatus=atmConfVpLoopbackAdminStatus, atmNteAlarmVcTable=atmNteAlarmVcTable, atmNtePlugAndPlayActivity=atmNtePlugAndPlayActivity, radBridgeMaskActiveBit3=radBridgeMaskActiveBit3, optPrtMonitorSupplyVoltage=optPrtMonitorSupplyVoltage, radAce3400=radAce3400, prtExClCnfgTable=prtExClCnfgTable, prtInVc3Oos=prtInVc3Oos, moduleInitFailTrap=moduleInitFailTrap, linkSelectorPLinkTable=linkSelectorPLinkTable, sysCBuRecMode=sysCBuRecMode, radBridgeCODParamTable=radBridgeCODParamTable, prtSpCnfgIdx=prtSpCnfgIdx, ethIfCurrentOutMulticastFrames=ethIfCurrentOutMulticastFrames, prtDlciPrtIdx=prtDlciPrtIdx, prtIpParamMngVlanId=prtIpParamMngVlanId, agnCBuMlDefaultGateway=agnCBuMlDefaultGateway, ethIfSrcMacCtrlAddrIndex=ethIfSrcMacCtrlAddrIndex, agnSAlrState=agnSAlrState, prtExTsRxSignaling=prtExTsRxSignaling, prtT1E1FdlMsgTable=prtT1E1FdlMsgTable, agnVoiceSwConfHGdbIdx=agnVoiceSwConfHGdbIdx, dot3OamDescrLbRxOperation=dot3OamDescrLbRxOperation, prtBertTxErrorBits=prtBertTxErrorBits, alarmForwardingFailPort=alarmForwardingFailPort, prtDs3CurrentFEBE=prtDs3CurrentFEBE, prtIn1p6VcPbxCnfgEntry=prtIn1p6VcPbxCnfgEntry, prtT1E1VoiceOos=prtT1E1VoiceOos, prtInPh1MlDlciEntry=prtInPh1MlDlciEntry, systemVoiceTable=systemVoiceTable, atmConfVpLoopbackFailureInd=atmConfVpLoopbackFailureInd, prtHdslLinkType=prtHdslLinkType, prtGenTestStatus=prtGenTestStatus, prtExVcPbxTsCnfgIdx=prtExVcPbxTsCnfgIdx, agnCBuMlWaitToRestore=agnCBuMlWaitToRestore, atmLoopbackVcIvlCDV=atmLoopbackVcIvlCDV, wfqEntry=wfqEntry, prtIpParamVlanId=prtIpParamVlanId, ethIfCurrentOverflowOutBroadcastFrames=ethIfCurrentOverflowOutBroadcastFrames, dot3OamDescrEntry=dot3OamDescrEntry, agnCmprObj=agnCmprObj, agnVoiceSwConfRtDlci=agnVoiceSwConfRtDlci, dsx1TxClockSource=dsx1TxClockSource, mdlSAlarmStatusAll=mdlSAlarmStatusAll, prtDimMng=prtDimMng, wrLanIfTable=wrLanIfTable, agnCnfgDesc=agnCnfgDesc, prtCrStatisEntry=prtCrStatisEntry, srvDiscardYellowRedPackets=srvDiscardYellowRedPackets, atmVcCurrentRxCellsClp01=atmVcCurrentRxCellsClp01, systemVoiceNationalTone=systemVoiceNationalTone, atmVpPMIntervalErroredCells=atmVpPMIntervalErroredCells, radMepLtrReceiveOrder=radMepLtrReceiveOrder, ip2IfPortMask=ip2IfPortMask, atmVcPMIntervalQuality=atmVcPMIntervalQuality, radBridgePortVlanMemberVlanId=radBridgePortVlanMemberVlanId, ethIfCurrentInPauseFrames=ethIfCurrentInPauseFrames, qosFlowMappingToVlanId=qosFlowMappingToVlanId, radBridgeCurrentRxBcastFrames=radBridgeCurrentRxBcastFrames, radHtuT1Sa=radHtuT1Sa, prtExPh1MlTsSltIdx=prtExPh1MlTsSltIdx, qosFlowMappingToSrcMacAddr=qosFlowMappingToSrcMacAddr, atmAceAlarmPathFEBE=atmAceAlarmPathFEBE, prtGenAlrClearCmd=prtGenAlrClearCmd, atmThresholdErroredCells=atmThresholdErroredCells, prtInLs2PrtIdx=prtInLs2PrtIdx, alarmsTrap=alarmsTrap, evcCosRowStatus=evcCosRowStatus, sysSAlarmOnOff=sysSAlarmOnOff, dacsMux=dacsMux, atmVcPmBlockSize=atmVcPmBlockSize, sysRedundancyActiveCardTrap=sysRedundancyActiveCardTrap, prtExPh1MlMfClkSrcPrt=prtExPh1MlMfClkSrcPrt, prtExPh1MlInternalSwitch=prtExPh1MlInternalSwitch, radBridgeAgingTime=radBridgeAgingTime, radBridgeStpCnfgHelloTime=radBridgeStpCnfgHelloTime, prtAcmAlrString=prtAcmAlrString, gfpCnfgIdx=gfpCnfgIdx, prtSAlrSeverity=prtSAlrSeverity, prtExLs2SltIdx=prtExLs2SltIdx, prtSClearAlrCmd=prtSClearAlrCmd, radBridgeCODRemoteIPAddr=radBridgeCODRemoteIPAddr, dsx1DataStreamStatInErrors=dsx1DataStreamStatInErrors, prtExPhPlFrWindowSize=prtExPhPlFrWindowSize, agnClkSrcPortIdx=agnClkSrcPortIdx, prtMl4PppEchoFailDetection=prtMl4PppEchoFailDetection, mdlCWorkMode=mdlCWorkMode, ethIfCurrentOverflowOutOctets=ethIfCurrentOverflowOutOctets, mdlPbxFramerCnfgTable=mdlPbxFramerCnfgTable, alrBufEntry=alrBufEntry, prtExClEnabled=prtExClEnabled, atmAceStatusChange=atmAceStatusChange, qosFlowMappingFromVlanId=qosFlowMappingFromVlanId, dot1agXCfmMdTable=dot1agXCfmMdTable, agnVoiceSwConfRtDbId=agnVoiceSwConfRtDbId, agnDlciTxBe=agnDlciTxBe, radMX30=radMX30, prtExClRate=prtExClRate, radRici622GE=radRici622GE, atmAceAlarmVcMisinsertedCells=atmAceAlarmVcMisinsertedCells, prtCfgParamInbandLoopDeactPattern=prtCfgParamInbandLoopDeactPattern, radMepLocalMepId=radMepLocalMepId, atmVpIntervalRxCellsClp01=atmVpIntervalRxCellsClp01, ethIfCurrentOverflowInBroadcastFrames=ethIfCurrentOverflowInBroadcastFrames, prtExPVc4Tc=prtExPVc4Tc, prtDimTxMode=prtDimTxMode, radOp34E1=radOp34E1, radDot1qPortDefaultVlanPriority=radDot1qPortDefaultVlanPriority, prtSupervisoryDSR=prtSupervisoryDSR, mdlSAlrStatus=mdlSAlrStatus, prtInLs6LinkTo=prtInLs6LinkTo, systemPsTable=systemPsTable, ip2IfPortEntry=ip2IfPortEntry, systemDacsMux=systemDacsMux, dot1agXCfmMepContinuityVerMode=dot1agXCfmMepContinuityVerMode, radSysRtrEvents=radSysRtrEvents, prtIsdnDirectoryRemoteSubAddr2=prtIsdnDirectoryRemoteSubAddr2, radMX300=radMX300, alrBufCode=alrBufCode, prtInPh1MlCongLevel=prtInPh1MlCongLevel, mdlPbxFraSignalVector=mdlPbxFraSignalVector, prtExPhPlModemTimeBtwnCalls=prtExPhPlModemTimeBtwnCalls, prtExLs6CnfgEntry=prtExLs6CnfgEntry, agnClkSrcPortQuality=agnClkSrcPortQuality, ip2IfStatTable=ip2IfStatTable, ethOamSvcTotalMinRoundTripDelay=ethOamSvcTotalMinRoundTripDelay, prtMl4CnfgIdx=prtMl4CnfgIdx, prtExTrePrtIdx=prtExTrePrtIdx, prtHdslCompHwVer=prtHdslCompHwVer, radRBHE=radRBHE, radETX202H=radETX202H, agnListDecodingDefState=agnListDecodingDefState, agnSigProfCnfgIdx=agnSigProfCnfgIdx, prtExPh1MlRedundType=prtExPh1MlRedundType, prtExVc2SigService=prtExVc2SigService, wrDhcpHighIpAddress=wrDhcpHighIpAddress, radBridgeIPXRipTickMetric=radBridgeIPXRipTickMetric, ip2IfAdminStatus=ip2IfAdminStatus, agnVoiceSwConfNodeId=agnVoiceSwConfNodeId, atmVpPMCurrentUAS=atmVpPMCurrentUAS, prtInLs6RemoteType=prtInLs6RemoteType, agnCAgendaDayIdx=agnCAgendaDayIdx, systemVoice=systemVoice, ethIfStormIfIdx=ethIfStormIfIdx, sysSAlrMask=sysSAlrMask, atmVpPMCurrentTxClp01=atmVpPMCurrentTxClp01, agnCFlipLogicalExp=agnCFlipLogicalExp, prtExVcPbxTsSourceSlot=prtExVcPbxTsSourceSlot, atmVcIntervalRxAIS=atmVcIntervalRxAIS, atmAceAlarmLineBIP=atmAceAlarmLineBIP, prtExPVc4DlciIConSlt=prtExPVc4DlciIConSlt, sysSTestStatus=sysSTestStatus, sysDbaseFlipTable=sysDbaseFlipTable, atmVpPMIntervalRxClp01=atmVpPMIntervalRxClp01, agnCT1E1RingPrimeSlot=agnCT1E1RingPrimeSlot, wrLanifIndex=wrLanifIndex, atmConfVpCreationTime=atmConfVpCreationTime, ethIfSrcMacCtrlAging=ethIfSrcMacCtrlAging, atmNteLevel=atmNteLevel, prtMl4CGA=prtMl4CGA, ds1SignalLossTrap=ds1SignalLossTrap, prtExHs4LineType=prtExHs4LineType, ethOamSvcCurrElapsedTime=ethOamSvcCurrElapsedTime, ip2IfTDMFrameBytes=ip2IfTDMFrameBytes, agnCNetGoCmd=agnCNetGoCmd, agnDlciRxBc=agnDlciRxBc, ethIfIntervalInPauseFrames=ethIfIntervalInPauseFrames, optPrtCnfgPrtIdx=optPrtCnfgPrtIdx, portTypicalMaxRange=portTypicalMaxRange)
mibBuilder.exportSymbols("RAD-MIB", sysCRdnSecPort=sysCRdnSecPort, prtSpWaitForConnect=prtSpWaitForConnect, systemOamTable=systemOamTable, atmThresholdMisinsertedCells=atmThresholdMisinsertedCells, trapVal=trapVal, portBalance=portBalance, ethOamServiceUnavailSec=ethOamServiceUnavailSec, prtCrRxTotalCells=prtCrRxTotalCells, gfpCnfgEntry=gfpCnfgEntry, prtParamLeds=prtParamLeds, dsx1XTotalEntry=dsx1XTotalEntry, prtInPh1MlDlciRxBe=prtInPh1MlDlciRxBe, prtExPVc4Connect=prtExPVc4Connect, radAce3402PSN=radAce3402PSN, prtExPVc4HuntGroupMb=prtExPVc4HuntGroupMb, qosFlowMappingToDestIpAddr=qosFlowMappingToDestIpAddr, lagStatActivePort=lagStatActivePort, atmVcIntervalVpi=atmVcIntervalVpi, agnSshAccess=agnSshAccess, dhcpPoolAllocLeasingIpAddress=dhcpPoolAllocLeasingIpAddress, atmVcIntervalContinuityLoss=atmVcIntervalContinuityLoss, radMP2200F=radMP2200F, xcInputPriority=xcInputPriority, maskingLowLevelProtCondition=maskingLowLevelProtCondition, prtHSBertEntry=prtHSBertEntry, prtExVcPbxConnect=prtExVcPbxConnect, prtInLs2CnfgTable=prtInLs2CnfgTable, ethIfIntervalInUnicastFrames=ethIfIntervalInUnicastFrames, srvDiscardYellowRedBytesOverflow=srvDiscardYellowRedBytesOverflow, atmAlarmForwardingTimeFilterWindow=atmAlarmForwardingTimeFilterWindow, systemNtp=systemNtp, radMBE1=radMBE1, prtInPh1MlDlciTxBc=prtInPh1MlDlciTxBc, atmIfIntervalNumber=atmIfIntervalNumber, radLA210=radLA210, dsx1IntervalStatus=dsx1IntervalStatus, ip2IfExitChannel=ip2IfExitChannel, ip2IfCurrentStatSeqErrors=ip2IfCurrentStatSeqErrors, radSPS2=radSPS2, prtCnfgAgenda=prtCnfgAgenda, mdlSAlrCode=mdlSAlrCode, prtExLs6VEchoCanceler=prtExLs6VEchoCanceler, agnXCmprObj=agnXCmprObj, prtExPh1MlIdleCode=prtExPh1MlIdleCode, prtSupervisoryCTS=prtSupervisoryCTS, ethIfCurrentOverflowInOctets=ethIfCurrentOverflowInOctets, dhcpPoolAllocTimeLeft=dhcpPoolAllocTimeLeft, prtSpCnfgTable=prtSpCnfgTable, qosFlowMappingFromSrcMacAddr=qosFlowMappingFromSrcMacAddr, radRici16=radRici16, ip2IfUdpMuxMethod=ip2IfUdpMuxMethod, radStkHub=radStkHub, dot3OamDescrRowStatus=dot3OamDescrRowStatus, chassTotalNoOfMlSlt=chassTotalNoOfMlSlt, alrGenEntry=alrGenEntry, prtGenTestDurationTable=prtGenTestDurationTable, radAsmi450R768Sa=radAsmi450R768Sa, prtExPVc4FaxRate=prtExPVc4FaxRate, SysIfEntityType=SysIfEntityType, agnSyslogSeverityLevel=agnSyslogSeverityLevel, radBridgeCurrentTxCorrectBytesHCOverflow=radBridgeCurrentTxCorrectBytesHCOverflow, sysSaSwchStatus=sysSaSwchStatus, prtVc3Cnfg=prtVc3Cnfg, prtIpParamDefInterface=prtIpParamDefInterface, atmLoopbackVpIvlOperStatus=atmLoopbackVpIvlOperStatus, agnCAgendaDayCategory=agnCAgendaDayCategory, prtExHsiCnfgIdx=prtExHsiCnfgIdx, radIpMux1E=radIpMux1E, agnSClearAlrCmd=agnSClearAlrCmd, cnfgUpdateTrap=cnfgUpdateTrap, flowMappingProfileMapIndex=flowMappingProfileMapIndex, ethIfCurrentSingleCollisionFrames=ethIfCurrentSingleCollisionFrames, prtPhyIntervalEntry=prtPhyIntervalEntry, agnWebAccess=agnWebAccess, radMP2100B=radMP2100B, agnVoiceSwConfRtPriority=agnVoiceSwConfRtPriority, statusChangedTrap=statusChangedTrap, atmAceAlarmLineRDI=atmAceAlarmLineRDI, prtT3E3PrtIdx=prtT3E3PrtIdx, physicalConnectorEntry=physicalConnectorEntry, atmVcPMCurrentDir=atmVcPMCurrentDir, prtGenCnfgBusConnection=prtGenCnfgBusConnection, prtDs3IntervalPlcpBIP=prtDs3IntervalPlcpBIP, radSAHTM=radSAHTM, prtDimPolarity=prtDimPolarity, prtExPhPlSltIdx=prtExPhPlSltIdx, atmAceAlarmPathRDI=atmAceAlarmPathRDI, prtGenCnfgProtectionMode=prtGenCnfgProtectionMode, wrSyncClkRate=wrSyncClkRate, ip2IfMacAddr=ip2IfMacAddr, prtHSFifoSize=prtHSFifoSize, atmVpPMQoSPeriodRef=atmVpPMQoSPeriodRef, prtTestIdx=prtTestIdx, prtClkSrcPrtIdx=prtClkSrcPrtIdx, prtExPh1MlTsSubChType=prtExPh1MlTsSubChType, prtDs3CurrentES=prtDs3CurrentES, atmVpPMIntervalSECB=atmVpPMIntervalSECB, prtExPhPlDlciIConPrt=prtExPhPlDlciIConPrt, atmNteTotalOutputRate=atmNteTotalOutputRate, swdlStatusTime=swdlStatusTime, radAce3200=radAce3200, radDot1qPortVlanEntry=radDot1qPortVlanEntry, atmAceAlarmVpGCRAViolation=atmAceAlarmVpGCRAViolation, atmNteTotalInputRate=atmNteTotalInputRate, ip2IfMaxVBDModemCalls=ip2IfMaxVBDModemCalls, prtAgendaBehaviourOnOff=prtAgendaBehaviourOnOff, prtInPh1MlDlciSltIdx=prtInPh1MlDlciSltIdx, ethOamServiceTable=ethOamServiceTable, prtInLs6Rate=prtInLs6Rate, radAce52L=radAce52L, optPrtMonitorTxPower=optPrtMonitorTxPower, atmAceModuleMismatchTrap=atmAceModuleMismatchTrap, atmNteMdlPrtCpuSharing=atmNteMdlPrtCpuSharing, agnVoiceSwConfHGExt=agnVoiceSwConfHGExt, ip2IfStatHdlcErroredFrames=ip2IfStatHdlcErroredFrames, radBridgeIPXSapInfIfIndex=radBridgeIPXSapInfIfIndex, radBridgePortBaseVlanEntry=radBridgePortBaseVlanEntry, prtSpAltNumMode=prtSpAltNumMode, agnVoiceSwConfHGConnect=agnVoiceSwConfHGConnect, prtMbeCnfg=prtMbeCnfg, radMP2100VoIP=radMP2100VoIP, ethMode=ethMode, ethIfIntervalOverflowInDiscardFrames=ethIfIntervalOverflowInDiscardFrames, radSysStkHub=radSysStkHub, prtInPh1MlPrtIdx=prtInPh1MlPrtIdx, ripSapIfConfIfIndex=ripSapIfConfIfIndex, prtSAlarmMask=prtSAlarmMask, sysCRdnWTR=sysCRdnWTR, mdlSEntry=mdlSEntry, prtT1E1PppEchoFailDetection=prtT1E1PppEchoFailDetection, atmVcCurrentSCR=atmVcCurrentSCR, radBridgeCurrentRxCorrectBytes=radBridgeCurrentRxCorrectBytes, prtHSRtsState=prtHSRtsState, dsx1EchoCancelerModule=dsx1EchoCancelerModule, atmVcIntervalShaperTotalDiscards=atmVcIntervalShaperTotalDiscards, atmConfAlarmForwarding=atmConfAlarmForwarding, agnGroupCnfgIdx=agnGroupCnfgIdx, radETX201A=radETX201A, agnSMaskedAlrStat=agnSMaskedAlrStat, radAtmCsuDsu=radAtmCsuDsu, agnDlciRxBe=agnDlciRxBe, radFcdT1L=radFcdT1L, intSwdlSize=intSwdlSize, systemReset=systemReset, dsx1IntervalLOCRCMF=dsx1IntervalLOCRCMF, prtCrTxDataCells=prtCrTxDataCells, radBridgeIPXRipTblBcastTrigUpdateInterval=radBridgeIPXRipTblBcastTrigUpdateInterval, radBridgeGenCfgIdx2=radBridgeGenCfgIdx2, mdlDacsMux=mdlDacsMux, atmNteMdlConfig=atmNteMdlConfig, prtIsdnEndpointRowStatus=prtIsdnEndpointRowStatus, mapLinkIdx=mapLinkIdx, ip2IfVlanTagging=ip2IfVlanTagging, agnSyslog=agnSyslog, dsx1IntervalLOC=dsx1IntervalLOC, agnCFlipNetEventNo=agnCFlipNetEventNo, prtInPh1MlDlciIdx=prtInPh1MlDlciIdx, wrDhcpTable=wrDhcpTable, agnSTstStatAll=agnSTstStatAll, radBridgeGenCfgTable=radBridgeGenCfgTable, ip2IfMfcSpoofing=ip2IfMfcSpoofing, prtT1E1StatTable=prtT1E1StatTable, atmNteVcAlarmVpi=atmNteVcAlarmVpi, radMepTransmitLbmMassages=radMepTransmitLbmMassages, mdlGen=mdlGen, atmAceAlarmVpUAS=atmAceAlarmVpUAS, cmprTypeIdx=cmprTypeIdx, qProfileIndex=qProfileIndex, atmNteDefaultVci=atmNteDefaultVci, prtGenTestIdx=prtGenTestIdx, agnCDeleteCnfgIdxCmd=agnCDeleteCnfgIdxCmd, prtExHsrParity=prtExHsrParity, radFcd155E=radFcd155E, radFcdE1=radFcdE1, ip2IfEchoCanceler=ip2IfEchoCanceler, radVmux2100=radVmux2100, radOp25=radOp25, agnCnfgAlrStartReportOn=agnCnfgAlrStartReportOn, ip2IfStatPsnReorderFrames=ip2IfStatPsnReorderFrames, ip2IfCallerIDType=ip2IfCallerIDType, agnCFlipTable=agnCFlipTable, ip2IfConnCheckPktFrequency=ip2IfConnCheckPktFrequency, fileTransferServerPort=fileTransferServerPort, prtCnfgAgendaEntry=prtCnfgAgendaEntry, prtExVc2EandMType=prtExVc2EandMType, alarmForwardingTable=alarmForwardingTable, optPrtCnfgEntry=optPrtCnfgEntry, atmIfTxCells=atmIfTxCells, linkSelectorPLinkEntry=linkSelectorPLinkEntry, sysSaSwRevision=sysSaSwRevision, qosFlowMappingFromDscp=qosFlowMappingFromDscp, intSwdlTable=intSwdlTable, mdlProtIpCnfgIdx=mdlProtIpCnfgIdx, atmNteConfOamIfAisRdi=atmNteConfOamIfAisRdi, radSysPS=radSysPS, prtLanWanCnfg=prtLanWanCnfg, radFcdE1M=radFcdE1M, sysDclCopyDbCmd=sysDclCopyDbCmd, swdlStatusResult=swdlStatusResult, mdlCmprSltIdx=mdlCmprSltIdx, atmVpCurrentGcra1Violations=atmVpCurrentGcra1Violations, srvDiscardYellowPacketsOverflow=srvDiscardYellowPacketsOverflow, radBridgeCODisConnectDelay=radBridgeCODisConnectDelay, dsx1BundleNextIndex=dsx1BundleNextIndex, wrGratuitousArp=wrGratuitousArp, radFcdSTM=radFcdSTM, atmNteSys=atmNteSys, wrSpoofingAction=wrSpoofingAction, mdlSAlrMask=mdlSAlrMask, agnSigProfTable=agnSigProfTable, sysCClkSrcIdx=sysCClkSrcIdx, agnDlciRowStatus=agnDlciRowStatus, prtExTsIConPrt=prtExTsIConPrt, wrIpAddress=wrIpAddress, cmprObj=cmprObj, ip2IfMaxRelayModemCalls=ip2IfMaxRelayModemCalls, ip2IfCurrentStatMinJittBufLevel=ip2IfCurrentStatMinJittBufLevel, radMepLtrTable=radMepLtrTable, atmVcIntervalTxAIS=atmVcIntervalTxAIS, ip2IfStatHdlcCrcErr=ip2IfStatHdlcCrcErr, prtMonitoredTSs=prtMonitoredTSs, prtDimCnfgIdx=prtDimCnfgIdx, dsx3XConfigEntry=dsx3XConfigEntry, qosFlowMappingToUdpSrcPort=qosFlowMappingToUdpSrcPort, prtGenCnfgIdx=prtGenCnfgIdx, prtCrTimeElapsed=prtCrTimeElapsed, radBridgeIPXRipAgingTime=radBridgeIPXRipAgingTime, atmVpPMIntervalLostCells=atmVpPMIntervalLostCells, radLrs22=radLrs22, radLA130=radLA130, bitMappingView=bitMappingView, sysDclChFailThreshold=sysDclChFailThreshold, atmGenSysSelfTestIndex=atmGenSysSelfTestIndex, prtDlciCmprSltIdx=prtDlciCmprSltIdx, radOpXLT1=radOpXLT1, agnCBuMlType=agnCBuMlType, prtIsdnCallBackTimeout=prtIsdnCallBackTimeout, prtCrStatisTable=prtCrStatisTable, flowMappingProfileEntry=flowMappingProfileEntry, modlParamType=modlParamType, ip2IfDtdErlRatioCutoffQ3=ip2IfDtdErlRatioCutoffQ3, atmNteHostIP=atmNteHostIP, atmVcPMCurrentRxClp01=atmVcPMCurrentRxClp01, agnCFlipNetEventEndTime=agnCFlipNetEventEndTime, prtQosEntry=prtQosEntry, prtHSBertTestResult=prtHSBertTestResult, prtSAlrInvert=prtSAlrInvert, atmNteCardType=atmNteCardType, prtAlarmsCmprTable=prtAlarmsCmprTable, atmVcPmIfIndex=atmVcPmIfIndex, atmNteMdlSlotIndex=atmNteMdlSlotIndex, radTRERAS=radTRERAS, prtExVcPbxTransparent=prtExVcPbxTransparent, atmAceAlarmVcContinuityLoss=atmAceAlarmVcContinuityLoss)
mibBuilder.exportSymbols("RAD-MIB", systemOamLinkCheck=systemOamLinkCheck, agnTsCmprVerIdx=agnTsCmprVerIdx, prtExPh1MlCnfgIdx=prtExPh1MlCnfgIdx, radMepLtrEgress=radMepLtrEgress, prtLogicalCnfgIdx=prtLogicalCnfgIdx, prtIsdnCallMode=prtIsdnCallMode, radDxc4=radDxc4, atmAceAlarmVcUAS=atmAceAlarmVcUAS, prtExPhPlParity=prtExPhPlParity, ifTeQosIdx1=ifTeQosIdx1, atmNteOamTable=atmNteOamTable, prtExPh1MlTsExt=prtExPh1MlTsExt, swdlStatusTable=swdlStatusTable, agnCnfgAlrFilterSet=agnCnfgAlrFilterSet, prtIn7p8VcPbxCnfgEntry=prtIn7p8VcPbxCnfgEntry, radOptimuxXLT1=radOptimuxXLT1, radETX105=radETX105, wfq=wfq, mdlCSlotIdx=mdlCSlotIdx, prtIpParamConnect=prtIpParamConnect, ethIfCurrentOverflowMultipleCollisionFrames=ethIfCurrentOverflowMultipleCollisionFrames, ds1ExcessiveErrorRatioTrap=ds1ExcessiveErrorRatioTrap, prtExPVc4DlciTable=prtExPVc4DlciTable, atmAceAlarmVpErroredCells=atmAceAlarmVpErroredCells, atmVcPMQoSPeriodRef=atmVcPMQoSPeriodRef, xcOperStatus=xcOperStatus, mdlPbxFraSltIdx=mdlPbxFraSltIdx, ethLineOam=ethLineOam, prtPriorityIdx=prtPriorityIdx, sysSRdnFlipIdx=sysSRdnFlipIdx, ethIfIntervalOutBroadcastFrames=ethIfIntervalOutBroadcastFrames, systemVoiceEchoCanceler=systemVoiceEchoCanceler, atmThresholdLineFEBE=atmThresholdLineFEBE, radIpMux116=radIpMux116, failedLogin=failedLogin, dot1agXCfmMepDbEntry=dot1agXCfmMepDbEntry, prtCrStatis=prtCrStatis, radBridgeStpCnfgIdx1=radBridgeStpCnfgIdx1, prtExLs2CnfgEntry=prtExLs2CnfgEntry, radFcdIpD=radFcdIpD, prtGenTestPrtIdx=prtGenTestPrtIdx, ethIfCurrentTable=ethIfCurrentTable, ethIfIntervalOverflowInOctets=ethIfIntervalOverflowInOctets, sysDbaseDownloadCnfgIdxCmd=sysDbaseDownloadCnfgIdxCmd, radETX205=radETX205, radFcdE1I=radFcdE1I, prtSExHsfRts=prtSExHsfRts, atmNteSysInfo=atmNteSysInfo, prtIsdnEndpointTable=prtIsdnEndpointTable, prtDlciTxBecn=prtDlciTxBecn, dsx1IntervalRAI=dsx1IntervalRAI, prtExHsrLinkTo=prtExHsrLinkTo, atmVpPMIntervalSES=atmVpPMIntervalSES, radBridgeCurrentIngressFilteringDiscardedFrames=radBridgeCurrentIngressFilteringDiscardedFrames, prtExTsTxSignaling=prtExTsTxSignaling, sysSAlarmCounter=sysSAlarmCounter, intSwdlFileName=intSwdlFileName, atmLoopbackVpIvlVpi=atmLoopbackVpIvlVpi, prtExPVc4OutPulsing=prtExPVc4OutPulsing, sysCnfgIdx=sysCnfgIdx, systemOamDescrEntry=systemOamDescrEntry, prtExPVc4SeizeAck=prtExPVc4SeizeAck, atmVcCurrentVci=atmVcCurrentVci, ds1ExcessiveLocalMfAlarmTrap=ds1ExcessiveLocalMfAlarmTrap, radMBE1D=radMBE1D, dhcpPoolAllocFreeCmd=dhcpPoolAllocFreeCmd, ip2IfVlanSupport=ip2IfVlanSupport, ifTeQos=ifTeQos, radRRMLBTF=radRRMLBTF, agnVoiceSwConfRtDigits=agnVoiceSwConfRtDigits, atmVpCurrentTotalDiscards=atmVpCurrentTotalDiscards, prtSpCmd=prtSpCmd, radDot1qPortVlanCnodeLevel1Agent=radDot1qPortVlanCnodeLevel1Agent, prtSpCTS=prtSpCTS, ethOamServiceTxFrames=ethOamServiceTxFrames, sysDclFlipUponStnClk=sysDclFlipUponStnClk, agnClkIntervalEntry=agnClkIntervalEntry, qosFlowMappingFromInnerVlanId=qosFlowMappingFromInnerVlanId, prtLanWanEgressVlanMode=prtLanWanEgressVlanMode, agnXCmprIdx7=agnXCmprIdx7, prtSpAltNum=prtSpAltNum, prtSpAlrRelayMode=prtSpAlrRelayMode, sysCRdnSecSlot=sysCRdnSecSlot, prtTestVctTxResult=prtTestVctTxResult, ip2IfVlanIdentifier=ip2IfVlanIdentifier, ip2IfVbdRate=ip2IfVbdRate, ip2IfTDMoIpMode=ip2IfTDMoIpMode, prtSAlarmEntry=prtSAlarmEntry, ethIfCurrentOverflowFCSErrors=ethIfCurrentOverflowFCSErrors, prtPhMlSltIdx=prtPhMlSltIdx, agnVoiceSwConfHGExtString=agnVoiceSwConfHGExtString, prtLanWanL2Protocol=prtLanWanL2Protocol, radRADring=radRADring, atmNteCardCmd=atmNteCardCmd, prtExVcPbxTsMode=prtExVcPbxTsMode, prtExVc2ReceiveGain=prtExVc2ReceiveGain, atmIfIntervalEntry=atmIfIntervalEntry, qosFlowMappingTos=qosFlowMappingTos, atmAceSystemTrap=atmAceSystemTrap, ethOamSvcCurrentStatEntry=ethOamSvcCurrentStatEntry, prtCnfgAgendaTo=prtCnfgAgendaTo, radBridgeStpCnfgMaxAge=radBridgeStpCnfgMaxAge, prtExPVc4PrtIdx=prtExPVc4PrtIdx, agnTestStatus=agnTestStatus, atmVcCurrentMCR=atmVcCurrentMCR, atmLoopbackVpTable=atmLoopbackVpTable, sysCRdnPrimeSlot=sysCRdnPrimeSlot, prtDlciTxBeViol=prtDlciTxBeViol, prtExHsiSltIdx=prtExHsiSltIdx, atmNteOamCellType=atmNteOamCellType, sysSRdnEnforcedChannel=sysSRdnEnforcedChannel, prtExTsBit=prtExTsBit, prtDs3IntervalPlcpRAI=prtDs3IntervalPlcpRAI, ethIfIntervalInOctets=ethIfIntervalInOctets, atmGenSysLogEntry=atmGenSysLogEntry, dhcpRelayTable=dhcpRelayTable, prtT1E1DedicatedTs=prtT1E1DedicatedTs, mngID=mngID, hostTable=hostTable, radBridgeIPXRipValueStatus=radBridgeIPXRipValueStatus, ip2IfStatPsnTxFrames=ip2IfStatPsnTxFrames, prtExVcPbxTransSignalTs=prtExVcPbxTransSignalTs, prtQosRateLimitCBS=prtQosRateLimitCBS, prtT1E1BpvLastMin=prtT1E1BpvLastMin, dsx3MappingTable=dsx3MappingTable, atmSysNetPrtInUse=atmSysNetPrtInUse, qosFlowMappingToIpPrecedence=qosFlowMappingToIpPrecedence, atmNteVcActiveAlarms=atmNteVcActiveAlarms, atmLoopbackVcIvlEntry=atmLoopbackVcIvlEntry, prtBertRxBits=prtBertRxBits, prtLanWanCnfgTable=prtLanWanCnfgTable, agnCQ50DiscardPktThresh=agnCQ50DiscardPktThresh, prtExPVc4PortConnection=prtExPVc4PortConnection, radSPH=radSPH, prtExMbeCnfgIdx=prtExMbeCnfgIdx, atmIfRxCells=atmIfRxCells, radFTBSAS=radFTBSAS, atmNtePlugAndPlayIfIndex=atmNtePlugAndPlayIfIndex, mdlCPrgEntry=mdlCPrgEntry, atmSysIntervalNumber=atmSysIntervalNumber, radBridgeGenFlowSchedulingMode=radBridgeGenFlowSchedulingMode, sysCBuPrimaryPort=sysCBuPrimaryPort, mapLinkState=mapLinkState, atmNteMdlConfigEntry=atmNteMdlConfigEntry, agnCurrClkMode=agnCurrClkMode, radBridgeIPXSapTblNoOfEntries=radBridgeIPXSapTblNoOfEntries, prtDs3IfEntry=prtDs3IfEntry, ip2IfStatHdlcAbort=ip2IfStatHdlcAbort, mdlAlarmMask=mdlAlarmMask, radTokenRing=radTokenRing, prtExTreLanRate=prtExTreLanRate, dscpMappingCnfgIdx=dscpMappingCnfgIdx, prtBdbandIndEvent=prtBdbandIndEvent, atmConfVpPolicing=atmConfVpPolicing, atmNteManagerVci=atmNteManagerVci, radVmux405=radVmux405, linkSelectorCnfgIdx=linkSelectorCnfgIdx, agnVoiceSwConfHGStatus=agnVoiceSwConfHGStatus, radImx2=radImx2, intSwdlFileSwVer=intSwdlFileSwVer, prtCmprSltIdx=prtCmprSltIdx, ip2IfBandWidth=ip2IfBandWidth, ethIfRingOperStatus=ethIfRingOperStatus, fileTransCmd=fileTransCmd, sysSaHwVersion=sysSaHwVersion, radSysTR=radSysTR, ethIfStormEntry=ethIfStormEntry, systemVoiceCoderCoderAndRate=systemVoiceCoderCoderAndRate, atmVcIntervalUAS=atmVcIntervalUAS, atmNteHostMask=atmNteHostMask, alrGenDefSeverity=alrGenDefSeverity, srvDiscardYellowPackets=srvDiscardYellowPackets, prtInVc3LinkTo=prtInVc3LinkTo, radLA240I=radLA240I, prtParamEntry=prtParamEntry, prtFrStatisInvIdx=prtFrStatisInvIdx, prtQosRateLimitEBS=prtQosRateLimitEBS, radImx6L=radImx6L, Dscp=Dscp, agnSyslogFacility=agnSyslogFacility, ds1ExcessiveCrc4ErrorTrap=ds1ExcessiveCrc4ErrorTrap, hostMode=hostMode, prtIsdnDirectoryPrtIdx=prtIsdnDirectoryPrtIdx, atmVcPMQoSCLR=atmVcPMQoSCLR, prtPhyTimeElapsed=prtPhyTimeElapsed, radSTC2UDP=radSTC2UDP, agnSwVersionSwapCmd=agnSwVersionSwapCmd, prtExLs2PrtIdx=prtExLs2PrtIdx, atmNteGranularityFactor=atmNteGranularityFactor, radFPS8=radFPS8, radSAHEMU=radSAHEMU, radBridgeCurrentTxCorrectBytes=radBridgeCurrentTxCorrectBytes, atmVpPMIntervalLastDayQuality=atmVpPMIntervalLastDayQuality, prtT1E1CGA=prtT1E1CGA, agnStringToIndexEntry=agnStringToIndexEntry, atmThresholdSectionBIP=atmThresholdSectionBIP, ifTeQosStatus=ifTeQosStatus, dsx1TsEchoCancel=dsx1TsEchoCancel, prtIsdnStatusTable=prtIsdnStatusTable, ethIfCurrentInDiscardFrames=ethIfCurrentInDiscardFrames, radSTC2=radSTC2, atmLoopbackVpMinDelay=atmLoopbackVpMinDelay, prtT1E1LinkMode=prtT1E1LinkMode, prtExPhPlCnfgTable=prtExPhPlCnfgTable, ethIfCurrentAlignmentErrors=ethIfCurrentAlignmentErrors, prtTestOamMaxRoundTripDelay=prtTestOamMaxRoundTripDelay, tftpStatusChangeTrap=tftpStatusChangeTrap, agnCBuMlOamTimeoutCycles=agnCBuMlOamTimeoutCycles, prtExPhPlDlciIConSlt=prtExPhPlDlciIConSlt, prtDs3CurrentOOF=prtDs3CurrentOOF, atmVcIntervalCDC=atmVcIntervalCDC, atmVcCurrentRxAIS=atmVcCurrentRxAIS, dsx1Scramble=dsx1Scramble, atmAlarmForwardingRowStatus=atmAlarmForwardingRowStatus, atmVpCurrentTxAIS=atmVpCurrentTxAIS, agnSErrIdx=agnSErrIdx, atmVcPMIntervalEntry=atmVcPMIntervalEntry, prtExVc2LinkTo=prtExVc2LinkTo, atmConfVpCongestionControl=atmConfVpCongestionControl, agnDlciCmprTable=agnDlciCmprTable, ethOamSvcIntervalAvgRoundTripDelay=ethOamSvcIntervalAvgRoundTripDelay, atmConfVpLoopbackSinkAddress=atmConfVpLoopbackSinkAddress, sysSRdnCmdEntry=sysSRdnCmdEntry, radDXC3000=radDXC3000, dhcpClientAction=dhcpClientAction, atmVcIntervalTotalCellOuts=atmVcIntervalTotalCellOuts, linkSelectorSltIdx=linkSelectorSltIdx, prtExTreCnfgEntry=prtExTreCnfgEntry, sysSEditCnfg=sysSEditCnfg, prtHSUnframed=prtHSUnframed, prtExVc2BusProtectionPoint=prtExVc2BusProtectionPoint, ethOamSvcCurrMinRoundTripDelay=ethOamSvcCurrMinRoundTripDelay, radETX208=radETX208, prtIpParamTrafficPriority=prtIpParamTrafficPriority, radDot1qPortVlanTable=radDot1qPortVlanTable, prtPhMlInterfaceType=prtPhMlInterfaceType, wrConfigIpDhcp=wrConfigIpDhcp, mapLinkSltIdx=mapLinkSltIdx, mdlSBackupSwVer=mdlSBackupSwVer, radFTC2=radFTC2, atmVpIntervalNumber=atmVpIntervalNumber, lagEntry=lagEntry, linkSelectorMinBUSession=linkSelectorMinBUSession, qProfileNumberOfInternalQ=qProfileNumberOfInternalQ, moduleFailTrap=moduleFailTrap, wrLanBridgeRouterMode=wrLanBridgeRouterMode, statMdlMux=statMdlMux, radEPR4TFL=radEPR4TFL, sysSErrListEntry=sysSErrListEntry, sysCRdnTxDownDurationUponFlip=sysCRdnTxDownDurationUponFlip, radHtu2=radHtu2, flowMappingProfileName=flowMappingProfileName, dot3OamEvents=dot3OamEvents, prtExPVc4ExtensionNumber=prtExPVc4ExtensionNumber)
mibBuilder.exportSymbols("RAD-MIB", radMepTransmitLbmDestMacAddress=radMepTransmitLbmDestMacAddress, radETX202AW=radETX202AW, atmConfIfCardType=atmConfIfCardType, radMepRemoteMepId=radMepRemoteMepId, atmSysNetPrts=atmSysNetPrts, radSysEth=radSysEth, prtExVc2SigFeedback=prtExVc2SigFeedback, agnClkSrcPortAdminStatus=agnClkSrcPortAdminStatus, radBridgePortCnfgEntry=radBridgePortCnfgEntry, atmNteVpActiveAlarms=atmNteVpActiveAlarms, radMdName=radMdName, agnCFlipNetEventISD=agnCFlipNetEventISD, prtExHsfBcastRingSrcPort=prtExHsfBcastRingSrcPort, radDXC8R=radDXC8R, atmNteHostVpi=atmNteHostVpi, atmVcPMQoSEntry=atmVcPMQoSEntry, agnVoiceSwitching=agnVoiceSwitching, ethOamSvcTotalFramesAboveDVarThresh=ethOamSvcTotalFramesAboveDVarThresh, prtE2Cnfg=prtE2Cnfg, radBridgeInvBasePortTable=radBridgeInvBasePortTable, atmVpPMCurrentLostCells=atmVpPMCurrentLostCells, prtExHsrPrtIdx=prtExHsrPrtIdx, radBridgeIntervalNumber=radBridgeIntervalNumber, xcEntry=xcEntry, agnCurrClkObjIdx=agnCurrClkObjIdx, prtSInstPrtIdx=prtSInstPrtIdx, autoFileTransferType=autoFileTransferType, radETX202=radETX202, radOptimuxT3L=radOptimuxT3L, prtExHsrRate=prtExHsrRate, atmAceAlarmLineFEBE=atmAceAlarmLineFEBE, prtDs3IntervalUAS=prtDs3IntervalUAS, prtCfgParamIdx=prtCfgParamIdx, prtIpParamVlanPriority=prtIpParamVlanPriority, ip2IfV23HD=ip2IfV23HD, swdlStatusFileName=swdlStatusFileName, agnSigProfileTable=agnSigProfileTable, prtExVc2RxBitOutput=prtExVc2RxBitOutput, prtExHsfInbandLoopback=prtExHsfInbandLoopback, prtExVcPbxTsSourcePrt=prtExVcPbxTsSourcePrt, prtLogicalCnfg=prtLogicalCnfg, atmSysCurrentCdc=atmSysCurrentCdc, ip2IfToneAckInterval=ip2IfToneAckInterval, radUNT20Fcd=radUNT20Fcd, wrFrCnfgEntry=wrFrCnfgEntry, prtPhMlBus=prtPhMlBus, trapNumeric=trapNumeric, atmVcPMCurrentVci=atmVcPMCurrentVci, radMBERASa=radMBERASa, agnCSaveFlipDbCmd=agnCSaveFlipDbCmd, prtExPh1MlTsCnfgIdx=prtExPh1MlTsCnfgIdx, ethIfStormDirection=ethIfStormDirection, mdlCInterfaces=mdlCInterfaces, agnXCmprIdx6=agnXCmprIdx6, radBridgeIPXSapInDiscards=radBridgeIPXSapInDiscards, atmVcPMCurrentRxClp0=atmVcPMCurrentRxClp0, prtHdsl=prtHdsl, prtGenTestRunningXP=prtGenTestRunningXP, mapLinkTable=mapLinkTable, agnSAlrCounter=agnSAlrCounter, agnAlarmsCmprEntry=agnAlarmsCmprEntry, swdlStatusSlot=swdlStatusSlot, prtT1E1Slt=prtT1E1Slt, prtControlCnfg=prtControlCnfg, prtExHsrRemoteModem=prtExHsrRemoteModem, radEPR4T2FL=radEPR4T2FL, agnSyslogDeviceUdpPort=agnSyslogDeviceUdpPort, atmVcCrossConnectExtenTable=atmVcCrossConnectExtenTable, prtPhyCurrentTable=prtPhyCurrentTable, prtIn7p8VcPbxOos=prtIn7p8VcPbxOos, mapLinkPortIdx=mapLinkPortIdx, ds1Crc4ErrorTrap=ds1Crc4ErrorTrap, prtT3E3AisFrame=prtT3E3AisFrame, agnFlipDb=agnFlipDb, mdlStatEntry=mdlStatEntry, prtGenTestMaskXP=prtGenTestMaskXP, radBridgeIPXSapStatus=radBridgeIPXSapStatus, agnDlciEntry=agnDlciEntry, radSPS3S=radSPS3S, prtSpDialMode=prtSpDialMode, dot3OamDescrId=dot3OamDescrId, prtMl4DedicatedTs=prtMl4DedicatedTs, mdlSSwVer=mdlSSwVer, qosFlowMappingToTcpSrcPort=qosFlowMappingToTcpSrcPort, prtIn7p8VcPbxRate=prtIn7p8VcPbxRate, dsx1SendUponFail=dsx1SendUponFail, dsx3MappingEntry=dsx3MappingEntry, ip2IfMaxGprsTxQueue=ip2IfMaxGprsTxQueue, prtPhyIntervalLOF=prtPhyIntervalLOF, prtDlciCmprTable=prtDlciCmprTable, prtExPVc4GenerateRingBack=prtExPVc4GenerateRingBack, prtLanWanPrtIdx=prtLanWanPrtIdx, ethIfCurrentDeferredTransmissions=ethIfCurrentDeferredTransmissions, systemNtpMode=systemNtpMode, mdlAlrMask=mdlAlrMask, ip2IfStatFrameTrackLongSerMiss=ip2IfStatFrameTrackLongSerMiss, atmGenSysCxRefCounter=atmGenSysCxRefCounter, prtExPVc4VarDelay=prtExPVc4VarDelay, agnSCmprErrListEntry=agnSCmprErrListEntry, dsx1CurrentLOF=dsx1CurrentLOF, prtDs3IntervalStatus=prtDs3IntervalStatus, atmVcIntervalGcra0Violations=atmVcIntervalGcra0Violations, ds1RemoteLoopTrap=ds1RemoteLoopTrap, sysSErrIdx=sysSErrIdx, srvForwardGreenBytes=srvForwardGreenBytes, prtMux=prtMux, agnXCmprVersion=agnXCmprVersion, prtExPVc4CnfgTable=prtExPVc4CnfgTable, radMepMeLevel=radMepMeLevel, radAPD8=radAPD8, atmVpPMCurrentTable=atmVpPMCurrentTable, cmprPrtIdx=cmprPrtIdx, atmInterfaceActiveAlarms=atmInterfaceActiveAlarms, atmGenSysSelfTestTable=atmGenSysSelfTestTable, atmIntervalDateTable=atmIntervalDateTable, mdlAlarmsCmprEntry=mdlAlarmsCmprEntry, radBridgeSplitHorizon=radBridgeSplitHorizon, agnCurrClkState=agnCurrClkState, agnRowPointerIndex=agnRowPointerIndex, modlParamReset=modlParamReset, radFcdIpL=radFcdIpL, prtInMbeLinkTo=prtInMbeLinkTo, ethIfMacLayer=ethIfMacLayer, systemsEvents=systemsEvents, atmLoopbackVpIfIndex=atmLoopbackVpIfIndex, agnVoiceSwConfTable=agnVoiceSwConfTable, prtExHs4CnfgIdx=prtExHs4CnfgIdx, prtIsdnDirectoryLocalSubAddr2=prtIsdnDirectoryLocalSubAddr2, mngEntry=mngEntry, dscpMapping=dscpMapping, radBridgeIPXSapInfTable=radBridgeIPXSapInfTable, radAmc102=radAmc102, agnWanGen=agnWanGen, intSwdlFileIdx=intSwdlFileIdx, prtPhPlCnfg=prtPhPlCnfg, prtExClParity=prtExClParity, prtExPh1MlTsIdx=prtExPh1MlTsIdx, dsx1AisEnable=dsx1AisEnable, atmVpPMIntervalEntry=atmVpPMIntervalEntry, prtPhyCurrentUAS=prtPhyCurrentUAS, radBridgeCODTimeTriggerEntry=radBridgeCODTimeTriggerEntry, radTRE1D=radTRE1D, prtInPh1MlCcittCrc=prtInPh1MlCcittCrc, ethIfIntervalInFrames=ethIfIntervalInFrames, atmVpPMCurrentEntry=atmVpPMCurrentEntry, atmNteManagerVlanSupport=atmNteManagerVlanSupport, prtSpPrimaryNum=prtSpPrimaryNum, atmLoopbackVcIvlMinDelay=atmLoopbackVcIvlMinDelay, xcVci=xcVci, radBridgePortCnfgEgressMtu=radBridgePortCnfgEgressMtu, hostParam3=hostParam3, prtGenCnfgSignalingType=prtGenCnfgSignalingType, sysSAlrStatus=sysSAlrStatus, prtSAlarmState=prtSAlarmState, radOpt4T1C=radOpt4T1C, prtExHsiActType=prtExHsiActType, ethIfPerfTable=ethIfPerfTable, srvDiscardGreenBytesOverflow=srvDiscardGreenBytesOverflow, atmVpPMIntervalMisinsertedCells=atmVpPMIntervalMisinsertedCells, ip2IfNextHopType=ip2IfNextHopType, sysCClkStationCableMode=sysCClkStationCableMode, agnCMainExitPort=agnCMainExitPort, hostDefaultNextHop=hostDefaultNextHop, sysBufferAlrTable=sysBufferAlrTable, prtExPhPlModemActivate=prtExPhPlModemActivate, radRTEC=radRTEC, atmIfCurrentUncorrectedHecs=atmIfCurrentUncorrectedHecs, prtSupervisoryUsage=prtSupervisoryUsage, mapLinkStatus=mapLinkStatus, atmNteTosMode=atmNteTosMode, radLA104=radLA104, radBridgePortBaseVlanVirtualGroups=radBridgePortBaseVlanVirtualGroups, atmVcPmVpi=atmVcPmVpi, wrDialInIpxNet=wrDialInIpxNet, radFcdT1A=radFcdT1A, flowMappingProfilePriority=flowMappingProfilePriority, prtQosRateLimitCIR=prtQosRateLimitCIR, prtDlciRxBcViol=prtDlciRxBcViol, radBridgePortCnfgMcastMode=radBridgePortCnfgMcastMode, agnVoiceSwConfEntry=agnVoiceSwConfEntry, ds1Interface=ds1Interface, agnClkSrcFrequencyAlarmTrap=agnClkSrcFrequencyAlarmTrap, agnVoiceSwConfHGUserParams=agnVoiceSwConfHGUserParams, prtIsdnDirectoryRemoteSubAddr=prtIsdnDirectoryRemoteSubAddr, prtDs3CurrentPlcpBIP=prtDs3CurrentPlcpBIP, radDXC30E=radDXC30E, mdlAlarmsCmprTable=mdlAlarmsCmprTable, wrInterface=wrInterface, radAPS16=radAPS16, prtBertSyncStatus=prtBertSyncStatus, qosFlowMappingFromUdpSrcPort=qosFlowMappingFromUdpSrcPort, atmVpCurrentMCR=atmVpCurrentMCR, prtMonEntry=prtMonEntry, prtInPh1MlMaxIdleTime=prtInPh1MlMaxIdleTime, radBridgeMaskOffset2=radBridgeMaskOffset2, prtInPh1MlDlciIConDlci=prtInPh1MlDlciIConDlci, atmVpPmBlockSize=atmVpPmBlockSize, prtPhMlCnfgEntry=prtPhMlCnfgEntry, cmprCnfgIdx=cmprCnfgIdx, lagWaitToRestore=lagWaitToRestore, prtDlciTxDeFrames=prtDlciTxDeFrames, prtFrTxMngFrames=prtFrTxMngFrames, prtLanWanDestIf=prtLanWanDestIf, ip2IfMplsTxExpBits=ip2IfMplsTxExpBits, radDot1qPortIngressTagHandling=radDot1qPortIngressTagHandling, prtMl4Cnfg=prtMl4Cnfg, prtInPh1MlEnqPeriod=prtInPh1MlEnqPeriod, atmLoopbackVpCDV=atmLoopbackVpCDV, prtExPVc4PrtType=prtExPVc4PrtType, mdlSAlrEntry=mdlSAlrEntry, prtExPh1MlTsTable=prtExPh1MlTsTable, atmVpPMCurrentRxClp01=atmVpPMCurrentRxClp01, prtGenSlt=prtGenSlt, qProfileRowStatus=qProfileRowStatus, ds1LocalSyncLossTrap=ds1LocalSyncLossTrap, agnSClearAllAlrCmd=agnSClearAllAlrCmd, prtExPVc4SrcIpMask=prtExPVc4SrcIpMask, prtExPhPlDlciStatus=prtExPhPlDlciStatus, prtDlciRxDcrdCongAllFr=prtDlciRxDcrdCongAllFr, prtExPVc4CoderAndRate=prtExPVc4CoderAndRate, ip2IfStatBufOverflows=ip2IfStatBufOverflows, srvDiscardRedBytesOverflow=srvDiscardRedBytesOverflow, xcRowStatus=xcRowStatus, flowMappingProfileRowStatus=flowMappingProfileRowStatus, atmVpCurrentSCR=atmVpCurrentSCR, radMP2200B=radMP2200B, prtDs3IntervalNumber=prtDs3IntervalNumber, ethIfRingEvents=ethIfRingEvents, radMP2104H=radMP2104H, linkSelectorRevert=linkSelectorRevert, ip2IfIntervalStatEntry=ip2IfIntervalStatEntry, radEFcdIp=radEFcdIp, prtParamClkSsmRxSource=prtParamClkSsmRxSource, prtDs3CurrentAIS=prtDs3CurrentAIS, ifCreateTable=ifCreateTable, atmVcIntervalSCR=atmVcIntervalSCR, atmNteManagerTrapMask=atmNteManagerTrapMask, radBridgeMaskPat2=radBridgeMaskPat2, prtT1E1Fdl=prtT1E1Fdl, prtGenTestCmd=prtGenTestCmd, agnSTimeCmd=agnSTimeCmd, prtExPhPlFrameSeparator=prtExPhPlFrameSeparator, trapTimeSinceOccurrence=trapTimeSinceOccurrence, cmprVersion=cmprVersion, dot3OamDescrMode=dot3OamDescrMode, prtSAlrCode=prtSAlrCode, dsx1CRC6CalcMode=dsx1CRC6CalcMode, atmVcCurrentPCR=atmVcCurrentPCR, sysSActiveCnfg=sysSActiveCnfg, agnStringToIndexTable=agnStringToIndexTable, ethOamSvcTotalFramesTxCounter=ethOamSvcTotalFramesTxCounter, radAce201=radAce201, prtIpParamEntry=prtIpParamEntry, prtExVc2Connect=prtExVc2Connect)
mibBuilder.exportSymbols("RAD-MIB", prtSpUsage=prtSpUsage, radHtuE1=radHtuE1, atmNteConfLoopbackSourceAdd=atmNteConfLoopbackSourceAdd, radEPR4TAUI=radEPR4TAUI, prtTestVctRxCrossPair=prtTestVctRxCrossPair, radBridgeCurrentIndex=radBridgeCurrentIndex, radBridgeMaskOffset3=radBridgeMaskOffset3, prtExPVc4DlciTxBe=prtExPVc4DlciTxBe, prtDlciIdx=prtDlciIdx, ds3Interface=ds3Interface, radPrbiE3=radPrbiE3, atmSysConfigCellTestQuantity=atmSysConfigCellTestQuantity, atmVpCurrentShaperClp0Discards=atmVpCurrentShaperClp0Discards, atmVpPMCurrentLastDayQuality=atmVpPMCurrentLastDayQuality, prtIpParamHostMask=prtIpParamHostMask, xcVpi=xcVpi, sysCRdnPrimePort=sysCRdnPrimePort, sysCRdnName=sysCRdnName, prtExHs4PrtIdx=prtExHs4PrtIdx, ethOamSvcCurrMaxRoundTripDelay=ethOamSvcCurrMaxRoundTripDelay, statAgnGen=statAgnGen, prtExPh1MlInbandMngRate=prtExPh1MlInbandMngRate, prtClkSrcEntry=prtClkSrcEntry, prtParamClearAlarm=prtParamClearAlarm, ethIfTable=ethIfTable, atmVpPmTable=atmVpPmTable, atmVpCurrentTxRDI=atmVpCurrentTxRDI, lagShutDownDurationUponFlip=lagShutDownDurationUponFlip, prtCfgParamInbandLoopActPattern=prtCfgParamInbandLoopActPattern, prtSAlrPrtIdx=prtSAlrPrtIdx, prtGenTestCmdXP=prtGenTestCmdXP, prtT1FdlMsg=prtT1FdlMsg, ethIfStorming=ethIfStorming, atmLoopbackVcIvlIfIndex=atmLoopbackVcIvlIfIndex, atmNteConfLoopbackAddMode=atmNteConfLoopbackAddMode, prtExPh1MlPrtIdx=prtExPh1MlPrtIdx, ethIfRingKeepAliveThresh=ethIfRingKeepAliveThresh, atmNteManagerEntry=atmNteManagerEntry, dsx1TcFirstSignal=dsx1TcFirstSignal, dsx1IntervalAIS=dsx1IntervalAIS, remoteConnStatusTrap=remoteConnStatusTrap, ethIfPerfOutOkFrames=ethIfPerfOutOkFrames, prtIpParamMediaMode=prtIpParamMediaMode, atmAceAlarmVcLoopback=atmAceAlarmVcLoopback, prtExPh1MlRedundPort=prtExPh1MlRedundPort, radRici8T1=radRici8T1, radFPS12=radFPS12, wrConfigIpDNS=wrConfigIpDNS, prtIsdnPrtIdx=prtIsdnPrtIdx, tftpRetryTimeOut=tftpRetryTimeOut, srvDiscardRedPacketsOverflow=srvDiscardRedPacketsOverflow, radSysFddi=radSysFddi, prtExMbeCnfgTable=prtExMbeCnfgTable, atmNteMdlInputPriorityMechanism=atmNteMdlInputPriorityMechanism, systemOamDescrIdx=systemOamDescrIdx, sysSaReadSwch=sysSaReadSwch, agnSEntryIdx=agnSEntryIdx, srvDiscardYellowBytesOverflow=srvDiscardYellowBytesOverflow, cnfgMdlMux=cnfgMdlMux, radAmcdE1=radAmcdE1, prtDlciRxDeFrames=prtDlciRxDeFrames, mdlClTable=mdlClTable, prtExLs6VCnfgIdx=prtExLs6VCnfgIdx, radMepContinuityVerMode=radMepContinuityVerMode, prtGenTsIConPrt=prtGenTsIConPrt, atmVcPMCurrentEntry=atmVcPMCurrentEntry, radAce2T=radAce2T, dsx1CurrentBPV=dsx1CurrentBPV, radBridgePortBaseVlanMng=radBridgePortBaseVlanMng, prtPhyIntervalTable=prtPhyIntervalTable, prtFrTxFecn=prtFrTxFecn, wrDhcpEntry=wrDhcpEntry, qInternalProfileWredStartDropThresh=qInternalProfileWredStartDropThresh, agnCQ50BlockNewModemVbdCallsThresh=agnCQ50BlockNewModemVbdCallsThresh, prtExVcPbxPrtIdx=prtExVcPbxPrtIdx, atmVpPMIntervalVpi=atmVpPMIntervalVpi, atmVpIntervalRxAIS=atmVpIntervalRxAIS, atmVcPMIntervalLostCells=atmVcPMIntervalLostCells, agnRadiusAccess=agnRadiusAccess, atmGen=atmGen, prtDs3IntervalAIS=prtDs3IntervalAIS, ethIfSrcMacCtrl=ethIfSrcMacCtrl, radFEB4SAS=radFEB4SAS, prtParamLoopDetect=prtParamLoopDetect, prtBdbandIndSigEnable=prtBdbandIndSigEnable, radRRFTBDAS=radRRFTBDAS, qosFlowMappingFromUdpDestPort=qosFlowMappingFromUdpDestPort, ip2IfOAMBundleIdent=ip2IfOAMBundleIdent, qosFlowMappingCriteria=qosFlowMappingCriteria, prtHdslMode=prtHdslMode, agnStringToIndexUserName=agnStringToIndexUserName, radIpMux4=radIpMux4, radRici155GE=radRici155GE, dsx1IntervalLOF=dsx1IntervalLOF, prtExVc2R2Delay=prtExVc2R2Delay, radAPD2=radAPD2, radMX3000=radMX3000, prtDs3IntervalSES=prtDs3IntervalSES, prtExPh1MlLineLen=prtExPh1MlLineLen, ds1ExcessiveRemoteSyncLossTrap=ds1ExcessiveRemoteSyncLossTrap, bitMappingIndex=bitMappingIndex, radBridgeIPXRipInfIfIndex=radBridgeIPXRipInfIfIndex, agnCT1E1RingRowStatus=agnCT1E1RingRowStatus, prtIsdnDirectoryEntry=prtIsdnDirectoryEntry, atmLoopbackVcOperStatus=atmLoopbackVcOperStatus, prtPhyCurrentSES=prtPhyCurrentSES, prtExPhPlModemCallDelay=prtExPhPlModemCallDelay, atmVpCurrentRxAIS=atmVpCurrentRxAIS, atmNteUPLTCR=atmNteUPLTCR, systemOamFrequency=systemOamFrequency, queueGroupQBlockProfile=queueGroupQBlockProfile, prtCrStatisSltIdx=prtCrStatisSltIdx, atmIfIntervalTable=atmIfIntervalTable, radFEC1UDP=radFEC1UDP, prtExPVc4DlciPriority=prtExPVc4DlciPriority, ip2IfIntervalStatTable=ip2IfIntervalStatTable, atmIfIntervalCorrectedHecs=atmIfIntervalCorrectedHecs, ethOamSvcIntervalMinRoundTripDelay=ethOamSvcIntervalMinRoundTripDelay, atmVpCurrentUAS=atmVpCurrentUAS, prtT1E1MaxTSs=prtT1E1MaxTSs, prtTestBwProfile=prtTestBwProfile, maskingProtocolType=maskingProtocolType, prtMl4CnfgTable=prtMl4CnfgTable, prtDs3TotalBPV=prtDs3TotalBPV, prtPhMlClockMode=prtPhMlClockMode, radBridgeCurrentEntry=radBridgeCurrentEntry, prtExPVc4CodingLaw=prtExPVc4CodingLaw, queueGroupRowStatus=queueGroupRowStatus, atmNteConfIfTable=atmNteConfIfTable, ip2IfCurrentStatMaxJittBufLevel=ip2IfCurrentStatMaxJittBufLevel, radMepCcStatus=radMepCcStatus, srvForwardGreenBytesOverflow=srvForwardGreenBytesOverflow, agnCnfgAlrCode=agnCnfgAlrCode, prtVcPbxCnfg=prtVcPbxCnfg, agnCAgendaTable=agnCAgendaTable, sysSRdnFlipEntry=sysSRdnFlipEntry, atmVpCurrentTable=atmVpCurrentTable, atmVpCurrentGcra0Violations=atmVpCurrentGcra0Violations, atmConfIfLoopback=atmConfIfLoopback, agnTsCmprEntry=agnTsCmprEntry, prtT3E3InbandMng=prtT3E3InbandMng, mdlSAlrClearAllCmd=mdlSAlrClearAllCmd, maskingCurrentEntries=maskingCurrentEntries, prtT1E1SignalMode=prtT1E1SignalMode, prtExVc3SltIdx=prtExVc3SltIdx, prtWanGen=prtWanGen, ip2IfOperStatus=ip2IfOperStatus, prtExPhPlJitter=prtExPhPlJitter, agnCFlipNetEventPort=agnCFlipNetEventPort, prtExPh1MlConnect=prtExPh1MlConnect, prtExPh1MlCnfgTable=prtExPh1MlCnfgTable, prtTestInitiator=prtTestInitiator, dsx1TcPattern=dsx1TcPattern, prtExLs2Rate=prtExLs2Rate, mdlSAlarmStatus=mdlSAlarmStatus, agnSAlrTable=agnSAlrTable, agnCnfgAlrEntry=agnCnfgAlrEntry, prtInLs2CnfgIdx=prtInLs2CnfgIdx, atmVcPMIntervalUAS=atmVcPMIntervalUAS)

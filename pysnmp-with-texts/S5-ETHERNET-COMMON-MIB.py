#
# PySNMP MIB module S5-ETHERNET-COMMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/S5-ETHERNET-COMMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:59:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
s5EnCfg, s5EnStat = mibBuilder.importSymbols("S5-ETHERNET-MIB", "s5EnCfg", "s5EnStat")
SrcIndx, TimeIntervalSec, AttId = mibBuilder.importSymbols("S5-TCS-MIB", "SrcIndx", "TimeIntervalSec", "AttId")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, iso, ModuleIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Gauge32, Unsigned32, MibIdentifier, NotificationType, IpAddress, Counter32, Bits, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "iso", "ModuleIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Gauge32", "Unsigned32", "MibIdentifier", "NotificationType", "IpAddress", "Counter32", "Bits", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
s5EthernetCommonMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 0))
s5EthernetCommonMib.setRevisions(('2004-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: s5EthernetCommonMib.setRevisionsDescriptions(('Version 118: Conversion to SMIv2',))
if mibBuilder.loadTexts: s5EthernetCommonMib.setLastUpdated('200407200000Z')
if mibBuilder.loadTexts: s5EthernetCommonMib.setOrganization('Nortel Networks')
if mibBuilder.loadTexts: s5EthernetCommonMib.setContactInfo('Nortel Networks')
if mibBuilder.loadTexts: s5EthernetCommonMib.setDescription("5000 Ethernet Common MIB Copyright 1993-2004 Nortel Networks, Inc. All rights reserved. This Nortel Networks SNMP Management Information Base Specification (Specification) embodies Nortel Networks' confidential and proprietary intellectual property. Nortel Networks retains all title and ownership in the Specification, including any revisions. This Specification is supplied 'AS IS,' and Nortel Networks makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
s5EnPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1), )
if mibBuilder.loadTexts: s5EnPortTable.setStatus('current')
if mibBuilder.loadTexts: s5EnPortTable.setDescription('A table containing information about each managed ethernet connectivity port on a board. The number of entries is determined by the number of managed ports. Those boards that do not have any ports do not have any entries in this table.')
s5EnPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1), ).setIndexNames((0, "S5-ETHERNET-COMMON-MIB", "s5EnPortBrdIndx"), (0, "S5-ETHERNET-COMMON-MIB", "s5EnPortIndx"))
if mibBuilder.loadTexts: s5EnPortEntry.setStatus('current')
if mibBuilder.loadTexts: s5EnPortEntry.setDescription('A row in Ethernet port table. Entries can not be created or deleted via SNMP.')
s5EnPortBrdIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortBrdIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnPortBrdIndx.setDescription('The index of the board. This corresponds to the index of the slot containing the board.')
s5EnPortIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnPortIndx.setDescription('The index of the port on the board. Its value ranges between 1 and index of the last manageable port on the board.')
s5EnPortPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("partition", 3), ("autoPartition", 4), ("timedPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s5EnPortPartStatus.setStatus('current')
if mibBuilder.loadTexts: s5EnPortPartStatus.setDescription('The partition status of the port. The following values can be written: enabled(2)..........enabled port partition(3)........partition port timedPartition(5)...time partition port (uses value from s5EnPortPartTime) The following values reflect the partition status of the port: other(1).............partition status unknown enabled(2)...........port enabled partition(3).........port partitioned autoPartition(4).....port auto-partitioned by hardware timedPartition(5)....port is timed partitioned (see value of s5EnPortPartTime). On GETs with port status of timedPartition(5), if the time remaining before the partition is undone is available, it will be reported in object s5EnPortPartTime as a positive value. If not available, the value of s5EnPortPartTime will be zero. When changing a port to timedPartition(5), the SET request must also contain the value for object s5EnPortPartTime. Only value partition(3) will survive resets of the host card.')
s5EnPortPartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 4), TimeIntervalSec()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s5EnPortPartTime.setStatus('current')
if mibBuilder.loadTexts: s5EnPortPartTime.setDescription('The length of time to keep the port partitioned when a timed partition is done to the port. This object can only be written in the same request that sets s5EnPortPartStatus to timedPartition(5). Afterwards, it indicates the amount of time left before the timed partition is completed, at which time s5EnPortPartStatus is changed to enabled(2). This object has the value of zero if the port is not time partitioned, or if the amount of time is not available.')
s5EnPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortLinkStatus.setStatus('current')
if mibBuilder.loadTexts: s5EnPortLinkStatus.setDescription('Tells whether the port is receiving link status. The values are: other(1)...returned for AUI off(2).....link is not connected on(3)......link is connected on/off applies to 10BASE-T and Fiber ports only.')
s5EnPortJabberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("jabbering", 2), ("ok", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortJabberStatus.setStatus('current')
if mibBuilder.loadTexts: s5EnPortJabberStatus.setDescription('The jabber status of the DTE(s) connected to the port. The values are: other(1).......unknown or other condition jabbering(2)...port receiving jabber ok(3)..........no jabber detected.')
s5EnPortExtTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3), )
if mibBuilder.loadTexts: s5EnPortExtTable.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtTable.setDescription('An extension table to s5EnPortTable containing additional information about per port switchable, autonegotiating 10/100 Mbit ethernet connectivity ports on a board. The number of entries is determined by the number of managed ports. Those boards that do not have any ports do not have any entries in this table.')
s5EnPortExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1), ).setIndexNames((0, "S5-ETHERNET-COMMON-MIB", "s5EnPortExtBrdIndx"), (0, "S5-ETHERNET-COMMON-MIB", "s5EnPortExtIndx"))
if mibBuilder.loadTexts: s5EnPortExtEntry.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtEntry.setDescription('A row in Ethernet port extension table. Entries can not be created or deleted via SNMP.')
s5EnPortExtBrdIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtBrdIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtBrdIndx.setDescription('The index of the board. This corresponds to the index of the slot containing the board.')
s5EnPortExtIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtIndx.setDescription('The index of the port on the board. Its value ranges between 1 and index of the last manageable port on the board.')
s5EnPortExtHwCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtHwCapability.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtHwCapability.setDescription('A bit array that contains the bit map representing the hardware capabilites of the port. The bit 7 tells if the port supports auto-negotiation. If the auto negotiation is on, the port will have multiple speed capabilities while if the auto negotiation is not supported, the hardware will only be capable for one speed: bit 0 - 10 BASE-T half duplex capable bit 1 - 10 BASE-T full duplex capable bit 2 - 100 BASE-TX half duplex capable bit 3 - 100 BASE-TX full duplex capable bit 5 - 100 BASE-FX full duplex capable bit 6 - 100 BASE-FX half duplex capable bit 7 - auto negotiation support capability When auto negotiation is supported only bits 0-3 are used to indicate the capabilities available for negotiation, and any or all of these bits may be set as long as at least one bit is set. When auto negotiation is NOT supported (bit 7 = 0) all other bits are used to indicate the capabilities supported by the port, but which must be manually configured.')
s5EnPortExtAutoNegAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s5EnPortExtAutoNegAdv.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtAutoNegAdv.setDescription('A bit array that contains the bit map representing the abilities advertised during link negociation. The bit 7 tells if auto negotiation is enabled or disabled: bit 0 - 10 BASE-T half duplex capable bit 1 - 10 BASE-T full duplex capable bit 2 - 100 BASE-TX half duplex capable bit 3 - 100 BASE-TX full duplex capable bit 5 - 100 BASE-FX full duplex capable bit 6 - 100 BASE-FX half duplex capable bit 7 - auto negotiation is enabled or disabled Only capabilites present in the hardware as indicated by s5EnPortExtHwCapability can be advertised. If auto negotiation is enabled only bits 0-3 are used to indicate the capabilities available for negotiation. Any or all of these bits may be set as long as at least one bit is set, AND the settings are in accordance with s5EnPortExtHwCapability. If auto negotiation is disabled one and only one of the speed setting bits MUST be set in accordance with s5EnPortExtHwCapability.')
s5EnPortExtAutoNegRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtAutoNegRcvd.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtAutoNegRcvd.setDescription('A bit array that contains the bit map representing the auto-negotiation abilities of the remote end of the link: bit 0 - 10 BASE-T half duplex capable bit 1 - 10 BASE-T full duplex capable bit 2 - 100 BASE-TX half duplex capable bit 3 - 100 BASE-TX full duplex capable ')
s5EnPortExt10MbSegAttCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 6), AttId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s5EnPortExt10MbSegAttCfg.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExt10MbSegAttCfg.setDescription('The index for the segment used in case a 10 Mbit link is established.')
s5EnPortExt100MbSegAttCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 7), AttId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s5EnPortExt100MbSegAttCfg.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExt100MbSegAttCfg.setDescription('The index for the segment used in case a 100 Mbit link is established.')
s5EnPortExt10MbSegConnCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExt10MbSegConnCapability.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExt10MbSegConnCapability.setDescription('A bit array that contains the bit map representing all available 10Mbit backplane segment and local segment connections for the port. One bit is also reserved to indicate if the cluster has an isolate capability. The first 31 bits of the array represent the backplane numbers, starting from the lower order bit. Bit 32 indicates whether the port has a null connection capability. The bits in the fifth and sixth octets, starting with bits in the lower order octet, represent local segments that the port can connect to. A bit with a value of 1 means that the port is capable of connecting to the corresponding backplane segment, local segment or null segment.')
s5EnPortExt100MbSegConnCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExt100MbSegConnCapability.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExt100MbSegConnCapability.setDescription('A bit array that contains the bit map representing all available 100Mbit backplane segment and local segment connections for the port. One bit is also reserved to indicate if the cluster has an isolate capability. The first 31 bits of the array represent the backplane numbers, starting from the lower order bit. Bit 32 indicates whether the port has a null connection capability. The bits in the fifth and sixth octets, starting with bits in the lower order octet, represent local segments that the port can connect to. A bit with a value of 1 means that the port is capable of connecting to the corresponding backplane segment, local segment or null segment.')
s5EnPortExtActiveSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("bps10M", 2), ("bps100M", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtActiveSpeed.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtActiveSpeed.setDescription('The speed of the link. The possible values are: unknown(1)........unknown, no link bps10M(2).........10 Mbit link bps100M(3)........100 Mbit link')
s5EnPortExtCurDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("halfDuplex", 2), ("fullDuplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPortExtCurDuplexMode.setStatus('current')
if mibBuilder.loadTexts: s5EnPortExtCurDuplexMode.setDescription('The status of duplex mode. The possible values are: unknown(1)........unknown, no link halfDuplex(2).........half duplex mode fullDuplex(3)........full duplex mode')
s5EnBStatTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1), )
if mibBuilder.loadTexts: s5EnBStatTable.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatTable.setDescription('A table containing Ethernet basic statistics. The entries in the table may come from several different data sources. The number of entries is determined by the number of sources that can provide the information.')
s5EnBStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1), ).setIndexNames((0, "S5-ETHERNET-COMMON-MIB", "s5EnBStatSrcIndx"))
if mibBuilder.loadTexts: s5EnBStatEntry.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatEntry.setDescription('A row in Ethernet basic statistics table. Entries can not be created or deleted via SNMP.')
s5EnBStatSrcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 1), SrcIndx()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatSrcIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatSrcIndx.setDescription('The index of the entry in the table. This index identifies the source of the information. Only those sources that provide these statistics are in this table.')
s5EnBStatGoodOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatGoodOctets.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatGoodOctets.setDescription('A count of octets contained in frames received which had no errors. This counter includes octets in unicast, broadcast, and multicast frames. This counter includes octets after the start frame delimiter up to FCS but not including FCS octets.')
s5EnBStatGoodFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatGoodFrms.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatGoodFrms.setDescription('A count of frames that are detected without errors. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes unicast, broadcast, and multicast frames.')
s5EnBStatBcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatBcastFrms.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatBcastFrms.setDescription('A count of frames that are detected without errors and are directed to the broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Multicast frames are not included.')
s5EnBStatMcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatMcastFrms.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatMcastFrms.setDescription('A count of frames that are detected without errors and are directed to a non-broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors.')
s5EnBStatAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatAlignErrors.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatAlignErrors.setDescription('A count of frames detected that are not an integral number of octets in length and do not pass the FCS check. This counter is incremented when the frame is received with FramingError and FcsError and whose OctetCount is greater than of equal to minFramSize and less than or equal to maxFramSize.')
s5EnBStatFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatFcsErrors.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatFcsErrors.setDescription('A count of frames detected that are an integral number of octets in length that do not pass the FCS check. This counter is incremented when the frame is received with FcsError and NoFramingError and NoCollisions and whose OctetCount is greater than or equal to minFramsize and less than or equal to maxFrameSize.')
s5EnBStatRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatRunts.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatRunts.setDescription('A count of frames detected that are less than the minimum permitted frame size and have a good FCS.')
s5EnBStatTooLongFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatTooLongFrms.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatTooLongFrms.setDescription('A count of frames detected that exceed the maximum permitted frame size. This counter is incremented when a frame received on this port whose OctetCount is greater than maxFramSize.')
s5EnBStatFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatFragments.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatFragments.setDescription('A count of fragments detected between 80-512 bits (64 bytes), inclusively, with invalid FCS. (These commonly represent collision fragments, and are not errors).')
s5EnBStatVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatVeryLongEvents.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatVeryLongEvents.setDescription('A count of the times that MAU jabber lockup protection (MJLP) was detected due to transmission of data that exceeded 5 msec in duration(OctetCount greater than maxFramSize). This information can be useful in identifying faulty stations.')
s5EnBStatColls = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatColls.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatColls.setDescription('A count of receive collisions detected.')
s5EnBStatLateColls = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatLateColls.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatLateColls.setDescription('A count of late receive collisions detected. This counter is incremented for each event in which there is a receive Collision and ActivityDuration is greater than the LateEventThreshold.')
s5EnBStatShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatShortEvents.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatShortEvents.setDescription('A count of fragments detected with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times.')
s5EnBStatRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatRateMismatches.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatRateMismatches.setDescription('A count of the occurrences of out of spec bit rates. This indicates the number of times the FIFO buffer over-runs or under-runs due to transmission rate errors.')
s5EnBStatBackOffFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatBackOffFailures.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatBackOffFailures.setDescription('This counter is incremented by one for each frame received on this port with collision and port activity time greater than 552 to 560 bit time.')
s5EnBStatAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatAutoPartitions.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatAutoPartitions.setDescription('A count of the number of times that this port was automatically partitioned. The condition occurs when 32 consecutive collisions are detected on the port.')
s5EnBStatShortIPGs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatShortIPGs.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatShortIPGs.setDescription('A count of occurrences of a too short IPG (inter packet gap before a good packet) that were detected.')
s5EnBStatNullFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnBStatNullFrames.setStatus('current')
if mibBuilder.loadTexts: s5EnBStatNullFrames.setDescription('A count of the occurrences of frames received with no collision and whose octetCount is equal to 0 and activity time is greater than ValidPacketMinTime.')
s5EnPStatTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2), )
if mibBuilder.loadTexts: s5EnPStatTable.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatTable.setDescription('A table containing Ethernet port extension statistics. This table extends table s5EnBStatTable for ports. The entries in the table may come only from port sources. The number of entries is determined by the number of sources that can provide the information.')
s5EnPStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2, 1), ).setIndexNames((0, "S5-ETHERNET-COMMON-MIB", "s5EnPStatSrcIndx"))
if mibBuilder.loadTexts: s5EnPStatEntry.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatEntry.setDescription('A row in Ethernet port extension statistic table. Entries can not be created or deleted via SNMP.')
s5EnPStatSrcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2, 1, 1), SrcIndx()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPStatSrcIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatSrcIndx.setDescription('The index of the entry in the table. This index identifies the source of the information. Only those sources that provide these statistics are in this table.')
s5EnPStatSourceAddrChngs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPStatSourceAddrChngs.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatSourceAddrChngs.setDescription('A count of changes in Last Source Address.')
s5EnPStatLinkStatusChngs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPStatLinkStatusChngs.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatLinkStatusChngs.setDescription('Contains a count of number of changes in link status from on(3) to off(2).')
s5EnPStatLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnPStatLastSourceAddr.setStatus('current')
if mibBuilder.loadTexts: s5EnPStatLastSourceAddr.setDescription('The Source Address of the last readable frame received by this port. If no frames have been received by this port since the agent began monitoring this port, the agent shall return a string of length zero.')
s5EnSStatTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 3), )
if mibBuilder.loadTexts: s5EnSStatTable.setStatus('current')
if mibBuilder.loadTexts: s5EnSStatTable.setDescription('A table containing Ethernet Segment extension statistics. This table extends table s5EnBStatTable for segments. The entries in the table may come from several different data sources. The number of entries is determined by the number of sources that can provide the information.')
s5EnSStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 3, 1), ).setIndexNames((0, "S5-ETHERNET-COMMON-MIB", "s5EnSStatSrcIndx"))
if mibBuilder.loadTexts: s5EnSStatEntry.setStatus('current')
if mibBuilder.loadTexts: s5EnSStatEntry.setDescription('A row in Ethernet segment statistics table. Entries can not be created or deleted via SNMP.')
s5EnSStatSrcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 3, 1, 1), SrcIndx()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnSStatSrcIndx.setStatus('current')
if mibBuilder.loadTexts: s5EnSStatSrcIndx.setDescription('The index of the entry in the table. This index identifies the source of the information. Only those sources that provide these statistics are in this table.')
s5EnSStatSegColls = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnSStatSegColls.setStatus('current')
if mibBuilder.loadTexts: s5EnSStatSegColls.setDescription('A count of number of transmit collision events(one per packet activity) for a segment (i.e., local channel or backplane network).')
s5EnSStatSegRate = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 6, 6, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("bps10m", 2), ("bps100m", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s5EnSStatSegRate.setStatus('current')
if mibBuilder.loadTexts: s5EnSStatSegRate.setDescription('The segment speed type of this ethernet segment. The following values are currently defined: unknown (1) ------- unknown type bps10m (2) ------- 10Mbps ethernet bps100m (3) ------ 100Mbps ethernet')
mibBuilder.exportSymbols("S5-ETHERNET-COMMON-MIB", s5EnPortJabberStatus=s5EnPortJabberStatus, s5EnPortExt10MbSegConnCapability=s5EnPortExt10MbSegConnCapability, s5EnPStatEntry=s5EnPStatEntry, s5EnPortExtActiveSpeed=s5EnPortExtActiveSpeed, s5EnBStatVeryLongEvents=s5EnBStatVeryLongEvents, s5EnBStatAutoPartitions=s5EnBStatAutoPartitions, s5EnBStatMcastFrms=s5EnBStatMcastFrms, s5EnPStatSrcIndx=s5EnPStatSrcIndx, s5EnPortTable=s5EnPortTable, s5EnPStatSourceAddrChngs=s5EnPStatSourceAddrChngs, s5EnBStatColls=s5EnBStatColls, s5EnPortPartStatus=s5EnPortPartStatus, s5EnBStatShortEvents=s5EnBStatShortEvents, s5EnPortExt10MbSegAttCfg=s5EnPortExt10MbSegAttCfg, s5EnSStatSrcIndx=s5EnSStatSrcIndx, s5EnBStatGoodOctets=s5EnBStatGoodOctets, s5EnPStatLinkStatusChngs=s5EnPStatLinkStatusChngs, s5EthernetCommonMib=s5EthernetCommonMib, s5EnPortExtTable=s5EnPortExtTable, s5EnBStatEntry=s5EnBStatEntry, s5EnBStatTooLongFrms=s5EnBStatTooLongFrms, s5EnSStatEntry=s5EnSStatEntry, s5EnBStatNullFrames=s5EnBStatNullFrames, s5EnBStatShortIPGs=s5EnBStatShortIPGs, s5EnBStatRateMismatches=s5EnBStatRateMismatches, s5EnBStatBackOffFailures=s5EnBStatBackOffFailures, s5EnSStatTable=s5EnSStatTable, s5EnSStatSegRate=s5EnSStatSegRate, s5EnBStatAlignErrors=s5EnBStatAlignErrors, s5EnPortExtBrdIndx=s5EnPortExtBrdIndx, s5EnPortExtCurDuplexMode=s5EnPortExtCurDuplexMode, s5EnPortExtIndx=s5EnPortExtIndx, s5EnPortExt100MbSegAttCfg=s5EnPortExt100MbSegAttCfg, s5EnBStatBcastFrms=s5EnBStatBcastFrms, s5EnPortLinkStatus=s5EnPortLinkStatus, s5EnPortPartTime=s5EnPortPartTime, s5EnBStatGoodFrms=s5EnBStatGoodFrms, s5EnBStatLateColls=s5EnBStatLateColls, s5EnBStatFcsErrors=s5EnBStatFcsErrors, s5EnBStatFragments=s5EnBStatFragments, s5EnPStatTable=s5EnPStatTable, s5EnPortExtAutoNegRcvd=s5EnPortExtAutoNegRcvd, s5EnPortBrdIndx=s5EnPortBrdIndx, s5EnPortIndx=s5EnPortIndx, s5EnPortExtEntry=s5EnPortExtEntry, s5EnBStatSrcIndx=s5EnBStatSrcIndx, s5EnPortExtAutoNegAdv=s5EnPortExtAutoNegAdv, s5EnPStatLastSourceAddr=s5EnPStatLastSourceAddr, s5EnPortExt100MbSegConnCapability=s5EnPortExt100MbSegConnCapability, s5EnBStatTable=s5EnBStatTable, s5EnPortEntry=s5EnPortEntry, s5EnBStatRunts=s5EnBStatRunts, s5EnSStatSegColls=s5EnSStatSegColls, PYSNMP_MODULE_ID=s5EthernetCommonMib, s5EnPortExtHwCapability=s5EnPortExtHwCapability)

#
# PySNMP MIB module LAN-EMULATION-CLIENT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LAN-EMULATION-CLIENT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:40:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
TimeTicks, Gauge32, MibIdentifier, NotificationType, iso, enterprises, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, Bits, ModuleIdentity, Counter32, Unsigned32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Gauge32", "MibIdentifier", "NotificationType", "iso", "enterprises", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "Bits", "ModuleIdentity", "Counter32", "Unsigned32", "Integer32")
DisplayString, TextualConvention, MacAddress, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "MacAddress", "RowStatus", "TruthValue")
atmfLanEmulation = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3))
leClientMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 3, 1))
if mibBuilder.loadTexts: leClientMIB.setLastUpdated('9505100000Z')
if mibBuilder.loadTexts: leClientMIB.setOrganization('ATM Forum LAN Emulation Sub-Working Group')
if mibBuilder.loadTexts: leClientMIB.setContactInfo(' The ATM Forum 303 Vintage Park Drive Foster City, CA 94404 United States of America Tel: 415-578-6860 E-mail: info@atmforum.com')
if mibBuilder.loadTexts: leClientMIB.setDescription("This module defines a portion of the management information base (MIB) for managing ATM LAN Emulation Client nodes. It is meant to be used in connection with the AToM MIB and MIB-II / RFC 1573 'ifTable' entries for each LEC / emulated 802.x network interface.")
leClientMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1))
class OwnerString(DisplayString):
    pass

class AtmLaneAddress(TextualConvention, OctetString):
    description = 'A twenty-octet binary string, containing a standard ATM Forum address -- or the zero-length string, indicating the absence of an address. For LAN Emulation purposes, the eight-octet address format is not used.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class VpiInteger(TextualConvention, Integer32):
    description = 'An integer large enough to hold a VPI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class VciInteger(TextualConvention, Integer32):
    description = 'An integer large enough to hold a VCI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class LeConnectionInterface(TextualConvention, Integer32):
    description = "A combination flag and ifTable index, indicating whether a LAN Emulation circuit exists - and, if so, which interface is associated with it at the point where it connects to a LE Client. Objects of this type are always defined as part of a set that includes fooInterface LeConnectionInterface fooVpi VpiInteger fooVci VciInteger The interpretation of these objects is as follows. 1. If no connection exists, 'fooInterface' has a value of 0. Because Interfaces table entries always have 'ifIndex' values larger than 0, 'fooInterface' reliably serves as a 'connection exists' flag. In this case, 'fooVpi' and 'fooVci' are meaningless, and have the value 0. 2. If a PVC or SVC exists, 'fooInterface' is defined to have the value of the MIB-II/RFC 1573 'ifIndex' of the 'atm' interface associated with the VCC. 'fooVpi' and 'fooVci' will contain its VPI/VCI. Therefore, ('fooInterface', 'fooVpi', 'fooVci') give you an index into the AToM MIB which allows you to examine and play with the circuit further. 3. If a proprietary connection (such as an internal data path between co-located components) exists, this specification does not mandate how it should be managed. One option is to set 'fooInterface' to the value of the MIB-II/RFC 1573 'ifIndex' for the LAN Emulation Client. This indicates that a connection exists, but is not being managed in the same fashion as an ATM VCC."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class LecState(TextualConvention, Integer32):
    reference = 'ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.3.1'
    description = 'An official protocol state of a LAN Emulation Client.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7))

class LecDataFrameFormat(TextualConvention, Integer32):
    reference = 'ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1'
    description = "A 'LAN Type' value. C2 LAN Type. The type of LAN that the LE Client is, or wishes to become, a member of. This MUST be one of Ethernet/IEEE 802.3, IEEE 802.5, or Unspecified."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unspecified", 1), ("aflane8023", 2), ("aflane8025", 3))

class LecDataFrameSize(TextualConvention, Integer32):
    reference = 'ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1'
    description = "A 'Maximum Data Frame Size' value. C3 Maximum Data Frame Size. The maximum AAL-5 SDU size of a data frame that the LE Client wishes to send on the Multicast Send VCC or to receive on the Multicast Send VCC or Multicast Forward VCC. This parameter also specifies the maximum AAL-5 SDU on all of a LE Client's Data Direct VCCs. This MUST be either 1516, 4544, 9234, or 18190 octets, or Unspecified."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("unspecified", 1), ("max1516", 2), ("max4544", 3), ("max9234", 4), ("max18190", 5))

class LeArpTableEntryType(TextualConvention, Integer32):
    description = "Indicates how a LE_ARP table entry was created and whether it is subject to aging. other(1) The LE_ARP entry does not fall into one of the categories defined below. learnedViaControl(2) This LE_ARP entry was learned by using the LE_ARP_REQUEST / LE_ARP_RESPONSE protocol, or by otherwise observing relevant traffic on Control VCCs. Entries of this type are aged. learnedViaData(3) This LE_ARP entry was learned by observing incoming traffic on Data VCCs. Entries of this type are aged. staticVolatile(4) This LE_ARP entry was created by management. It will not be aged. On the other hand, it will not survive a restart of the client. If an agent permits LE_ARP entries of this type to be created, it may require that the LAN Emulation Client be in the 'operational' state at the time. staticNonVolatile(5) This LE_ARP entry was created by management. It will not be aged, and it will survive a restart of the client. The values 'learnedViaData' and 'learnedViaControl' can be read, but may not be written."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("learnedViaControl", 2), ("learnedViaData", 3), ("staticVolatile", 4), ("staticNonVolatile", 5))

lecConfigTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1), )
if mibBuilder.loadTexts: lecConfigTable.setStatus('current')
if mibBuilder.loadTexts: lecConfigTable.setDescription("A table describing all of the LAN Emulation Clients implemented by this host. Each LE Client has a row in the MIB-II/RFC 1573 Interfaces table (describing the emulated packet interface it presents to higher layers). Each LE Client also has a row in this and other LEC MIB tables (describing its interface with other LAN Emulation components). This table contains configuration variables. Three extension tables contain client status, performance statistics, and information about control/multicast VCCs. Unlike hardware ports, LE Clients can be created by management. However, the RFC 1573 Interfaces table does not directly support row creation. Therefore, creating or deleting a row in the lecConfigTable is defined to have the side effect of creating or deleting corresponding rows in - the MIB-II / RFC 1573 Interfaces table, - the 'lecMappingTable', - the 'lecStatusTable', - the 'lecServerVccTable', - the 'lecStatisticsTable', and - any other dependent tables New Interfaces table rows for LAN Emulation Clients always have 'ifAdminStatus' set to 'down'. A Note On Indexing: ------------------- Most of the tables in this MIB are indexed in whole or in part by 'lecIndex' - not by 'ifIndex'. Why is there a separate index? Traditionally, ifIndex values are chosen by agents, and are permitted to change across restarts. Using ifIndex to index lecConfigTable could complicate row creation and/or cause interoperability problems (if each agent had special restrictions on ifIndex). Having a separate index avoids these problems. ")
lecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: lecConfigEntry.setStatus('current')
if mibBuilder.loadTexts: lecConfigEntry.setDescription('Each table entry contains configuration information for one LAN Emulation Client. Most of the objects are derived from Initial State Parameters in the LAN Emulation specification.')
lecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lecIndex.setStatus('current')
if mibBuilder.loadTexts: lecIndex.setDescription('A value which uniquely identifies this conceptual row in the lecConfigTable. If the conceptual row identified by this value of lecIndex is recreated following an agent restart, the same value of lecIndex must be used to identify the recreated row. (However, the Interfaces table index associated with the client may change.)')
lecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecRowStatus.setStatus('current')
if mibBuilder.loadTexts: lecRowStatus.setDescription("This object lets network managers create and delete LAN Emulation Clients, on systems that support this optional capability. It does not control Joins and Terminations; they are controlled by 'ifAdminStatus'. However, taking rows out of service will have the side effect of changing their 'ifAdminStatus' values to 'down', thus causing any active emulated LAN connections to be terminated. Within each conceptual lecConfigTable row, objects which are writable may be modified regardless of the value of lecRowStatus. It is not necessary to set a row's status to 'notInService' first. When creating a LAN Emulation Client, it is up to the management station to determine a suitable 'lecIndex'. To facilitate interoperability, agents should not put any restrictions on the 'lecIndex' beyond the obvious ones that it be valid and unused. If you create a LAN Emulation Client via this object, it will initially have 'ifAdminStatus' = 'down' 'ifOperStatus' = 'down' 'lecInterfaceState' = 'initialState' ")
lecOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 3), OwnerString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecOwner.setStatus('current')
if mibBuilder.loadTexts: lecOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
lecConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConfigMode.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Sections 3.4.1.1 and 5.3')
if mibBuilder.loadTexts: lecConfigMode.setStatus('current')
if mibBuilder.loadTexts: lecConfigMode.setDescription('Indicates whether this LAN Emulation Client should auto-configure the next time it is (re)started. In automatic(1) mode, a client uses a LAN Emulation Configuration Server to learn the ATM address of its LAN Emulation Server, and to obtain other parameters. lecConfig{ LanType, MaxDataFrameSize, LanName } are used in the Configure request. lecConfigLesAtmAddress is ignored. In manual(2) mode, management tells the client the ATM address of its LAN Emulation Server and the values of other parameters. lecConfig{ LanType, MaxDataFrameSize, LanName } are used in the Join request. lecConfigLesAtmAddress tells the client which LES to call.')
lecConfigLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 5), LecDataFrameFormat().clone('unspecified')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConfigLanType.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecConfigLanType.setStatus('current')
if mibBuilder.loadTexts: lecConfigLanType.setDescription('C2 LAN Type. The data frame format which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, lecActualLanType will be.')
lecConfigMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 6), LecDataFrameSize().clone('unspecified')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConfigMaxDataFrameSize.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecConfigMaxDataFrameSize.setStatus('current')
if mibBuilder.loadTexts: lecConfigMaxDataFrameSize.setDescription('C3 Maximum Data Frame Size. The maximum data frame size which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, lecActualMaxDataFrameSize will be.')
lecConfigLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConfigLanName.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecConfigLanName.setStatus('current')
if mibBuilder.loadTexts: lecConfigLanName.setDescription('C5 ELAN Name. The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, lecActualLanName will be.')
lecConfigLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 8), AtmLaneAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConfigLesAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecConfigLesAtmAddress.setStatus('current')
if mibBuilder.loadTexts: lecConfigLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When lecConfigMode is 'automatic', there is no need to set this address, and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in lecActualLesAtmAddress while leaving lecConfigLesAtmAddress alone.")
lecControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecControlTimeout.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecControlTimeout.setStatus('current')
if mibBuilder.loadTexts: lecControlTimeout.setDescription('C7 Control Time-out. Time out period used for timing out most request/response control frame interactions, as specified elsewhere [in the LAN Emulation specification]. This time value is expressed in seconds.')
lecMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setUnits('frames').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMaxUnknownFrameCount.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMaxUnknownFrameCount.setStatus('current')
if mibBuilder.loadTexts: lecMaxUnknownFrameCount.setDescription('C10 Maximum Unknown Frame Count. See the description of lecMaxUnknownFrameTime below.')
lecMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMaxUnknownFrameTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMaxUnknownFrameTime.setStatus('current')
if mibBuilder.loadTexts: lecMaxUnknownFrameTime.setDescription('C11 Maximum Unknown Frame Time. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to the BUS for a given unicast LAN Destination, and it must also initiate the address resolution protocol to resolve that LAN Destination. This time value is expressed in seconds.')
lecVccTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 12), Integer32().clone(1200)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecVccTimeoutPeriod.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecVccTimeoutPeriod.setStatus('current')
if mibBuilder.loadTexts: lecVccTimeoutPeriod.setDescription('C12 VCC Time-out Period. A LE Client SHOULD release any Data Direct VCC that it has not used to transmit or receive any data frames for the length of the VCC Time-out Period. This parameter is only meaningful for SVC Data Direct VCCs. This time value is expressed in seconds. The default value is 20 minutes. A value of 0 seconds means that the timeout period is infinite. Negative values will be rejected by the agent.')
lecMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMaxRetryCount.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMaxRetryCount.setStatus('current')
if mibBuilder.loadTexts: lecMaxRetryCount.setDescription("C13 Maximum Retry Count. A LE CLient MUST not retry a LE_ARP_REQUEST for a given frame's LAN destination more than Maximum Retry Count times, after the first LE_ARP_REQUEST for that same frame's LAN destination.")
lecAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecAgingTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecAgingTime.setStatus('current')
if mibBuilder.loadTexts: lecAgingTime.setDescription('C17 Aging Time. The maximum time that a LE Client will maintain an entry in its LE_ARP cache in the absence of a verification of that relationship. This time value is expressed in seconds.')
lecForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecForwardDelayTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecForwardDelayTime.setStatus('current')
if mibBuilder.loadTexts: lecForwardDelayTime.setDescription('C18 Forward Delay Time. The maximum time that a LE Client will maintain an entry for a non-local MAC address in its LE_ARP cache in the absence of a verification of that relationship, as long as the Topology Change flag C19 is true. lecForwardDelayTime SHOULD BE less than lecAgingTime. When it is not, lecAgingTime governs LE_ARP aging. This time value is expressed in seconds.')
lecExpectedArpResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecExpectedArpResponseTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecExpectedArpResponseTime.setStatus('current')
if mibBuilder.loadTexts: lecExpectedArpResponseTime.setDescription('C20 Expected LE_ARP Response Time. The maximum time that the LEC expects an LE_ARP_REQUEST/ LE_ARP_RESPONSE cycle to take. Used for retries and verifies. This time value is expressed in seconds.')
lecFlushTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecFlushTimeOut.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecFlushTimeOut.setStatus('current')
if mibBuilder.loadTexts: lecFlushTimeOut.setDescription('C21 Flush Time-out. Time limit to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action. This time value is expressed in seconds.')
lecPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(6)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecPathSwitchingDelay.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecPathSwitchingDelay.setStatus('current')
if mibBuilder.loadTexts: lecPathSwitchingDelay.setDescription('C22 Path Switching Delay. The time since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol. This time value is expressed in seconds.')
lecLocalSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecLocalSegmentID.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecLocalSegmentID.setStatus('current')
if mibBuilder.loadTexts: lecLocalSegmentID.setDescription('C23 Local Segment ID. The segment ID of the emulated LAN. This is only required for IEEE 802.5 clients that are Source Routing bridges.')
lecMulticastSendType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bestEffort", 1), ("variableBitRate", 2), ("constantBitRate", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMulticastSendType.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMulticastSendType.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendType.setDescription('C24 Multicast Send VCC Type. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. This is the method to be used by the LE Client when specifying traffic parameters when it sets up the Multicast Send VCC for this emulated LAN.')
lecMulticastSendAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 21), Integer32()).setUnits('cells per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMulticastSendAvgRate.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMulticastSendAvgRate.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendAvgRate.setDescription('C25 Multicast Send VCC AvgRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Sustained Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings.')
lecMulticastSendPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 22), Integer32()).setUnits('cells per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecMulticastSendPeakRate.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMulticastSendPeakRate.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendPeakRate.setDescription('C26 Multicast Send VCC PeakRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Peak Cell Rate to be requested by LE Client when setting up the Multicast Send VCC when using either Variable or Constant bit rate codings.')
lecConnectionCompleteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecConnectionCompleteTimer.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecConnectionCompleteTimer.setStatus('current')
if mibBuilder.loadTexts: lecConnectionCompleteTimer.setDescription('C28 Connection Complete Timer. Optional. In Connection Establishment this is the time period in which data or a READY_IND message is expected from a Calling Party. This time value is expressed in seconds.')
lecStatusTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2), )
if mibBuilder.loadTexts: lecStatusTable.setStatus('current')
if mibBuilder.loadTexts: lecStatusTable.setDescription('A read-only table containing identification, status, and operational information about the LAN Emulation Clients this agent manages.')
lecStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: lecStatusEntry.setStatus('current')
if mibBuilder.loadTexts: lecStatusEntry.setDescription('Each table entry contains information about one LAN Emulation Client.')
lecIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecIfIndex.setStatus('current')
if mibBuilder.loadTexts: lecIfIndex.setDescription("This object identifies the logical interface number ('ifIndex') assigned to this client, and is used to identify corresponding rows in the Interfaces MIB. Note that re-initialization of the management agent may cause a client's 'lecIfIndex' to change.")
lecPrimaryAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecPrimaryAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecPrimaryAtmAddress.setStatus('current')
if mibBuilder.loadTexts: lecPrimaryAtmAddress.setDescription("C1 LE Client's ATM Addresses. The primary ATM address of this LAN Emulation Client. This address is used to establish the Control Direct and Multicast Send VCCs, and may also be used to set up Data Direct VCCs. A client may have additional ATM addresses for use with Data Direct VCCs. These addresses are readable via the lecAtmAddressTable.")
lecID = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecID.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecID.setStatus('current')
if mibBuilder.loadTexts: lecID.setDescription("C14 LE Client Identifier. Each LE Client requires a LE Client Identifier (LECID) assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client. This value MUST NOT change without terminating the LE Client and returning to the Initial state. A valid LECID MUST be in the range X'0001' through X'FEFF'. The value of this object is only meaningful for a LEC that is connected to a LES. For a LEC which does not belong to an emulated LAN, the value of this object is defined to be 0.")
lecInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 4), LecState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecInterfaceState.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.3.1')
if mibBuilder.loadTexts: lecInterfaceState.setStatus('current')
if mibBuilder.loadTexts: lecInterfaceState.setDescription("The current state of the LAN Emulation Client. Note that 'ifOperStatus' is defined to be 'up' when, and only when, 'lecInterfaceState' is 'operational'.")
lecLastFailureRespCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("undefinedError", 3), ("versionNotSupported", 4), ("invalidRequestParameters", 5), ("duplicateLanDestination", 6), ("duplicateAtmAddress", 7), ("insufficientResources", 8), ("accessDenied", 9), ("invalidRequesterId", 10), ("invalidLanDestination", 11), ("invalidAtmAddress", 12), ("noConfiguration", 13), ("leConfigureError", 14), ("insufficientInformation", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLastFailureRespCode.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2, Table 13')
if mibBuilder.loadTexts: lecLastFailureRespCode.setStatus('current')
if mibBuilder.loadTexts: lecLastFailureRespCode.setDescription("Status code from the last failed Configure response or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a timeout period. If none of this client's requests have failed, this object has the value 'none'. If the failed response contained a STATUS code that is not defined in the LAN Emulation specification, this object has the value 'undefinedError'. The value 'timeout' is self-explanatory. Other failure codes correspond to those defined in the specification, although they may have different numeric values.")
lecLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 6), LecState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecLastFailureState.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.3.1')
if mibBuilder.loadTexts: lecLastFailureState.setStatus('current')
if mibBuilder.loadTexts: lecLastFailureState.setDescription("The state this client was in when it updated the 'lecLastFailureRespCode'. If 'lecLastFailureRespCode' is 'none', this object has the value initialState(1).")
lecProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecProtocol.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2')
if mibBuilder.loadTexts: lecProtocol.setStatus('current')
if mibBuilder.loadTexts: lecProtocol.setDescription('The LAN Emulation protocol which this client supports, and specifies in its LE_JOIN_REQUESTs.')
lecVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecVersion.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2')
if mibBuilder.loadTexts: lecVersion.setStatus('current')
if mibBuilder.loadTexts: lecVersion.setDescription('The LAN Emulation protocol version which this client supports, and specifies in its LE_JOIN_REQUESTs.')
lecTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecTopologyChange.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecTopologyChange.setStatus('current')
if mibBuilder.loadTexts: lecTopologyChange.setDescription("C19 Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Aging Time C17, to age non-local entries in its LE_ARP cache C16. For a client which is not connected to the LES, this object is defined to have the value 'false'.")
lecConfigServerAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 10), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigServerAtmAddress.setStatus('current')
if mibBuilder.loadTexts: lecConfigServerAtmAddress.setDescription('The ATM address of the LAN Emulation Configuration Server (if known) or the empty string (otherwise).')
lecConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gotAddressViaIlmi", 1), ("usedWellKnownAddress", 2), ("usedLecsPvc", 3), ("didNotUseLecs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigSource.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.2')
if mibBuilder.loadTexts: lecConfigSource.setStatus('current')
if mibBuilder.loadTexts: lecConfigSource.setDescription('Indicates whether this LAN Emulation Client used the LAN Emulation Configuration Server, and, if so, what method it used to establish the Configuration Direct VCC.')
lecActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 12), LecDataFrameFormat()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLanType.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecActualLanType.setStatus('current')
if mibBuilder.loadTexts: lecActualLanType.setDescription("C2 LAN Type. The data frame format that this LAN Emulation Client is using right now. This may come from * lecConfigLanType, * the LAN Emulation Configuration Server, or * the LAN Emulation Server This value is related to 'ifMtu' and 'ifType'. See the LEC management specification for more details.")
lecActualMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 13), LecDataFrameSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualMaxDataFrameSize.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecActualMaxDataFrameSize.setStatus('current')
if mibBuilder.loadTexts: lecActualMaxDataFrameSize.setDescription('C3 Maximum Data Frame Size. The maximum data frame size that this LAN Emulation client is using right now. This may come from * lecConfigMaxDataFrameSize, * the LAN Emulation Configuration Server, or * the LAN Emulation Server ')
lecActualLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLanName.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecActualLanName.setStatus('current')
if mibBuilder.loadTexts: lecActualLanName.setDescription('C5 ELAN Name. The identity of the emulated LAN which this client last joined, or wishes to join. This may come from * lecConfigLanName, * the LAN Emulation Configuration Server, or * the LAN Emulation Server ')
lecActualLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 15), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecActualLesAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecActualLesAtmAddress.setStatus('current')
if mibBuilder.loadTexts: lecActualLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server address currently in use or most recently attempted. If no LAN Emulation Server attachment has been tried, this object's value is the zero-length string.")
lecProxyClient = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 2, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecProxyClient.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecProxyClient.setStatus('current')
if mibBuilder.loadTexts: lecProxyClient.setDescription('C4 Proxy. Indicates whether this client is acting as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST frames for such addresses.')
lecMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 3), )
if mibBuilder.loadTexts: lecMappingTable.setStatus('current')
if mibBuilder.loadTexts: lecMappingTable.setDescription("A table mapping the 'ifIndex' values of 'aflane8023' and 'aflane8025' interfaces to the 'lecIndex' values of the corresponding LAN Emulation Clients.")
lecMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: lecMappingEntry.setStatus('current')
if mibBuilder.loadTexts: lecMappingEntry.setDescription('Each row describes one ifIndex --> lecIndex mapping.')
lecMappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMappingIndex.setStatus('current')
if mibBuilder.loadTexts: lecMappingIndex.setDescription("The 'lecIndex' of the client which implements the specified interface.")
lecStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4), )
if mibBuilder.loadTexts: lecStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: lecStatisticsTable.setDescription('An extension table containing traffic statistics for all the LAN Emulation Clients this host implements.')
lecStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: lecStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: lecStatisticsEntry.setDescription('Each row in this table contains traffic statistics for one LAN Emulation client.')
lecArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRequestsOut.setStatus('current')
if mibBuilder.loadTexts: lecArpRequestsOut.setDescription('The number of LE_ARP_REQUESTs sent over the LUNI by this LAN Emulation Client.')
lecArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRequestsIn.setStatus('current')
if mibBuilder.loadTexts: lecArpRequestsIn.setDescription('The number of LE_ARP_REQUESTs received over the LUNI by this LAN Emulation Client. Requests may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented and the chances it has had for learning. This counter covers both VCCs.')
lecArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRepliesOut.setStatus('current')
if mibBuilder.loadTexts: lecArpRepliesOut.setDescription('The number of LE_ARP_RESPONSEs sent over the LUNI by this LAN Emulation Client.')
lecArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecArpRepliesIn.setStatus('current')
if mibBuilder.loadTexts: lecArpRepliesIn.setDescription('The number of LE_ARP_RESPONSEs received over the LUNI by this LAN Emulation Client. This count includes all such replies, whether solicited or not. Replies may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented. This counter covers both VCCs.')
lecControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlFramesOut.setStatus('current')
if mibBuilder.loadTexts: lecControlFramesOut.setDescription('The total number of control packets sent by this LAN Emulation Client over the LUNI.')
lecControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlFramesIn.setStatus('current')
if mibBuilder.loadTexts: lecControlFramesIn.setDescription('The total number of control packets received by this LAN Emulation Client over the LUNI.')
lecSvcFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecSvcFailures.setStatus('current')
if mibBuilder.loadTexts: lecSvcFailures.setDescription('The total number of * outgoing LAN Emulation SVCs which this client tried, but failed, to open; * incoming LAN Emulation SVCs which this client tried, but failed to establish; and * incoming LAN Emulation SVCs which this client rejected for protocol or security reasons. ')
lecServerVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5), )
if mibBuilder.loadTexts: lecServerVccTable.setStatus('current')
if mibBuilder.loadTexts: lecServerVccTable.setDescription('A table identifying the Control and Multicast VCCs for each LAN Emulation Client this host implements.')
lecServerVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: lecServerVccEntry.setStatus('current')
if mibBuilder.loadTexts: lecServerVccEntry.setDescription('Each row in this table describes the Control VCCs and Multicast VCCs for one LAN Emulation client.')
lecConfigDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 1), LeConnectionInterface()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigDirectInterface.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.1')
if mibBuilder.loadTexts: lecConfigDirectInterface.setStatus('current')
if mibBuilder.loadTexts: lecConfigDirectInterface.setDescription('The interface associated with the Configuration Direct VCC. If no Configuration Direct VCC exists, this object has the value 0. Otherwise, the objects ( lecConfigDirectInterface, lecConfigDirectVpi, lecConfigDirectVci ) identify the circuit.')
lecConfigDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 2), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigDirectVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.1')
if mibBuilder.loadTexts: lecConfigDirectVpi.setStatus('current')
if mibBuilder.loadTexts: lecConfigDirectVpi.setDescription('If the Configuration Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecConfigDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 3), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecConfigDirectVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.1')
if mibBuilder.loadTexts: lecConfigDirectVci.setStatus('current')
if mibBuilder.loadTexts: lecConfigDirectVci.setDescription('If the Configuration Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecControlDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 4), LeConnectionInterface()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDirectInterface.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.2')
if mibBuilder.loadTexts: lecControlDirectInterface.setStatus('current')
if mibBuilder.loadTexts: lecControlDirectInterface.setDescription('The interface associated with the Control Direct VCC. If no Control Direct VCC exists, this object has the value 0. Otherwise, the objects ( lecControlDirectInterface, lecControlDirectVpi, lecControlDirectVci ) identify the circuit.')
lecControlDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 5), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDirectVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.2')
if mibBuilder.loadTexts: lecControlDirectVpi.setStatus('current')
if mibBuilder.loadTexts: lecControlDirectVpi.setDescription('If the Control Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecControlDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 6), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDirectVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.2')
if mibBuilder.loadTexts: lecControlDirectVci.setStatus('current')
if mibBuilder.loadTexts: lecControlDirectVci.setDescription('If the Control Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecControlDistributeInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 7), LeConnectionInterface()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDistributeInterface.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.3')
if mibBuilder.loadTexts: lecControlDistributeInterface.setStatus('current')
if mibBuilder.loadTexts: lecControlDistributeInterface.setDescription('The interface associated with the Control Distribute VCC. If no Control Distribute VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( lecControlDistributeInterface, lecControlDistributeVpi, lecControlDistributeVci ) identify the circuit.')
lecControlDistributeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 8), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDistributeVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.3')
if mibBuilder.loadTexts: lecControlDistributeVpi.setStatus('current')
if mibBuilder.loadTexts: lecControlDistributeVpi.setDescription('If the Control Distribute VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecControlDistributeVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 9), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecControlDistributeVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.3')
if mibBuilder.loadTexts: lecControlDistributeVci.setStatus('current')
if mibBuilder.loadTexts: lecControlDistributeVci.setDescription('If the Control Distribute VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object contains the value 0.')
lecMulticastSendInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 10), LeConnectionInterface()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastSendInterface.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.2')
if mibBuilder.loadTexts: lecMulticastSendInterface.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendInterface.setDescription('The interface associated with the Multicast Send VCC. If no Multicast Send VCC exists, this object has the value 0. Otherwise, the objects ( lecMulticastSendInterface, lecMulticastSendVpi, lecMulticastSendVci ) identify the circuit.')
lecMulticastSendVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 11), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastSendVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.2')
if mibBuilder.loadTexts: lecMulticastSendVpi.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendVpi.setDescription('If the Multicast Send VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecMulticastSendVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 12), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastSendVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.2')
if mibBuilder.loadTexts: lecMulticastSendVci.setStatus('current')
if mibBuilder.loadTexts: lecMulticastSendVci.setDescription('If the Multicast Send VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecMulticastForwardInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 13), LeConnectionInterface()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastForwardInterface.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.3')
if mibBuilder.loadTexts: lecMulticastForwardInterface.setStatus('current')
if mibBuilder.loadTexts: lecMulticastForwardInterface.setDescription('The interface associated with the Multicast Forward VCC. If no Multicast Forward VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( lecMulticastForwardInterface, lecMulticastForwardVpi, lecMulticastForwardVci ) identify the circuit.')
lecMulticastForwardVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 14), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastForwardVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.3')
if mibBuilder.loadTexts: lecMulticastForwardVpi.setStatus('current')
if mibBuilder.loadTexts: lecMulticastForwardVpi.setDescription('If the Multicast Forward VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecMulticastForwardVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 5, 1, 15), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMulticastForwardVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.3')
if mibBuilder.loadTexts: lecMulticastForwardVci.setStatus('current')
if mibBuilder.loadTexts: lecMulticastForwardVci.setDescription('If the Multicast Forward VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
lecAtmAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 6), )
if mibBuilder.loadTexts: lecAtmAddressTable.setStatus('current')
if mibBuilder.loadTexts: lecAtmAddressTable.setDescription("A table listing all of the ATM addresses belonging to this host's LAN Emulation Clients.")
lecAtmAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 6, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "lecAtmAddress"))
if mibBuilder.loadTexts: lecAtmAddressEntry.setStatus('current')
if mibBuilder.loadTexts: lecAtmAddressEntry.setDescription("Each row in this table describes one of a client's ATM addresses.")
lecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 6, 1, 1), AtmLaneAddress())
if mibBuilder.loadTexts: lecAtmAddress.setStatus('current')
if mibBuilder.loadTexts: lecAtmAddress.setDescription('The ATM address this row describes. This could be either a primary address or a secondary address.')
lecAtmAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lecAtmAddressStatus.setStatus('current')
if mibBuilder.loadTexts: lecAtmAddressStatus.setDescription("Used to create and delete rows in this table. A management station may not change the status of a primary ATM address to 'notInService' or 'destroy' unless the client's ifAdminStatus is 'down', and the client's lecInterfaceState is 'initialState'. Secondary ATM addresses may be destroyed at any time permitted by the agent.")
lecMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 7), )
if mibBuilder.loadTexts: lecMacAddressTable.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecMacAddressTable.setStatus('current')
if mibBuilder.loadTexts: lecMacAddressTable.setDescription("This table contains entries for all of the registered MAC addresses belonging to this agent's LE clients. C6 Local Unicast MAC Address(es). Each LE Client has zero or more local unicast MAC addresses. In an operational LE Client, every address in this variable MUST have been registered with the LE Server. Two LE CLients joined to the same emulated LAN MUST NOT have the same local unicast MAC address. A LE Client's MAC addresses may change during normal operations. When answering a LE_ARP_REQUEST for any address in this list, the 'Remote Address' bit in the FLAGS field of the LE_ARP_RESPONSE MUST be clear.")
lecMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 7, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "lecMacAddress"))
if mibBuilder.loadTexts: lecMacAddressEntry.setStatus('current')
if mibBuilder.loadTexts: lecMacAddressEntry.setDescription('Each table row describes a (MAC address, ATM address) pair registered for a particular client.')
lecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 7, 1, 1), MacAddress())
if mibBuilder.loadTexts: lecMacAddress.setStatus('current')
if mibBuilder.loadTexts: lecMacAddress.setDescription("A unicast MAC address which the LE client denoted by 'lecIndex' has registered with its LE Server.")
lecMacAddressAtmBinding = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 7, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecMacAddressAtmBinding.setStatus('current')
if mibBuilder.loadTexts: lecMacAddressAtmBinding.setDescription("The ATM address registered for 'lecMacAddress'.")
lecRouteDescrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 8), )
if mibBuilder.loadTexts: lecRouteDescrTable.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lecRouteDescrTable.setStatus('current')
if mibBuilder.loadTexts: lecRouteDescrTable.setDescription("This table lists all of the Route Descriptors which are registered by this host's LAN Emulation Clients. C8 Route Descriptor(s). Route Descriptors exist only for source-routed IEEE 802.5 LE Clients that are Source-Route Bridges. All Route Descriptors in any given emulated LAN MUST be unique. A LE Client MAY have zero or more Route Descriptors and these Route Descriptors MAY change during normal operation. In an operational LE Client, every Local Route Descriptor in C8 MUST have been registered with the LE Server. When answering a LE_ARP_REQUEST for any address in this list, the 'Remote Address' bit in the FLAGS field of the LE_ARP_RESPONSE MUST be clear.")
lecRouteDescrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 8, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "lecRouteDescrSegmentID"), (0, "LAN-EMULATION-CLIENT-MIB", "lecRouteDescrBridgeNumber"))
if mibBuilder.loadTexts: lecRouteDescrEntry.setStatus('current')
if mibBuilder.loadTexts: lecRouteDescrEntry.setDescription('Each table row describes a (Route Descriptor, ATM address) pair registered for a particular client.')
lecRouteDescrSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: lecRouteDescrSegmentID.setStatus('current')
if mibBuilder.loadTexts: lecRouteDescrSegmentID.setDescription('The LAN ID portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
lecRouteDescrBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lecRouteDescrBridgeNumber.setStatus('current')
if mibBuilder.loadTexts: lecRouteDescrBridgeNumber.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
lecRouteDescrAtmBinding = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 8, 1, 3), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecRouteDescrAtmBinding.setStatus('current')
if mibBuilder.loadTexts: lecRouteDescrAtmBinding.setDescription("The ATM address registered for the IEEE 802.5 route descriptor ('lecRouteDescrSegmentID', 'lecRouteDescrBridgeNumber').")
leArpTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9), )
if mibBuilder.loadTexts: leArpTable.setReference('ATM Forum LAN Emulation Over ATM Specification, Section 5.1.1')
if mibBuilder.loadTexts: leArpTable.setStatus('current')
if mibBuilder.loadTexts: leArpTable.setDescription("This table provides access to an ATM LAN Emulation Client's MAC-to-ATM ARP cache. It contains entries for unicast addresses and for the broadcast address, but not for multicast MAC addresses. C16 LE_ARP Cache. A table of entries, each of which establishes a relationship between a LAN Destination external to the LE Client and the ATM address to which data frames for that LAN Destination will be sent.")
leArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "leArpMacAddress"))
if mibBuilder.loadTexts: leArpEntry.setStatus('current')
if mibBuilder.loadTexts: leArpEntry.setDescription('An ATM LAN Emulation ARP cache entry containing information about the binding of one MAC address to one ATM address.')
leArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1, 1), MacAddress())
if mibBuilder.loadTexts: leArpMacAddress.setStatus('current')
if mibBuilder.loadTexts: leArpMacAddress.setDescription("The MAC address for which this cache entry provides a translation. Since ATM LAN Emulation uses an ARP protocol to locate the Broadcast and Unknown Server, the value of this object could be the broadcast MAC address. MAC addresses should be unique within any given ATM Emulated LAN. However, there's no requirement that they be unique across disjoint emulated LANs.")
leArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1, 2), AtmLaneAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leArpAtmAddress.setStatus('current')
if mibBuilder.loadTexts: leArpAtmAddress.setDescription("The ATM address of the Broadcast & Unknown Server or LAN Emulation Client whose MAC address is stored in 'leArpMacAddress'. This value may be determined through the use of the LE_ARP procedure, through source address learning, or through other mechanisms. Some agents may provide write access to this object, as part of their support for 'static' LE_ARP entries. The effect of attempting to write an ATM address to a 'learned' row is explicitly undefined. Agents may disallow the write, accept the write and change the row's type, or even accept the write as-is.")
leArpIsRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: leArpIsRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: leArpIsRemoteAddress.setDescription("Indicates whether this entry is for a local or remote MAC address. In this context, 'local' means 'a MAC address that is local to the remote client', as opposed to 'one of my addresses'. true(1) The address is believed to be remote - or its local/remote status is unknown. For an entry created via the LE_ARP mechanism, this corresponds to the 'Remote address' flag being set in the LE_ARP_RESPONSE. During Topology Change periods, remote LE_ARP entries generally age out faster than others. Specifically, they are subject to the Forward Delay Time as well as to the Aging Time. false(2) The address is believed to be local - that is to say, registered with the LES by the client whose ATM address is leArpAtmAddress. For an entry created via the LE_ARP mechanism, this corresponds to the 'Remote address' flag being cleared in the LE_ARP_RESPONSE.")
leArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1, 4), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leArpEntryType.setStatus('current')
if mibBuilder.loadTexts: leArpEntryType.setDescription('Indicates how this LE_ARP table entry was created and whether it is aged.')
leArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 9, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leArpRowStatus.setStatus('current')
if mibBuilder.loadTexts: leArpRowStatus.setDescription("Lets users create and delete LE_ARP cache entries, on systems that support this capability. Normally clients will maintain their LE_ARP caches automatically. However, managers may occasionally want to create 'static' LE_ARP cache entries. Rules 1. Before a new row can become 'active', values must be supplied for the columnar objects leArpAtmAddress and leArpEntryType. 2. It is not necessary to set leArpRowStatus to 'notInService' in order to modify a writable object in the same conceptual row. 3. LE_ARP entries whose status is 'notReady' or 'notInService' will not be used to translate LAN Destinations to ATM Addresses. However, clients may overwrite such entries with data obtained from other sources. For example, a client which needed to transmit a data frame to a given MAC address (or via a given Route Descriptor) might find that its LE_ARP entry for the LAN Destination is 'notInService' or 'notReady'. The client might then act as if the LAN Destination was unknown - generating a LE_ARP_REQUEST, flooding the data frame to the BUS, and creating a new, 'active' LE_ARP cache entry based on the LE_ARP_RESPONSE.")
leRDArpTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10), )
if mibBuilder.loadTexts: leRDArpTable.setReference('ATM Forum LAN Emulation Over ATM Specification, Section 5.1.1')
if mibBuilder.loadTexts: leRDArpTable.setStatus('current')
if mibBuilder.loadTexts: leRDArpTable.setDescription("This table provides access to an ATM LAN Emulation Client's Route Descriptor-to-ATM ARP cache. Implementation of this table is optional for hosts that do not support emulated IEEE 802.5 Token Ring LANs, and mandatory for hosts which do. C16 LE_ARP Cache. A table of entries, each of which establishes a relationship between a LAN Destination external to the LE Client and the ATM address to which data frames for that LAN Destination will be sent.")
leRDArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "leRDArpSegmentID"), (0, "LAN-EMULATION-CLIENT-MIB", "leRDArpBridgeNumber"))
if mibBuilder.loadTexts: leRDArpEntry.setStatus('current')
if mibBuilder.loadTexts: leRDArpEntry.setDescription('An ATM LAN Emulation ARP cache entry containing information about the binding of one IEEE 802.5 route descriptor to one ATM address.')
leRDArpSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: leRDArpSegmentID.setStatus('current')
if mibBuilder.loadTexts: leRDArpSegmentID.setDescription('The LAN ID portion of the IEEE 802.5 route descriptor associated with this ARP cache entry.')
leRDArpBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: leRDArpBridgeNumber.setStatus('current')
if mibBuilder.loadTexts: leRDArpBridgeNumber.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this ARP cache entry.')
leRDArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1, 3), AtmLaneAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leRDArpAtmAddress.setStatus('current')
if mibBuilder.loadTexts: leRDArpAtmAddress.setDescription("The ATM address of the LAN Emulation Client which is associated with the route descriptor ('leRDArpSegmentID', 'leRDArpBridgeNumber'). This value may be determined through the use of the LE_ARP procedure, through source address learning, or through other mechanisms. Some agents may provide write access to this object, as part of their support for 'static' LE_ARP entries. The effect of attempting to write an ATM address to a 'learned' row is explicitly undefined. Agents may disallow the write, accept the write and change the row's type, or even accept the write as-is.")
leRDArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1, 4), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leRDArpEntryType.setStatus('current')
if mibBuilder.loadTexts: leRDArpEntryType.setDescription('Indicates how this LE_ARP table entry was created and whether it is aged.')
leRDArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 1, 10, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: leRDArpRowStatus.setStatus('current')
if mibBuilder.loadTexts: leRDArpRowStatus.setDescription("Lets users create and delete LE_ARP cache entries, on systems that support this capability. Normally clients will maintain their LE_ARP caches automatically. However, managers may occasionally want to create 'static' LE_ARP cache entries. Rules 1. Before a new row can become 'active', values must be supplied for the columnar objects leRDArpAtmAddress and leRDArpEntryType. 2. It is not necessary to set leRDArpRowStatus to 'notInService' in order to modify a writable object in the same conceptual row. 3. LE_ARP entries whose status is 'notReady' or 'notInService' will not be used to translate LAN Destinations to ATM Addresses. However, clients may overwrite such entries with data obtained from other sources. For example, a client which needed to transmit a data frame to a given MAC address (or via a given Route Descriptor) might find that its LE_ARP entry for the LAN Destination is 'notInService' or 'notReady'. The client might then act as if the LAN Destination was unknown - generating a LE_ARP_REQUEST, flooding the data frame to the BUS, and creating a new, 'active' LE_ARP cache entry based on the LE_ARP_RESPONSE.")
leClientMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2))
leClientMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1))
leClientMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 2))
leClientMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 2, 1)).setObjects(("LAN-EMULATION-CLIENT-MIB", "leClientConfigGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientStatusGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientMappingGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientStatisticsGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientServerVccGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientAtmAddressesGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientMacAddressesGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientArpGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientRouteDescriptorsGroup"), ("LAN-EMULATION-CLIENT-MIB", "leClientRDArpGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientMIBCompliance = leClientMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: leClientMIBCompliance.setDescription("The compliance statement for SNMP entities which support ATM LAN Emulation Clients. For a host to conform to this MIB, it must also implement - RFC 1213 - MIB II. - Interfaces table entries for each LE Client, as per the LAN Emulation Client management specification. - The AToM MIB (RFC 1695 - Definitions of Managed Objects for ATM Management), according to the conformance statements defined in that RFC. Optionally, a host may implement - RFC 1573 - Evolution of the Interfaces Group of MIB-II. - The 'ifRcvAddressGroup' from RFC 1573, which provides a way to represent and configure interfaces with multiple addresses. See the LAN Emulation Client management specification for interpretations of RFC 1573 / MIB-II as they apply to LAN Emulation Clients.")
leClientConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 1)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecRowStatus"), ("LAN-EMULATION-CLIENT-MIB", "lecOwner"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigMode"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigLanType"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigMaxDataFrameSize"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigLanName"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigLesAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "lecControlTimeout"), ("LAN-EMULATION-CLIENT-MIB", "lecMaxUnknownFrameCount"), ("LAN-EMULATION-CLIENT-MIB", "lecMaxUnknownFrameTime"), ("LAN-EMULATION-CLIENT-MIB", "lecVccTimeoutPeriod"), ("LAN-EMULATION-CLIENT-MIB", "lecMaxRetryCount"), ("LAN-EMULATION-CLIENT-MIB", "lecAgingTime"), ("LAN-EMULATION-CLIENT-MIB", "lecForwardDelayTime"), ("LAN-EMULATION-CLIENT-MIB", "lecExpectedArpResponseTime"), ("LAN-EMULATION-CLIENT-MIB", "lecFlushTimeOut"), ("LAN-EMULATION-CLIENT-MIB", "lecPathSwitchingDelay"), ("LAN-EMULATION-CLIENT-MIB", "lecLocalSegmentID"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendType"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendAvgRate"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendPeakRate"), ("LAN-EMULATION-CLIENT-MIB", "lecConnectionCompleteTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientConfigGroup = leClientConfigGroup.setStatus('current')
if mibBuilder.loadTexts: leClientConfigGroup.setDescription('A collection of objects used for creating and configuring LAN Emulation Clients.')
leClientStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 2)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecIfIndex"), ("LAN-EMULATION-CLIENT-MIB", "lecPrimaryAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "lecID"), ("LAN-EMULATION-CLIENT-MIB", "lecInterfaceState"), ("LAN-EMULATION-CLIENT-MIB", "lecLastFailureRespCode"), ("LAN-EMULATION-CLIENT-MIB", "lecLastFailureState"), ("LAN-EMULATION-CLIENT-MIB", "lecProtocol"), ("LAN-EMULATION-CLIENT-MIB", "lecVersion"), ("LAN-EMULATION-CLIENT-MIB", "lecTopologyChange"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigServerAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigSource"), ("LAN-EMULATION-CLIENT-MIB", "lecActualLanType"), ("LAN-EMULATION-CLIENT-MIB", "lecActualMaxDataFrameSize"), ("LAN-EMULATION-CLIENT-MIB", "lecActualLanName"), ("LAN-EMULATION-CLIENT-MIB", "lecActualLesAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "lecProxyClient"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientStatusGroup = leClientStatusGroup.setStatus('current')
if mibBuilder.loadTexts: leClientStatusGroup.setDescription('A collection of objects describing the status and operational parameters of the managed LAN Emulation Clients.')
leClientMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 3)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecMappingIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientMappingGroup = leClientMappingGroup.setStatus('current')
if mibBuilder.loadTexts: leClientMappingGroup.setDescription("A collection of objects which map a LAN Emulation Client's 'ifIndex' to its 'lecIndex'.")
leClientStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 4)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecArpRequestsOut"), ("LAN-EMULATION-CLIENT-MIB", "lecArpRequestsIn"), ("LAN-EMULATION-CLIENT-MIB", "lecArpRepliesOut"), ("LAN-EMULATION-CLIENT-MIB", "lecArpRepliesIn"), ("LAN-EMULATION-CLIENT-MIB", "lecControlFramesOut"), ("LAN-EMULATION-CLIENT-MIB", "lecControlFramesIn"), ("LAN-EMULATION-CLIENT-MIB", "lecSvcFailures"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientStatisticsGroup = leClientStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: leClientStatisticsGroup.setDescription('A collection of objects which act as an extension to the lecConfigTable. These objects provide statistics on LAN Emulation control traffic and SVC establishment.')
leClientServerVccGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 5)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecConfigDirectInterface"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigDirectVpi"), ("LAN-EMULATION-CLIENT-MIB", "lecConfigDirectVci"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDirectInterface"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDirectVpi"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDirectVci"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDistributeInterface"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDistributeVpi"), ("LAN-EMULATION-CLIENT-MIB", "lecControlDistributeVci"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendInterface"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendVpi"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastSendVci"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastForwardInterface"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastForwardVpi"), ("LAN-EMULATION-CLIENT-MIB", "lecMulticastForwardVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientServerVccGroup = leClientServerVccGroup.setStatus('current')
if mibBuilder.loadTexts: leClientServerVccGroup.setDescription('A collection of objects which act as an extension to the lecConfigTable. These objects identify Configuration Direct, Control, and Multicast VCCs for each client, making it easier to locate their entries in the AToM MIB.')
leClientAtmAddressesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 6)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecAtmAddressStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientAtmAddressesGroup = leClientAtmAddressesGroup.setStatus('current')
if mibBuilder.loadTexts: leClientAtmAddressesGroup.setDescription('A collection of objects which describe all of the ATM addresses belonging to each client.')
leClientMacAddressesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 7)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecMacAddressAtmBinding"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientMacAddressesGroup = leClientMacAddressesGroup.setStatus('current')
if mibBuilder.loadTexts: leClientMacAddressesGroup.setDescription('A collection of objects which describe all of the MAC addresses registered for each client.')
leClientRouteDescriptorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 8)).setObjects(("LAN-EMULATION-CLIENT-MIB", "lecRouteDescrAtmBinding"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientRouteDescriptorsGroup = leClientRouteDescriptorsGroup.setStatus('current')
if mibBuilder.loadTexts: leClientRouteDescriptorsGroup.setDescription('A collection of objects which describe all of the Route Descriptors registered for each client.')
leClientArpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 9)).setObjects(("LAN-EMULATION-CLIENT-MIB", "leArpAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "leArpIsRemoteAddress"), ("LAN-EMULATION-CLIENT-MIB", "leArpEntryType"), ("LAN-EMULATION-CLIENT-MIB", "leArpRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientArpGroup = leClientArpGroup.setStatus('current')
if mibBuilder.loadTexts: leClientArpGroup.setDescription('A collection of objects which describe the MAC- to-ATM address mappings that this LAN Emulation Client has learned.')
leClientRDArpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 3, 1, 2, 1, 10)).setObjects(("LAN-EMULATION-CLIENT-MIB", "leRDArpAtmAddress"), ("LAN-EMULATION-CLIENT-MIB", "leRDArpEntryType"), ("LAN-EMULATION-CLIENT-MIB", "leRDArpRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    leClientRDArpGroup = leClientRDArpGroup.setStatus('current')
if mibBuilder.loadTexts: leClientRDArpGroup.setDescription('A collection of objects which describe the IEEE 802.5 Route Descriptor-to-ATM address mappings that this LAN Emulation Client has learned.')
mibBuilder.exportSymbols("LAN-EMULATION-CLIENT-MIB", leClientServerVccGroup=leClientServerVccGroup, lecForwardDelayTime=lecForwardDelayTime, lecMulticastSendInterface=lecMulticastSendInterface, leClientRouteDescriptorsGroup=leClientRouteDescriptorsGroup, leArpMacAddress=leArpMacAddress, lecVccTimeoutPeriod=lecVccTimeoutPeriod, lecConfigServerAtmAddress=lecConfigServerAtmAddress, lecConfigMode=lecConfigMode, leClientMIBCompliances=leClientMIBCompliances, leClientMacAddressesGroup=leClientMacAddressesGroup, lecAtmAddress=lecAtmAddress, leClientAtmAddressesGroup=leClientAtmAddressesGroup, lecSvcFailures=lecSvcFailures, lecActualLanType=lecActualLanType, lecServerVccEntry=lecServerVccEntry, lecProxyClient=lecProxyClient, lecConfigDirectInterface=lecConfigDirectInterface, lecStatusEntry=lecStatusEntry, lecConfigEntry=lecConfigEntry, lecAtmAddressStatus=lecAtmAddressStatus, lecConfigLesAtmAddress=lecConfigLesAtmAddress, leRDArpBridgeNumber=leRDArpBridgeNumber, lecControlDistributeVci=lecControlDistributeVci, leClientMIBConformance=leClientMIBConformance, LecState=LecState, lecMulticastSendType=lecMulticastSendType, leArpTable=leArpTable, lecIfIndex=lecIfIndex, leClientStatisticsGroup=leClientStatisticsGroup, lecPrimaryAtmAddress=lecPrimaryAtmAddress, lecControlFramesOut=lecControlFramesOut, leClientMIBGroups=leClientMIBGroups, PYSNMP_MODULE_ID=leClientMIB, lecConfigSource=lecConfigSource, lecVersion=lecVersion, lecControlFramesIn=lecControlFramesIn, lecMaxUnknownFrameCount=lecMaxUnknownFrameCount, leClientMIBCompliance=leClientMIBCompliance, lecActualMaxDataFrameSize=lecActualMaxDataFrameSize, lecAgingTime=lecAgingTime, lecLastFailureState=lecLastFailureState, lecID=lecID, lecMacAddressEntry=lecMacAddressEntry, VciInteger=VciInteger, lecConfigLanType=lecConfigLanType, lecControlDistributeInterface=lecControlDistributeInterface, lecTopologyChange=lecTopologyChange, lecServerVccTable=lecServerVccTable, lecConnectionCompleteTimer=lecConnectionCompleteTimer, lecOwner=lecOwner, leArpIsRemoteAddress=leArpIsRemoteAddress, LeArpTableEntryType=LeArpTableEntryType, lecMacAddress=lecMacAddress, leRDArpEntryType=leRDArpEntryType, OwnerString=OwnerString, lecConfigDirectVpi=lecConfigDirectVpi, lecMulticastForwardInterface=lecMulticastForwardInterface, lecMappingTable=lecMappingTable, lecArpRepliesIn=lecArpRepliesIn, lecRouteDescrEntry=lecRouteDescrEntry, lecStatusTable=lecStatusTable, lecProtocol=lecProtocol, lecControlDistributeVpi=lecControlDistributeVpi, lecFlushTimeOut=lecFlushTimeOut, leRDArpSegmentID=leRDArpSegmentID, atmfLanEmulation=atmfLanEmulation, lecAtmAddressTable=lecAtmAddressTable, lecMulticastSendVci=lecMulticastSendVci, lecMulticastForwardVpi=lecMulticastForwardVpi, lecConfigTable=lecConfigTable, leArpEntry=leArpEntry, lecMacAddressTable=lecMacAddressTable, leRDArpTable=leRDArpTable, lecMulticastSendVpi=lecMulticastSendVpi, leClientMappingGroup=leClientMappingGroup, LecDataFrameSize=LecDataFrameSize, lecArpRepliesOut=lecArpRepliesOut, lecRouteDescrBridgeNumber=lecRouteDescrBridgeNumber, lecMulticastSendPeakRate=lecMulticastSendPeakRate, lecStatisticsTable=lecStatisticsTable, lecConfigLanName=lecConfigLanName, lecRouteDescrTable=lecRouteDescrTable, lecMulticastSendAvgRate=lecMulticastSendAvgRate, lecStatisticsEntry=lecStatisticsEntry, lecControlDirectInterface=lecControlDirectInterface, lecActualLanName=lecActualLanName, lecMacAddressAtmBinding=lecMacAddressAtmBinding, leClientRDArpGroup=leClientRDArpGroup, lecLastFailureRespCode=lecLastFailureRespCode, leClientStatusGroup=leClientStatusGroup, lecIndex=lecIndex, lecControlDirectVpi=lecControlDirectVpi, lecRouteDescrAtmBinding=lecRouteDescrAtmBinding, lecArpRequestsIn=lecArpRequestsIn, LecDataFrameFormat=LecDataFrameFormat, lecExpectedArpResponseTime=lecExpectedArpResponseTime, lecMulticastForwardVci=lecMulticastForwardVci, lecConfigDirectVci=lecConfigDirectVci, lecLocalSegmentID=lecLocalSegmentID, lecActualLesAtmAddress=lecActualLesAtmAddress, leClientMIB=leClientMIB, leClientMIBObjects=leClientMIBObjects, LeConnectionInterface=LeConnectionInterface, lecInterfaceState=lecInterfaceState, lecMaxRetryCount=lecMaxRetryCount, VpiInteger=VpiInteger, lecPathSwitchingDelay=lecPathSwitchingDelay, leArpRowStatus=leArpRowStatus, leClientConfigGroup=leClientConfigGroup, lecMappingEntry=lecMappingEntry, AtmLaneAddress=AtmLaneAddress, leRDArpAtmAddress=leRDArpAtmAddress, leRDArpRowStatus=leRDArpRowStatus, lecControlDirectVci=lecControlDirectVci, leRDArpEntry=leRDArpEntry, leArpEntryType=leArpEntryType, lecRouteDescrSegmentID=lecRouteDescrSegmentID, lecConfigMaxDataFrameSize=lecConfigMaxDataFrameSize, leClientArpGroup=leClientArpGroup, leArpAtmAddress=leArpAtmAddress, lecArpRequestsOut=lecArpRequestsOut, lecMaxUnknownFrameTime=lecMaxUnknownFrameTime, lecMappingIndex=lecMappingIndex, lecRowStatus=lecRowStatus, lecControlTimeout=lecControlTimeout, lecAtmAddressEntry=lecAtmAddressEntry)

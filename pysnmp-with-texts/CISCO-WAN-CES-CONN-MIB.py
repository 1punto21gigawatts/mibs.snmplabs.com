#
# PySNMP MIB module CISCO-WAN-CES-CONN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-CES-CONN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
circuitEmulation, cesmChan = mibBuilder.importSymbols("BASIS-MIB", "circuitEmulation", "cesmChan")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
iso, Counter64, ModuleIdentity, Gauge32, ObjectIdentity, NotificationType, IpAddress, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Unsigned32, Integer32, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "ModuleIdentity", "Gauge32", "ObjectIdentity", "NotificationType", "IpAddress", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Unsigned32", "Integer32", "MibIdentifier", "Counter32")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
ciscoWanCesConnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 42))
ciscoWanCesConnMIB.setRevisions(('2002-09-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanCesConnMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanCesConnMIB.setLastUpdated('200209180000Z')
if mibBuilder.loadTexts: ciscoWanCesConnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanCesConnMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanCesConnMIB.setDescription('The MIB module to configure the Circuit Emulation connections in MGX82xx series products. Terminology: CES : Circuit Emulation Service. The CES defines a method of carrying a traffic from non-ATM telephony devices over an ATM cloud. The CES provides an interworking function(IWF) that allows the two protocols to communicate. channel , endpoint : channel and connection endpoint have same meaning and are used interchangebly. DAX Connection : Digital Access and Cross-connect connection is a connection where master and slave endpoints are with in the same MGX shelf. CAS : Channel Associated Signaling. This is in-band signaling. CCS : Common Channel Signaling. This is is out-of-band signaling.')
cesmChanCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1))
cesmChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1), )
if mibBuilder.loadTexts: cesmChanCnfGrpTable.setStatus('current')
if mibBuilder.loadTexts: cesmChanCnfGrpTable.setDescription('This table contains the configuration information for connection endpoints.')
cesmChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-CES-CONN-MIB", "cesCnfChanNum"))
if mibBuilder.loadTexts: cesmChanCnfGrpEntry.setStatus('current')
if mibBuilder.loadTexts: cesmChanCnfGrpEntry.setDescription('An entry in the cesmChanCnfGrpTable. The each entry corresponds to a connection endpoint identified by following objects: - cesCnfChanNum : Channel Number - cesChanPortNum: Logical Port Number - VPI/VCI value for local/remote endpoints - NSAP Addresses for local/remote endpoints.')
cesCnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 2064))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCnfChanNum.setStatus('current')
if mibBuilder.loadTexts: cesCnfChanNum.setDescription('This object identifies the channel number of the CESM channel. For CESM-4P the range is 16..19 (only for 4 entries). For CESM-8t1 the range is 16..192 For CESM-8e1 the range is 16..248. For CESM-T3/E3 the range is 16..16. For CESM-T1/E1/T3/E3, channel number starts from 35 in Release2.2.')
cesChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanRowStatus.setStatus('current')
if mibBuilder.loadTexts: cesChanRowStatus.setDescription("This object is used to create,modify or delete an entry in the table. A row need to be created using 'add' option. When the row is successfully created, this object would be set to 'mod' by the agent. Following mandatory objects need to be specified for the successful creation of the row(both master and slave endpoints). cesConnServiceType cesVpcFlag cesMastership Following mandatory objects need to be specified for creation of master endpoint: cesRemoteVpi cesRemoteVci cesRemoteNSAP A row can be deleted by setting this object to 'delete'. A row can be modified by setting this object to 'mod'. When there is a need to administratively down the channel this object could be set to 'outOfService'. The channel could be made active by setting this object to 'mod'.")
cesMapPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapPortNum.setStatus('current')
if mibBuilder.loadTexts: cesMapPortNum.setDescription('This object provides the mapping from CES channel number and physical line number. In case of CESM-4P this variable specifies the port number to which this channel is associated. Mappings are as follows: Port 1 - channel 16, 2-17, 3-18, 4-19 (it can take value from 1..4) In CESM-8 this variable gives mapping between logical channel and physical line number. In case of CESM-8P instead of this cesChanPortNum will be used to have the mapping between Channel and logical Port. In case of CESM-T3 it can be 1..1.')
cesMapVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapVpi.setStatus('current')
if mibBuilder.loadTexts: cesMapVpi.setDescription('The value of this object is equal to the VPI used for the emulated circuit represented by this connection. In MGX8220( formerly AXIS) Implementaion slot number of the card will be used for this.')
cesMapVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 2064))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapVci.setStatus('current')
if mibBuilder.loadTexts: cesMapVci.setDescription('This specifies VCI for emulated circuit represented by this VC. Our Implementation cesCnfChanNum will be used for this. In case of CESM-4P valid range is 16..19. In case of CESM-8P valid range is 32..279. In case of CESM-T3/E3 valid value is 32.')
cesCBRService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unstructured", 1), ("structured", 2))).clone('unstructured')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCBRService.setStatus('current')
if mibBuilder.loadTexts: cesCBRService.setDescription("This specifies data type supported by the CBR service. unstructured(1) : This is also known as 'clear channel'. This service utilizes the entire T1 bandwidth. The switch does not look into the T1, but simply reproduces a stream of bits with clocking from the receiving port to the target port. structured(2) : This is also known as channelized T1 or cross-connect. This provides emulation point-to-point fractional T1(Nx64) connections. This aloows the T1 to break into multiple DS-0 channels towards different destinations. More than one circuit(AAL1) entity will share the same physical T1 interface. To provide this service, AAL1 is capable of delineating repetitive fixed-size blocks of data. The card limitations: - CESM-4P supports only Unstructured mode. - CESM-8P supports both structured and unstructured mode for T1/E1 - CESM-8P supports unstructured mode for T3/E3 - CESM-T3 supports only unstructured mode.")
cesCBRClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("synchronous", 1), ("srts", 2), ("adaptive", 3))).clone('synchronous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCBRClockMode.setStatus('current')
if mibBuilder.loadTexts: cesCBRClockMode.setDescription('This specifies clocking mode of the CBR service. synchronous(1) : The transmit clock frequency is produced by an external source. srts (2) : Synchronous Residual TimeStamp(SRTS) is an asnychronous clocking method. The SRTS measures the difference between the service clock(received on the CBR interface) and the network-wide reference clock. The difference is the Residual Time Stamp(RTS). The RTS is propogated to the remote end of the circuit in the AAL1 header. The receiving end reconstructs the clock by adjusting the reference clock by RTS value. adaptive(3) : In adaptive clocking, the source CES IWF simply sends data to the destination CES IWF. The destination CES IWF writes data to the segmentation and re-assembly(SAR) buffer reads it with local T1 service clock. The local (interface) service clock is determined from the actual CBR data received. Only synchronous(1) mode is supported in CESM-4P and CESM-T3.')
cesCas = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("basic", 1), ("e1Cas", 2), ("ds1SfCas", 3), ("ds1EsfCas", 4), ("ccs", 5), ("conditionedE1Cas", 6), ("basicNoPointer", 7), ("ds1SfCasMF", 8), ("ds1EsfCasMF", 9))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCas.setStatus('current')
if mibBuilder.loadTexts: cesCas.setDescription('This object specifies whether CAS bits are carried by the service. This also selects which AAL1 format should be used. The possible values are : basic(1) : for 1x64 connections, cells will be generated with a AAL1 pointer. While receiving, pointer will be expected in the incoming cells. ds1SfCas (3), ds1EsfCas (4): used when line level multiframe sync to be enabled. ccs(5) : Common Channel Signaling. This particular VC is carrying signaling information. This value is not supported in CESM-8T1E1. basicNoPointer(7): 1x64 basic connections without AAL1 pointer. This is to support CES-IS 2.0 compliance. In CESM-8T1/E1 all channels on a line should have the same value. The value basic(1) is applicable for cesCBRService value of unstructured(1). The CESM-4P and CESM-T3E3 cards support value basic(1) only.')
cesPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPartialFill.setStatus('current')
if mibBuilder.loadTexts: cesPartialFill.setDescription('Specifies the number of user octets per cell, if partial cell fill is used. 47 means partial fill disabled. Partial fill is not supported in CESM-4P Ranges for partial fill are: T1 struct 25 - 47 T1 unstruct 33 - 47 E1 struct 20 - 47 E1 unstruct 33 - 47 and partial fill for any channel should always exceed the number of time slots assigned to that channel.')
cesBufMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesBufMaxSize.setStatus('current')
if mibBuilder.loadTexts: cesBufMaxSize.setDescription('Specifies the maximum size in octets of egress buffer. CESM - 4P: Should be at least 0.6*CDVRxT for a T1 line and 0.7 * CDVRxT for a E1 line. 0 can be specified to internally compute the value Defaults for CESM-8T1E1 and CESM-T3E3 ------------------------------------- Default value of cesBufMaxSize is 0. Maximum value for CESM-8T1E1 and CESM-T3E3 ------------------------------------------- For T1 UDT and E1 UDT : 16224 bytes For T1 SDT : 384 * N bytes For E1 SDT : 417 * N bytes For T3 UDT and E3 UDT : 16224 bytes where N is the number of timeslots assigned in Nx64 connection. For T1-UDT and E1 UDT use N = 32 . Minimum value for CESM-8T1E1 and CESM-T3E3 ------------------------------------------- In CESM-8T1/E1 and CESM-T3E3 this object ( unit in bytes ) should be at least the greater of (1) CDVT in frames * 2 * N (2) ( CDVT in frames + number of frames in two cells ) * N where N is the number of timeslots assigned in Nx64 connection. For T1-UDT and E1-UDT use N = 32. ')
cesCDVRxT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(125, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCDVRxT.setStatus('current')
if mibBuilder.loadTexts: cesCDVRxT.setDescription('This object specifies maximum cell arrival jitter that the reassembly process will tolerate. In case of CESM-8P it should be in increment of 125 micro secs and Max limit are as follows. T1 = 24 ms E1 = 26 ms T3 = 1.447 ms and E3 = 1.884 ms. Default values in CESM-8T1/E1 and CESM-T3/E3.: For T1 and E1 , 1000 microsecs. For T3 and E3 , 1000 microsecs.')
cesCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535))).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setStatus('current')
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setDescription('This object specifies the cell loss integration period.')
cesChanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanLocRmtLpbkState.setStatus('current')
if mibBuilder.loadTexts: cesChanLocRmtLpbkState.setDescription('Loopback on cellbus in egress direction.')
cesChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3), ("testconsti", 4), ("testdelaysti", 5))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanTestType.setStatus('current')
if mibBuilder.loadTexts: cesChanTestType.setDescription('This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = no test is initated 4 = test continuity with sti cell format 5 = test delay with sti cell format ')
cesChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanTestState.setStatus('current')
if mibBuilder.loadTexts: cesChanTestState.setDescription('This shows the state of the test 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
cesChanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanRTDResult.setStatus('current')
if mibBuilder.loadTexts: cesChanRTDResult.setDescription('This is round trip delay time.')
cesChanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanPortNum.setStatus('current')
if mibBuilder.loadTexts: cesChanPortNum.setDescription("This object refers to the CES logical port on which channel is created. The value for this object must be same as the 'cesPortNum' object from cesmPortCnfGrpTable. This is a mandatory object for creating the channel.")
cesChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("spvc", 3))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanConnType.setStatus('current')
if mibBuilder.loadTexts: cesChanConnType.setDescription('This object identifies the type of the connection. The possible values are : pvc(1) : Permanent Virtual Connection svc(2) : Switched Virtual Connection spvc(3) : Soft PVC Only applicable to CESM-8P and CESM-T3/E3. This object can be specified only during row creation.')
cesChanStrauSciNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonStrauChannel", 1), ("sci1", 2), ("sci2", 3), ("sci3", 4), ("sci4", 5))).clone('nonStrauChannel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanStrauSciNum.setStatus('current')
if mibBuilder.loadTexts: cesChanStrauSciNum.setDescription('This indicates the type of connection. 1 = Normal Channel (nonStrauChannel(0) ) 2 = SCI 1 i.e bit 1 & 2 3 = SCI 2 i.e bit 3 & 4 4 = SCI 3 i.e bit 5 & 6 5 = SCI 4 i.e bit 7 & 8 Currently not supported in CESM-8 Not applicable for CESM-4 and CESM-T3/E3 ')
cesChanIdleDetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enableOnhookDet", 2), ("enableIdlePatternDet", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleDetEnable.setStatus('current')
if mibBuilder.loadTexts: cesChanIdleDetEnable.setDescription("This indicates the type of Idle detection enabled disable(1) : Idle code detection is disabled. enableOnhookDet(2) : Enable Idle detection whenver it detects Onhook in ABCD bits(of T1 frame). The on hook code is configurable using 'cesChanOnhookCode' object. Applicable in structured mode. enableIdlePatternDet(3): Enable payload Idle code detection. Idle pattern is configurable through cesChanIdleSignalCode object. Only applicable to CESM-8T1/E1 and non strau channels.")
cesChanIdleSignalCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleSignalCode.setStatus('current')
if mibBuilder.loadTexts: cesChanIdleSignalCode.setDescription('This object identifies the signal code to be sent. The value indicates the idle pattern in DS0 time slots. This object is applicable only when cesChanIdleDetEnable object is set to enableIdlePatternDet(3).')
cesChanIdleCodeIntgnPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleCodeIntgnPeriod.setStatus('current')
if mibBuilder.loadTexts: cesChanIdleCodeIntgnPeriod.setDescription('This object indicates the Integration period in seconds This object is applicable only when cesChanIdleDetEnable is set to enableIdlePatternDet(3).')
cesChanOnhookCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanOnhookCode.setStatus('current')
if mibBuilder.loadTexts: cesChanOnhookCode.setDescription('This object identifies the on-hook code to be sent. This object is applicable only when cesChanIdleDetEnable object is set to enableOnhookDet(2). The value 0..3 is applicable for T1 with framing mode set to super frame(SF). The value 0..15 is applicable for T1 with framing mode set to Extended Super Frame(ESF)/E1 CAS. Only applicable for CESM-8T1/E1.')
cesChanConditionedData = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanConditionedData.setStatus('current')
if mibBuilder.loadTexts: cesChanConditionedData.setDescription('This byte will indicate Idle data to be sent towards the line whenever channels goes in to Underrun Only applicable for CESM-8T1/E1.')
cesmChanExtTrgIdleSupp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disablesuppression", 1), ("enableSuppresion", 2))).clone('disablesuppression')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanExtTrgIdleSupp.setStatus('current')
if mibBuilder.loadTexts: cesmChanExtTrgIdleSupp.setDescription('This object is used for disabling/enabling idle suppression on the connection. This can be set by external signalling device. Only applicable to CESM-8T1/E1.')
cesmChanConditionedSigCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanConditionedSigCode.setStatus('current')
if mibBuilder.loadTexts: cesmChanConditionedSigCode.setDescription('This byte will indicate Signal code to be sent sent towards the line whenever channels goes in to Underrun Only applicable to CESM-8T1/E1.')
cesLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLocalVpi.setStatus('current')
if mibBuilder.loadTexts: cesLocalVpi.setDescription('This object identifies the internal VPI assigned to a local endpoint, by the switch. The cesLocalVpi, cesLocalVci and cesLocalNSAP form a unique identifier for the local connection endpoint.')
cesLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLocalVci.setStatus('current')
if mibBuilder.loadTexts: cesLocalVci.setDescription('This object identifies the internal VCI assigned to a local endpoint, by the switch. The cesLocalVpi, cesLocalVci and cesLocalNSAP form a unique identifier for the local connection endpoint.')
cesLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesLocalNSAP.setStatus('current')
if mibBuilder.loadTexts: cesLocalNSAP.setDescription('This object identifies the internal NSAP address assigned to local endpoint. The NSAP address is 20 bytes long and follows the format: - 13 bytes as prefix 2 bytes for Cisco ID, - 2 bytes for Cisco ID - 1 byte reserved - 3 bytes for logical interface (slot:1 bytes,port number:2 bytes) - 1 byte is for Selector (SEL).')
cesRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: cesRemoteVpi.setDescription('This object identifies the VPI value of the peer endpoint. The cesRemoteVpi, cesRemoteVci and the cesRemoteNSAP identify the peer endpoint(remote) in the networking domain. The value should be 0 for a DAX connection within the switch. This object can be set only during row creation.')
cesRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteVci.setStatus('current')
if mibBuilder.loadTexts: cesRemoteVci.setDescription('This object identifies the VCI value of the peer endpoint. The cesRemoteVpi, cesRemoteVci and the cesRemoteNSAP identify the peer endpoint(remote) in the networking domain. The value should be 0 for a DACS connection within the switch. This object can be set only during row creation.')
cesRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 32), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteNSAP.setStatus('current')
if mibBuilder.loadTexts: cesRemoteNSAP.setDescription('This object identifies the NSAP address of the peer endpoint. The NSAP address is 20 bytes long and follows the format: - 13 bytes as prefix 2 bytes for Cisco ID, - 2 bytes for Cisco ID - 1 byte reserved - 3 bytes for logical interface (slot:1 bytes,port number:2 bytes) - 1 byte is for Selector(SEL).')
cesMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unkown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesMastership.setStatus('current')
if mibBuilder.loadTexts: cesMastership.setDescription('This is used by PXM to determine if this end point is master or slave, a new type unknown(3) is added to identify the SM in MGX8220(formerly AXIS) shelf and the SM in MGX8250 shelf. In MGX8220 shelf, user can create endpoints without specifying X/Y/P parameters. In MGX8250 shelf, the user can not add endpoint with value of this object set to unknown(3). This object can be set only during row creation.')
cesVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesVpcFlag.setStatus('current')
if mibBuilder.loadTexts: cesVpcFlag.setDescription("This represents the connection type, used for PXM to identify VPC/VCC but CESM card doesn't use it always set to vcc for CESM card.")
cesConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7), ("cbr1", 21), ("vbr1rt", 22), ("vbr2rt", 23), ("vbr3rt", 24), ("vbr1nrt", 25), ("vbr2nrt", 26), ("vbr3nrt", 27), ("ubr1", 28), ("ubr2", 29), ("stdabr", 30), ("cbr2", 31), ("cbr3", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnServiceType.setStatus('current')
if mibBuilder.loadTexts: cesConnServiceType.setDescription('This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Not used 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR Note that the value of this object is used by PXM card. The default value is cbr1(21). The following types are being added for PNNI support and are based on UNI 4.0. cbr1 (21) - CBR.1 vbr1rt (22) - Real time VBR.1 vbr2rt (23) - Real time VBR.2 vbr3rt (24) - Real time VBR.3 vbr1nrt(25) - Non Real time VBR.1 vbr2nrt(26) - Non Real time VBR.2 vbr3nrt(27) - Non Real time VBR.3 ubr1 (28) - UBR.1 ubr2 (29) - UBR.2 stdabr (30) - TM 4.0 compliant standard ABR cbr2 (31) - CBR.2 cbr3 (32) - CBR.3 Note that for CESM, the only valid connection type for PNNI support is cbr1(21). Other enumerations have been added for the sake of consistency across Narrow-Band service modules. This object can be set only during row creation.')
cesRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRoutingPriority.setStatus('current')
if mibBuilder.loadTexts: cesRoutingPriority.setDescription('This is used by PXM to determine how important this connection is when selecting connections to route.')
cesMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesMaxCost.setStatus('current')
if mibBuilder.loadTexts: cesMaxCost.setDescription("This object is used by the networking entity to select a route based on administrative weight of possible routes. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. This is not necessary to be provided in the connection setup request, if not provided, the default value 255 will be used. When used with PAR controller the valid range is 1..65535 and the default value is 255. When used with PNNI controller the valid range is 1..2147483647 and the default value is 2147483647. ")
cesRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noresriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRestrictTrunkType.setStatus('current')
if mibBuilder.loadTexts: cesRestrictTrunkType.setDescription('Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. It is not necessary to be provide in the connection setup request, the default value is noresriction(1).')
cesConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnPCR.setStatus('current')
if mibBuilder.loadTexts: cesConnPCR.setDescription('This object identifies the Peak Cell Rate(PCR) value. If not provided during the row creation, the value will be computed as follows, For CESM-8T1/E1 - N * 64 Kbps , where N = Number of timeslots assigned to this channel. For CESM-T3, the value is 44736 Kbps For CESM-E3, the value is 34368 Kbps.')
cesConnMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnMCR.setStatus('current')
if mibBuilder.loadTexts: cesConnMCR.setDescription('This object identifies the Minimum Cell Rate(MCR) value. If not provided during the row creation, the value will be computed as follows, For CESM-8T1/E1 - N * 64 Kbps , where N = Number of timeslots assigned to this channel. For CESM-T3, the value is 44736 Kbps For CESM-E3, the value is 34368 Kbps.')
cesConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnPercentUtil.setStatus('current')
if mibBuilder.loadTexts: cesConnPercentUtil.setDescription('This is the expected long-term utilization of the channel by theis end-point. For CESM-8T1/E1/T3/E3 , the value is 100%')
cesmConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemotePCR.setStatus('current')
if mibBuilder.loadTexts: cesmConnRemotePCR.setDescription('The PCR value of the remote end. If not set, the value for this object is derived from the end point parameter.')
cesmConnRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemoteMCR.setStatus('current')
if mibBuilder.loadTexts: cesmConnRemoteMCR.setDescription('The MCR value of the remote end. If not set, the value for this object is derived from the end point parameter.')
cesmConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemotePercentUtil.setStatus('current')
if mibBuilder.loadTexts: cesmConnRemotePercentUtil.setDescription('This is the expected long-term utilization of the channel by the other end-point.')
cesmConnForeSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnForeSightEnable.setStatus('current')
if mibBuilder.loadTexts: cesmConnForeSightEnable.setDescription('This object is used by the controller(PAR/PNNI/TAG) to set up the Qbin for the connection. This is notapplicable to CESM-8T1/E1/T3/E3. ')
cesmConnFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnFGCRAEnable.setStatus('current')
if mibBuilder.loadTexts: cesmConnFGCRAEnable.setDescription('enables/disables Frame based GCRA (early packet discard). This is not applicable to CESM-8T1/E1/T3/E3.')
cesmChanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanReroute.setStatus('current')
if mibBuilder.loadTexts: cesmChanReroute.setDescription('This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). This object is not applicable to MGX Release 1.x. ')
cesmConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cesmConnAdminStatus.setDescription('This object specifies administrative status of the connection endpoint. This object is not applicable to MGX Release 1.x.')
cesmChanPrefRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanPrefRouteId.setStatus('current')
if mibBuilder.loadTexts: cesmChanPrefRouteId.setDescription("This object serves to to associate a preferred route with a connection. The value '0' means no preferred route is associated with this connection. Usage: - If the value of this set to 0, the object cesmChanDirectRoute is automatically set to FALSE by the switch. - The preferred route is defined in cwaPrefRouteConfTable object. ")
cesmChanDirectRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 50), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanDirectRoute.setStatus('current')
if mibBuilder.loadTexts: cesmChanDirectRoute.setDescription('This object serves to associate a prefer route as directed route (correspond to the prefer route object cesmChanPrefRouteId). A directed route specifies that the associated preferred route is the only permission route for the connection to take. Should the associated preferred route be unavailable, the connection is failed. The object is not applicable if there is no associated preferred route with the connection.')
cesmChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesmChanNumNextAvailable.setStatus('current')
if mibBuilder.loadTexts: cesmChanNumNextAvailable.setDescription('This variable contains the next unused channel number of the possible 248. This number can be used in channel config table. cesChanNumNextAvailable gets updated whenever this number is used to create a new logical channel. Value 0 for this variable indicates that no more channels are available. In CESM 8-port card), the maximum number of values for this variable is 248 (i.e. 32 ..279). Only applicable to CESM-8T1/E1/T3/E3. ')
cesmEndPtMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3))
cesmEndPtMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1), )
if mibBuilder.loadTexts: cesmEndPtMapGrpTable.setStatus('current')
if mibBuilder.loadTexts: cesmEndPtMapGrpTable.setDescription('This is the Endpoint mapping table for CES connection.')
cesmEndPtMapGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-CES-CONN-MIB", "cesEndPortNum"))
if mibBuilder.loadTexts: cesmEndPtMapGrpEntry.setStatus('current')
if mibBuilder.loadTexts: cesmEndPtMapGrpEntry.setDescription('An entry for cesmEndPtMapGrpEntry.')
cesEndPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndPortNum.setStatus('current')
if mibBuilder.loadTexts: cesEndPortNum.setDescription("This object identifies the CES logical port. The value for this object must be same as 'cesPortNum' object from cesmPortCnfGrpTable.")
cesEndChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 2080))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndChanNum.setStatus('current')
if mibBuilder.loadTexts: cesEndChanNum.setDescription("This object identifies the CES connection number. The value of this object is same as the value of 'cesCnfChanNum' object in cesmChanCnfGrpTable.")
cesEndLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndLineNum.setStatus('current')
if mibBuilder.loadTexts: cesEndLineNum.setDescription("This object identifies the physical line on which connection is provisioned. The value in this object object must match with the value specified in 'cesPortLineNum' for a given logical port(cesEndPortNum).")
ciscoWanCesConnMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 42, 2))
ciscoWanCesConnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 1))
ciscoWanCesConnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 2))
ciscoWanCesConnCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 2, 1)).setObjects(("CISCO-WAN-CES-CONN-MIB", "ciscoWanCesConnGroup"), ("CISCO-WAN-CES-CONN-MIB", "ciscoWanCesConnEndptGroup"), ("CISCO-WAN-CES-CONN-MIB", "ciscoWanCesConnGeneralGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanCesConnCompliance = ciscoWanCesConnCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoWanCesConnCompliance.setDescription('The compliance statement for SNMP entities which support Frame realy connection MIB.')
ciscoWanCesConnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 1, 1)).setObjects(("CISCO-WAN-CES-CONN-MIB", "cesCnfChanNum"), ("CISCO-WAN-CES-CONN-MIB", "cesChanRowStatus"), ("CISCO-WAN-CES-CONN-MIB", "cesMapPortNum"), ("CISCO-WAN-CES-CONN-MIB", "cesMapVpi"), ("CISCO-WAN-CES-CONN-MIB", "cesMapVci"), ("CISCO-WAN-CES-CONN-MIB", "cesCBRService"), ("CISCO-WAN-CES-CONN-MIB", "cesCBRClockMode"), ("CISCO-WAN-CES-CONN-MIB", "cesCas"), ("CISCO-WAN-CES-CONN-MIB", "cesPartialFill"), ("CISCO-WAN-CES-CONN-MIB", "cesBufMaxSize"), ("CISCO-WAN-CES-CONN-MIB", "cesCDVRxT"), ("CISCO-WAN-CES-CONN-MIB", "cesCellLossIntegrationPeriod"), ("CISCO-WAN-CES-CONN-MIB", "cesChanLocRmtLpbkState"), ("CISCO-WAN-CES-CONN-MIB", "cesChanTestType"), ("CISCO-WAN-CES-CONN-MIB", "cesChanTestState"), ("CISCO-WAN-CES-CONN-MIB", "cesChanRTDResult"), ("CISCO-WAN-CES-CONN-MIB", "cesChanPortNum"), ("CISCO-WAN-CES-CONN-MIB", "cesChanConnType"), ("CISCO-WAN-CES-CONN-MIB", "cesChanStrauSciNum"), ("CISCO-WAN-CES-CONN-MIB", "cesChanIdleDetEnable"), ("CISCO-WAN-CES-CONN-MIB", "cesChanIdleSignalCode"), ("CISCO-WAN-CES-CONN-MIB", "cesChanIdleCodeIntgnPeriod"), ("CISCO-WAN-CES-CONN-MIB", "cesChanOnhookCode"), ("CISCO-WAN-CES-CONN-MIB", "cesChanConditionedData"), ("CISCO-WAN-CES-CONN-MIB", "cesmChanExtTrgIdleSupp"), ("CISCO-WAN-CES-CONN-MIB", "cesmChanConditionedSigCode"), ("CISCO-WAN-CES-CONN-MIB", "cesLocalVpi"), ("CISCO-WAN-CES-CONN-MIB", "cesLocalVci"), ("CISCO-WAN-CES-CONN-MIB", "cesLocalNSAP"), ("CISCO-WAN-CES-CONN-MIB", "cesRemoteVpi"), ("CISCO-WAN-CES-CONN-MIB", "cesRemoteVci"), ("CISCO-WAN-CES-CONN-MIB", "cesRemoteNSAP"), ("CISCO-WAN-CES-CONN-MIB", "cesMastership"), ("CISCO-WAN-CES-CONN-MIB", "cesVpcFlag"), ("CISCO-WAN-CES-CONN-MIB", "cesConnServiceType"), ("CISCO-WAN-CES-CONN-MIB", "cesRoutingPriority"), ("CISCO-WAN-CES-CONN-MIB", "cesMaxCost"), ("CISCO-WAN-CES-CONN-MIB", "cesRestrictTrunkType"), ("CISCO-WAN-CES-CONN-MIB", "cesConnPCR"), ("CISCO-WAN-CES-CONN-MIB", "cesConnMCR"), ("CISCO-WAN-CES-CONN-MIB", "cesConnPercentUtil"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnRemotePCR"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnRemoteMCR"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnRemotePercentUtil"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnForeSightEnable"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnFGCRAEnable"), ("CISCO-WAN-CES-CONN-MIB", "cesmChanReroute"), ("CISCO-WAN-CES-CONN-MIB", "cesmConnAdminStatus"), ("CISCO-WAN-CES-CONN-MIB", "cesmChanPrefRouteId"), ("CISCO-WAN-CES-CONN-MIB", "cesmChanDirectRoute"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanCesConnGroup = ciscoWanCesConnGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanCesConnGroup.setDescription('A collection of objects providing information applicable to CES Connections.')
ciscoWanCesConnEndptGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 1, 2)).setObjects(("CISCO-WAN-CES-CONN-MIB", "cesEndPortNum"), ("CISCO-WAN-CES-CONN-MIB", "cesEndChanNum"), ("CISCO-WAN-CES-CONN-MIB", "cesEndLineNum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanCesConnEndptGroup = ciscoWanCesConnEndptGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanCesConnEndptGroup.setDescription('A collection of objects related to End Point mapping in circuit emulation connections.')
ciscoWanCesConnGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 42, 2, 1, 3)).setObjects(("CISCO-WAN-CES-CONN-MIB", "cesmChanNumNextAvailable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanCesConnGeneralGroup = ciscoWanCesConnGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanCesConnGeneralGroup.setDescription('A collection of objects related to next available channeli number and next available VPI value of connections supported.')
mibBuilder.exportSymbols("CISCO-WAN-CES-CONN-MIB", cesPartialFill=cesPartialFill, cesCellLossIntegrationPeriod=cesCellLossIntegrationPeriod, cesChanIdleDetEnable=cesChanIdleDetEnable, cesLocalVci=cesLocalVci, cesChanConnType=cesChanConnType, cesCBRClockMode=cesCBRClockMode, cesmChanCnfGrp=cesmChanCnfGrp, cesLocalVpi=cesLocalVpi, cesChanPortNum=cesChanPortNum, cesmConnAdminStatus=cesmConnAdminStatus, ciscoWanCesConnCompliance=ciscoWanCesConnCompliance, cesmChanCnfGrpEntry=cesmChanCnfGrpEntry, cesEndPortNum=cesEndPortNum, cesChanTestState=cesChanTestState, cesmConnRemoteMCR=cesmConnRemoteMCR, cesChanTestType=cesChanTestType, cesBufMaxSize=cesBufMaxSize, cesEndLineNum=cesEndLineNum, cesCas=cesCas, cesChanRTDResult=cesChanRTDResult, cesChanConditionedData=cesChanConditionedData, cesmConnRemotePCR=cesmConnRemotePCR, cesmEndPtMapGrp=cesmEndPtMapGrp, cesChanStrauSciNum=cesChanStrauSciNum, cesmEndPtMapGrpTable=cesmEndPtMapGrpTable, cesMapVci=cesMapVci, ciscoWanCesConnMIB=ciscoWanCesConnMIB, cesChanIdleSignalCode=cesChanIdleSignalCode, cesmChanPrefRouteId=cesmChanPrefRouteId, ciscoWanCesConnMIBGroups=ciscoWanCesConnMIBGroups, PYSNMP_MODULE_ID=ciscoWanCesConnMIB, cesmConnRemotePercentUtil=cesmConnRemotePercentUtil, cesMapPortNum=cesMapPortNum, cesmChanNumNextAvailable=cesmChanNumNextAvailable, cesmChanReroute=cesmChanReroute, ciscoWanCesConnGroup=ciscoWanCesConnGroup, cesEndChanNum=cesEndChanNum, cesChanLocRmtLpbkState=cesChanLocRmtLpbkState, cesCDVRxT=cesCDVRxT, cesLocalNSAP=cesLocalNSAP, cesmChanCnfGrpTable=cesmChanCnfGrpTable, cesChanRowStatus=cesChanRowStatus, cesMaxCost=cesMaxCost, cesRestrictTrunkType=cesRestrictTrunkType, cesConnPercentUtil=cesConnPercentUtil, cesmConnFGCRAEnable=cesmConnFGCRAEnable, cesRoutingPriority=cesRoutingPriority, ciscoWanCesConnMIBCompliances=ciscoWanCesConnMIBCompliances, cesConnPCR=cesConnPCR, ciscoWanCesConnGeneralGroup=ciscoWanCesConnGeneralGroup, cesmChanExtTrgIdleSupp=cesmChanExtTrgIdleSupp, cesConnServiceType=cesConnServiceType, cesmChanConditionedSigCode=cesmChanConditionedSigCode, cesRemoteVpi=cesRemoteVpi, cesMastership=cesMastership, ciscoWanCesConnMIBConformance=ciscoWanCesConnMIBConformance, cesmEndPtMapGrpEntry=cesmEndPtMapGrpEntry, ciscoWanCesConnEndptGroup=ciscoWanCesConnEndptGroup, cesChanIdleCodeIntgnPeriod=cesChanIdleCodeIntgnPeriod, cesRemoteVci=cesRemoteVci, cesConnMCR=cesConnMCR, cesCnfChanNum=cesCnfChanNum, cesRemoteNSAP=cesRemoteNSAP, cesChanOnhookCode=cesChanOnhookCode, cesmChanDirectRoute=cesmChanDirectRoute, cesCBRService=cesCBRService, cesMapVpi=cesMapVpi, cesmConnForeSightEnable=cesmConnForeSightEnable, cesVpcFlag=cesVpcFlag)

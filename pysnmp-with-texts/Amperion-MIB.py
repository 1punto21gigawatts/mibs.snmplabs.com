#
# PySNMP MIB module Amperion-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Amperion-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:33:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Gauge32, TimeTicks, MibIdentifier, iso, ModuleIdentity, ObjectIdentity, enterprises, Counter64, NotificationType, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Opaque, Bits, Unsigned32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "TimeTicks", "MibIdentifier", "iso", "ModuleIdentity", "ObjectIdentity", "enterprises", "Counter64", "NotificationType", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Opaque", "Bits", "Unsigned32", "Counter32")
TextualConvention, TruthValue, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString", "RowStatus")
amperion = ModuleIdentity((1, 3, 6, 1, 4, 1, 13995))
if mibBuilder.loadTexts: amperion.setLastUpdated('200305080000Z')
if mibBuilder.loadTexts: amperion.setOrganization('Amperion')
if mibBuilder.loadTexts: amperion.setContactInfo('Sanjay Jaiman')
if mibBuilder.loadTexts: amperion.setDescription(' Amperion Inc. private MIB')
ds2 = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1))
powerline = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1))
plMibIIExtension = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1))
plCards = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2))
plCdNumber = MibScalar((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdNumber.setStatus('current')
if mibBuilder.loadTexts: plCdNumber.setDescription('Number of Cards available. Maximum index of plCdTable')
plCdTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2), )
if mibBuilder.loadTexts: plCdTable.setStatus('current')
if mibBuilder.loadTexts: plCdTable.setDescription('Powerline Cards Table. List of attributes of each Card available in the System. Indexed by the number of the Card (from 1 to plCdNumber).')
plCdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1), ).setIndexNames((0, "Amperion-MIB", "plCdIndex"))
if mibBuilder.loadTexts: plCdEntry.setStatus('current')
if mibBuilder.loadTexts: plCdEntry.setDescription('Row of table plCdTable')
plCdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: plCdIndex.setStatus('current')
if mibBuilder.loadTexts: plCdIndex.setDescription('Number of powerline card. Maximum: plCdNumber')
plCdType = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("he", 0), ("cpe", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdType.setStatus('current')
if mibBuilder.loadTexts: plCdType.setDescription('Type of card: 0 => HE 1 => CPE')
plCdLink = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("link1", 1), ("link2", 2), ("link3", 3), ("link4", 4), ("link5", 5), ("link6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plCdLink.setStatus('current')
if mibBuilder.loadTexts: plCdLink.setDescription('Type of link: 1 => Link 1 2 => Link 2 3 => Link 3 4 => Link 4 5 => Link 5 6 => Link 6')
plCdShortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plCdShortMacAddress.setStatus('current')
if mibBuilder.loadTexts: plCdShortMacAddress.setDescription('Short MAC Address of the Card')
plCdLongMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdLongMacAddress.setStatus('current')
if mibBuilder.loadTexts: plCdLongMacAddress.setDescription('Long MAC Address of the Card')
plCdHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: plCdHardwareVersion.setDescription('Hardware Version')
plCdFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: plCdFirmwareVersion.setDescription('Firmware Version')
plCdDriverVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdDriverVersion.setStatus('current')
if mibBuilder.loadTexts: plCdDriverVersion.setDescription('Driver Version')
plCdReset = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plCdReset.setStatus('current')
if mibBuilder.loadTexts: plCdReset.setDescription('Reset to Saved Values. Soft Reset.')
plCdFactoryReset = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plCdFactoryReset.setStatus('current')
if mibBuilder.loadTexts: plCdFactoryReset.setDescription('Reset to factory values. Hard Reset.')
plCdSaveAsPermanent = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plCdSaveAsPermanent.setStatus('current')
if mibBuilder.loadTexts: plCdSaveAsPermanent.setDescription('Save MIB values as default values: the information of the Remote List (long MAC address and short MAC address of each user) is saved and will be restored after a reboot or a poweroff.')
plCdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdStatus.setStatus('current')
if mibBuilder.loadTexts: plCdStatus.setDescription('Status related to the interface: 0 => OK.')
plCdRemoteList = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdRemoteList.setStatus('current')
if mibBuilder.loadTexts: plCdRemoteList.setDescription('List of Long MAC Address that can be connected with HE (only HE). Returns a string with the list of long MAC address (not separated by spaces)')
plCdNumRemoteList = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 1, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plCdNumRemoteList.setStatus('current')
if mibBuilder.loadTexts: plCdNumRemoteList.setDescription('Number of CPE in remote list (only HE). This is the maximum value for cpeId in Network table.')
plNetwork = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2))
plNetTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2, 1), )
if mibBuilder.loadTexts: plNetTable.setStatus('current')
if mibBuilder.loadTexts: plNetTable.setDescription('Network Topology. Indexed by number of card and number of remote user (.plCdIndex.cpeId). Maximum values for indexes: plCdNumber and plCdNumRemoteList. Only available in HE.')
plNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2, 1, 1), ).setIndexNames((0, "Amperion-MIB", "plNetShortMacAddress"))
if mibBuilder.loadTexts: plNetEntry.setStatus('current')
if mibBuilder.loadTexts: plNetEntry.setDescription('Row of table plNetTable')
plNetShortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: plNetShortMacAddress.setStatus('current')
if mibBuilder.loadTexts: plNetShortMacAddress.setDescription('SMAC of remote CPE.')
plNetLongMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14)).clone('0x000000000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: plNetLongMacAddress.setStatus('current')
if mibBuilder.loadTexts: plNetLongMacAddress.setDescription('Long Mac Address of Remote Node.')
plNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 2, 1, 1, 8), RowStatus().clone('createAndWait')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: plNetRowStatus.setStatus('current')
if mibBuilder.loadTexts: plNetRowStatus.setDescription('Row Status')
plTransmission = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3))
plInpTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2), )
if mibBuilder.loadTexts: plInpTable.setStatus('current')
if mibBuilder.loadTexts: plInpTable.setDescription('Input Channel Table. Common input characteristics. Indexed by number of card. Maximum value of index: plCdNumber')
plInpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: plInpEntry.setStatus('current')
if mibBuilder.loadTexts: plInpEntry.setDescription('Row of table plInpTable')
plInpTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpTotalOctets.setStatus('current')
if mibBuilder.loadTexts: plInpTotalOctets.setDescription('Total number of rx octets (including FEC overhead)')
plInpGain = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpGain.setStatus('current')
if mibBuilder.loadTexts: plInpGain.setDescription('Reception gain')
plInpAGC = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("agcdisabled", 0), ("agcenabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpAGC.setStatus('current')
if mibBuilder.loadTexts: plInpAGC.setDescription('To enable or disable Adaptive Rx Gain Control. 0 => AGC disabled 1 => AGC enabled.')
plInpMaxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpMaxGain.setStatus('current')
if mibBuilder.loadTexts: plInpMaxGain.setDescription('Maximum reception gain')
plInpThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpThresholds.setStatus('current')
if mibBuilder.loadTexts: plInpThresholds.setDescription('SNR Thresholds in dB. Returns a string containing 4 integers.')
plInpAttenuationGain = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpAttenuationGain.setStatus('current')
if mibBuilder.loadTexts: plInpAttenuationGain.setDescription('Attenuation Gain (only HE)')
plInpSamsDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpSamsDecode.setStatus('current')
if mibBuilder.loadTexts: plInpSamsDecode.setDescription('Number of decoded SAMS (only CPE)')
plInpSamsGood = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpSamsGood.setStatus('current')
if mibBuilder.loadTexts: plInpSamsGood.setDescription('Number of used SAMS (only CPE)')
plInpSamsBad = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpSamsBad.setStatus('current')
if mibBuilder.loadTexts: plInpSamsBad.setDescription('Number of discarded SAMS (only CPE)')
plInpNodeTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4), )
if mibBuilder.loadTexts: plInpNodeTable.setStatus('current')
if mibBuilder.loadTexts: plInpNodeTable.setDescription('Input Characteristics Remote equipments connected')
plInpNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "Amperion-MIB", "plNetShortMacAddress"))
if mibBuilder.loadTexts: plInpNodeEntry.setStatus('current')
if mibBuilder.loadTexts: plInpNodeEntry.setDescription('Row of table plInpNodeTable')
plInpNodeReceivedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedPkts.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedPkts.setDescription('Number of Packets received from cpeId user')
plInpNodeReceivedUnrecPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedUnrecPkts.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedUnrecPkts.setDescription('Number of Unrecoverable received packets')
plInpNodeReceivedCorrectedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedCorrectedPkts.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedCorrectedPkts.setDescription('Number of Corrected (by FEC) received packets')
plInpNodeReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedOctets.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedOctets.setDescription('Number of Received bytes')
plInpNodeReceivedCorrectedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedCorrectedOctets.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedCorrectedOctets.setDescription('Number of Corrected (by FEC) received bytes')
plInpNodeReceivedPower = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeReceivedPower.setStatus('current')
if mibBuilder.loadTexts: plInpNodeReceivedPower.setDescription('Total received power')
plInpNodePLR = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodePLR.setStatus('current')
if mibBuilder.loadTexts: plInpNodePLR.setDescription('Packet Loss Rate')
plInpNodeMeanBPC = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeMeanBPC.setStatus('current')
if mibBuilder.loadTexts: plInpNodeMeanBPC.setDescription('Mean BPC: sum of current bits configuration')
plInpNodeSNRChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeSNRChanges.setStatus('current')
if mibBuilder.loadTexts: plInpNodeSNRChanges.setDescription('Changes of SNR')
plInpNodeSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeSNR.setStatus('current')
if mibBuilder.loadTexts: plInpNodeSNR.setDescription('String with SNR per carrier: contains 512 bytes if it is a HE or 768 if it is a CPE.')
plInpNodeBPC = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeBPC.setStatus('current')
if mibBuilder.loadTexts: plInpNodeBPC.setDescription('String with BPC per carrier configuration: contains 256 bytes if it is a HE or 384 if it is a CPE.')
plInpNodeCFR = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeCFR.setStatus('current')
if mibBuilder.loadTexts: plInpNodeCFR.setDescription('String with CFR per carrier: contains 512 bytes if it is a HE or 768 if it is a CPE.')
plInpNodeEnableCarriers = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpNodeEnableCarriers.setStatus('current')
if mibBuilder.loadTexts: plInpNodeEnableCarriers.setDescription('String with enabled (1) and disabled (0) carriers: contains 256 bytes if it is a HE or 384 if it is a CPE.')
plInpNodeProtocolEnableCarriers = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plInpNodeProtocolEnableCarriers.setStatus('current')
if mibBuilder.loadTexts: plInpNodeProtocolEnableCarriers.setDescription('String with enabled (1) and disabled (0) carriers: contains 256 bytes if it is a HE or 384 if it is a CPE.')
plInpNodeEnableProtocolEnableCarriers = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 1, 1, 3, 4, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plInpNodeEnableProtocolEnableCarriers.setStatus('current')
if mibBuilder.loadTexts: plInpNodeEnableProtocolEnableCarriers.setDescription('Enable protocol (1) and disable protocol (0).')
plTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 4))
plRemoteCPE = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 1, 5))
internal = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 1, 2))
amperionSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 2))
serialNumber = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('####')).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialNumber.setStatus('current')
if mibBuilder.loadTexts: serialNumber.setDescription('The serial number of the board, which is unique per part number')
partNumber = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('####')).setMaxAccess("readonly")
if mibBuilder.loadTexts: partNumber.setStatus('current')
if mibBuilder.loadTexts: partNumber.setDescription('The part number of the board, which identifies the board type')
rombootVersion = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('####')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rombootVersion.setStatus('current')
if mibBuilder.loadTexts: rombootVersion.setDescription('The string that identifies the Romboot software')
alarms = MibTable((1, 3, 6, 1, 4, 1, 13995, 2, 4), )
if mibBuilder.loadTexts: alarms.setStatus('current')
if mibBuilder.loadTexts: alarms.setDescription('Dynamic alarm table - shows all the outstanding alarms on the system')
alarmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 2, 4, 1), ).setIndexNames((0, "Amperion-MIB", "alarmIndex"))
if mibBuilder.loadTexts: alarmsEntry.setStatus('current')
if mibBuilder.loadTexts: alarmsEntry.setDescription('Row of table alarms')
alarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 2, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: alarmIndex.setStatus('current')
if mibBuilder.loadTexts: alarmIndex.setDescription('The alarmIndex uniquely identifies alarms on the system')
description = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: description.setStatus('current')
if mibBuilder.loadTexts: description.setDescription('Textual description of the alarm')
productType = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 0), ("ohInjector", 1), ("ohExtractor", 2), ("ohRepeater", 3), ("ohRepeaterExt", 4), ("ugInjector", 5), ("ugExtractor", 6), ("ugRepeater", 7), ("ugRepeaterExt", 8))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: productType.setStatus('current')
if mibBuilder.loadTexts: productType.setDescription('injector/extractor/repeator')
linuxVersion = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('####')).setMaxAccess("readonly")
if mibBuilder.loadTexts: linuxVersion.setStatus('current')
if mibBuilder.loadTexts: linuxVersion.setDescription('The string that identifies the Linux kernel software')
amperionSysDescr = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('####')).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionSysDescr.setStatus('current')
if mibBuilder.loadTexts: amperionSysDescr.setDescription("A textual description of the entity. This value should include the full name and version identification of the system's hardware type, software operating-system, and networking software. It is mandatory that this only contain printable ASCII characters.")
amperionSysObjectID = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionSysObjectID.setStatus('current')
if mibBuilder.loadTexts: amperionSysObjectID.setDescription("The vendor's authoritative identification of the network management subsystem contained in the entity. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides an easy and unambiguous means for determining `what kind of box' is being managed. For example, if vendor `Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, it could assign the identifier 1.3.6.1.4.1.4242.1.1 to its `Fred Router'.")
amperionSysUpTime = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionSysUpTime.setStatus('current')
if mibBuilder.loadTexts: amperionSysUpTime.setDescription('The time (in hundredths of a second) since the network management portion of the system was last re-initialized.')
amperionSysContact = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('Amperion Inc. Andover MA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionSysContact.setStatus('current')
if mibBuilder.loadTexts: amperionSysContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person.')
amperionSysName = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('Amperion')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionSysName.setStatus('current')
if mibBuilder.loadTexts: amperionSysName.setDescription("An administratively-assigned name for this managed node. By convention, this is the node's fully-qualified domain name.")
amperionSysLocation = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionSysLocation.setStatus('current')
if mibBuilder.loadTexts: amperionSysLocation.setDescription("The physical location of this node (e.g., `telephone closet, 3rd floor').")
amperionSysServices = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionSysServices.setStatus('current')
if mibBuilder.loadTexts: amperionSysServices.setDescription('A value which indicates the set of services that this entity primarily offers. The value is a sum. This sum initially takes the value zero, Then, for each layer, L, in the range 1 through 7, that this node performs transactions for, 2 raised to (L - 1) is added to the sum. For example, a node which performs primarily routing functions would have a value of 4 (2^(3-1)). In contrast, a node which is a host offering application services would have a value of 72 (2^(4-1) + 2^(7-1)). Note that in the context of the Internet suite of protocols, values should be calculated accordingly: layer functionality 1 physical (e.g., repeaters) 2 datalink/subnetwork (e.g., bridges) 3 internet (e.g., IP gateways) 4 end-to-end (e.g., IP hosts) 7 applications (e.g., mail relays) For systems including OSI protocols, layers 5 and 6 may also be counted.')
amperionTrapMgr1 = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 18), IpAddress().clone(hexValue="7f000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionTrapMgr1.setStatus('current')
if mibBuilder.loadTexts: amperionTrapMgr1.setDescription('IP address of Manager receceiving traps')
amperionTrapMgr2 = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 19), IpAddress().clone(hexValue="7f000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionTrapMgr2.setStatus('current')
if mibBuilder.loadTexts: amperionTrapMgr2.setDescription('IP address of Manager receceiving traps')
amperionTrapMgr3 = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 20), IpAddress().clone(hexValue="7f000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionTrapMgr3.setStatus('current')
if mibBuilder.loadTexts: amperionTrapMgr3.setDescription('amperionTrapMgr3')
userGpsInfoString = MibScalar((1, 3, 6, 1, 4, 1, 13995, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userGpsInfoString.setStatus('current')
if mibBuilder.loadTexts: userGpsInfoString.setDescription('User defined string for the user to put the GPS info of this device')
softwareUpgrade = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 3))
serverAddress = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('0.0.0.0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serverAddress.setStatus('current')
if mibBuilder.loadTexts: serverAddress.setDescription('Name or IP Address of the primary file server from which to retrieve new software.')
currentState = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("inProgress", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentState.setStatus('current')
if mibBuilder.loadTexts: currentState.setDescription('Current state of the software upgrade.')
bootPartition = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootPartition.setStatus('current')
if mibBuilder.loadTexts: bootPartition.setDescription('Image in this partition will be used when the system boots.')
upgradePartition = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2))).clone('backup')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradePartition.setStatus('current')
if mibBuilder.loadTexts: upgradePartition.setDescription('Default partition to erase and load with a new image.')
currentPartition = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("primary", 1), ("backup", 2))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentPartition.setStatus('current')
if mibBuilder.loadTexts: currentPartition.setDescription('Partition from which currently running software was loaded.')
commandOptions = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commandOptions.setStatus('current')
if mibBuilder.loadTexts: commandOptions.setDescription('Software upgrade options: Reserved for future use')
primaryPartitionContents = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: primaryPartitionContents.setStatus('current')
if mibBuilder.loadTexts: primaryPartitionContents.setDescription('Description of image in primary partition.')
primaryCRC = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("ok", 1), ("failed", 2))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: primaryCRC.setStatus('current')
if mibBuilder.loadTexts: primaryCRC.setDescription('CRC status of image in primary partition.')
backupPartitionContents = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: backupPartitionContents.setStatus('current')
if mibBuilder.loadTexts: backupPartitionContents.setDescription('Description of image in backup partition.')
backupCRC = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("ok", 1), ("failed", 2))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: backupCRC.setStatus('current')
if mibBuilder.loadTexts: backupCRC.setDescription('CRC status of image in backup partition.')
lastStatus = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastStatus.setStatus('current')
if mibBuilder.loadTexts: lastStatus.setDescription('Status of current or last software upgrade performed (since last reboot).')
filename = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('ampmulti')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filename.setStatus('current')
if mibBuilder.loadTexts: filename.setDescription('Path to filename to retrieve for software upgrade')
server1Address = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('0.0.0.0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: server1Address.setStatus('current')
if mibBuilder.loadTexts: server1Address.setDescription('Name or IP Address of the alternate file server from which to retrieve new software.')
server2Address = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('0.0.0.0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: server2Address.setStatus('current')
if mibBuilder.loadTexts: server2Address.setDescription('Name or IP Address of the second alternate file server from which to retrieve new software.')
upgradeSchedule = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('None scheduled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeSchedule.setStatus('current')
if mibBuilder.loadTexts: upgradeSchedule.setDescription('Scheduled upgrade date and time in MMDDhhmm format.')
rebootSchedule = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('None scheduled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootSchedule.setStatus('current')
if mibBuilder.loadTexts: rebootSchedule.setDescription('Scheduled reboot date and time in MMDDhhmm format.')
login = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('anonymous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: login.setStatus('current')
if mibBuilder.loadTexts: login.setDescription('login to use for software upgrade file server access.')
password = MibScalar((1, 3, 6, 1, 4, 1, 13995, 3, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('root@Amperion000000.com')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: password.setStatus('current')
if mibBuilder.loadTexts: password.setDescription('password to use for software upgrade file server access.')
swupgradeCompleted = NotificationType((1, 3, 6, 1, 4, 1, 13995, 3, 19)).setObjects(("Amperion-MIB", "backupPartitionContents"), ("Amperion-MIB", "backupCRC"), ("Amperion-MIB", "primaryPartitionContents"), ("Amperion-MIB", "primaryCRC"), ("Amperion-MIB", "bootPartition"))
if mibBuilder.loadTexts: swupgradeCompleted.setStatus('current')
if mibBuilder.loadTexts: swupgradeCompleted.setDescription('swupgradeCompleted')
psGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 4))
psImageChecksumError = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 14)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: psImageChecksumError.setStatus('current')
if mibBuilder.loadTexts: psImageChecksumError.setDescription('The power supply is notifying the main digital board that its main image crc is incorrect. The main digital board needs to reprogram the new power supply image again, or revert back to an older good image')
criticalBatteryShutdownWarning = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 15)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: criticalBatteryShutdownWarning.setStatus('current')
if mibBuilder.loadTexts: criticalBatteryShutdownWarning.setDescription('The power supply is warning the main digital board that we have lost AC Line voltage and the battery is running low. The system will be shutting down in seconds. Perform necessary backup.')
p12vOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 16)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: p12vOutOfRange.setStatus('current')
if mibBuilder.loadTexts: p12vOutOfRange.setDescription('The power supply is warning the main digital board that the +12v regulator is out of range. If the condition is such that it is too high, the decision may be to shutdown the regulator to avoid destroying the hardware')
m8point5vOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 17)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: m8point5vOutOfRange.setStatus('current')
if mibBuilder.loadTexts: m8point5vOutOfRange.setDescription('The power supply is warning the main digital board that the -8.5v regulator is out of range. Note that the -8.5v regulator is the same regulator as the +12v. If the condition is such that it is too high, the decision may be to shutdown the regulator to avoid destroying the hardware.')
p5vOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 18)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: p5vOutOfRange.setStatus('current')
if mibBuilder.loadTexts: p5vOutOfRange.setDescription('The power supply is warning the main digital board that the +5v regulator is out of range. If the condition is such that it is too high, the decision may be to shutdown the regulator to avoid destroying the hardware.')
p3point3vOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 19)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: p3point3vOutOfRange.setStatus('current')
if mibBuilder.loadTexts: p3point3vOutOfRange.setDescription('The power supply is warning the main digital board that the +3.3v regulator is out of range. If the condition is such that it is too high, the decision may be to shutdown the regulator to avoid destroying the hardware.')
batteryVoltsOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 20)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: batteryVoltsOutOfRange.setStatus('current')
if mibBuilder.loadTexts: batteryVoltsOutOfRange.setDescription('The power supply is warning the main digital board that the battery voltage is out of range.')
mcuTempOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 21)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: mcuTempOutOfRange.setStatus('current')
if mibBuilder.loadTexts: mcuTempOutOfRange.setDescription('The power supply is warning the main digital board that the microcontroller unit core temperature is out of range.')
batteryTempOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 22)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: batteryTempOutOfRange.setStatus('current')
if mibBuilder.loadTexts: batteryTempOutOfRange.setDescription('The power supply is warning the main digital board that the battery temperature is out of range')
psDetectedCommLapse = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 23)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: psDetectedCommLapse.setStatus('current')
if mibBuilder.loadTexts: psDetectedCommLapse.setDescription('Power Supply notifies main digital board that it did not communnicate to the power supply within the agreed upon periodic interval')
criticalRequestAborted = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 24)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: criticalRequestAborted.setStatus('current')
if mibBuilder.loadTexts: criticalRequestAborted.setDescription('The power supply is notifying the main digital board that one of the critical requests was aborted due to not receiving it twice in a row.')
powerSupplyInternalError = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 25)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: powerSupplyInternalError.setStatus('current')
if mibBuilder.loadTexts: powerSupplyInternalError.setDescription('Power Supply / netmgt (PS thread) detected an internal error condition')
psBatteryNotConnected = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 26)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: psBatteryNotConnected.setStatus('current')
if mibBuilder.loadTexts: psBatteryNotConnected.setDescription('Power Supply Battery Not Connected. There is no battery backup for the system.')
psAcOnOff = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 27)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: psAcOnOff.setStatus('current')
if mibBuilder.loadTexts: psAcOnOff.setDescription('Power Supply detected AC going ON / OFF')
psHardwareError = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 29)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: psHardwareError.setStatus('current')
if mibBuilder.loadTexts: psHardwareError.setDescription('The power supply is notifying the main digital board that it incurred a hardware error')
npuDetectedCommLapse = NotificationType((1, 3, 6, 1, 4, 1, 13995, 4, 34)).setObjects(("Amperion-MIB", "eventDescription"))
if mibBuilder.loadTexts: npuDetectedCommLapse.setStatus('current')
if mibBuilder.loadTexts: npuDetectedCommLapse.setDescription('Network processing unit could not communnicate to the power supply')
acLineVoltage = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acLineVoltage.setStatus('current')
if mibBuilder.loadTexts: acLineVoltage.setDescription('State of AC Line voltage (on/off)')
plus12v = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plus12v.setStatus('current')
if mibBuilder.loadTexts: plus12v.setDescription('Regulated 12 volt supply')
minus8point5v = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: minus8point5v.setStatus('current')
if mibBuilder.loadTexts: minus8point5v.setDescription('Regulated -8.5 volt supply')
plus5v = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plus5v.setStatus('current')
if mibBuilder.loadTexts: plus5v.setDescription('Regulated +5 volt supply')
plus3point3v = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plus3point3v.setStatus('current')
if mibBuilder.loadTexts: plus3point3v.setDescription('Regulated +3.3 volt supply')
batteryCaseTemp = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryCaseTemp.setStatus('current')
if mibBuilder.loadTexts: batteryCaseTemp.setDescription('Battery Case Temperature')
internalMcuTemp = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalMcuTemp.setStatus('current')
if mibBuilder.loadTexts: internalMcuTemp.setDescription('Internal Micro Controller Unit Temperature')
batteryCurrent = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryCurrent.setStatus('current')
if mibBuilder.loadTexts: batteryCurrent.setDescription('Battery Current')
batteryVoltage = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryVoltage.setStatus('current')
if mibBuilder.loadTexts: batteryVoltage.setDescription('Battery Voltage')
mcuSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcuSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: mcuSoftwareVersion.setDescription('Micro Controller Unit Software Version')
powerCycleNpu = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("idle", 0), ("commit", 1))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: powerCycleNpu.setStatus('current')
if mibBuilder.loadTexts: powerCycleNpu.setDescription('Power Cycle the Network Processor Unit')
psMode = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("protocol", 0), ("dump", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psMode.setStatus('current')
if mibBuilder.loadTexts: psMode.setDescription('Power Supply mode, normal mode is protocol; dump mode is a debug mode which displays debug prints from the MCU')
shutdownNpu = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("idle", 0), ("commit", 1))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shutdownNpu.setStatus('current')
if mibBuilder.loadTexts: shutdownNpu.setDescription('Shut down 12v, -8.5v, 3.3v and 5v regulators driving the Network Processor Unit. This should only be used if one of the voltages is too high.')
psEt = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psEt.setStatus('current')
if mibBuilder.loadTexts: psEt.setDescription('Power Supply elapsed time since powerup')
npuEt = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: npuEt.setStatus('current')
if mibBuilder.loadTexts: npuEt.setDescription('Power Supply elapsed time since powerup')
npuPuTimes = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npuPuTimes.setStatus('current')
if mibBuilder.loadTexts: npuPuTimes.setDescription('Number of times the Network Processing Unit has been powered up.')
eventDescription = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventDescription.setStatus('current')
if mibBuilder.loadTexts: eventDescription.setDescription('Description of the Last Event - Used in sending traps')
psHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 13995, 4, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: psHardwareVersion.setDescription('Hardware Version of the Power SUpply')
amperionInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 5))
interfaceAdminDown = NotificationType((1, 3, 6, 1, 4, 1, 13995, 5, 3)).setObjects(("Amperion-MIB", "amperionifDescr"))
if mibBuilder.loadTexts: interfaceAdminDown.setStatus('current')
if mibBuilder.loadTexts: interfaceAdminDown.setDescription('Admin of Interface being set down')
interfaceAdminUp = NotificationType((1, 3, 6, 1, 4, 1, 13995, 5, 4)).setObjects(("Amperion-MIB", "amperionifDescr"))
if mibBuilder.loadTexts: interfaceAdminUp.setStatus('current')
if mibBuilder.loadTexts: interfaceAdminUp.setDescription('Interface is being set up')
amperionifNumber = MibScalar((1, 3, 6, 1, 4, 1, 13995, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifNumber.setStatus('current')
if mibBuilder.loadTexts: amperionifNumber.setDescription('The number of network interfaces (regardless of their current state) present on this system.')
amperionifTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 5, 2), )
if mibBuilder.loadTexts: amperionifTable.setStatus('current')
if mibBuilder.loadTexts: amperionifTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
amperionifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: amperionifEntry.setStatus('current')
if mibBuilder.loadTexts: amperionifEntry.setDescription('Row of table amperionifTable')
amperionifDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifDescr.setStatus('current')
if mibBuilder.loadTexts: amperionifDescr.setDescription('A textual string containing information about the interface. This string should include the name of the manufacturer, the product name and the version of the hardware interface.')
amperionifType = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddnx25", 4), ("rfc877x25", 5), ("ethernetcsmacd", 6), ("iso88023csmacd", 7), ("iso88024tokenBus", 8), ("iso88025tokenRing", 9), ("iso88026man", 10), ("starLan", 11), ("proteon10Mbit", 12), ("proteon80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("framerelay", 32), ("ieee80211b", 33), ("ieee80211a", 34), ("ieee80211g", 35)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifType.setStatus('current')
if mibBuilder.loadTexts: amperionifType.setDescription("The type of interface, distinguished according to the physical/link protocol(s) immediately `below' the network layer in the protocol stack.")
amperionifMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifMtu.setStatus('current')
if mibBuilder.loadTexts: amperionifMtu.setDescription('The size of the largest datagram which can be sent/received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
amperionifSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifSpeed.setStatus('current')
if mibBuilder.loadTexts: amperionifSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
amperionifPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifPhysAddress.setStatus('current')
if mibBuilder.loadTexts: amperionifPhysAddress.setDescription("The interface's address at the protocol layer immediately `below' the network layer in the protocol stack. For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.")
amperionifAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionifAdminStatus.setStatus('current')
if mibBuilder.loadTexts: amperionifAdminStatus.setDescription('The desired state of the interface. The testing(3) state indicates that no operational packets can be passed.')
amperionifOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOperStatus.setStatus('current')
if mibBuilder.loadTexts: amperionifOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational packets can be passed.')
amperionifLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifLastChange.setStatus('current')
if mibBuilder.loadTexts: amperionifLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re- initialization of the local network management subsystem, then this object contains a zero value.')
amperionifInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInOctets.setStatus('current')
if mibBuilder.loadTexts: amperionifInOctets.setDescription('The total number of octets received on the interface, including framing characters.')
amperionifInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: amperionifInUcastPkts.setDescription('The number of subnetwork-unicast packets delivered to a higher-layer protocol.')
amperionifInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: amperionifInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork- broadcast or subnetwork-multicast) packets delivered to a higher-layer protocol.')
amperionifInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInDiscards.setStatus('current')
if mibBuilder.loadTexts: amperionifInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
amperionifInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInErrors.setStatus('current')
if mibBuilder.loadTexts: amperionifInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
amperionifInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifInUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: amperionifInUnknownProtos.setDescription('The number of packets received via the interface which were discarded because of an unknown or unsupported protocol.')
amperionifOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutOctets.setStatus('current')
if mibBuilder.loadTexts: amperionifOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters.')
amperionifOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: amperionifOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a subnetwork-unicast address, including those that were discarded or not sent.')
amperionifOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: amperionifOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non- unicast (i.e., a subnetwork-broadcast or subnetwork-multicast) address, including those that were discarded or not sent.')
amperionifOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutDiscards.setStatus('current')
if mibBuilder.loadTexts: amperionifOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
amperionifOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutErrors.setStatus('current')
if mibBuilder.loadTexts: amperionifOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
amperionifOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifOutQLen.setStatus('current')
if mibBuilder.loadTexts: amperionifOutQLen.setDescription('The length of the output packet queue (in packets).')
amperionifSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 22), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionifSpecific.setStatus('current')
if mibBuilder.loadTexts: amperionifSpecific.setDescription('A reference to MIB definitions specific to the particular media being used to realize the interface. For example, if the interface is realized by an ethernet, then the value of this object refers to a document defining objects specific to ethernet. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
amperionWirelessConfigEssid = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 33)).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigEssid.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigEssid.setDescription('802.11 network name')
amperionWirelessConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("adhoc", 1), ("managed", 2), ("master", 3), ("repeater", 4))).clone('master')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigMode.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigMode.setDescription('802.11 station operational mode')
amperionWirelessConfigChanFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 25), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigChanFreq.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigChanFreq.setDescription('802.11 Channel ID')
amperionWirelessConfigKey = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 33)).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigKey.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigKey.setDescription('802.11 encryption or scrambling keys and encryption mode.')
amperionWirelessConfigWifType = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wtype11a", 1), ("wtype11b", 2), ("wtype11g", 3))).clone('wtype11b')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigWifType.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigWifType.setDescription('802.11 protocol type.')
amperionWirelessLinkQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionWirelessLinkQuality.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessLinkQuality.setDescription('A measure of how good the received signal is.')
amperionWirelessSignalLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionWirelessSignalLevel.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessSignalLevel.setDescription('Received signal strength (how strong the received signal is).')
amperionWirelessNoiseLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionWirelessNoiseLevel.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessNoiseLevel.setDescription('Background noise level (when no packet is transmited).')
amperionWirelessActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessActivate.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessActivate.setDescription('Command to activate 802.11 parameters on demand.')
amperionWirelessConfigBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigBitRate.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigBitRate.setDescription('The bit transmission rate in Megabits per second. (0 = autonegotiated)')
amperionWirelessConfigWDSPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 5, 2, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: amperionWirelessConfigWDSPeer.setStatus('current')
if mibBuilder.loadTexts: amperionWirelessConfigWDSPeer.setDescription('The MAC address of any WDS peer.')
amperionWireless = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 6))
ampMacAcceptTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 6, 3), )
if mibBuilder.loadTexts: ampMacAcceptTable.setStatus('current')
if mibBuilder.loadTexts: ampMacAcceptTable.setDescription('List of Mac address to be accepted')
ampMacAcceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 6, 3, 1), ).setIndexNames((0, "Amperion-MIB", "macAcceptTableIndex"))
if mibBuilder.loadTexts: ampMacAcceptEntry.setStatus('current')
if mibBuilder.loadTexts: ampMacAcceptEntry.setDescription('Row of table ampMacAcceptTable')
macAcceptTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 6, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)))
if mibBuilder.loadTexts: macAcceptTableIndex.setStatus('current')
if mibBuilder.loadTexts: macAcceptTableIndex.setDescription('Unique index')
macAcceptTableRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 6, 3, 1, 2), RowStatus().clone('createAndGo')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: macAcceptTableRowStatus.setStatus('current')
if mibBuilder.loadTexts: macAcceptTableRowStatus.setDescription('Row Status')
macAcceptTableMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 6, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone('00:00:00:00:00:00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: macAcceptTableMacAddress.setStatus('current')
if mibBuilder.loadTexts: macAcceptTableMacAddress.setDescription('Mac address to be accepted')
macAcceptTableWirelessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 6, 3, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: macAcceptTableWirelessIf.setStatus('current')
if mibBuilder.loadTexts: macAcceptTableWirelessIf.setDescription('The wireless interface (e.g. wlan0) that ACL table is applied to.')
accessControlStatus = MibScalar((1, 3, 6, 1, 4, 1, 13995, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessControlStatus.setStatus('current')
if mibBuilder.loadTexts: accessControlStatus.setDescription('Status of the access control table')
amperionipAddrTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 7), )
if mibBuilder.loadTexts: amperionipAddrTable.setStatus('current')
if mibBuilder.loadTexts: amperionipAddrTable.setDescription("The table of addressing information relevant to this entity's IP addresses.")
amperionipAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 7, 1), ).setIndexNames((0, "Amperion-MIB", "amperionipAdEntAddr"))
if mibBuilder.loadTexts: amperionipAddrEntry.setStatus('current')
if mibBuilder.loadTexts: amperionipAddrEntry.setDescription('Row of table amperionipAddrTable')
amperionipAdEntAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 1), IpAddress())
if mibBuilder.loadTexts: amperionipAdEntAddr.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntAddr.setDescription("The IP address to which this entry's addressing information pertains.")
amperionipAdEntIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionipAdEntIfName.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntIfName.setDescription('The name which uniquely identifies the interface to which this entry is applicable.')
amperionipAdEntNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionipAdEntNetMask.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntNetMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
amperionipAdEntBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionipAdEntBcastAddr.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntBcastAddr.setDescription('The value of the least-significant bit in the IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry. For example, when the Internet standard all-ones broadcast address is used, the value will be 1. This value applies to both the subnet and network broadcasts addresses used by the entity on this (logical) interface.')
amperionipAdEntReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amperionipAdEntReasmMaxSize.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntReasmMaxSize.setDescription('The size of the largest IP datagram which this entity can re-assemble from incoming IP fragmented datagrams received on this interface.')
amperionipAdEntActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 7), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: amperionipAdEntActivate.setStatus('current')
if mibBuilder.loadTexts: amperionipAdEntActivate.setDescription('Command to activate the new IP address/netmask on demand.')
amperionipAdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 7, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: amperionipAdRowStatus.setStatus('current')
if mibBuilder.loadTexts: amperionipAdRowStatus.setDescription('Row status')
qualityOfService = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 8))
serviceClassA = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 65536)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceClassA.setStatus('current')
if mibBuilder.loadTexts: serviceClassA.setDescription('Service Class A (Bandwidth in Kbps)')
serviceClassB = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 65536)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceClassB.setStatus('current')
if mibBuilder.loadTexts: serviceClassB.setDescription('Service Class B (Bandwidth in Kbps)')
serviceClassC = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 65536)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceClassC.setStatus('current')
if mibBuilder.loadTexts: serviceClassC.setDescription('Service Class C (Bandwidth in Kbps)')
serviceClassD = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 65536)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceClassD.setStatus('current')
if mibBuilder.loadTexts: serviceClassD.setDescription('Service Class D (Bandwidth in Kbps)')
subscriberTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 8, 5), )
if mibBuilder.loadTexts: subscriberTable.setStatus('current')
if mibBuilder.loadTexts: subscriberTable.setDescription('List of subscribers')
subscriberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1), ).setIndexNames((0, "Amperion-MIB", "index"))
if mibBuilder.loadTexts: subscriberEntry.setStatus('current')
if mibBuilder.loadTexts: subscriberEntry.setDescription('Row of table subscriberTable')
index = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)))
if mibBuilder.loadTexts: index.setStatus('current')
if mibBuilder.loadTexts: index.setDescription('Subscriber unique identification')
name = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: name.setStatus('current')
if mibBuilder.loadTexts: name.setDescription('Subscriber Name')
ipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 3), IpAddress().clone(hexValue="0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipAddress.setStatus('current')
if mibBuilder.loadTexts: ipAddress.setDescription('Subscriber IP address')
macAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17)).clone('00:00:00:00:00:00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: macAddress.setStatus('current')
if mibBuilder.loadTexts: macAddress.setDescription('Subscriber MAC address')
serviceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("classA", 1), ("classB", 2), ("classC", 3), ("classD", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serviceClass.setStatus('current')
if mibBuilder.loadTexts: serviceClass.setDescription('Subscriber Server Class')
rowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 8, 5, 1, 6), RowStatus().clone('createAndGo')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rowStatus.setStatus('current')
if mibBuilder.loadTexts: rowStatus.setDescription('A special field used to create new rows.')
upstreamDownstreamRatio = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)).clone('1:3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upstreamDownstreamRatio.setStatus('current')
if mibBuilder.loadTexts: upstreamDownstreamRatio.setDescription('Upstream bandwidth to downstream bandwidth ratio')
qosStatus = MibScalar((1, 3, 6, 1, 4, 1, 13995, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosStatus.setStatus('current')
if mibBuilder.loadTexts: qosStatus.setDescription('Enable or disable status of Qos')
afe = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 9))
afeExtractor = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 9, 1))
afeExtTxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeExtTxGain.setStatus('current')
if mibBuilder.loadTexts: afeExtTxGain.setDescription('afeExtTxGain')
afeExtRxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeExtRxGain.setStatus('current')
if mibBuilder.loadTexts: afeExtRxGain.setDescription('afeExtRxGain')
afeExtDownstream = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeExtDownstream.setStatus('current')
if mibBuilder.loadTexts: afeExtDownstream.setDescription('afeExtDownstream')
afeExtUpstream = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeExtUpstream.setStatus('current')
if mibBuilder.loadTexts: afeExtUpstream.setDescription('afeExtUpstream')
afeExtActivate = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeExtActivate.setStatus('current')
if mibBuilder.loadTexts: afeExtActivate.setDescription('afeExtActivate')
afeInjector = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 9, 2))
afeInjTxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeInjTxGain.setStatus('current')
if mibBuilder.loadTexts: afeInjTxGain.setDescription('afeInjTxGain')
afeInjRxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeInjRxGain.setStatus('current')
if mibBuilder.loadTexts: afeInjRxGain.setDescription('afeInjRxGain')
afeInjDownstream = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeInjDownstream.setStatus('current')
if mibBuilder.loadTexts: afeInjDownstream.setDescription('afeInjDownstream')
afeInjUpstream = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeInjUpstream.setStatus('current')
if mibBuilder.loadTexts: afeInjUpstream.setDescription('afeInjUpstream')
afeInjActivate = MibScalar((1, 3, 6, 1, 4, 1, 13995, 9, 2, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: afeInjActivate.setStatus('current')
if mibBuilder.loadTexts: afeInjActivate.setDescription('afeInjActivate')
amperionRoutes = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 10))
amperionRouteTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 10, 1), )
if mibBuilder.loadTexts: amperionRouteTable.setStatus('current')
if mibBuilder.loadTexts: amperionRouteTable.setDescription("This entity's IP Routing table.")
amperionRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1), ).setIndexNames((0, "Amperion-MIB", "ipRouteDest"))
if mibBuilder.loadTexts: amperionRouteEntry.setStatus('current')
if mibBuilder.loadTexts: amperionRouteEntry.setDescription('Row of table amperionRouteTable')
ipRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteDest.setStatus('current')
if mibBuilder.loadTexts: ipRouteDest.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
ipRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ipRouteMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: ipRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: ipRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: ipRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: ipRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: ipRouteNextHop.setDescription("The IP address of the next hop of this route. (In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IP address on that interface.)")
ipRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4))).clone('direct')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteType.setStatus('current')
if mibBuilder.loadTexts: ipRouteType.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the IP architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively dissasociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
ipRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isis", 9), ("esis", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteProto.setStatus('current')
if mibBuilder.loadTexts: ipRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
ipRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteAge.setStatus('current')
if mibBuilder.loadTexts: ipRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMask.setStatus('current')
if mibBuilder.loadTexts: ipRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipRouteMask by determining whether the value of the correspondent ipRouteDest field belong to a class-A, B, or C network, and then using one of: mask network 255.0.0.0 class-A 255.255.0.0 class-B 255.255.255.0 class-C If the value of the ipRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0. It should be noted that all IP routing subsystems implicitly use this mechanism.')
ipRouteMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: ipRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
ipRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfo.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's ipRouteProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.")
ipDefRouteActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 10, 1, 1, 14), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDefRouteActivate.setStatus('current')
if mibBuilder.loadTexts: ipDefRouteActivate.setDescription('Command to activate the new default route.')
plc = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 11))
plcExtractor = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 11, 1))
plcExtTxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plcExtTxGain.setStatus('current')
if mibBuilder.loadTexts: plcExtTxGain.setDescription('plcExtTxGain')
plcExtRxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plcExtRxGain.setStatus('current')
if mibBuilder.loadTexts: plcExtRxGain.setDescription('plcExtRxGain')
plcInjector = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 11, 2))
plcInjTxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plcInjTxGain.setStatus('current')
if mibBuilder.loadTexts: plcInjTxGain.setDescription('plcInjTxGain')
plcInjRxGain = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plcInjRxGain.setStatus('current')
if mibBuilder.loadTexts: plcInjRxGain.setDescription('plcInjRxGain')
plcUp = NotificationType((1, 3, 6, 1, 4, 1, 13995, 11, 3)).setObjects(("Amperion-MIB", "plcEventDescription"))
if mibBuilder.loadTexts: plcUp.setStatus('current')
if mibBuilder.loadTexts: plcUp.setDescription("Extractor's PLC interface came up")
plcDown = NotificationType((1, 3, 6, 1, 4, 1, 13995, 11, 4)).setObjects(("Amperion-MIB", "plcEventDescription"))
if mibBuilder.loadTexts: plcDown.setStatus('current')
if mibBuilder.loadTexts: plcDown.setDescription("Extractor's PLC interface went down")
afeCpldResetCount = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: afeCpldResetCount.setStatus('current')
if mibBuilder.loadTexts: afeCpldResetCount.setDescription('afe Cpld Reset Count')
plcLossCount = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plcLossCount.setStatus('current')
if mibBuilder.loadTexts: plcLossCount.setDescription('plc Loss Count')
resetCounters = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetCounters.setStatus('current')
if mibBuilder.loadTexts: resetCounters.setDescription('reset Counters')
optimizationTable = MibTable((1, 3, 6, 1, 4, 1, 13995, 11, 8), )
if mibBuilder.loadTexts: optimizationTable.setStatus('current')
if mibBuilder.loadTexts: optimizationTable.setDescription('If Injector - This table contains the frequencies(channels) / gains / throughput of all the extractors down stream. If Extractor - This table should contain frequencies(channels) / gains / throughput for the the plc segment between this extractor and the injector/repeator upstream.')
optimizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1), ).setIndexNames((0, "Amperion-MIB", "extrIpaddress"), (0, "Amperion-MIB", "extrChannelNumber"))
if mibBuilder.loadTexts: optimizationEntry.setStatus('current')
if mibBuilder.loadTexts: optimizationEntry.setDescription('Row of table optimizationTable')
extrIpaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: extrIpaddress.setStatus('current')
if mibBuilder.loadTexts: extrIpaddress.setDescription("extractor's ipaddress")
extrChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: extrChannelNumber.setStatus('current')
if mibBuilder.loadTexts: extrChannelNumber.setDescription('Extractor Channel Number')
upstreamFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upstreamFreq.setStatus('current')
if mibBuilder.loadTexts: upstreamFreq.setDescription('Upstream Frequency')
downstreamFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: downstreamFreq.setStatus('current')
if mibBuilder.loadTexts: downstreamFreq.setDescription('Downstream Frequency')
rxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxGain.setStatus('current')
if mibBuilder.loadTexts: rxGain.setDescription('rxGain setting')
txGain = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txGain.setStatus('current')
if mibBuilder.loadTexts: txGain.setDescription('Tx Gain Setting')
plcThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: plcThroughput.setStatus('current')
if mibBuilder.loadTexts: plcThroughput.setDescription('plcThroughput')
upStreamDownStream = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("upstream", 1), ("downstream", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: upStreamDownStream.setStatus('current')
if mibBuilder.loadTexts: upStreamDownStream.setDescription('This to indicate if this entry pertains to the upstream segment or the downstream segment')
gpsInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 13995, 11, 8, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gpsInfo.setStatus('current')
if mibBuilder.loadTexts: gpsInfo.setDescription("GPS co-ordinates. Currently this is a string which means the machine just picks up whatever GPS info is defined in it's system group and sends it to the extractor")
plcEventDescription = MibScalar((1, 3, 6, 1, 4, 1, 13995, 11, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plcEventDescription.setStatus('current')
if mibBuilder.loadTexts: plcEventDescription.setDescription("String to be sent in the plc up/down event. Will contain ip address of the unit which just went down or will say 'local system' if current system")
tempGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 13995, 12))
tempFanState = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempFanState.setStatus('current')
if mibBuilder.loadTexts: tempFanState.setDescription('The fans may be on or off.')
tempFanTargetTemp = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70)).clone(25)).setUnits('degrees celcius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempFanTargetTemp.setStatus('current')
if mibBuilder.loadTexts: tempFanTargetTemp.setDescription('The target temperature is the average temperature we would like the system to operate at if possible. It is used to calculate how long the fans should stay on during a cycle which is part of a duty cycle algorithm. Temperature is in degrees celsius.')
tempEventDescription = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 130))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempEventDescription.setStatus('current')
if mibBuilder.loadTexts: tempEventDescription.setDescription('String to be sent with the temperature trap events.')
tempHighWarnLimitTrap = NotificationType((1, 3, 6, 1, 4, 1, 13995, 12, 4)).setObjects(("Amperion-MIB", "tempEventDescription"), ("Amperion-MIB", "tempHighWarnLimit"), ("Amperion-MIB", "tempSystemTemp"))
if mibBuilder.loadTexts: tempHighWarnLimitTrap.setStatus('current')
if mibBuilder.loadTexts: tempHighWarnLimitTrap.setDescription('The system temperature has exceeded the High Warning threshold.')
tempHighErrorLimitTrap = NotificationType((1, 3, 6, 1, 4, 1, 13995, 12, 6)).setObjects(("Amperion-MIB", "tempEventDescription"), ("Amperion-MIB", "tempHighErrorLimit"), ("Amperion-MIB", "tempSystemTemp"))
if mibBuilder.loadTexts: tempHighErrorLimitTrap.setStatus('current')
if mibBuilder.loadTexts: tempHighErrorLimitTrap.setDescription('The system temperature has exceeded the High Error Threshold.')
tempLowWarnLimitTrap = NotificationType((1, 3, 6, 1, 4, 1, 13995, 12, 7)).setObjects(("Amperion-MIB", "tempEventDescription"), ("Amperion-MIB", "tempLowWarnLimit"), ("Amperion-MIB", "tempSystemTemp"))
if mibBuilder.loadTexts: tempLowWarnLimitTrap.setStatus('current')
if mibBuilder.loadTexts: tempLowWarnLimitTrap.setDescription('The system temperature has gone below the Low Warning Threshold.')
tempLowErrorLimitTrap = NotificationType((1, 3, 6, 1, 4, 1, 13995, 12, 8)).setObjects(("Amperion-MIB", "tempEventDescription"), ("Amperion-MIB", "tempLowErrorLimit"), ("Amperion-MIB", "tempSystemTemp"))
if mibBuilder.loadTexts: tempLowErrorLimitTrap.setStatus('current')
if mibBuilder.loadTexts: tempLowErrorLimitTrap.setDescription('The system temperature has gone below the Low Error Threshold.')
tempHighWarnLimit = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 150)).clone(65)).setUnits('degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHighWarnLimit.setStatus('current')
if mibBuilder.loadTexts: tempHighWarnLimit.setDescription('The system temperature has exceeded a high temperature warning threshold. Temperature is in degrees Celsius.')
tempHighErrorLimit = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 150)).clone(100)).setUnits('degrees Celscius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHighErrorLimit.setStatus('current')
if mibBuilder.loadTexts: tempHighErrorLimit.setDescription('The system temperature has exceeded a high temperature error threshold. Temperature is in degrees Celsius.')
tempLowWarnLimit = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 60)).clone(-10)).setUnits('degrees Celscius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempLowWarnLimit.setStatus('current')
if mibBuilder.loadTexts: tempLowWarnLimit.setDescription('The system temperature has gone below a low temperature warning threshold. Temperature is in degrees Celscius.')
tempLowErrorLimit = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 60)).clone(-30)).setUnits('degrees Celscius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempLowErrorLimit.setStatus('current')
if mibBuilder.loadTexts: tempLowErrorLimit.setDescription('The system temperature has gone below the Low Temperature Error Threshold. The temperature is in degrees Celscius.')
tempHighWarnHist = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 150)).clone(55)).setUnits('degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHighWarnHist.setStatus('current')
if mibBuilder.loadTexts: tempHighWarnHist.setDescription('Hysteresis value for the High Temperature Warning Condition. Once the system temperature has reached or exceeded the High Temperature Warning threshold, it must go down to or below the Hysteresis temperature before sending the trap again. The hysteresis temperature is in degrees Celcius.')
tempHighErrorHist = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 150)).clone(90)).setUnits('degrees Celscius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHighErrorHist.setStatus('current')
if mibBuilder.loadTexts: tempHighErrorHist.setDescription('Hysteresis value for the High Temperature Error Condition. Once the system temperature has reached or exceeded the High Temperature Error Threshold, it must go down to or below the Hysteresis temperature before sending the trap again. The hysteresis temperature is in degrees Celcius.')
tempLowWarnHist = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 60))).setUnits('degrees Celscius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempLowWarnHist.setStatus('current')
if mibBuilder.loadTexts: tempLowWarnHist.setDescription('Hysteresis value for the Low Temperature Warning Condition. Once the system temperature is less than or equal to the LowTemperature Warning threshold, it must go up to or above the Hysteresis temperature before sending the trap again. The hysteresis temperature is in degrees Celcius.')
tempLowErrorHist = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 60)).clone(-20)).setUnits('degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempLowErrorHist.setStatus('current')
if mibBuilder.loadTexts: tempLowErrorHist.setDescription('Hysteresis value for the Low Temperature Error Condition. Once the system temperature is less than or equal to the LowTemperature Error threshold, it must go up to or above the Hysteresis temperature before sending the trap again. The hysteresis temperature is in degrees Celcius.')
tempSystemTemp = MibScalar((1, 3, 6, 1, 4, 1, 13995, 12, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSystemTemp.setStatus('current')
if mibBuilder.loadTexts: tempSystemTemp.setDescription('The temperature of the Main Digital Board. The temperature is obtained by reading a chip located on the digital board.')
mibBuilder.exportSymbols("Amperion-MIB", ipRouteMetric5=ipRouteMetric5, backupPartitionContents=backupPartitionContents, amperionifOutNUcastPkts=amperionifOutNUcastPkts, plNetTable=plNetTable, ampMacAcceptEntry=ampMacAcceptEntry, rowStatus=rowStatus, afeCpldResetCount=afeCpldResetCount, powerSupplyInternalError=powerSupplyInternalError, ipRouteMetric4=ipRouteMetric4, tempLowWarnHist=tempLowWarnHist, ds2=ds2, ipRouteMetric2=ipRouteMetric2, afeExtractor=afeExtractor, afeExtUpstream=afeExtUpstream, serviceClassA=serviceClassA, amperionWirelessConfigKey=amperionWirelessConfigKey, psGroup=psGroup, plCdFirmwareVersion=plCdFirmwareVersion, plNetLongMacAddress=plNetLongMacAddress, plInpNodeMeanBPC=plInpNodeMeanBPC, plus12v=plus12v, amperionifOutUcastPkts=amperionifOutUcastPkts, plInpNodeSNR=plInpNodeSNR, plus5v=plus5v, plc=plc, plNetRowStatus=plNetRowStatus, plInpThresholds=plInpThresholds, password=password, amperionWirelessConfigEssid=amperionWirelessConfigEssid, upstreamDownstreamRatio=upstreamDownstreamRatio, ipRouteNextHop=ipRouteNextHop, macAcceptTableMacAddress=macAcceptTableMacAddress, ipDefRouteActivate=ipDefRouteActivate, plCdLink=plCdLink, plInpNodeReceivedOctets=plInpNodeReceivedOctets, internal=internal, ampMacAcceptTable=ampMacAcceptTable, afe=afe, macAddress=macAddress, amperionifOutDiscards=amperionifOutDiscards, ipRouteMetric1=ipRouteMetric1, upstreamFreq=upstreamFreq, batteryCurrent=batteryCurrent, amperionWirelessConfigBitRate=amperionWirelessConfigBitRate, ipRouteDest=ipRouteDest, plcEventDescription=plcEventDescription, plInpNodeEntry=plInpNodeEntry, afeInjDownstream=afeInjDownstream, plCards=plCards, plInpAGC=plInpAGC, psMode=psMode, amperionifNumber=amperionifNumber, plInpSamsBad=plInpSamsBad, ipRouteProto=ipRouteProto, plInpTable=plInpTable, tempHighErrorHist=tempHighErrorHist, downstreamFreq=downstreamFreq, minus8point5v=minus8point5v, psEt=psEt, amperionifInOctets=amperionifInOctets, amperionipAdEntActivate=amperionipAdEntActivate, acLineVoltage=acLineVoltage, eventDescription=eventDescription, bootPartition=bootPartition, macAcceptTableIndex=macAcceptTableIndex, qosStatus=qosStatus, batteryTempOutOfRange=batteryTempOutOfRange, amperionWirelessConfigMode=amperionWirelessConfigMode, afeInjector=afeInjector, batteryCaseTemp=batteryCaseTemp, shutdownNpu=shutdownNpu, currentState=currentState, interfaceAdminUp=interfaceAdminUp, subscriberTable=subscriberTable, index=index, plCdDriverVersion=plCdDriverVersion, plRemoteCPE=plRemoteCPE, upgradePartition=upgradePartition, plCdHardwareVersion=plCdHardwareVersion, amperionifMtu=amperionifMtu, rxGain=rxGain, macAcceptTableWirelessIf=macAcceptTableWirelessIf, amperionTrapMgr3=amperionTrapMgr3, plNetEntry=plNetEntry, amperionifInNUcastPkts=amperionifInNUcastPkts, p12vOutOfRange=p12vOutOfRange, amperionifSpeed=amperionifSpeed, plCdStatus=plCdStatus, plCdFactoryReset=plCdFactoryReset, amperionWirelessSignalLevel=amperionWirelessSignalLevel, upgradeSchedule=upgradeSchedule, criticalRequestAborted=criticalRequestAborted, amperionWirelessConfigWifType=amperionWirelessConfigWifType, plcInjTxGain=plcInjTxGain, amperionipAdEntNetMask=amperionipAdEntNetMask, plcExtTxGain=plcExtTxGain, plcExtRxGain=plcExtRxGain, plInpNodeBPC=plInpNodeBPC, batteryVoltage=batteryVoltage, amperionifOperStatus=amperionifOperStatus, alarmsEntry=alarmsEntry, amperionSysContact=amperionSysContact, npuPuTimes=npuPuTimes, amperionifLastChange=amperionifLastChange, amperionWirelessLinkQuality=amperionWirelessLinkQuality, userGpsInfoString=userGpsInfoString, tempHighErrorLimit=tempHighErrorLimit, backupCRC=backupCRC, amperionifAdminStatus=amperionifAdminStatus, amperionifOutQLen=amperionifOutQLen, amperionSysServices=amperionSysServices, description=description, p5vOutOfRange=p5vOutOfRange, amperionTrapMgr2=amperionTrapMgr2, login=login, swupgradeCompleted=swupgradeCompleted, amperionipAddrTable=amperionipAddrTable, amperionipAdEntIfName=amperionipAdEntIfName, powerline=powerline, linuxVersion=linuxVersion, psBatteryNotConnected=psBatteryNotConnected, psAcOnOff=psAcOnOff, ipAddress=ipAddress, plInpNodeProtocolEnableCarriers=plInpNodeProtocolEnableCarriers, productType=productType, macAcceptTableRowStatus=macAcceptTableRowStatus, txGain=txGain, tempLowErrorLimitTrap=tempLowErrorLimitTrap, currentPartition=currentPartition, amperionipAdEntAddr=amperionipAdEntAddr, plCdType=plCdType, plInpNodeReceivedCorrectedPkts=plInpNodeReceivedCorrectedPkts, optimizationEntry=optimizationEntry, afeExtTxGain=afeExtTxGain, plCdShortMacAddress=plCdShortMacAddress, amperionSysName=amperionSysName, amperionWirelessConfigWDSPeer=amperionWirelessConfigWDSPeer, plInpNodeSNRChanges=plInpNodeSNRChanges, criticalBatteryShutdownWarning=criticalBatteryShutdownWarning, amperionipAdEntBcastAddr=amperionipAdEntBcastAddr, ipRouteType=ipRouteType, gpsInfo=gpsInfo, plInpEntry=plInpEntry, plCdLongMacAddress=plCdLongMacAddress, plInpNodeReceivedPower=plInpNodeReceivedPower, rebootSchedule=rebootSchedule, tempHighWarnLimitTrap=tempHighWarnLimitTrap, amperionRouteTable=amperionRouteTable, serviceClassC=serviceClassC, mcuTempOutOfRange=mcuTempOutOfRange, plCdSaveAsPermanent=plCdSaveAsPermanent, afeInjUpstream=afeInjUpstream, amperionifType=amperionifType, tempLowErrorHist=tempLowErrorHist, amperionipAdEntReasmMaxSize=amperionipAdEntReasmMaxSize, amperionifInUnknownProtos=amperionifInUnknownProtos, ipRouteIfIndex=ipRouteIfIndex, plcThroughput=plcThroughput, serviceClass=serviceClass, plus3point3v=plus3point3v, plMibIIExtension=plMibIIExtension, rombootVersion=rombootVersion, ipRouteInfo=ipRouteInfo, plInpNodeCFR=plInpNodeCFR, amperionTrapMgr1=amperionTrapMgr1, extrIpaddress=extrIpaddress, tempGroup=tempGroup, serialNumber=serialNumber, amperionipAdRowStatus=amperionipAdRowStatus, psDetectedCommLapse=psDetectedCommLapse, plInpNodeReceivedCorrectedOctets=plInpNodeReceivedCorrectedOctets, plcInjector=plcInjector, psHardwareError=psHardwareError, plcDown=plcDown, mcuSoftwareVersion=mcuSoftwareVersion, tempLowWarnLimitTrap=tempLowWarnLimitTrap, amperionRouteEntry=amperionRouteEntry, afeExtActivate=afeExtActivate, tempLowErrorLimit=tempLowErrorLimit, amperionifDescr=amperionifDescr, plcLossCount=plcLossCount, amperionWireless=amperionWireless, resetCounters=resetCounters, plCdIndex=plCdIndex, name=name, plInpNodeTable=plInpNodeTable, m8point5vOutOfRange=m8point5vOutOfRange, amperionifInErrors=amperionifInErrors, amperionWirelessConfigChanFreq=amperionWirelessConfigChanFreq, tempEventDescription=tempEventDescription, tempFanState=tempFanState, tempHighErrorLimitTrap=tempHighErrorLimitTrap, amperionifOutOctets=amperionifOutOctets, plCdEntry=plCdEntry, plCdRemoteList=plCdRemoteList, amperionifSpecific=amperionifSpecific, plCdNumRemoteList=plCdNumRemoteList, plcExtractor=plcExtractor, amperionifInUcastPkts=amperionifInUcastPkts, alarms=alarms, plInpNodeReceivedPkts=plInpNodeReceivedPkts, amperionWirelessNoiseLevel=amperionWirelessNoiseLevel, amperionRoutes=amperionRoutes, afeInjTxGain=afeInjTxGain, amperionifOutErrors=amperionifOutErrors, tempHighWarnLimit=tempHighWarnLimit, amperionSysDescr=amperionSysDescr, psHardwareVersion=psHardwareVersion, server2Address=server2Address, amperionWirelessActivate=amperionWirelessActivate, plcUp=plcUp, serverAddress=serverAddress, p3point3vOutOfRange=p3point3vOutOfRange, qualityOfService=qualityOfService, afeExtDownstream=afeExtDownstream, tempLowWarnLimit=tempLowWarnLimit, plCdReset=plCdReset, plNetwork=plNetwork, upStreamDownStream=upStreamDownStream, tempSystemTemp=tempSystemTemp, ipRouteMetric3=ipRouteMetric3, lastStatus=lastStatus, primaryCRC=primaryCRC, npuDetectedCommLapse=npuDetectedCommLapse, plInpSamsGood=plInpSamsGood, amperionifPhysAddress=amperionifPhysAddress, PYSNMP_MODULE_ID=amperion, internalMcuTemp=internalMcuTemp, primaryPartitionContents=primaryPartitionContents, psImageChecksumError=psImageChecksumError, amperionSysUpTime=amperionSysUpTime, filename=filename, tempFanTargetTemp=tempFanTargetTemp, plNetShortMacAddress=plNetShortMacAddress, alarmIndex=alarmIndex, batteryVoltsOutOfRange=batteryVoltsOutOfRange, serviceClassD=serviceClassD, amperionInterfaces=amperionInterfaces, softwareUpgrade=softwareUpgrade, amperionipAddrEntry=amperionipAddrEntry, extrChannelNumber=extrChannelNumber, tempHighWarnHist=tempHighWarnHist, amperionifInDiscards=amperionifInDiscards, amperionSystem=amperionSystem, plInpAttenuationGain=plInpAttenuationGain, plTransmission=plTransmission, server1Address=server1Address, accessControlStatus=accessControlStatus, plInpSamsDecode=plInpSamsDecode, afeInjRxGain=afeInjRxGain, npuEt=npuEt, plCdNumber=plCdNumber, plInpNodePLR=plInpNodePLR, amperionSysObjectID=amperionSysObjectID)
mibBuilder.exportSymbols("Amperion-MIB", amperionSysLocation=amperionSysLocation, ipRouteAge=ipRouteAge, amperionifEntry=amperionifEntry, subscriberEntry=subscriberEntry, commandOptions=commandOptions, plCdTable=plCdTable, plTraps=plTraps, amperionifTable=amperionifTable, plInpMaxGain=plInpMaxGain, afeExtRxGain=afeExtRxGain, afeInjActivate=afeInjActivate, ipRouteMask=ipRouteMask, plInpTotalOctets=plInpTotalOctets, partNumber=partNumber, plcInjRxGain=plcInjRxGain, plInpNodeEnableProtocolEnableCarriers=plInpNodeEnableProtocolEnableCarriers, powerCycleNpu=powerCycleNpu, plInpNodeReceivedUnrecPkts=plInpNodeReceivedUnrecPkts, serviceClassB=serviceClassB, interfaceAdminDown=interfaceAdminDown, plInpNodeEnableCarriers=plInpNodeEnableCarriers, plInpGain=plInpGain, optimizationTable=optimizationTable, amperion=amperion)

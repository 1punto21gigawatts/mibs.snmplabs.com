#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-AtmBaseMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-AtmBaseMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
mscLpEng, mscLpEngIndex, mscLpIndex, mscLp = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEng", "mscLpEngIndex", "mscLpIndex", "mscLp")
StorageType, RowStatus, Integer32, Unsigned32, DisplayString, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "StorageType", "RowStatus", "Integer32", "Unsigned32", "DisplayString", "Gauge32")
FixedPoint1, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "FixedPoint1", "NonReplicated")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Integer32, NotificationType, iso, Counter32, MibIdentifier, Unsigned32, IpAddress, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "NotificationType", "iso", "Counter32", "MibIdentifier", "Unsigned32", "IpAddress", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
atmBaseMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63))
mscLpArc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19))
mscLpArcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1), )
if mibBuilder.loadTexts: mscLpArcRowStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpArc components.')
mscLpArcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpArcIndex"))
if mibBuilder.loadTexts: mscLpArcRowStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpArc component.')
mscLpArcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpArc components. These components can be added and deleted.')
mscLpArcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpArcComponentName.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpArcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpArcStorageType.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcStorageType.setDescription('This variable represents the storage type value for the mscLpArc tables.')
mscLpArcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpArcIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcIndex.setDescription('This variable represents the index for the mscLpArc tables.')
mscLpArcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100), )
if mibBuilder.loadTexts: mscLpArcProvTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services. Note that altering any of these parameters will result in a card reboot.')
mscLpArcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpArcIndex"))
if mibBuilder.loadTexts: mscLpArcProvEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcProvEntry.setDescription('An entry in the mscLpArcProvTable.')
mscLpArcTotalConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752)).clone(3072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcTotalConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcTotalConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute of the same name. This attribute specifies the maximum number of connections (both VCC and VPC) that can be enabled on the LogicalProcessor. If the LogicalProcessor is associated with a card of a cardType other than one of the following: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the value of the attribute restricts the sum of the (maxVccs + maxVpcs) across all AtmIfs bound to this LogicalProcessor. If the LogicalProcessor is associated with a card of one of the following cardTypes: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the number of available connections are distributed equally across the ports on the FP. The number of connections associated to a particular port will limit the size of the Vcc space defined by the ConnMap of the AtmIf linked to the port. Furthermore, the value of this attribute is restricted based on the number of ports on the card. For one port cards, the minimum is 512, the maximum is 4096 and the value must be divisible by 256. For two port cards, the minimum is 1024, the maximum is 8192 and the value must be divisible by 512. For three port cards, the minimum is 1536, the maximum is 7680 and the value must be divisible by 768. Increasing the value of this attribute reduces the CQM memory available for cell and frame free list. This attribute must be set to 0 is the connectionPoolCapacity attribute is set to non-zero values.')
mscLpArcMulticastBranchesCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcMulticastBranchesCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcMulticastBranchesCapacity.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute of the same name. This attribute specifies the number of multicast branches that can be enabled on the Logical Processor. A multicast branch is used for cell replication on a Vcc connection whose Vcc distributionType is pointToMultipoint. A branch represent one ATM destination for the replicated cells Increasing the value of this attribute reduces the CQM memory available for the cell and frame free lists.')
mscLpArcTxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcTxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcTxFrameMemoryAllocation.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute txCellMemoryAllocation. It is converted from frame percentage to cell percentage by subtracting this value from 100. This attribute specifies the percentage of the transmit CQM memory which should be allocated to the transmit frame free list on the ATM-FP. The remaining transmit CQM memory is allocated to the transmit cell free list. Frame memory is used for trunks, ATM VCC testing and for inter-card communication. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software will allocate the minimum required, rather than the actual number requested. The actual percentage of the transmit CQM memory allocated to the transmit frame free list is indicated by the Aru txFrameMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
mscLpArcRxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcRxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcRxFrameMemoryAllocation.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute rxCellMemoryAllocation. It is converted from frame percentage to cell percentage by subtracting this value from 100. This attribute specifies the percentage of the receive CQM memory which should be allocated to the receive frame free list on the ATM- FP. The remaining receive CQM memory is allocated to the receive cell free list. Frame memory is used for trunks, ATM VCC testing and for inter-card communication. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software will allocate the minimum required, rather than the actual number requested. The actual percentage of the receive CQM memory allocated to the receive frame free list is indicated by the Aru rxFrameMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP')
mscLpArcPerVcQueueInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcPerVcQueueInterfaces.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcPerVcQueueInterfaces.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute specifies the number of independent ports or IMA components which support shaping and per-Vc queueing on the LogicalProcessor. When this attribute is not zero, at most 4 independent ports or 4 Ima virtual links are supported, regardless of whether or not traffic shaping is enabled on the associated AtmIf components. In this case only independent port instances 0-3 or Ima instances 0-3 can be supported on an associated AtmIf component. For 2 ports cards, the valid values for this attribute are 0, 1, or 2. For 3 ports cards, the valid values for this attribute are 0, 1, or 3. For 8 ports cards, the valid values for this attribute are 0, 1, 2, or 4.')
mscLpArcShapingStackAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcShapingStackAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcShapingStackAllocation.setDescription('This attribute is migrated to the perVcQueueInterfaces attribute of the Lp/n Eng Arc Cqc Ov. Value ~0,~1,~2 is migrated to the value 0; value 0,~1,~2 is migrated to value 1; value 0,1,~2 is migrated to the value 2 and value 0,1,2 is migrated to the value 3 (for cardTypes 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm) or to the value 4 (for other cardTypes). This attribute specifies the allocation of shaping stack resources among the ports on this FP. Shaping stacks can currently be allocated on port 0, ports 0 and 1, or ports 0, 1 and 2. Allocating shaping stacks on a port allows the use of traffic shaping and per-Vc queueing on that port. Description of bits: n0(0) n1(1) n2(2)')
mscLpArcShapingScalingFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 40), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(14, 14), ValueRangeConstraint(20, 20), ValueRangeConstraint(28, 28), ValueRangeConstraint(40, 40), ValueRangeConstraint(56, 56), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcShapingScalingFactor.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcShapingScalingFactor.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute specifies the scaling factor which is to be applied to all shaping rates for this ATM-FP. The scaling factor is a multiplicative factor which is applied to the chosen shaping rate to produce an actual shaping rate. For example, if a shaping rate of 25 Mbps is used with a scaling factor of 2, the actual shaping rate is 12.5 Mbps.')
mscLpArcCdvAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcCdvAttenuation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcCdvAttenuation.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute cdvReduction. This attribute enables the attenuation of the maximum Cell Delay Variation (CDV) of shaped transmit traffic. When the value of this attribute is set to off, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is set to on, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS As can be noted from the equations above, setting this attribute to on can reduce the CDV significantly. CDV attenuation may be used to conform to policers which have strict Cell Delay Variance Tolerance (CDVT). However using this function reduces the transmit bandwidth utilization of the following cards: 3pDS3Atm, 3pOC3Atm.')
mscLpArcPortAggregation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcPortAggregation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcPortAggregation.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute portCongestionPolicy. This attribute specifies whether port aggregation is turned on or off for this ATM-FP. It applies only to transmit traffic served on the common queues and does not apply to perVc queues. When port aggregation is on, the enqueue decision of cells or frames to a common queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its queues: the low, medium and high emission priority queues. Thus, for example, if the low priority queue is congested, the high priority queue will also experience discards even though the high priority queue may itself not be congested. Setting port aggregation on assures that the low priority queues are also serviced in the event of congestion. When the value of this attribute is set to off, the enqueue decision of cells or frames to a common queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether or not the lower priority queues are being served.')
mscLpArcSubConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcSubConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcSubConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Fcrc Ov attribute of the same name. This attribute specifies the maximum number of sub-connections for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. Due to limited resources, not all of the provisioned number of sub- connections may be allocated. The actual number of sub- connections allocated is indicated by the sum of Aru subConnectionPoolAvailable and Aru SubConnectionPoolUsage attributes. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z When the sub-connection pool is exhausted, no more connections will be accepted from the services which utilize this pool.')
mscLpArcLnnConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 100, 1, 44), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcLnnConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcLnnConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Fcrc Ov attribute of the same name. This attribute specifies the maximum number of resource records for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. Due to limited resources, not all of the provisioned number of LNN connection resource records may be allocated. The actual number of resource records allocated is indicated by the sum of Aru lnnConnectionPoolAvailable and Aru lnnConnectionPoolUsage attributes. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool.')
mscLpArcConnCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 291), )
if mibBuilder.loadTexts: mscLpArcConnCapTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcConnCapTable.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute is provided for backward compatibility and can only be used if the LogicalProcessor is associated to a card of one of the following cardType: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm. This attribute can be used when the desired distribution of connections across ports cannot be achieved using the totalConnectionPoolCapacity attribute. This attribute defines the maximum number of connections (both VCC and VPC) that are available on each port. The entries are indexed by port number. This number limits the range of the ConnMap entries. Note that the value of this attribute must be evenly divisible by 256, and that port 2 supports at most 2560 connections, not the full 4096.')
mscLpArcConnCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 291, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpArcConnCapIndex"))
if mibBuilder.loadTexts: mscLpArcConnCapEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcConnCapEntry.setDescription('An entry in the mscLpArcConnCapTable.')
mscLpArcConnCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 291, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: mscLpArcConnCapIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcConnCapIndex.setDescription('This variable represents the mscLpArcConnCapTable specific index for the mscLpArcConnCapTable.')
mscLpArcConnCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 19, 291, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 4096), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpArcConnCapValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpArcConnCapValue.setDescription('This variable represents an individual value for the mscLpArcConnCapTable.')
mscLpAru = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20))
mscLpAruRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1), )
if mibBuilder.loadTexts: mscLpAruRowStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpAru components.')
mscLpAruRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"))
if mibBuilder.loadTexts: mscLpAruRowStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRowStatusEntry.setDescription('A single entry in the table represents a single mscLpAru component.')
mscLpAruRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpAru components. These components cannot be added nor deleted.')
mscLpAruComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruComponentName.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpAruStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruStorageType.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruStorageType.setDescription('This variable represents the storage type value for the mscLpAru tables.')
mscLpAruIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpAruIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruIndex.setDescription('This variable represents the index for the mscLpAru tables.')
mscLpAruOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100), )
if mibBuilder.loadTexts: mscLpAruOperTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services.')
mscLpAruOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"))
if mibBuilder.loadTexts: mscLpAruOperEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruOperEntry.setDescription('An entry in the mscLpAruOperTable.')
mscLpAruTotalConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTotalConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTotalConnectionPoolUsage.setDescription('If the LogicalProcessor is associated with a card of a cardType other than 4pE1Aal1 or 4pDS1Aal1, this attribute indicates the total number of enabled VCCs and VPCs in AtmIfs associated with this LogicalProcessor. An example of a VCC not in the enabled state is a VCC with a Test subcomponent. This attribute is equal to the sum of the AtmIf Ca connectionPoolUsage attributes of AtmIfs associated with this LogicalProcessor. If the LogicalProcessor is associated with a card of cardType 4pE1Aal1 or 4pDS1Aal1, this attribute indicates the total number of Ces components associated with this LogicalProcessor.')
mscLpAruMulticastBranchesUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruMulticastBranchesUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruMulticastBranchesUsage.setDescription('This attribute indicates the total number of multicast branches that are active on the Logical Processor.')
mscLpAruTxCellBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxCellBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCellBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing ATM cells to be transmitted by the Lp.')
mscLpAruTxCellBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 20), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxCellBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCellBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store ATM cells to be transmitted by the Lp.')
mscLpAruTxCellFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxCellFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCellFreeListSize.setDescription('This attribute indicates the current size of the transmit cell free list. The transmit cell free list is the memory available for storing ATM cells to be transmitted by the Lp.')
mscLpAruTxCellFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxCellFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCellFreeListCongestionState.setDescription('This attribute indicates the congestion state of the transmit cell free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
mscLpAruTxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFrameMemoryAllocation.setDescription('This attribute defines the percentage of the transmit CQM memory which is allocated to the transmit frame free list on the ATM-FP. The remaining transmit CQM memory is allocated to the transmit cell free list. Frame memory is used for trunks, ATM Vcc testing and for inter-card communication.')
mscLpAruTxFrameBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFrameBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFrameBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing frames to be transmitted by the Lp.')
mscLpAruTxFrameBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 50), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFrameBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFrameBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store frames to be transmitted by the Lp.')
mscLpAruTxFrameFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 53), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFrameFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFrameFreeListSize.setDescription('This attribute indicates the current size of the transmit frame free list. The transmit frame free list is the memory (in ATM cells) available for storing frames to be transmitted by the Lp.')
mscLpAruTxFrameFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFrameFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFrameFreeListCongestionState.setDescription('This attribute indicates the congestion state of the transmit frame free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
mscLpAruRxCellBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxCellBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCellBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing ATM cells received by the Lp.')
mscLpAruRxCellBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 70), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxCellBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCellBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store ATM cells received by the Lp.')
mscLpAruRxCellFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxCellFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCellFreeListSize.setDescription('This attribute indicates the current size of the receive cell free list. The receive cell free list is the memory available for storing ATM cells received by the Lp.')
mscLpAruRxCellFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxCellFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCellFreeListCongestionState.setDescription('This attribute indicates the congestion state of the receive cell free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
mscLpAruRxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 80), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFrameMemoryAllocation.setDescription('This attribute indicates the percentage of the receive CQM memory which is allocated to the receive frame free list on the ATM-FP. The remaining receive CQM memory is allocated to the receive cell free list. Frame memory is used for trunks, ATM Vcc testing and for inter-card communication.')
mscLpAruRxFrameBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 90), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFrameBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFrameBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing frames received by the Lp.')
mscLpAruRxFrameBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 100), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFrameBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFrameBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store frames received by the Lp.')
mscLpAruRxFrameFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 103), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFrameFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFrameFreeListSize.setDescription('This attribute indicates the current size of the receive frame free list. The receive frame free list is the memory (in ATM cells) available for storing frames received by the Lp.')
mscLpAruRxFrameFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 106), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFrameFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFrameFreeListCongestionState.setDescription('This attribute indicates the congestion state of the receive frame free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
mscLpAruSubConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 107), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruSubConnectionPoolAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruSubConnectionPoolAvailable.setDescription('This attribute indicates the number of sub-connections available for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z Note when the value of this attribute reaches zero, no more connections will be accepted for any of the services which utilize this pool. To increase the size of this pool, use the Arc subConnectionPoolCapacity attribute.')
mscLpAruSubConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 108), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruSubConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruSubConnectionPoolUsage.setDescription('This attribute indicates the number of sub-connections being utilized for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z')
mscLpAruLnnConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 109), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruLnnConnectionPoolAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruLnnConnectionPoolAvailable.setDescription('This attribute indicates the number of resource records available for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool. Note, when the value of this attribute reaches zero, no more connections will be accepted for any of the services which utilize this pool. To increase the size of this pool, use the Arc lnnConnectionPoolCapacity attribute.')
mscLpAruLnnConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 100, 1, 110), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruLnnConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruLnnConnectionPoolUsage.setDescription('This attribute indicates the number of resource records being utilized for the connections which use Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is applied at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool.')
mscLpAruConnUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 292), )
if mibBuilder.loadTexts: mscLpAruConnUsageTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruConnUsageTable.setDescription('This attribute has been replaced by the set of AtmIf CA connectionPoolUsage attributes for AtmIf associated to independent links or IMA groups on this LogicalProcessor. The change better encapsulates the information associated with the AtmIf. This attribute indicates the number of connection identifiers (both VCC and VPC) that are in use on each port. The entries are indexed by port number.')
mscLpAruConnUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 292, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruConnUsageIndex"))
if mibBuilder.loadTexts: mscLpAruConnUsageEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruConnUsageEntry.setDescription('An entry in the mscLpAruConnUsageTable.')
mscLpAruConnUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 292, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: mscLpAruConnUsageIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruConnUsageIndex.setDescription('This variable represents the mscLpAruConnUsageTable specific index for the mscLpAruConnUsageTable.')
mscLpAruConnUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 292, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruConnUsageValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruConnUsageValue.setDescription('This variable represents an individual value for the mscLpAruConnUsageTable.')
mscLpAruTxCflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 353), )
if mibBuilder.loadTexts: mscLpAruTxCflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCflThreshTable.setDescription('This attribute indicates the maximum value of the txCellFreeListSize and the discard thresholds of the transmit cell free list. The transmit cell free list is the memory used for storing ATM cells to be transmitted by the Lp. The first value indicates the maximum size of the transmit cell free list. This is derived based upon the connectionPoolCapacity and the txFrameMemoryAllocation under the ARC component. When the txCellFreeListSize decreases to the second value, the txCellFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum transmit cell free list size. When the txCellFreeListSize decreases to the third value, the txCellFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum transmit cell free list size. When the txCellFreeListSize decreases to the fourth value, the txCellFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum transmit cell free list size.')
mscLpAruTxCflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 353, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruTxCflThreshIndex"))
if mibBuilder.loadTexts: mscLpAruTxCflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCflThreshEntry.setDescription('An entry in the mscLpAruTxCflThreshTable.')
mscLpAruTxCflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 353, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpAruTxCflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCflThreshIndex.setDescription('This variable represents the mscLpAruTxCflThreshTable specific index for the mscLpAruTxCflThreshTable.')
mscLpAruTxCflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 353, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxCflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxCflThreshValue.setDescription('This variable represents an individual value for the mscLpAruTxCflThreshTable.')
mscLpAruTxFflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 354), )
if mibBuilder.loadTexts: mscLpAruTxFflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFflThreshTable.setDescription('This attribute indicates the maximum txFrameFeeListSize and the discard thresholds of the transmit frame free list. The transmit frame free list is the memory (in units of ATM cells) used for storing frames to be transmitted by the Lp. The first parameter indicates the total size of the transmit frame free list. This is derived based upon the connectionPoolCapacity and the txFrameMemoryAllocation under the ARC component. When the txFrameFreeListSize decreases to the second value, the txFrameFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum transmit frame free list size. When the txFrameFreeListSize decreases to the third value, the txFrameFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum transmit frame free list size. When the txFameFreeListSize decreases to the fourth value, the txFameFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum transmit frame free list size.')
mscLpAruTxFflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 354, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruTxFflThreshIndex"))
if mibBuilder.loadTexts: mscLpAruTxFflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFflThreshEntry.setDescription('An entry in the mscLpAruTxFflThreshTable.')
mscLpAruTxFflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 354, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpAruTxFflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFflThreshIndex.setDescription('This variable represents the mscLpAruTxFflThreshTable specific index for the mscLpAruTxFflThreshTable.')
mscLpAruTxFflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 354, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruTxFflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruTxFflThreshValue.setDescription('This variable represents an individual value for the mscLpAruTxFflThreshTable.')
mscLpAruRxCflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 355), )
if mibBuilder.loadTexts: mscLpAruRxCflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCflThreshTable.setDescription('This attribute indicates the maximum value of the rxCellFreeListSize and the discard thresholds of the receive cell free list. The receive cell free list is the memory used for storing ATM cells to be received by the Lp. The first value indicates the maximum size of the recieve cell free list. This is derived based upon the connectionPoolCapacity and the rxFrameMemoryAllocation under the ARC component. When the rxCellFreeListSize decreases to the second value, the rxCellFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum receive cell free list size. When the rxCellFreeListSize decreases to the third value, the rxCellFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum receive cell free list size. When the rxCellFreeListSize decreases to the fourth value, the rxCellFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum receive cell free list size.')
mscLpAruRxCflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 355, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruRxCflThreshIndex"))
if mibBuilder.loadTexts: mscLpAruRxCflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCflThreshEntry.setDescription('An entry in the mscLpAruRxCflThreshTable.')
mscLpAruRxCflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 355, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpAruRxCflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCflThreshIndex.setDescription('This variable represents the mscLpAruRxCflThreshTable specific index for the mscLpAruRxCflThreshTable.')
mscLpAruRxCflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 355, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxCflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxCflThreshValue.setDescription('This variable represents an individual value for the mscLpAruRxCflThreshTable.')
mscLpAruRxFflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 356), )
if mibBuilder.loadTexts: mscLpAruRxFflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFflThreshTable.setDescription('This attribute indicates the maximum rxFrameFeeListSize and the discard thresholds of the transmit frame free list. The receive frame free list is the memory (in units of ATM cells) used for storing frames to be received by the Lp. The first parameter indicates the total size of the receive frame free list. This is derived based upon the connectionPoolCapacity and the rxFrameMemoryAllocation under the ARC component. When the rxFrameFreeListSize decreases to the second value, the rxFrameFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum receive frame free list size. When the rxFrameFreeListSize decreases to the third value, the rxFrameFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum receive frame free list size. When the rxFameFreeListSize decreases to the fourth value, the rxFameFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum receive frame free list size.')
mscLpAruRxFflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 356, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpAruRxFflThreshIndex"))
if mibBuilder.loadTexts: mscLpAruRxFflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFflThreshEntry.setDescription('An entry in the mscLpAruRxFflThreshTable.')
mscLpAruRxFflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 356, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpAruRxFflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFflThreshIndex.setDescription('This variable represents the mscLpAruRxFflThreshTable specific index for the mscLpAruRxFflThreshTable.')
mscLpAruRxFflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 20, 356, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAruRxFflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscLpAruRxFflThreshValue.setDescription('This variable represents an individual value for the mscLpAruRxFflThreshTable.')
mscLpEngArc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5))
mscLpEngArcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1), )
if mibBuilder.loadTexts: mscLpEngArcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArc components.')
mscLpEngArcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"))
if mibBuilder.loadTexts: mscLpEngArcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArc component.')
mscLpEngArcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArc components. These components can be added and deleted.')
mscLpEngArcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcStorageType.setDescription('This variable represents the storage type value for the mscLpEngArc tables.')
mscLpEngArcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngArcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcIndex.setDescription('This variable represents the index for the mscLpEngArc tables.')
mscLpEngArcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10), )
if mibBuilder.loadTexts: mscLpEngArcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services. The attributes listed represent Queue Controller resource usage for all ATM Cards (CQC for CQC based cards or PQC for SGAF cards).')
mscLpEngArcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"))
if mibBuilder.loadTexts: mscLpEngArcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOperEntry.setDescription('An entry in the mscLpEngArcOperTable.')
mscLpEngArcTotalConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTotalConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTotalConnectionPoolAvailable.setDescription('This attribute indicates the number of connection resources available (VCC, VPC, and VPT) that can be used on this FP. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
mscLpEngArcTotalConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTotalConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTotalConnectionPoolUsage.setDescription('This attribute indicates the number of connection resources (VCC, VPC, and VPT) in use on this FP. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
mscLpEngArcMulticastBranchesAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcMulticastBranchesAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcMulticastBranchesAvailable.setDescription('This attribute indicates the total number of multicast branches that are available on this FP.')
mscLpEngArcMulticastBranchesUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcMulticastBranchesUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcMulticastBranchesUsage.setDescription('This attribute indicates the total number of multicast branches that are active on this FP.')
mscLpEngArcTxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryAllocation.setDescription('This attribute indicates the fraction of the transmit memory which is allocated for the transmission of cells on the FP. Cell memory is used for Atm Bearer Services, ATM SVCs and ATM PVCs. The remaining transmit memory is allocated for the transmission of frames. Frame memory is used for trunks, ATM VCC testing and for inter-card communication.')
mscLpEngArcTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by this FP.')
mscLpEngArcTxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryMinAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by this FP. This value is reset to the current availability every 15 minutes and when the card is reset.')
mscLpEngArcTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit cell memory on this FP. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) 0 to 'x' is processed. Traffic with DP > 'x' is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is stored.")
mscLpEngArcRxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryAllocation.setDescription('This attribute indicates the fraction of the receive memory which is allocated for the reception of cells on the FP. Cell memory is used for Atm Bearer Services, ATM SVCS and ATM PVCS. The remaining receive memory is allocated to the reception of frame. Frame memory is used for trunks, ATM VCC testing and for inter-card communication.')
mscLpEngArcRxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the receive cell memory. The receive cell memory is the memory available for storing ATM cells to be transmitted by this FP.')
mscLpEngArcRxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryMinAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the receive cell memory. The receive cell memory is the memory available for storing ATM cells to be transmitted by this FP. This value is reset to the current availability every 15 minutes and when the card is reset.')
mscLpEngArcRxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 10, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the receive cell memory on this FP. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) 0 to 'x' is processed. Traffic with DP > 'x' is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is stored.")
mscLpEngArcTxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 440), )
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshTable.setDescription('This attribute indicates the total transmit cell memory size and the discard thresholds of the transmit cell memory. The transmit cell memory is the memory used for storing ATM cells to be transmitted by this FP. The first value indicates the the total transmit cell memory size. This is derived based upon the connectionPoolCapacity and the txCellMemoryAllocation attributes. When the txCellMemoryAvailable attribute decreases to the second value, the txCellMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the total transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the third value, the txCellMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) >= 2 is discarded. This threshold is set approximately at 20 percent of the first value, the total transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the fourth value, the txCellMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) >= 1 is discarded. This threshold is set approximately at 10 percent of the first value, the total transmit cell memory size. The opposite effect occurs when the txCellMemoryAvailable attribute increases (txCellMemoryCongestionState increases from 0 to 3 accordingly).')
mscLpEngArcTxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 440, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcTxCellThreshIndex"))
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshEntry.setDescription('An entry in the mscLpEngArcTxCellThreshTable.')
mscLpEngArcTxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 440, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshIndex.setDescription('This variable represents the mscLpEngArcTxCellThreshTable specific index for the mscLpEngArcTxCellThreshTable.')
mscLpEngArcTxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 440, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcTxCellThreshValue.setDescription('This variable represents an individual value for the mscLpEngArcTxCellThreshTable.')
mscLpEngArcRxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 444), )
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshTable.setDescription('This attribute indicates the total receive cell memory size and the discard thresholds of the receive cell memory. The receive cell memory is the memory used for storing ATM cells to be received by this FP. The first value indicates the total receive cell memory size. This is derived based upon the connectionPoolCapacity and the rxCellMemoryAllocation under the ARC component. When the rxCellMemoryAvailable attribute decreases to the second value, the rxCellMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the total receive cell memory size. When the rxCellMemoryAvailable attribute decreases to the third value, the rxCellMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) >= 2 is discarded. This threshold is set approximately at 20 percent of the first value, the total receive cell memory size. When the rxCellMemoryAvailable attribute decreases to the fourth value, the rxCellMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) >= 1 is discarded. This threshold is set approximately at 10 percent of the first value, the total receive cell memory size. The opposite effect occurs when the rxCellMemoryAvailable attribute increases (rxCellMemoryCongestionState increases from 0 to 3 accordingly).')
mscLpEngArcRxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 444, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcRxCellThreshIndex"))
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshEntry.setDescription('An entry in the mscLpEngArcRxCellThreshTable.')
mscLpEngArcRxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 444, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshIndex.setDescription('This variable represents the mscLpEngArcRxCellThreshTable specific index for the mscLpEngArcRxCellThreshTable.')
mscLpEngArcRxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 444, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcRxCellThreshValue.setDescription('This variable represents an individual value for the mscLpEngArcRxCellThreshTable.')
mscLpEngArcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2))
mscLpEngArcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1), )
if mibBuilder.loadTexts: mscLpEngArcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArcOv components.')
mscLpEngArcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArcOv component.')
mscLpEngArcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArcOv components. These components can be added and deleted.')
mscLpEngArcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngArcOv tables.')
mscLpEngArcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngArcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvIndex.setDescription('This variable represents the index for the mscLpEngArcOv tables.')
mscLpEngArcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10), )
if mibBuilder.loadTexts: mscLpEngArcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services on ATM cards. Note that altering any of these parameters will result in a card reboot.')
mscLpEngArcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvProvEntry.setDescription('An entry in the mscLpEngArcOvProvTable.')
mscLpEngArcOvTotalConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768)).clone(3072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcOvTotalConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvTotalConnectionPoolCapacity.setDescription('This attribute specifies the maximum number of connections (VCC, VPC and VPT) that can be enabled on this FP.A standard Vpt uses 3 connections and a basic Vpt uses 2. If the LogicalProcessor is associated with a card of a cardType other than one of the following: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the value of the attribute restricts the sum of the (maxVccs + maxVpcs + (maxVpts * 3)) across all AtmIfs bound to this LogicalProcessor. If the LogicalProcessor is associated with a card of one of the following cardTypes: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the number of available connections are distributed equally across the ports on the FP. The number of connections associated to a particular port limits the size of the Vcc space which can be defined by the ConnMap of the AtmIf linked to the port. If the ConnMap component does not exist, its default settings are used for this check. Furthermore, the value of this attribute is restricted based on the number of ports on the card. For one port cards, the minimum is 512, the maximum is 4096 and the value must be divisible by 256. For two port cards, the minimum is 1024, the maximum is 8192 and the value must be divisible by 512. For three port cards, the minimum is 1536, the maximum is 7680 and the value must be divisible by 768. If the LogicalProcessor is associated with a card of one of the following cardTypes: 8pE1Atm, 8pDS1Atm, the maximum value for this attribute is 10752. For SGAF cards, the Connmap attributes are set to their default values. Increasing the value of this attribute reduces the memory available for cell and frame memory. This attribute must be set to 0 if the connectionPoolCapacity attribute of the Arc Ov component is set to non-zero values.')
mscLpEngArcOvMulticastBranchesCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcOvMulticastBranchesCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvMulticastBranchesCapacity.setDescription('This attribute specifies the number of multicast branches that can be enabled on this FP. A multicast branch is used for cell replication on a VCC connection whose Vcc distributionType is pointToMultipoint. A branch represents one ATM destination for the replicated cells. Increasing the value of this attribute reduces the memory available for the cell and frame memorys. This attribute is ignored for the 1pOC48SmSrAtm card as it does not support multicast connections. For CQC based ATM FPs, the maximum value for this attribute is 10752.')
mscLpEngArcOvTxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcOvTxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvTxCellMemoryAllocation.setDescription('This attribute specifies the fraction of the transmit memory which should be allocated to the transmission of cells on an FP. The remaining memory is allocated for the transmission of frames. Frame memory is used for trunks, ATM VCC testing and for inter- card communication. Cell memory is used for Atm Bearer Service, ATM SVCs and ATM PVCs. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software allocates the minimum required, rather than the actual number requested. The actual percentage of the transmit memory allocated to the transmit cell memory is indicated by the Arc txCellMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
mscLpEngArcOvRxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcOvRxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcOvRxCellMemoryAllocation.setDescription('This attribute specifies the fraction of the receive memory which should be allocated to the reception of cells on an FP. The remaining receive memory is allocated for the reception of frames. Frame memory is used for trunks, ATM VCC testing and for inter- card communication. Cell memory is used for Atm Bearer Service, ATM SVCs and ATM PVCs. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software allocates the minimum required, rather than the actual number requested. The actual percentage of the receive memory allocated to the receive cell memory is indicated by the Arc rxCellMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
mscLpEngArcCqc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3))
mscLpEngArcCqcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1), )
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArcCqc components.')
mscLpEngArcCqcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcIndex"))
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArcCqc component.')
mscLpEngArcCqcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArcCqc components. These components can be added and deleted.')
mscLpEngArcCqcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcCqcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcStorageType.setDescription('This variable represents the storage type value for the mscLpEngArcCqc tables.')
mscLpEngArcCqcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngArcCqcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcIndex.setDescription('This variable represents the index for the mscLpEngArcCqc tables.')
mscLpEngArcCqcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 10), )
if mibBuilder.loadTexts: mscLpEngArcCqcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services on a CQC based card.')
mscLpEngArcCqcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcIndex"))
if mibBuilder.loadTexts: mscLpEngArcCqcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOperEntry.setDescription('An entry in the mscLpEngArcCqcOperTable.')
mscLpEngArcCqcCdvReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("cardDependent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcCdvReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcCdvReduction.setDescription('This attribute indicates if the reduction of the maximum Cell Delay Variation (CDV) of shaped transmit traffic is applicable. When the value of this attribute is disabled, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is enabled, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS')
mscLpEngArcCqcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2))
mscLpEngArcCqcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1), )
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArcCqcOv components.')
mscLpEngArcCqcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArcCqcOv component.')
mscLpEngArcCqcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArcCqcOv components. These components cannot be added nor deleted.')
mscLpEngArcCqcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcCqcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcCqcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngArcCqcOv tables.')
mscLpEngArcCqcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngArcCqcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvIndex.setDescription('This variable represents the index for the mscLpEngArcCqcOv tables.')
mscLpEngArcCqcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10), )
if mibBuilder.loadTexts: mscLpEngArcCqcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services. Note that altering any of these parameters will result in a card reboot.')
mscLpEngArcCqcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcCqcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvProvEntry.setDescription('An entry in the mscLpEngArcCqcOvProvTable.')
mscLpEngArcCqcOvPerVcQueueInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcOvPerVcQueueInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvPerVcQueueInterfaces.setDescription('This attribute specifies the number of independent ports or IMA components which support shaping and per-VC queueing on this FP. When this attribute is not zero, at most 4 independent ports or 4 Ima virtual links are supported, regardless of whether or not traffic shaping is enabled on the associated AtmIf components. In this case only independent port instances 0-3 or Ima instances 0-3 can be supported on an associated AtmIf component. For 2 ports cards, the valid values for this attribute are 0, 1, or 2. For 3 ports cards, the valid values for this attribute are 0, 1, 2 or 3. For 8 ports cards, the valid values for this attribute are 0, 1, 2, or 4.')
mscLpEngArcCqcOvShapingScalingFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10, 1, 2), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(14, 14), ValueRangeConstraint(20, 20), ValueRangeConstraint(28, 28), ValueRangeConstraint(40, 40), ValueRangeConstraint(56, 56), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcOvShapingScalingFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvShapingScalingFactor.setDescription('This attribute specifies the scaling factor which is to be applied to all shaping rates for this FP. The scaling factor is an inverse factor which is applied to the chosen shaping rate to produce an actual shaping rate. For example, if a shaping rate of 25 Mbit/s is used with a scaling factor of 2, the actual shaping rate is 12.5 Mbit/s.')
mscLpEngArcCqcOvCdvReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("cardDependent", 2))).clone('cardDependent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcOvCdvReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvCdvReduction.setDescription('This attribute specifies the reduction of the maximum Cell Delay Variation (CDV) of shaped transmit traffic. When the value of this attribute is set to disabled, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is set to enabled, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS As can be noted from the equations above, setting this attribute to enabled can reduce the CDV significantly. CDV reduction may be used to conform to policers which have strict Cell Delay Variance Tolerance (CDVT). However using this function reduces the transmit bandwidth utilization of the following cards: 3pDS3Atm, 3pOC3Atm, 2pJ6MAtm. When the value is cardDependent, CDV reduction is disabled for cardtypes 3pDS3Atm, 3pOC3Atm, 2pJ6MAtm, 4pDS1Aal1, 4pE1Aal1 and enabled for all other cards.')
mscLpEngArcCqcOvPortCongestionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aggregate", 0), ("individualQueue", 1))).clone('aggregate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcOvPortCongestionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvPortCongestionPolicy.setDescription('This attribute specifies the congestion behavior of all ports on this FP. It applies only to transmit traffic served on the common queues and does not apply to per-VC queues. When the value is aggregate, the enqueue decision of cells or frames to a common queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its common queues: the low, medium and high emission priority queues. Thus, for example, if the low priority queue is congested, the high priority queue also experiences discards even though the high priority queue may itself not be congested. Setting this attribute to aggregate assures that the low priority queues are also serviced in the event of congestion. When the value of this attribute is set to individualQueue, the enqueue decision of cells or frames to a common queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether the lower priority queues are being served.')
mscLpEngArcCqcOvConnCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 450), )
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapTable.setDescription('This attribute is provided for backward compatibility and can only be used if the LogicalProcessor is associated with a card of one of the following cardType: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm. This attribute can be used when the desired distribution of connections across ports cannot be achieved using the totalConnectionPoolCapacity attribute. This attribute defines the maximum number of connections (VCC, VPC and VPT) that are available on each port. A basic Vpt uses 2 connections. The entries are indexed by port number. This number limits the range of the ConnMap entries. If the Connmap component does not exist, its default settings are used for this check. Note that the value of this attribute must be evenly divisible by 256, and that port 2 supports at most 2560 connections, not the full 4096. The connection pool for each port must be set to 0 if the totalConnectionPoolCapacity attribute is set to a non-zero value.')
mscLpEngArcCqcOvConnCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 450, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcOvIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcCqcOvConnCapIndex"))
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapEntry.setDescription('An entry in the mscLpEngArcCqcOvConnCapTable.')
mscLpEngArcCqcOvConnCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 450, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapIndex.setDescription('This variable represents the mscLpEngArcCqcOvConnCapTable specific index for the mscLpEngArcCqcOvConnCapTable.')
mscLpEngArcCqcOvConnCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 3, 2, 450, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 4096), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcCqcOvConnCapValue.setDescription('This variable represents an individual value for the mscLpEngArcCqcOvConnCapTable.')
mscLpEngArcAqm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4))
mscLpEngArcAqmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1), )
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArcAqm components.')
mscLpEngArcAqmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmIndex"))
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArcAqm component.')
mscLpEngArcAqmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArcAqm components. These components can be added and deleted.')
mscLpEngArcAqmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcAqmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmStorageType.setDescription('This variable represents the storage type value for the mscLpEngArcAqm tables.')
mscLpEngArcAqmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngArcAqmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmIndex.setDescription('This variable represents the index for the mscLpEngArcAqm tables.')
mscLpEngArcAqmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10), )
if mibBuilder.loadTexts: mscLpEngArcAqmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOperTable.setDescription('This group describes the usage of ATM-specific resources for a specific AQM on a Logical Processor running ATM services.')
mscLpEngArcAqmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmIndex"))
if mibBuilder.loadTexts: mscLpEngArcAqmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOperEntry.setDescription('An entry in the mscLpEngArcAqmOperTable.')
mscLpEngArcAqmConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmConnectionPoolAvailable.setDescription('This attribute indicates the number of connection resources available (VCC, VPC and VPT) that can be configured on the AQM instance of the LogicalProcessor. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
mscLpEngArcAqmConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmConnectionPoolUsage.setDescription('This attribute indicates the total number of configured VCCs, VPCs and VPTs in AtmIfs associated with the AQM instance of the LogicalProcessor. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
mscLpEngArcAqmTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by the Lp.')
mscLpEngArcAqmTxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryMinAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by the Lp. This attribute is reset to the current availability every 15 minutes and when the card is reset.')
mscLpEngArcAqmTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit cell memory on this FP. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) 0 to 'x' is processed. Traffic with DP > 'x' is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is processed.")
mscLpEngArcAqmTxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 448), )
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshTable.setDescription('This attribute indicates the total transmit cell memory size and the discard thresholds of the transmit cell memory. The transmit cell memory is the memory used for storing ATM cells to be transmitted by the Lp. The first value indicates the total transmit cell memory size. This is derived based upon the connectionPoolCapacity value. When the txCellMemoryAvailable attribute decreases to the second value, the txCellMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the total transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the third value, the txCellMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) >= 2 is discarded. This threshold is set approximately at 20 percent of the first value, the total transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the fourth value, the txCellMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) >= 1 is discarded. This threshold is set approximately at 10 percent of the first value, the total transmit cell memory size. The opposite effect occurs when the txCellMemoryAvailable attribute increases (txCellMemoryCongestionState increases from 0 to 3 accordingly)')
mscLpEngArcAqmTxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 448, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmTxCellThreshIndex"))
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshEntry.setDescription('An entry in the mscLpEngArcAqmTxCellThreshTable.')
mscLpEngArcAqmTxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 448, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshIndex.setDescription('This variable represents the mscLpEngArcAqmTxCellThreshTable specific index for the mscLpEngArcAqmTxCellThreshTable.')
mscLpEngArcAqmTxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 448, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmTxCellThreshValue.setDescription('This variable represents an individual value for the mscLpEngArcAqmTxCellThreshTable.')
mscLpEngArcAqmOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2))
mscLpEngArcAqmOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1), )
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngArcAqmOv components.')
mscLpEngArcAqmOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngArcAqmOv component.')
mscLpEngArcAqmOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngArcAqmOv components. These components cannot be added nor deleted.')
mscLpEngArcAqmOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngArcAqmOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngArcAqmOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngArcAqmOv tables.')
mscLpEngArcAqmOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngArcAqmOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvIndex.setDescription('This variable represents the index for the mscLpEngArcAqmOv tables.')
mscLpEngArcAqmOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10), )
if mibBuilder.loadTexts: mscLpEngArcAqmOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services on CQC based cards. Note that altering any of these parameters will result in a card reboot.')
mscLpEngArcAqmOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngArcAqmOvIndex"))
if mibBuilder.loadTexts: mscLpEngArcAqmOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvProvEntry.setDescription('An entry in the mscLpEngArcAqmOvProvTable.')
mscLpEngArcAqmOvConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcAqmOvConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvConnectionPoolCapacity.setDescription('This attribute specifies the maximum number of connections (VCC, VPC and VPT) that can be configured on the AQM instance of the LogicalProcessor. The value of the attribute restricts the sum of the (maxVccs + maxVpcs +(maxVpts * 3)) across all AtmIfs bound to this AQM instance. Note that 3 connections are used for each standard Vpt and 2 for each basic Vpt. The value of this attribute should be less than than or equal to totalConnectionPoolCapacity of the Arc component. The default value derivedFromArc is obtained using the following equation: totalConnectionPoolCapacity / number of AQM component on FP. VALUES ( 0 = derivedFromArc )')
mscLpEngArcAqmOvHighPriorityEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 1024)).clone(28)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcAqmOvHighPriorityEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvHighPriorityEpdOffset.setDescription('This attribute specifies the high priority Early Packet Discard (EPD) offset for connection queues. On ATM IP FPs a given connection queue is associated with one of eight emission priorities (EP). These include six unshaped EPs, one exclusive VBR shaper EP and one ABR/VBR shaper EP. This attribute specifies the EPD offset for the exclusive VBR shaper EP and the first four (higher priority) unshaped EPs. This offset is used to derive a connection EPD threshold for a given Congestion Control (CC) level by subtracting the offset from the All Packet Discard (APD) threshold at the same CC level. The APD thresholds are themselves derived from the transmit queue limit. The EPD threshold only applies to a connection if the txPacketWiseDiscard feature is requested. The txPacketWiseDiscard feature can be enabled only if the transmit queue limit is at least 5.71 times the EPD offset. This ensures that the derived EPD threshold will never be less than 17.5 % of the transmit queue limit. If this condition is not satisfied, txPacketWiseDiscard for the connection will be automatically disabled. Due to the above constraint, if the operator wishes to decrease the transmit queue limit and still have txPacketWiseDiscard enabled on the connection then this offset must be set to a lower value that meets the above requirement. Due to hardware granularity the actual value of the EPD offset may not match exactly the value provisioned. The actual value is displayed under the ATM Connection Administrator service category subcomponents on ATM IP FPs. This attribute does not apply to CQC FPs.')
mscLpEngArcAqmOvLowPriorityEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 1024)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcAqmOvLowPriorityEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvLowPriorityEpdOffset.setDescription('This attribute specifies the low priority Early Packet Discard (EPD) offset for connection queues. On ATM IP FPs a given connection queue is associated with one of eight emission priorities (EP). These include six unshaped EPs, one exclusive VBR shaper EP and one ABR/VBR shaper EP. This attribute specifies the EPD offset for the exclusive ABR/VBR shaper EP and the last two (lower priority) unshaped EPs. This offset is used to derive a connection EPD threshold for a given Congestion Control (CC) level by subtracting the offset from the All Packet Discard (APD) threshold at the same CC level. The APD thresholds are themselves derived from the transmit queue limit. The EPD threshold only applies to a connection if the txPacketWiseDiscard feature is requested. The txPacketWiseDiscard feature can be enabled only if the transmit queue limit is at least 5.71 times the EPD offset. This ensures that the derived EPD threshold will never be less than 17.5 % of the transmit queue limit. If this condition is not satisfied, txPacketWiseDiscard for the connection will be automatically disabled. Due to the above constraint, if the operator wishes to decrease the transmit queue limit and still have txPacketWiseDiscard enabled on the connection then this offset must be set to a lower value that meets the above requirement. Due to hardware granularity the actual value of the EPD offset may not match exactly the value provisioned. The actual value is displayed under the ATM Connection Administrator service category subcomponents on ATM IP FPs. This attribute does not apply to CQC FPs.')
mscLpEngArcAqmOvPortCongestionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 5, 4, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aggregate", 0), ("individualQueue", 1))).clone('individualQueue')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngArcAqmOvPortCongestionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngArcAqmOvPortCongestionPolicy.setDescription('This attribute specifies the congestion behavior of all ports on this FP. It applies only to transmit traffic and does not apply to the CBR service category. When the value is aggregate, the enqueue decision of cells or frames to a queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its queues. Thus, for example, if a nrtVBR queue is congested, the rtVBR queue also experiences discards even though the rtVBR queue may itself not be congested. Setting this attribute to aggregate assures that the low priority queues are also serviced in the event of congestion. If this attribute is set to aggregate then rtVBR must not be configured to do common queueing and its emissionPriority should be set to a number numerically smaller than or equal to 3. Another impact of setting this attribute to aggregate is that the per connection queue limits for nrtVBR and UBR connections will be increased to the link pool size and their discard thresholds will be modified to be aligned with the free list discard thresholds. When the value of this attribute is set to individualQueue, the enqueue decision of cells or frames to a queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether the lower priority queues are being served. On 3pOC3SmAtm2 and 3pOC3MmAtm2 cards, if more than one override component exists, they must have the same setting for this attribute. Otherwise, setting the attribute under one override component applies to the entire card.')
mscLpEngFcrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6))
mscLpEngFcrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1), )
if mibBuilder.loadTexts: mscLpEngFcrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngFcrc components.')
mscLpEngFcrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngFcrc component.')
mscLpEngFcrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngFcrc components. These components can be added and deleted.')
mscLpEngFcrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngFcrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcStorageType.setDescription('This variable represents the storage type value for the mscLpEngFcrc tables.')
mscLpEngFcrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngFcrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcIndex.setDescription('This variable represents the index for the mscLpEngFcrc tables.')
mscLpEngFcrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10), )
if mibBuilder.loadTexts: mscLpEngFcrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOperTable.setDescription('This group indicates the configuration of processor-wide frame specific resources on a LogicalProcessor.')
mscLpEngFcrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOperEntry.setDescription('An entry in the mscLpEngFcrcOperTable.')
mscLpEngFcrcSubConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 49152))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcSubConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcSubConnectionPoolAvailable.setDescription('This attribute indicates the number of sub-connections available for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n Note: When the value of this attribute reaches zero, no more connections are accepted for any of the services which utilize this pool. To increase the size of this pool, use the Lp Eng Fcrc Ov subConnectionPoolCapacity attribute.')
mscLpEngFcrcSubConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 49152))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcSubConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcSubConnectionPoolUsage.setDescription('This attribute indicates the number of sub-connections being utilized by the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n')
mscLpEngFcrcLnnConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcLnnConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcLnnConnectionPoolAvailable.setDescription('This attribute indicates the number of resource records available for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of Passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool. When the value of this attribute reaches zero, no more connections are accepted for any of the services which utilize this pool. To increase the size of this pool, use the Fcrc Ov lnnConnectionPoolCapacity attribute.')
mscLpEngFcrcLnnConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcLnnConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcLnnConnectionPoolUsage.setDescription('This attribute indicates the number of resource records being utilized for the connections which use Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of Passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is applied at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool.')
mscLpEngFcrcTxFrameMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit frame memory (in units of frames). The transmit frame memory is the memory available for storing frames to be transmitted by this FP.')
mscLpEngFcrcTxFrameMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryMinAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit PQC/ CQC frame memory (in units of frames). The transmit frame memory is the memory available for storing frames to be transmitted by this FP. This value is reset every 15 minutes and when the card is reset.')
mscLpEngFcrcTxFrameMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrameMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit frame memory on this FP. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) 0 to 'x' is processed. Traffic with DP > 'x' is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is processed. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is processed.")
mscLpEngFcrcRxFrameMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryAvailable.setDescription('This attribute indicates the current availability of the receive frame memory (in units of frames). The receive frame memory is the memory available for storing frames received by this FP.')
mscLpEngFcrcRxFrameMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryMinAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the receive frame memory (in units of frames). The receive frame memory is the memory available for storing frames received by this FP. This value is reset every 15 minutes and when the card is reset.')
mscLpEngFcrcRxFrameMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrameMemoryCongestionState.setDescription("This attribute indicates the congestion state of the receive frame memory on this FP. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) 0 to 'x' is processed. Traffic with DP > 'x' is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is stored.")
mscLpEngFcrcTxFrThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 442), )
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshTable.setDescription('This attribute indicates the total transmit frame memory size and the discard thresholds of the transmit frame memory. The transmit frame memory is the memory (in units of frames) used for storing frames to be transmitted by this FP. The first parameter indicates the total size of the transmit frame memory. This is derived from the connectionPoolCapacity and the txCellMemoryAllocation under the ARC component. When the txFrameMemoryAvailable attribute decreases to the second value, the txFrameMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the total transmit frame memory size. When the txFrameMemoryAvailable attribute decreases to the third value, the txFrameMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) >= 2 is discarded. This threshold is set approximately at 20 percent of the first value, the total transmit frame memory size. When the txFrameMemoryAvailable attribute decreases to the fourth value, the txFrameMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) >= 1 is discarded. This threshold is set approximately at 10 percent of the first value, the total transmit frame memory size. The opposite effect occurs when the txFrameMemoryAvailable attribute increases (txFrameMemoryCongestionState increases from 0 to 3 accordingly).')
mscLpEngFcrcTxFrThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 442, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcTxFrThreshIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshEntry.setDescription('An entry in the mscLpEngFcrcTxFrThreshTable.')
mscLpEngFcrcTxFrThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 442, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshIndex.setDescription('This variable represents the mscLpEngFcrcTxFrThreshTable specific index for the mscLpEngFcrcTxFrThreshTable.')
mscLpEngFcrcTxFrThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 442, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcTxFrThreshValue.setDescription('This variable represents an individual value for the mscLpEngFcrcTxFrThreshTable.')
mscLpEngFcrcRxFrThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 446), )
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshTable.setDescription('This attribute indicates the total received frame memory size and the discard thresholds of the receive frame memory. The receive frame memory is the memory (in units of frames) used for storing frames received by this FP. The first parameter indicates the total size of the receive frame memory. This is derived from the connectionPoolCapacity and the rxFrameMemoryAllocation under the ARC component. When the rxFrameMemoryAvailable attribute decreases to the second value, the rxFrameMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the total received frame memory size. When the rxFrameMemoryAvailable attribute decreases to the third value, the rxFrameMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) >= 2 is discarded. This threshold is set approximately at 20 percent of the first value, the total received frame memory size. When the rxFrameMemoryAvailable attribute decreases to the fourth value, the rxFrameMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) >= 1 is discarded. This threshold is set approximately at 10 percent of the first value, the total received frame memory size. The opposite effect occurs when the rxFrameMemoryAvailable attribute increases (rxFrameMemoryCongestionState increases from 0 to 3 accordingly).')
mscLpEngFcrcRxFrThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 446, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcRxFrThreshIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshEntry.setDescription('An entry in the mscLpEngFcrcRxFrThreshTable.')
mscLpEngFcrcRxFrThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 446, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshIndex.setDescription('This variable represents the mscLpEngFcrcRxFrThreshTable specific index for the mscLpEngFcrcRxFrThreshTable.')
mscLpEngFcrcRxFrThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 446, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcRxFrThreshValue.setDescription('This variable represents an individual value for the mscLpEngFcrcRxFrThreshTable.')
mscLpEngFcrcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2))
mscLpEngFcrcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1), )
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngFcrcOv components.')
mscLpEngFcrcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcOvIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngFcrcOv component.')
mscLpEngFcrcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngFcrcOv components. These components can be added and deleted.')
mscLpEngFcrcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngFcrcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngFcrcOv tables.')
mscLpEngFcrcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngFcrcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvIndex.setDescription('This variable represents the index for the mscLpEngFcrcOv tables.')
mscLpEngFcrcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 10), )
if mibBuilder.loadTexts: mscLpEngFcrcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvProvTable.setDescription('This group contains frame services provisionable engineering parameters for this LogicalProcessor. Note that altering any of these parameters will result in a card reset.')
mscLpEngFcrcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcOvIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvProvEntry.setDescription('An entry in the mscLpEngFcrcOvProvTable.')
mscLpEngFcrcOvSubConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 49152), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcOvSubConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvSubConnectionPoolCapacity.setDescription('This attribute indicates the maximum number of sub-connections for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. Due to limited resources, not all of the sub-connections requested by this attribute may be allocated. The desired number of sub- connections allocated is indicated by the sum of fcrc subConnectionPoolAvailable and fcrc subConnectionPoolUsage attributes. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n When the sub-connection pool is exhausted, no more connections are accepted from the services which utilize this pool. Note: Ip Routing entries also compete for this memory. The maximum size of this pool is 8192 for CQC based cards. The default cardDependent has the effect of setting subConnectionPoolCapacity to 1024 for both CQC cards and SGAF cards. VALUES ( 65535 = cardDependent )')
mscLpEngFcrcOvLnnConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2048), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcOvLnnConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcOvLnnConnectionPoolCapacity.setDescription('This attribute indicates the maximum number of resource records for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool. Note: Frame and Cell queues also compete for this memory. Each DPRS instance requires two resource records and each VNS instance requires one resource records from this pool. (A VNS instance is an lnn combined with a trunk). The maximum size of this pool is 256 for CQC based cards. The default cardDependent has the effect of setting lnnConnectionPoolCapacity to 128 for CQC cards and 256 for SGAF cards. VALUES ( 0 = cardDependent )')
mscLpEngFcrcPqc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3))
mscLpEngFcrcPqcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1), )
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngFcrcPqc components.')
mscLpEngFcrcPqcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngFcrcPqc component.')
mscLpEngFcrcPqcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngFcrcPqc components. These components can be added and deleted.')
mscLpEngFcrcPqcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngFcrcPqcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcStorageType.setDescription('This variable represents the storage type value for the mscLpEngFcrcPqc tables.')
mscLpEngFcrcPqcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngFcrcPqcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcIndex.setDescription('This variable represents the index for the mscLpEngFcrcPqc tables.')
mscLpEngFcrcPqcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 10), )
if mibBuilder.loadTexts: mscLpEngFcrcPqcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOperTable.setDescription('This group describes the usage of resources specific to frame services on a PQC based FP.')
mscLpEngFcrcPqcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcPqcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOperEntry.setDescription('An entry in the mscLpEngFcrcPqcOperTable.')
mscLpEngFcrcPqcIpRoutesPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 10, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolSize.setDescription('This attribute indicates the number of IP routing entries permitted on the Logical Processor. If there are enough resources on the card, this value is equal to the provisioned attribute (in Fcrc Pqc Ov) ipRoutesPoolCapacity.')
mscLpEngFcrcPqcIpRoutesPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolUsage.setDescription('This attribute represents the current number of IP routing entries that are in use.')
mscLpEngFcrcPqcIpRoutesPoolAvailableEst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolAvailableEst.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcIpRoutesPoolAvailableEst.setDescription('Each IP routing resource can hold between one and three IP routing entries. Therefore, it is not possible to know exactly how many more IP routing entries can be added to the IP routing table. This attribute specifies the estimated number of IP routing entries that are available on the Logical Processor. It is an approximation based on the current average number of IP routing entries per IP routing resource.')
mscLpEngFcrcPqcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2))
mscLpEngFcrcPqcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1), )
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngFcrcPqcOv components.')
mscLpEngFcrcPqcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcOvIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngFcrcPqcOv component.')
mscLpEngFcrcPqcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngFcrcPqcOv components. These components cannot be added nor deleted.')
mscLpEngFcrcPqcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngFcrcPqcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngFcrcPqcOv tables.')
mscLpEngFcrcPqcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvIndex.setDescription('This variable represents the index for the mscLpEngFcrcPqcOv tables.')
mscLpEngFcrcPqcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 10), )
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvProvTable.setDescription('This group is used for fine tuning resource configuration of frame services on a PQC based Logical Processor.')
mscLpEngFcrcPqcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBaseMIB", "mscLpEngFcrcPqcOvIndex"))
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvProvEntry.setDescription('An entry in the mscLpEngFcrcPqcOvProvTable.')
mscLpEngFcrcPqcOvIpRoutesPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 6, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvIpRoutesPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngFcrcPqcOvIpRoutesPoolCapacity.setDescription('This attribute indicates the number of desired IP routing entries for the Logical Processor. It is used to determine the number of IP routing resources to be allocated on the card. Each IP routing resource can hold between one and three IP routing entries. To calculate the number of IP routing resources required, an average of 2 IP routing entries per IP routing resource is used. If there are not enough resources on the card, a smaller pool is allocated. Operational attribute (in Fcrc Pqc) ipRoutesPoolSize indicates the actual size of the pool.')
atmBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 1))
atmBaseGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 1, 1))
atmBaseGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 1, 1, 3))
atmBaseGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 1, 1, 3, 2))
atmBaseCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 3))
atmBaseCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 3, 1))
atmBaseCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 3, 1, 3))
atmBaseCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 63, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmBaseMIB", mscLpEngArcCqcRowStatus=mscLpEngArcCqcRowStatus, mscLpEngArcTxCellMemoryAvailable=mscLpEngArcTxCellMemoryAvailable, mscLpArcLnnConnectionPoolCapacity=mscLpArcLnnConnectionPoolCapacity, mscLpEngArcRxCellThreshTable=mscLpEngArcRxCellThreshTable, atmBaseCapabilitiesCA02=atmBaseCapabilitiesCA02, mscLpEngFcrcTxFrThreshValue=mscLpEngFcrcTxFrThreshValue, mscLpEngFcrcLnnConnectionPoolUsage=mscLpEngFcrcLnnConnectionPoolUsage, mscLpEngArcCqcOvIndex=mscLpEngArcCqcOvIndex, atmBaseMIB=atmBaseMIB, mscLpArcTxFrameMemoryAllocation=mscLpArcTxFrameMemoryAllocation, mscLpArcRowStatus=mscLpArcRowStatus, mscLpArc=mscLpArc, mscLpEngArcOvIndex=mscLpEngArcOvIndex, mscLpEngArcAqmTxCellMemoryAvailable=mscLpEngArcAqmTxCellMemoryAvailable, atmBaseGroupCA02=atmBaseGroupCA02, atmBaseCapabilitiesCA=atmBaseCapabilitiesCA, mscLpAruRxCellFreeListSize=mscLpAruRxCellFreeListSize, mscLpEngFcrcRowStatusTable=mscLpEngFcrcRowStatusTable, mscLpEngArcCqcOvProvEntry=mscLpEngArcCqcOvProvEntry, mscLpAruTxCflThreshValue=mscLpAruTxCflThreshValue, mscLpAruRxCellFreeListCongestionState=mscLpAruRxCellFreeListCongestionState, mscLpEngArcAqmConnectionPoolUsage=mscLpEngArcAqmConnectionPoolUsage, mscLpEngFcrcRxFrameMemoryMinAvailable=mscLpEngFcrcRxFrameMemoryMinAvailable, mscLpEngFcrcOvRowStatusTable=mscLpEngFcrcOvRowStatusTable, mscLpAruTxFrameFreeListSize=mscLpAruTxFrameFreeListSize, mscLpEngArcOvRxCellMemoryAllocation=mscLpEngArcOvRxCellMemoryAllocation, mscLpEngFcrcRxFrThreshIndex=mscLpEngFcrcRxFrThreshIndex, mscLpAruRowStatusEntry=mscLpAruRowStatusEntry, mscLpAruRxFrameMemoryAllocation=mscLpAruRxFrameMemoryAllocation, mscLpEngArcOvComponentName=mscLpEngArcOvComponentName, mscLpEngFcrcRxFrameMemoryCongestionState=mscLpEngFcrcRxFrameMemoryCongestionState, mscLpEngFcrcRxFrThreshTable=mscLpEngFcrcRxFrThreshTable, mscLpEngFcrcPqcOvRowStatusTable=mscLpEngFcrcPqcOvRowStatusTable, mscLpEngFcrcRowStatusEntry=mscLpEngFcrcRowStatusEntry, mscLpEngFcrcPqcIpRoutesPoolAvailableEst=mscLpEngFcrcPqcIpRoutesPoolAvailableEst, mscLpEngArcAqmOvHighPriorityEpdOffset=mscLpEngArcAqmOvHighPriorityEpdOffset, mscLpEngArcAqmOvProvEntry=mscLpEngArcAqmOvProvEntry, mscLpEngArcAqmRowStatusTable=mscLpEngArcAqmRowStatusTable, mscLpEngArcRowStatus=mscLpEngArcRowStatus, mscLpAruTxFflThreshValue=mscLpAruTxFflThreshValue, mscLpAruTxCellFreeListSize=mscLpAruTxCellFreeListSize, mscLpArcShapingScalingFactor=mscLpArcShapingScalingFactor, mscLpAruStorageType=mscLpAruStorageType, mscLpEngArcTxCellMemoryAllocation=mscLpEngArcTxCellMemoryAllocation, mscLpEngFcrcRxFrThreshEntry=mscLpEngFcrcRxFrThreshEntry, mscLpEngFcrcPqc=mscLpEngFcrcPqc, mscLpEngArcOperEntry=mscLpEngArcOperEntry, mscLpEngArcCqcOvRowStatusEntry=mscLpEngArcCqcOvRowStatusEntry, atmBaseCapabilities=atmBaseCapabilities, mscLpEngArcMulticastBranchesUsage=mscLpEngArcMulticastBranchesUsage, mscLpAruTxFrameMemoryAllocation=mscLpAruTxFrameMemoryAllocation, mscLpAruRxCflThreshIndex=mscLpAruRxCflThreshIndex, mscLpAruTxFrameBlockUsage=mscLpAruTxFrameBlockUsage, mscLpArcShapingStackAllocation=mscLpArcShapingStackAllocation, mscLpAruRxFrameBlockCapacity=mscLpAruRxFrameBlockCapacity, mscLpEngFcrcOvLnnConnectionPoolCapacity=mscLpEngFcrcOvLnnConnectionPoolCapacity, mscLpAruRxCflThreshEntry=mscLpAruRxCflThreshEntry, mscLpAruTotalConnectionPoolUsage=mscLpAruTotalConnectionPoolUsage, mscLpEngArcCqcOv=mscLpEngArcCqcOv, mscLpEngArcRxCellMemoryAvailable=mscLpEngArcRxCellMemoryAvailable, mscLpEngArcAqmTxCellThreshIndex=mscLpEngArcAqmTxCellThreshIndex, mscLpAruTxFrameFreeListCongestionState=mscLpAruTxFrameFreeListCongestionState, mscLpArcConnCapTable=mscLpArcConnCapTable, mscLpEngArcAqmIndex=mscLpEngArcAqmIndex, mscLpArcRowStatusEntry=mscLpArcRowStatusEntry, mscLpAruTxFrameBlockCapacity=mscLpAruTxFrameBlockCapacity, mscLpAruTxCflThreshEntry=mscLpAruTxCflThreshEntry, mscLpEngFcrcRxFrameMemoryAvailable=mscLpEngFcrcRxFrameMemoryAvailable, mscLpEngFcrcRowStatus=mscLpEngFcrcRowStatus, mscLpArcRowStatusTable=mscLpArcRowStatusTable, mscLpEngFcrcTxFrameMemoryAvailable=mscLpEngFcrcTxFrameMemoryAvailable, mscLpEngArcCqcOvRowStatus=mscLpEngArcCqcOvRowStatus, mscLpAruTxFflThreshIndex=mscLpAruTxFflThreshIndex, mscLpEngArcRxCellThreshIndex=mscLpEngArcRxCellThreshIndex, mscLpEngFcrcPqcOperTable=mscLpEngFcrcPqcOperTable, mscLpEngFcrcPqcIpRoutesPoolUsage=mscLpEngFcrcPqcIpRoutesPoolUsage, mscLpEngArcAqmOvLowPriorityEpdOffset=mscLpEngArcAqmOvLowPriorityEpdOffset, mscLpEngFcrcOperEntry=mscLpEngFcrcOperEntry, mscLpEngFcrcOvIndex=mscLpEngFcrcOvIndex, mscLpEngFcrcPqcOvRowStatusEntry=mscLpEngFcrcPqcOvRowStatusEntry, mscLpArcProvTable=mscLpArcProvTable, mscLpArcComponentName=mscLpArcComponentName, mscLpAruTxCflThreshIndex=mscLpAruTxCflThreshIndex, mscLpEngArcOperTable=mscLpEngArcOperTable, mscLpEngFcrcOv=mscLpEngFcrcOv, mscLpAruRxFflThreshIndex=mscLpAruRxFflThreshIndex, mscLpEngArcCqc=mscLpEngArcCqc, mscLpEngArcAqmOvStorageType=mscLpEngArcAqmOvStorageType, mscLpAruLnnConnectionPoolUsage=mscLpAruLnnConnectionPoolUsage, mscLpAruTxCellBlockCapacity=mscLpAruTxCellBlockCapacity, mscLpEngArcCqcIndex=mscLpEngArcCqcIndex, mscLpEngFcrcOvProvTable=mscLpEngFcrcOvProvTable, mscLpEngArcAqmOvRowStatus=mscLpEngArcAqmOvRowStatus, mscLpAruConnUsageIndex=mscLpAruConnUsageIndex, mscLpEngArcCqcOvCdvReduction=mscLpEngArcCqcOvCdvReduction, mscLpEngArcCqcOvConnCapIndex=mscLpEngArcCqcOvConnCapIndex, mscLpEngFcrcPqcOvComponentName=mscLpEngFcrcPqcOvComponentName, mscLpArcStorageType=mscLpArcStorageType, mscLpEngArcIndex=mscLpEngArcIndex, mscLpEngArcTxCellThreshEntry=mscLpEngArcTxCellThreshEntry, mscLpEngArcTxCellThreshIndex=mscLpEngArcTxCellThreshIndex, mscLpEngArcCqcOvPerVcQueueInterfaces=mscLpEngArcCqcOvPerVcQueueInterfaces, mscLpAruRxFrameFreeListSize=mscLpAruRxFrameFreeListSize, mscLpEngArcCqcOperEntry=mscLpEngArcCqcOperEntry, mscLpEngFcrcOvProvEntry=mscLpEngFcrcOvProvEntry, mscLpAruRowStatus=mscLpAruRowStatus, mscLpEngArcTotalConnectionPoolUsage=mscLpEngArcTotalConnectionPoolUsage, mscLpEngArcTxCellThreshTable=mscLpEngArcTxCellThreshTable, mscLpAruConnUsageTable=mscLpAruConnUsageTable, mscLpEngArcMulticastBranchesAvailable=mscLpEngArcMulticastBranchesAvailable, mscLpAruTxCellBlockUsage=mscLpAruTxCellBlockUsage, mscLpEngArcAqmTxCellThreshEntry=mscLpEngArcAqmTxCellThreshEntry, mscLpEngFcrcPqcRowStatusTable=mscLpEngFcrcPqcRowStatusTable, mscLpEngFcrcPqcComponentName=mscLpEngFcrcPqcComponentName, mscLpEngFcrcTxFrThreshEntry=mscLpEngFcrcTxFrThreshEntry, mscLpEngFcrcOvRowStatus=mscLpEngFcrcOvRowStatus, mscLpEngFcrcOvStorageType=mscLpEngFcrcOvStorageType, mscLpEngArcOvMulticastBranchesCapacity=mscLpEngArcOvMulticastBranchesCapacity, mscLpAruRxCellBlockUsage=mscLpAruRxCellBlockUsage, mscLpAruOperTable=mscLpAruOperTable, mscLpAruRxCellBlockCapacity=mscLpAruRxCellBlockCapacity, mscLpEngArcTxCellMemoryMinAvailable=mscLpEngArcTxCellMemoryMinAvailable, mscLpEngArcAqmOvIndex=mscLpEngArcAqmOvIndex, mscLpEngArcRxCellMemoryAllocation=mscLpEngArcRxCellMemoryAllocation, mscLpEngFcrcRxFrThreshValue=mscLpEngFcrcRxFrThreshValue, mscLpEngArcRowStatusTable=mscLpEngArcRowStatusTable, mscLpEngFcrcPqcOperEntry=mscLpEngFcrcPqcOperEntry, mscLpEngArcAqmOvRowStatusTable=mscLpEngArcAqmOvRowStatusTable, mscLpArcConnCapEntry=mscLpArcConnCapEntry, mscLpAruRxCflThreshValue=mscLpAruRxCflThreshValue, mscLpEngArcCqcCdvReduction=mscLpEngArcCqcCdvReduction, mscLpArcIndex=mscLpArcIndex, mscLpEngArcAqmStorageType=mscLpEngArcAqmStorageType, mscLpEngArcAqmOperTable=mscLpEngArcAqmOperTable, mscLpEngArcAqmOvPortCongestionPolicy=mscLpEngArcAqmOvPortCongestionPolicy, mscLpEngArcAqm=mscLpEngArcAqm, mscLpAruMulticastBranchesUsage=mscLpAruMulticastBranchesUsage, mscLpEngArc=mscLpEngArc, mscLpAru=mscLpAru, mscLpEngArcCqcRowStatusTable=mscLpEngArcCqcRowStatusTable, mscLpEngArcAqmRowStatus=mscLpEngArcAqmRowStatus, mscLpEngFcrcPqcOvRowStatus=mscLpEngFcrcPqcOvRowStatus, mscLpEngArcCqcOvProvTable=mscLpEngArcCqcOvProvTable, mscLpEngFcrcComponentName=mscLpEngFcrcComponentName, mscLpEngFcrcPqcOvIndex=mscLpEngFcrcPqcOvIndex, mscLpEngArcTxCellThreshValue=mscLpEngArcTxCellThreshValue, mscLpEngArcCqcOvShapingScalingFactor=mscLpEngArcCqcOvShapingScalingFactor, mscLpAruOperEntry=mscLpAruOperEntry, mscLpEngArcRxCellThreshEntry=mscLpEngArcRxCellThreshEntry, mscLpEngFcrcSubConnectionPoolAvailable=mscLpEngFcrcSubConnectionPoolAvailable, mscLpEngArcOvStorageType=mscLpEngArcOvStorageType, mscLpAruConnUsageValue=mscLpAruConnUsageValue, mscLpArcTotalConnectionPoolCapacity=mscLpArcTotalConnectionPoolCapacity, mscLpArcCdvAttenuation=mscLpArcCdvAttenuation, mscLpAruRxFrameBlockUsage=mscLpAruRxFrameBlockUsage, mscLpAruLnnConnectionPoolAvailable=mscLpAruLnnConnectionPoolAvailable, mscLpEngArcAqmTxCellMemoryMinAvailable=mscLpEngArcAqmTxCellMemoryMinAvailable, mscLpEngArcAqmOvComponentName=mscLpEngArcAqmOvComponentName, mscLpAruSubConnectionPoolUsage=mscLpAruSubConnectionPoolUsage, mscLpEngFcrcTxFrThreshTable=mscLpEngFcrcTxFrThreshTable, mscLpEngArcAqmOv=mscLpEngArcAqmOv, mscLpEngFcrcTxFrameMemoryMinAvailable=mscLpEngFcrcTxFrameMemoryMinAvailable, mscLpAruRxCflThreshTable=mscLpAruRxCflThreshTable, mscLpEngFcrcStorageType=mscLpEngFcrcStorageType, mscLpEngArcCqcOperTable=mscLpEngArcCqcOperTable, mscLpAruTxFflThreshTable=mscLpAruTxFflThreshTable, mscLpEngArcRxCellMemoryCongestionState=mscLpEngArcRxCellMemoryCongestionState, mscLpEngArcTotalConnectionPoolAvailable=mscLpEngArcTotalConnectionPoolAvailable, mscLpAruTxCellFreeListCongestionState=mscLpAruTxCellFreeListCongestionState, mscLpEngArcAqmOvConnectionPoolCapacity=mscLpEngArcAqmOvConnectionPoolCapacity, mscLpEngArcCqcRowStatusEntry=mscLpEngArcCqcRowStatusEntry, mscLpEngArcCqcOvConnCapEntry=mscLpEngArcCqcOvConnCapEntry, mscLpEngFcrcIndex=mscLpEngFcrcIndex, mscLpEngFcrcPqcOvIpRoutesPoolCapacity=mscLpEngFcrcPqcOvIpRoutesPoolCapacity, mscLpArcConnCapValue=mscLpArcConnCapValue, atmBaseGroupCA=atmBaseGroupCA, atmBaseCapabilitiesCA02A=atmBaseCapabilitiesCA02A, mscLpEngArcOv=mscLpEngArcOv, mscLpEngFcrcPqcOvStorageType=mscLpEngFcrcPqcOvStorageType, mscLpEngArcAqmConnectionPoolAvailable=mscLpEngArcAqmConnectionPoolAvailable, mscLpAruRowStatusTable=mscLpAruRowStatusTable, mscLpEngFcrc=mscLpEngFcrc, mscLpEngFcrcTxFrThreshIndex=mscLpEngFcrcTxFrThreshIndex, mscLpEngFcrcOperTable=mscLpEngFcrcOperTable, mscLpEngArcComponentName=mscLpEngArcComponentName, mscLpEngArcAqmOperEntry=mscLpEngArcAqmOperEntry, atmBaseGroup=atmBaseGroup, mscLpEngArcOvTxCellMemoryAllocation=mscLpEngArcOvTxCellMemoryAllocation, mscLpEngArcOvRowStatus=mscLpEngArcOvRowStatus, mscLpEngArcCqcComponentName=mscLpEngArcCqcComponentName, mscLpEngArcAqmTxCellThreshValue=mscLpEngArcAqmTxCellThreshValue, mscLpAruTxCflThreshTable=mscLpAruTxCflThreshTable, mscLpEngArcCqcOvPortCongestionPolicy=mscLpEngArcCqcOvPortCongestionPolicy, mscLpArcSubConnectionPoolCapacity=mscLpArcSubConnectionPoolCapacity, mscLpEngArcRowStatusEntry=mscLpEngArcRowStatusEntry, mscLpEngArcAqmTxCellMemoryCongestionState=mscLpEngArcAqmTxCellMemoryCongestionState, mscLpEngFcrcPqcOvProvEntry=mscLpEngFcrcPqcOvProvEntry, mscLpAruRxFrameFreeListCongestionState=mscLpAruRxFrameFreeListCongestionState, mscLpAruTxFflThreshEntry=mscLpAruTxFflThreshEntry, mscLpEngArcRxCellMemoryMinAvailable=mscLpEngArcRxCellMemoryMinAvailable, mscLpArcMulticastBranchesCapacity=mscLpArcMulticastBranchesCapacity, mscLpEngFcrcTxFrameMemoryCongestionState=mscLpEngFcrcTxFrameMemoryCongestionState, mscLpArcPortAggregation=mscLpArcPortAggregation, mscLpEngArcCqcOvConnCapTable=mscLpEngArcCqcOvConnCapTable, mscLpArcPerVcQueueInterfaces=mscLpArcPerVcQueueInterfaces, mscLpAruRxFflThreshEntry=mscLpAruRxFflThreshEntry, mscLpEngArcOvRowStatusTable=mscLpEngArcOvRowStatusTable, mscLpEngFcrcPqcStorageType=mscLpEngFcrcPqcStorageType, mscLpAruRxFflThreshValue=mscLpAruRxFflThreshValue, mscLpEngArcRxCellThreshValue=mscLpEngArcRxCellThreshValue, mscLpEngArcCqcStorageType=mscLpEngArcCqcStorageType, mscLpEngFcrcPqcOv=mscLpEngFcrcPqcOv, mscLpEngFcrcOvComponentName=mscLpEngFcrcOvComponentName, mscLpEngFcrcOvSubConnectionPoolCapacity=mscLpEngFcrcOvSubConnectionPoolCapacity, mscLpEngArcCqcOvComponentName=mscLpEngArcCqcOvComponentName, mscLpArcRxFrameMemoryAllocation=mscLpArcRxFrameMemoryAllocation, atmBaseGroupCA02A=atmBaseGroupCA02A, mscLpEngArcAqmRowStatusEntry=mscLpEngArcAqmRowStatusEntry, mscLpEngFcrcPqcOvProvTable=mscLpEngFcrcPqcOvProvTable, mscLpEngArcStorageType=mscLpEngArcStorageType, mscLpEngFcrcLnnConnectionPoolAvailable=mscLpEngFcrcLnnConnectionPoolAvailable, mscLpEngArcOvProvTable=mscLpEngArcOvProvTable, mscLpEngArcAqmComponentName=mscLpEngArcAqmComponentName, mscLpEngFcrcSubConnectionPoolUsage=mscLpEngFcrcSubConnectionPoolUsage, mscLpEngFcrcOvRowStatusEntry=mscLpEngFcrcOvRowStatusEntry, mscLpEngArcCqcOvConnCapValue=mscLpEngArcCqcOvConnCapValue, mscLpEngArcCqcOvStorageType=mscLpEngArcCqcOvStorageType, mscLpEngArcAqmOvRowStatusEntry=mscLpEngArcAqmOvRowStatusEntry, mscLpAruSubConnectionPoolAvailable=mscLpAruSubConnectionPoolAvailable, mscLpEngArcOvProvEntry=mscLpEngArcOvProvEntry, mscLpEngArcTxCellMemoryCongestionState=mscLpEngArcTxCellMemoryCongestionState, mscLpArcConnCapIndex=mscLpArcConnCapIndex, mscLpEngFcrcPqcRowStatusEntry=mscLpEngFcrcPqcRowStatusEntry, mscLpEngArcOvTotalConnectionPoolCapacity=mscLpEngArcOvTotalConnectionPoolCapacity, mscLpArcProvEntry=mscLpArcProvEntry, mscLpEngArcOvRowStatusEntry=mscLpEngArcOvRowStatusEntry, mscLpAruConnUsageEntry=mscLpAruConnUsageEntry, mscLpEngArcCqcOvRowStatusTable=mscLpEngArcCqcOvRowStatusTable, mscLpEngArcAqmTxCellThreshTable=mscLpEngArcAqmTxCellThreshTable, mscLpEngArcAqmOvProvTable=mscLpEngArcAqmOvProvTable, mscLpEngFcrcPqcRowStatus=mscLpEngFcrcPqcRowStatus, mscLpAruIndex=mscLpAruIndex, mscLpEngFcrcPqcIpRoutesPoolSize=mscLpEngFcrcPqcIpRoutesPoolSize, mscLpAruRxFflThreshTable=mscLpAruRxFflThreshTable, mscLpAruComponentName=mscLpAruComponentName, mscLpEngFcrcPqcIndex=mscLpEngFcrcPqcIndex)

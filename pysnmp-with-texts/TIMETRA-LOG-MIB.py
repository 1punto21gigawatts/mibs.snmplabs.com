#
# PySNMP MIB module TIMETRA-LOG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TIMETRA-LOG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:17:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, SnmpMessageProcessingModel, SnmpSecurityLevel = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString", "SnmpMessageProcessingModel", "SnmpSecurityLevel")
snmpNotifyEntry, = mibBuilder.importSymbols("SNMP-NOTIFICATION-MIB", "snmpNotifyEntry")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
sysDescr, sysObjectID = mibBuilder.importSymbols("SNMPv2-MIB", "sysDescr", "sysObjectID")
MibIdentifier, Counter64, ObjectIdentity, Counter32, iso, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Integer32, Unsigned32, NotificationType, ModuleIdentity, Bits, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter64", "ObjectIdentity", "Counter32", "iso", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Integer32", "Unsigned32", "NotificationType", "ModuleIdentity", "Bits", "IpAddress")
DateAndTime, TimeStamp, TruthValue, RowStatus, StorageType, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TimeStamp", "TruthValue", "RowStatus", "StorageType", "DisplayString", "TextualConvention")
TFilterActionOrDefault, TFilterAction = mibBuilder.importSymbols("TIMETRA-FILTER-MIB", "TFilterActionOrDefault", "TFilterAction")
tmnxSRNotifyPrefix, timetraSRMIBModules, tmnxSRObjs, tmnxSRConfs = mibBuilder.importSymbols("TIMETRA-GLOBAL-MIB", "tmnxSRNotifyPrefix", "timetraSRMIBModules", "tmnxSRObjs", "tmnxSRConfs")
TNamedItem, TQueueIdOrAll, TItemDescription, TQueueId, TmnxAccPlcyQECounters, TmnxAccPlcyOECounters, TmnxAdminState, TmnxOperState, TmnxAccPlcyAACounters, THsmdaCounterIdOrZeroOrAll, TmnxActionType, THsmdaCounterIdOrZero, TmnxAccPlcyQICounters, TmnxAccPlcyOICounters, TNamedItemOrEmpty = mibBuilder.importSymbols("TIMETRA-TC-MIB", "TNamedItem", "TQueueIdOrAll", "TItemDescription", "TQueueId", "TmnxAccPlcyQECounters", "TmnxAccPlcyOECounters", "TmnxAdminState", "TmnxOperState", "TmnxAccPlcyAACounters", "THsmdaCounterIdOrZeroOrAll", "TmnxActionType", "THsmdaCounterIdOrZero", "TmnxAccPlcyQICounters", "TmnxAccPlcyOICounters", "TNamedItemOrEmpty")
timetraLogMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 12))
timetraLogMIBModule.setRevisions(('2011-02-01 00:00', '2009-02-28 00:00', '2008-01-01 00:00', '2007-01-01 00:00', '2006-03-15 00:00', '2005-01-24 00:00', '2004-05-27 00:00', '2004-01-15 00:00', '2003-08-15 00:00', '2003-01-20 00:00', '2001-11-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraLogMIBModule.setRevisionsDescriptions(('Rev 9.0 1 Feb 2011 00:00 9.0 release of the TIMETRA-LOG-MIB.', 'Rev 7.0 28 Feb 2009 00:00 7.0 release of the TIMETRA-LOG-MIB.', 'Rev 6.0 01 Jan 2008 00:00 6.0 release of the TIMETRA-LOG-MIB.', 'Rev 5.0 01 Jan 2007 00:00 5.0 release of the TIMETRA-LOG-MIB.', 'Rev 4.0 15 Mar 2006 00:00 4.0 release of the TIMETRA-LOG-MIB.', 'Rev 2.1 24 Jan 2005 00:00 2.1 release of the TIMETRA-LOG-MIB.', 'Rev 2.1 27 May 2004 00:00 2.1 release of the TIMETRA-LOG-MIB.', 'Rev 2.0 15 Jan 2004 00:00 2.0 release of the TIMETRA-LOG-MIB.', 'Rev 1.2 15 Aug 2003 00:00 1.2 release of the TIMETRA-LOG-MIB.', 'Rev 1.0 20 Jan 2003 00:00 1.0 Release of the TIMETRA-LOG-MIB.', 'Rev 0.1 10 Nov 2001 00:00 Initial version of the TIMETRA-LOG-MIB.',))
if mibBuilder.loadTexts: timetraLogMIBModule.setLastUpdated('201102010000Z')
if mibBuilder.loadTexts: timetraLogMIBModule.setOrganization('Alcatel-Lucent')
if mibBuilder.loadTexts: timetraLogMIBModule.setContactInfo('Alcatel-Lucent SROS Support Web: http://support.alcatel-lucent.com')
if mibBuilder.loadTexts: timetraLogMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the Alcatel-Lucent SROS Logging utility. Copyright 2003-2012 Alcatel-Lucent. All rights reserved. Reproduction of this document is authorized on the condition that the foregoing copyright notice is included. This SNMP MIB module (Specification) embodies Alcatel-Lucent's proprietary intellectual property. Alcatel-Lucent retains all title and ownership in the Specification, including any revisions. Alcatel-Lucent grants all interested parties a non-exclusive license to use and distribute an unmodified copy of this Specification in connection with management of Alcatel-Lucent products, and without fee, provided this copyright notice and license appear on all copies. This Specification is supplied 'as is', and Alcatel-Lucent makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
tmnxLogObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12))
tmnxLogNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1))
tmnxLogNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12))
tmnxLogNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0))
tmnxLogConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12))
class TmnxPerceivedSeverity(TextualConvention, Integer32):
    description = 'ITU perceived severity values as per M.3100 and X.733'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 0), ("cleared", 1), ("indeterminate", 2), ("critical", 3), ("major", 4), ("minor", 5), ("warning", 6))

class TmnxSyslogId(TextualConvention, Integer32):
    description = "The value of TmnxSyslogId uniquely identifies an entry in the tmnxSyslogTargetTable to be used for the syslog collector target information when creating a log file where tmnxLogIdDestination has a value of 'syslog (2)'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 10)

class TmnxSyslogIdOrEmpty(TextualConvention, Integer32):
    description = "The value of TmnxSyslogIdOrEmpty uniquely identifies an entry in the tmnxSyslogTargetTable to be used for the syslog collector target information when creating a log file where tmnxLogIdDestination has a value of 'syslog (2)'. The value of 0 is used when no entry exists in the tmnxSyslogTargetTable."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 10), )
class TmnxSyslogFacility(TextualConvention, Integer32):
    description = 'The value of TmnxSyslogFacility is an enumerated integer that specifies which syslog facility is the intended destination for the log event stream.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))
    namedValues = NamedValues(("kernel", 0), ("user", 1), ("mail", 2), ("systemd", 3), ("auth", 4), ("syslogd", 5), ("printer", 6), ("netnews", 7), ("uucp", 8), ("cron", 9), ("authpriv", 10), ("ftp", 11), ("ntp", 12), ("logaudit", 13), ("logalert", 14), ("cron2", 15), ("local0", 16), ("local1", 17), ("local2", 18), ("local3", 19), ("local4", 20), ("local5", 21), ("local6", 22), ("local7", 23))

class TmnxUdpPort(TextualConvention, Integer32):
    description = 'The value of TmnxUdpPort is the port used to send messages to an event collector target. 514 is the IANA assigned port number for syslog. 162 is the IANA assigned port number for SNMP notifications.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class TmnxSyslogSeverity(TextualConvention, Integer32):
    description = 'The value of TmnxSyslogSeverity is an enumerated integer that specifies the severity levels of syslog messages.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("emergency", 0), ("alert", 1), ("critical", 2), ("error", 3), ("warning", 4), ("notice", 5), ("info", 6), ("debug", 7))

class TmnxLogFileId(TextualConvention, Integer32):
    description = 'The value of TmnxLogFileId uniquely identifies a file-id to be used when creating a log or billing file. A value of zero (0) indicates none specified and is invalid when used as an index for the tmnxLogFileIdTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 99)

class TmnxLogFileType(TextualConvention, Integer32):
    description = 'The value of TmnxLogFileType indicates the type of information that will be written to this file.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("none", 0), ("eventLog", 1), ("accountingPolicy", 2))

class TmnxLogIdIndex(TextualConvention, Integer32):
    description = 'The value of tmnxLogIdIndex uniquely identifies an event stream log. Note that 2 default TmnxLogIdEntry rows are created by the agent using TmnxLogIdIndex values 99 and 100.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 100)

class TmnxCFlash(TextualConvention, Unsigned32):
    description = 'The value of TmnxCFlash uniquely identifies a compact flash module on the active CPM card. A value of zero (0) indicates none specified.'
    status = 'current'

class TmnxLogFilterId(TextualConvention, Unsigned32):
    description = 'The value of TmnxLogFilterId is the identification number of an event log filter. The value of zero indicates none specified. The value of zero (0) is invalid when used as an index for the tmnxLogFilterTable. Filter entry 1001 is created by the agent.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 1001)

class TmnxLogFilterEntryId(TextualConvention, Unsigned32):
    description = 'The value of TmnxLogFilterEntryId is the identification number of an event log filter entry.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 999)

class TmnxLogFilterOperator(TextualConvention, Integer32):
    description = "When TmnxLogFilterOperator has a value of 'off', the item is not matched. Otherwise the value of TmnxLogFilterOperator determines the comparison operator to be used as the parameter match criterion."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("off", 1), ("equal", 2), ("notEqual", 3), ("lessThan", 4), ("lessThanOrEqual", 5), ("greaterThan", 6), ("greaterThanOrEqual", 7))

class TmnxEventNumber(TextualConvention, Unsigned32):
    description = 'Each log event type has a unique identifying number. This number is unique within a particular software application, such as IP, MPLS, OSPF, etc.; but it is not necessarily unique across different software applications. That is MPLS event #1001 may be different from OSPF event #1001.'
    status = 'current'

tmnxLogMaxLogs = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 2), Unsigned32().clone(15)).setUnits('logs').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogMaxLogs.setStatus('current')
if mibBuilder.loadTexts: tmnxLogMaxLogs.setDescription('The maximum number of concurrent active Logs that are allowed. A value of zero (0) for this object implies that there is no limit for the number of concurrent active logs in effect.')
tmnxLogFileIdTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3), )
if mibBuilder.loadTexts: tmnxLogFileIdTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdTable.setDescription('Defines the Alcatel-Lucent SROS series Log File ID Table for providing, via SNMP, the capability of defining the characteristics for log and billing files and associating them with a file-id. The actual file is not created until the file-id is used in a log or billing file configuration.')
tmnxLogFileIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogFileId"))
if mibBuilder.loadTexts: tmnxLogFileIdEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdEntry.setDescription('Defines an entry in the tmnxLogFileIdTable. Entries are created and deleted in this table by SNMP sets to tmnxLogFileIdRowStatus.')
tmnxLogFileId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 1), TmnxLogFileId())
if mibBuilder.loadTexts: tmnxLogFileId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileId.setDescription('The index value tmnxLogFileId uniquely identifies a file-id to be used when creating a log or billing file.')
tmnxLogFileIdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: tmnxLogFileIdRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdRowStatus.setDescription('This object allows entries to be created and deleted in the tmnxLogFileIdTable. Deletion of an entry in this table will not succeed if it is currently used by any log or billing file.')
tmnxLogFileIdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdStorageType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
tmnxLogFileIdRolloverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10080)).clone(1440)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdRolloverTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdRolloverTime.setDescription("The value of tmnxLogFileIdRolloverTime specifies how often, in minutes, a new log or billing file will be created. If the value of tmnxLogFileIdLogType is not 'rollover', then the value of this object is irrelevant.")
tmnxLogFileIdRetainTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500)).clone(12)).setUnits('hours').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdRetainTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdRetainTime.setDescription('The value of tmnxLogFileIdRetainTime specifies the minimum time, in hours, that a file is retained on the media. Once this time period has expired the file is deleted.')
tmnxLogFileIdAdminLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 6), TmnxCFlash()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdAdminLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdAdminLocation.setDescription('The value of tmnxLogFileIdAdminLocation specifies where the log or billing file should be created. The file location should be a compact flash on the primary CPM. When the secondary CPM becomes the primary CPM after a failure, the same log file policies will be activated. Thus it is recommended that the same media is available to both secondary and primary CPMs. If no location is specified, 0, the compact flash cf1: is used to store the log files or cf2: is used to store billing files.')
tmnxLogFileIdOperLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 7), TmnxCFlash()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFileIdOperLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdOperLocation.setDescription('The value of tmnxLogFileIdOperLocation specifies where the log or billing file has been created. The file location should be a compact flash on the primary CPM. When the secondary CPM becomes the primary CPM after a failure, the same log file policies will be activated. Thus it is recommended that the same media is available to both secondary and primary CPMs.')
tmnxLogFileIdDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 8), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdDescription.setDescription('The value of tmnxLogFileIdDescription is a user provided description string for this log file-id entry. It can consist of any printable, seven-bit ASCII characters up to 80 characters in length.')
tmnxLogFileIdLogType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 9), TmnxLogFileType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFileIdLogType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdLogType.setDescription('The value of tmnxLogFileIdLogType indicates the type of information that will be written to this file.')
tmnxLogFileIdLogId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFileIdLogId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdLogId.setDescription('The value of tmnxLogFileIdLogId indicates the ID index of the log or accounting policy this file is attached to. A value of zero (0) indicates that this file definition is not currently used by any log or accounting policy.')
tmnxLogFileIdPathName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFileIdPathName.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdPathName.setDescription('The value of tmnxLogFileIdPathName is the pathname of the currently opened file used by this file-id entry.')
tmnxLogFileIdCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 12), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFileIdCreateTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdCreateTime.setDescription('The value of tmnxLogFileIdCreateTime is the time the currently opened file version used by this file-id entry was created.')
tmnxLogFileIdBackupLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 3, 1, 13), TmnxCFlash()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFileIdBackupLoc.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdBackupLoc.setDescription("The value of tmnxLogFileIdBackupLoc specifies where the log or billing file should be created if it cannot be created in the location specified by tmnxLogFileIdAdminLocation. The file location should be a compact flash on the primary CPM. When the secondary CPM becomes the primary CPM after a failure, the same log file policies will be activated. Thus it is recommended that the same media is available to both secondary and primary CPMs. If no backup location is specified, 0, and the log or billing file could not be created in the location specified by tmnxLogFileIdAdminLocation or the file creation at the specified backup location fails, a file create failure trap is issued and the associated log or accounting policy is marked as operationally 'outOfService'.")
tmnxLogApTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4), )
if mibBuilder.loadTexts: tmnxLogApTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApTable.setDescription('The Alcatel-Lucent SROS series Log Accounting Policy Table contains an entry for each accounting policy that specifies the characteristics of the accounting records associated with an accounting policy.')
tmnxLogApEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogApPolicyId"))
if mibBuilder.loadTexts: tmnxLogApEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApEntry.setDescription('Defines an entry in the tmnxLogApTable. Entries in the tmnxLogApTable are created and destroyed via SNMP Set requests to tmnxLogApRowStatus.')
tmnxLogApPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)))
if mibBuilder.loadTexts: tmnxLogApPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApPolicyId.setDescription('The value of tmnxLogApPolicyId uniquely identifies an accounting policy to be used for creating accounting records. A specific accounting policy can be applied to one or more service access points (SAPs). Any changes made to an existing policy is applied immediately to all SAPs where this policy is applied.')
tmnxLogApRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: tmnxLogApRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApRowStatus.setDescription('This object allows entries to be created and deleted in the tmnxLogApTable. Deletion of an entry in this table will not succeed if it is currently applied to any service access point (SAP).')
tmnxLogApStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApStorageType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
tmnxLogApAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 4), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApAdminStatus.setDescription('The value of tmnxLogApAdminStatus specifies the desired administrative state for this accounting policy.')
tmnxLogApOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 5), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApOperStatus.setDescription('The value of tmnxLogApOperStatus indicates the current operational status of this accounting policy.')
tmnxLogApInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(5)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApInterval.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApInterval.setDescription("The value of tmnxLogApInterval determines how frequently the statistics are collected and written to their destination. tmnxLogApInterval will have a default value if the value of tmnxLogApDefaultInterval is set to 'true'. Value of tmnxLogApInterval can be set manually if tmnxLogApDefaultInterval is set to 'false'. An attempt to set this object to a non-default value will fail with an inconsistentValue error if tmnxLogApDefaultInterval has the value 'true' set. If no record is specified, default value for tmnxLogApInterval is 5 minutes. For service and network types of record, default values are 5 minutes and 15 minutes respectively. For SAA only, the minimum value of tmnxLogApInterval is 1 minute. Otherwise the minimum value is 5 minutes.")
tmnxLogApDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 7), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApDescription.setDescription('The value of tmnxLogApDescription is a user provided description string for this accounting policy. It can consist of any printable, seven-bit ASCII characters up to 80 characters in length.')
tmnxLogApDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApDefault.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApDefault.setDescription("When tmnxLogApDefault has a value of 'true', it indicates that this accounting policy is applied to all service access points (SAPs) that do not have an explicit accounting policy applied. If no accounting policy is associated with a SAP accounting records are produced in accordance with the default policy. Only one accounting policy entry in the tmnxLogApTable can have tmnxLogApDefault set to 'true'. If there is no entry in the tmnxLogApTable with tmnxLogApDefault set to 'true', then the only accounting records collected are those explicitly configured accounting policies.")
tmnxLogApRecord = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61))).clone(namedValues=NamedValues(("none", 0), ("svcIngressOctet", 1), ("svcEgressOctet", 2), ("svcIngressPkt", 3), ("svcEgressPkt", 4), ("netIngressOctet", 5), ("netEgressOctet", 6), ("netIngressPkt", 7), ("netEgressPkt", 8), ("compactSvcInOctet", 9), ("combinedSvcIngress", 10), ("combinedNetInEgOctet", 11), ("combinedSvcInEgOctet", 12), ("completeSvcInEg", 13), ("combinedSvcSdpInEg", 14), ("completeSvcSdpInEg", 15), ("completeSubscrIngrEgr", 16), ("bsxProtocol", 17), ("bsxApplication", 18), ("bsxAppGroup", 19), ("bsxSubscriberProtocol", 20), ("bsxSubscriberApplication", 21), ("bsxSubscriberAppGroup", 22), ("customRecordSubscriber", 23), ("customRecordService", 24), ("customRecordAa", 25), ("queueGroupOctets", 26), ("queueGroupPackets", 27), ("combinedQueueGroup", 28), ("combinedMplsLspIngress", 29), ("combinedMplsLspEgress", 30), ("combinedLdpLspEgress", 31), ("saa", 32), ("video", 33), ("kpiSystem", 34), ("kpiBearerMgmt", 35), ("kpiBearerTraffic", 36), ("kpiRefPoint", 37), ("kpiPathMgmt", 38), ("kpiIom3", 39), ("kciSystem", 40), ("kciBearerMgmt", 41), ("kciPathMgmt", 42), ("completeKpi", 43), ("completeKci", 44), ("kpiBearerGroup", 45), ("kpiRefPathGroup", 46), ("kpiKciBearerMgmt", 47), ("kpiKciPathMgmt", 48), ("kpiKciSystem", 49), ("completeKpiKci", 50), ("aaPerformance", 51), ("netInfIngressOct", 52), ("netInfIngressPkt", 53), ("combinedNetInfIngress", 54), ("accessEgressPkt", 55), ("accessEgressOct", 56), ("combinedAccessEgress", 57), ("combinedNetEgress", 58), ("combinedSvcEgress", 59), ("combinedSvcInEgPkt", 60), ("combinedNetInEgPkt", 61))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApRecord.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApRecord.setDescription("The value of tmnxLogApRecord indicates the type of predefined accounting record type to be written to the accounting file. When tmnxLogApDefaultInterval has a value of 'false', statistics collection interval of the record type will be ignored. The value 'bsxSubscriberAppGroup (22)' was made obsolete in release 7.0 and replaced by 'custom-record-aa (25).'")
tmnxLogApToFileId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 10), TmnxLogFileId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApToFileId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApToFileId.setDescription("The value of tmnxLogApToFileId is the index to the entry in the tmnxLogFileIdTable that specifies the file characteristics to be used for the destination of the accounting policy records collected by this accounting policy. The file itself is created the first time this accounting policy is applied to a service access point (SAP). tmnxLogApToFileId must be set along with tmnxLogApToFileType to indicate whether the records will be stored in a file or not. When a destination file is specified, the value of the file is specified by tmnxLogApToFileId and the value of tmnxLogApToFileType should be 'fileId'. When the destination file is not specified, the value of tmnxLogApToFileId should be zero and the value of tmnxLogApToFileType should be 'noFile'.")
tmnxLogApPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("access", 1), ("network", 2), ("sdp", 3), ("subscriber", 4), ("appAssure", 5), ("qgrp", 6), ("saa", 7), ("mplsLspIngr", 8), ("mplsLspEgr", 9), ("ldpLspEgr", 10), ("video", 11), ("mobileGateway", 12), ("networkIf", 13), ("accessport", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApPortType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApPortType.setDescription("The tmnxLogApPortType variable indicates if this accounting policy's record type is to be associated with a service access port, a network access port, a service destination point, a subscriber or the application-assurance feature.")
tmnxLogApDefaultInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 12), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApDefaultInterval.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApDefaultInterval.setDescription("When tmnxLogApDefaultInterval has a value of 'true', it indicates that tmnxLogApInterval will have a default value. When tmnxLogApDefaultInterval has a value of 'false', user can set the value of tmnxLogApInterval manually.")
tmnxLogApDataLossCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApDataLossCount.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApDataLossCount.setDescription('The value of tmnxLogApDataLossCount indicates the number of times a tmnxLogAccountingDataLoss trap was raised against this application policy.')
tmnxLogApLastDataLossTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApLastDataLossTimeStamp.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApLastDataLossTimeStamp.setDescription('The value of tmnxLogApLastDataLossTimeStamp indicates the last time, since system startup that a tmnxLogAccountingDataLoss trap was raised against this application policy.')
tmnxLogApToFileType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("fileId", 0), ("noFile", 1))).clone('fileId')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApToFileType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApToFileType.setDescription("The value of tmnxLogApToFileType indicates where records of an accounting policy are stored. It should be set along with tmnxLogApToFileId which specifies the destination file index where the accounting records are stored. When the value of tmnxLogApToFileType is 'noFile', it indicates that the accounting records will not to be stored in a file and the value of tmnxLogApToFileId should be set to zero. When the value of tmnxLogApToFileType is 'fileId', it indicates that the accounting records will be stored in a file specified by tmnxLogApToFileId. tmnxLogApOperStatus will transition to 'inService' when the tmnxLogApToFileType is set to 'noFile' or 'fileId'.")
tmnxLogIdTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5), )
if mibBuilder.loadTexts: tmnxLogIdTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdTable.setDescription('The Alcatel-Lucent SROS series Log Identification Table contains an entry for each log that specifies the characteristics of that log associated with a log-id number.')
tmnxLogIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogIdIndex"))
if mibBuilder.loadTexts: tmnxLogIdEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdEntry.setDescription('Defines an entry in the tmnxLogIdTable. Entries in the tmnxLogIdTable are created and destroyed via SNMP Set requests to tmnxLogIdRowStatus. Default log entries 99 and 100 are created by the agent.')
tmnxLogIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 1), TmnxLogIdIndex())
if mibBuilder.loadTexts: tmnxLogIdIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdIndex.setDescription('The value of tmnxLogIdIndex uniquely identifies an event stream log.')
tmnxLogIdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: tmnxLogIdRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdRowStatus.setDescription("This object allows entries to be created and deleted in the tmnxLogIdTable. Deletion of an entry in this table will not succeed if tmnxLogIdOperStatus is not 'outOfService'. tmnxLogIdOperStatus will not transition to 'inService' if tmnxLogIdSource and tmnxLogIdDestination and their associated objects have not been set to valid values.")
tmnxLogIdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdStorageType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
tmnxLogIdAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 4), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdAdminStatus.setDescription('The value of tmnxLogIdAdminStatus indicates the desired administrative state for this log.')
tmnxLogIdOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 5), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogIdOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdOperStatus.setDescription('The value of tmnxLogIdOperStatus indicates the current operational status of this log.')
tmnxLogIdDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 6), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdDescription.setDescription('The value of tmnxLogIdDescription is a user provided description string for this log. It can consist of any printable, seven-bit ASCII characters up to 80 characters in length.')
tmnxLogIdFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 7), TmnxLogFilterId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdFilterId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdFilterId.setDescription("The value of tmnxLogIdFilterId is the index into the tmnxLogFilterTable to the entry the defines a filter to be applied to this log's source event stream to limit the events output to this log's destination. If tmnxLogIdFilterId has a value of 0, then all events in the source log are forwarded to the destination.")
tmnxLogIdSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 8), Bits().clone(namedValues=NamedValues(("main", 0), ("security", 1), ("change", 2), ("debugTrace", 3), ("li", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdSource.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdSource.setDescription("The value of tmnxLogIdSource is a bit mask that specifies the log event source stream(s) to be forwarded to the destination specified in tmnxLogIdDestination. Events from more than one source may be forwarded to the log destination. The 'main' event stream consists of all events that are not explicitly directed to any other event stream. The 'security' event stream contains all events that affect attempts to breach system security such as failed login attempts, attempts to access SNMP MIB tables to which the user has not been granted access, or attempts to enter a branch of the CLI for which the user is not authorized. The 'user' activity event stream contains all events that directly affect the configuration or operation of the system. The 'debugTrace' event stream contains all events configured for application or protocol tracing. The 'li' event stream contains all events configured for Lawful Intercept activities. An attempt to set the 'li' event stream will fail with an inconsistentValue error if the requestor does not have access to the 'li' context. An attempt to set the 'li' event stream will fail with an inconsistentValue error if tmnxLogIdDestination has the value 'syslog' or 'file'.")
tmnxLogIdDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("console", 1), ("syslog", 2), ("snmpTraps", 3), ("file", 4), ("memory", 5))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdDestination.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdDestination.setDescription("The value of tmnxLogIdDestination specifies the event log stream destination. Once this object has been set to a value other than the default 'none' it cannot be modified and attempts to reset it to another value will fail with an INCONSISTENT VALUE error. The 'console' destination causes all selected log events to be directed to the system console. If the console is not connected then all entries are dropped. The 'syslog' destination sends all selected log events to the syslog address configured in tmnxSyslogTargetAddress and tmnxSyslogTargetUdpPort in the tmnxSyslogTargetTable row entry pointed to by the value of tmnxLogIdSyslogId. An attempt to set this object ot 'syslog' will fail with an inconsistentValue error if tmnxLogIdSource has the value 'li' set. The 'snmpTraps' destination causes events defined as SNMP traps to be sent to the configured SNMP trap destinations and also to be logged in the NOTIFICATION-LOG-MIB tables. The allocated memory size for the log of transmitted traps is specified in tmnxLogIdMaxMemorySize. The events are logged to memory in a circular fashion. Once the space is full, the oldest entry is replaced with a new entry. The 'file' destination causes all selected log events to be directed to a file on one of the CPM's compact flash discs. Details of the file's configuration are in the tmnxLogFileIdTable entry pointed to by the value of tmnxLogIdFileId. An attempt to set this object ot 'file' will fail with an inconsistentValue error if tmnxLogIdSource has the value 'li' set. The 'memory' destination causes all selected log events to be directed to an in memory storage area. The allocated memory size for the log is specified in tmnxLogIdMaxMemorySize. The events are logged to memory in a circular fashion. Once the space is full, the oldest entry is replaced with a new entry.")
tmnxLogIdFileId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 10), TmnxLogFileId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdFileId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdFileId.setDescription("The value of tmnxLogIdFileId is the index to the entry in the tmnxLogFileIdTable that specifies the file characteristics to be used for the destination of the log events written to this log. tmnxLogIdOperStatus will not transition to 'inService' until a valid value has been set for tmnxLogIdFileId. This object is valid only if tmnxLogIdDestination is set to 'file'.")
tmnxLogIdSyslogId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 11), TmnxSyslogIdOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdSyslogId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdSyslogId.setDescription("The value of tmnxLogIdSyslogId is the index into the tmnxSyslogTargetTable for the row entry with the information to format event messages to be sent to a specific syslog collector target. This object is valid only when tmnxLogIdDestination has a value of 'syslog'. If this object has a value of zero (0), then no collector is specified and no messages are sent.")
tmnxLogIdMaxMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 3000), )).clone(100)).setUnits('events').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdMaxMemorySize.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdMaxMemorySize.setDescription("The value of tmnxLogIdMaxMemorySize specifies the amount of memory to allocate for this log. This object is valid only when tmnxLogIdDestination has a value of 'memory' or 'snmpTraps'. If the value tmnxLogIdDestination is neither 'memory' nor 'snmpTraps' a read of this object will return zero (0). Once a memory size has been specified and the log created, any attempt to modify this object will fail with an INCONSISTENT VALUE error.")
tmnxLogIdConsoleSession = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdConsoleSession.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdConsoleSession.setDescription("This object exists for the convenience of the Alcatel-Lucent SROS CLI. When set to 'true' it indicates that the 'CONSOLE' log output should be printed to the Telnet session instead of the CONSOLE device. When a tmnxLogIdEntry is created directly via SNMP, setting this object has no meaning and the 'CONSOLE' log output will always be sent to the CONSOLE device.")
tmnxLogIdForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogIdForwarded.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdForwarded.setDescription("The value of tmnxLogIdForwarded is the count of the number of events that have been forwarded to this log's destination. This counter is incremented after an event has been selected by the log filter defined in tmnxLogIdFilterId.")
tmnxLogIdDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogIdDropped.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdDropped.setDescription('The value of tmnxLogIdDropped is the count of the number of events that have been sent to this logs source(s) and that have not been forwarded to the log destination because they were filtered out by the log filter defined in tmnxLogIdFilterId.')
tmnxLogIdTimeFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("utc", 1), ("local", 2))).clone('utc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogIdTimeFormat.setStatus('current')
if mibBuilder.loadTexts: tmnxLogIdTimeFormat.setDescription("The value of tmnxLogIdTimeFormat specifies the type of timestamp format for events sent to logs where tmnxLogIdDestination has a value of either 'syslog (2)' or 'file (4)'. When tmnxLogIdTimeFormat has a value of 'utc (1)' timestamps are written using the Coordinated Universal Time value. When tmnxLogIdTimeFormat has a value of 'local (2)' timestamps are written in the system's local time.")
tmnxLogFilterTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6), )
if mibBuilder.loadTexts: tmnxLogFilterTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterTable.setDescription(' ')
tmnxLogFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogFilterId"))
if mibBuilder.loadTexts: tmnxLogFilterEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterEntry.setDescription('Information about a particular Log Filter entry. Entries are created by user. Entries are deleted by user. Entry 1001 is created by the agent for default TmnxLogIdIndex 100. There is no StorageType object. Entries have a presumed StorageType of nonVolatile. ')
tmnxLogFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1, 1), TmnxLogFilterId().subtype(subtypeSpec=ValueRangeConstraint(1, 1001)))
if mibBuilder.loadTexts: tmnxLogFilterId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterId.setDescription('The value of tmnxLogFilterId is a unique index that identifies a particular entry in the tmnxLogFilterTable.')
tmnxLogFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterRowStatus.setDescription('Row entries in this table are created and destroyed via SNMP set requests.')
tmnxLogFilterDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1, 3), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterDescription.setDescription('The value of tmnxLogFilterDescription is a user provided description string for this log filter. It can consist of any printable, seven-bit ASCII characters up to 80 characters in length.')
tmnxLogFilterDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1, 4), TFilterAction().clone('forward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterDefaultAction.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterDefaultAction.setDescription('The action to take for packets that do not match any filter entries. the values default(3), and nat(5) are not allowed.')
tmnxLogFilterInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 6, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogFilterInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterInUse.setDescription("When tmnxLogFilterInUse has a value of 'true', this filter is attached to a log file configuration. The same tmnxLogFilterEntry can be attached to more than one log file.")
tmnxLogFilterParamsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7), )
if mibBuilder.loadTexts: tmnxLogFilterParamsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsTable.setDescription('A table of all log filter match entries for all log filters.')
tmnxLogFilterParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogFilterId"), (0, "TIMETRA-LOG-MIB", "tmnxLogFilterParamsIndex"))
if mibBuilder.loadTexts: tmnxLogFilterParamsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsEntry.setDescription('Information about a particular Log Filter Parameter entry. Every Log Filter can have zero or more Log Filter Parameter match entries. The Log Filter parameter entries are checked in ascending order by their index value, tmnxLogFilterParamsIndex. Upon the first successful match, the specified actions are applied as indicated by the value of tmnxLogFilterParamsAction. No further checking against remaining tmnxLogFilterParamsEntry rows is done. Therefore, entries in this table should be sequenced from most to least explicit match criterion. It is recommended that multiple parameter entries for a log filter should be created with gaps between their index values. This allows a new entry to be inserted into an existing filter policy without needing to renumber the already existing filter parameters entries. A log filter entry in the tmnxLogFilterTable with no entry in the tmnxLogFilterParamsTable to define its match criteria set will match every log event, and the default action specified by tmnxLogFilterDefaultAction will be taken. Entries are created by user. Entries are deleted by user. There is no StorageType object, entries have a presumed StorageType of nonVolatile. ')
tmnxLogFilterParamsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 1), TmnxLogFilterEntryId())
if mibBuilder.loadTexts: tmnxLogFilterParamsIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsIndex.setDescription('')
tmnxLogFilterParamsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsRowStatus.setDescription("Row Status for this Log filter's parameter entry.")
tmnxLogFilterParamsDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 3), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsDescription.setDescription('The value of tmnxLogFilterParamsDescription is a user provided description string for this log filter match entry. It can consist of any printable, seven-bit ASCII characters up to 80 characters in length.')
tmnxLogFilterParamsAction = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 4), TFilterActionOrDefault().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsAction.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsAction.setDescription("the action to take for log events that match this filter entry. the value default(3) is allowed. If tmnxLogFilterParamsAction has the value 'default', the action specified by the value of tmnxLogFilterDefaultAction is applied to events that match this filter entry. The value nat(5) is not allowed.")
tmnxLogFilterParamsApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 5), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsApplication.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsApplication.setDescription('Matches log events with the specified application name. An application is the software entity the reports the log event and includes IP, MPLS, OSPF, CLI, SERVICES, etc.')
tmnxLogFilterParamsApplOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 6), TmnxLogFilterOperator().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsApplOperator.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsApplOperator.setDescription("The value of tmnxLogFilterParamsApplOperator is the comparison operator to use to determine if the log event matches the value of tmnxLogFilterParamsApplication. The only valid values from TmnxLogFilterOperator are 'off', 'equal', and 'notEqual'.")
tmnxLogFilterParamsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 7), TmnxEventNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsNumber.setDescription('The value of tmnxLogFilterParamsNumber is the log event number to be matched. Event numbers uniquely identify a certain event within an application but not across applications.')
tmnxLogFilterParamsNumberOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 8), TmnxLogFilterOperator().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsNumberOperator.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsNumberOperator.setDescription('The value of tmnxLogFilterParamsNumberOperator is the comparison operator to use to determine if the log event matches the value of tmnxLogFilterParamsNumber.')
tmnxLogFilterParamsSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 9), TmnxPerceivedSeverity().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsSeverity.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsSeverity.setDescription('The value of tmnxLogFilterParamsSeverity is the log event severity level to be matched.')
tmnxLogFilterParamsSeverityOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 10), TmnxLogFilterOperator().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsSeverityOperator.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsSeverityOperator.setDescription('The value of tmnxLogFilterParamsSeverityOperator is the comparison operator to use to determine if the log event matches the value of tmnxLogFilterParamsSeverity.')
tmnxLogFilterParamsSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 11), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsSubject.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsSubject.setDescription('The value of tmnxLogFilterParamsSubject is the log event subject string to be matched. The subject is the entity that the event is reported for, such as a port ID.')
tmnxLogFilterParamsSubjectOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 12), TmnxLogFilterOperator().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsSubjectOperator.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsSubjectOperator.setDescription("The value of tmnxLogFilterParamsSubjectOperator is the comparison operator to use to determine if the log event matches the value of tmnxLogFilterParamsSubject. The only valid values of TmnxLogFilterOperator to use for the subject string comparison are 'off', 'equal', and 'notEqual'.")
tmnxLogFilterParamsSubjectRegexp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsSubjectRegexp.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsSubjectRegexp.setDescription("The value of tmnxLogFilterParamsSubjectRegexp specifies the type of string comparison to use to determine if the log event matches the value of tmnxLogFilterParamsSubject. When the value of tmnxLogFilterParamsSubjectRegexp is 'true', the string in tmnxLogFilterParamsSubject is a regular expression string to be matched against the subject string in the log event being filtered. When it has a value of 'false', the string in tmnxLogFilterParamsSubject is matched exactly by the event filter.")
tmnxLogFilterParamsRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 14), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsRouter.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsRouter.setDescription('The value of tmnxLogFilterParamsRouter is the log event router context name string to be matched.')
tmnxLogFilterParamsRouterOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 15), TmnxLogFilterOperator().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsRouterOperator.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsRouterOperator.setDescription("The value of tmnxLogFilterParamsRouterOperator is the comparison operator to use to determine if the log event matches the value of tmnxLogFilterParamsRouter. The only valid values of TmnxLogFilterOperator to use for the router name string comparison are 'off', 'equal', and 'notEqual'.")
tmnxLogFilterParamsRouterRegexp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 7, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogFilterParamsRouterRegexp.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFilterParamsRouterRegexp.setDescription("The value of tmnxLogFilterParamsRouterRegexp specifies the type of string comparison to use to determine if the log event matches the value of tmnxLogFilterParamsRouter. When the value of tmnxLogFilterParamsRouterRegexp is 'true', the string in tmnxLogFilterParamsRouter is a regular expression string to be matched against the router name string in the log event being filtered. When it has a value of 'false', the string in tmnxLogFilterParamsRouter is matched exactly by the event filter.")
tmnxSyslogTargetTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8), )
if mibBuilder.loadTexts: tmnxSyslogTargetTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetTable.setDescription('A table of all remote syslog collectors that this agent is configured to send syslog messages to.')
tmnxSyslogTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxSyslogTargetIndex"))
if mibBuilder.loadTexts: tmnxSyslogTargetEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetEntry.setDescription('Information about a particular Syslog Target entry. Entries are created by user. Entries are deleted by user. There is no StorageType object, entries have a presumed StorageType of nonVolatile. ')
tmnxSyslogTargetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 1), TmnxSyslogId())
if mibBuilder.loadTexts: tmnxSyslogTargetIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetIndex.setDescription('The value of tmnxSyslogTargetIndex is a unique arbitrary identifier for this syslog collector target.')
tmnxSyslogTargetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetRowStatus.setReference('RFC2579 (Textual Conventions for SMIv2)')
if mibBuilder.loadTexts: tmnxSyslogTargetRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetRowStatus.setDescription("The tmnxSyslogTargetRowStatus object allows for dynamic creation and deletion of row entries in the tmnxSyslogTargetTable as well as the activation and deactivation of these entries. When this object's value is set to 'notInService (2)', no messages will be sent to this target collector and none of its counters will be incremented. Refer to the RowStatus convention for further details on the behavior of this object.")
tmnxSyslogTargetDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 3), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetDescription.setDescription('The value of tmnxSyslogTargetDescription is an administratively assigned textual description of this syslog collector target.')
tmnxSyslogTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetAddress.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSyslogTargetAddress.setDescription("The value of tmnxSyslogTargetAddress is the IPv4 address for this syslog message collector target. If the value of this object is '0.0.0.0', then no messages will be sent, nor will any counters be incremented. This object was made obsolete in release 5.0. It is replaced by the InetAddress pair tmnxSyslogTargetAddrType and tmnxSyslogTargetAddr.")
tmnxSyslogTargetUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 5), TmnxUdpPort().clone(514)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetUdpPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetUdpPort.setDescription('The value of tmnxSyslogTargetUdpPort is the UDP port number that is used to send messages to this syslog collector target.')
tmnxSyslogTargetFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 6), TmnxSyslogFacility().clone('local7')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetFacility.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetFacility.setDescription('The value of tmnxSyslogTargetFacility is the syslog facility number that will be encoded in messages sent to this syslog collector target.')
tmnxSyslogTargetSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 7), TmnxSyslogSeverity().clone('info')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetSeverity.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetSeverity.setDescription('The value of tmnxSyslogTargetSeverity is the maximum severity level of the messages that SHOULD be forwarded to this syslog collector target. The higher the level, the lower the severity.')
tmnxSyslogTargetMessagePrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 8), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetMessagePrefix.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetMessagePrefix.setDescription("The value of tmnxSyslogTargetMessagePrefix is a string of ABNF alphanumeric characters to be prepended as the MSG TAG to the syslog MSG CONTENT string and separated from it with a colon and space, ': '.")
tmnxSyslogTargetMessagesDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyslogTargetMessagesDropped.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetMessagesDropped.setDescription('The value of tmnxSyslogTargetMessagesDropped is a count of messages not sent to this syslog collector target because the severity level of the message was above tmnxSyslogTargetSeverity; the higher the level, the lower the severity.')
tmnxSyslogTargetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 10), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetAddrType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetAddrType.setDescription("The value of tmnxSyslogTargetAddrType specifies the type of host address to be used for the syslog message collector target. This object indicates the type of address stored in the corresponding tmnxSyslogTargetAddr object. Only 'ipv4', 'ipv6', and 'ipv6z' address types are supported.")
tmnxSyslogTargetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 8, 1, 11), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSyslogTargetAddr.setStatus('current')
if mibBuilder.loadTexts: tmnxSyslogTargetAddr.setDescription("The value of tmnxSyslogTargetAddr specifies the IP host address to be used for the syslog message collector target. If no address is specified, ''H, then no messages will be sent nor will any counters be incremented. The syslog target address type is determined by the value of the corresponding tmnxSyslogTargetAddrType object.")
tmnxEventAppTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 9), )
if mibBuilder.loadTexts: tmnxEventAppTable.setStatus('current')
if mibBuilder.loadTexts: tmnxEventAppTable.setDescription('A table of all applications that generate TiMOS logger events.')
tmnxEventAppEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 9, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxEventAppIndex"))
if mibBuilder.loadTexts: tmnxEventAppEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxEventAppEntry.setDescription('Information about a particular application entry. Entries are created by the agent when the system initializes. There is no StorageType object, entries have a presumed StorageType of permanent. ')
tmnxEventAppIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 9, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxEventAppIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxEventAppIndex.setDescription('The value of tmnxEventAppIndex is a unique arbitrary identifier for this application event generator.')
tmnxEventAppName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 9, 1, 2), TNamedItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxEventAppName.setStatus('current')
if mibBuilder.loadTexts: tmnxEventAppName.setDescription('The value of tmnxEventAppName is the name string that is used in TiMOS log messages as the application that generated the logged event.')
tmnxEventTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10), )
if mibBuilder.loadTexts: tmnxEventTable.setStatus('current')
if mibBuilder.loadTexts: tmnxEventTable.setDescription('A table of all TiMOS events that can be generated.')
tmnxEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxEventAppIndex"), (0, "TIMETRA-LOG-MIB", "tmnxEventID"))
if mibBuilder.loadTexts: tmnxEventEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxEventEntry.setDescription('Information about a particular TiMOS event type entry. Entries are created by the agent when the system initializes. There is no StorageType object, entries have a presumed StorageType of permanent. ')
tmnxEventID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxEventID.setStatus('current')
if mibBuilder.loadTexts: tmnxEventID.setDescription('The value of tmnxEventID is a unique arbitrary identifier for indexing event type entries within an event generator application as identified by the value of tmnxEventAppIndex.')
tmnxEventName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 2), TNamedItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxEventName.setStatus('current')
if mibBuilder.loadTexts: tmnxEventName.setDescription('The value of tmnxEventName is a short name string used to describe this event type.')
tmnxEventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 3), TmnxPerceivedSeverity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventSeverity.setStatus('current')
if mibBuilder.loadTexts: tmnxEventSeverity.setDescription('The value of tmnxEventSeverity indicates the severity level that will be associated with this type of event when it is generated.')
tmnxEventControl = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventControl.setStatus('current')
if mibBuilder.loadTexts: tmnxEventControl.setDescription("The value of tmnxEventControl determines whether or not events of this type will be generated or suppressed. When it has a value of 'true', the event is generated and tmnxEventCounter is incremented. When it has a value of 'false', the event is suppressed and tmnxEventDropCount is incremented.")
tmnxEventCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxEventCounter.setStatus('current')
if mibBuilder.loadTexts: tmnxEventCounter.setDescription('The value of tmnxEventCounter is the number of times an event of this type has been generated.')
tmnxEventDropCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxEventDropCount.setStatus('current')
if mibBuilder.loadTexts: tmnxEventDropCount.setDescription("The value of tmnxEventDropCount is the number of times and event of this type has been suppressed because tmnxEventControl is set to 'false'. When tmnxEventControl is set to 'true', tmnxEventDropCount indicates the number of events dropped because of logger input queue size overrun or dropped because of throttling when tmnxEventThrottle is set to 'true'.")
tmnxEventReset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 7), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventReset.setStatus('current')
if mibBuilder.loadTexts: tmnxEventReset.setDescription("Setting tmnxEventReset to 'doAction (1)' causes the agent to reset the values of tmnxEventSeverity and tmnxEventControl to the default values for this event type.")
tmnxEventThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 10, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventThrottle.setStatus('current')
if mibBuilder.loadTexts: tmnxEventThrottle.setDescription("The value of tmnxEventThrottle determines whether or not events of this type will be throttled. When it has a value of 'true', the event is throttled at the rate indicated by the value of tmnxEventThrottleLimit and tmnxEventThrottleInterval. When it has a value of 'false', no event throttling is applied.")
tmnxSnmpTrapGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11), )
if mibBuilder.loadTexts: tmnxSnmpTrapGroupTable.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSnmpTrapGroupTable.setDescription('A table of all remote SNMP trap collectors to which this agent is configured to send SNMP notifications messages. This table was made obsolete in the 5.0 release and is replace with tmnxSnmpTrapDestTable.')
tmnxSnmpTrapGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxStgIndex"), (0, "TIMETRA-LOG-MIB", "tmnxStgDestAddress"), (0, "TIMETRA-LOG-MIB", "tmnxStgDestPort"))
if mibBuilder.loadTexts: tmnxSnmpTrapGroupEntry.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSnmpTrapGroupEntry.setDescription('Information about a particular SNMP trap destination entry. The first index instance creates and snmp trap group to be associated with the event log with the same value for tmnxLogIdIndex. The second and third indexes specify a remote SNMP trap destination that will be sent SNMP notification messages from the associated event log. Entries are created by user. Entries are deleted by user. There is no StorageType object, entries have a presumed StorageType of nonVolatile. This table was made obsolete in the 5.0 release and is replaced with the tmnxSnmpTrapDestTable.')
tmnxStgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 1), TmnxLogIdIndex())
if mibBuilder.loadTexts: tmnxStgIndex.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgIndex.setDescription('The value of tmnxStgIndex specifies an snmp trap group to be associated with the event log with the same value for tmnxLogIdIndex. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdIndex.')
tmnxStgDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 2), IpAddress().clone(hexValue="00000000"))
if mibBuilder.loadTexts: tmnxStgDestAddress.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgDestAddress.setDescription("The value of tmnxStgDestAddress is the IPv4 address for this remote snmp notification destination. If the value of this object is '0.0.0.0', then no messages will be sent, nor will any counters be incremented. This object was made obsolete in the 5.0 release. It is replaced by the InetAddressType/InetAddress objects tmnxStdDestAddrType and tmnxStdDestAddr.")
tmnxStgDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 3), TmnxUdpPort().clone(162))
if mibBuilder.loadTexts: tmnxStgDestPort.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgDestPort.setDescription('The value of tmnxStgDestPort is the UDP port number that is used to send messages to this remote SNMP notification destination. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdDestPort.')
tmnxStgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStgRowStatus.setReference('RFC2579 (Textual Conventions for SMIv2)')
if mibBuilder.loadTexts: tmnxStgRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgRowStatus.setDescription("The tmnxStgRowStatus object allows for dynamic creation and deletion of row entries in the tmnxSnmpTrapGroupTable as well as the activation and deactivation of these entries. When this object's value is set to 'notInService (2)', no messages will be sent to this snmp trap group and none of its counters will be incremented. Refer to the RowStatus convention for further details on the behavior of this object. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdRowStatus.")
tmnxStgDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 5), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStgDescription.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgDescription.setDescription('The value of tmnxStgDescription is an administratively assigned textual description of this snmp trap destination. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdDescription.')
tmnxStgVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 6), SnmpMessageProcessingModel().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStgVersion.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgVersion.setDescription('The value of tmnxStgVersion specifies the SNMP version that will be used to format notification messages sent to this snmp trap destination. The values supported by the Alcatel-Lucent SROS series SNMP agent are: 0 for SNMPv1 1 for SNMPv2c 3 for SNMPv3 This object was made obsolete in the 5.0 release. It is replaced by tmnxStdVersion.')
tmnxStgNotifyCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStgNotifyCommunity.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgNotifyCommunity.setDescription('The value of tmnxStgNotifyCommunity specifies the SNMPv1 or SNMPv2c community name string or the SNMPv3 security name used when an SNMP notification message is sent to this trap destination. If the value of this object is the empty string, then no messages will be sent nor will any counters be incremented. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdVersion.')
tmnxStgSecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 11, 1, 8), SnmpSecurityLevel().clone('noAuthNoPriv')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStgSecurityLevel.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxStgSecurityLevel.setDescription("The value of tmnxStgSecurityLevel specifies the level of security at which SNMP notification messages will be sent to the SNMP trap destination when tmnxStgVersion has a value of '3' for SNMPv3. This object was made obsolete in the 5.0 release. It is replaced by tmnxStdSecurityLevel.")
tmnxEventTest = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 12), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventTest.setStatus('current')
if mibBuilder.loadTexts: tmnxEventTest.setDescription("Setting tmnxEventTest to 'doAction' causes the tmnxTestEvent notification to be generated.")
tmnxEventThrottleLimit = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20000)).clone(2000)).setUnits('events').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventThrottleLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxEventThrottleLimit.setDescription('The value of tmnxEventThrottleLimit specifies the number of log events that can be logged within the tmnxEventThrottleInterval for a specific entry in the tmnxEventTable. Once the limit has been reached, any additional events of that type will be dropped, i.e. tmnxEventDropCount will be incremented. At the end of the throttle interval if any events have been dropped a tmnxLogEventThrottled notification will be sent.')
tmnxEventThrottleInterval = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventThrottleInterval.setStatus('current')
if mibBuilder.loadTexts: tmnxEventThrottleInterval.setDescription('The value of tmnxEventThrottleInterval specifies the number of seconds that an event throttling interval lasts.')
tmnxSnmpSetErrsMax = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSnmpSetErrsMax.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpSetErrsMax.setDescription('The value of tmnxSnmpSetErrsMax indicates the maximum number of entries the agent will create in the tmnxSnmpSetErrsTable. Once the table is full the agent will delete the oldest entry in the table in order to add new entries.')
tmnxSnmpSetErrsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16), )
if mibBuilder.loadTexts: tmnxSnmpSetErrsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpSetErrsTable.setDescription('A table of recent SNMP SET failures. Only the SET errs from remote SNMP manager requests are saved in this table. Only SET errs detected by the SNMP engine in the test phase consistency check method functions are saved. SET errors that are caught by the preliminary access and ASN.1 decoding phase are not saved. These are errs such as noAccess, notWritable, wrongType, wrongLength and wrongEncoding. Note that notWritable, wrongType, and wrongLength errs may sometimes be generated by the consistency check; in this case they will be saved in this table. SET errs caused by local CLI sessions are not saved. The tmnxSnmpSetErrsTable is intended to provide an aide to Network Management Systems (NMS) developers. When an SNMP SET fails during the consistency checking test phase, this table may provide more detailed failure reason information than the simple SNMP error code value in the SNMP response PDU.')
tmnxSnmpSetErrsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxSseAddressType"), (0, "TIMETRA-LOG-MIB", "tmnxSseAddress"), (0, "TIMETRA-LOG-MIB", "tmnxSseSnmpPort"), (0, "TIMETRA-LOG-MIB", "tmnxSseRequestId"))
if mibBuilder.loadTexts: tmnxSnmpSetErrsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpSetErrsEntry.setDescription('Information about a particular SNMP SET error. The first two index instances identify the SNMP manager who sent the SNMP SET request that failed. The third index specifies the SNMP request-id (sequence number) of the SNMP SET request that failed. Entries are created by the agent. Entries are deleted by the agent. There is no StorageType object, entries have a presumed StorageType of volatile.')
tmnxSseAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 1), InetAddressType())
if mibBuilder.loadTexts: tmnxSseAddressType.setStatus('current')
if mibBuilder.loadTexts: tmnxSseAddressType.setDescription("The value of tmnxSseAddressType indicates the IP address type of address specified in tmnxSseAddress. 'ipv4' and 'ipv6' are the only address type values supported.")
tmnxSseAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: tmnxSseAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxSseAddress.setDescription('The value of tmnxSseAddress is the IP address of the SNMP manager that sent the SNMP SET request that failed for this error reason.')
tmnxSseSnmpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 3), TmnxUdpPort())
if mibBuilder.loadTexts: tmnxSseSnmpPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSseSnmpPort.setDescription('The value of tmnxSseSnmpPort is the UDP port number of the SNMP manager that sent the SNMP SET request that failed for this error reason.')
tmnxSseRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 4), Unsigned32())
if mibBuilder.loadTexts: tmnxSseRequestId.setStatus('current')
if mibBuilder.loadTexts: tmnxSseRequestId.setDescription('The value of tmnxSseRequestId indicates the request-id of the SNMP SNMP SET request that failed for this error reason.')
tmnxSseVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 5), SnmpMessageProcessingModel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxSseVersion.setDescription('The value of tmnxSseVersion indicates the SNMP version of the SNMP SET request that failed. The values supported by the Alcatel-Lucent SROS series SNMP agent are: 0 for SNMPv1 1 for SNMPv2c 3 for SNMPv3 ')
tmnxSseSeverityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 6), TmnxPerceivedSeverity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseSeverityLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSseSeverityLevel.setDescription('The value of tmnxSseSeverityLevel indicates severity level that is associated with this type SNMP SET error.')
tmnxSseModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseModuleId.setStatus('current')
if mibBuilder.loadTexts: tmnxSseModuleId.setDescription('The value of tmnxSseModuleId indicates a unique arbitrary identified for the TiMOS application module that generated this SNMP SET error. NOTE: This is NOT the same value used for tmnxEventAppIndex.')
tmnxSseModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 8), TNamedItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseModuleName.setStatus('current')
if mibBuilder.loadTexts: tmnxSseModuleName.setDescription('The value of tmnxSseModuleName indicates the name string of the TiMOS application module that generated this SNMP SET error. NOTE: This is NOT the same value used for tmnxEventAppName.')
tmnxSseErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseErrorCode.setStatus('current')
if mibBuilder.loadTexts: tmnxSseErrorCode.setDescription('The value of tmnxSseErrorCode indicates the error number associated with this SNMP SET error. The error numbers are unique within a tmnxSseModuleId. They are not unique across all modules so both the module name and error number are required to identify a particular error message.')
tmnxSseErrorName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseErrorName.setStatus('current')
if mibBuilder.loadTexts: tmnxSseErrorName.setDescription('The value of tmnxSseErrorName indicates the error name associated with this SNMP SET error. The error names are unique within a tmnxSseModuleId. They are not unique across all modules so both the module name and error name are required to identify a particular error message.')
tmnxSseErrorMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseErrorMsg.setStatus('current')
if mibBuilder.loadTexts: tmnxSseErrorMsg.setDescription('The value of tmnxSseErrorMsg indicates the fixed error message text associated with this SNMP SET error identified by the values of tmnxSseModuleId and tmnxSseErrorCode.')
tmnxSseExtraText = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 320))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseExtraText.setStatus('current')
if mibBuilder.loadTexts: tmnxSseExtraText.setDescription('The value of tmnxSseExtraText indicates the fixed run-time variable message text associated with this SNMP SET error identified by the values of tmnxSseModuleId and tmnxSseErrorCode. If the extra text was truncated to fit into buffer size allowed, the last character will be an asterix (*).')
tmnxSseTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 16, 1, 13), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSseTimestamp.setStatus('current')
if mibBuilder.loadTexts: tmnxSseTimestamp.setDescription('The value of tmnxSseTimestamp indicates the sysUpTime value when this tmnxSnmpSetErrsEntry was created by the agent.')
tmnxSnmpTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 17), )
if mibBuilder.loadTexts: tmnxSnmpTrapLogTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapLogTable.setDescription('A table of all remote SNMP trap logs to which this agent is configured to send SNMP notifications messages.')
tmnxSnmpTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 17, 1), )
snmpNotifyEntry.registerAugmentions(("TIMETRA-LOG-MIB", "tmnxSnmpTrapLogEntry"))
tmnxSnmpTrapLogEntry.setIndexNames(*snmpNotifyEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxSnmpTrapLogEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapLogEntry.setDescription('Each row entry in the tmnxSnmpTrapLogTable represents additional columns for attributes specific to the Alcatel-Lucent SROS series implementation of SNMP-NOTIFICATION-MIB::snmpNotifyTable.')
tmnxSnmpTrapLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 17, 1, 1), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxSnmpTrapLogDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapLogDescription.setDescription('The value of tmnxSnmpTrapLogDescription is an administratively assigned textual description of this snmp trap log.')
tmnxSnmpTrapDestTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18), )
if mibBuilder.loadTexts: tmnxSnmpTrapDestTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapDestTable.setDescription('A table of all remote SNMP IPv4/v6 trap collectors to which this agent is configured to send SNMP notification messages.')
tmnxSnmpTrapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxStdIndex"), (1, "TIMETRA-LOG-MIB", "tmnxStdName"))
if mibBuilder.loadTexts: tmnxSnmpTrapDestEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapDestEntry.setDescription('Information about a particular SNMP notification destination entry. The first index instance creates an snmp notification group to be associated with the event log with the same value for tmnxLogIdIndex. The second index specifies an administrative name to identify a specific SNMP notification target. Entries are created by user. Entries are deleted by user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxStdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 1), TmnxLogIdIndex())
if mibBuilder.loadTexts: tmnxStdIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxStdIndex.setDescription('The value of tmnxStdIndex specifies an snmp notification group to be associated with the event log with the same value for tmnxLogIdIndex.')
tmnxStdName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 28)))
if mibBuilder.loadTexts: tmnxStdName.setStatus('current')
if mibBuilder.loadTexts: tmnxStdName.setDescription('The value of tmnxStdName specifies the name of an snmp notification destination within the snmp notification group specified by tmnxLogIdIndex.')
tmnxStdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdRowStatus.setReference('RFC2579 (Textual Conventions for SMIv2)')
if mibBuilder.loadTexts: tmnxStdRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxStdRowStatus.setDescription("The tmnxStdRowStatus object allows for dynamic creation and deletion of row entries in the tmnxSnmpTrapDestTable as well as the activation and deactivation of these entries. In order for 'createAndGo' row creation to succeed or status to transition to 'active' a value must be set for tmnxStdNotifyCommunity. In order for 'createAndGo' row creation to succeed or status to transition to 'active' an entry must exist in the SNMP-NOTIFICATION-MIB::snmpNotifyTable with an snmpNotifyName index that is the ASCII string representation of the value of tmnxStdIndex. When this object's value is set to 'notInService (2)', no messages will be sent to this snmp notification collector and none of its counters will be incremented. Refer to the RowStatus convention for further details on the behavior of this object.")
tmnxStdRowLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxStdRowLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxStdRowLastChanged.setDescription('The value of tmnxStdRowLastChanged indicates the sysUpTime when the value of a writable object in this row entry was modified.')
tmnxStdDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 5), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdDestAddrType.setStatus('current')
if mibBuilder.loadTexts: tmnxStdDestAddrType.setDescription("The value of tmnxStdDestAddrType specifies the type of host address to be used for the remote SNMP notification collector. This object indicates the type of address stored in the corresponding tmnxStdDestAddr object. If the value of this object is 'unknown', then no messages will be sent nor will any counters be incremented. If tmnxStdDestAddrType is not set in the same PDU with tmnxStdDestAddr, the set request will fail with an inconsistentValue error.")
tmnxStdDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdDestAddr.setStatus('current')
if mibBuilder.loadTexts: tmnxStdDestAddr.setDescription('The value of tmnxStdDestAddr specifies the IP host address to be used for the remote SNMP notification collector. The SNMP notification collector IP address type is determined by the value of the corresponding tmnxStdDestAddrType object. If the value of this object is empty or all NULLs, then no messages will be sent nor will any counters be incremented. If tmnxStdDestAddrType is not set in the same PDU with tmnxStdDestAddr, the set request will fail with an inconsistentValue error.')
tmnxStdDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 7), TmnxUdpPort().clone(162)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdDestPort.setStatus('current')
if mibBuilder.loadTexts: tmnxStdDestPort.setDescription('The value of tmnxStdDestPort is the UDP port number that is used to send messages to this remote SNMP notification collector.')
tmnxStdDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 8), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxStdDescription.setDescription('The value of tmnxStdDescription is an administratively assigned textual description of this SNMP notification collector.')
tmnxStdVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 9), SnmpMessageProcessingModel().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxStdVersion.setDescription('The value of tmnxStdVersion specifies the SNMP version that will be used to format notification messages sent to this SNMP notification collector. The values supported by the Alcatel-Lucent SROS series SNMP agent are: 0 for SNMPv1 1 for SNMPv2c 3 for SNMPv3 ')
tmnxStdNotifyCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdNotifyCommunity.setStatus('current')
if mibBuilder.loadTexts: tmnxStdNotifyCommunity.setDescription('The value of tmnxStdNotifyCommunity specifies the SNMPv1 or SNMPv2c community name string or the SNMPv3 security name used when an SNMP notification message is sent to this SNMP notification collector. If the value of this object is the empty string, then no messages will be sent nor will any counters be incremented.')
tmnxStdSecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 11), SnmpSecurityLevel().clone('noAuthNoPriv')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxStdSecurityLevel.setDescription("The value of tmnxStdSecurityLevel specifies the level of security at which SNMP notification messages will be sent to the SNMP notification collector when tmnxStdVersion has a value of '3' for SNMPv3.")
tmnxStdReplay = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxStdReplay.setStatus('current')
if mibBuilder.loadTexts: tmnxStdReplay.setDescription('The value of tmnxStdReplay specifies whether or not to resend notifications that were generated while this notification destination did not have a route installed for it in the route tables.')
tmnxStdReplayStart = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxStdReplayStart.setStatus('current')
if mibBuilder.loadTexts: tmnxStdReplayStart.setDescription('The value of tmnxStdReplayStart indicates the SNMP notification request ID of the first event that cound not be generated because there is no route to this notification target address. Events will be resent when this notification target address is readded to the route tables, on either an in-band or out-of-band interface. The agent searches backwards in the event log and begins resending events from the oldest event that has a timestamp <= 5 hundredths of a second less than the timestamp of the event with this request ID. Note that if the outage is long and a large number of events are generated in the meantime, it is possible that the log memory storage has wrapped and the event data for this request ID is no longer available. In that case, the oldest event saved in the log will be the first event resent. A value of 0 indicates that there are no missed events waiting to be resent.')
tmnxStdReplayLastTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 18, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxStdReplayLastTime.setStatus('current')
if mibBuilder.loadTexts: tmnxStdReplayLastTime.setDescription('The value of tmnxStdReplayLastTime indicates the sysUpTime when missed events were last replayed to this SNMP notification target address. A value of 0 indicates that no missed events have been replayed to this SNMP notification target address.')
tmnxStdMaxTargets = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 100)).clone(25)).setUnits('trap-targets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxStdMaxTargets.setStatus('current')
if mibBuilder.loadTexts: tmnxStdMaxTargets.setDescription('The maximum number of tmnxSnmpTrapDestTable row entries that can be created for a specific tmnxStdIndex that represents an snmp notification group.')
tmnxLogApCustRecordTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20), )
if mibBuilder.loadTexts: tmnxLogApCustRecordTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCustRecordTable.setDescription('The Alcatel-Lucent SROS series tmnxLogApCustRecordTable augments tmnxLogApTable. The table allows to configure the layout and setting for a custom accounting record associated with this accounting policy.')
tmnxLogApCustRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1), )
tmnxLogApEntry.registerAugmentions(("TIMETRA-LOG-MIB", "tmnxLogApCustRecordEntry"))
tmnxLogApCustRecordEntry.setIndexNames(*tmnxLogApEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxLogApCustRecordEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCustRecordEntry.setDescription('Defines an entry in the tmnxLogApCustRecordTable. Entries in this table are created and destroyed via SNMP Set requests to the tmnxLogApRowStatus object of the tmnxLogApTable.')
tmnxLogApCrLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApCrLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrLastChanged.setDescription('The value of tmnxLogApCrLastChanged indicates the sysUpTime when an object in this table was last modified. A Value 0 means that no change was made to this row since the box was last initialized.')
tmnxLogApCrSignChangeDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeDelta.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeDelta.setDescription('The value of tmnxLogApCrSignChangeDelta specifies the delta change (significant change) that is required for the custom record to be written to the xml file.')
tmnxLogApCrSignChangeQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 3), TQueueIdOrAll()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQueue.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQueue.setDescription('The value of tmnxLogApCrSignChangeQueue specifies the reference queue to which the significant change defined in tmnxLogApCrSignChangeDelta applies.')
tmnxLogApCrSignChangeOCntr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 4), THsmdaCounterIdOrZeroOrAll()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOCntr.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOCntr.setDescription('The value of tmnxLogApCrSignChangeOCntr specifies the counter-id that will be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies.')
tmnxLogApCrSignChangeQICounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 5), TmnxAccPlcyQICounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQICounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQICounters.setDescription('The value of tmnxLogApCrSignChangeQICounters specifies the ingress counter Ids in the queue defined by tmnxLogApCrSignChangeQueue to be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies. A non-zero value of this object is only allowed if the object tmnxLogApCrSignChangeQueue has a non-zero value.')
tmnxLogApCrSignChangeQECounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 6), TmnxAccPlcyQECounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQECounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeQECounters.setDescription('The value of tmnxLogApCrSignChangeQECounters specifies the egress counter Ids in the queue defined by tmnxLogApCrSignChangeQueue to be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies. A non-zero value of this object is only allowed if the object tmnxLogApCrSignChangeQueue has a non-zero value.')
tmnxLogApCrSignChangeOICounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 7), TmnxAccPlcyOICounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOICounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOICounters.setDescription('The value of tmnxLogApCrSignChangeOICounters specifies the ingress counter Ids in the counter-group defined by tmnxLogApCrSignChangeOCntr to be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies. A non-zero value of this object is only allowed if the object tmnxLogApCrSignChangeOCntr has a non-zero value.')
tmnxLogApCrSignChangeOECounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 8), TmnxAccPlcyOECounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOECounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeOECounters.setDescription('The value of tmnxLogApCrSignChangeOECounters specifies the egress counter Ids in the counter-group defined by tmnxLogApCrSignChangeOCntr to be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies. A non-zero value of this object is only allowed if the object tmnxLogApCrSignChangeOCntr has a non-zero value.')
tmnxLogApCrSignChangeAACounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 9), TmnxAccPlcyAACounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrSignChangeAACounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrSignChangeAACounters.setDescription('The value of tmnxLogApCrSignChangeAACounters specifies the AA (Application assurance) counter Ids to be taken as reference to which the significant change defined in tmnxLogApCrSignChangeDelta applies. A non-zero value of this object is only allowed if both the objects tmnxLogApCrSignChangeOCntr and tmnxLogApCrSignChangeQueue are zero. Also, a non-zero value for this object is only allowed if the object tmnxLogApCrSignChangeDelta is either 0 or 1.')
tmnxLogApCrAACounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 20, 1, 10), TmnxAccPlcyAACounters().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogApCrAACounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrAACounters.setDescription('The value of tmnxLogApCrQueueECounters indicates the list of AA (application Assurance) counters that need to be collected in this custom record.')
tmnxLogApCustRecordQueueTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21), )
if mibBuilder.loadTexts: tmnxLogApCustRecordQueueTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCustRecordQueueTable.setDescription('The Alcatel-Lucent SROS series tmnxLogApCustRecordQueueTable allows to create custom record queue information for a given accounting policy. Rows can only be created for existing accounting policies (as defined in tmnxLogApTable).')
tmnxLogApCustRecordQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogApPolicyId"), (0, "TIMETRA-LOG-MIB", "tmnxLogApCrQueueId"))
if mibBuilder.loadTexts: tmnxLogApCustRecordQueueEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCustRecordQueueEntry.setDescription('Defines an entry in the tmnxLogApCustRecordQueueTable. Entries in this table are created and destroyed via SNMP Set requests.')
tmnxLogApCrQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1, 1), TQueueId().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: tmnxLogApCrQueueId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrQueueId.setDescription('The value of tmnxLogApCrQueueId specifies the queue-id for which counters will be collected in this custom record. The counters that will be collected are defined in tmnxLogApCrQueueICounters and tmnxLogApCrQueueECounters.')
tmnxLogApCrQueueRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrQueueRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrQueueRowStatus.setDescription('Row Status of the entry. This allows creation/deletion of rows in this table.')
tmnxLogApCrQueueLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApCrQueueLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrQueueLastChanged.setDescription('The value of tmnxLogApCrQueueLastChanged indicates the sysUpTime when an object in this table was last modified. A Value 0 means that no change was made to this row since it was created.')
tmnxLogApCrQueueICounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1, 4), TmnxAccPlcyQICounters().clone(hexValue="0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrQueueICounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrQueueICounters.setDescription('The value of tmnxLogApCrQueueICounters indicates the list of ingress counters that need to be collected in this custom record. At least one of the objects tmnxLogApCrQueueICounters or tmnxLogApCrQueueECounters must have a non-zero value.')
tmnxLogApCrQueueECounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 21, 1, 5), TmnxAccPlcyQECounters().clone(hexValue="0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrQueueECounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrQueueECounters.setDescription('The value of tmnxLogApCrQueueECounters indicates the list of egress counters that need to be collected in this custom record. At least one of the objects tmnxLogApCrQueueICounters or tmnxLogApCrQueueECounters must have a non-zero value.')
tmnxLogApCrOverrideCntrTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22), )
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrTable.setDescription('The Alcatel-Lucent SROS series tmnxLogApCrOverrideCntrTable allows to create custom record counter override information for a given accounting policy. Rows can only be created for existing accounting policies (as defined in tmnxLogApTable).')
tmnxLogApCrOverrideCntrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogApPolicyId"), (0, "TIMETRA-LOG-MIB", "tmnxLogApCrOverrideCntrId"))
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrEntry.setDescription('Defines an entry in the tmnxLogApCrOverrideCntrTable. Entries in this table are created and destroyed via SNMP Set requests.')
tmnxLogApCrOverrideCntrId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1, 1), THsmdaCounterIdOrZero().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrId.setDescription('The value of tmnxLogApCrOverrideCntrId specifies the counter group for which counters will be collected in this custom record. The counters that will be collected are defined in tmnxLogApCrOverrideCntrICounters and tmnxLogApCrOverrideCntrECounters.')
tmnxLogApCrOverrideCntrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrRowStatus.setDescription('Row Status of the entry. This allows creation/deletion of rows in this table.')
tmnxLogApCrOverrideCntrLastChngd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrLastChngd.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrLastChngd.setDescription('The value of tmnxLogApCrOverrideCntrLastChngd indicates the sysUpTime when an object in this table was last modified. A Value 0 means that no change was made to this row since it was created.')
tmnxLogApCrOverrideCntrICounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1, 4), TmnxAccPlcyOICounters().clone(hexValue="0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrICounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrICounters.setDescription('The value of tmnxLogApCrOverrideCntrICounters indicates the list of ingress counters that need to be collected in this custom record. At least one of the objects tmnxLogApCrOverrideCntrICounters or tmnxLogApCrOverrideCntrECounters must have a non-zero value.')
tmnxLogApCrOverrideCntrECounters = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 22, 1, 5), TmnxAccPlcyOECounters().clone(hexValue="0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrECounters.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApCrOverrideCntrECounters.setDescription('The value of tmnxLogApCrOverrideCntrECounters indicates the list of egress counters that need to be collected in this custom record. At least one of the objects tmnxLogApCrOverrideCntrICounters or tmnxLogApCrOverrideCntrECounters must have a non-zero value.')
tmnxEventPrimaryRoutePref = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inband", 1), ("outband", 2))).clone('outband')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventPrimaryRoutePref.setStatus('current')
if mibBuilder.loadTexts: tmnxEventPrimaryRoutePref.setDescription("The value of tmnxEventPrimaryRoutePref specifies the primary routing preference for traffic generated for SNMP notifications and syslog messages. A value of 'inband' specifies that the Logging utility will attempt to use the Base routing context to send SNMP notifications and syslog messages to remote destinations. A value of 'outband' specifies that the Logging utility will attempt to use the management routing context to send SNMP notifications and syslog messages to remote destinations. If the remote destination, as specified by tmnxStdDestAddr or tmnxSyslogTargetAddr, is not reachable via the routing context specified by tmnxEventPrimaryRoutePref, the secondary routing preference as specified by tmnxEventSecondaryRoutePref will be attempted.")
tmnxEventSecondaryRoutePref = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inband", 1), ("outband", 2), ("none", 3))).clone('inband')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxEventSecondaryRoutePref.setStatus('current')
if mibBuilder.loadTexts: tmnxEventSecondaryRoutePref.setDescription("The value of tmnxEventSecondaryRoutePref specifies the secondary routing preference for traffic generated for SNMP notifications and syslog messages. The routing context specified by the tmnxEventSecondaryRoutePref will be attempted if the remote destination was not reachable by the primary routing preference, specified by tmnxEventPrimaryRoutePref. The value specified for tmnxEventSecondaryRoutePref must be distinct from the value for tmnxEventPrimaryRoutePref. A value of 'inband' specifies that the Logging utility will attempt to use the Base routing context to send SNMP notifications and syslog messages to remote destinations. A value of 'outband' specifies that the Logging utility will attempt to use the management routing context to send SNMP notifications and syslog messages to remote destinations. A value of 'none' specifies that no attempt will be made to send SNMP notifications and syslog messages to remote destinations. If the remote destination, as specified by tmnxStdDestAddr or tmnxSyslogTargetAddr, is not reachable via the routing contexts specified by tmnxEventPrimaryRoutePref and tmnxEventSecondaryRoutePref, the Log utility will fail to send SNMP notifications and syslog messages to the remote destination.")
tmnxLogConfigEventsDamped = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 25), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogConfigEventsDamped.setStatus('current')
if mibBuilder.loadTexts: tmnxLogConfigEventsDamped.setDescription("The value of tmnxLogConfigEventsDamped specifies whether or not the module generating tmnxConfigCreate, tmnxConfigDelete, and tmnxConfigModify events applies a damping algorithm. WARNING: While this event damping is original behavior for some modules such as service manager, QoS, and filters it can result in the NMS system database being out of sync because of missed change events. On the other hand, if the damping is disabled, 'false', it may take much longer for a large CLI configuration file to be processed when manually 'execed' after system bootup.")
tmnxLogEventHistoryObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26))
tmnxLogEventHistGeneralObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 1))
tmnxLogExRbkOpTblLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpTblLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpTblLastChange.setDescription('The value of the object tmnxLogExRbkOpTblLastChange indicates the value of sysUpTime at the time of the last modification of a row entry in the tmnxLogExecRollbackOpTable.')
tmnxLogExRbkOpMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogExRbkOpMaxEntries.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpMaxEntries.setDescription('The value of the object tmnxLogExRbkOpMaxEntries specifies the maximum number of row entries supported in the tmnxLogExecRollbackOpTable.')
tmnxLogExecRollbackOpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3), )
if mibBuilder.loadTexts: tmnxLogExecRollbackOpTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExecRollbackOpTable.setDescription("The Alcatel-Lucent SROS series tmnxLogExecRollbackOpTable provides a history of up to the last number of 'exec' or rollback revert operations specified by the value of tmnxLogExRbkOpMaxEntries. The tmnxLogExecRollbackOpTable is intended to provide an aide to Network Management Systems (NMS). The 'exec' of a large configuration file via the system's CLI or a large rollback revert operation will generate so many configuration change and other events in a short time that neither the SROS's event logging utility no the NMS can keep up with them. This results in either or both the SROS and NMS dropping events and requires the NMS to perform a costly resynchronization of its management database.")
tmnxLogExecRollbackOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogExRbkOpIndex"))
if mibBuilder.loadTexts: tmnxLogExecRollbackOpEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExecRollbackOpEntry.setDescription('Defines a row entry in the tmnxLogExecRollbackOpTable. Entries in this table are created and deleted by the agent.')
tmnxLogExRbkOpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxLogExRbkOpIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpIndex.setDescription('The value of tmnxLogExRbkOpIndex is a unique value that indicates an instance of an exec or rollback revert operation. Only the most recent instances are kept in this table. The maximum number of row entries supported in this table is specified by the value of tmnxLogExRbkOpMaxEntries.')
tmnxLogExRbkOpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpLastChanged.setDescription('The value of tmnxLogExRbkOpLastChanged indicates the sysUpTime when an object in this table was last modified. A Value 0 means that no change was made to this row since it was created.')
tmnxLogExRbkOpType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("exec", 1), ("rollback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpType.setDescription('The value of tmnxLogExRbkOpType indicates the type of operation this row entry represents.')
tmnxLogExRbkOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("inProgress", 1), ("success", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpStatus.setDescription('The value of tmnxLogExRbkOpStatus indicates the status of this exec or rollback revert operation.')
tmnxLogExRbkOpBegin = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpBegin.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpBegin.setDescription('The value of tmnxLogExRbkOpBegin indicates the sysUpTime when the exec or rollback revert operation began.')
tmnxLogExRbkOpEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpEnd.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpEnd.setDescription('The value of tmnxLogExRbkOpEnd indicates the sysUpTime when the exec or rollback revert operation ended. A value of zero (0) means that the operation has not completed.')
tmnxLogExRbkOpFile = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpFile.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpFile.setDescription('The value of tmnxLogExRbkOpFile indicates the location and name of the file used for the exec or rollback revert operation.')
tmnxLogExRbkOpUser = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 8), TNamedItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpUser.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpUser.setDescription('The value of tmnxLogExRbkOpUser indicates the user who initiated the exec or rollback revert operation.')
tmnxLogExRbkOpNumEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkOpNumEvents.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpNumEvents.setDescription('The value of tmnxLogExRbkOpNumEvents indicates the number of row entries in the associated tmnxLogExecRollbackEventTable for this exec or rollback revert operation. It is updated only when the exec or rollback revert operation ends. A value of zero (0) means that the operation has not completed.')
tmnxLogExecRollbackEventTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 4), )
if mibBuilder.loadTexts: tmnxLogExecRollbackEventTable.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExecRollbackEventTable.setDescription('The Alcatel-Lucent SROS series tmnxLogExecRollbackEventTable provides a history of mib tables modified or specific events generated during an exec or rollback revert operation.')
tmnxLogExecRollbackEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 4, 1), ).setIndexNames((0, "TIMETRA-LOG-MIB", "tmnxLogExRbkOpIndex"), (0, "TIMETRA-LOG-MIB", "tmnxLogExRbkEventIndex"))
if mibBuilder.loadTexts: tmnxLogExecRollbackEventEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExecRollbackEventEntry.setDescription('Defines a row entry in the tmnxLogExecRollbackEventTable. Each row entry represents either an SNMP table that has been modified or a specific event generated during an exec or rollback revert operation. Entries in this table are created and deleted by the agent.')
tmnxLogExRbkEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxLogExRbkEventIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkEventIndex.setDescription('The value of tmnxLogExRbkEventIndex is a unique value that indicates an instance of an event generated during an exec or rollback revert operation.')
tmnxLogExRbkEventOID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxLogExRbkEventOID.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkEventOID.setDescription('The value of tmnxLogExRbkEventOID indicates the object identifier of either a mib table for which a generic change event was generated or the notification object identifier of a specific event notification generated during the the exec or rollback revert operation. The generic change events are tmnxConfigCreate, tmnxConfigDelete, tmnxConfigModify, and tmnxStateChange notifications. For these event types, the value of tmnxLogExRbkEventOID is the object identifier specified by the tmnxNotifyEntryOID varbind. For specific events generated during an exec or rollback revert, the value of this object is the notification object identifier itself. An object identifier will appear only once in this table.')
tmnxLogExRbkNotifyObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 5))
tmnxLogExecRollbackOpIndex = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 26, 5, 1), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogExecRollbackOpIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExecRollbackOpIndex.setDescription("The value of tmnxLogExecRollbackOpIndex is a unique value that indicates a row entry instance of an exec or rollback revert operation in the tmnxLogExecRollbackOpTable. It is included in the 'exec' and rollback revert start and end notifications.")
tmnxLogColdStartWaitTime = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogColdStartWaitTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogColdStartWaitTime.setDescription('The value of tmnxLogColdStartWaitTime specifies the time delay that must pass before notifying specific CPM applications that a route is available after a cold reboot.')
tmnxLogRouteRecoveryWaitTime = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxLogRouteRecoveryWaitTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogRouteRecoveryWaitTime.setDescription('The value of tmnxLogRouteRecoveryWaitTime specifies the time delay that must pass before notifying specific CPM applications after the recovery or change of a route during normal operation.')
tmnxLogFileDeletedLogId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 1), TmnxLogIdIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedLogId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedLogId.setDescription('The value of tmnxLogFileDeletedLogId indicates with which event log-id or accounting-policy-id the deleted file was associated. Note the corresponding entry in the tmnxLogIdTable or tmnxLogApTable may no longer exist.')
tmnxLogFileDeletedFileId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 2), TmnxLogFileId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedFileId.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedFileId.setDescription('The value of tmnxLogFileDeletedFileId indicates with which event log-id or accounting-policy-id the deleted file was associated. Note that the corresponding entry in the tmnxLogFileIdTable may no longer exist.')
tmnxLogFileDeletedLogType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 3), TmnxLogFileType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedLogType.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedLogType.setDescription("The value of tmnxLogFileDeletedLogType indicates whether the deleted file was an 'eventLog' or 'accountingPolicy'.")
tmnxLogFileDeletedLocation = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 4), TmnxCFlash()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedLocation.setDescription('The value of tmnxLogFileDeletedLocation indicates on which compact flash device the event log or accounting policy file that has been deleted was located. ')
tmnxLogFileDeletedName = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 5), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedName.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedName.setDescription('The value of tmnxLogFileDeletedName indicates the pathname of an event log or accounting policy file that has been deleted because of space contention on a compact flash device.')
tmnxLogFileDeletedCreateTime = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 6), DateAndTime()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogFileDeletedCreateTime.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeletedCreateTime.setDescription('The value of tmnxLogFileDeletedCreateTime indicates the date and time when the deleted file had been created.')
tmnxLogTraceErrorTitle = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogTraceErrorTitle.setStatus('current')
if mibBuilder.loadTexts: tmnxLogTraceErrorTitle.setDescription('The value of tmnxLogTraceErrorTitle indicates the title string of the trace error event that generated the tmnxLogTraceError notification.')
tmnxLogTraceErrorSubject = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogTraceErrorSubject.setStatus('current')
if mibBuilder.loadTexts: tmnxLogTraceErrorSubject.setDescription('The value of tmnxLogTraceErrorSubject indicates the subject string of the trace error event that generated the tmnxLogTraceError notification. The subject is the entity that originated the event, such as the Slot ID.')
tmnxLogTraceErrorMessage = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 9), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogTraceErrorMessage.setStatus('current')
if mibBuilder.loadTexts: tmnxLogTraceErrorMessage.setDescription('The value of tmnxLogTraceErrorMessage indicates the message text string of the trace error event that generated the tmnxLogTraceError notification.')
tmnxLogThrottledEventID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 10), ObjectIdentifier()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogThrottledEventID.setStatus('current')
if mibBuilder.loadTexts: tmnxLogThrottledEventID.setDescription('tmnxLogThrottledEventID is used by the tmnxLogEventThrottled notification to indicate the NOTIFICATION-TYPE object identifier of the throttled event.')
tmnxLogThrottledEvents = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 11), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogThrottledEvents.setStatus('current')
if mibBuilder.loadTexts: tmnxLogThrottledEvents.setDescription('tmnxLogThrottledEvents is used by the tmnxLogEventThrottled notification to indicate the number of events dropped because of event throttling during the last throttle interval.')
tmnxSysLogTargetId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 12), TmnxSyslogId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxSysLogTargetId.setStatus('current')
if mibBuilder.loadTexts: tmnxSysLogTargetId.setDescription('tmnxSysLogTargetId is used by the tmnxSysLogTargetProblem notification to indicate the involved TmnxSyslogId.')
tmnxSysLogTargetProblemDescr = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 13), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxSysLogTargetProblemDescr.setStatus('current')
if mibBuilder.loadTexts: tmnxSysLogTargetProblemDescr.setDescription('The value of tmnxSysLogTargetProblemDescr indicates the type of error encountered when trying to deliver events to the destination specified in the TmnxSyslogId.')
tmnxLogNotifyApInterval = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 120))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxLogNotifyApInterval.setStatus('current')
if mibBuilder.loadTexts: tmnxLogNotifyApInterval.setDescription('The value of tmnxLogNotifyApInterval indicates how frequently the statistics are collected and written to their destination.')
tmnxStdReplayStartEvent = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 15), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxStdReplayStartEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxStdReplayStartEvent.setDescription('The value of tmnxStdReplayStartEvent indicates the SNMP notification request ID of the first missed event that was replayed when an SNMP notification target address was readded to the RTM following a period when the target address had been removed. It is used by the tmnxStdEventsReplayed notification.')
tmnxStdReplayEndEvent = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 12, 1, 16), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxStdReplayEndEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxStdReplayEndEvent.setDescription('The value of tmnxStdReplayEndEvent indicates the SNMP notification request ID of the last missed event that was replayed when an SNMP notification target address was readded to the RTM following a period when the target address had been removed. It is used by the tmnxStdEventsReplayed notification.')
tmnxLogSpaceContention = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 1)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdRolloverTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdRetainTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogType"))
if mibBuilder.loadTexts: tmnxLogSpaceContention.setStatus('current')
if mibBuilder.loadTexts: tmnxLogSpaceContention.setDescription('Generated when space contention occurs on the compact flash where a log or billing file creation is being attempted. Space contention exists if: Insufficient space is available on the compact flash to create a file of the same size as the file being rolled over. The first file of this type is being created and less than 10% of the total compact flash space is available. A write operation on a log or billing file is denied due to lack of space.')
tmnxLogAdminLocFailed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 2)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogType"))
if mibBuilder.loadTexts: tmnxLogAdminLocFailed.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAdminLocFailed.setDescription('Generated when an attempt to create a log or billing file at the location specified by tmnxLogFileIdAdminLocation has failed. Indicates that the backup location, if specified, will be used.')
tmnxLogBackupLocFailed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 3)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogType"))
if mibBuilder.loadTexts: tmnxLogBackupLocFailed.setStatus('current')
if mibBuilder.loadTexts: tmnxLogBackupLocFailed.setDescription('Generated when an attempt to create a log or billing file at the location specified by tmnxLogFileIdBackupLoc has failed.')
tmnxLogFileRollover = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 4)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdRolloverTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdRetainTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdPathName"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdCreateTime"))
if mibBuilder.loadTexts: tmnxLogFileRollover.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileRollover.setDescription("Generated when an event log or accounting policy file's rollover time has expired. The file located as indicated by the value of tmnxLogFileIdOperLocation is closed and a new file is created as specified by tmnxLogFileIdAdminLocation and tmnxLogFileIdBackupLoc.")
tmnxLogFileDeleted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 5)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedFileId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedName"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedCreateTime"))
if mibBuilder.loadTexts: tmnxLogFileDeleted.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileDeleted.setDescription('Generated when a closed event log or accounting policy file has been deleted as part of the space contention cleanup.')
tmnxTestEvent = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 6)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysObjectID"))
if mibBuilder.loadTexts: tmnxTestEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxTestEvent.setDescription("The tmnxTestEvent notification is generated when the object tmnxEventTest is set to a value of 'doAction'. This event can be used to test that remote log destinations such as syslog and snmp trap destinations are configured correctly.")
tmnxLogTraceError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 7)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogTraceErrorTitle"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorMessage"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorSubject"))
if mibBuilder.loadTexts: tmnxLogTraceError.setStatus('current')
if mibBuilder.loadTexts: tmnxLogTraceError.setDescription('The tmnxLogTraceError notification is generated when a trace error event is detected.')
tmnxLogEventThrottled = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 8)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogThrottledEventID"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEvents"))
if mibBuilder.loadTexts: tmnxLogEventThrottled.setStatus('current')
if mibBuilder.loadTexts: tmnxLogEventThrottled.setDescription('A tmnxLogEventThrottled notification is generated at the end of the throttling interval when one or more events are dropped because the throttling limit was reached for that interval.')
tmnxSysLogTargetProblem = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 9)).setObjects(("TIMETRA-LOG-MIB", "tmnxSysLogTargetId"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblemDescr"))
if mibBuilder.loadTexts: tmnxSysLogTargetProblem.setStatus('current')
if mibBuilder.loadTexts: tmnxSysLogTargetProblem.setDescription('A tmnxSysLogTargetProblem notification is generated when a problem is encountered when trying to deliver data to the syslog destination identfied by the tmnxSysLogTargetId.')
tmnxLogAccountingDataLoss = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 10)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdRolloverTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdRetainTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogNotifyApInterval"))
if mibBuilder.loadTexts: tmnxLogAccountingDataLoss.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAccountingDataLoss.setDescription('A tmnxLogAccountingDataLoss notification is generated when an accounting file is still being written to when the next interval ends. The collection of statistics for the past interval is immediately stopped and collection is started for the next interval. There are missing records in the file for this past interval.')
tmnxStdEventsReplayed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 11)).setObjects(("TIMETRA-LOG-MIB", "tmnxStdDestAddrType"), ("TIMETRA-LOG-MIB", "tmnxStdDestAddr"), ("TIMETRA-LOG-MIB", "tmnxStdReplayStartEvent"), ("TIMETRA-LOG-MIB", "tmnxStdReplayEndEvent"), ("TIMETRA-LOG-MIB", "tmnxStdReplayStart"))
if mibBuilder.loadTexts: tmnxStdEventsReplayed.setStatus('current')
if mibBuilder.loadTexts: tmnxStdEventsReplayed.setDescription('A tmnxStdEventsReplayed notification is generated when an SNMP trap target address is added to the RTM (tmnxVRtrID) following a period when the address had been removed. The value of tmnxStdReplayStartEvent is the SNMP notification request ID of the first event that was replayed. The value of tmnxStdReplayEndEvent is the SNMP notification request ID of the last missed event that was replayed. The value of tmnxStdReplayStart is the request ID of the first event for which there was no route to the trap target address.')
tmnxLogEventOverrun = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 12, 0, 12)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogThrottledEventID"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEvents"))
if mibBuilder.loadTexts: tmnxLogEventOverrun.setStatus('current')
if mibBuilder.loadTexts: tmnxLogEventOverrun.setDescription("[CAUSE] A tmnxLogEventOverrun notification is generated at the end of the overrun throttling interval when one or more events of the type specified by tmnxLogThrottledEventID were dropped because the logger input stream's input queue limit was exceeded. The overrun throttling interval begins when the input queue limit is first exceeded and ends when the number of events in the input queue has dropped below an internal low watermark. At that point a tmnxLogEventOverrun notification is generated for each event type that had one or more events dropped because of the input queue overrun. The number of dropped events is specified by tmnxLogThrottledEvents. [EFFECT] Logger events have been dropped and were not sent to any log destination. tmnxEventDropCount has been incremented for each event dropped because of input queue overrun. [RECOVERY] The specific event information of dropped events cannot be recovered. The frequency of input queue overruns can be lessened by configuring as few event logs as possible, especially those going to remote destinations such as file, syslog and snmp notification logs.")
tmnxLogCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1))
tmnxLogGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2))
tmnxLogV4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 4)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV4v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogGroup"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsR2r1Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationR3r0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV4v0Compliance = tmnxLogV4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV4v0Compliance.setDescription('The compliance statement for revision 4.0 of TIMETRA-LOG-MIB.')
tmnxLogV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 5)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV5v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV5v0Compliance = tmnxLogV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV5v0Compliance.setDescription('The compliance statement for revision 5.0 of TIMETRA-LOG-MIB.')
tmnxLogV6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 6)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV6v0Compliance = tmnxLogV6v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV6v0Compliance.setDescription('The compliance statement for revision 6.0 of TIMETRA-LOG-MIB.')
tmnxLogV6v1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 7)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV6v1Compliance = tmnxLogV6v1Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxLogV6v1Compliance.setDescription('The compliance statement for revision 6.1 of TIMETRA-LOG-MIB.')
tmnxLogV7v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 8)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyV6v1Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyCRV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogRoutePreferenceV7v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV7v0Compliance = tmnxLogV7v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV7v0Compliance.setDescription('The compliance statement for revision 7.0 of TIMETRA-LOG-MIB.')
tmnxLogV9v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 9)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyV6v1Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyCRV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV9v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogRoutePreferenceV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogEventDampedV8v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogApV9v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV9v0Compliance = tmnxLogV9v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV9v0Compliance.setDescription('The compliance statement for revision 9.0 of TIMETRA-LOG-MIB.')
tmnxLogV8v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 10)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyV6v1Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyCRV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogRoutePreferenceV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogEventDampedV8v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV8v0Compliance = tmnxLogV8v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV8v0Compliance.setDescription('The compliance statement for revision 7.0 of TIMETRA-LOG-MIB.')
tmnxLogV10v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 1, 11)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogGlobalGroup"), ("TIMETRA-LOG-MIB", "tmnxLogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyGroup"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyV6v1Group"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingPolicyCRV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdGroup"), ("TIMETRA-LOG-MIB", "tmnxLogSyslogV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpTrapDestV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsGroup"), ("TIMETRA-LOG-MIB", "tmnxLogEventsV5v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV6v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogNotificationV9v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogRoutePreferenceV7v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogEventDampedV8v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogApV9v0Group"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpGroup"), ("TIMETRA-LOG-MIB", "tmnxLogApExtGroup"), ("TIMETRA-LOG-MIB", "tmnxLogAppRouteNotifV10v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV10v0Compliance = tmnxLogV10v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxLogV10v0Compliance.setDescription('The compliance statement for revision 10.0 of TIMETRA-LOG-MIB.')
tmnxLogGlobalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 1)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogMaxLogs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogGlobalGroup = tmnxLogGlobalGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLogGlobalGroup.setDescription('The group of objects supporting management of event logging capabilities on Alcatel-Lucent SROS series systems.')
tmnxLogAccountingPolicyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 3)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogApRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogApStorageType"), ("TIMETRA-LOG-MIB", "tmnxLogApAdminStatus"), ("TIMETRA-LOG-MIB", "tmnxLogApOperStatus"), ("TIMETRA-LOG-MIB", "tmnxLogApInterval"), ("TIMETRA-LOG-MIB", "tmnxLogApDescription"), ("TIMETRA-LOG-MIB", "tmnxLogApDefault"), ("TIMETRA-LOG-MIB", "tmnxLogApRecord"), ("TIMETRA-LOG-MIB", "tmnxLogApToFileId"), ("TIMETRA-LOG-MIB", "tmnxLogApPortType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogAccountingPolicyGroup = tmnxLogAccountingPolicyGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAccountingPolicyGroup.setDescription('The group of objects supporting management of accounting policies capabilities on Alcatel-Lucent SROS series systems.')
tmnxLogFileIdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 4)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileIdRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdStorageType"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdRolloverTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdRetainTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdAdminLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdOperLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdDescription"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdPathName"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdCreateTime"), ("TIMETRA-LOG-MIB", "tmnxLogFileIdBackupLoc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogFileIdGroup = tmnxLogFileIdGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLogFileIdGroup.setDescription('The group of objects supporting management of Log File destinations on Alcatel-Lucent SROS series systems.')
tmnxLogSyslogGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 5)).setObjects(("TIMETRA-LOG-MIB", "tmnxSyslogTargetRowStatus"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetDescription"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetAddress"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetUdpPort"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetFacility"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetSeverity"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetMessagePrefix"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetMessagesDropped"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogSyslogGroup = tmnxLogSyslogGroup.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogSyslogGroup.setDescription('The group of objects supporting management of Log Syslog destinations on Alcatel-Lucent SROS series systems.')
tmnxSnmpTrapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 6)).setObjects(("TIMETRA-LOG-MIB", "tmnxStgRowStatus"), ("TIMETRA-LOG-MIB", "tmnxStgDescription"), ("TIMETRA-LOG-MIB", "tmnxStgVersion"), ("TIMETRA-LOG-MIB", "tmnxStgNotifyCommunity"), ("TIMETRA-LOG-MIB", "tmnxStgSecurityLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSnmpTrapGroup = tmnxSnmpTrapGroup.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxSnmpTrapGroup.setDescription('The group of objects supporting management of Log SNMP notification destinations on Alcatel-Lucent SROS series systems.')
tmnxLogEventsR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 10)).setObjects(("TIMETRA-LOG-MIB", "tmnxEventAppName"), ("TIMETRA-LOG-MIB", "tmnxEventName"), ("TIMETRA-LOG-MIB", "tmnxEventSeverity"), ("TIMETRA-LOG-MIB", "tmnxEventControl"), ("TIMETRA-LOG-MIB", "tmnxEventCounter"), ("TIMETRA-LOG-MIB", "tmnxEventDropCount"), ("TIMETRA-LOG-MIB", "tmnxEventReset"), ("TIMETRA-LOG-MIB", "tmnxEventTest"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogEventsR2r1Group = tmnxLogEventsR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogEventsR2r1Group.setDescription('The group of objects supporting management of Log Events on Alcatel-Lucent SROS series systems release 2.1.')
tmnxLogNotifyObjsR3r0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 13)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedFileId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedName"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedCreateTime"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorTitle"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotifyObjsR3r0Group = tmnxLogNotifyObjsR3r0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogNotifyObjsR3r0Group.setDescription('The group of objects supporting management of Log notifications on Alcatel-Lucent SROS series systems.')
tmnxLogNotificationR3r0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 14)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogSpaceContention"), ("TIMETRA-LOG-MIB", "tmnxLogAdminLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogBackupLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogFileRollover"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeleted"), ("TIMETRA-LOG-MIB", "tmnxTestEvent"), ("TIMETRA-LOG-MIB", "tmnxLogTraceError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotificationR3r0Group = tmnxLogNotificationR3r0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogNotificationR3r0Group.setDescription('The group of notifications supporting the Log feature on Alcatel-Lucent SROS series systems release 3.0.')
tmnxLogV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 15)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogIdRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdStorageType"), ("TIMETRA-LOG-MIB", "tmnxLogIdAdminStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdOperStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdDescription"), ("TIMETRA-LOG-MIB", "tmnxLogIdFilterId"), ("TIMETRA-LOG-MIB", "tmnxLogIdSource"), ("TIMETRA-LOG-MIB", "tmnxLogIdDestination"), ("TIMETRA-LOG-MIB", "tmnxLogIdFileId"), ("TIMETRA-LOG-MIB", "tmnxLogIdSyslogId"), ("TIMETRA-LOG-MIB", "tmnxLogIdMaxMemorySize"), ("TIMETRA-LOG-MIB", "tmnxLogIdConsoleSession"), ("TIMETRA-LOG-MIB", "tmnxLogIdForwarded"), ("TIMETRA-LOG-MIB", "tmnxLogIdDropped"), ("TIMETRA-LOG-MIB", "tmnxLogIdTimeFormat"), ("TIMETRA-LOG-MIB", "tmnxLogFilterRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogFilterDescription"), ("TIMETRA-LOG-MIB", "tmnxLogFilterDefaultAction"), ("TIMETRA-LOG-MIB", "tmnxLogFilterInUse"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsDescription"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsAction"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsApplication"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsApplOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsNumber"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsNumberOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSeverity"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSeverityOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubject"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubjectOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubjectRegexp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV4v0Group = tmnxLogV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogV4v0Group.setDescription('The group of objects supporting management of event logs on Alcatel-Lucent SROS series systems.')
tmnxSnmpSetErrsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 16)).setObjects(("TIMETRA-LOG-MIB", "tmnxSnmpSetErrsMax"), ("TIMETRA-LOG-MIB", "tmnxSseVersion"), ("TIMETRA-LOG-MIB", "tmnxSseSeverityLevel"), ("TIMETRA-LOG-MIB", "tmnxSseModuleId"), ("TIMETRA-LOG-MIB", "tmnxSseModuleName"), ("TIMETRA-LOG-MIB", "tmnxSseErrorCode"), ("TIMETRA-LOG-MIB", "tmnxSseErrorName"), ("TIMETRA-LOG-MIB", "tmnxSseErrorMsg"), ("TIMETRA-LOG-MIB", "tmnxSseExtraText"), ("TIMETRA-LOG-MIB", "tmnxSseTimestamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSnmpSetErrsGroup = tmnxSnmpSetErrsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpSetErrsGroup.setDescription('The group of objects supporting management of SNMP SET failure error messages.')
tmnxLogEventsV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 17)).setObjects(("TIMETRA-LOG-MIB", "tmnxEventAppName"), ("TIMETRA-LOG-MIB", "tmnxEventName"), ("TIMETRA-LOG-MIB", "tmnxEventSeverity"), ("TIMETRA-LOG-MIB", "tmnxEventControl"), ("TIMETRA-LOG-MIB", "tmnxEventCounter"), ("TIMETRA-LOG-MIB", "tmnxEventDropCount"), ("TIMETRA-LOG-MIB", "tmnxEventReset"), ("TIMETRA-LOG-MIB", "tmnxEventThrottle"), ("TIMETRA-LOG-MIB", "tmnxEventTest"), ("TIMETRA-LOG-MIB", "tmnxEventThrottleLimit"), ("TIMETRA-LOG-MIB", "tmnxEventThrottleInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogEventsV5v0Group = tmnxLogEventsV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogEventsV5v0Group.setDescription('The group of objects supporting management of Log Events on Alcatel-Lucent SROS series systems release 5.0.')
tmnxLogNotifyObjsV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 18)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedFileId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedName"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedCreateTime"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorTitle"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorMessage"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEventID"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEvents"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetId"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblemDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotifyObjsV5v0Group = tmnxLogNotifyObjsV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogNotifyObjsV5v0Group.setDescription('The group of objects supporting management of Log notifications on Alcatel-Lucentx SROS series systems release 5.0.')
tmnxLogNotificationV5v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 19)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogSpaceContention"), ("TIMETRA-LOG-MIB", "tmnxLogAdminLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogBackupLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogFileRollover"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeleted"), ("TIMETRA-LOG-MIB", "tmnxTestEvent"), ("TIMETRA-LOG-MIB", "tmnxLogTraceError"), ("TIMETRA-LOG-MIB", "tmnxLogEventThrottled"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblem"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotificationV5v0Group = tmnxLogNotificationV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogNotificationV5v0Group.setDescription('The group of notifications supporting the Log feature on Alcatel-Lucent SROS series systems release 5.0.')
tmnxLogSyslogV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 20)).setObjects(("TIMETRA-LOG-MIB", "tmnxSyslogTargetRowStatus"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetDescription"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetUdpPort"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetFacility"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetSeverity"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetMessagePrefix"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetMessagesDropped"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetAddrType"), ("TIMETRA-LOG-MIB", "tmnxSyslogTargetAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogSyslogV5v0Group = tmnxLogSyslogV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogSyslogV5v0Group.setDescription('The group of objects supporting management of Log Syslog destinations on Alcatel-Lucent SROS series systems release 5.0.')
tmnxSnmpTrapV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 21)).setObjects(("TIMETRA-LOG-MIB", "tmnxSnmpTrapLogDescription"), ("TIMETRA-LOG-MIB", "tmnxStdRowStatus"), ("TIMETRA-LOG-MIB", "tmnxStdRowLastChanged"), ("TIMETRA-LOG-MIB", "tmnxStdDestAddrType"), ("TIMETRA-LOG-MIB", "tmnxStdDestAddr"), ("TIMETRA-LOG-MIB", "tmnxStdDestPort"), ("TIMETRA-LOG-MIB", "tmnxStdDescription"), ("TIMETRA-LOG-MIB", "tmnxStdVersion"), ("TIMETRA-LOG-MIB", "tmnxStdNotifyCommunity"), ("TIMETRA-LOG-MIB", "tmnxStdSecurityLevel"), ("TIMETRA-LOG-MIB", "tmnxStdMaxTargets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSnmpTrapV5v0Group = tmnxSnmpTrapV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapV5v0Group.setDescription('The group of objects supporting management of Log SNMP notification destinations on Alcatel-Lucent SROS series systems for release 5.0.')
tmnxLogV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 22)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogIdRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdStorageType"), ("TIMETRA-LOG-MIB", "tmnxLogIdAdminStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdOperStatus"), ("TIMETRA-LOG-MIB", "tmnxLogIdDescription"), ("TIMETRA-LOG-MIB", "tmnxLogIdFilterId"), ("TIMETRA-LOG-MIB", "tmnxLogIdSource"), ("TIMETRA-LOG-MIB", "tmnxLogIdDestination"), ("TIMETRA-LOG-MIB", "tmnxLogIdFileId"), ("TIMETRA-LOG-MIB", "tmnxLogIdSyslogId"), ("TIMETRA-LOG-MIB", "tmnxLogIdMaxMemorySize"), ("TIMETRA-LOG-MIB", "tmnxLogIdConsoleSession"), ("TIMETRA-LOG-MIB", "tmnxLogIdForwarded"), ("TIMETRA-LOG-MIB", "tmnxLogIdDropped"), ("TIMETRA-LOG-MIB", "tmnxLogIdTimeFormat"), ("TIMETRA-LOG-MIB", "tmnxLogFilterRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogFilterDescription"), ("TIMETRA-LOG-MIB", "tmnxLogFilterDefaultAction"), ("TIMETRA-LOG-MIB", "tmnxLogFilterInUse"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsDescription"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsAction"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsApplication"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsApplOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsNumber"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsNumberOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSeverity"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSeverityOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubject"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubjectOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsSubjectRegexp"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsRouter"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsRouterOperator"), ("TIMETRA-LOG-MIB", "tmnxLogFilterParamsRouterRegexp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogV5v0Group = tmnxLogV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogV5v0Group.setDescription('The group of objects supporting management of event logs on Alcatel-Lucent SROS series systems in release 5.0.')
tmnxLogObsoleteObjsV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 23)).setObjects(("TIMETRA-LOG-MIB", "tmnxSyslogTargetAddress"), ("TIMETRA-LOG-MIB", "tmnxStgRowStatus"), ("TIMETRA-LOG-MIB", "tmnxStgDescription"), ("TIMETRA-LOG-MIB", "tmnxStgVersion"), ("TIMETRA-LOG-MIB", "tmnxStgNotifyCommunity"), ("TIMETRA-LOG-MIB", "tmnxStgSecurityLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogObsoleteObjsV5v0Group = tmnxLogObsoleteObjsV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogObsoleteObjsV5v0Group.setDescription('The group of objects supporting management of TiMOS logs obsoleted on Alcatel-Lucent SROS series systems in release 5.0.')
tmnxLogNotifyObjsV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 24)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedFileId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedName"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedCreateTime"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorTitle"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorMessage"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEventID"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEvents"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetId"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblemDescr"), ("TIMETRA-LOG-MIB", "tmnxLogNotifyApInterval"), ("TIMETRA-LOG-MIB", "tmnxStdReplayStartEvent"), ("TIMETRA-LOG-MIB", "tmnxStdReplayEndEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotifyObjsV6v0Group = tmnxLogNotifyObjsV6v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxLogNotifyObjsV6v0Group.setDescription('The group of objects supporting management of Log notifications on Alcatel-Lucent SROS series systems release 6.0.')
tmnxLogNotificationV6v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 25)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogSpaceContention"), ("TIMETRA-LOG-MIB", "tmnxLogAdminLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogBackupLocFailed"), ("TIMETRA-LOG-MIB", "tmnxLogFileRollover"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeleted"), ("TIMETRA-LOG-MIB", "tmnxTestEvent"), ("TIMETRA-LOG-MIB", "tmnxLogTraceError"), ("TIMETRA-LOG-MIB", "tmnxLogEventThrottled"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblem"), ("TIMETRA-LOG-MIB", "tmnxLogAccountingDataLoss"), ("TIMETRA-LOG-MIB", "tmnxStdEventsReplayed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotificationV6v0Group = tmnxLogNotificationV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogNotificationV6v0Group.setDescription('The group of notifications supporting the Log feature on Alcatel-Lucent SROS series systems release 6.0.')
tmnxSnmpTrapDestV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 26)).setObjects(("TIMETRA-LOG-MIB", "tmnxStdReplay"), ("TIMETRA-LOG-MIB", "tmnxStdReplayStart"), ("TIMETRA-LOG-MIB", "tmnxStdReplayLastTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSnmpTrapDestV6v0Group = tmnxSnmpTrapDestV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSnmpTrapDestV6v0Group.setDescription('The group of objects added to support SNMP trap destinations in the Alcatel-Lucent SROS series systems release 6.0.')
tmnxLogAccountingPolicyV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 27)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogApDefaultInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogAccountingPolicyV6v1Group = tmnxLogAccountingPolicyV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAccountingPolicyV6v1Group.setDescription('The group of objects supporting management of accounting policies capabilities on Alcatel-Lucent SROS series systems release 6.1.')
tmnxLogAccountingPolicyCRV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 28)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogApCrLastChanged"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeDelta"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeQueue"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeOCntr"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeQICounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeQECounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeOICounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeOECounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrSignChangeAACounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrAACounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrQueueRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogApCrQueueLastChanged"), ("TIMETRA-LOG-MIB", "tmnxLogApCrQueueICounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrQueueECounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrOverrideCntrRowStatus"), ("TIMETRA-LOG-MIB", "tmnxLogApCrOverrideCntrLastChngd"), ("TIMETRA-LOG-MIB", "tmnxLogApCrOverrideCntrICounters"), ("TIMETRA-LOG-MIB", "tmnxLogApCrOverrideCntrECounters"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogAccountingPolicyCRV7v0Group = tmnxLogAccountingPolicyCRV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAccountingPolicyCRV7v0Group.setDescription('The group of objects supporting the creation of a custom record inside a accounting policy on Alcatel-Lucent SROS series systems.')
tmnxLogRoutePreferenceV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 29)).setObjects(("TIMETRA-LOG-MIB", "tmnxEventPrimaryRoutePref"), ("TIMETRA-LOG-MIB", "tmnxEventSecondaryRoutePref"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogRoutePreferenceV7v0Group = tmnxLogRoutePreferenceV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogRoutePreferenceV7v0Group.setDescription('The group of objects supporting routing preferences of Log Events on Alcatel-Lucent SROS series systems release 7.0.')
tmnxLogNotifyObjsV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 30)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedFileId"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLogType"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedLocation"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedName"), ("TIMETRA-LOG-MIB", "tmnxLogFileDeletedCreateTime"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorTitle"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorSubject"), ("TIMETRA-LOG-MIB", "tmnxLogTraceErrorMessage"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEventID"), ("TIMETRA-LOG-MIB", "tmnxLogThrottledEvents"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetId"), ("TIMETRA-LOG-MIB", "tmnxSysLogTargetProblemDescr"), ("TIMETRA-LOG-MIB", "tmnxLogNotifyApInterval"), ("TIMETRA-LOG-MIB", "tmnxStdReplayStartEvent"), ("TIMETRA-LOG-MIB", "tmnxStdReplayEndEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotifyObjsV8v0Group = tmnxLogNotifyObjsV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogNotifyObjsV8v0Group.setDescription('The group of objects supporting management of Log notifications on Alcatel-Lucent SROS series systems release 8.0.')
tmnxLogNotificationV9v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 31)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogEventOverrun"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotificationV9v0Group = tmnxLogNotificationV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogNotificationV9v0Group.setDescription('The group of notifications supporting the Log feature on Alcatel SROS series systems added in release 9.0.')
tmnxLogEventDampedV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 32)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogConfigEventsDamped"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogEventDampedV8v0Group = tmnxLogEventDampedV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogEventDampedV8v0Group.setDescription('The group of objects supporting damping of change events on Alcatel-Lucent SROS series systems added in release 8.0r7.')
tmnxLogApV9v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 33)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogApDataLossCount"), ("TIMETRA-LOG-MIB", "tmnxLogApLastDataLossTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogApV9v0Group = tmnxLogApV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApV9v0Group.setDescription('The group of objects extending the application log table on Alcatel-Lucent SROS series systems added in release 9.0.')
tmnxLogExRbkOpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 34)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogExRbkOpTblLastChange"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpMaxEntries"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpLastChanged"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpType"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpStatus"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpBegin"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpEnd"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpFile"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpUser"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkOpNumEvents"), ("TIMETRA-LOG-MIB", "tmnxLogExRbkEventOID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogExRbkOpGroup = tmnxLogExRbkOpGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLogExRbkOpGroup.setDescription('The group of objects managing exec and rollback revert event history.')
tmnxLogNotifyObjsV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 35)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogExecRollbackOpIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogNotifyObjsV10v0Group = tmnxLogNotifyObjsV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogNotifyObjsV10v0Group.setDescription('The group of accessible-for-notify objects added to Alcatel-Lucent SROS series systems release 10.0.')
tmnxLogApExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 36)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogApToFileType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogApExtGroup = tmnxLogApExtGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxLogApExtGroup.setDescription('The group of objects extending the accounting policy table on Alcatel-Lucent SROS series systems.')
tmnxLogAppRouteNotifV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 12, 2, 37)).setObjects(("TIMETRA-LOG-MIB", "tmnxLogColdStartWaitTime"), ("TIMETRA-LOG-MIB", "tmnxLogRouteRecoveryWaitTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxLogAppRouteNotifV10v0Group = tmnxLogAppRouteNotifV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxLogAppRouteNotifV10v0Group.setDescription('The group of objects supporting notifications on completion of wait time after cold reboot and route recovery on Alcatel-Lucent SROS series systems release 10.0.')
mibBuilder.exportSymbols("TIMETRA-LOG-MIB", TmnxSyslogId=TmnxSyslogId, tmnxSseAddress=tmnxSseAddress, tmnxLogFileIdCreateTime=tmnxLogFileIdCreateTime, tmnxLogFilterParamsRouter=tmnxLogFilterParamsRouter, tmnxSyslogTargetAddress=tmnxSyslogTargetAddress, tmnxStdIndex=tmnxStdIndex, tmnxSyslogTargetMessagePrefix=tmnxSyslogTargetMessagePrefix, tmnxLogEventHistoryObjs=tmnxLogEventHistoryObjs, tmnxLogExRbkOpFile=tmnxLogExRbkOpFile, tmnxLogFileDeletedFileId=tmnxLogFileDeletedFileId, tmnxLogAccountingDataLoss=tmnxLogAccountingDataLoss, tmnxLogV5v0Compliance=tmnxLogV5v0Compliance, tmnxLogIdTimeFormat=tmnxLogIdTimeFormat, tmnxLogNotifyObjsV5v0Group=tmnxLogNotifyObjsV5v0Group, tmnxEventAppIndex=tmnxEventAppIndex, tmnxStdReplay=tmnxStdReplay, tmnxLogFileIdBackupLoc=tmnxLogFileIdBackupLoc, tmnxSnmpTrapGroupTable=tmnxSnmpTrapGroupTable, tmnxEventSecondaryRoutePref=tmnxEventSecondaryRoutePref, tmnxLogFilterParamsAction=tmnxLogFilterParamsAction, tmnxLogApDescription=tmnxLogApDescription, tmnxLogApCustRecordQueueTable=tmnxLogApCustRecordQueueTable, tmnxLogExRbkNotifyObjects=tmnxLogExRbkNotifyObjects, tmnxLogNotifications=tmnxLogNotifications, TmnxSyslogFacility=TmnxSyslogFacility, tmnxLogIdIndex=tmnxLogIdIndex, tmnxLogApCrOverrideCntrRowStatus=tmnxLogApCrOverrideCntrRowStatus, tmnxLogNotificationV9v0Group=tmnxLogNotificationV9v0Group, tmnxLogExRbkOpMaxEntries=tmnxLogExRbkOpMaxEntries, tmnxLogApDefaultInterval=tmnxLogApDefaultInterval, tmnxLogFilterParamsEntry=tmnxLogFilterParamsEntry, tmnxEventAppTable=tmnxEventAppTable, tmnxLogConformance=tmnxLogConformance, TmnxUdpPort=TmnxUdpPort, tmnxTestEvent=tmnxTestEvent, tmnxLogApPolicyId=tmnxLogApPolicyId, TmnxCFlash=TmnxCFlash, tmnxStdDestPort=tmnxStdDestPort, tmnxLogApCrOverrideCntrECounters=tmnxLogApCrOverrideCntrECounters, tmnxLogFilterParamsNumber=tmnxLogFilterParamsNumber, tmnxSseAddressType=tmnxSseAddressType, tmnxLogFileIdPathName=tmnxLogFileIdPathName, tmnxLogFilterDescription=tmnxLogFilterDescription, tmnxLogExecRollbackOpIndex=tmnxLogExecRollbackOpIndex, tmnxLogApToFileType=tmnxLogApToFileType, tmnxLogAdminLocFailed=tmnxLogAdminLocFailed, tmnxLogApV9v0Group=tmnxLogApV9v0Group, tmnxSseErrorName=tmnxSseErrorName, tmnxLogIdDropped=tmnxLogIdDropped, tmnxLogApCrAACounters=tmnxLogApCrAACounters, tmnxLogNotifyObjsR3r0Group=tmnxLogNotifyObjsR3r0Group, tmnxSyslogTargetAddrType=tmnxSyslogTargetAddrType, tmnxLogApCrQueueRowStatus=tmnxLogApCrQueueRowStatus, tmnxLogApCrSignChangeOICounters=tmnxLogApCrSignChangeOICounters, tmnxLogEventsV5v0Group=tmnxLogEventsV5v0Group, tmnxLogIdSyslogId=tmnxLogIdSyslogId, tmnxLogApCrSignChangeQICounters=tmnxLogApCrSignChangeQICounters, tmnxLogV10v0Compliance=tmnxLogV10v0Compliance, tmnxLogIdStorageType=tmnxLogIdStorageType, tmnxEventAppName=tmnxEventAppName, tmnxLogFileDeletedName=tmnxLogFileDeletedName, TmnxLogFileId=TmnxLogFileId, tmnxLogFileIdRetainTime=tmnxLogFileIdRetainTime, tmnxLogIdFileId=tmnxLogIdFileId, tmnxLogFilterParamsSeverity=tmnxLogFilterParamsSeverity, tmnxStgSecurityLevel=tmnxStgSecurityLevel, tmnxSnmpTrapGroupEntry=tmnxSnmpTrapGroupEntry, tmnxLogGroups=tmnxLogGroups, tmnxSseSeverityLevel=tmnxSseSeverityLevel, tmnxStgDestAddress=tmnxStgDestAddress, tmnxSnmpSetErrsMax=tmnxSnmpSetErrsMax, tmnxLogV4v0Compliance=tmnxLogV4v0Compliance, tmnxLogIdDestination=tmnxLogIdDestination, tmnxStdReplayStart=tmnxStdReplayStart, TmnxLogFileType=TmnxLogFileType, tmnxSyslogTargetAddr=tmnxSyslogTargetAddr, tmnxSnmpTrapLogEntry=tmnxSnmpTrapLogEntry, tmnxLogExRbkOpBegin=tmnxLogExRbkOpBegin, tmnxLogEventThrottled=tmnxLogEventThrottled, tmnxLogNotifyObjsV8v0Group=tmnxLogNotifyObjsV8v0Group, tmnxSyslogTargetMessagesDropped=tmnxSyslogTargetMessagesDropped, tmnxStdEventsReplayed=tmnxStdEventsReplayed, tmnxLogFileDeleted=tmnxLogFileDeleted, tmnxLogExRbkOpIndex=tmnxLogExRbkOpIndex, tmnxStgDestPort=tmnxStgDestPort, tmnxSseErrorMsg=tmnxSseErrorMsg, tmnxLogThrottledEventID=tmnxLogThrottledEventID, tmnxStgRowStatus=tmnxStgRowStatus, tmnxSseExtraText=tmnxSseExtraText, tmnxLogFilterParamsSubjectRegexp=tmnxLogFilterParamsSubjectRegexp, tmnxSyslogTargetIndex=tmnxSyslogTargetIndex, tmnxLogFilterParamsRouterOperator=tmnxLogFilterParamsRouterOperator, tmnxLogExRbkEventIndex=tmnxLogExRbkEventIndex, tmnxSyslogTargetDescription=tmnxSyslogTargetDescription, tmnxLogV4v0Group=tmnxLogV4v0Group, tmnxLogApOperStatus=tmnxLogApOperStatus, tmnxLogExRbkOpStatus=tmnxLogExRbkOpStatus, tmnxLogFilterParamsTable=tmnxLogFilterParamsTable, tmnxLogSpaceContention=tmnxLogSpaceContention, tmnxLogApPortType=tmnxLogApPortType, tmnxLogFileIdLogType=tmnxLogFileIdLogType, tmnxLogApStorageType=tmnxLogApStorageType, tmnxLogColdStartWaitTime=tmnxLogColdStartWaitTime, tmnxSnmpTrapLogTable=tmnxSnmpTrapLogTable, tmnxStgNotifyCommunity=tmnxStgNotifyCommunity, tmnxLogFilterParamsApplOperator=tmnxLogFilterParamsApplOperator, tmnxSseErrorCode=tmnxSseErrorCode, tmnxLogNotificationObjects=tmnxLogNotificationObjects, tmnxLogTraceErrorSubject=tmnxLogTraceErrorSubject, tmnxLogFilterParamsNumberOperator=tmnxLogFilterParamsNumberOperator, tmnxLogIdFilterId=tmnxLogIdFilterId, tmnxLogApAdminStatus=tmnxLogApAdminStatus, tmnxLogFileIdGroup=tmnxLogFileIdGroup, tmnxLogAccountingPolicyV6v1Group=tmnxLogAccountingPolicyV6v1Group, tmnxLogExRbkEventOID=tmnxLogExRbkEventOID, tmnxLogApCrOverrideCntrTable=tmnxLogApCrOverrideCntrTable, tmnxSnmpTrapLogDescription=tmnxSnmpTrapLogDescription, tmnxStdRowStatus=tmnxStdRowStatus, tmnxLogApCrSignChangeOCntr=tmnxLogApCrSignChangeOCntr, tmnxLogIdAdminStatus=tmnxLogIdAdminStatus, tmnxLogEventHistGeneralObjs=tmnxLogEventHistGeneralObjs, tmnxLogEventsR2r1Group=tmnxLogEventsR2r1Group, tmnxSseModuleId=tmnxSseModuleId, tmnxLogApCrQueueLastChanged=tmnxLogApCrQueueLastChanged, tmnxLogFilterInUse=tmnxLogFilterInUse, tmnxLogFilterParamsRouterRegexp=tmnxLogFilterParamsRouterRegexp, tmnxLogBackupLocFailed=tmnxLogBackupLocFailed, tmnxLogFilterParamsRowStatus=tmnxLogFilterParamsRowStatus, tmnxLogApCrQueueId=tmnxLogApCrQueueId, tmnxLogTraceError=tmnxLogTraceError, tmnxLogNotifyObjsV6v0Group=tmnxLogNotifyObjsV6v0Group, tmnxLogEventDampedV8v0Group=tmnxLogEventDampedV8v0Group, tmnxLogExRbkOpNumEvents=tmnxLogExRbkOpNumEvents, tmnxEventPrimaryRoutePref=tmnxEventPrimaryRoutePref, tmnxSyslogTargetRowStatus=tmnxSyslogTargetRowStatus, tmnxLogV8v0Compliance=tmnxLogV8v0Compliance, tmnxEventEntry=tmnxEventEntry, tmnxSnmpSetErrsEntry=tmnxSnmpSetErrsEntry, tmnxLogIdEntry=tmnxLogIdEntry, tmnxLogFilterParamsDescription=tmnxLogFilterParamsDescription, tmnxLogApLastDataLossTimeStamp=tmnxLogApLastDataLossTimeStamp, tmnxLogFilterRowStatus=tmnxLogFilterRowStatus, tmnxLogV6v1Compliance=tmnxLogV6v1Compliance, tmnxLogApCrOverrideCntrLastChngd=tmnxLogApCrOverrideCntrLastChngd, tmnxEventCounter=tmnxEventCounter, tmnxLogIdOperStatus=tmnxLogIdOperStatus, tmnxLogFilterTable=tmnxLogFilterTable, tmnxStgVersion=tmnxStgVersion, tmnxLogFileRollover=tmnxLogFileRollover, tmnxStdReplayLastTime=tmnxStdReplayLastTime, tmnxLogNotifyObjsV10v0Group=tmnxLogNotifyObjsV10v0Group, tmnxStdDestAddrType=tmnxStdDestAddrType, TmnxLogFilterEntryId=TmnxLogFilterEntryId, tmnxSseModuleName=tmnxSseModuleName, tmnxSysLogTargetId=tmnxSysLogTargetId, tmnxLogFilterEntry=tmnxLogFilterEntry, tmnxLogFilterParamsIndex=tmnxLogFilterParamsIndex, tmnxStdDescription=tmnxStdDescription, tmnxSysLogTargetProblemDescr=tmnxSysLogTargetProblemDescr, tmnxLogV9v0Compliance=tmnxLogV9v0Compliance, tmnxLogApCrSignChangeDelta=tmnxLogApCrSignChangeDelta, TmnxLogFilterOperator=TmnxLogFilterOperator, TmnxSyslogSeverity=TmnxSyslogSeverity, tmnxStgIndex=tmnxStgIndex, tmnxStdSecurityLevel=tmnxStdSecurityLevel, tmnxSyslogTargetSeverity=tmnxSyslogTargetSeverity, tmnxStdReplayEndEvent=tmnxStdReplayEndEvent, tmnxLogApCrSignChangeQueue=tmnxLogApCrSignChangeQueue, tmnxLogFileIdLogId=tmnxLogFileIdLogId, tmnxLogObjs=tmnxLogObjs, tmnxLogApCrSignChangeAACounters=tmnxLogApCrSignChangeAACounters, tmnxSyslogTargetFacility=tmnxSyslogTargetFacility, tmnxLogFileIdStorageType=tmnxLogFileIdStorageType, tmnxEventID=tmnxEventID, tmnxLogApRecord=tmnxLogApRecord, tmnxSseVersion=tmnxSseVersion, tmnxSseTimestamp=tmnxSseTimestamp, tmnxLogApCrLastChanged=tmnxLogApCrLastChanged, tmnxLogApCrOverrideCntrId=tmnxLogApCrOverrideCntrId, tmnxLogTraceErrorTitle=tmnxLogTraceErrorTitle, tmnxLogNotificationV5v0Group=tmnxLogNotificationV5v0Group, tmnxLogFileIdRowStatus=tmnxLogFileIdRowStatus, tmnxLogApExtGroup=tmnxLogApExtGroup, tmnxLogApTable=tmnxLogApTable, TmnxLogIdIndex=TmnxLogIdIndex, tmnxSnmpTrapDestV6v0Group=tmnxSnmpTrapDestV6v0Group, tmnxLogFileDeletedCreateTime=tmnxLogFileDeletedCreateTime, tmnxLogSyslogV5v0Group=tmnxLogSyslogV5v0Group, tmnxSyslogTargetEntry=tmnxSyslogTargetEntry, tmnxSnmpTrapV5v0Group=tmnxSnmpTrapV5v0Group, tmnxEventSeverity=tmnxEventSeverity, TmnxLogFilterId=TmnxLogFilterId, tmnxLogFileIdRolloverTime=tmnxLogFileIdRolloverTime, tmnxLogExRbkOpLastChanged=tmnxLogExRbkOpLastChanged, tmnxLogApCustRecordTable=tmnxLogApCustRecordTable, tmnxLogEventOverrun=tmnxLogEventOverrun, tmnxSnmpTrapDestEntry=tmnxSnmpTrapDestEntry, tmnxSyslogTargetUdpPort=tmnxSyslogTargetUdpPort, tmnxLogV7v0Compliance=tmnxLogV7v0Compliance, tmnxLogApInterval=tmnxLogApInterval, tmnxLogApCrQueueICounters=tmnxLogApCrQueueICounters, tmnxStdReplayStartEvent=tmnxStdReplayStartEvent, TmnxEventNumber=TmnxEventNumber, tmnxLogIdSource=tmnxLogIdSource, tmnxEventControl=tmnxEventControl, tmnxLogFileIdTable=tmnxLogFileIdTable, tmnxLogRouteRecoveryWaitTime=tmnxLogRouteRecoveryWaitTime, tmnxLogAppRouteNotifV10v0Group=tmnxLogAppRouteNotifV10v0Group, tmnxEventThrottle=tmnxEventThrottle, tmnxSnmpTrapGroup=tmnxSnmpTrapGroup, tmnxLogMaxLogs=tmnxLogMaxLogs, tmnxStdDestAddr=tmnxStdDestAddr, tmnxLogApCustRecordEntry=tmnxLogApCustRecordEntry, tmnxLogFileIdDescription=tmnxLogFileIdDescription, tmnxLogFilterDefaultAction=tmnxLogFilterDefaultAction, tmnxSnmpSetErrsGroup=tmnxSnmpSetErrsGroup, tmnxLogFilterId=tmnxLogFilterId, tmnxLogExRbkOpEnd=tmnxLogExRbkOpEnd, tmnxEventTable=tmnxEventTable, tmnxLogExecRollbackOpEntry=tmnxLogExecRollbackOpEntry, tmnxLogIdRowStatus=tmnxLogIdRowStatus, tmnxStdMaxTargets=tmnxStdMaxTargets, tmnxLogApCrSignChangeQECounters=tmnxLogApCrSignChangeQECounters, tmnxLogApCrSignChangeOECounters=tmnxLogApCrSignChangeOECounters, tmnxLogApCustRecordQueueEntry=tmnxLogApCustRecordQueueEntry, tmnxLogV6v0Compliance=tmnxLogV6v0Compliance, tmnxLogApToFileId=tmnxLogApToFileId, tmnxLogNotifyApInterval=tmnxLogNotifyApInterval, tmnxLogAccountingPolicyGroup=tmnxLogAccountingPolicyGroup, tmnxLogFileId=tmnxLogFileId, tmnxLogApCrOverrideCntrEntry=tmnxLogApCrOverrideCntrEntry, tmnxLogFileDeletedLogId=tmnxLogFileDeletedLogId, tmnxLogRoutePreferenceV7v0Group=tmnxLogRoutePreferenceV7v0Group, tmnxLogIdDescription=tmnxLogIdDescription, tmnxEventName=tmnxEventName, tmnxLogV5v0Group=tmnxLogV5v0Group, tmnxEventThrottleInterval=tmnxEventThrottleInterval, tmnxEventAppEntry=tmnxEventAppEntry, tmnxStgDescription=tmnxStgDescription, tmnxSseRequestId=tmnxSseRequestId, tmnxLogFilterParamsSubject=tmnxLogFilterParamsSubject, tmnxEventReset=tmnxEventReset, timetraLogMIBModule=timetraLogMIBModule, tmnxLogFilterParamsSubjectOperator=tmnxLogFilterParamsSubjectOperator, tmnxLogExecRollbackEventTable=tmnxLogExecRollbackEventTable, tmnxStdNotifyCommunity=tmnxStdNotifyCommunity, tmnxLogFilterParamsSeverityOperator=tmnxLogFilterParamsSeverityOperator, tmnxStdRowLastChanged=tmnxStdRowLastChanged, tmnxStdVersion=tmnxStdVersion, tmnxLogApCrOverrideCntrICounters=tmnxLogApCrOverrideCntrICounters, tmnxLogExRbkOpType=tmnxLogExRbkOpType, tmnxLogAccountingPolicyCRV7v0Group=tmnxLogAccountingPolicyCRV7v0Group, tmnxLogFileIdAdminLocation=tmnxLogFileIdAdminLocation, tmnxLogIdConsoleSession=tmnxLogIdConsoleSession)
mibBuilder.exportSymbols("TIMETRA-LOG-MIB", tmnxLogApCrQueueECounters=tmnxLogApCrQueueECounters, tmnxLogGlobalGroup=tmnxLogGlobalGroup, TmnxSyslogIdOrEmpty=TmnxSyslogIdOrEmpty, tmnxLogExRbkOpTblLastChange=tmnxLogExRbkOpTblLastChange, tmnxLogExRbkOpUser=tmnxLogExRbkOpUser, tmnxStdName=tmnxStdName, tmnxLogFileDeletedLocation=tmnxLogFileDeletedLocation, tmnxLogIdTable=tmnxLogIdTable, tmnxEventTest=tmnxEventTest, tmnxLogExRbkOpGroup=tmnxLogExRbkOpGroup, tmnxLogFileIdOperLocation=tmnxLogFileIdOperLocation, tmnxLogApDataLossCount=tmnxLogApDataLossCount, tmnxLogNotificationR3r0Group=tmnxLogNotificationR3r0Group, tmnxLogNotificationV6v0Group=tmnxLogNotificationV6v0Group, tmnxLogSyslogGroup=tmnxLogSyslogGroup, tmnxLogConfigEventsDamped=tmnxLogConfigEventsDamped, tmnxLogApDefault=tmnxLogApDefault, TmnxPerceivedSeverity=TmnxPerceivedSeverity, tmnxSseSnmpPort=tmnxSseSnmpPort, tmnxLogExecRollbackOpTable=tmnxLogExecRollbackOpTable, tmnxLogApRowStatus=tmnxLogApRowStatus, tmnxSyslogTargetTable=tmnxSyslogTargetTable, tmnxLogFileDeletedLogType=tmnxLogFileDeletedLogType, tmnxLogFilterParamsApplication=tmnxLogFilterParamsApplication, tmnxLogObsoleteObjsV5v0Group=tmnxLogObsoleteObjsV5v0Group, tmnxLogExecRollbackEventEntry=tmnxLogExecRollbackEventEntry, tmnxLogNotifyPrefix=tmnxLogNotifyPrefix, tmnxLogFileIdEntry=tmnxLogFileIdEntry, tmnxEventDropCount=tmnxEventDropCount, tmnxLogApEntry=tmnxLogApEntry, tmnxLogThrottledEvents=tmnxLogThrottledEvents, tmnxSysLogTargetProblem=tmnxSysLogTargetProblem, tmnxLogCompliances=tmnxLogCompliances, tmnxEventThrottleLimit=tmnxEventThrottleLimit, PYSNMP_MODULE_ID=timetraLogMIBModule, tmnxLogTraceErrorMessage=tmnxLogTraceErrorMessage, tmnxLogIdForwarded=tmnxLogIdForwarded, tmnxSnmpTrapDestTable=tmnxSnmpTrapDestTable, tmnxLogIdMaxMemorySize=tmnxLogIdMaxMemorySize, tmnxSnmpSetErrsTable=tmnxSnmpSetErrsTable)

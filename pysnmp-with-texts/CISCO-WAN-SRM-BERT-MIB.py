#
# PySNMP MIB module CISCO-WAN-SRM-BERT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-SRM-BERT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
axisDiagnostics, = mibBuilder.importSymbols("BASIS-MIB", "axisDiagnostics")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
TimeTicks, ModuleIdentity, Bits, MibIdentifier, Gauge32, Counter64, ObjectIdentity, Integer32, Counter32, Unsigned32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ModuleIdentity", "Bits", "MibIdentifier", "Gauge32", "Counter64", "ObjectIdentity", "Integer32", "Counter32", "Unsigned32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ciscoWanSrmBertMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 31))
ciscoWanSrmBertMIB.setRevisions(('2002-08-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanSrmBertMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanSrmBertMIB.setLastUpdated('200208260000Z')
if mibBuilder.loadTexts: ciscoWanSrmBertMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanSrmBertMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanSrmBertMIB.setDescription('The MIB Module for BERT(Bit Error Rate Testing) using Service Resource Module(SRM). This MIB module is used for BERT on FRSM, AUSM, CESM, VISM modules. This module contains information on results from BERT tests using DDS(Digital Data Service) pattern.')
bert = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 6, 1))
bertControl = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("acquireBert", 1), ("releaseBert", 2), ("cnfBert", 3), ("startBert", 4), ("modBert", 5), ("delBert", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertControl.setStatus('current')
if mibBuilder.loadTexts: bertControl.setDescription('This object controls all the SET operations on this MIB group. acquireBert : Acquire BERT resources. cnfBert : Configure the required BERT test. startBert : The configured test has to be started. modBert : Modify parameters for the ongoing BERT test. delBert : Running BERT test has to be stopped. The above list shows the sequence in which the SET operations on this group need to be done, ideally. Bert can be operated upon only with bertUserId and bertSlotNumber. The default value is 0, means no action.')
bertResourceStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("free", 1), ("inUse", 2), ("cleanupPending", 3))).clone('free')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertResourceStatus.setStatus('current')
if mibBuilder.loadTexts: bertResourceStatus.setDescription('All of bert resources can be used by only one user at a time. This gives the status of the resources.')
bertOwner = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertOwner.setStatus('current')
if mibBuilder.loadTexts: bertOwner.setDescription('This refers to the user who owns the BERT resources. If the user is a CLI user, then this is username. If it is SNMP Manager(For example Cisco Wan Manager), then this would be the IP address. For example, this value can be, 192.9.209.157 within quotes.')
bertUserId = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertUserId.setStatus('current')
if mibBuilder.loadTexts: bertUserId.setDescription('This identifies the user who wants to do a SET operation on this group. This will be compared against bertOwner and access will be given only if it matches. Hence, for every SET request, this object should have a valid value. If the user is a CLI user, then this is username. If it is SNMP Manager, then this would be the IP address. For example, this value can be, 192.9.209.157 within quotes. Required for bert operations.')
bertStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("inactive", 1), ("bertInSync", 2), ("bertOutOfSync", 3), ("searchingDDSCommands", 4), ("farEndInLoop", 5), ("facilityInLoop", 6), ("portFacilityFifoFault", 7), ("portFacilityFifoOutOfSync", 8), ("metallicInLoop", 9), ("bertFailed", 10))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStatus.setStatus('current')
if mibBuilder.loadTexts: bertStatus.setDescription('This variable provides the status of BERT in the shelf.')
bertSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertSlotNumber.setStatus('current')
if mibBuilder.loadTexts: bertSlotNumber.setDescription('specifies the physical slot number of the Service Module which is to run BERT For MGX 8220, the range is 5-14. For MGX 8850, the range is 1-6, 9-14, 17-22, 25-30. Required for bert operations.')
bertTestMedium = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port", 1), ("line", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertTestMedium.setStatus('current')
if mibBuilder.loadTexts: bertTestMedium.setDescription('specifies whether the bert is to test a port or an entire T1/E1 line. No default value for this, it has to be set if bert is configured.')
bertPort = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertPort.setStatus('current')
if mibBuilder.loadTexts: bertPort.setDescription('specifies the port number for BERT.')
bertLine = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLine.setStatus('current')
if mibBuilder.loadTexts: bertLine.setDescription('specifies the line number for BERT. If the test medium is port, this represents the line to which the port belongs.')
bertMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bertPatternTest", 1), ("ddsSeek", 2), ("loopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertMode.setStatus('current')
if mibBuilder.loadTexts: bertMode.setDescription('specifies the mode, the BERT module is to be configured for.')
bertDeviceToLoop = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLatchOCUwith1", 1), ("noLatchOCUwitout1", 2), ("noLatchCSU", 3), ("noLatchDSU", 4), ("latchDS0Drop", 5), ("latchDS0Line", 6), ("latchOCU", 7), ("latchCSU", 8), ("latchDSU", 9), ("latchHL96", 10), ("v54Polynomial", 11), ("inband", 12), ("esf", 13), ("metallic", 14), ("noDevice", 15), ("smartJackInband", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertDeviceToLoop.setStatus('current')
if mibBuilder.loadTexts: bertDeviceToLoop.setDescription('This shows the type of the end device and the type of the loopback used (latching/nonlatching/polynomial).')
bertDS0DPIterationCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertDS0DPIterationCount.setStatus('current')
if mibBuilder.loadTexts: bertDS0DPIterationCount.setDescription('The Iteration Register needs to be programmed in SRM when DSO drop loop option is selected in bertDeviceToLoop. The value to be programmed there is minus one of this object value, since the register is 0 based. DSP-OP devices can be cross connected in the centeral office. By this, the user has capablitiy to put any of the devices in the chain in loopback mode. This is done by repeating the latching activation code in a specific manner. The binary number in the iterataion register determines how many times the first portion of a latching loop activation code needs to be repeated as per user request and according to the Bellcore spec. A value of 0 results in no iteration and will cause the very first device in chain to go into loop back. A value of 1 will result into one iteration and will cause the second device to go into loopback and so on. The range of this count is 1 to 32, and it would translate to a range of 0 to 31 for the iteration register.')
bertPattern = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("allZeros", 1), ("allOnes", 2), ("alternateONeZero", 3), ("doubleOneZero", 4), ("fifteenBit", 5), ("twentyBit", 6), ("twentyBitQRSS", 7), ("twentythreeBit", 8), ("oneInEight", 9), ("threeIntwentyfour", 10), ("dds-1", 11), ("dds-2", 12), ("dds-3", 13), ("dds-4", 14), ("dds-5", 15), ("nineBit", 16), ("elevenBit", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertPattern.setStatus('current')
if mibBuilder.loadTexts: bertPattern.setDescription('This variable determines BERT pattern to be transmitted.')
bertLoopback = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("farEndLoopback", 1), ("facilityLoopback", 2), ("metallicLoopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLoopback.setStatus('current')
if mibBuilder.loadTexts: bertLoopback.setDescription('specifies the type of loopback to be (d)established.')
bertLoopbackOperation = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopUp", 1), ("loopDown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLoopbackOperation.setStatus('current')
if mibBuilder.loadTexts: bertLoopbackOperation.setDescription('specifies the operation of loopback (up or down).')
bertDS0Speed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("speed56k", 1), ("speed64k", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDS0Speed.setStatus('current')
if mibBuilder.loadTexts: bertDS0Speed.setDescription('represents the ds0 speed of the test running.')
bertTimeSlots = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertTimeSlots.setStatus('current')
if mibBuilder.loadTexts: bertTimeSlots.setDescription('represents the number of ds0s in the test medium chosen.')
bertStartTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStartTime.setStatus('current')
if mibBuilder.loadTexts: bertStartTime.setDescription('The syntax is hh:mm:ss The time zone is as configured in the shelf.')
bertStartDate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStartDate.setStatus('current')
if mibBuilder.loadTexts: bertStartDate.setDescription('On MGX 8220, the syntax is mm/dd/yy On MGX 8850, the syntax is mm/dd/yyyy.')
bertBitCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertBitCount.setStatus('current')
if mibBuilder.loadTexts: bertBitCount.setDescription('This shows the number of bits transmitted.')
bertBitErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertBitErrorCount.setStatus('current')
if mibBuilder.loadTexts: bertBitErrorCount.setDescription('This shows the number of bits received in error.')
bertErrorInjectCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertErrorInjectCount.setStatus('current')
if mibBuilder.loadTexts: bertErrorInjectCount.setDescription('This shows the number of times error was injected.')
bertCleanupAction = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("noAction", 1), ("smCleanup", 2), ("latchDS0DropLoopdown", 3), ("latchDS0LineLoopdown", 4), ("latchOCULoopdown", 5), ("latchCSULoopdown", 6), ("latchDSULoopdown", 7), ("latchHL96Loopdown", 8), ("v54PolynomialLoopdown", 9), ("inbandLoopdown", 10), ("esfLoopdown", 11), ("facilityLoopdown", 12), ("metallicLoopdown", 13), ("smartJackInbandLoopdown", 14))).clone('noAction')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertCleanupAction.setStatus('current')
if mibBuilder.loadTexts: bertCleanupAction.setDescription('When the BERT has to be stopped or aborted (due to card state changes), this object would give the exact action to take. The bert related changes to the shelf, then, can be cleaned up. When its value is a Loopdown, it implies smCleanup plus the corresponding Loopdown.')
bertAbortReason = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ascStateChange", 1), ("smStateChange", 2), ("srmStateChange", 3), ("coreCardSwitch", 4), ("smRedundancySwitch", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertAbortReason.setStatus('current')
if mibBuilder.loadTexts: bertAbortReason.setDescription('when the BERT is aborted, this object would give the reason for that.')
bertDDSSeekResultsTableFirstIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableFirstIndex.setStatus('current')
if mibBuilder.loadTexts: bertDDSSeekResultsTableFirstIndex.setDescription('Denotes the index of the oldest entry in the table. A value of zero means that there are no entries in the table.')
bertDDSSeekResultsTableLastIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableLastIndex.setStatus('current')
if mibBuilder.loadTexts: bertDDSSeekResultsTableLastIndex.setDescription('Denotes the index of the latest entry in the table. A value of zero means that there are no entries in the table.')
bertDDSSeekResultsTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27), )
if mibBuilder.loadTexts: bertDDSSeekResultsTable.setStatus('current')
if mibBuilder.loadTexts: bertDDSSeekResultsTable.setDescription('This table contains all available DDS patterns detected and latched by an interaface(lines,ports etc) configured to detect DDS patterns.')
bertDDSSeekResultsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1), ).setIndexNames((0, "CISCO-WAN-SRM-BERT-MIB", "bertDDSSeekResultsTableIndex"))
if mibBuilder.loadTexts: bertDDSSeekResultsTableEntry.setStatus('current')
if mibBuilder.loadTexts: bertDDSSeekResultsTableEntry.setDescription('An entry in the detected DDS codes table.')
bertDDSSeekResultsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableIndex.setStatus('current')
if mibBuilder.loadTexts: bertDDSSeekResultsTableIndex.setDescription('Denotes the serial number of the entry in the table.')
bertDDSCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(30, 10, 40, 44, 90, 126, 86, 114, 26, 42, 120, 28, 108, 58, 24, 50))).clone(namedValues=NamedValues(("abnormalStationCondition", 30), ("block", 10), ("channelLoopback", 40), ("dsuLoopback", 44), ("farEndVoice", 90), ("idle", 126), ("loopbackEnable", 86), ("mjuAlert", 114), ("muxOutOfSync", 26), ("ocuLoopback", 42), ("release", 120), ("test", 28), ("testAlert", 108), ("transitionInProgress", 58), ("unassignedMuxChannel", 24), ("unnamed", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSCode.setStatus('current')
if mibBuilder.loadTexts: bertDDSCode.setDescription('Denotes the type of DDS code detected.')
bertSupportedTestsTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28), )
if mibBuilder.loadTexts: bertSupportedTestsTable.setStatus('current')
if mibBuilder.loadTexts: bertSupportedTestsTable.setDescription('A list of supported tests for a given SM.')
bertSupportedTestsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1), ).setIndexNames((0, "CISCO-WAN-SRM-BERT-MIB", "bertSupportedTestsTableIndex"))
if mibBuilder.loadTexts: bertSupportedTestsTableEntry.setStatus('current')
if mibBuilder.loadTexts: bertSupportedTestsTableEntry.setDescription('A general supported tests entry.')
bertSupportedTestsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertSupportedTestsTableIndex.setStatus('current')
if mibBuilder.loadTexts: bertSupportedTestsTableIndex.setDescription('This index is the physical slot number of the Service Module whose entry it represents in the table. For MGX 8220, the range is 5-14. For MGX 8850, the range is 1-6, 9-14, 17-22, 25-30.')
bertSupportFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertSupportFlag.setStatus('current')
if mibBuilder.loadTexts: bertSupportFlag.setDescription("'yes' if the table entry correctly represents the supported tests for the SM on the corresponding slot. 'no' if no tests at all are supported.")
bertTestMediumMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertTestMediumMask.setStatus('current')
if mibBuilder.loadTexts: bertTestMediumMask.setDescription('Every test medium is represented by a bit of mask. Bits 0-1 are valid in this integer. The meaning of the mask can be understood from the example below: -------------------------- TestMedium | SM | support -------------------------- port | 1 line | 1 -------------------------- (Table contents applicable to FRSM-4T1) bertTestMediumMask = 11 binary The column titles represent the variables bertTestMedium depends on. The mask is represented in column major order.')
bertModeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertModeMask.setStatus('current')
if mibBuilder.loadTexts: bertModeMask.setDescription('Every mode is represented by 2 bits of mask. Bits 0-5 are valid in this integer. The meaning of the mask can be understood from the example below: ----------------------------------------------------------- Mode | SM support | Test Medium: | | Multiple | | T1 time slots ----------------------------------------------------------- Pattern test | 1 | 1 DDS seek | 1 | 0 Loopback | 1 | 1 ----------------------------------------------------------- (Table contents applicable to FRSM-4T1) bertModeMask = 101111 binary The column titles represent the variables bertMode depends on. The mask is represented in column major order.')
bertDeviceToLoopMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDeviceToLoopMask.setStatus('current')
if mibBuilder.loadTexts: bertDeviceToLoopMask.setDescription("Every class of devices to loop is represented by 6 bits of mask. Bits 0-29 are valid in this integer. The meaning of the mask can be understood from the example below: ----------------------------------------------------------- | | | Test Medium Class of | SM | MODE |________________________________ devices |supp | Loopback|Line |multiple T1 | 64k | 56k | | | | time slots | | ----------------------------------------------------------- noLatch | 1 0 0 0 0 1 latch | 1 1 0 0 1 1 v54 | 1 1 0 1 1 1 inband/esf| 1 1 1 0 0 0 metallic | 1 0 1 0 0 0 ----------------------------------------------------------- (Table contents applicable to FRSM-4T1) bertDeviceToLoopMask = 001110011000100110000111011111 binary The column titles represent the variables bertDeviceToLoop depends on. The mask is represented in column major order. Due to the limitation on the length of the mask, 'noDevice' option is not represented in this mask. But, the mask for it, is assumed to be a row of ones except for a zero on 'MODE Loopback' column.")
bertPatternMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertPatternMask.setStatus('current')
if mibBuilder.loadTexts: bertPatternMask.setDescription('Every class of patterns is represented by 2 bits of mask. Bits 0-3 are valid in this integer. The meaning of the mask can be understood from the example below: ---------------------------------------------- Class of | SM | Non latching patterns | support |device to loop ---------------------------------------------- Other patterns | 1 | 0 ---------------------------------------------- Patterns | 1 | 1 power 9 and 11 | | ---------------------------------------------- (Table contents applicable to FRSM-4T1) bertPatternMask = 1011 binary The column titles represent the variables bertPattern depends on. The mask is represented in column major order.')
bertLoopbackMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertLoopbackMask.setStatus('current')
if mibBuilder.loadTexts: bertLoopbackMask.setDescription('Every loopback is represented by 2 bits of mask. Bits 0-5 are valid in this integer. The meaning of the mask can be understood from the example below: ---------------------------------------------- Loopback | SM | Test Medium | support | Port ---------------------------------------------- Far End Loopback | 1 | 1 Facility Loopback | 1 | 1 Metallic Loopback | 1 | 0 ---------------------------------------------- (Table contents applicable to FRSM-4T1) bertLoopbackMask = 011111 binary The column titles represent the variables bertLoopback depends on. The mask is represented in column major order.')
bertCardT1E1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1", 1), ("e1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertCardT1E1Type.setStatus('current')
if mibBuilder.loadTexts: bertCardT1E1Type.setDescription('Specifies whether a t1 or e1 card.')
ciscoWanSrmBertMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 31, 2))
ciscoWanSrmBertMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 1))
ciscoWanSrmBertMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 2))
ciscoWanSrmBertCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 2, 1)).setObjects(("CISCO-WAN-SRM-BERT-MIB", "ciscoWanSrmBertConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanSrmBertCompliance = ciscoWanSrmBertCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoWanSrmBertCompliance.setDescription('The compliance statement for objects related to Bert MIB.')
ciscoWanSrmBertConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 1, 1)).setObjects(("CISCO-WAN-SRM-BERT-MIB", "bertControl"), ("CISCO-WAN-SRM-BERT-MIB", "bertResourceStatus"), ("CISCO-WAN-SRM-BERT-MIB", "bertOwner"), ("CISCO-WAN-SRM-BERT-MIB", "bertUserId"), ("CISCO-WAN-SRM-BERT-MIB", "bertStatus"), ("CISCO-WAN-SRM-BERT-MIB", "bertSlotNumber"), ("CISCO-WAN-SRM-BERT-MIB", "bertTestMedium"), ("CISCO-WAN-SRM-BERT-MIB", "bertPort"), ("CISCO-WAN-SRM-BERT-MIB", "bertLine"), ("CISCO-WAN-SRM-BERT-MIB", "bertMode"), ("CISCO-WAN-SRM-BERT-MIB", "bertDeviceToLoop"), ("CISCO-WAN-SRM-BERT-MIB", "bertDS0DPIterationCount"), ("CISCO-WAN-SRM-BERT-MIB", "bertPattern"), ("CISCO-WAN-SRM-BERT-MIB", "bertLoopback"), ("CISCO-WAN-SRM-BERT-MIB", "bertLoopbackOperation"), ("CISCO-WAN-SRM-BERT-MIB", "bertDS0Speed"), ("CISCO-WAN-SRM-BERT-MIB", "bertTimeSlots"), ("CISCO-WAN-SRM-BERT-MIB", "bertStartTime"), ("CISCO-WAN-SRM-BERT-MIB", "bertStartDate"), ("CISCO-WAN-SRM-BERT-MIB", "bertBitCount"), ("CISCO-WAN-SRM-BERT-MIB", "bertBitErrorCount"), ("CISCO-WAN-SRM-BERT-MIB", "bertErrorInjectCount"), ("CISCO-WAN-SRM-BERT-MIB", "bertCleanupAction"), ("CISCO-WAN-SRM-BERT-MIB", "bertAbortReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanSrmBertConfGroup = ciscoWanSrmBertConfGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanSrmBertConfGroup.setDescription('The collection of objects which are used for configuring/running BERT on Service modules using SRM module.')
ciscoWanSrmBertTestResultsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 1, 2)).setObjects(("CISCO-WAN-SRM-BERT-MIB", "bertSupportedTestsTableIndex"), ("CISCO-WAN-SRM-BERT-MIB", "bertSupportFlag"), ("CISCO-WAN-SRM-BERT-MIB", "bertTestMediumMask"), ("CISCO-WAN-SRM-BERT-MIB", "bertModeMask"), ("CISCO-WAN-SRM-BERT-MIB", "bertDeviceToLoopMask"), ("CISCO-WAN-SRM-BERT-MIB", "bertPatternMask"), ("CISCO-WAN-SRM-BERT-MIB", "bertLoopbackMask"), ("CISCO-WAN-SRM-BERT-MIB", "bertCardT1E1Type"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanSrmBertTestResultsGroup = ciscoWanSrmBertTestResultsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanSrmBertTestResultsGroup.setDescription('The collection of objects which are used for finding the results of running BERT tests.')
ciscoWanSrmBertDDSResultsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 31, 2, 1, 3)).setObjects(("CISCO-WAN-SRM-BERT-MIB", "bertDDSSeekResultsTableFirstIndex"), ("CISCO-WAN-SRM-BERT-MIB", "bertDDSSeekResultsTableLastIndex"), ("CISCO-WAN-SRM-BERT-MIB", "bertDDSSeekResultsTableIndex"), ("CISCO-WAN-SRM-BERT-MIB", "bertDDSCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanSrmBertDDSResultsGroup = ciscoWanSrmBertDDSResultsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanSrmBertDDSResultsGroup.setDescription('The collection of objects which are used for finding the results of running BERT tests using DDS pattern.')
mibBuilder.exportSymbols("CISCO-WAN-SRM-BERT-MIB", ciscoWanSrmBertMIB=ciscoWanSrmBertMIB, bertLoopbackOperation=bertLoopbackOperation, bertDDSSeekResultsTableLastIndex=bertDDSSeekResultsTableLastIndex, bertDeviceToLoopMask=bertDeviceToLoopMask, ciscoWanSrmBertMIBGroups=ciscoWanSrmBertMIBGroups, bertCardT1E1Type=bertCardT1E1Type, bertSlotNumber=bertSlotNumber, bertSupportFlag=bertSupportFlag, bertErrorInjectCount=bertErrorInjectCount, bertLoopbackMask=bertLoopbackMask, bertTimeSlots=bertTimeSlots, ciscoWanSrmBertTestResultsGroup=ciscoWanSrmBertTestResultsGroup, bertModeMask=bertModeMask, bertDeviceToLoop=bertDeviceToLoop, ciscoWanSrmBertCompliance=ciscoWanSrmBertCompliance, bertUserId=bertUserId, bertResourceStatus=bertResourceStatus, bert=bert, ciscoWanSrmBertDDSResultsGroup=ciscoWanSrmBertDDSResultsGroup, bertLoopback=bertLoopback, bertStartTime=bertStartTime, ciscoWanSrmBertConfGroup=ciscoWanSrmBertConfGroup, bertOwner=bertOwner, bertSupportedTestsTable=bertSupportedTestsTable, bertAbortReason=bertAbortReason, bertTestMediumMask=bertTestMediumMask, bertPort=bertPort, bertBitErrorCount=bertBitErrorCount, ciscoWanSrmBertMIBConformance=ciscoWanSrmBertMIBConformance, bertDDSSeekResultsTableEntry=bertDDSSeekResultsTableEntry, bertLine=bertLine, bertBitCount=bertBitCount, bertPattern=bertPattern, bertTestMedium=bertTestMedium, bertCleanupAction=bertCleanupAction, bertStatus=bertStatus, bertDDSCode=bertDDSCode, ciscoWanSrmBertMIBCompliances=ciscoWanSrmBertMIBCompliances, bertSupportedTestsTableEntry=bertSupportedTestsTableEntry, bertPatternMask=bertPatternMask, bertDDSSeekResultsTableIndex=bertDDSSeekResultsTableIndex, bertControl=bertControl, bertSupportedTestsTableIndex=bertSupportedTestsTableIndex, bertMode=bertMode, bertDDSSeekResultsTable=bertDDSSeekResultsTable, bertDS0DPIterationCount=bertDS0DPIterationCount, bertStartDate=bertStartDate, bertDS0Speed=bertDS0Speed, PYSNMP_MODULE_ID=ciscoWanSrmBertMIB, bertDDSSeekResultsTableFirstIndex=bertDDSSeekResultsTableFirstIndex)

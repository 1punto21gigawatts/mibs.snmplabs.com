#
# PySNMP MIB module RFC1285-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RFC1285-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:56:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, TimeTicks, Unsigned32, MibIdentifier, transmission, ObjectIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Counter64, NotificationType, iso, IpAddress, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "Unsigned32", "MibIdentifier", "transmission", "ObjectIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Counter64", "NotificationType", "iso", "IpAddress", "ModuleIdentity", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
fddi = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15))
class FddiTime(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class FddiResourceId(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class FddiSMTStationIdType(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class FddiMACLongAddressType(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

snmpFddiSMT = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 1))
snmpFddiMAC = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 2))
snmpFddiPATH = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 3))
snmpFddiPORT = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 4))
snmpFddiATTACHMENT = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 5))
snmpFddiChipSets = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 6))
snmpFddiSMTNumber = MibScalar((1, 3, 6, 1, 2, 1, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTNumber.setDescription("The number of SMT implementations (regardless of their current state) on this network management application entity. The value for this variable must remain constant at least from one re- initialization of the entity's network management system to the next re-initialization.")
snmpFddiSMTTable = MibTable((1, 3, 6, 1, 2, 1, 10, 15, 1, 2), )
if mibBuilder.loadTexts: snmpFddiSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTTable.setDescription('A list of SMT entries. The number of entries is given by the value of snmpFddiSMTNumber.')
snmpFddiSMTEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1), ).setIndexNames((0, "RFC1285-MIB", "snmpFddiSMTIndex"))
if mibBuilder.loadTexts: snmpFddiSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTEntry.setDescription('An SMT entry containing information common to a given SMT.')
snmpFddiSMTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTIndex.setDescription("A unique value for each SMT. Its value ranges between 1 and the value of snmpFddiSMTNumber. The value for each SMT must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiSMTStationId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 2), FddiSMTStationIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTStationId.setReference('ANSI { fddiSMT 11 }')
if mibBuilder.loadTexts: snmpFddiSMTStationId.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTStationId.setDescription('Uniquely identifies an FDDI station.')
snmpFddiSMTOpVersionId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiSMTOpVersionId.setReference('ANSI { fddiSMT 13 }')
if mibBuilder.loadTexts: snmpFddiSMTOpVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTOpVersionId.setDescription('The version that this station is using for its operation (refer to ANSI 7.1.2.2).')
snmpFddiSMTHiVersionId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTHiVersionId.setReference('ANSI { fddiSMT 14 }')
if mibBuilder.loadTexts: snmpFddiSMTHiVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTHiVersionId.setDescription('The highest version of SMT that this station supports (refer to ANSI 7.1.2.2).')
snmpFddiSMTLoVersionId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTLoVersionId.setReference('ANSI { fddiSMT 15 }')
if mibBuilder.loadTexts: snmpFddiSMTLoVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTLoVersionId.setDescription('The lowest version of SMT that this station supports (refer to ANSI 7.1.2.2).')
snmpFddiSMTMACCt = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTMACCt.setReference('ANSI { fddiSMT 21 }')
if mibBuilder.loadTexts: snmpFddiSMTMACCt.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTMACCt.setDescription('The number of MACs in the station or concentrator.')
snmpFddiSMTNonMasterCt = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTNonMasterCt.setReference('ANSI { fddiSMT 22 }')
if mibBuilder.loadTexts: snmpFddiSMTNonMasterCt.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTNonMasterCt.setDescription('The number of Non Master PORTs (A, B, or S PORTs) in the station or concentrator.')
snmpFddiSMTMasterCt = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTMasterCt.setReference('ANSI { fddiSMT 23 }')
if mibBuilder.loadTexts: snmpFddiSMTMasterCt.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTMasterCt.setDescription('The number of Master PORTs in a node. If the node is not a concentrator, the value is zero.')
snmpFddiSMTPathsAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTPathsAvailable.setReference('ANSI { fddiSMT 24 }')
if mibBuilder.loadTexts: snmpFddiSMTPathsAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTPathsAvailable.setDescription('A value that indicates the PATH types available in the station. The value is a sum. This value initially takes the value zero, then for each type of PATH that this node has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 For example, a station having Primary and Local PATHs available would have a value of 5 (2**0 + 2**2).')
snmpFddiSMTConfigCapabilities = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTConfigCapabilities.setReference('ANSI { fddiSMT 25 }')
if mibBuilder.loadTexts: snmpFddiSMTConfigCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTConfigCapabilities.setDescription("A value that indicates capabilities that are present in the node. If 'holdAvailable' is present, this indicates support of the optional Hold Function (refer to ANSI SMT 9.4.3.2). If 'CF-Wrap-AB' is present, this indicates that the WRAP_AB state is forced. The value is a sum. This value initially takes the value zero, then for each of the configuration policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power holdAvailable 0 CF-Wrap-AB 1 ")
snmpFddiSMTConfigPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiSMTConfigPolicy.setReference('ANSI { fddiSMT 26 }')
if mibBuilder.loadTexts: snmpFddiSMTConfigPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTConfigPolicy.setDescription("A value that indicates the configuration policies currently enforced in the node (refer to ANSI SMT 9.4.3.2). The 'configurationHold' policy refers to the Hold flag, and should not be present only if the Hold function is supported. The 'CF-Wrap- AB' policy refers to the CF_Wrap_AB flag. The value is a sum. This value initially takes the value zero, then for each of the configuration policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power configurationHold 0 CF-Wrap-AB 1 ")
snmpFddiSMTConnectionPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiSMTConnectionPolicy.setReference('ANSI { fddiSMT 27 }')
if mibBuilder.loadTexts: snmpFddiSMTConnectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTConnectionPolicy.setDescription("A value that indicates the connection policies enforced at the station. A station sets the corresponding policy for each of the connection types that it rejects. The letter designations, X and Y, in the 'rejectX-Y' names have the following significance: X represents the PC-Type of the local PORT and Y represents a PC-Neighbor in the evaluation of Connection-Policy (PC-Type, PC- Neighbor) that is done to determine the setting of T-Val(3) in the PC-Signaling sequence (refer to ANSI Section 9.6.3). The value is a sum. This value initially takes the value zero, then for each of the connection policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power rejectA-A 0 rejectA-B 1 rejectA-S 2 rejectA-M 3 rejectB-A 4 rejectB-B 5 rejectB-S 6 rejectB-M 7 rejectS-A 8 rejectS-B 9 rejectS-S 10 rejectS-M 11 rejectM-A 12 rejectM-B 13 rejectM-S 14 rejectM-M 15 Implementors should note that the polarity of these bits is different in different places in an SMT system. Implementors should take appropriate care.")
snmpFddiSMTTNotify = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiSMTTNotify.setReference('ANSI { fddiSMT 29 }')
if mibBuilder.loadTexts: snmpFddiSMTTNotify.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTTNotify.setDescription('The timer used in the Neighbor Notification protocol, reported in seconds and ranging from 2 to 30 seconds (refer to ANSI SMT 8.3.1).')
snmpFddiSMTStatusReporting = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTStatusReporting.setReference('ANSI { fddiSMT 30 }')
if mibBuilder.loadTexts: snmpFddiSMTStatusReporting.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTStatusReporting.setDescription('Indicates whether the node implements the Status Reporting Protocol. This object is included for compatibility with products that were designed prior to the adoption of this standard.')
snmpFddiSMTECMState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ec0", 1), ("ec1", 2), ("ec2", 3), ("ec3", 4), ("ec4", 5), ("ec5", 6), ("ec6", 7), ("ec7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTECMState.setReference('ANSI { fddiSMT 41 }')
if mibBuilder.loadTexts: snmpFddiSMTECMState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTECMState.setDescription('Indicates the current state of the ECM state machine (refer to ANSI SMT 9.5.2).')
snmpFddiSMTCFState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("cf0", 1), ("cf1", 2), ("cf2", 3), ("cf3", 4), ("cf4", 5), ("cf5", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTCFState.setReference('ANSI { fddiSMT 42 }')
if mibBuilder.loadTexts: snmpFddiSMTCFState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTCFState.setDescription('The attachment configuration for the station or concentrator (refer to ANSI SMT 9.7.4.3).')
snmpFddiSMTHoldState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-implemented", 1), ("not-holding", 2), ("holding-prm", 3), ("holding-sec", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTHoldState.setReference('ANSI { fddiSMT 43 }')
if mibBuilder.loadTexts: snmpFddiSMTHoldState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTHoldState.setDescription("This value indicates the current state of the Hold function. The values are determined as follows: 'holding-prm' is set if the primary ring is operational and the Recovery Enable Flag is clear (NOT NO_Flag(primary) AND NOT RE_Flag). is set if the secondary ring is operational and the Recovery Enable Flag is clear (NOT NO_Flag(secondary) AND NOT RE_Flag). Ref 9.4.3. and 10.3.1. the primary or secondary, i.e., the Recovery Enable, RE_Flag, is set.")
snmpFddiSMTRemoteDisconnectFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiSMTRemoteDisconnectFlag.setReference('ANSI { fddiSMT 44 }')
if mibBuilder.loadTexts: snmpFddiSMTRemoteDisconnectFlag.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTRemoteDisconnectFlag.setDescription('A flag indicating that the station was remotely disconnected from the network. A station requires a Connect Action (SM_CM_CONNECT.request (Connect)) to rejoin and clear the flag (refer to ANSI 6.4.5.2).')
snmpFddiSMTStationAction = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("connect", 2), ("disconnect", 3), ("path-Test", 4), ("self-Test", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiSMTStationAction.setReference('ANSI { fddiSMT 60 }')
if mibBuilder.loadTexts: snmpFddiSMTStationAction.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiSMTStationAction.setDescription('This object, when read, always returns a value of other(1). The behavior of setting this variable to each of the acceptable values is as follows: Other: Results in a badValue error. Connect: Generates an SM_CM_Connect.request(connect) signal to CMT indicating that the ECM State machine is to begin a connection sequence. The fddiSMTRemoteDisconnectFlag is cleared on the setting of this variable to 1. See ANSI Ref 9.3.1.1. Disconnect: Generates an SM_CM_Connect.request(disconnect) signal to ECM and sets the fddiSMTRemoteDisconnectFlag. See ANSI Ref 9.3.1.1. Path-Test: Initiates a station path test. The Path_Test variable (See ANSI Ref. 9.4.1) is set to Testing. The results of this action are not specified in this standard. Self-Test: Initiates a station self test. The results of this action are not specified in this standard. Attempts to set this object to all other values results in a badValue error. Agents may elect to return a badValue error on attempts to set this variable to path-Test(4) or self-Test(5).')
snmpFddiMACNumber = MibScalar((1, 3, 6, 1, 2, 1, 10, 15, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACNumber.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACNumber.setDescription("The total number of MAC implementations (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiMACTable = MibTable((1, 3, 6, 1, 2, 1, 10, 15, 2, 2), )
if mibBuilder.loadTexts: snmpFddiMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTable.setDescription('A list of MAC entries. The number of entries is given by the value of snmpFddiMACNumber.')
snmpFddiMACEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1), ).setIndexNames((0, "RFC1285-MIB", "snmpFddiMACSMTIndex"), (0, "RFC1285-MIB", "snmpFddiMACIndex"))
if mibBuilder.loadTexts: snmpFddiMACEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACEntry.setDescription('A MAC entry containing information common to a given MAC.')
snmpFddiMACSMTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACSMTIndex.setDescription('The value of the SMT index associated with this MAC.')
snmpFddiMACIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACIndex.setDescription("A unique value for each MAC on the managed entity. The MAC identified by a particular value of this index is that identified by the same value of an ifIndex object instance. That is, if a MAC is associated with the interface whose value of ifIndex in the Internet-Standard MIB is equal to 5, then the value of snmpFddiMACIndex shall also equal 5. The value for each MAC must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiMACFrameStatusCapabilities = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1799))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACFrameStatusCapabilities.setReference('ANSI { fddiMAC 11 }')
if mibBuilder.loadTexts: snmpFddiMACFrameStatusCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACFrameStatusCapabilities.setDescription("A value that indicates the MAC's bridge and end- station capabilities for operating in a bridged FDDI network. The value is a sum. This value initially takes the value zero, then for each capability present, 2 raised to a power is added to the sum. The powers are according to the following table: Capability Power FSC-Type0 0 -- MAC repeats A/C indicators as received on -- copying with the intent to forward. FSC-Type1 1 -- MAC sets C but not A on copying for -- forwarding. FSC-Type2 2 -- MAC resets C and sets A on C set and -- A reset if the frame is not copied and the -- frame was addressed to this MAC FSC-Type0-programmable 8 -- Type0 capability is programmable FSC-Type1-programmable 9 -- Type1 capability is programmable FSC-Type2-programmable 10 -- Type2 capability is programmable ")
snmpFddiMACTMaxGreatestLowerBound = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 4), FddiTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiMACTMaxGreatestLowerBound.setReference('ANSI { fddiMAC 13 }')
if mibBuilder.loadTexts: snmpFddiMACTMaxGreatestLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTMaxGreatestLowerBound.setDescription('The greatest lower bound of T_Max supported for this MAC.')
snmpFddiMACTVXGreatestLowerBound = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 5), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACTVXGreatestLowerBound.setReference('ANSI { fddiMAC 14 }')
if mibBuilder.loadTexts: snmpFddiMACTVXGreatestLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTVXGreatestLowerBound.setDescription('The greatest lower bound of TVX supported for this MAC.')
snmpFddiMACPathsAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACPathsAvailable.setReference('ANSI { fddiMAC 22 }')
if mibBuilder.loadTexts: snmpFddiMACPathsAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACPathsAvailable.setDescription('A value that indicates the PATH types available for this MAC. The value is a sum. This value initially takes the value zero, then for each type of PATH that this MAC has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 ')
snmpFddiMACCurrentPath = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("unknown", 1), ("primary", 2), ("secondary", 4), ("local", 8), ("isolated", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACCurrentPath.setReference('ANSI { fddiMAC 23 }')
if mibBuilder.loadTexts: snmpFddiMACCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACCurrentPath.setDescription('Indicates the association of the MAC with a station PATH.')
snmpFddiMACUpstreamNbr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 8), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACUpstreamNbr.setReference('ANSI { fddiMAC 24 }')
if mibBuilder.loadTexts: snmpFddiMACUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACUpstreamNbr.setDescription("The MAC's upstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1). The value shall be reported as '00 00 00 00 00 00' if it is unknown.")
snmpFddiMACOldUpstreamNbr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 9), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACOldUpstreamNbr.setReference('ANSI { fddiMAC 26 }')
if mibBuilder.loadTexts: snmpFddiMACOldUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACOldUpstreamNbr.setDescription("The previous value of the MAC's upstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol (refer to ANSI SMT 7.2.1). The value shall be reported as '00 00 00 00 00 00' if it is unknown.")
snmpFddiMACDupAddrTest = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pass", 2), ("fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACDupAddrTest.setReference('ANSI { fddiMAC 29 }')
if mibBuilder.loadTexts: snmpFddiMACDupAddrTest.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACDupAddrTest.setDescription('The Duplicate Address Test flag, Dup_Addr_Test (refer to ANSI 8.3.1).')
snmpFddiMACPathsRequested = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiMACPathsRequested.setReference('ANSI { fddiMAC 32 }')
if mibBuilder.loadTexts: snmpFddiMACPathsRequested.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACPathsRequested.setDescription('A value that indicates PATH(s) desired for this MAC. The value is a sum which represents the individual PATHs that are desired. This value initially takes the value zero, then for each type of PATH that this node is, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 Isolated 3 The precedence order is primary, secondary, local, and then isolated if multiple PATHs are desired are set.')
snmpFddiMACDownstreamPORTType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACDownstreamPORTType.setReference('ANSI { fddiMAC 33 }')
if mibBuilder.loadTexts: snmpFddiMACDownstreamPORTType.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACDownstreamPORTType.setDescription('Indicates the PC-Type of the first port that is downstream of this MAC (the exit port).')
snmpFddiMACSMTAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 13), FddiMACLongAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACSMTAddress.setReference('ANSI { fddiMAC 41 }')
if mibBuilder.loadTexts: snmpFddiMACSMTAddress.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACSMTAddress.setDescription('The 48 bit individual address of the MAC used for SMT frames.')
snmpFddiMACTReq = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 14), FddiTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiMACTReq.setReference('ANSI { fddiMAC 51 }')
if mibBuilder.loadTexts: snmpFddiMACTReq.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTReq.setDescription('The value of T-Req (refer to ANSI MAC 2.2.1 and ANSI MAC 7.3.5.2).')
snmpFddiMACTNeg = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 15), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACTNeg.setReference('ANSI { fddiMAC 52 }')
if mibBuilder.loadTexts: snmpFddiMACTNeg.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTNeg.setDescription('The value of T-Neg (refer to ANSI MAC 2.2.1 and ANSI MAC 7.3.5.2).')
snmpFddiMACTMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 16), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACTMax.setReference('ANSI { fddiMAC 53 }')
if mibBuilder.loadTexts: snmpFddiMACTMax.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTMax.setDescription('The value of T-Max (refer to ANSI MAC 2.2.1 and ANSI MAC 7.3.5.2).')
snmpFddiMACTvxValue = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 17), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACTvxValue.setReference('ANSI { fddiMAC 54 }')
if mibBuilder.loadTexts: snmpFddiMACTvxValue.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTvxValue.setDescription('The value of TvxValue (refer to ANSI MAC 2.2.1 and ANSI MAC 7.3.5.2).')
snmpFddiMACTMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 18), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACTMin.setReference('ANSI { fddiMAC 55 }')
if mibBuilder.loadTexts: snmpFddiMACTMin.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACTMin.setDescription('The value of T-Min (refer to ANSI MAC 2.2.1 and ANSI MAC 7.3.5.2).')
snmpFddiMACCurrentFrameStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiMACCurrentFrameStatus.setReference('ANSI { fddiMAC 63 }')
if mibBuilder.loadTexts: snmpFddiMACCurrentFrameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACCurrentFrameStatus.setDescription("A value that indicates the MAC's operational frame status setting functionality. The value is a sum. This value initially takes the value zero, then for each functionality present, 2 raised to a power is added to the sum. The powers are according to the following table: Functionality Power FSC-Type0 0 -- MAC repeats A/C indicators as received FSC-Type1 1 -- MAC sets C but not A on copying for -- forwarding FSC-Type2 2 -- MAC resets C and sets A on C set and A -- reset if frame is not copied ")
snmpFddiMACFrameCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACFrameCts.setReference('ANSI { fddiMAC 71 }')
if mibBuilder.loadTexts: snmpFddiMACFrameCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACFrameCts.setDescription('Frame_Ct (refer to ANSI MAC 2.2.1).')
snmpFddiMACErrorCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACErrorCts.setReference('ANSI { fddiMAC 81 }')
if mibBuilder.loadTexts: snmpFddiMACErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACErrorCts.setDescription('Error_Ct (refer to ANSI MAC 2.2.1).')
snmpFddiMACLostCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACLostCts.setReference('ANSI { fddiMAC 82 }')
if mibBuilder.loadTexts: snmpFddiMACLostCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACLostCts.setDescription('Lost_Ct (refer to ANSI MAC 2.2.1).')
snmpFddiMACFrameErrorThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACFrameErrorThreshold.setReference('ANSI { fddiMAC 95 }')
if mibBuilder.loadTexts: snmpFddiMACFrameErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACFrameErrorThreshold.setDescription('A threshold for determining when a MAC Condition report should be generated. The condition is true when the ratio, ((delta snmpFddiMACLostCt + delta snmpFddiMACErrorCt) / (delta snmpFddiMACFrameCt + delta snmpFddiMACLostCt)) x 2**16. exceeds the threshold. It is used to determine when a station has an unacceptable frame error threshold. The sampling algorithm is implementation dependent. Any attempt to set this variable to a value of less than one shall result in a badValue error. Those who are familiar with the SNMP management framework will recognize that thresholds are not in keeping with the SNMP philosophy. However, this variable is supported by underlying SMT implementations already and maintaining this threshold should not pose an undue additional burden on SNMP agent implementors.')
snmpFddiMACFrameErrorRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACFrameErrorRatio.setReference('ANSI { fddiMAC 96 }')
if mibBuilder.loadTexts: snmpFddiMACFrameErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACFrameErrorRatio.setDescription('This attribute is the actual ratio, ((delta snmpFddiMACLostCt + delta snmpFddiMACErrorCt) / (delta snmpFddiMACFrameCt + delta snmpFddiMACLostCt)) x 2**16.')
snmpFddiMACRMTState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("rm0", 1), ("rm1", 2), ("rm2", 3), ("rm3", 4), ("rm4", 5), ("rm5", 6), ("rm6", 7), ("rm7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACRMTState.setReference('ANSI { fddiMAC 111 }')
if mibBuilder.loadTexts: snmpFddiMACRMTState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACRMTState.setDescription('Indicates the current state of the Ring Management state machine (refer to ANSI Section 10).')
snmpFddiMACDaFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACDaFlag.setReference('ANSI { fddiMAC 112 }')
if mibBuilder.loadTexts: snmpFddiMACDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACDaFlag.setDescription('The RMT flag Duplicate Address Flag, DA_Flag (refer to ANSI 10.3.1.2).')
snmpFddiMACUnaDaFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACUnaDaFlag.setReference('ANSI { fddiMAC 113 }')
if mibBuilder.loadTexts: snmpFddiMACUnaDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACUnaDaFlag.setDescription('A flag set when the upstream neighbor reports a duplicate address condition. Reset when the condition clears.')
snmpFddiMACFrameCondition = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACFrameCondition.setReference('ANSI { fddiMAC 114 }')
if mibBuilder.loadTexts: snmpFddiMACFrameCondition.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACFrameCondition.setDescription('Indicates the MAC Condition is active when set. Cleared when the condition clears and on power up.')
snmpFddiMACChipSet = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 29), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiMACChipSet.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACChipSet.setDescription("This object identifies the hardware chip(s) which is (are) principally responsible for the implementation of the MAC function. A few OBJECT IDENTIFIERS are identified elsewhere in this memo. For those The assignment of additional OBJECT IDENTIFIERs to various types of hardware chip sets is managed by the IANA. For example, vendors whose chip sets are not defined in this memo may request a number from the Internet Assigned Numbers Authority (IANA) which indicates the assignment of a enterprise specific subtree which, among other things, may be used to allocate OBJECT IDENTIFIER assignments for that enterprise's chip sets. Similarly, in the absence of an appropriately assigned OBJECT IDENTIFIER in this memo or in an enterprise specific subtree of a chip vendor, a board or system vendor can request a number for a subtree from the IANA and make an appropriate assignment. It is desired that, whenever possible, the same OBJECT IDENTIFIER be used for all chips of a given type. Consequently, the assignment made in this memo for a chip, if any, should be used in preference to any other assignment and the assignment made by the chip manufacturer, if any, should be used in preference to assignments made by users of those chips. If the hardware chip set is unknown, the object identifier unknownChipSet OBJECT IDENTIFIER ::= { 0 0 } is returned. Note that unknownChipSet is a syntactically valid object identifier, and any conformant implementation of ASN.1 and the BER must be able to generate and recognize this value.")
snmpFddiMACAction = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("enableLLCService", 2), ("disableLLCService", 3), ("connectMAC", 4), ("disconnectMAC", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiMACAction.setReference('ANSI { fddiMAC 130 }')
if mibBuilder.loadTexts: snmpFddiMACAction.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiMACAction.setDescription('This object, when read, always returns a value of other(1). The behavior of setting this variable to each of the acceptable values is as follows: Other: Results in a badValue error. enableLLCService: enables MAC service to higher layers. disableLLCService: disables MAC service to higher layers. connectMAC: connect this MAC in station. disconnectMAC: disconnect this MAC in station. Attempts to set this object to all other values results in a badValue error.')
snmpFddiPORTNumber = MibScalar((1, 3, 6, 1, 2, 1, 10, 15, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTNumber.setDescription("The total number of PORT implementations (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiPORTTable = MibTable((1, 3, 6, 1, 2, 1, 10, 15, 4, 2), )
if mibBuilder.loadTexts: snmpFddiPORTTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTTable.setDescription('A list of PORT entries. The number of entries is given by the value of snmpFddiPORTNumber.')
snmpFddiPORTEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1), ).setIndexNames((0, "RFC1285-MIB", "snmpFddiPORTSMTIndex"), (0, "RFC1285-MIB", "snmpFddiPORTIndex"))
if mibBuilder.loadTexts: snmpFddiPORTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTEntry.setDescription('A PORT entry containing information common to a given PORT.')
snmpFddiPORTSMTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTSMTIndex.setDescription('The value of the SMT index associated with this PORT.')
snmpFddiPORTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTIndex.setDescription("A unique value for each PORT within a given SMT. Its value ranges between 1 and the sum of the values of snmpFddiSMTNonMasterCt { snmpFddiSMTEntry 6 } and snmpFddiSMTMasterCt { snmpFddiSMTEntry 7 } on the given SMT. The value for each PORT must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiPORTPCType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTPCType.setReference('ANSI { fddiPORT 12 }')
if mibBuilder.loadTexts: snmpFddiPORTPCType.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTPCType.setDescription('PC_Type (refer to ANSI SMT 9.2.2 and ANSI SMT 9.6.3.2).')
snmpFddiPORTPCNeighbor = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTPCNeighbor.setReference('ANSI { fddiPORT 13 }')
if mibBuilder.loadTexts: snmpFddiPORTPCNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTPCNeighbor.setDescription('The type (PC_Neighbor) of the remote PORT that is determined in PC_Signaling in R_Val (1,2) (refer to ANSI SMT 9.6.3.2).')
snmpFddiPORTConnectionPolicies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTConnectionPolicies.setReference('ANSI { fddiPORT 14 }')
if mibBuilder.loadTexts: snmpFddiPORTConnectionPolicies.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTConnectionPolicies.setDescription("A value that indicates the node's PORT policies. Pc-MAC-LCT, Pc-MAC-Loop, and Pc-MAC-Placement indicate how the respective PC Signaling Capability flags should be set (refer to ANSI SMT 9.4.3.2). The value is a sum. This value initially takes the value zero, then for each PORT policy, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power Pc-MAC-LCT 0 Pc-MAC-Loop 1 Pc-MAC-Placement 2 ")
snmpFddiPORTRemoteMACIndicated = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTRemoteMACIndicated.setReference('ANSI { fddiPORT 15 }')
if mibBuilder.loadTexts: snmpFddiPORTRemoteMACIndicated.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTRemoteMACIndicated.setDescription('The indication, in PC-Signaling that the remote partner intends to place a MAC in the output token PATH of this PORT. Signaled as R_Val (9) (refer to ANSI SMT 9.6.3.2).')
snmpFddiPORTCEState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ce0", 1), ("ce1", 2), ("ce2", 3), ("ce3", 4), ("ce4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTCEState.setReference('ANSI { fddiPORT 16 }')
if mibBuilder.loadTexts: snmpFddiPORTCEState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTCEState.setDescription("Indicates the current state of PORT's Configuration Element (CE) (refer to ANSI 9.7.5). Note that this value represents the Current Path information for this PORT.")
snmpFddiPORTPathsRequested = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTPathsRequested.setReference('ANSI { fddiPORT 17 }')
if mibBuilder.loadTexts: snmpFddiPORTPathsRequested.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTPathsRequested.setDescription("A value that indicates the desired association(s) of the port with a station PATH. The 'Primary' Path is the default. The value of 'Secondary' is only meaningful for S (slave) or M (master) PORT PC-Types. This value effects the setting of the CF_Insert_S, and CF_Insert_L flags (refer to ANSI Section 9.4.3). If the 'Primary' PATH is present, then the Primary PATH (the default PATH) is selected. If the 'Secondary' PATH is present and the 'Primary' PATH is not present, then the CF_Insert_S flag is set. If the 'Local' PATH is sent and neither the 'Primary' or 'Secondary' PATHs are sent, then the CF_Insert_L flag is set. The value is a sum. This value initially takes the value zero, then for each type of PATH desired, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 Isolated 3 ")
snmpFddiPORTMACPlacement = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 9), FddiResourceId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTMACPlacement.setReference('ANSI { fddiPORT 18 }')
if mibBuilder.loadTexts: snmpFddiPORTMACPlacement.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTMACPlacement.setDescription('Indicates the upstream MAC, if any, that is associated with the PORT. The value shall be zero if there is no MAC associated with the PORT. Otherwise, the value shall be equal to the value of snmpFddiMACIndex associated with the MAC.')
snmpFddiPORTAvailablePaths = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTAvailablePaths.setReference('ANSI { fddiPORT 19 }')
if mibBuilder.loadTexts: snmpFddiPORTAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTAvailablePaths.setDescription('A value that indicates the PATH types available for M and S PORTs. The value is a sum. This value initially takes the value zero, then for each type of PATH that this port has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power Primary 0 Secondary 1 Local 2 ')
snmpFddiPORTMACLoopTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 11), FddiTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTMACLoopTime.setReference('ANSI { fddiPORT 21 }')
if mibBuilder.loadTexts: snmpFddiPORTMACLoopTime.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTMACLoopTime.setDescription('Time for the optional MAC Local Loop, T_Next(9), which is greater-than or equal-to 200 milliseconds (refer to ANSI SMT 9.4.4.2.3).')
snmpFddiPORTTBMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 12), FddiTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTTBMax.setReference('ANSI { fddiPORT 32 }')
if mibBuilder.loadTexts: snmpFddiPORTTBMax.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTTBMax.setDescription('TB_Max (refer to ANSI SMT 9.4.4.2.1).')
snmpFddiPORTBSFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTBSFlag.setReference('ANSI { fddiPORT 33 }')
if mibBuilder.loadTexts: snmpFddiPORTBSFlag.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTBSFlag.setDescription('The Break State, BS_Flag (refer to ANSI SMT 9.4.3.4).')
snmpFddiPORTLCTFailCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTLCTFailCts.setReference('ANSI { fddiPORT 42 }')
if mibBuilder.loadTexts: snmpFddiPORTLCTFailCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLCTFailCts.setDescription('The count of the consecutive times the link confidence test (LCT) has failed during connection management (refer to ANSI 9.4.1).')
snmpFddiPORTLerEstimate = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTLerEstimate.setReference('ANSI { fddiPORT 51 }')
if mibBuilder.loadTexts: snmpFddiPORTLerEstimate.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLerEstimate.setDescription('A long term average link error rate. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the exponent of the estimate.')
snmpFddiPORTLemRejectCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTLemRejectCts.setReference('ANSI { fddiPORT 52 }')
if mibBuilder.loadTexts: snmpFddiPORTLemRejectCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLemRejectCts.setDescription('A link error monitoring count of the times that a link has been rejected.')
snmpFddiPORTLemCts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTLemCts.setReference('ANSI { fddiPORT 53 }')
if mibBuilder.loadTexts: snmpFddiPORTLemCts.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLemCts.setDescription('The aggregate link error monitor error count, set to zero only on station power_up.')
snmpFddiPORTLerCutoff = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTLerCutoff.setReference('ANSI { fddiPORT 58 }')
if mibBuilder.loadTexts: snmpFddiPORTLerCutoff.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLerCutoff.setDescription('The link error rate estimate at which a link connection will be broken. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the exponent.')
snmpFddiPORTLerAlarm = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTLerAlarm.setReference('ANSI { fddiPORT 59 }')
if mibBuilder.loadTexts: snmpFddiPORTLerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLerAlarm.setDescription('The link error rate estimate at which a link connection will generate an alarm. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the exponent of the estimate.')
snmpFddiPORTConnectState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("connecting", 2), ("standby", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTConnectState.setReference('ANSI { fddiPORT 61 }')
if mibBuilder.loadTexts: snmpFddiPORTConnectState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTConnectState.setDescription('An indication of the connect state of this PORT. Basically, this gives a higher level view of the state of the connection by grouping PCM states and the PC-Withhold flag state. The supported values and their corresponding PCM states and PC-Withhold condition, when relevant, are: disabled: (PC0:Off, PC9:Maint) connecting: (PC1(Break) || PC3 (Connect) || PC4 (Next) || PC5 (Signal) || PC6 (Join) || PC7 (Verify)) && (PC_Withhold = None) standby: (NOT PC_Withhold == None) active: (PC2:Trace || PC8:Active) ')
snmpFddiPORTPCMState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("pc0", 1), ("pc1", 2), ("pc2", 3), ("pc3", 4), ("pc4", 5), ("pc5", 6), ("pc6", 7), ("pc7", 8), ("pc8", 9), ("pc9", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTPCMState.setReference('ANSI { fddiPORT 62 }')
if mibBuilder.loadTexts: snmpFddiPORTPCMState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTPCMState.setDescription('(refer to SMT 9.6.2).')
snmpFddiPORTPCWithhold = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("m-m", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTPCWithhold.setReference('ANSI { fddiPORT 63 }')
if mibBuilder.loadTexts: snmpFddiPORTPCWithhold.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTPCWithhold.setDescription('PC_Withhold, (refer to ANSI SMT 9.4.1).')
snmpFddiPORTLerCondition = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTLerCondition.setReference('ANSI { fddiPORT 64 }')
if mibBuilder.loadTexts: snmpFddiPORTLerCondition.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTLerCondition.setDescription('This variable is set to true whenever LerEstimate is less than or equal to LerAlarm.')
snmpFddiPORTChipSet = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 24), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiPORTChipSet.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTChipSet.setDescription("This object identifies the hardware chip(s) which is (are) principally responsible for the implementation of the PORT (PHY) function. A few OBJECT IDENTIFIERS are identified elsewhere in this memo. For those The assignment of additional OBJECT IDENTIFIERs to various types of hardware chip sets is managed by the IANA. For example, vendors whose chip sets are not defined in this memo may request a number from the Internet Assigned Numbers Authority (IANA) which indicates the assignment of a enterprise specific subtree which, among other things, may be used to allocate OBJECT IDENTIFIER assignments for that enterprise's chip sets. Similarly, in the absence of an appropriately assigned OBJECT IDENTIFIER in this memo or in an enterprise specific subtree of a chip vendor, a board or system vendor can request a number for a subtree from the IANA and make an appropriate assignment. It is desired that, whenever possible, the same OBJECT IDENTIFIER be used for all chips of a given type. Consequently, the assignment made in this memo for a chip, if any, should be used in preference to any other assignment and the assignment made by the chip manufacturer, if any, should be used in preference to assignments made by users of those chips. If the hardware chip set is unknown, the object identifier unknownChipSet OBJECT IDENTIFIER ::= { 0 0 } is returned. Note that unknownChipSet is a syntactically valid object identifier, and any conformant implementation of ASN.1 and the BER must be able to generate and recognize this value.")
snmpFddiPORTAction = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 4, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("maintPORT", 2), ("enablePORT", 3), ("disablePORT", 4), ("startPORT", 5), ("stopPORT", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiPORTAction.setReference('ANSI { fddiPORT 70 }')
if mibBuilder.loadTexts: snmpFddiPORTAction.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiPORTAction.setDescription("This object, when read, always returns a value of other(1). The behavior of setting this variable to each of the acceptable values is as follows: Other: Results in a badValue error. maintPORT: Signal PC_Maint enablePORT: Signal PC_Enable disablePORT: Signal PC_Disable startPORT: Signal PC_Start stopPORT: Signal PC_Stop Signals cause an SM_CM_CONTROL.request service to be generated with a control_action of `Signal' and the `variable' parameter set with the appropriate value (i.e., PC_Maint, PC_Enable, PC_Disable, PC_Start, PC_Stop). Ref. ANSI SMT Section 9.3.2. Attempts to set this object to all other values results in a badValue error.")
snmpFddiATTACHMENTNumber = MibScalar((1, 3, 6, 1, 2, 1, 10, 15, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTNumber.setDescription("The total number of attachments (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiATTACHMENTTable = MibTable((1, 3, 6, 1, 2, 1, 10, 15, 5, 2), )
if mibBuilder.loadTexts: snmpFddiATTACHMENTTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTTable.setDescription('A list of ATTACHMENT entries. The number of entries is given by the value of snmpFddiATTACHMENTNumber.')
snmpFddiATTACHMENTEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1), ).setIndexNames((0, "RFC1285-MIB", "snmpFddiATTACHMENTSMTIndex"), (0, "RFC1285-MIB", "snmpFddiATTACHMENTIndex"))
if mibBuilder.loadTexts: snmpFddiATTACHMENTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTEntry.setDescription("An ATTACHMENT entry containing information common to a given set of ATTACHMENTs. The ATTACHMENT Resource represents a PORT or a pair of PORTs plus the optional associated optical bypass that are managed as a functional unit. Because of its relationship to the PORT Objects, there is a natural association of ATTACHMENT Resource Indices to the PORT Indices. The resource index for the ATTACHMENT is equal to the associated PORT index for 'single-attachment' and 'concentrator' type snmpFddiATTACHMENTClasses. For 'dual-attachment' Classes, the ATTACHMENT Index is the PORT Index of the A PORT of the A/B PORT Pair that represents the ATTACHMENT.")
snmpFddiATTACHMENTSMTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTSMTIndex.setDescription('The value of the SMT index associated with this ATTACHMENT.')
snmpFddiATTACHMENTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTIndex.setDescription("A unique value for each ATTACHMENT on a given SMT. Its value ranges between 1 and the sum of the values of snmpFddiSMTNonMasterCt { snmpFddiSMTEntry 6 } and snmpFddiSMTMasterCt { snmpFddiSMTEntry 7 } on the given SMT. The value for each ATTACHMENT must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
snmpFddiATTACHMENTClass = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("single-attachment", 1), ("dual-attachment", 2), ("concentrator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTClass.setReference('ANSI { fddiATTACHMENT 11 }')
if mibBuilder.loadTexts: snmpFddiATTACHMENTClass.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTClass.setDescription('The Attachment class. This represents a PORT or a pair of PORTs plus the associated optional optical bypass that are managed as a functional unit. The PORT associations are the following: single-attachment - S PORTs dual-attachment - A/B PORT Pairs concentrator - M PORTs ')
snmpFddiATTACHMENTOpticalBypassPresent = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTOpticalBypassPresent.setReference('ANSI { fddiATTACHMENT 12 }')
if mibBuilder.loadTexts: snmpFddiATTACHMENTOpticalBypassPresent.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTOpticalBypassPresent.setDescription("The value of this value is false for 'single- attachment' and { snmpFddiATTACHMENT 11 }. Correct operation of CMT for single-attachment and concentrator attachments requires that a bypass function must not loopback the network side of the MIC, but only the node side.")
snmpFddiATTACHMENTIMaxExpiration = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 5), FddiTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTIMaxExpiration.setReference('ANSI { fddiATTACHMENT 13 }')
if mibBuilder.loadTexts: snmpFddiATTACHMENTIMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTIMaxExpiration.setDescription('I_Max (refer to ANSI SMT 9.4.4.2.1). It is recognized that some currently deployed systems do not implement an optical bypass. Systems which do not implement optical bypass should return a value of 0.')
snmpFddiATTACHMENTInsertedStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertedStatus.setReference('ANSI { fddiATTACHMENT 14 }')
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertedStatus.setDescription('Indicates whether the attachment is currently inserted in the node.')
snmpFddiATTACHMENTInsertPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 15, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertPolicy.setReference('ANSI { fddiATTACHMENT 15 }')
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: snmpFddiATTACHMENTInsertPolicy.setDescription("Indicates the Insert Policy for this Attachment. Insert: True (1), Don't Insert: False (2), Unimplemented (3)")
snmpFddiPHYChipSets = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 6, 1))
snmpFddiMACChipSets = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 6, 2))
snmpFddiPHYMACChipSets = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 15, 6, 3))
mibBuilder.exportSymbols("RFC1285-MIB", snmpFddiSMTMasterCt=snmpFddiSMTMasterCt, snmpFddiMACTVXGreatestLowerBound=snmpFddiMACTVXGreatestLowerBound, snmpFddiATTACHMENTClass=snmpFddiATTACHMENTClass, fddi=fddi, snmpFddiMACTable=snmpFddiMACTable, snmpFddiPORTBSFlag=snmpFddiPORTBSFlag, snmpFddiATTACHMENTEntry=snmpFddiATTACHMENTEntry, snmpFddiPHYMACChipSets=snmpFddiPHYMACChipSets, snmpFddiMACDownstreamPORTType=snmpFddiMACDownstreamPORTType, snmpFddiSMTStatusReporting=snmpFddiSMTStatusReporting, snmpFddiATTACHMENTInsertPolicy=snmpFddiATTACHMENTInsertPolicy, snmpFddiMACDupAddrTest=snmpFddiMACDupAddrTest, snmpFddiPORTMACPlacement=snmpFddiPORTMACPlacement, snmpFddiSMTTNotify=snmpFddiSMTTNotify, snmpFddiSMTTable=snmpFddiSMTTable, snmpFddiMACDaFlag=snmpFddiMACDaFlag, snmpFddiMACSMTIndex=snmpFddiMACSMTIndex, snmpFddiPORTAction=snmpFddiPORTAction, snmpFddiSMTPathsAvailable=snmpFddiSMTPathsAvailable, snmpFddiMACOldUpstreamNbr=snmpFddiMACOldUpstreamNbr, snmpFddiMACEntry=snmpFddiMACEntry, snmpFddiPORTPathsRequested=snmpFddiPORTPathsRequested, snmpFddiPORTLerAlarm=snmpFddiPORTLerAlarm, snmpFddiMACChipSets=snmpFddiMACChipSets, snmpFddiATTACHMENTIMaxExpiration=snmpFddiATTACHMENTIMaxExpiration, snmpFddiSMTStationId=snmpFddiSMTStationId, snmpFddiPORTPCType=snmpFddiPORTPCType, snmpFddiMACTMin=snmpFddiMACTMin, snmpFddiPORTAvailablePaths=snmpFddiPORTAvailablePaths, snmpFddiPORTLemCts=snmpFddiPORTLemCts, snmpFddiSMTRemoteDisconnectFlag=snmpFddiSMTRemoteDisconnectFlag, snmpFddiMACTMaxGreatestLowerBound=snmpFddiMACTMaxGreatestLowerBound, snmpFddiPORTIndex=snmpFddiPORTIndex, snmpFddiPORTLemRejectCts=snmpFddiPORTLemRejectCts, snmpFddiPORTPCMState=snmpFddiPORTPCMState, FddiResourceId=FddiResourceId, snmpFddiSMTIndex=snmpFddiSMTIndex, snmpFddiMACTNeg=snmpFddiMACTNeg, snmpFddiPORTLerEstimate=snmpFddiPORTLerEstimate, FddiTime=FddiTime, snmpFddiMACSMTAddress=snmpFddiMACSMTAddress, snmpFddiATTACHMENTSMTIndex=snmpFddiATTACHMENTSMTIndex, snmpFddiPORTCEState=snmpFddiPORTCEState, snmpFddiMACUpstreamNbr=snmpFddiMACUpstreamNbr, snmpFddiMACFrameCts=snmpFddiMACFrameCts, snmpFddiMACIndex=snmpFddiMACIndex, snmpFddiPORTConnectState=snmpFddiPORTConnectState, snmpFddiPORTMACLoopTime=snmpFddiPORTMACLoopTime, snmpFddiSMTStationAction=snmpFddiSMTStationAction, snmpFddiATTACHMENTOpticalBypassPresent=snmpFddiATTACHMENTOpticalBypassPresent, FddiMACLongAddressType=FddiMACLongAddressType, snmpFddiSMTEntry=snmpFddiSMTEntry, snmpFddiSMTConnectionPolicy=snmpFddiSMTConnectionPolicy, snmpFddiMACErrorCts=snmpFddiMACErrorCts, snmpFddiMACPathsAvailable=snmpFddiMACPathsAvailable, snmpFddiPORTPCWithhold=snmpFddiPORTPCWithhold, snmpFddiPORTEntry=snmpFddiPORTEntry, snmpFddiMACChipSet=snmpFddiMACChipSet, snmpFddiSMTConfigCapabilities=snmpFddiSMTConfigCapabilities, snmpFddiPORTRemoteMACIndicated=snmpFddiPORTRemoteMACIndicated, snmpFddiATTACHMENTTable=snmpFddiATTACHMENTTable, snmpFddiChipSets=snmpFddiChipSets, snmpFddiPORTTBMax=snmpFddiPORTTBMax, snmpFddiPORTLCTFailCts=snmpFddiPORTLCTFailCts, snmpFddiPORTLerCondition=snmpFddiPORTLerCondition, snmpFddiMACTReq=snmpFddiMACTReq, snmpFddiMACUnaDaFlag=snmpFddiMACUnaDaFlag, snmpFddiSMTHiVersionId=snmpFddiSMTHiVersionId, snmpFddiSMTNonMasterCt=snmpFddiSMTNonMasterCt, snmpFddiMACLostCts=snmpFddiMACLostCts, snmpFddiMACFrameCondition=snmpFddiMACFrameCondition, snmpFddiSMTECMState=snmpFddiSMTECMState, snmpFddiSMTNumber=snmpFddiSMTNumber, snmpFddiPHYChipSets=snmpFddiPHYChipSets, snmpFddiMAC=snmpFddiMAC, snmpFddiATTACHMENTInsertedStatus=snmpFddiATTACHMENTInsertedStatus, snmpFddiMACPathsRequested=snmpFddiMACPathsRequested, snmpFddiSMTLoVersionId=snmpFddiSMTLoVersionId, snmpFddiATTACHMENTIndex=snmpFddiATTACHMENTIndex, snmpFddiMACAction=snmpFddiMACAction, snmpFddiPORTTable=snmpFddiPORTTable, snmpFddiATTACHMENTNumber=snmpFddiATTACHMENTNumber, snmpFddiPORTChipSet=snmpFddiPORTChipSet, snmpFddiMACFrameErrorRatio=snmpFddiMACFrameErrorRatio, snmpFddiSMTHoldState=snmpFddiSMTHoldState, snmpFddiMACCurrentPath=snmpFddiMACCurrentPath, snmpFddiMACCurrentFrameStatus=snmpFddiMACCurrentFrameStatus, snmpFddiMACFrameErrorThreshold=snmpFddiMACFrameErrorThreshold, snmpFddiPORTConnectionPolicies=snmpFddiPORTConnectionPolicies, snmpFddiPATH=snmpFddiPATH, snmpFddiPORTPCNeighbor=snmpFddiPORTPCNeighbor, snmpFddiMACTMax=snmpFddiMACTMax, FddiSMTStationIdType=FddiSMTStationIdType, snmpFddiATTACHMENT=snmpFddiATTACHMENT, snmpFddiSMTMACCt=snmpFddiSMTMACCt, snmpFddiSMT=snmpFddiSMT, snmpFddiMACTvxValue=snmpFddiMACTvxValue, snmpFddiSMTCFState=snmpFddiSMTCFState, snmpFddiPORTSMTIndex=snmpFddiPORTSMTIndex, snmpFddiSMTConfigPolicy=snmpFddiSMTConfigPolicy, snmpFddiMACRMTState=snmpFddiMACRMTState, snmpFddiPORT=snmpFddiPORT, snmpFddiMACFrameStatusCapabilities=snmpFddiMACFrameStatusCapabilities, snmpFddiPORTNumber=snmpFddiPORTNumber, snmpFddiMACNumber=snmpFddiMACNumber, snmpFddiSMTOpVersionId=snmpFddiSMTOpVersionId, snmpFddiPORTLerCutoff=snmpFddiPORTLerCutoff)

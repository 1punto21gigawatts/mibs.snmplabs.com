#
# PySNMP MIB module ZhoneV52-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZhoneV52-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:52:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
PerfCurrentCount, = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, ModuleIdentity, ObjectIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, NotificationType, Integer32, MibIdentifier, Gauge32, TimeTicks, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ModuleIdentity", "ObjectIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "NotificationType", "Integer32", "MibIdentifier", "Gauge32", "TimeTicks", "Bits", "iso")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
zhoneVoice, = mibBuilder.importSymbols("Zhone", "zhoneVoice")
ZhoneSlotValueOrZero, ZhoneAdminString, ZhoneShelfValueOrZero, ZhoneRowStatus, ZhoneShelfValue, ZhoneSlotValue = mibBuilder.importSymbols("Zhone-TC", "ZhoneSlotValueOrZero", "ZhoneAdminString", "ZhoneShelfValueOrZero", "ZhoneRowStatus", "ZhoneShelfValue", "ZhoneSlotValue")
zhoneV52 = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2))
zhoneV52.setRevisions(('2008-02-05 01:38', '2003-12-09 16:36', '2003-01-31 14:09', '2002-09-10 15:15', '2002-04-05 09:30', '2001-12-13 14:30', '2001-10-24 17:00', '2001-09-04 14:30', '2001-08-01 11:15', '2001-07-23 15:50', '2001-03-09 14:30', '2001-01-17 13:17', '2001-01-09 11:12', '2000-12-19 14:33', '2000-11-22 13:22', '2000-10-04 10:53', '2000-08-23 10:58',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: zhoneV52.setRevisionsDescriptions(('V01.02.09: - Added support for south-africa and saudi-arabia in National pstn region.', 'V01.02.08: - Correct the lower range v52IgLocalInterfaceId and v52IgRemoteInterfaceId.', 'V01.02.07: Add Estonia to v52IgNationalPstnRegion list.', 'V01.02.06: Add Ireland and Australia to v52IgNationalPstnRegion list.', 'V01.02.05: Add United Arab Emirates to v52IgNationalPstnRegion list.', 'V01.02.04: - Add ISDN calls to current, interval and total statistics tables. - Change OutboundCallsBlocked to CallsBlocked for current, interval and total statistics tables.', 'V01.02.03: - Update default values and add read-only restrictions to all MIB variables in v52InterfaceGroupLapvTable.', 'V01.02.02: - Add v52ProtectionCPathTable and trap notification.', 'V01.02.01: Add Taiwan to v52IgNationalPstnRegion enum list.', "V01.02.00: Update V52 MIB to reflect release 1.2 revisions: - Update more MIB variables as supported. - Add and update notification traps and their matching MIB variables. - Set v52LinkAdminStatus to 'obsolete'. - Remove 'unknown' from v52IgSwitchVendor enum. - Changed default values for v52IgStartupCheckLinkId and v52IgStartupUnblockUserPorts.", "V01.01.06: - Added 'restart' to v52IgAdminStatus. - Added additional countries to v52IgNationalPstnRegion. - Added a new enum to v52IgSwitchVendor. - Added a new block state to v52UserPortBlock. - Added v52UserPortOperStatus to v52UserPortEntry. - Added v52IgExtensionTable for additional V5.2 interface configuration variables.", 'V01.01.05: Change the validation for the v52LinkDs1ChannelNumber', 'V01.00.04: Reordered ZHONE_KEYWORD_STORAGE_ORDER to agree to the MIB.', 'V01.00.03: Added 3 new variables to the v52UserPortTable: v52UserPortIsdnDsCPathId, v52UserPortIsdnPCPathId, v52UserPortIsdnFCPathId. Added v52IgProtocolSpecification and v52IgPeerStatus to v52InterfaceTable. Changed austrilia(6) for austria(6) for v52IgNationalPstnRegion.', 'V01.00.02: Added v52IgSwitchVendor. Updated v52UserPortTable index. Added reference for v52LinkCheckId and v52LinkCheckIdStatus.', 'V01.00.01: Updated table index structures. Updated v52InterfaceGroupTable and v52LinkTable according to ETSI V5.2 specifications. Added V5.2 notificatoin traps.', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: zhoneV52.setLastUpdated('200312091636Z')
if mibBuilder.loadTexts: zhoneV52.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: zhoneV52.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: zhoneV52.setDescription('The MIB module to describe objects for V5.2.')
v52InterfaceGroupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1), )
if mibBuilder.loadTexts: v52InterfaceGroupTable.setReference('ETSI EN 300 347-1 V2.2.2 (1999-12) ')
if mibBuilder.loadTexts: v52InterfaceGroupTable.setStatus('current')
if mibBuilder.loadTexts: v52InterfaceGroupTable.setDescription('V5.2 Interface Group table. A V5.2 interface contains 1-16 E1 links. The protocols defined in the ETSI V5.2 specification (ETS 300 347-1) are carried across the interface that is located between the AN and the LE. The V5 interface is a logical concept.')
v52InterfaceGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"))
if mibBuilder.loadTexts: v52InterfaceGroupEntry.setStatus('current')
if mibBuilder.loadTexts: v52InterfaceGroupEntry.setDescription('An entry in the v52InterfaceBundleTable')
v52IgNameId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 1), ZhoneAdminString())
if mibBuilder.loadTexts: v52IgNameId.setStatus('current')
if mibBuilder.loadTexts: v52IgNameId.setDescription('The Interface Group name is a system-wide unique symbolic name that is used for call routing. The maximum length for this name is 32 characters.')
v52IgShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 2), ZhoneShelfValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgShelf.setStatus('current')
if mibBuilder.loadTexts: v52IgShelf.setDescription('The shelf where this Interface and V5.2 stack resides. Range of valid values is 1-255. Note 0 is an invalid value.')
v52IgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 3), ZhoneSlotValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgSlot.setStatus('current')
if mibBuilder.loadTexts: v52IgSlot.setDescription('The shelf where this Interface and V5.2 stack resides. Range of valid values is 1-17. Note 0 is an invalid value.')
v52IgPeerShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 4), ZhoneShelfValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgPeerShelf.setStatus('current')
if mibBuilder.loadTexts: v52IgPeerShelf.setDescription("The shelf where this Redundancy Group's peer (or standby) resides. Peer shelf and peer slot define where this peer Interface Group and V5.2 stack resides. Range of valid values is 0-255. A peer shelf value of 0 represents a no backup configuration.")
v52IgPeerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 5), ZhoneSlotValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgPeerSlot.setStatus('current')
if mibBuilder.loadTexts: v52IgPeerSlot.setDescription("The slot where this Interface Group's peer (or standby) resides. Peer shelf and peer slot define where this Interface Group peer and V5.2 stack resides. Range of valid values is 0-17. A peer slot value of 0 represents a no backup configuration.")
v52IgPeerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noStandbyConfigured", 1), ("configuredAndAvailable", 2), ("configuredAndUnavailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgPeerStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgPeerStatus.setDescription('The status of the peer (or standby) Interface Group Valid peer status values are: * noStandbyConfigured * configuredAndAvailable * configuredAndUnavailable')
v52IgLocalInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLocalInterfaceId.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgLocalInterfaceId.setStatus('current')
if mibBuilder.loadTexts: v52IgLocalInterfaceId.setDescription('24-bit AN side V5.2 Interface identifier provisioned. Valid range is 0..16777215.')
v52IgRemoteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgRemoteInterfaceId.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgRemoteInterfaceId.setStatus('current')
if mibBuilder.loadTexts: v52IgRemoteInterfaceId.setDescription('24-bit LE side V5.2 Interface identifier provisioned. This is read only can only be updated indirectly by setting v52IgProvVariantRequest to requestFromLe. Valid range is 0..16777215.')
v52IgLocalProvVariant = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLocalProvVariant.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgLocalProvVariant.setStatus('current')
if mibBuilder.loadTexts: v52IgLocalProvVariant.setDescription('AN side provisioning variant used to differentiate variations in configuration. This is provisioned by the user. Valid range is 0..127. Default is 0.')
v52IgRemoteProvVariant = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgRemoteProvVariant.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgRemoteProvVariant.setStatus('current')
if mibBuilder.loadTexts: v52IgRemoteProvVariant.setDescription('LE side provisioning variant used to differentiate variations in configuration. This is read only can only be updated indirectly by setting v52IgProvVariantRequest to requestFromLe. Valid range is 0..127. Default is 0.')
v52IgProvVariantRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noRequest", 1), ("verifyWithLe", 2), ("requestFromLe", 3), ("switchLeToLocal", 4))).clone('noRequest')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgProvVariantRequest.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgProvVariantRequest.setStatus('current')
if mibBuilder.loadTexts: v52IgProvVariantRequest.setDescription('User requests to carry out various actions about provisioning variant. Valid values for this variable can be: * noRequest - this is the default value. Setting the variable to this value explicitly has no effect. * verifyWithLe - request to verify if LE is ready for reprovision. * requestFromLe - request to get LE Variant ID and Interface ID. * switchLeToLocal - request the LE side to change its provisioning variant to be the same as v52IgLocalProvVariant. Only requestFromLe set option is currently supported.')
v52IgProvVariantRequestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("verifyWithLeSucceeded", 1), ("verifyWithLeFailed", 2), ("requestFromLeSucceeded", 3), ("requestFromLeFailed", 4), ("switchToLocalSucceeded", 5), ("switchToLocalFailed", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgProvVariantRequestStatus.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52IgProvVariantRequestStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgProvVariantRequestStatus.setDescription('Status result for v52IgProvVariantRequest. When v52IgProvVariantRequest has a value of noRequest, the value for this variable is invalid. Valid values for this variable are: * verifyWithLeSucceeded - LE is ready for reprovision with the verifyWithLe request. * verifyWithLeFailed - LE is not ready for reprovision with the verifyWithLe request. * requestFromLeSucceeded - received Variant ID and Interface ID from LE with the requestFromLe request. * requestFromLeFailed - did not receive Variant ID and Interface ID from LE with the requestFromLe request. * swithtoLocalSucceeded - LE side has changed its own provisioning variant to be the same as v52IgLocalProvVariant with the switchToLocal request. * swithtoLocalFailed - LE side failed to change its own provisioning variant to be the same as v52IgLocalProvVariant with the switchToLocal request.')
v52IgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2), ("deferredOutOfService", 3), ("restart", 4))).clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgAdminStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgAdminStatus.setDescription("Interface Admin Status. Valid values are inService, outOfService, deferredOutOfService and restart. Default value is outOfService. * 'deferredOutofService' takes the interface group out of service, but not until all calls are completed. * 'restart' causes the v52 interface to shutdown for a period of time and then go through the startup procedure. When restart is complete, the V5.2 interface should go back to the previously configured admin status before it was set to 'restart'. According to ETSI EN 300 347-1 V2.2.2, 95 seconds is the minimum time a system has to be shutdown before it can be returned for service.")
v52IgOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("operable", 1), ("inoperable", 2), ("standby", 3), ("degradedService", 4), ("inoperableIsInProgress", 5), ("inoperableOosInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgOperationalStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgOperationalStatus.setDescription("Interface operational status. Valid values are operable, inoperable, standby, and degradedService. Indicates whether it is fully inoperable and unable to provide service to the user, or it is fully operable and available for use. Valid values are operable, inoperable, standby, degradedService and the transitional states of inoperableIsInProgress and inoperableOosInProgress. Depending on the V52 configuration, the transition between inService and outOfService can take quite some time for an interface group. The transitional states give operator a more accurate indication of a V52 IG's behavior. AdminStatus OperationalStatus Description ----------- ----------------- ----------- outOfService operable not valid outOfService inoperable admin out of service outOfService standby not valid inService operable normal operations inService inOperable fault inService standby normal operations")
v52IgOperStatusCause = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("localDisable", 2), ("remoteOutOfService", 3), ("protocolFailure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgOperStatusCause.setStatus('current')
if mibBuilder.loadTexts: v52IgOperStatusCause.setDescription('Cause for Interface operational status. Valid values are other, localDisable, remoteOutOfService, and protocolFailure.')
v52IgMaxConfiguredCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 16), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(30, 480))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgMaxConfiguredCalls.setStatus('current')
if mibBuilder.loadTexts: v52IgMaxConfiguredCalls.setDescription('Maximum number of active calls. Maximum number of active calls is equal to the maximum number of links (up to 16) assigned to the IG times the maximum number of time slots per E1 link (31) less the total number of provisioned C channels on these links.')
v52IgCurrActiveCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 17), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 480))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgCurrActiveCalls.setStatus('current')
if mibBuilder.loadTexts: v52IgCurrActiveCalls.setDescription('The number of calls currently active. Not supported.')
v52IgPstnLayer3StartAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgPstnLayer3StartAddress.setStatus('current')
if mibBuilder.loadTexts: v52IgPstnLayer3StartAddress.setDescription('Starting PSTN layer 3 port address the analogue access is assigned to. Valid range in 0..32767. This variable can only be modified when v52IgAdminStatus is set to outOfService and there are no PSTN user ports attached to the interface group.')
v52IgIsdnEnvFuncStartAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8175))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgIsdnEnvFuncStartAddress.setStatus('current')
if mibBuilder.loadTexts: v52IgIsdnEnvFuncStartAddress.setDescription('The envelope function starting address the ISDN primary rate access is assigned to. Valid range is 0..8175. This variable can only be modified when v52IgAdminStatus is set to outOfService and there are no ISDN user ports attached to the interface group.')
v52IgStatsTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgStatsTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: v52IgStatsTimeElapsed.setDescription("The number of seconds that have elapsed since the beginning of the current collection period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value. Not supported.")
v52IgStatsValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgStatsValidIntervals.setStatus('current')
if mibBuilder.loadTexts: v52IgStatsValidIntervals.setDescription('The number of previous intervals for which data was collected. The value will typically be 96 unless the interface group was brought online within the last 24 hours, in which case the value will be the number of complete 15 minute intervals since the interface has been online. In the case where the agent is an SNMP transport bridging proxy or SNMP translating proxy, it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available. Not supported.')
v52IgStatsInvalidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgStatsInvalidIntervals.setStatus('current')
if mibBuilder.loadTexts: v52IgStatsInvalidIntervals.setDescription('The number of intervals in the range from 0 to igStatsValidIntervals for which no data is available. This object will typically be zero except in cases where the data for some intervals are not available (e.g., in proxy situations). Not supported.')
v52IgPortAlignmentRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noRequest", 1), ("blockAll", 2), ("blockIsdn", 3), ("blockPstn", 4), ("unblockAll", 5), ("unblockIsdn", 6), ("unblockPstn", 7))).clone('noRequest')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgPortAlignmentRequest.setStatus('current')
if mibBuilder.loadTexts: v52IgPortAlignmentRequest.setDescription("Request to block or unblock all the user ports associated with the current IG by port type. This is needed to be compiliant with the V5.2 requirement for Accelerated Port Alignment. The status result of this request will be indicated by v52IgPortAlignmentStatus and the individual user port block status will also be updated. Valid values for the variable are: * noRequest - this is the default value. * blockAll - block all user ports associated with this IG. * blockIsdn - block all the isdnBa and isdnPra user ports associated with this IG. * blockPstn - block all the pstn user ports associated with this IG. * unblockAll - unblock all user ports associated with this IG. * unblockIsdn - unblock all the isdnBa and isdnPra user ports associated with this IG. * unblockPstn - unblock all the pstn user ports associated with this IG. When v52UserPortBlock at the user port level is set to be 'blockedNotSuitableForGroupUnblocking', the user port will not be unblocked by issuing an unblocking request using the v52IgPortAlignmentRequest. 'blockAll' option is currently not supported.")
v52IgPortAlignmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("blockAllSucceeded", 1), ("blockAllFailed", 2), ("blockIsdnSucceded", 3), ("blockIsdnFailed", 4), ("blockPstnSucceded", 5), ("blockPstnFailed", 6), ("unblockAllSucceeded", 7), ("unblockAllFailed", 8), ("unblockIsdnSucceeded", 9), ("unblockIsdnFailed", 10), ("unblockPstnSucceeded", 11), ("unblockPstnFailed", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IgPortAlignmentStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgPortAlignmentStatus.setDescription('Indicate the status result for user port block/unblock request by port type. The values of this variable indicate both type of request and its success or fail status. The value is invalid when v52IgPortAlignmentRequest is noRequest.')
v52IgNationalPstnRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))).clone(namedValues=NamedValues(("etsi", 1), ("germany", 2), ("uk", 3), ("italy", 4), ("finland", 5), ("austria", 6), ("belgium", 7), ("china", 8), ("france", 9), ("hong-kong", 10), ("japan", 11), ("korea", 12), ("netherlands", 13), ("new-zealand", 14), ("singapore", 15), ("spain", 16), ("sweden", 17), ("switzerland", 18), ("mexico", 19), ("argentina", 20), ("peru", 21), ("puerto-rico", 22), ("brazil", 23), ("malaysia", 24), ("taiwan", 25), ("united-arab-emirates", 26), ("ireland", 27), ("australia", 28), ("estonia", 29), ("south-africa", 30), ("saudi-arabia", 31))).clone('etsi')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgNationalPstnRegion.setStatus('current')
if mibBuilder.loadTexts: v52IgNationalPstnRegion.setDescription("V5.2's regional and country specific setting for the PSTN profile. This setting will dictate the regional signaling differences such as ring cadence. ETSI is the default value and the list of PSTN regions can be extended in the future.")
v52IgSwitchVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("lucent", 2), ("nortel", 3), ("alcatel", 4), ("ericsson", 5), ("nokia", 6), ("siemens", 7), ("samsung", 8))).clone('ericsson')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgSwitchVendor.setStatus('current')
if mibBuilder.loadTexts: v52IgSwitchVendor.setDescription("The switch vendor for the Interface Group. The following switch vendors are defined: unknown, lucent, nortel, alcatel, ericsson, nokia, siemens, samsung. Please note that 'unknown(1)' is no longer a valid value for this variable.")
v52IgProtocolSpecification = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("edition1", 1), ("edition2", 2))).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgProtocolSpecification.setStatus('current')
if mibBuilder.loadTexts: v52IgProtocolSpecification.setDescription('This variable specifies which variation of the v5.2 protocol is to be used by this interface group. Currently, there are two variations defined according to the ETSI specifications: * edition1 - refers to V5.2 specification defined in ETSI ETS 300 347-1 ed.1 (1994-09). * edition2 - refers to V5.2 specification defined in ETSI EN 300 347-1 V2.2.2 (1999-12)')
v52IgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 1, 1, 28), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgRowStatus.setStatus('current')
if mibBuilder.loadTexts: v52IgRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) v52IgRowStatus set to'CreateAndGo', b) the following READ-CREATE object(s): * If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. An row object of v52InterfaceGroupEntry can only be deleted when there are no v52UserPort associated with this IG. When an IG is deleted, the associated entries in the following tables will be deleted as well. - v52InterfaceGroupLapvTable - v52LinkTable - v52CChannelTable - v52CPathTable")
v52InterfaceGroupLapvTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2), )
if mibBuilder.loadTexts: v52InterfaceGroupLapvTable.setStatus('current')
if mibBuilder.loadTexts: v52InterfaceGroupLapvTable.setDescription('V5.2 Interface Group LAPV table. This table contains the configurable LAPV parameters for the interface group. It augments the v52InterfaceGroupTable. When an v52InterfaceGroupEntry is created, a corresponding row in the v52InterfaceGroupLapvTable will be created. All read-create objects must be provided for the SET if the DEFVAL, if one is defined, is to be over-ridden.')
v52InterfaceGroupLapvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1), )
v52InterfaceGroupEntry.registerAugmentions(("ZhoneV52-MIB", "v52InterfaceGroupLapvEntry"))
v52InterfaceGroupLapvEntry.setIndexNames(*v52InterfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: v52InterfaceGroupLapvEntry.setStatus('current')
if mibBuilder.loadTexts: v52InterfaceGroupLapvEntry.setDescription('An augmented entry in the v52InterfaceGroupLapvTable. This table augments the v52InterfaceGroupTable.')
v52IgLapvMaxOutstandingFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setUnits('frames').setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLapvMaxOutstandingFrames.setStatus('current')
if mibBuilder.loadTexts: v52IgLapvMaxOutstandingFrames.setDescription('Maximum number of outstanding information frames at layer 2 Range of valid values is 1-7. Default value is 7. Currently, the value of this variable cannot be changed and it will always be 7.')
v52IgLapvN200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLapvN200.setStatus('current')
if mibBuilder.loadTexts: v52IgLapvN200.setDescription('The maximum number of retransmissions for a frame allowed at layer 2, N200 shall be user selectable within the range of 1 to 10, inclusive, with a step size of 1 and a default value of 3. Currently, the value of this variable cannot be changed and it will always be 3.')
v52IgLapvN201 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 260)).clone(260)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLapvN201.setStatus('current')
if mibBuilder.loadTexts: v52IgLapvN201.setDescription('The maximum number of octets in the information field of an I frame, N201, shall be 260. (This SAP is used for operations messages.) Valid range is 0..260. Default is 260. Currently, the value of this variable cannot be changed and it will always be 260.')
v52IgLapvT200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(100, 100), ValueRangeConstraint(150, 150), ValueRangeConstraint(200, 200), ValueRangeConstraint(250, 250), ValueRangeConstraint(300, 300), ValueRangeConstraint(350, 350), ValueRangeConstraint(400, 400), ValueRangeConstraint(450, 450), ValueRangeConstraint(500, 500), ValueRangeConstraint(550, 550), ValueRangeConstraint(600, 600), ValueRangeConstraint(650, 650), ValueRangeConstraint(700, 700), ValueRangeConstraint(750, 750), ValueRangeConstraint(800, 800), ValueRangeConstraint(850, 850), ValueRangeConstraint(900, 900), ValueRangeConstraint(950, 950), ValueRangeConstraint(1000, 1000), )).clone(1000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLapvT200.setStatus('current')
if mibBuilder.loadTexts: v52IgLapvT200.setDescription('Maximum layer 2 wait time for an acknowledgment of a transmitted frame (T200) For all SAPs, the value of T200 shall be user selectable within the range of 100 ms to 1000 ms, inclusive, the step size shall be 50 ms, and the default value of T200 shall be 1000 ms. Currently, the value of this variable cannot be changed and it will always be 1000 ms.')
v52IgLapvT203 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(20, 20), ValueRangeConstraint(30, 30), ValueRangeConstraint(40, 40), ValueRangeConstraint(50, 50), ValueRangeConstraint(60, 60), ValueRangeConstraint(70, 70), ValueRangeConstraint(80, 80), ValueRangeConstraint(90, 90), ValueRangeConstraint(100, 100), ValueRangeConstraint(110, 110), ValueRangeConstraint(120, 120), ValueRangeConstraint(130, 130), ValueRangeConstraint(140, 140), ValueRangeConstraint(150, 150), ValueRangeConstraint(160, 160), ValueRangeConstraint(170, 170), ValueRangeConstraint(180, 180), ValueRangeConstraint(190, 190), ValueRangeConstraint(200, 200), ValueRangeConstraint(210, 210), ValueRangeConstraint(220, 220), ValueRangeConstraint(230, 230), ValueRangeConstraint(240, 240), ValueRangeConstraint(250, 250), ValueRangeConstraint(260, 260), ValueRangeConstraint(270, 270), ValueRangeConstraint(280, 280), ValueRangeConstraint(290, 290), ValueRangeConstraint(300, 300), )).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLapvT203.setStatus('current')
if mibBuilder.loadTexts: v52IgLapvT203.setDescription('Maximum layer 2 idle time before connection verification is necessary (T203).For all SAPS, the value of T203 shall be user selectable within the range of 10 to 300 seconds, inclusive, the step size shall be 10 seconds, and the default value shall be 10 seconds. Currently, the value of this variable cannot be changed and it will always be 10 seconds.')
v52LinkTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3), )
if mibBuilder.loadTexts: v52LinkTable.setStatus('current')
if mibBuilder.loadTexts: v52LinkTable.setDescription('Table of provisioned 2.048 Mbit/s E1 links, The term link is a logical concept used to describe a communication channel between two points. in V5 there are many kinds of links: E1 links, data links, etc. The term link is used to mean E1 link. ')
v52LinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52LinkDsnLgId"), (0, "ZhoneV52-MIB", "v52LinkDs1ChannelNumber"))
if mibBuilder.loadTexts: v52LinkEntry.setStatus('current')
if mibBuilder.loadTexts: v52LinkEntry.setDescription('An entry in the v52LinkTable.')
v52LinkDsnLgId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: v52LinkDsnLgId.setStatus('current')
if mibBuilder.loadTexts: v52LinkDsnLgId.setDescription('The v52LinkDsnLgId object identifies the line group entry ID for the E1 line group ID. The range for v52LinkDsnLgId is 1..2147483647.')
v52LinkDs1ChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28)))
if mibBuilder.loadTexts: v52LinkDs1ChannelNumber.setStatus('current')
if mibBuilder.loadTexts: v52LinkDs1ChannelNumber.setDescription('Identifies the DS1 for the channelized DS3 or physical T1/E1. The v52LinkDs1ChannelNumber for a card with a physical T1 or E1 is 1, otherwise it refers to the channel number of the DS3 port which contains the DS1. In the later case, the range for v52LinkDS1ChannelNumber is 1..28.')
v52LinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52LinkId.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52LinkId.setStatus('current')
if mibBuilder.loadTexts: v52LinkId.setDescription('V5.2 Link identifier. Provisioned. Valid range is 0..255.')
v52LinkCheckId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activated", 1), ("notActivated", 2))).clone('notActivated')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52LinkCheckId.setReference('Section 16.2.4.3.5 - ETSI EN 300 347-1 V2.2.2 (1999-12)')
if mibBuilder.loadTexts: v52LinkCheckId.setStatus('current')
if mibBuilder.loadTexts: v52LinkCheckId.setDescription("Valid values for this variable are activated and notActivated and the default is notActivated. Set this variable to 'activated' to request check v52LinkId with the LE side link id. When the checkId is finished, this value will be 'notActivated'. Setting the value to 'notActivated' has no impact. A link identification check can successfully be started only when the link is operational. This link identification procedure can be initiated from either the AN or LE side but LE has priority over AN initiated request in case of collision of requests from AN and LE, in which case, the v52LinkCheckId request will fail. It is up to the system management to initiate the link identification or not. It can be performed by the system management on a timed basis, or be applied after re-provisioning.")
v52LinkCheckIdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("succeeded", 1), ("failed", 2), ("rejected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52LinkCheckIdStatus.setReference('Section 16.2.4.3.5 - ETSI EN 300 347-1 V2.2.2 (1999-12)')
if mibBuilder.loadTexts: v52LinkCheckIdStatus.setStatus('current')
if mibBuilder.loadTexts: v52LinkCheckIdStatus.setDescription("Status result for v52LinkCheckId. Valid values for this variable are succeeded, failed and rejected. It is the responsibility of the system management to take the appropriate action according to the v52LinkCheckIdStatus: If v52LinkCheckIdStatus is 'rejected', the operator can retry the request sometime later. If v52LinkCheckIdStatus is 'failed', the operator must correctly reprovision the system coordinating with the LE provisioning data and restart it.")
v52LinkAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2))).clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52LinkAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: v52LinkAdminStatus.setDescription('Link Admin Status. Valid values are inService and outOfService. Default is outOfService. This variable is obsolete and will no longer be used.')
v52LinkBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deferredBlocked", 1), ("nonDeferredBlocked", 2), ("forceBlocked", 3), ("unblocked", 4))).clone('unblocked')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52LinkBlock.setStatus('current')
if mibBuilder.loadTexts: v52LinkBlock.setDescription("Link blocking procedure is asymmetrical. AN requests link block, LE decides, LE releases connection, LE re-establishes semi-perm and pre-connected connections. An E1 is added in a blocked state and must be unblocked by the LE before the E1 becomes operational. An E1 must be administratively locked or blocked by the LE before it can be deleted. The default value is unblocked and valid values are: * deferredBlocked - wait until there is no active calls on the link. * nonDeferredBlocked - disconnect any connection after approval from LE. * forceBlocked - This is a forced blocking from AN without LE's approval. * unblocked - Unlock the link.")
v52LinkBlockStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unblocked", 1), ("local", 2), ("remote", 3), ("both", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52LinkBlockStatus.setStatus('current')
if mibBuilder.loadTexts: v52LinkBlockStatus.setDescription('AdminLinkBlock operational status. Link blocking procedure is assymetrical. AN requests link block, LE decides, LE releases connection, LE re-establishes semi-perm and pre-connected connections. Valid values are unblocked, local, remote, and both: * local - local is blocked * remote - remote is blocked * both - both local and remote are blocked * unblocked - both local and remote are unblocked')
v52LinkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 3, 1, 9), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52LinkRowStatus.setStatus('current')
if mibBuilder.loadTexts: v52LinkRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) v52LinkRowStatus set to'CreateAndGo', b) all READ-CREATE object(s) If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. ")
v52CChannelTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4), )
if mibBuilder.loadTexts: v52CChannelTable.setStatus('current')
if mibBuilder.loadTexts: v52CChannelTable.setDescription('Communication Channel (C-channel). C-paths (see v52CPathTable) are carried over C-channels (communications channels). In V5, there are two types of C-channels, logical and physical. Information about logical and physical C-channels is included in the provisioning data for V5.2 interfaces. A C-path associated with a logical C-channel is protected. A C-path associated with a physical C-channel is not protected. In V5.2 only, logical C-channels carry a group of one or more C-paths, excluding the C-paths for the protection protocol. A logical C-channel may consist of the C-paths for the Control, Link Control, and BCC protocols. Another logical C-channel may consist of the C-path for the PSTN protocol. A third logical C-channel may consist of the C-paths for ISDN Ds-type data and ISDN p-type data. A V5.2 interface may contain up to 44 logical C-channels and each logical C-channel on an interface is uniquely identified in V5.2 with a 16-bit logical C-channel identifier. The goal of the protection protocol is to protect the C-paths for the V5 Signaling protocols (ie, BCC, Control, etc) as well as the C-paths for ISDN D-channel data. However, the protection protocol is designed to protect logical C-channels, not C-paths. Therefore, in order to protect a C-path, it must be associated with a logical C-channel. This association is made as part of the provisioning variant. A physical C-channel consists of a time slot (64kbit/s) on an E1 that carries a C-channel (C-channels are used to carry signaling traffic). All physical C-channels are restricted to timeslots 16, 15, and 31 in accordance with the ETSI specification. If logical C-channels are in use, each logical C-channel is mapped to one and only one physical C-channel. This restriction is mandated by the role of the protection protocol. The protection protocol, which protects logical C-channels, can only protect a single logical C-channel per protection switch over. This implies an implicit limitation of one logical C-channel per physical C-channel. For a V5.2 interface, the physical C-channels are identified by a logical link ID and a timeslot. Each V5.2 interface can support a maximum of 48 physical C-channels (timeslots 16, 15, and 31 on up to 16 E1 links; 3 * 16 = 48). Physical C-channels are not available for bearer connections. The physical C-channels are identified at provisioning time and when ISDN ports with D-channel signaling are added.')
v52CChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52LinkDsnLgId"), (0, "ZhoneV52-MIB", "v52LinkDs1ChannelNumber"), (0, "ZhoneV52-MIB", "v52CChannelTimeSlotIndex"))
if mibBuilder.loadTexts: v52CChannelEntry.setStatus('current')
if mibBuilder.loadTexts: v52CChannelEntry.setDescription('Communication Channel (C-Channel) Entry. Indexed by v52IgNameId, v52LinkIndex and v52CChannelTimeSlotIndex. Time slots are contained in the Link and in the event of the link going out of service, no allocation of free timeslots from that link is allowed.')
v52CChannelTimeSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(15, 15), ValueRangeConstraint(16, 16), ValueRangeConstraint(31, 31), )))
if mibBuilder.loadTexts: v52CChannelTimeSlotIndex.setStatus('current')
if mibBuilder.loadTexts: v52CChannelTimeSlotIndex.setDescription('Time Slot Index. A V5 interface contains 31 V5 time slots. Time slot 0 is not instantiated, as it is an intrinsic part of the 2048 kbit/s link used for framing. Valid values can only be 16, 15 and 31 according to the ETSI specification.')
v52CChannelLogicalChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CChannelLogicalChannelId.setStatus('current')
if mibBuilder.loadTexts: v52CChannelLogicalChannelId.setDescription('Logical C-Channels carry a group of one or more C-Paths, excluding the C-Paths used for Protection protocol. A V5.2 interface may contain up to 44 logical C-channels and each logical C-channel on an interface is uniquely identified in V5.2 with a 16 bit logical C-channel identifier. Physical C-channels that are provisioned as standby channels in a protection group do not have logical C-channel identifiers associated with them. The logical C-channel identifiers are provisioned, valid range is 0..65535.')
v52CChannelProtGp = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("group1", 2), ("oneToOneGroup2", 3), ("mToNGroup2", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CChannelProtGp.setStatus('current')
if mibBuilder.loadTexts: v52CChannelProtGp.setDescription("C-Channel protection group. Valid values are none, group1, oneToOneGroup2, and mToNgroup2. Default value is none. oneToOneGroup2 option is currently not supported. v52CChanelProtGp can only be modified when the v52IgAdminStatus is 'outOfService'.")
v52CChannelRole = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("switchToStandby", 3))).clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CChannelRole.setReference('AV5 Application Notes 2.1.4.1 Logical C-Channels')
if mibBuilder.loadTexts: v52CChannelRole.setStatus('current')
if mibBuilder.loadTexts: v52CChannelRole.setDescription("C-Channel role. Valid values are: * active - the C-Channel is currently active mode. * standby - the C-Channel is currently in standby mode. * switchToStandby - This value can only be set when the C-Channel is in active mode. When an active channel is set to switchToStandby, one of the standby channels in the same protection group will take over as the new active channel. When this is completed, the channel being switched will become a standby channel in its protection group if it does not fail. If the channel fails, then v52CChannelStatus will indicate a value of failed. 'switchToStandby' is only supported for group2 C-Channels.")
v52CChannelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52CChannelStatus.setStatus('current')
if mibBuilder.loadTexts: v52CChannelStatus.setDescription('C-Channel status. Valid values are active, standby, and failed.')
v52CChannelCurrentLogicalChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52CChannelCurrentLogicalChannelId.setStatus('current')
if mibBuilder.loadTexts: v52CChannelCurrentLogicalChannelId.setDescription('The value of this variable indicates the current logical C-Channel identifier of the physical C-Channel. This is useful when a physical C-Channel that was provisioned as an active channel fails - if the physical C-Channel was a member of a V5.2 protection group the logical C-Channel identifier will be assigned to a standby physical C-Channel. This variable is only valid when read in conjunction with v52CChannel status as summarized in the following table: Physical Channel Current Logical Chan Role Status Channel Id ----------------------------------------------- Active Active Valid (prov channel Id) Active Failed Invalid Standby Standby Invalid Standby Active Valid Standby Failed Invalid')
v52CChannelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 7), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CChannelRowStatus.setStatus('current')
if mibBuilder.loadTexts: v52CChannelRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) v52CChannelRowStatus set to'CreateAndGo', b) all READ-CREATE object(s) If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. ")
v52CChannelStatusCause = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("switchOverRejected", 2), ("switchOverError", 3), ("switchOverResetSequenceNumberError", 4), ("switchOverAborted", 5), ("switchOverRejectedProvisioningError", 6), ("switchOverResetSequence", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52CChannelStatusCause.setStatus('current')
if mibBuilder.loadTexts: v52CChannelStatusCause.setDescription('Cause for CChannelStatus. Valid values are * other, * switchOverRejected * switchOverError * switchOverResetSequenceNumberError * switchOverAborted * switchOverRejectedProvisioningError * switchOverResetSequence')
v52CPathTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5), )
if mibBuilder.loadTexts: v52CPathTable.setStatus('current')
if mibBuilder.loadTexts: v52CPathTable.setDescription('C-paths consist of a layer 2 data link carrying an associated layer 3 signaling protocol. Layer 3 signaling is defined by the Control, Link Control, PSTN, BCC, and Protection protocols. Therefore, a C-path can exist for the Control protocol, the Link Control protocol, the PSTN protocol, the BCC protocol, and the Protection protocol. In addition, ISDN D-channel data is also carried over C-paths. Separate C-paths exist for ISDN Ds, p, and f-type data. There can only be one of each control, link control, and BCC C-Paths whereas multiple PSTN and ISDN C-Paths may exist. A group of C-Paths are associated with a C-channel. The C-path for protection, however, is not carried in a C-channel.')
v52CPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52CPathId"))
if mibBuilder.loadTexts: v52CPathEntry.setStatus('current')
if mibBuilder.loadTexts: v52CPathEntry.setDescription('Entry in the v52CPathTable.')
v52CPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: v52CPathId.setStatus('current')
if mibBuilder.loadTexts: v52CPathId.setDescription('8-bit C-Path identifier. Provisioned. Valid range is 1..48.')
v52CPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("pstn", 2), ("ctrl", 3), ("bcc", 4), ("lctl", 5), ("isdnDs", 6), ("isdnF", 7), ("isdnP", 8))).clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CPathType.setStatus('current')
if mibBuilder.loadTexts: v52CPathType.setDescription('C-path type can be unknown, pstn (PSTN), ctrl (Control protocol), bcc (Bearer Channel Connection protocol), lctl (Link Control protocol), and the following ISDN path types: Ds-isdn, f-isdn, and p-isdn. Default is unknown.')
v52CPathLogicalChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CPathLogicalChannelId.setStatus('current')
if mibBuilder.loadTexts: v52CPathLogicalChannelId.setDescription('C-Channel logical Channel ID assigned to this C-Path. Provisioned. Valid range is 0..65535.')
v52CPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 4), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52CPathRowStatus.setStatus('current')
if mibBuilder.loadTexts: v52CPathRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) v52CPathRowStatus set to'CreateAndGo', b) all READ-CREATE object(s) If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. A CPath object can only be deleted when v52IgAdminStatus is 'outOfService'.")
v52CPathOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52CPathOperStatus.setStatus('current')
if mibBuilder.loadTexts: v52CPathOperStatus.setDescription("The operational status of this CPath. Valid values are 'up' and 'down'.")
v52CPathOperStatusCause = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("establishConfirmationReceived", 1), ("establishIndicationReceived", 2), ("releaseIndicationReceived", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52CPathOperStatusCause.setStatus('current')
if mibBuilder.loadTexts: v52CPathOperStatusCause.setDescription('Cause for CPathOperStatus. Valid values are: * establishConfirmationReceived - the data link has been successfully established upon a local request. * establishIndicationReceived - the data link has been successfully established upon its peer request. * releaseIndicationReceived - the data link has failed because of either Layer 1 failure or no frame exchange with the peer was possible within the given time frame (after T203 timer expiry, followed by T200 timer expiry N200 times).')
v52UserPortTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6), )
if mibBuilder.loadTexts: v52UserPortTable.setStatus('current')
if mibBuilder.loadTexts: v52UserPortTable.setDescription('The User Port Table holds information regarding the PSTN and ISDN user ports. Information regarding the provisioning and availability status of the port is maintained. If a user port is busy, information regarding the allocation status of Bearer Channels to the user port is maintained and tracked by the configuration. If the port is put out of service for maintenance, the port is marked unavailable.')
v52UserPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52UserPortAddress"), (0, "ZhoneV52-MIB", "v52UserPortType"))
if mibBuilder.loadTexts: v52UserPortEntry.setStatus('current')
if mibBuilder.loadTexts: v52UserPortEntry.setDescription('User Port Entry.')
v52UserPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767)))
if mibBuilder.loadTexts: v52UserPortAddress.setStatus('current')
if mibBuilder.loadTexts: v52UserPortAddress.setDescription('User Port Address. If UserPortType is PSTN, valid range is 0..32767. If UserPortType is ISDN, valid range is 0..8175. Maximum value is 32767. The actual address range is further limited by the following rules: PSTN: v52IgPstnLayer3StartAddress <= v52UserPortAddress < v52IgPstnLayer3StartAddress + maximum_PSTN_users_allowed_per_IG ISDN: v52IgIsdnEnvFuncStartAddress <= v52UserPortAddress < v52IgIsdnEnvFuncStartAddress + maximum_ISDN_users_allowed_per_IG Further, the total number of user ports is restricted by the following rule: Total_Pstn_User_Ports + 2*Total_Isdn_Bri_User_Ports <= Total_User_Ports_Supported_Per_Platform. ISDN PRI is not supported by the current release. For the current 8 E1 release of Sechtor 100: -------------------------------------------- maximum_PSTN_users_allowed_per_IG is 1920. maximum_ISDN_users_allowed_per_IG is 960. maximum users supported on the entire Sechtor 100 is 4800. The maximum number of PSTN and ISDN user ports supported for the 16 E1 release will be updated in the near future.')
v52UserPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("pstn", 2), ("isdnBa", 3), ("isdnPra", 4))))
if mibBuilder.loadTexts: v52UserPortType.setStatus('current')
if mibBuilder.loadTexts: v52UserPortType.setDescription('User Port type. Valid values are unknown, pstn, isdnBa, isdnPra.')
v52UserPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2))).clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: v52UserPortAdminStatus.setDescription('UserPort Admin Status. Valid values are inService and outOfService. Default is outOfService.')
v52UserPortBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("blocked", 1), ("shuttingDown", 2), ("unblocked", 3), ("blockedNotSuitableForGroupUnblocking", 4))).clone('blocked')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortBlock.setStatus('current')
if mibBuilder.loadTexts: v52UserPortBlock.setDescription("The Q3 interface of the access network can request that a port be blocked for non-urgent configuration or reconfiguration. If the port is routed through a V5 interface to a local exchange, then this request can only be granted by the local exchange via the V5 interface. This is intended to avoid interference with calls in progress, or calls being set up or cleared down. The Q3 interface on the access network can request that a port be blocked for urgent configuration or reconfiguration. If the port is routed through a V5 interface to a local exchange, the other side of the interface shall be informed of this blocking via the V5 interface. Valid values are: * 'blocked' - the user port can be unblocked by both accelerated port alignment (i.e. group unblocking) and sequential port alignment. * 'shuttingDown' - same as 'blocked' except active calls will not be blocked until the calls are completed. * 'unblocked' - port will be unblocked regardless of its previous port block state. * 'blockedNotSuitableForGroupUnblocking' - the user port cannot be unblocked by accelerated port alignment unblocking but can be unblocked by sequential unblocking. Default value is blocked.")
v52UserPortBlockStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unblocked", 1), ("localBlocked", 2), ("remoteBlocked", 3), ("bothBlocked", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52UserPortBlockStatus.setStatus('current')
if mibBuilder.loadTexts: v52UserPortBlockStatus.setDescription('UserPortBlock operational status. Valid values are: * localBlocked - local is blocked * remoteBlocked - remote is blocked * bothBlocked - both local and remote are blocked * unblocked - both local and remote are unblocked')
v52UserPortRegOrLeaseUser = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("regular", 1), ("permanentLease", 2), ("semiPermanentLease", 3))).clone('regular')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortRegOrLeaseUser.setStatus('current')
if mibBuilder.loadTexts: v52UserPortRegOrLeaseUser.setDescription('User is a regular, permanent lease, or semi-permanent leaseuser. Valid values are regular, permanentLease, semiPermanentLease. Default is regular.')
v52UserPortIsdnDsCPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortIsdnDsCPathId.setStatus('current')
if mibBuilder.loadTexts: v52UserPortIsdnDsCPathId.setDescription('An ISDN user port can carry more than one type of the Ds-type, p-type and f-type data. When this user port is configured to carry Ds-type data, the value of this variable should be configured to be the value of the v52CPathID for the isdnDs CPath carrying the data. A value of 0 indicates the user port is not configured to carry Ds-type data.')
v52UserPortIsdnPCPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortIsdnPCPathId.setStatus('current')
if mibBuilder.loadTexts: v52UserPortIsdnPCPathId.setDescription('An ISDN user port can carry more than one type of the Ds-type, p-type and f-type data. When this user port is configured to carry p-type data, the value of this variable should be configured to be the value of the v52CPathID for the isdnP CPath carrying the data. A value of 0 indicates the user port is not configured to carry p-type data.')
v52UserPortIsdnFCPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortIsdnFCPathId.setStatus('current')
if mibBuilder.loadTexts: v52UserPortIsdnFCPathId.setDescription('An ISDN user port can carry more than one type of the Ds-type, p-type and f-type data. When this user port is configured to carry f-type data, the value of this variable should be configured to be the value of the v52CPathID for the isdnF CPath carrying the data. A value of 0 indicates the user port is not configured to carry f-type data.')
v52UserPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 10), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52UserPortRowStatus.setStatus('current')
if mibBuilder.loadTexts: v52UserPortRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) v52UserPortRowStatus set to'CreateAndGo', b) the following READ-CREATE object(s): * v52UserPortAddress If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. ")
v52UserPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inService", 1), ("manualOos", 2), ("oos", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52UserPortOperStatus.setStatus('current')
if mibBuilder.loadTexts: v52UserPortOperStatus.setDescription("User port operational status. Valid values are inService, manualOos and Oos. * 'inService' - the user port is ready to carry calls. * 'manualOos' - the user port has been manually put into OOS state. * 'oos' - the user port is in out of service state even though the port admin state is set to in service.")
v52StatsCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7), )
if mibBuilder.loadTexts: v52StatsCurrentTable.setStatus('current')
if mibBuilder.loadTexts: v52StatsCurrentTable.setDescription('The V5.2 Interface Group Statistics Current Table. The V5.2 Interface Group Statistics current table contains various statistics being collected for the current 15 minute interval. The maximum number of entries is identical to that of the Interface Group Table. The interfaceGroupTable is the base table for this augmented table.')
v52StatsCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1), )
v52InterfaceGroupEntry.registerAugmentions(("ZhoneV52-MIB", "v52StatsCurrentEntry"))
v52StatsCurrentEntry.setIndexNames(*v52InterfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: v52StatsCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: v52StatsCurrentEntry.setDescription("An entry in the v52StatsCurrentTable which AUGMENTS the base table v52InterfaceGroupTable. There is a 1-to-1 correspondence between rows in interfaceGroupTable and rows in this table. When a row is created in the base table interfaceGroupTable, the corresponding row in the augmenting table igStatsCurrentTable must also be simultaneously created. A row in this table is created by setting the value of igRowStatus to 'CreateAndGo' and setting the appropriate values for the columns. Likewise, when a row expires by setting the value of igRowStatus to 'destroy' in the interfaceGroupTable base table, the same row also expires in this augmenting table.")
v52IfCurrentPstnOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentPstnOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentPstnOutboundCalls.setDescription('The number of PSTN outbound calls completed.')
v52IfCurrentPstnInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentPstnInboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentPstnInboundCalls.setDescription('The number of PSTN inbound calls completed.')
v52IfCurrentCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentCallsBlocked.setDescription('The number of calls that were blocked due to no available time-slot.')
v52IfCurrentV52ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentV52ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentV52ProtocolErrors.setDescription('The number of V5.2 Protocol errors.')
v52IfCurrentLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentLapdSent.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentLapdSent.setDescription('The number of LAPD frames sent on all C-Paths for this interface group.')
v52IfCurrentLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentLapdRcvd.setDescription('The number LAPD frames received on all C-Paths for this interface group.')
v52IfCurrentLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentLapdRcvdErrs.setDescription('The number LAPD frames received in error on all C-Paths for this interface group.')
v52IfCurrentIsdnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 7, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfCurrentIsdnCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfCurrentIsdnCalls.setDescription('The number of ISDN calls completed.')
v52StatsIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8), )
if mibBuilder.loadTexts: v52StatsIntervalTable.setStatus('current')
if mibBuilder.loadTexts: v52StatsIntervalTable.setDescription('V5.2 Interface Group Statistics Interval Table. The V5.2 Interface Group Statistics Interval Table contains various statistics collected by each Interface Group over the previous 6. 12. 18, or 24 hours of operation. The past 6, 12, 18, or 24 hours are broken into 24, 48, 72, or 96 completed 15 minute intervals. Each row in this table represents one such interval (identified by igIntervalNumber) for one specific instance (identified by igIntervalIndex).')
v52StatsIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52IfIntervalNumber"))
if mibBuilder.loadTexts: v52StatsIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: v52StatsIntervalEntry.setDescription('An entry in the igStatsIntervalTable. Indexed by (igNameId, igIntervalNumber).')
v52IfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: v52IfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the 15 minutes interval completed 23 hours and 45 minutes prior to interval 1.')
v52IfIntervalPstnOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalPstnOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalPstnOutboundCalls.setDescription('The number of PSTN outbound calls completed.')
v52IfIntervalPstnInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalPstnInboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalPstnInboundCalls.setDescription('The number of PSTN inbound calls completed.')
v52IfIntervalCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalCallsBlocked.setDescription('The number of calls that were blocked due to no available time-slot.')
v52IfIntervalV52ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalV52ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalV52ProtocolErrors.setDescription('The number of V5.2 Protocol errors.')
v52IfIntervalLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalLapdSent.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalLapdSent.setDescription('The number of LAPD frames sent on all C-Paths for this interface group.')
v52IfIntervalLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalLapdRcvd.setDescription('The number LAPD frames received on all C-Paths for this interface group.')
v52IfIntervalLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalLapdRcvdErrs.setDescription('The number LAPD frames received in error on all C-Paths for this interface group.')
v52IfIntervalIsdnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 8, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfIntervalIsdnCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfIntervalIsdnCalls.setDescription('The number of ISDN calls completed.')
v52StatsTotalTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9), )
if mibBuilder.loadTexts: v52StatsTotalTable.setStatus('current')
if mibBuilder.loadTexts: v52StatsTotalTable.setDescription('V5.2 Interface Group Statistics Total Table. The V5.2 Interface Group Statistics Total Table contains the cumulative sum of the various statistics for the 24 hour period preceding the current interval. The maximum number of entries is identical to that of the Interface Group Table. The v52InterfaceGroupTable is the base table for this augmented table.')
v52StatsTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1), )
v52InterfaceGroupEntry.registerAugmentions(("ZhoneV52-MIB", "v52StatsTotalEntry"))
v52StatsTotalEntry.setIndexNames(*v52InterfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: v52StatsTotalEntry.setStatus('current')
if mibBuilder.loadTexts: v52StatsTotalEntry.setDescription("An entry in the v52StatsTotalTable which AUGMENTS the base table interfaceGroupTable. There is a 1-to-1 correspondence between rows in v52InterfaceGroupTable and rows in this table. When a row is created in the base table v52InterfaceGroupTable, the corresponding row in the augmenting table v52StatsTotalTable must also be simultaneously created. A row in this table is created by setting the value of v52IgRowStatus to 'CreateAndGo' and setting the appropriate values for the columns. Likewise, when a row expires by setting the value of v52IgRowStatus to 'destroy' in the v52InterfaceGroupTable base table, the same row also expires in this augmenting table.")
v52IfTotalPstnOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalPstnOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalPstnOutboundCalls.setDescription('The number of PSTN outbound calls completed.')
v52IfTotalPstnInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalPstnInboundCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalPstnInboundCalls.setDescription('The number of PSTN inbound calls completed.')
v52IfTotalCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalCallsBlocked.setDescription('The number of calls that were blocked due to no available time-slot.')
v52IfTotalV52ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalV52ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalV52ProtocolErrors.setDescription('The number of V5.2 Protocol errors.')
v52ifTotalLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52ifTotalLapdSent.setStatus('current')
if mibBuilder.loadTexts: v52ifTotalLapdSent.setDescription('The number of LAPD frames sent on all C-Paths for this interface group.')
v52IfTotalLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalLapdRcvd.setDescription('The number LAPD frames received on all C-Paths for this interface group.')
v52IfTotalLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalLapdRcvdErrs.setDescription('The number LAPD frames received in error on all C-Paths for this interface group.')
v52IfTotalIsdnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 9, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52IfTotalIsdnCalls.setStatus('current')
if mibBuilder.loadTexts: v52IfTotalIsdnCalls.setDescription('The number of ISDN calls completed.')
v52Traps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10))
if mibBuilder.loadTexts: v52Traps.setStatus('current')
if mibBuilder.loadTexts: v52Traps.setDescription('All the Zhone trap notifications for V5.2 managed objectes will be defined under v52Traps.')
v52TrapsPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0))
if mibBuilder.loadTexts: v52TrapsPrefix.setStatus('current')
if mibBuilder.loadTexts: v52TrapsPrefix.setDescription('This is the 0 prefix which is required for all v52 traps defined in SNMPv2.')
v52IgProvVariantRequestNotification = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 1)).setObjects(("ZhoneV52-MIB", "v52IgLocalInterfaceId"), ("ZhoneV52-MIB", "v52IgRemoteInterfaceId"), ("ZhoneV52-MIB", "v52IgLocalProvVariant"), ("ZhoneV52-MIB", "v52IgRemoteProvVariant"), ("ZhoneV52-MIB", "v52IgProvVariantRequest"), ("ZhoneV52-MIB", "v52IgProvVariantRequestStatus"))
if mibBuilder.loadTexts: v52IgProvVariantRequestNotification.setStatus('current')
if mibBuilder.loadTexts: v52IgProvVariantRequestNotification.setDescription("This is the notification response for a SNMP set on v52IgProvVariantRequest. This notification is generated only when request is initiatated from the AN side. When the AN responds to LE's request, the AN just updates v52IgRemoteInterfaceId and v52IgRemoteProvVariant.")
v52IgPortAlignmentNotification = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 2)).setObjects(("ZhoneV52-MIB", "v52IgPortAlignmentRequest"), ("ZhoneV52-MIB", "v52IgPortAlignmentStatus"))
if mibBuilder.loadTexts: v52IgPortAlignmentNotification.setStatus('current')
if mibBuilder.loadTexts: v52IgPortAlignmentNotification.setDescription("This is the notification response for a SNMP set on v52IgPortAlignmentRequest. The v52IgPortAlignmentRequest object indicates the type of request initiated by the operator. When the request is initiated by LE, v52IgPortAlignmentRequest has a value of 'noRequest'.")
v52LinkCheckIdNotification = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 3)).setObjects(("ZhoneV52-MIB", "v52LinkCheckId"), ("ZhoneV52-MIB", "v52LinkCheckIdStatus"))
if mibBuilder.loadTexts: v52LinkCheckIdNotification.setStatus('current')
if mibBuilder.loadTexts: v52LinkCheckIdNotification.setDescription("This is the notification response for a SNMP set on v52LinkCheckId. When Check Link ID is initiated by AN, v52LinkCheckId has a value of 'activated'. When Check Link ID is triggered by LE, v52LinkCheckId has a value of 'notActivated'.")
v52LinkBlockNotification = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 4)).setObjects(("ZhoneV52-MIB", "v52LinkBlock"), ("ZhoneV52-MIB", "v52LinkBlockStatus"))
if mibBuilder.loadTexts: v52LinkBlockNotification.setStatus('current')
if mibBuilder.loadTexts: v52LinkBlockNotification.setDescription('This is the notification response for a SNMP set on v52LinkBlock.')
v52IgOperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 5)).setObjects(("ZhoneV52-MIB", "v52IgAdminStatus"), ("ZhoneV52-MIB", "v52IgOperationalStatus"), ("ZhoneV52-MIB", "v52IgOperStatusCause"))
if mibBuilder.loadTexts: v52IgOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: v52IgOperStatusChange.setDescription('A v52IgOperStatusChange notification is sent out whenever the value of v52IgOperationalStatus changes.')
v52CChannelStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 6)).setObjects(("ZhoneV52-MIB", "v52CChannelRole"), ("ZhoneV52-MIB", "v52CChannelStatus"), ("ZhoneV52-MIB", "v52CChannelStatusCause"))
if mibBuilder.loadTexts: v52CChannelStatusChange.setStatus('current')
if mibBuilder.loadTexts: v52CChannelStatusChange.setDescription('A v52CChannelStatusChange notification is sent out whenever the value of v52ChannelStatus changes.')
v52CPathOperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 7)).setObjects(("ZhoneV52-MIB", "v52CPathOperStatus"), ("ZhoneV52-MIB", "v52CPathOperStatusCause"))
if mibBuilder.loadTexts: v52CPathOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: v52CPathOperStatusChange.setDescription("A v52CPathOperStatusChange notification is sent out whenever the value of v52CPathOperStatus changes. This notificatoin will only be generated for pstn, ctrl, bcc and lctl CPath's.")
v52ProtectionCPathOperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 10, 0, 8)).setObjects(("ZhoneV52-MIB", "v52ProtectionCPathOperStatus"), ("ZhoneV52-MIB", "v52ProtectionCPathOperStatusCause"))
if mibBuilder.loadTexts: v52ProtectionCPathOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathOperStatusChange.setDescription("A v52ProtectionCPathOperStatusChange notification is sent out whenever the value of v52ProtectionCPathOperStatus changes. The protection C-Path is identified by its igNameId and C-Path id in the instance OID's in the OBJECTS list.")
v52IgExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11), )
if mibBuilder.loadTexts: v52IgExtensionTable.setStatus('current')
if mibBuilder.loadTexts: v52IgExtensionTable.setDescription('This is the extension of the v52InterfaceGroupTable for extra configuration and monitoring variables for the V5.2 interface group.')
v52IgExtensionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11, 1), )
v52InterfaceGroupEntry.registerAugmentions(("ZhoneV52-MIB", "v52IgExtensionEntry"))
v52IgExtensionEntry.setIndexNames(*v52InterfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: v52IgExtensionEntry.setStatus('current')
if mibBuilder.loadTexts: v52IgExtensionEntry.setDescription('An entry in the v52IgExtensionTable. v52IgExtensionEntry is augmented to v52InterfaceGroupEntry. Whenever a row is created or destroyed for the v52InterfaceGroupEntry, the same row should also be created or destroyed for the v52IgExtensionEntry. ')
v52IgStartupCheckLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgStartupCheckLinkId.setStatus('current')
if mibBuilder.loadTexts: v52IgStartupCheckLinkId.setDescription("This variable indicates whether or not Link ID check will be performed when a V5.2 interface is starting up. The default value is 'false'.")
v52IgStartupUnblockUserPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgStartupUnblockUserPorts.setStatus('current')
if mibBuilder.loadTexts: v52IgStartupUnblockUserPorts.setDescription("This variable indicates whether or not user ports will be unblocked when a V5.2 interface is starting up. The default value is 'false'.")
v52IgLinkOutOfServiceTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(2500)).setUnits('milliseconds.').setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLinkOutOfServiceTimer.setStatus('current')
if mibBuilder.loadTexts: v52IgLinkOutOfServiceTimer.setDescription('This timer specifies the length of time a Link must be in a failed state before the interface declares the link failed. This timer value should always exceed the equivalent value on the LE. Valid range for the value is 50..10000 milliseconds and the default value is 2500 milliseconds. ')
v52IgLinkInServiceTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 10000)).clone(200)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: v52IgLinkInServiceTimer.setStatus('current')
if mibBuilder.loadTexts: v52IgLinkInServiceTimer.setDescription('This timer specifies the length of time a Link must be in a framed state before the interface declares the link in service. This timer value should always be less than the equivalent value on the LE. Valid range for the value is 50..10000 milliseconds and the default value is 200 milliseconds.')
v52ProtectionCPathTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 12), )
if mibBuilder.loadTexts: v52ProtectionCPathTable.setReference('Section 18.1.2, ETSI EN 300 347-1 V2.2.2 (1999-12)')
if mibBuilder.loadTexts: v52ProtectionCPathTable.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathTable.setDescription('This table is read-only and is derived from the protection group provisioning information from the v52CChannelTable. Unlike the C-Paths defined in v52CPathTable, C-Paths for the protection protocol are not carried over logical C-Channels. For each Interface Group, there will always be two C-Paths for protection protcol when an active and a standby CChannel are provisioned in protection group 1. The active and standby C-Channels for the group 1 protection shall always carry the two C-Paths for the protection protocol respectively and the protection C-Paths shall not be switched by the protection mechanism. When an Interface Group has no protection group provisioned in the v52CChannelTable, there will be no entries in this table for this Interface Group.')
v52ProtectionCPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 12, 1), ).setIndexNames((0, "ZhoneV52-MIB", "v52IgNameId"), (0, "ZhoneV52-MIB", "v52ProtectionCPathId"))
if mibBuilder.loadTexts: v52ProtectionCPathEntry.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathEntry.setDescription('An entry in the v52ProtectionCPathTable. The maximum number of entryies for this table is two.')
v52ProtectionCPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: v52ProtectionCPathId.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathId.setDescription('The valid value range is 1..2. v52ProtectionCPathId 1 refers to the C-Path for protection running on the provisioned active C-Channel in protection group 1. v52ProtectionCPathId 2 refers to the C-Path for protection running on the provisioned standby C-Channel in protection group 1. When an Interface Group is provisioned correctly and there are one active C-Channel and one standby C-Channel provisioned in group 1 protection group for that IG, protection C_Paths with ProtectionCPathId 1 and 2 will be automatically created for that IG.')
v52ProtectionCPathOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52ProtectionCPathOperStatus.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathOperStatus.setDescription('This variable indicates the operational status of the protection CPath. The valid values are up(1) or down(2).')
v52ProtectionCPathOperStatusCause = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("establishConfirmationReceived", 1), ("establishIndicationReceived", 2), ("releaseIndicationReceived", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v52ProtectionCPathOperStatusCause.setStatus('current')
if mibBuilder.loadTexts: v52ProtectionCPathOperStatusCause.setDescription('Cause for v52ProtectionCPathOperStatus. Valid values are: * establishConfirmationReceived - the data link has been successfully established upon a local request. * establishIndicationReceived - the data link has been successfully established upon its peer request. * releaseIndicationReceived - the data link has failed because of either Layer 1 failure or no frame exchange with the peer was possible within the given time frame (after T203 timer expiry, followed by T200 timer expiry N200 times).')
mibBuilder.exportSymbols("ZhoneV52-MIB", v52IfIntervalPstnInboundCalls=v52IfIntervalPstnInboundCalls, v52UserPortAdminStatus=v52UserPortAdminStatus, v52CChannelCurrentLogicalChannelId=v52CChannelCurrentLogicalChannelId, v52IgRemoteProvVariant=v52IgRemoteProvVariant, v52CPathOperStatus=v52CPathOperStatus, v52IfCurrentPstnOutboundCalls=v52IfCurrentPstnOutboundCalls, v52LinkCheckIdStatus=v52LinkCheckIdStatus, v52IfCurrentLapdSent=v52IfCurrentLapdSent, v52CChannelLogicalChannelId=v52CChannelLogicalChannelId, v52CPathOperStatusChange=v52CPathOperStatusChange, v52IfCurrentIsdnCalls=v52IfCurrentIsdnCalls, v52IfCurrentPstnInboundCalls=v52IfCurrentPstnInboundCalls, v52IgLinkInServiceTimer=v52IgLinkInServiceTimer, v52IgStartupCheckLinkId=v52IgStartupCheckLinkId, v52IgPortAlignmentRequest=v52IgPortAlignmentRequest, v52IfIntervalV52ProtocolErrors=v52IfIntervalV52ProtocolErrors, v52IgPeerShelf=v52IgPeerShelf, v52StatsTotalEntry=v52StatsTotalEntry, v52LinkBlockNotification=v52LinkBlockNotification, v52IgPeerStatus=v52IgPeerStatus, v52IfTotalCallsBlocked=v52IfTotalCallsBlocked, v52IgLocalProvVariant=v52IgLocalProvVariant, v52IgOperationalStatus=v52IgOperationalStatus, v52CPathRowStatus=v52CPathRowStatus, v52LinkDsnLgId=v52LinkDsnLgId, v52StatsCurrentEntry=v52StatsCurrentEntry, PYSNMP_MODULE_ID=zhoneV52, v52IgLapvN201=v52IgLapvN201, v52CPathEntry=v52CPathEntry, v52CChannelStatusChange=v52CChannelStatusChange, v52IgRowStatus=v52IgRowStatus, v52UserPortAddress=v52UserPortAddress, v52IfTotalPstnOutboundCalls=v52IfTotalPstnOutboundCalls, v52InterfaceGroupLapvTable=v52InterfaceGroupLapvTable, v52LinkCheckIdNotification=v52LinkCheckIdNotification, v52LinkBlock=v52LinkBlock, v52IgMaxConfiguredCalls=v52IgMaxConfiguredCalls, v52LinkCheckId=v52LinkCheckId, v52IfIntervalLapdRcvd=v52IfIntervalLapdRcvd, v52ProtectionCPathTable=v52ProtectionCPathTable, v52Traps=v52Traps, v52IgCurrActiveCalls=v52IgCurrActiveCalls, v52CChannelTable=v52CChannelTable, v52IfIntervalNumber=v52IfIntervalNumber, v52IfCurrentLapdRcvd=v52IfCurrentLapdRcvd, v52IfIntervalLapdSent=v52IfIntervalLapdSent, v52IgStatsInvalidIntervals=v52IgStatsInvalidIntervals, v52IfTotalV52ProtocolErrors=v52IfTotalV52ProtocolErrors, v52CPathLogicalChannelId=v52CPathLogicalChannelId, v52LinkBlockStatus=v52LinkBlockStatus, v52StatsIntervalTable=v52StatsIntervalTable, v52CPathTable=v52CPathTable, v52LinkEntry=v52LinkEntry, v52IgPeerSlot=v52IgPeerSlot, v52UserPortOperStatus=v52UserPortOperStatus, v52UserPortRowStatus=v52UserPortRowStatus, v52CPathOperStatusCause=v52CPathOperStatusCause, v52ProtectionCPathEntry=v52ProtectionCPathEntry, v52CChannelEntry=v52CChannelEntry, v52IgRemoteInterfaceId=v52IgRemoteInterfaceId, v52IgOperStatusChange=v52IgOperStatusChange, v52IgNationalPstnRegion=v52IgNationalPstnRegion, v52IgLocalInterfaceId=v52IgLocalInterfaceId, v52IgPortAlignmentNotification=v52IgPortAlignmentNotification, v52IgLapvN200=v52IgLapvN200, v52IgProtocolSpecification=v52IgProtocolSpecification, v52ifTotalLapdSent=v52ifTotalLapdSent, v52UserPortIsdnPCPathId=v52UserPortIsdnPCPathId, v52IgNameId=v52IgNameId, v52IfIntervalCallsBlocked=v52IfIntervalCallsBlocked, v52ProtectionCPathId=v52ProtectionCPathId, v52IgOperStatusCause=v52IgOperStatusCause, v52CChannelRowStatus=v52CChannelRowStatus, v52StatsIntervalEntry=v52StatsIntervalEntry, v52IgLinkOutOfServiceTimer=v52IgLinkOutOfServiceTimer, v52UserPortRegOrLeaseUser=v52UserPortRegOrLeaseUser, v52StatsCurrentTable=v52StatsCurrentTable, v52CChannelProtGp=v52CChannelProtGp, v52IfCurrentCallsBlocked=v52IfCurrentCallsBlocked, v52IfIntervalPstnOutboundCalls=v52IfIntervalPstnOutboundCalls, v52IfCurrentLapdRcvdErrs=v52IfCurrentLapdRcvdErrs, v52IgProvVariantRequestNotification=v52IgProvVariantRequestNotification, v52CChannelRole=v52CChannelRole, v52UserPortEntry=v52UserPortEntry, v52IfIntervalIsdnCalls=v52IfIntervalIsdnCalls, v52IgStatsValidIntervals=v52IgStatsValidIntervals, v52ProtectionCPathOperStatusChange=v52ProtectionCPathOperStatusChange, v52IgExtensionEntry=v52IgExtensionEntry, v52IgPortAlignmentStatus=v52IgPortAlignmentStatus, v52IgPstnLayer3StartAddress=v52IgPstnLayer3StartAddress, v52CChannelStatusCause=v52CChannelStatusCause, v52UserPortBlock=v52UserPortBlock, v52TrapsPrefix=v52TrapsPrefix, v52IgShelf=v52IgShelf, v52UserPortTable=v52UserPortTable, v52LinkId=v52LinkId, v52IgStatsTimeElapsed=v52IgStatsTimeElapsed, v52CPathType=v52CPathType, v52InterfaceGroupEntry=v52InterfaceGroupEntry, v52ProtectionCPathOperStatusCause=v52ProtectionCPathOperStatusCause, v52UserPortIsdnFCPathId=v52UserPortIsdnFCPathId, v52UserPortBlockStatus=v52UserPortBlockStatus, v52UserPortType=v52UserPortType, v52IgLapvMaxOutstandingFrames=v52IgLapvMaxOutstandingFrames, v52IgExtensionTable=v52IgExtensionTable, v52LinkTable=v52LinkTable, v52IgSlot=v52IgSlot, v52IgStartupUnblockUserPorts=v52IgStartupUnblockUserPorts, v52IfTotalLapdRcvd=v52IfTotalLapdRcvd, v52ProtectionCPathOperStatus=v52ProtectionCPathOperStatus, v52CPathId=v52CPathId, v52InterfaceGroupTable=v52InterfaceGroupTable, v52StatsTotalTable=v52StatsTotalTable, v52CChannelTimeSlotIndex=v52CChannelTimeSlotIndex, v52IgAdminStatus=v52IgAdminStatus, v52IgSwitchVendor=v52IgSwitchVendor, v52LinkDs1ChannelNumber=v52LinkDs1ChannelNumber, v52IfIntervalLapdRcvdErrs=v52IfIntervalLapdRcvdErrs, v52IfCurrentV52ProtocolErrors=v52IfCurrentV52ProtocolErrors, v52IgProvVariantRequestStatus=v52IgProvVariantRequestStatus, v52IgProvVariantRequest=v52IgProvVariantRequest, v52IgLapvT203=v52IgLapvT203, v52IfTotalLapdRcvdErrs=v52IfTotalLapdRcvdErrs, v52LinkAdminStatus=v52LinkAdminStatus, v52IfTotalIsdnCalls=v52IfTotalIsdnCalls, v52LinkRowStatus=v52LinkRowStatus, v52InterfaceGroupLapvEntry=v52InterfaceGroupLapvEntry, v52IfTotalPstnInboundCalls=v52IfTotalPstnInboundCalls, zhoneV52=zhoneV52, v52IgLapvT200=v52IgLapvT200, v52CChannelStatus=v52CChannelStatus, v52UserPortIsdnDsCPathId=v52UserPortIsdnDsCPathId, v52IgIsdnEnvFuncStartAddress=v52IgIsdnEnvFuncStartAddress)

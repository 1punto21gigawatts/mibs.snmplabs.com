#
# PySNMP MIB module ITOUCH-X25-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ITOUCH-X25-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
iTouch, = mibBuilder.importSymbols("ITOUCH-MIB", "iTouch")
X121Address, = mibBuilder.importSymbols("RFC1382-MIB", "X121Address")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Counter64, NotificationType, Integer32, Gauge32, ModuleIdentity, MibIdentifier, iso, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "NotificationType", "Integer32", "Gauge32", "ModuleIdentity", "MibIdentifier", "iso", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xX25 = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 20))
xX25ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 33, 20, 4), )
if mibBuilder.loadTexts: xX25ChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelTable.setDescription('Entries of xX25Channel Table.')
xX25ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 20, 4, 1), ).setIndexNames((0, "ITOUCH-X25-MIB", "xX25ChannelIndex"))
if mibBuilder.loadTexts: xX25ChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelEntry.setDescription('Entries of xX25ChannelTable.')
xX25ChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xX25ChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelIndex.setDescription('The ifIndex value for the X.25 physical link.')
xX25ChannelLowPVC = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25ChannelLowPVC.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelLowPVC.setDescription("Lowest PVC channel. Setting it to zero indicates 'none', and will also set the xX25ChannelHighPVC to zero. If set to a non-zero value and xX25ChannelHighPVC is zero, xX25ChannelHighPVC will be set to the same value. Otherwise, xX25ChannelLowPVC must be less than or equal to xX25ChannelHighPVC.")
xX25ChannelHighPVC = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25ChannelHighPVC.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelHighPVC.setDescription('Highest PVC channel. Setting it to 0 indicates none, and will also set the xX25ChannelLowPVC to 0. If set to a non-zero value and xX25ChannelLowPVC is zero, xX25ChannelLowPVC will be set to the same value. Otherwise, xX25ChannelHighPVC must be less than or equal to xX25ChannelLowPVC.')
xX25ChannelNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ccitt", 1), ("ddnStandard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25ChannelNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelNetwork.setDescription('The type of network being run.')
xX25ChannelMaxPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25ChannelMaxPrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelMaxPrecedence.setDescription('The maximum level of IP precedence supported.')
xX25ChannelStdVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25ChannelStdVersion.setStatus('mandatory')
if mibBuilder.loadTexts: xX25ChannelStdVersion.setDescription('The standard year supported by x25. Values are usually 1980 or 1984 (the default).')
xX25VcCfgTable = MibTable((1, 3, 6, 1, 4, 1, 33, 20, 6), )
if mibBuilder.loadTexts: xX25VcCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgTable.setDescription('These objects contain information about the virtual circuit configuration in an X.25 PLE. These values are the configured values for circuits that may or may not be connected. Unconfigured calls may be added to this table as calls are accepted.')
xX25VcCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 20, 6, 1), ).setIndexNames((0, "ITOUCH-X25-MIB", "xX25VcCfgIndex"))
if mibBuilder.loadTexts: xX25VcCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgEntry.setDescription('Entries of the xX25VcCfgTable.')
xX25VcCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xX25VcCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgIndex.setDescription('An arbitrary index value for the virtual circuit.')
xX25VcCfgPartnerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 2), X121Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgPartnerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgPartnerAddr.setDescription("Partner's X.121 Address.")
xX25VcCfgInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgInterfaceIndex.setDescription('ifIndex of ITouch logical interface associated with this VC.')
xX25VcCfgLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgLinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgLinkIndex.setDescription('ifIndex of physical link on which this VC resides.')
xX25VcCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("appleTalk", 1), ("bridged", 2), ("decnet", 3), ("ip", 4), ("ipx", 5), ("multiProtocol", 6), ("osi", 7))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgProtocol.setDescription('Protocol which is being encapsulated by this VC.')
xX25VcCfgEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("null", 1), ("dedicated", 2), ("snap", 3))).clone('dedicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgEncapsulation.setDescription('Encapsulation method used by this VC.')
xX25VcCfgPvc = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgPvc.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgPvc.setDescription('Channel number if VC is a PVC, else 0. The value must be in the range of xX25ChannelLowPVC to xX25ChannelHighPVC')
xX25VcCfgPartnerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgPartnerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgPartnerIpAddress.setDescription('IP address of the partner over this VC. This must be configured if IP packets will not be MAC-encapsulated.')
xX25VcCfgClearFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2))).clone('ready')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgClearFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgClearFacilities.setDescription("Control to clear the VC call facilities string. In response to a get-request or get-next-request, the agent always returns 'ready' for this value. Setting the value to 'ready' has no effect. Setting it to 'execute' causes the string to be cleared.")
xX25VcCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25VcCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xX25VcCfgStatus.setDescription("Setting to 'invalid' removes this VC from the table. If 'valid', setting to 'valid' has no effect, otherwise it creates an entry.")
xX25LinkTable = MibTable((1, 3, 6, 1, 4, 1, 33, 20, 7), )
if mibBuilder.loadTexts: xX25LinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkTable.setDescription('These objects contain information about the configuration of the X.25 physical links necessary for the ITouch Bridge/Router. Unless otherwise noted, changes to these objects require that the X.25 physical link be restarted in order for the changes to take effect.')
xX25LinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 20, 7, 1), ).setIndexNames((0, "ITOUCH-X25-MIB", "xX25LinkIndex"))
if mibBuilder.loadTexts: xX25LinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkEntry.setDescription('Entries of the xX25LinkTable.')
xX25LinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xX25LinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkIndex.setDescription('The ifIndex value for a ITouch physical link.')
xX25LinkRRDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkRRDelay.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkRRDelay.setDescription('Number of packets received before an RR will be sent. The value must be less than the xX25CallParmInWindowSize. Modifying this object does not require the X.25 physical link to be restarted. 0 indicates that RR will not be sent.')
xX25LinkIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkIdleTimeout.setDescription('Length of time in minutes that a virtual circuit may be idle before the circuit will be cleared. Modifying this object does not require the X.25 physical link to be restarted.')
xX25LinkHoldDownTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkHoldDownTimer.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkHoldDownTimer.setDescription('Length of time in minutes after a virtual circuit has been cleared before it may make a call again. Modifying this object does not require the X.25 physical link to be restarted.')
xX25LinkAccUncfgCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkAccUncfgCalls.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkAccUncfgCalls.setDescription('Indicates whether unconfigured, non-reverse charged calls will be accepted. Modifying this object does not require the X.25 physical link to be restarted.')
xX25LinkDefWindSize = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefWindSize.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkDefWindSize.setDescription('Default packet level window size for this link.')
xX25LinkMaxWindSize = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkMaxWindSize.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkMaxWindSize.setDescription('Maximum packet level window size for this link.')
xX25LinkDefPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 64, 128, 256, 512, 1024, 2048, 4096))).clone(namedValues=NamedValues(("bytes16", 16), ("bytes32", 32), ("bytes64", 64), ("bytes128", 128), ("bytes256", 256), ("bytes512", 512), ("bytes1024", 1024), ("bytes2048", 2048), ("bytes4096", 4096)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkDefPktSize.setDescription('Default packet size for this link.')
xX25LinkDefThrptClassIn = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200, 48000))).clone(namedValues=NamedValues(("bps75", 75), ("bps150", 150), ("bps300", 300), ("bps600", 600), ("bps1200", 1200), ("bps2400", 2400), ("bps4800", 4800), ("bps9600", 9600), ("bps19200", 19200), ("bps48000", 48000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefThrptClassIn.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkDefThrptClassIn.setDescription('Default input throughput class for this link.')
xX25LinkDefThrptClassOut = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200, 48000))).clone(namedValues=NamedValues(("bps75", 75), ("bps150", 150), ("bps300", 300), ("bps600", 600), ("bps1200", 1200), ("bps2400", 2400), ("bps4800", 4800), ("bps9600", 9600), ("bps19200", 19200), ("bps48000", 48000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefThrptClassOut.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkDefThrptClassOut.setDescription('Default output throughput class for this link.')
xX25LinkDefThrptClassInMsk = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200, 48000))).clone(namedValues=NamedValues(("bps75", 75), ("bps150", 150), ("bps300", 300), ("bps600", 600), ("bps1200", 1200), ("bps2400", 2400), ("bps4800", 4800), ("bps9600", 9600), ("bps19200", 19200), ("bps48000", 48000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefThrptClassInMsk.setStatus('deprecated')
if mibBuilder.loadTexts: xX25LinkDefThrptClassInMsk.setDescription('Default incoming throughput class mask for this link.')
xX25LinkDefThrptClassOutMsk = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(75, 150, 300, 600, 1200, 2400, 4800, 9600, 19200, 48000))).clone(namedValues=NamedValues(("bps75", 75), ("bps150", 150), ("bps300", 300), ("bps600", 600), ("bps1200", 1200), ("bps2400", 2400), ("bps4800", 4800), ("bps9600", 9600), ("bps19200", 19200), ("bps48000", 48000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefThrptClassOutMsk.setStatus('deprecated')
if mibBuilder.loadTexts: xX25LinkDefThrptClassOutMsk.setDescription('Default outgoing throughput class mask for this link.')
xX25LinkFlowCtrlNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkFlowCtrlNeg.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkFlowCtrlNeg.setDescription('Indicates whether flow control negotiation will be performed on this link.')
xX25LinkThrptClassNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkThrptClassNeg.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkThrptClassNeg.setDescription('Indicates whether throughput class negotiation will be performed on this link.')
xX25LinkICallBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkICallBarred.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkICallBarred.setDescription('Indicates whether incoming calls are barred on this link.')
xX25LinkOCallBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkOCallBarred.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkOCallBarred.setDescription('Indicates whether outgoing calls are barred on this link.')
xX25LinkOneOut = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkOneOut.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkOneOut.setDescription('Indicates whether the link supports one way outgoing channels.')
xX25LinkOneIn = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkOneIn.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkOneIn.setDescription('Indicates whether the link supports one way incoming channels.')
xX25LinkRevChargeAcc = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkRevChargeAcc.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkRevChargeAcc.setDescription('Indicates whether reverse charge acceptance may be configured on this link.')
xX25LinkLocalChargePrevent = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkLocalChargePrevent.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkLocalChargePrevent.setDescription('Indicates whether local charge prevention may be configured on the link.')
xX25LinkRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkRpoa.setDescription('Indicates whether RPOA may be configured on the link.')
xX25LinkNui = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkNui.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkNui.setDescription('Indicates whether NUI may be configured on the link.')
xX25LinkMaxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 64, 128, 256, 512, 1024))).clone(namedValues=NamedValues(("bytes16", 16), ("bytes32", 32), ("bytes64", 64), ("bytes128", 128), ("bytes256", 256), ("bytes512", 512), ("bytes1024", 1024)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkMaxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkMaxPacketSize.setDescription('Maximum size of packets on the link.')
xX25LinkInsertCallingAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkInsertCallingAddr.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkInsertCallingAddr.setDescription("Indicates whether the caller's X.121 address should be inserted into the the call request packet.")
xX25LinkDefaultInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 20, 7, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xX25LinkDefaultInterface.setStatus('mandatory')
if mibBuilder.loadTexts: xX25LinkDefaultInterface.setDescription("The ITouch logical ifIndex to which new SVCs should be attached, when 'accept unconfigured calls' is enabled. A value of zero means 'create a new interface'.")
mibBuilder.exportSymbols("ITOUCH-X25-MIB", xX25LinkAccUncfgCalls=xX25LinkAccUncfgCalls, xX25LinkDefaultInterface=xX25LinkDefaultInterface, xX25LinkLocalChargePrevent=xX25LinkLocalChargePrevent, xX25ChannelHighPVC=xX25ChannelHighPVC, xX25LinkIdleTimeout=xX25LinkIdleTimeout, xX25ChannelIndex=xX25ChannelIndex, xX25LinkMaxPacketSize=xX25LinkMaxPacketSize, xX25ChannelLowPVC=xX25ChannelLowPVC, xX25VcCfgTable=xX25VcCfgTable, xX25VcCfgIndex=xX25VcCfgIndex, xX25VcCfgInterfaceIndex=xX25VcCfgInterfaceIndex, xX25VcCfgStatus=xX25VcCfgStatus, xX25LinkNui=xX25LinkNui, xX25ChannelNetwork=xX25ChannelNetwork, xX25LinkRevChargeAcc=xX25LinkRevChargeAcc, xX25LinkIndex=xX25LinkIndex, xX25LinkHoldDownTimer=xX25LinkHoldDownTimer, xX25VcCfgPartnerAddr=xX25VcCfgPartnerAddr, xX25VcCfgClearFacilities=xX25VcCfgClearFacilities, xX25LinkRRDelay=xX25LinkRRDelay, xX25LinkMaxWindSize=xX25LinkMaxWindSize, xX25LinkTable=xX25LinkTable, xX25VcCfgEntry=xX25VcCfgEntry, xX25LinkInsertCallingAddr=xX25LinkInsertCallingAddr, xX25LinkDefPktSize=xX25LinkDefPktSize, xX25LinkOneIn=xX25LinkOneIn, xX25LinkOneOut=xX25LinkOneOut, xX25VcCfgPvc=xX25VcCfgPvc, xX25LinkDefThrptClassInMsk=xX25LinkDefThrptClassInMsk, xX25VcCfgLinkIndex=xX25VcCfgLinkIndex, xX25LinkEntry=xX25LinkEntry, xX25ChannelEntry=xX25ChannelEntry, xX25VcCfgPartnerIpAddress=xX25VcCfgPartnerIpAddress, xX25ChannelTable=xX25ChannelTable, xX25LinkDefThrptClassIn=xX25LinkDefThrptClassIn, xX25LinkDefWindSize=xX25LinkDefWindSize, xX25LinkFlowCtrlNeg=xX25LinkFlowCtrlNeg, xX25LinkRpoa=xX25LinkRpoa, xX25LinkThrptClassNeg=xX25LinkThrptClassNeg, xX25VcCfgEncapsulation=xX25VcCfgEncapsulation, xX25VcCfgProtocol=xX25VcCfgProtocol, xX25LinkDefThrptClassOut=xX25LinkDefThrptClassOut, xX25LinkOCallBarred=xX25LinkOCallBarred, xX25ChannelStdVersion=xX25ChannelStdVersion, xX25LinkICallBarred=xX25LinkICallBarred, xX25=xX25, xX25LinkDefThrptClassOutMsk=xX25LinkDefThrptClassOutMsk, xX25ChannelMaxPrecedence=xX25ChannelMaxPrecedence)

#
# PySNMP MIB module INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:54:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
chassis, = mibBuilder.importSymbols("INTELCORPORATION-MULTI-FLEX-SERVER-MIB", "chassis")
groups, regModule = mibBuilder.importSymbols("INTELCORPORATION-MULTI-FLEX-SERVER-REG", "groups", "regModule")
Index, Power, Presence, FaultLedStates, INT32withException, PresenceLedStates, PowerLedStates, IdromBinary16 = mibBuilder.importSymbols("INTELCORPORATION-MULTI-FLEX-SERVER-TC", "Index", "Power", "Presence", "FaultLedStates", "INT32withException", "PresenceLedStates", "PowerLedStates", "IdromBinary16")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter32, Integer32, MibIdentifier, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, ObjectIdentity, Gauge32, Unsigned32, NotificationType, IpAddress, TimeTicks, ModuleIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Integer32", "MibIdentifier", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "ObjectIdentity", "Gauge32", "Unsigned32", "NotificationType", "IpAddress", "TimeTicks", "ModuleIdentity", "Bits")
MacAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "DisplayString")
multiFlexServerBladesMibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 1, 1, 12))
multiFlexServerBladesMibModule.setRevisions(('2008-05-19 20:28', '2008-05-07 02:40', '2007-09-19 15:40', '2007-08-31 09:30', '2007-08-29 19:30', '2007-08-29 14:30', '2007-08-27 16:00', '2007-08-22 15:45', '2007-08-20 15:30', '2007-08-16 13:30', '2007-07-27 15:30', '2007-07-09 12:30', '2007-07-05 16:00', '2007-05-21 14:00', '2007-05-21 14:00', '2007-04-09 10:30', '2007-03-14 11:00', '2007-03-13 18:00', '2007-03-06 10:30', '2007-02-22 17:00', '2006-11-07 07:01', '2006-10-01 18:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: multiFlexServerBladesMibModule.setRevisionsDescriptions(('Added bladeBootCount column to bladeTable', "Added additional documentation to blade's power led; also made settable to overload it as a means of controlling the blade's power", 'Renamed smbiosHandle to just handle to remove confusion', 'Added bladeMemoryTable', 'Reworked CPU table so that the SMBIOS handle is now the key, rather than the name of the CPU slot. This same handle will be used for other SMBIOS related tables later (e.g., DIMMs).', 'Added bladeNicTable Moved bladeProcessorTable & bladeMemorySummaryTable.', 'Added more information about the individual blades bladeTable: bladeConsoleRedirection bladeLegacyOsRedirection ', 'Added more information about the individual blades: to bladeMSNumFailed account for failed DIMMs rather than failed memory size', 'Added bladeMemorySummaryTable', 'Reordered Revision to reverse chronological as some browsers choke, cleaned up some other simple nit-picky errors', 'Added Processor table providing information as described by the SMBIOS from the blades', 'Dropped Most of the SMBIOS data for feature complete. Will be added back in as time allots Dropped fruIndex and replaced it with fruType as they are identical, moved fruPresence to second column to be consistent with other tables Dropped bladeFruFirmwareVersion', 'Dropped DAS support (on board drives) Dropped S-State information. Dropped Information about the SAS Controller/option ROM', 'Changed out the INTEGERs to INT32withException in static tables to be able to display enumerations when exceptions occur. Moved the Presence to the first column passed the index to be consistent with the other tables', 'Added enumerations to bladeTable numerics to flag unknown and notApplicable states to differentiate from actual values Also Added a blade presence column to bladeTable. Originally, this was to be included solely within the bladeFruTable, but it just rubbed wrong.', 'Renamed bladeBmcVersion to bladeBmcFirmwareVersion to be consistent in naming with other subsystems', 'Dropped bmcMacTable', 'Moved FirmwareBundleId from chassis to CMM Tree. cmmTable data now complies with IDROM (DID/DSD) information. Added cmmPowerLedStates, cmmFaultLedStates, & cmmPresenceLedStates to cmmTable. Renamed fruTable to bladeFruTable (to avoid conflicts in other MIBs) Added ebfFirmwareVersion. Added cmmFirmwareVersion. Added maxLocalDrives, numOfLocalDrives, & bladeLocalDrivePresenceMask to the bladeFruTable Moved cpuSState to the bladeTable (as sState) Added mState (albiet as a token for the moment) to the bladeTable Renumbered / reorganized accordingly', "Changed Mask representations from an Opaque to a DisplayString at the request of the architects such that it now is an ASCII representation of bit string reflecting the presence with the left most 'bit' being bit 1 and max* bits being represented. Due to the new nomenclature, new columns were added to match the masks changed within the FRU table Removed the sasIdTable Everything has been renumbered and resequenced", 'Renamed MIB file and updated internal relevance to formal product name Multi-Flex Server', "Consolidated use of Presence datatype and changed 'theChassis' to 'chassis'", "Partitioned off and created as it's own module",))
if mibBuilder.loadTexts: multiFlexServerBladesMibModule.setLastUpdated('200805192028Z')
if mibBuilder.loadTexts: multiFlexServerBladesMibModule.setOrganization('Intel Corporation')
if mibBuilder.loadTexts: multiFlexServerBladesMibModule.setContactInfo('Brian Kurle Intel Corporation JF5-2-C3 Tel: 503-712-5032 E-Mail: brianx.j.kurle@intel.com')
if mibBuilder.loadTexts: multiFlexServerBladesMibModule.setDescription('Blade Module of the Multi-Flex Server')
maxBlades = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxBlades.setStatus('current')
if mibBuilder.loadTexts: maxBlades.setDescription('Maximum number of Blades possible in this chassis.')
numOfBlades = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numOfBlades.setStatus('current')
if mibBuilder.loadTexts: numOfBlades.setDescription('The number of Blades in the system.')
bladePresenceMask = MibScalar((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 32), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladePresenceMask.setStatus('current')
if mibBuilder.loadTexts: bladePresenceMask.setDescription("ASCII representation of bit string reflecting the presence of the blades with the left most 'bit' being bit 1 and maxBlades bits being represented. Thus, '010011' would express that blades 2, 5, & 6 (of six blades) are present")
blades = ObjectIdentity((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202))
if mibBuilder.loadTexts: blades.setStatus('current')
if mibBuilder.loadTexts: blades.setDescription('Container for Blade specific information as well as all components logically contained within.')
bladeTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1), )
if mibBuilder.loadTexts: bladeTable.setStatus('current')
if mibBuilder.loadTexts: bladeTable.setDescription('Each row describes a Blade in the chassis. Note, all blade rows possible for a chassis are present so that the presence field is accessible even when the blade is not.')
bladeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1), ).setIndexNames((0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"))
if mibBuilder.loadTexts: bladeEntry.setStatus('current')
if mibBuilder.loadTexts: bladeEntry.setDescription('Individual blade entry')
bladeSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 1), Index()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeSlotId.setStatus('current')
if mibBuilder.loadTexts: bladeSlotId.setDescription('Slot number which the blade current occupies (or would occupy).')
bladePresence = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 2), Presence()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladePresence.setStatus('current')
if mibBuilder.loadTexts: bladePresence.setDescription('column used to flag the existence of a particular FRU')
maxFrus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 3), INT32withException()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxFrus.setStatus('current')
if mibBuilder.loadTexts: maxFrus.setDescription('Given a board, the Maximum number of FRUs for this board. This parameter is related to the bladeFruPresenceMask as it defines the number of FRUs to be represented (whether they are present or not)')
numOfFrus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 4), INT32withException()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numOfFrus.setStatus('current')
if mibBuilder.loadTexts: numOfFrus.setDescription('The number FRUs present on the board')
bladeFruPresenceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruPresenceMask.setStatus('current')
if mibBuilder.loadTexts: bladeFruPresenceMask.setDescription("ASCII representation of bit string reflecting the presence of the FRUs with the left most 'bit' being bit 1 and maxFrus bits being represented. bit 1 - blade, itself bit 2 - mez card Thus, '10' would express that the blade is present, but does not have a Mez card When indeterminate, the string will be empty")
bladePowerLed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 6), PowerLedStates()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bladePowerLed.setStatus('current')
if mibBuilder.loadTexts: bladePowerLed.setDescription('State of the Power LED on the Blade (and optionally power control blade)')
bladeFaultLed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 7), FaultLedStates()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFaultLed.setStatus('current')
if mibBuilder.loadTexts: bladeFaultLed.setDescription('State of the Fault LED on the Blade')
bladePresenceLed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 8), PresenceLedStates()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bladePresenceLed.setStatus('current')
if mibBuilder.loadTexts: bladePresenceLed.setDescription('State of the Presence LED on the Blade (and optionally intiate identification)')
bladeBmcFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeBmcFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: bladeBmcFirmwareVersion.setDescription('Textual BMC Version of this blade.')
bladeBootBlockVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeBootBlockVersion.setStatus('current')
if mibBuilder.loadTexts: bladeBootBlockVersion.setDescription('Textual Boot Block Version of this blade.')
bladeBiosVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeBiosVersion.setStatus('current')
if mibBuilder.loadTexts: bladeBiosVersion.setDescription('Textual BIOS Version of this blade.')
bladeConsoleRedirection = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-32, -16, 0, 1))).clone(namedValues=NamedValues(("notApplicable", -32), ("unknown", -16), ("disabled", 0), ("networkSerialPort", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeConsoleRedirection.setStatus('current')
if mibBuilder.loadTexts: bladeConsoleRedirection.setDescription('Console redirection configuration within BIOS')
bladeLegacyOsRedirection = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-32, -16, 0, 1))).clone(namedValues=NamedValues(("notApplicable", -32), ("unknown", -16), ("noLegacyOsRedirection", 0), ("legacyOsRedirection", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeLegacyOsRedirection.setStatus('current')
if mibBuilder.loadTexts: bladeLegacyOsRedirection.setDescription('Legacy OS Redirection configuration within BIOS')
bladeBootCount = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeBootCount.setStatus('current')
if mibBuilder.loadTexts: bladeBootCount.setDescription("Number of times the blade has booted (since manufactured or NVRAM cleared) Will be 0 if unknown (e.g., blade hasn't been powered on at least once since insertion, blade not present, etc.).")
bladeFruTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2), )
if mibBuilder.loadTexts: bladeFruTable.setStatus('current')
if mibBuilder.loadTexts: bladeFruTable.setDescription('Each row describes a FRU associated with (and including) a Blade in the chassis There will always be 2 FRU entries for every blade (with the presence field marking whether marking whether the rest of the row is relevant). Thus, the presence can be queried of all FRUs regardless of their being present.')
bladeFruEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1), ).setIndexNames((0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"), (0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruType"))
if mibBuilder.loadTexts: bladeFruEntry.setStatus('current')
if mibBuilder.loadTexts: bladeFruEntry.setDescription('blade & SubFRU common information.')
bladeFruType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("blade", 1), ("mezzanine", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruType.setStatus('current')
if mibBuilder.loadTexts: bladeFruType.setDescription('column used to identify a particular FRU. FRU 1 is the blade, itself, FRU 2 is the mezzanine card')
bladeFruPresence = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 2), Presence()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruPresence.setStatus('current')
if mibBuilder.loadTexts: bladeFruPresence.setDescription('column used to flag the existence of a particular FRU')
bladeFruVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruVendor.setStatus('current')
if mibBuilder.loadTexts: bladeFruVendor.setDescription('Device manufacturer')
bladeFruMfgDate = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruMfgDate.setStatus('current')
if mibBuilder.loadTexts: bladeFruMfgDate.setDescription('Manufacture date/time')
bladeFruDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruDeviceName.setStatus('current')
if mibBuilder.loadTexts: bladeFruDeviceName.setDescription('Device Name')
bladeFruPart = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 6), IdromBinary16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruPart.setStatus('current')
if mibBuilder.loadTexts: bladeFruPart.setDescription('Device Part Number')
bladeFruSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 7), IdromBinary16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruSerialNo.setStatus('current')
if mibBuilder.loadTexts: bladeFruSerialNo.setDescription('Device Serial Number')
bladeFruMaximumPower = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 8), Power()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruMaximumPower.setStatus('current')
if mibBuilder.loadTexts: bladeFruMaximumPower.setDescription('Static maximum power generation / consumption (in watts): <0 - Negative numbers indicate device consumes power (in watts) >0 - Positive numbers indicate device generates power (in watts) 0 - Device is passive (does not not consume or generate power) 0xffff - Maximum power generation/consumption not known or specified')
bladeFruNominalPower = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 9), Power()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruNominalPower.setStatus('current')
if mibBuilder.loadTexts: bladeFruNominalPower.setDescription('Static Nominal power generation / consumption (in watts): <0 - Negative numbers indicate device consumes power (in watts) >0 - Positive numbers indicate device generates power (in watts) 0 - Device is passive (does not not consume or generate power) 0xffff - Nominal power generation/consumption not known or specified')
bladeFruAssetTag = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 2, 1, 10), IdromBinary16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeFruAssetTag.setStatus('current')
if mibBuilder.loadTexts: bladeFruAssetTag.setDescription('Asset Tag # of device')
bladeNicTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 3), )
if mibBuilder.loadTexts: bladeNicTable.setStatus('current')
if mibBuilder.loadTexts: bladeNicTable.setDescription('Each row describes a NIC associated with a blade from the system memory as described by the blades SMBIOS entries. For future compatibility, this table is sparsely populate based on the presence of the blade, and the availability of the SMBIOS from the blade (e.g., a blade may be present, but if it never has powered on, or there is a communications error to the BMC, it may not be displayed)')
bladeNicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 3, 1), ).setIndexNames((0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"), (0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeNic"))
if mibBuilder.loadTexts: bladeNicEntry.setStatus('current')
if mibBuilder.loadTexts: bladeNicEntry.setDescription('Overall NIC information per blade information')
bladeNic = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeNic.setStatus('current')
if mibBuilder.loadTexts: bladeNic.setDescription('NIC associated with blade (both onboard and optional Mezzanine card) as found within the SMBIOS data for the blade')
bladeProcessorTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4), )
if mibBuilder.loadTexts: bladeProcessorTable.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorTable.setDescription("Each row describes a Processor associated with a Blade in the chassis as described by the blades SMBIOS entries. As there are multiple Processors available per blade, there are two indices associated with this table. One for the blade, the other for the Processor in question. Although the blade is associated by slot within the chassis and is easily made a numeric value, the processor is less reliable. Although initial boards return via the BIOS the form 'CPU#', this is not required by the SMBIOS specification (it could be J2341). Thus, the SMBIOS handle associated with the processor is used so that cross referencing is more straight forward (e.g., when listing L caches associated with processors). For future compatibility, this table is sparsely populate based on the presence of the blade, and the availability of the SMBIOS from the blade (e.g., a blade may be present, but if it never has powered on, or there is a communications error to the BMC, it may not be displayed)")
bladeProcessorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1), ).setIndexNames((0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"), (0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "handle"))
if mibBuilder.loadTexts: bladeProcessorEntry.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorEntry.setDescription('Processor(s) per blade information')
handle = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 1), Index())
if mibBuilder.loadTexts: handle.setStatus('current')
if mibBuilder.loadTexts: handle.setDescription('Unique handle within the SMBIOS table for a specific blade which lays out the assorted record types.')
bladeProcessorSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorSocket.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorSocket.setDescription("String returned by SMBIOS designating the socket location of the CPU for the indexed blade. The string is returned by the BIOS and is arbitrary as determined by the vendor. Thus it could be J202, or CPU2. Regardless, it will be unqiue in it's designation for a blade.")
bladeProcessorPresence = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 3), Presence()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorPresence.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorPresence.setDescription('column used to flag the existence of a particular CPU')
bladeProcessorType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorType.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorType.setDescription('SMBIOS string representing type of Processor in this slot')
bladeProcessorFamily = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorFamily.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorFamily.setDescription('String representing SMBIOS data for the processor family type')
bladeProcessorManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorManufacturer.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorManufacturer.setDescription('String representing SMBIOS data for the Manufacturer of the Processor')
bladeProcessorID = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorID.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorID.setDescription("SMBIOS string containing the Processor ID field which contains processor-specific information that describes the processor's features.")
bladeProcessorVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorVersion.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorVersion.setDescription('String representing SMBIOS data describing the Processor')
bladeProcessorVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorVoltage.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorVoltage.setDescription('SMBIOS string representing the voltage(s) the processor is capable of')
bladeProcessorExtClock = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorExtClock.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorExtClock.setDescription('SMBIOS value of the External Clock Frequency, in MHZ. If the value is unknown, the field is set to 0')
bladeProcessorMaxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorMaxSpeed.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorMaxSpeed.setDescription('SMBIOS value of the Maximum processor speed (in MHz) supported by the system for this processor socket. If the value is unknown, the field is set to 0. Note: This field identifies a capability for the system, not the processor itself.')
bladeProcessorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorStatus.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorStatus.setDescription('String representing SMBIOS data describing CPU status information')
bladeProcessorUpgrade = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorUpgrade.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorUpgrade.setDescription("String representing SMBIOS data describing the CPU 'Upgrade' or how the processor is located on the blade")
bladeProcessorSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorSerialNo.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorSerialNo.setDescription('SMBIOS string of the serial number of this processor. This value is set by the manufactureer and normally not changeable.')
bladeProcessorAssetTag = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorAssetTag.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorAssetTag.setDescription('SMBIOS string of the asset tag of this processor.')
bladeProcessorPartNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 4, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeProcessorPartNo.setStatus('current')
if mibBuilder.loadTexts: bladeProcessorPartNo.setDescription('SMBIOS string of the part number of this processor. This value is set by the manufactureer and normally not changeable.')
bladeMemorySummaryTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5), )
if mibBuilder.loadTexts: bladeMemorySummaryTable.setStatus('current')
if mibBuilder.loadTexts: bladeMemorySummaryTable.setDescription('Each row describes the overall summary of the memory configuration for a given blade in the chassis as described by the blades SMBIOS entries. For future compatibility, this table is sparsely populate based on the presence of the blade, and the availability of the SMBIOS from the blade (e.g., a blade may be present, but if it never has powered on, or there is a communications error to the BMC, it may not be displayed)')
bladeMemorySummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1), )
bladeEntry.registerAugmentions(("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemorySummaryEntry"))
bladeMemorySummaryEntry.setIndexNames(*bladeEntry.getIndexNames())
if mibBuilder.loadTexts: bladeMemorySummaryEntry.setStatus('current')
if mibBuilder.loadTexts: bladeMemorySummaryEntry.setDescription('Overall memory configuration summary per blade information')
bladeMSMaxDevices = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSMaxDevices.setStatus('current')
if mibBuilder.loadTexts: bladeMSMaxDevices.setDescription('The number of slots or sockets available for Memory Devices on the board.')
bladeMSNumOfDevices = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSNumOfDevices.setStatus('current')
if mibBuilder.loadTexts: bladeMSNumOfDevices.setDescription('The number of slots or sockets populated with Memory Devices on the board.')
bladeMSCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSCapacity.setStatus('current')
if mibBuilder.loadTexts: bladeMSCapacity.setDescription('The maximum memory capacity in MB for this array.')
bladeMSTotalSize = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSTotalSize.setStatus('current')
if mibBuilder.loadTexts: bladeMSTotalSize.setDescription('Total size in MB of all memory physically installed')
bladeMSEffectiveSize = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSEffectiveSize.setStatus('current')
if mibBuilder.loadTexts: bladeMSEffectiveSize.setDescription('Memory available after deducting for failed and redundant memory units')
bladeMSNumFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSNumFailed.setStatus('current')
if mibBuilder.loadTexts: bladeMSNumFailed.setDescription('Total Number of failed memory devices')
bladeMSDisabledSize = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSDisabledSize.setStatus('current')
if mibBuilder.loadTexts: bladeMSDisabledSize.setDescription('Total size in MB of all disabled memory')
bladeMSSpareSize = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSSpareSize.setStatus('current')
if mibBuilder.loadTexts: bladeMSSpareSize.setDescription('Total size in MB of all spare memory (see bladeMSRasPossible & bladeMSRasConfiguration columns)')
bladeMSRasPossible = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 0), ("supportsMirroring", 1), ("supportsSparing", 2), ("supportsBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSRasPossible.setStatus('current')
if mibBuilder.loadTexts: bladeMSRasPossible.setDescription('RAS Configuration Possible')
bladeMSRasConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("mirroring", 1), ("sparing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSRasConfiguration.setStatus('current')
if mibBuilder.loadTexts: bladeMSRasConfiguration.setDescription('RAS Configuration Possible')
bladeMSErrorCorrection = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("none", 3), ("parity", 4), ("singleBitEcc", 5), ("multiBitEcc", 6), ("crc", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMSErrorCorrection.setStatus('current')
if mibBuilder.loadTexts: bladeMSErrorCorrection.setDescription('The primary hardware error correction or detection method supported')
bladeMemoryTable = MibTable((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6), )
if mibBuilder.loadTexts: bladeMemoryTable.setStatus('current')
if mibBuilder.loadTexts: bladeMemoryTable.setDescription('Each row describes an individual memory device for system memory given a specific blade in the chassis as described by the blades SMBIOS entries. For future compatibility, this table is sparsely populate based on the presence of the blade, and the availability of the SMBIOS from the blade (e.g., a blade may be present, but if it never has powered on, or there is a communications error to the BMC, it may not be displayed)')
bladeMemoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1), ).setIndexNames((0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"), (0, "INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "handle"))
if mibBuilder.loadTexts: bladeMemoryEntry.setStatus('current')
if mibBuilder.loadTexts: bladeMemoryEntry.setDescription('Overall memory device per blade information')
bladeMemTotalWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1))).clone(namedValues=NamedValues(("unknown", -1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemTotalWidth.setStatus('current')
if mibBuilder.loadTexts: bladeMemTotalWidth.setDescription('The total width, in bits, of this memory device, including any check or error-correction bits. If there are no error-correction bits, this value should be equal to bladeMemDataWidth. If the width is unknown, the field is set to -1.')
bladeMemDataWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1))).clone(namedValues=NamedValues(("unknown", -1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemDataWidth.setStatus('current')
if mibBuilder.loadTexts: bladeMemDataWidth.setDescription('The data width, in bits, of this memory device. If 0 and bladeMemTotalWidth is 8 indicates that the device is being used solely to provide 8 error-correction bits. If the width is unknown, the field is set to -1.')
bladeMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("unknown", -1), ("notInstalled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemSize.setStatus('current')
if mibBuilder.loadTexts: bladeMemSize.setDescription("The size of the memory device. If the value is 0, no memory device is installed in the socket (shouldn't occur as the table is sparsely populated); if the size is unknown, the field value is -1.")
bladeMemGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1))).clone(namedValues=NamedValues(("unknown", -1), ("megabytes", 0), ("kilobytes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemGranularity.setStatus('current')
if mibBuilder.loadTexts: bladeMemGranularity.setDescription('The granularity of the bladeMemSize')
bladeMemFormFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("simm", 3), ("sip", 4), ("chip", 5), ("dip", 6), ("zip", 7), ("proprietaryCard", 8), ("dimm", 9), ("tsop", 10), ("rowOfChips", 11), ("rimm", 12), ("sodimm", 13), ("srimm", 14), ("fbdimm", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemFormFactor.setStatus('current')
if mibBuilder.loadTexts: bladeMemFormFactor.setDescription('The implementation form factor for this memory device.')
bladeMemDeviceSet = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("unknown", -1), ("noSet", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemDeviceSet.setStatus('current')
if mibBuilder.loadTexts: bladeMemDeviceSet.setDescription('Identifies when the Memory Device is one of a set of Memory Devices that must be populated with all devices of the same type and size and the set to which this device belongs. A value of 0 indicates that the device is not part of a set; a value of -1 indicates that the attribute is unknown.')
bladeMemLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemLocation.setStatus('current')
if mibBuilder.loadTexts: bladeMemLocation.setDescription('String that identifies the physically labeled socket or board position where the memory device is located')
bladeMemBank = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemBank.setStatus('current')
if mibBuilder.loadTexts: bladeMemBank.setDescription('String that identifies the physically labeled bank where where the memory device is located')
bladeMemType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("dram", 3), ("edram", 4), ("vram", 5), ("sram", 6), ("ram", 7), ("rom", 8), ("flash", 9), ("eeprom", 10), ("feprom", 11), ("eprom", 12), ("cdram", 13), ("dram3", 14), ("sdram", 15), ("sgram", 16), ("rdram", 17), ("ddr", 18), ("ddr2", 19), ("ddr2fbdimm", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemType.setStatus('current')
if mibBuilder.loadTexts: bladeMemType.setDescription('The type of memory used in this device')
bladeMemTypeDetail = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 10), Bits().clone(namedValues=NamedValues(("reserved", 0), ("other", 1), ("unknown", 2), ("fastPaged", 3), ("staticColumn", 4), ("pseudoStatic", 5), ("rambus", 6), ("synchronous", 7), ("cmos", 8), ("edo", 9), ("windowDram", 10), ("cacheDram", 11), ("nonVolatile", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemTypeDetail.setStatus('current')
if mibBuilder.loadTexts: bladeMemTypeDetail.setDescription('The type of memory used in this device')
bladeMemSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("unknown", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemSpeed.setStatus('current')
if mibBuilder.loadTexts: bladeMemSpeed.setDescription('Identifies the speed of the device in megahertz (MHz).')
bladeMemManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemManufacturer.setStatus('current')
if mibBuilder.loadTexts: bladeMemManufacturer.setDescription('Manufacturer of this memory device')
bladeMemSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemSerialNo.setStatus('current')
if mibBuilder.loadTexts: bladeMemSerialNo.setDescription('Serial Number of this memory device')
bladeMemAssetTag = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemAssetTag.setStatus('current')
if mibBuilder.loadTexts: bladeMemAssetTag.setDescription('Asset Tag of this memory device')
bladeMemPart = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 10, 202, 6, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bladeMemPart.setStatus('current')
if mibBuilder.loadTexts: bladeMemPart.setDescription('Part Number of this memory device')
bladeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 343, 2, 19, 1, 2, 2, 2, 12)).setObjects(("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "maxBlades"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "numOfBlades"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladePresenceMask"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeSlotId"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "maxFrus"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "numOfFrus"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladePresence"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladePowerLed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFaultLed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladePresenceLed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruPresenceMask"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeBmcFirmwareVersion"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeBootBlockVersion"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeBiosVersion"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeConsoleRedirection"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeLegacyOsRedirection"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeBootCount"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruType"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruPresence"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruVendor"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruMfgDate"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruDeviceName"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruPart"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruSerialNo"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruMaximumPower"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruNominalPower"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeFruAssetTag"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeNic"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorSocket"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorPresence"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorType"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorFamily"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorManufacturer"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorID"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorVersion"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorVoltage"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorExtClock"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorMaxSpeed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorStatus"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorUpgrade"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorSerialNo"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorAssetTag"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeProcessorPartNo"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSMaxDevices"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSNumOfDevices"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSCapacity"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSErrorCorrection"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSTotalSize"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSNumFailed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSDisabledSize"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSSpareSize"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSEffectiveSize"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSRasPossible"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMSRasConfiguration"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemTotalWidth"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemDataWidth"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemSize"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemGranularity"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemFormFactor"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemDeviceSet"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemLocation"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemBank"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemType"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemTypeDetail"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemSpeed"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemManufacturer"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemSerialNo"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemAssetTag"), ("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", "bladeMemPart"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bladeGroup = bladeGroup.setStatus('current')
if mibBuilder.loadTexts: bladeGroup.setDescription('Description.')
mibBuilder.exportSymbols("INTELCORPORATION-MULTI-FLEX-SERVER-BLADES-MIB", bladeFruType=bladeFruType, bladeBootBlockVersion=bladeBootBlockVersion, bladeMSCapacity=bladeMSCapacity, bladeLegacyOsRedirection=bladeLegacyOsRedirection, bladeMemoryEntry=bladeMemoryEntry, bladeMemTypeDetail=bladeMemTypeDetail, bladeSlotId=bladeSlotId, bladeProcessorSocket=bladeProcessorSocket, bladeMSMaxDevices=bladeMSMaxDevices, bladeTable=bladeTable, bladeFruSerialNo=bladeFruSerialNo, bladeGroup=bladeGroup, bladeMSErrorCorrection=bladeMSErrorCorrection, blades=blades, bladeBiosVersion=bladeBiosVersion, bladeFruNominalPower=bladeFruNominalPower, bladeProcessorStatus=bladeProcessorStatus, bladeFruPresence=bladeFruPresence, maxBlades=maxBlades, bladeProcessorTable=bladeProcessorTable, bladeProcessorID=bladeProcessorID, maxFrus=maxFrus, bladeMemDeviceSet=bladeMemDeviceSet, numOfFrus=numOfFrus, bladeFruMaximumPower=bladeFruMaximumPower, PYSNMP_MODULE_ID=multiFlexServerBladesMibModule, bladeMSSpareSize=bladeMSSpareSize, bladeFruTable=bladeFruTable, bladePresenceMask=bladePresenceMask, bladeProcessorVoltage=bladeProcessorVoltage, bladeMSNumOfDevices=bladeMSNumOfDevices, bladeFruAssetTag=bladeFruAssetTag, bladeMemSerialNo=bladeMemSerialNo, bladeProcessorManufacturer=bladeProcessorManufacturer, bladeMemorySummaryEntry=bladeMemorySummaryEntry, bladeNicTable=bladeNicTable, bladeMemoryTable=bladeMemoryTable, bladeMSDisabledSize=bladeMSDisabledSize, bladeProcessorEntry=bladeProcessorEntry, bladeProcessorExtClock=bladeProcessorExtClock, bladeMemBank=bladeMemBank, bladeBootCount=bladeBootCount, bladeMemManufacturer=bladeMemManufacturer, bladeProcessorFamily=bladeProcessorFamily, bladeProcessorUpgrade=bladeProcessorUpgrade, bladeNic=bladeNic, handle=handle, bladePowerLed=bladePowerLed, bladeFruMfgDate=bladeFruMfgDate, bladeMSRasPossible=bladeMSRasPossible, bladeMemGranularity=bladeMemGranularity, bladeMemSize=bladeMemSize, bladeConsoleRedirection=bladeConsoleRedirection, bladeFruEntry=bladeFruEntry, bladeMemDataWidth=bladeMemDataWidth, numOfBlades=numOfBlades, bladeNicEntry=bladeNicEntry, bladeMemAssetTag=bladeMemAssetTag, bladeProcessorType=bladeProcessorType, bladeProcessorAssetTag=bladeProcessorAssetTag, multiFlexServerBladesMibModule=multiFlexServerBladesMibModule, bladeMemFormFactor=bladeMemFormFactor, bladeBmcFirmwareVersion=bladeBmcFirmwareVersion, bladeFruPresenceMask=bladeFruPresenceMask, bladeProcessorPartNo=bladeProcessorPartNo, bladeProcessorMaxSpeed=bladeProcessorMaxSpeed, bladePresenceLed=bladePresenceLed, bladeMSEffectiveSize=bladeMSEffectiveSize, bladeMemTotalWidth=bladeMemTotalWidth, bladeProcessorVersion=bladeProcessorVersion, bladeEntry=bladeEntry, bladeMemLocation=bladeMemLocation, bladeMemPart=bladeMemPart, bladeProcessorPresence=bladeProcessorPresence, bladeMSTotalSize=bladeMSTotalSize, bladeMemType=bladeMemType, bladeFruVendor=bladeFruVendor, bladeFruDeviceName=bladeFruDeviceName, bladeMemorySummaryTable=bladeMemorySummaryTable, bladeProcessorSerialNo=bladeProcessorSerialNo, bladeMemSpeed=bladeMemSpeed, bladePresence=bladePresence, bladeFaultLed=bladeFaultLed, bladeFruPart=bladeFruPart, bladeMSNumFailed=bladeMSNumFailed, bladeMSRasConfiguration=bladeMSRasConfiguration)

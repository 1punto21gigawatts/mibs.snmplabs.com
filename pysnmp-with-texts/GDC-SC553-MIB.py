#
# PySNMP MIB module GDC-SC553-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDC-SC553-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
gdc, = mibBuilder.importSymbols("GDCCMN-MIB", "gdc")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, iso, Gauge32, IpAddress, Counter32, ObjectIdentity, Integer32, TimeTicks, Bits, Counter64, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "iso", "Gauge32", "IpAddress", "Counter32", "ObjectIdentity", "Integer32", "TimeTicks", "Bits", "Counter64", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
sc553 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11))
sc553Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 1))
sc553Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 2))
sc553Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 3))
sc553Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 4))
sc553Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5))
sc553Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 6))
sc553MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: sc553MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Upon formal release, no designation for the test revision will be present. Acceptable values for the individual revision components are as follows: x: 1 - 9, y: 0 - 9, z: 0 - 9, T: A - Z")
sc553VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2), )
if mibBuilder.loadTexts: sc553VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553VersionTable.setDescription(' ')
sc553VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553VersionIndex"))
if mibBuilder.loadTexts: sc553VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553VersionEntry.setDescription('An entry in the GDC SC553 Version Table.')
sc553VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553VersionIndex.setDescription('Identifies Version parameters associated with the managed object.')
sc553ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc553StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc553StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc553BootRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553BootRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc553BootRev.setDescription('The version number of the bootstrap firmware. The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
sc553StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6), ("statDownloadAborted", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc553StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set sc553SwitchActive to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress statDownloadAborted(7) Download aborted by user The object is read only. ')
sc553SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: sc553SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in sc553ActiveRev to the version in sc553StoredRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set sc553StoredStatus object to indicate results 5) If succesfull: update sc553ActiveFirmwareRev and sc553StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the sc553StoredStatus is not statOK(3) will result in an error. ')
sc553DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to SC553 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code ')
sc553ChannelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1), )
if mibBuilder.loadTexts: sc553ChannelConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelConfigTable.setDescription('The GDC 553 Channel Configuration table.')
sc553ChannelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553ChannelConfigIndex"))
if mibBuilder.loadTexts: sc553ChannelConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelConfigEntry.setDescription('The sc553 Channel Configuration table entry.')
sc553ChannelConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ChannelConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelConfigIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-indentifier for this SCinstance is the channel.')
sc553ChannelDS0AllocationScheme = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("consecutive", 1), ("alternate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelDS0AllocationScheme.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelDS0AllocationScheme.setDescription('Identifies the DSU DS0 allocation scheme.The value consecutive(2) indicates that bundles of DS0s are allocated to channels consecutively from the starting DS0. The value of alternate(3) indicates that bundles of DS0s are allocated to channels alternatly, or every other DS0 from the starting DS0. The unused DS0s are forced to marks. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
sc553ChannelBaseRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nx56k", 1), ("nx64k", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelBaseRate.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelBaseRate.setDescription('Indicates the DS0 base rate: either 56K or 64K bits per second. This is used in conjunction with the number of DS0s to determine the bandwidth of the channel. Note that base rate of 64K defines the DS0 as clear channel in which all 8 bits of the DS0 are used. A base rate of 56K defines the DS0 as non-clear in which bits 1-7 are used for channel data and the 8th bit is either unused and forced to marks or used to pass signaling information.')
sc553ChannelStartingDS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelStartingDS0.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelStartingDS0.setDescription('Indicates the starting DS0 number for the bundle of DS0s used for the channel. DS0 bundles are allocated starting at the DS0 defined by this integer. When this integer is set to 0, the channel is disabled and no DS0s are allocated to the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
sc553ChannelNumberOfDS0s = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelNumberOfDS0s.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelNumberOfDS0s.setDescription('Indicates the number of DS0s for the bundle allocated to the channel. The number of DS0s, in conjunction with the DS0 base rate, also determines the bandwidth of the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
sc553ChannelInbandDccMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("embedded", 2), ("dccDs0", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelInbandDccMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelInbandDccMode.setDescription("The mode of propagation of inband Diagnostics Communication Channel to the dedicated remote sc553 unit. None specifies no inband DCC. Embedded is an allowed value when the mib object sc553DS0BaseRate is set to Nx56K, and specifies that DCC is propagated in the 8th bit of the assigned DS0's. dccDs0 specifies that a DS0 is used for propagation of DCC, this value would be selected if the sc553DS0BaseRate is Nx64k (clear channel) since all data bits are used for user data, a minimum of two DS0's must be assigned to this device in this mode, the last ds0 should be set as the sc553DccDs0 when using this mode.")
sc553ChannelSplitTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelSplitTiming.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelSplitTiming.setDescription("Indicates whether or not to use split timing. The value disabled(1) indicates that channel's transmit timing is provided by the DSU. The value enabled(2) indicates that the channel's transmit timing is provided by the customer business equipment (ext Tx Clk). Split timing refers to the activation of elastic storage to allow the channel interface to receive data using the customer business equipment's timing source (ext Tx Clk) and transmit that same data to the network using the networks timing source.")
sc553ChannelChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("v35", 2), ("eia530", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ChannelChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelChannelType.setDescription('The channel interface type. The value none(1) indicates that there is no channel interface for the index. The value v35(2) indicates the channel interface is standard V.35 and the value eia530(3) indicates the channel interface is standard EIA 530.')
sc553ChannelAdminClkInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("invertRx", 2), ("invertTx", 3), ("both", 4), ("autoTxnormRx", 5), ("autoTxinvertRx", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelAdminClkInvert.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelAdminClkInvert.setDescription('Clock invert option for manual settings ( 1-4). Options autoTxnormRx(5) and autoTxinvertRx(6) allow auto selection of Tx clock with Rx clock normal, or inverted. ')
sc553ChannelOperClkInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("invertRx", 2), ("invertTx", 3), ("both", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ChannelOperClkInvert.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelOperClkInvert.setDescription('Clock invert option. Read Only.')
sc553ChannelDataInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("invertRx", 2), ("invertTx", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelDataInvert.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelDataInvert.setDescription('Data invert option')
sc553ChannelLocalDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelLocalDCD.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelLocalDCD.setDescription("Controls the operation of Data Carrier Detect (DCD) signal. The value followsSignal(1) indicates that the channel's DCD follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DCD is forced on.")
sc553ChannelLocalDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelLocalDSR.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelLocalDSR.setDescription("Controls the operation of the Data Set Ready (DSR) signal. The value followsSignal(1) indicates that the channel's DSR follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DSR is forced on.")
sc553ChannelRTSCTSControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ctrl", 1), ("ctsForcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelRTSCTSControl.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelRTSCTSControl.setDescription(' ? ')
sc553ChannelEIAtestLeads = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelEIAtestLeads.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelEIAtestLeads.setDescription("Controls the channel's EIA test leads. The EIA test leads allow customer business equipment to initiate diagnostic tests through the assertion of the EIA test leads RDL, LL, and ST. When this object is enabled(1), then the assertion of these leads is recognized and acted upon by the DSU. When this object is disabled(2), then the assertion of these leads is ignored by the DSU.")
sc553ChannelInbandLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelInbandLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelInbandLoop.setDescription('In-band loopcode enable/disable. The value disabled(1) indicates the channel does not enter an RDL loop when an inband RDL code is detected. The value enable(2) indicates the channel does enter an RDL loop when an inband RDL code is detected.')
sc553ChannelInbandLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable10Min", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelInbandLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelInbandLoopdown.setDescription("The time limit in seconds before terminating a channel's RDL. The value inhibit(1) indicates that the loopdown time is disabled and the loopback will only terminate by the in-band loopdown code. The value enable10Min(2) indicates the time before terminating the RDL in the event the loopdown code is never received.")
sc553channelRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553channelRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: sc553channelRedundancy.setDescription(' ')
sc553ChannelActivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("cascade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelActivePort.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelActivePort.setDescription(' This option routes the Channel bundle through either the network or cascade port. When a port becomes active the other port is automatically defined as the standby port. ')
sc553ChannelNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("networkOne", 1), ("networkTwo", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelNetworkNumber.setStatus('obsolete')
if mibBuilder.loadTexts: sc553ChannelNetworkNumber.setDescription(" In redundant T1 applications, there are two (2) networks employed. The are arbitrarily labeled Network 1 and Network 2. This option designates which of these redundant T1 networks is used for transmission over the SC553's Active T1 port. ")
sc553ChannelNetworkPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("cascade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelNetworkPosition.setStatus('obsolete')
if mibBuilder.loadTexts: sc553ChannelNetworkPosition.setDescription(' In redundant T1 applications, this option defines the network position of the DSU. Network position indicates that the DSU is connected directly to the network. Cascade position indicates that the DSU is connected to the network as a cascaded DSU through at least one ther DSU. ')
sc553WakeUpRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553WakeUpRemote.setStatus('mandatory')
if mibBuilder.loadTexts: sc553WakeUpRemote.setDescription('This object is requested to initiate the add remote process. The serial number of the associated remote is returned.')
sc553ChannelInService = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ChannelInService.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ChannelInService.setDescription('')
sc553NetworkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2), )
if mibBuilder.loadTexts: sc553NetworkConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkConfigTable.setDescription('The GDC 553 Network Configuration table.')
sc553NetworkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553NetworkConfigIndex"))
if mibBuilder.loadTexts: sc553NetworkConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkConfigEntry.setDescription('The sc553 Network Configuration table entry.')
sc553NetworkConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier.')
sc553NetworkAdminLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unframed", 1), ("manEsf", 2), ("manD4", 3), ("auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkAdminLineType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkAdminLineType.setDescription("The values describe: 'auto' indicates the unit will determine framing. 'manEsf' indicates manual selection of extended superframe format. 'manD4'indicates manual selection of D4 framing format. 'unframed' indicates manual selection of unframed format.")
sc553NetworkOperLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unframed", 1), ("esf", 2), ("d4", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkOperLineType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkOperLineType.setDescription("The values describe: 'manEsf' indicates the current setting of Line type. 'manD4'indicates the current setting of Line type. 'unframed' indicates the current setting of Line type.")
sc553NetworkInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("dsx1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkInterfaceType.setDescription('The operating mode of the interface. Setting the value of this object to ds1(1) configures the interface as standard DS1. Setting the value of this object to dsx1(2) configures the interface to operate as a standard cross-connect DSX-1. This object interoperates with the sc553NetworkPreequalization object. When this object is set to ds1(1), then the value of sc553NetworkPreequalization does not apply. This object interoperates with the sc553NetworkAdminLineBuildout object. When this object is set to dsx1(2), then the value of sc553NetworkLineBuildout does not apply.')
sc553NetworkPreequalization = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("preeq130", 1), ("preeq260", 2), ("preeq390", 3), ("preeq530", 4), ("preeq655", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkPreequalization.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkPreequalization.setDescription('Is the preequalization of the transmitter of the interface. This object interoperates with the object sc553NetworkInterfaceType. When the value of sc553NetworkInterfaceType is ds1(2) then this value is not applicable.')
sc553NetworkAdminLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 11, 12, 13, 16))).clone(namedValues=NamedValues(("man00dB", 10), ("man75dB", 11), ("man150dB", 12), ("man225dB", 13), ("auto", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkAdminLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkAdminLineBuildout.setDescription('This variable is used to set the Transmit Ntwk Build-Out value on the network side and is only valid if the sc553NetworkInterfaceType is set for ds1(1). The values, in sequence, describe: auto(16) indicates auto detection of receive level to determine the appropriate Ntwk build out without controller intervention man00dB(10) indicates manual selection of 0.0 dB transmit Ntwk build out man75dB(11) indicates manual selection of -7.5 dB transmit Ntwk build out man150dB(12) indicates manual selection of -15.0 dB transmit Ntwk build out man225B(13) indicates manual selection of -22.5 dB transmit Ntwk build out')
sc553NetworkOperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("tx00dB", 2), ("tx75dB", 3), ("tx150dB", 4), ("tx225dB", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkOperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkOperLineBuildout.setDescription('This variable is used to report the current Ntwk build-out setting if the sc553NetworkInterfaceType is set for ds1(1). tx00dB(2) indicates the unit is set for 0.0 dB of attenuation when the sc553NetworkAdminLineBuildout is set for auto (16) or man00dB (10) tx75dB(3) indicates the unit is set for 7.5 dB of attenuation when the sc553NetworkAdminLineBuildout is set for auto (16) or man75dB (11) tx150dB(4) indicates the unit is set for -15.0 dB of attenuation when the sc553NetworkAdminLineBuildout is set for auto (16) or man150dB (12) tx225dB(5) indicates the unit is set for -22.5 dB of attenuation when the sc553NetworkAdminLineBuildout is set for auto (16) or man225dB (13)')
sc553NetworkOnesDensity = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5))).clone(namedValues=NamedValues(("inhibit", 1), ("restrict8XNplus1", 4), ("min1in8", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkOnesDensity.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkOnesDensity.setDescription('The ones density restriction for the interface. The values of this object define the ones density restriction that is enforced on the interface. The value inhibit(1) indicates that no ones density restriction is enforced. The value restrict8nX1(4) indicates a minimum of N ones per 8(N+1) bits, where N is in the range 1 to 24. The value min1in8(5) indicates a minimum of 1 one per 8 bits. With this value, pulse density violations are enforced but not recorded.')
sc553NetworkTransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6))).clone(namedValues=NamedValues(("receive", 1), ("cascade", 2), ("internal", 4), ("station", 5), ("extChannelClkPPL", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkTransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkTransmitClockSource.setDescription('')
sc553NetworkFallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("receive", 1), ("cascade", 2), ("internal", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkFallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkFallbackClockSource.setDescription('')
sc553NetworkFDLdcc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkFDLdcc.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkFDLdcc.setDescription('Controls whether or not the DCC uses the FDL as its transport. The FDL is only available when the DS1 line type is ESF, a full DS1 interface is being used, and transportation of the FDL completely through the network is supported. The value enabled(1) enables the transportation of the DCC using the FDL. The value disabled(2) disables the use of the FDL to transport the DCC, which implies that the DCC is transported by some other means. This object interoperates with the sc553NetworkLineType object. The value of this object can be set to enabled(1) only when the value of the sc553NetworkLineType is one of the ESF values.')
sc553NetworkAISLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkAISLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkAISLoopdown.setDescription('The time in seconds when receiving a continuous AIS signal before a remotely initiated loopback is terminated. When this object has the value 4, then there is no time limit and the loop must be terminated by remotely issued in-band loopdown codes. When the object has a value between 5 and 60, then this is time in seconds of continuous AIS signal before the loopback is terminated.')
sc553NetworkLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("payload", 2), ("lineloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkLoopbackConfig.setDescription('This variable is used to set the In-Band DS1 Loopback Code Detection. none(1) refers to when the in-band loopback codes are ignored. payload(2) designates a payload loopback is done upon recognition of the inband loopback code. lineloop(3) designates a line loopback is done upon recognition of the inband loopback code.')
sc553NetworkLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sc553B8ZS", 1), ("sc553AMI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkLineCoding.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. sc553B8ZS refers to the use of a specified pat- tern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits. sc553AMI refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data.')
sc553NetworkFdl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sc553Fdl-none", 1), ("sc553Ansi-T1-403", 2), ("sc553Att-54016", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553NetworkFdl.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkFdl.setDescription('This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: sc553Fdl-none(1) indicates that the device does not use the FDL. sc553Ansi-T1-403(2) refers to the FDL exchange recommended by ANSI. sc553Att-54016(3) refers to ESF FDL exchanges.')
sc553CascadeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4), )
if mibBuilder.loadTexts: sc553CascadeConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeConfigTable.setDescription('The GDC 553 Cascade Configuration table.')
sc553CascadeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553CascadeConfigIndex"))
if mibBuilder.loadTexts: sc553CascadeConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeConfigEntry.setDescription('The sc553 Cascade Configuration table entry.')
sc553CascadeConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CascadeConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier.')
sc553CascadeAdminLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unframed", 1), ("manEsf", 2), ("manD4", 3), ("auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeAdminLineType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeAdminLineType.setDescription("The values describe: 'auto' indicates the unit will determine framing. 'manEsf' indicates manual selection of extended superframe format. 'manD4'indicates manual selection of D4 framing format. 'unframed' indicates manual selection of unframed format.")
sc553CascadeOperLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unframed", 1), ("esf", 2), ("d4", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CascadeOperLineType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeOperLineType.setDescription("The values describe: 'manEsf' indicates the current setting of Line type. 'manD4'indicates the current setting of Line type. 'unframed' indicates the current setting of Line type.")
sc553CascadeInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("dsx1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeInterfaceType.setDescription('The operating mode of the interface. Setting the value of this object to ds1(1) configures the interface as standard DS1. Setting the value of this object to dsx1(2) configures the interface to operate as a standard cross-connect DSX-1. This object interoperates with the sc553CascadePreequalization object. When this object is set to ds1(1), then the value of sc553CascadePreequalization does not apply. This object interoperates with the sc553CascadeAdminLineBuildout object. When this object is set to dsx1(2), then the value of sc553CascadeLineBuildout does not apply.')
sc553CascadePreequalization = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("preeq130", 1), ("preeq260", 2), ("preeq390", 3), ("preeq530", 4), ("preeq655", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadePreequalization.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadePreequalization.setDescription('Is the preequalization of the transmitter of the interface. This object interoperates with the object sc553CascadeInterfaceType. When the value of sc553CascadeInterfaceType is ds1(2) then this value is not applicable.')
sc553CascadeAdminLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 11, 12, 13, 16))).clone(namedValues=NamedValues(("man00dB", 10), ("man75dB", 11), ("man150dB", 12), ("man225dB", 13), ("auto", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeAdminLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeAdminLineBuildout.setDescription('This variable is used to set the Transmit Ntwk Build-Out value on the cascade side and is only valid if the sc553CascadeInterfaceType is set for ds1(1). The values, in sequence, describe: auto(16) indicates auto detection of receive level to determine the appropriate Ntwk build out without controller intervention man00dB(10) indicates manual selection of 0.0 dB transmit Ntwk build out man75dB(11) indicates manual selection of -7.5 dB transmit Ntwk build out man150dB(12) indicates manual selection of -15.0 dB transmit Ntwk build out man225B(13) indicates manual selection of -22.5 dB transmit Ntwk build out')
sc553CascadeOperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("tx00dB", 2), ("tx75dB", 3), ("tx150dB", 4), ("tx225dB", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CascadeOperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeOperLineBuildout.setDescription('This variable is used to report the current Ntwk build-out setting if the sc553CascadeInterfaceType is set for ds1(1). tx00dB(2) indicates the unit is set for 0.0 dB of attenuation when the sc553CascadeAdminLineBuildout is set for auto (16) or man00dB (10) tx75dB(3) indicates the unit is set for 7.5 dB of attenuation when the sc553CascadeAdminLineBuildout is set for auto (16) or man75dB (11) tx150dB(4) indicates the unit is set for -15.0 dB of attenuation when the sc553CascadeAdminLineBuildout is set for auto (16) or man150dB (12) tx225dB(5) indicates the unit is set for -22.5 dB of attenuation when the sc553CascadeAdminLineBuildout is set for auto (16) or man225dB (13)')
sc553CascadeFDLdcc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeFDLdcc.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeFDLdcc.setDescription('Controls whether or not the DCC uses the FDL as its transport. The FDL is only available when the DS1 line type is ESF, a full DS1 interface is being used, and transportation of the FDL completely through the cascade is supported. The value enabled(1) enables the transportation of the DCC using the FDL. The value disabled(2) disables the use of the FDL to transport the DCC, which implies that the DCC is transported by some other means. This object interoperates with the sc553CascadeLineType object. The value of this object can be set to enabled(1) only when the value of the sc553CascadeLineType is one of the ESF values.')
sc553CascadeLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sc553B8ZS", 1), ("sc553AMI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeLineCoding.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. sc553B8ZS refers to the use of a specified pat- tern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits. sc553AMI refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data.')
sc553CascadeFdl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sc553Fdl-none", 1), ("sc553Ansi-T1-403", 2), ("sc553Att-54016", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeFdl.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeFdl.setDescription('This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: sc553Fdl-none(1) indicates that the device does not use the FDL. sc553Ansi-T1-403(2) refers to the FDL exchange recommended by ANSI. sc553Att-54016(3) refers to ESF FDL exchanges.')
sc553CascadeInService = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeInService.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeInService.setDescription('')
sc553CascadeAISLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeAISLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeAISLoopdown.setDescription('The time in seconds when receiving a continuous AIS signal before a remotely initiated loopback is terminated. When this object has the value 4, then there is no time limit and the loop must be terminated by remotely issued in-band loopdown codes. When the object has a value between 5 and 60, then this is time in seconds of continuous AIS signal before the loopback is terminated.')
sc553CascadeLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("payload", 2), ("lineloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553CascadeLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadeLoopbackConfig.setDescription('This variable is used to set the In-Band DS1 Loopback Code Detection. none(1) refers to when the in-band loopback codes are ignored. payload(2) designates a payload loopback is done upon recognition of the inband loopback code. lineloop(3) designates a line loopback is done upon recognition of the inband loopback code.')
sc553ConfigurationSave = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 11, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("saveall", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ConfigurationSave.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ConfigurationSave.setDescription('This variable is used to set the update status flag for saving network and channel configuration settings. Management can only set a saveall(2). A norm(1) will always be read. Configuration settings are not saved to network element by default. This permits the configuration of several objects before saving. After all objects are set-up, a (2) must be sent. This will enable and save the new configuration(s). ')
sc553DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1), )
if mibBuilder.loadTexts: sc553DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagTable.setDescription('The SC553 Diagnostics table.')
sc553DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553DiagIndex"))
if mibBuilder.loadTexts: sc553DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagEntry.setDescription('The SNMP553S Diagnostics table entry.')
sc553DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier, which in this case is a network interface.')
sc553DiagTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("testTime30Secs", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("testTimeInfinite", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagTestDuration.setDescription('Selects the duration to run a diagnostic test. ')
sc553DiagProgPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagProgPattern.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagProgPattern.setDescription('The 16 bit user programmable test pattern. This object works with the sc553DiagT1SelfTestPattern object in that when it is set to t1ProgPattern(4), the the value of this object is used as the 16 bit user programmable test pattern. This object is used for all tests defined in both the GDC dsx1 mib.')
sc553InsertBitError = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("insertBitErrorNorm", 1), ("insertOneBitError", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553InsertBitError.setStatus('mandatory')
if mibBuilder.loadTexts: sc553InsertBitError.setDescription('A set of 2 will insert one bit error for test. Management may only write a 2. A 1 will always be read. ')
sc553DiagDS0Number = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagDS0Number.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagDS0Number.setDescription('Indicates the DS0 number for the test. The valid range is between one (1) and twenty-four (24).')
sc553DiagT1SelfTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("t1511Pattern", 1), ("t12047Pattern", 2), ("t1QRSPattern", 3), ("t1ProgPattern", 4), ("t13in24", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagT1SelfTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagT1SelfTestPattern.setDescription('The selected option is used when a sc553DiagT1Test is performed. ')
sc553DiagT1Test = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("t1SelfTest", 1), ("t1LocalSelfTest", 2), ("t1RemoteSelfTest", 3), ("t1LocalTest", 4), ("t1RemoteTest", 5), ("t1NetworkInterface", 6), ("t1LineLoopback", 7), ("t1PayLoadLoopback", 8), ("t1NoTest", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagT1Test.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagT1Test.setDescription(' ')
sc553DiagDS0SelfTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds0511Pattern", 1), ("ds02047Pattern", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagDS0SelfTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagDS0SelfTestPattern.setDescription('The selected option is used when a sc553DiagDS0Test is performed. ')
sc553DiagDS0Test = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ds0SelfTest", 1), ("ds0CircuitDelay", 2), ("ds0Loopback", 3), ("ds0NoDS0Test", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagDS0Test.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagDS0Test.setDescription(' ')
sc553DiagChannelSelfTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("chan511Pattern", 1), ("chan2047Pattern", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagChannelSelfTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagChannelSelfTestPattern.setDescription('The selected option is used when a sc553DiagChannelTest is performed. ')
sc553DiagChannelTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("chanSelfTest", 1), ("chanLocalSelfTest", 2), ("chanRemoteSelfTest", 3), ("chandigitalLoop", 4), ("chanLocalLoop", 5), ("chanRemoteDataLoop", 6), ("chanNoTest", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagChannelTest.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagChannelTest.setDescription(' Reading will indicate the ')
sc553DiagTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553DiagTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagTestResults.setDescription('Returns a the folowing bytes. Octet 1 bit 7 - parity bit 6 - f/u bit 5 - 1: Circuit Delay Results or 0: for Bit Error Count bit 4 - 1: Test is in Progress, 0: Test not in progress bit 3 - 1: Remote Test did not loop bit 2 - 1: Remote Digital Loop did not loop bit 1 - 1: No Sync bit 0 - 1: Bit Over Range Octet 2 bit 7 - parity bit 6 - f/u bit 5 - 2^19 Bit Error Count / Circuit Delay ms bit 4 - 2^18 bit 3 - 2^17 bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - parity bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - parity bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
sc553DiagTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("statNoTestinProgress", 1), ("statT1SelfTest", 2), ("statT1LocalSelfTest", 3), ("statT1RemoteSelfTest", 4), ("statT1LocalTest", 5), ("statT1RemoteTest", 6), ("statT1NetworkInterface", 7), ("statT1LineLoopback", 8), ("statT1PayLoadLoopback", 9), ("statChanSelfTest", 10), ("statChanLocalSelfTest", 11), ("statChanRemoteSelfTest", 12), ("statChandigitalLoop", 13), ("statChanLocalLoop", 14), ("statChanRemoteDataLoop", 15), ("statDS0SelfTest", 16), ("statDS0CircuitDelay", 17), ("statDS0Loopback", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553DiagTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagTestStatus.setDescription('This object will return the test current test in progress, if any.')
sc553DiagResetTestToNormal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("resetTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagResetTestToNormal.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagResetTestToNormal.setDescription('This object will halt the execution of any and all diagnostic test that may be running with the exception of the Network Delay Test.')
sc553DiagResetTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("resetTestResult", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagResetTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagResetTestResults.setDescription('This object will clear the results register while running any test except for Network Delay. Starting a new test will automatically zero out the register. A normal(1) will always be read. Management will set a resetTestResult(2) to reset the test results. ')
sc553DiagT1TestDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("toNetwork", 1), ("toCascade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagT1TestDirection.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagT1TestDirection.setDescription('Selects the test direction for T1 tests.')
sc553DiagDS0TestDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("toNetwork", 1), ("toCascade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DiagDS0TestDirection.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DiagDS0TestDirection.setDescription('Selects the test direction for DS0 tests.')
sc553MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1), )
if mibBuilder.loadTexts: sc553MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553MaintenanceTable.setDescription('The table describes the maintenance functions for the sc553. ')
sc553MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553MaintenanceIndex"))
if mibBuilder.loadTexts: sc553MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553MaintenanceEntry.setDescription('An entry in the GDC maintenance Table')
sc553MaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553MaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553MaintenanceIndex.setDescription('The index value: slot, line, drop, and interface')
sc553LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc553LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state and front panel switches. Octet 1 bit 7 - not used bit 6 - ON (0:LED inactive 1:LED active) bit 5 - f/u bit 4 - RSP bit 3 - f/u bit 2 - f/u bit 1 - f/u bit 0 - f/u Octet 2 bit 7 - not used bit 6 - NET OOF bit 5 - NET NS bit 4 - NET BPV bit 3 - NET AIS bit 2 - TM bit 1 - ALM bit 0 - f/u Octet 3 bit 7 - not used bit 6 - CHA SD bit 5 - CHA RD bit 4 - INS bit 3 - CH bit 2 - T1 bit 1 - RL bit 0 - EQP ')
sc553SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: sc553SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(1), then the unit performs a soft reset. The value norm will be returned when the reset is complete. The value of norm can not be set by management.')
sc553DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("factoryDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault, the unit will reset to the default configuration. The value of normal will be returned when the initialization is complete. The value normal can not be set by management.')
sc553FrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553FrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FrontPanel.setDescription('This variable is used to indicate whether the front panel switches are operational or not.')
sc553ProductType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("sc553", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ProductType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ProductType.setDescription('Indicates the product type of the unit.')
sc553ResetStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553ResetStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ResetStatistics.setDescription('Supports the action of soft resetting the sc553ValidIntervals object. When this object is set to reset(2), then the unit will reset the sc553ValidIntervals object to zero. The value of norm(1) can not be set by management.')
sc553ValidUserIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ValidUserIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ValidUserIntervals.setDescription('The number of previous User intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
sc553ValidNetworkIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ValidNetworkIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ValidNetworkIntervals.setDescription('The number of previous Network intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
sc553ValidFarEndIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ValidFarEndIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ValidFarEndIntervals.setDescription('The number of previous Far End intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
sc553CascadePresent = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CascadePresent.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CascadePresent.setDescription('Identifies whether or not the cascade interface cards are installed.')
sc553ReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("invalidNiDSX1", 1), ("noSignal", 2), ("pos2toNeg7andOneHalf", 3), ("neg7andOneHalftoNeg15", 4), ("neg15toNeg22andOneHalf", 5), ("lessThanNeg22andOneHalf", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ReceiveLevel.setDescription(' invalidNiDSX1(1) indicates an invalid request because the Network Interface is configured as DSX-1. noSignal(2) is present when there is no T1 signal detected (NS led on front panel will be on). The last 4 options (3) - (6) indicate the ranges for receive level: (3): +2db to -7.5db (4): -7.5db to -15db (5): -15db to -22.5db (6): less than -22.5db ')
sc553DteStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553DteStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553DteStat.setDescription('Returns a bitwise snapshot of the DTE signals. Octet 1 bit 7 - not used bit 6 - CTS (1:ON; 0:OFF) bit 5 - RTS (1:ON; 0:OFF) bit 4 - DTR (1:ON; 0:OFF) bit 3 - DSR (1:ON; 0:OFF) bit 2 - future use bit 1 - DCD (1:ON; 0:OFF) bit 0 - future use Octet 2 bit 7 - not used bit 6 - RXC (1:Transitions) bit 5 - DCD (1:Transitions) bit 4 - RTS (1:Transitions) bit 3 - CTS (1:Transitions) bit 2 - RXD (1:Transitions) bit 1 - TXC (1:Transitions) bit 0 - TXD (1:Transitions)')
sc553CasReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("invalidNiDSX1", 1), ("noSignal", 2), ("pos2toNeg7andOneHalf", 3), ("neg7andOneHalftoNeg15", 4), ("neg15toNeg22andOneHalf", 5), ("lessThanNeg22andOneHalf", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CasReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CasReceiveLevel.setDescription(' invalidNiDSX1(1) indicates an invalid request because the Cascade Interface is configured as DSX-1. noSignal(2) is present when there is no T1 signal detected (NS led on front panel will be on). The last 4 options (3) - (6) indicate the ranges for receive level: (3): +2db to -7.5db (4): -7.5db to -15db (5): -15db to -22.5db (6): less than -22.5db ')
sc553ShelfType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("spectracomm", 1), ("twinPack", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ShelfType.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfType.setDescription('Type of shelf the sc553 is located in.')
sc553TwinPackPowerSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("bottomOnly", 2), ("topOnly", 3), ("both", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TwinPackPowerSupply.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TwinPackPowerSupply.setDescription('Power supplies currently installed in Twin Pack. When the sc553 is located in a Spectracomm shelf none(1) will always be returned.')
sc553TestAllLeds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allLedsON", 1), ("allLedsOFF", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553TestAllLeds.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TestAllLeds.setDescription('This variable is used to test the front panel leds and individual segments of the display. A one (1) will turn all leds and display segments on. They will remain on until a two (2) is set or the card is rebooted')
sc553AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1))
sc553NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 1))
sc553DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 2))
sc553PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 3))
sc553NvRamCorruptAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 4))
sc553UnitFailureAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 5))
sc553StatusChangeAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 6))
sc553UnsolicitedTestAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 7))
sc553FrontPanelTestAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 8))
sc553ConfigChangeAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 9))
sc553TimingLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 10))
sc553LossOfSignalAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 11))
sc553LossOfFrameAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 12))
sc553AlarmIndicationSignalAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 13))
sc553ReceivedYellowAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 14))
sc553UnavailableSignalStateAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 15))
sc553CrcErrorsAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 16))
sc553BipolarViolationsAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 17))
sc553LowAverageDensityAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 18))
sc553ExternalTXClockLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 19))
sc553DCDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 20))
sc553DSRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 21))
sc553DTRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 22))
sc553RXDNoTransitionsAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 23))
sc553TXDNoTransitionsAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 24))
sc553RedundancyOn = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 25))
sc553RemoteNotResponding = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 26))
sc553TopPowerSupplyFail = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 27))
sc553BottomPowerSupplyFail = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 1, 28))
sc553AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2), )
if mibBuilder.loadTexts: sc553AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmConfigTable.setDescription('The sc553AlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
sc553AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553AlarmConfigIndex"), (0, "GDC-SC553-MIB", "sc553AlarmConfigIdentifier"))
if mibBuilder.loadTexts: sc553AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmConfigEntry.setDescription('An entry in the GDC Alarm Configuration table.')
sc553AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
sc553AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
sc553AlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("reportAll", 1), ("last1sec", 2), ("last1min", 3), ("last1hr", 4), ("reportWhen", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553AlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmCountWindow.setDescription('This variable sets/reads the alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting.')
sc553AlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thresGT10", 1), ("thresGT100", 2), ("thresGT1000", 3), ("thresGT10000", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553AlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sc553AlarmCountThreshold.setDescription('This function sets/reads the alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active.')
sc553CurrentUserTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 1), )
if mibBuilder.loadTexts: sc553CurrentUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentUserTable.setDescription('The sc553 CurrentUser table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553CurrentUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 1, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553CurrentUserIndex"))
if mibBuilder.loadTexts: sc553CurrentUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentUserEntry.setDescription('An entry in the sc553 CurrentUser table.')
sc553CurrentUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentUserIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentUserIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553CurrentUserStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentUserStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentUserStat.setDescription("Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - 2^15 CRC's bit 5 - 2^14 bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^13 CRC's bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - parity bit 6 - 2^6 CRC's bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ")
sc553CurrentNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 2), )
if mibBuilder.loadTexts: sc553CurrentNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentNetworkTable.setDescription('The sc553 CurrentNetwork table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553CurrentNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 2, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553CurrentNetworkIndex"))
if mibBuilder.loadTexts: sc553CurrentNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentNetworkEntry.setDescription('An entry in the sc553 CurrentNetwork table.')
sc553CurrentNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentNetworkIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553CurrentNetworkStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentNetworkStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentNetworkStat.setDescription("Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - 2^15 CRC's bit 5 - 2^14 bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^13 CRC's bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - parity bit 6 - 2^6 CRC's bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ")
sc553CurrentFarEndTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 3), )
if mibBuilder.loadTexts: sc553CurrentFarEndTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentFarEndTable.setDescription('The sc553 CurrentFarEnd table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553CurrentFarEndEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 3, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553CurrentFarEndIndex"))
if mibBuilder.loadTexts: sc553CurrentFarEndEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentFarEndEntry.setDescription('An entry in the sc553 CurrentFarEnd table.')
sc553CurrentFarEndIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentFarEndIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentFarEndIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553CurrentFarEndStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553CurrentFarEndStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553CurrentFarEndStat.setDescription("Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - 2^15 CRC's bit 5 - 2^14 bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^13 CRC's bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - parity bit 6 - 2^6 CRC's bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ")
sc553TotalUserTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 4), )
if mibBuilder.loadTexts: sc553TotalUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalUserTable.setDescription('The sc553 TotalUser table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553TotalUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 4, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553TotalUserIndex"))
if mibBuilder.loadTexts: sc553TotalUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalUserEntry.setDescription('An entry in the sc553 TotalUser table.')
sc553TotalUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalUserIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalUserIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553TotalUserStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalUserStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalUserStat.setDescription("Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - 2^15 CRC's bit 5 - 2^14 bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^13 CRC's bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - parity bit 6 - 2^6 CRC's bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ")
sc553TotalNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 5), )
if mibBuilder.loadTexts: sc553TotalNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalNetworkTable.setDescription('The sc553 TotalNetwork table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553TotalNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 5, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553TotalNetworkIndex"))
if mibBuilder.loadTexts: sc553TotalNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalNetworkEntry.setDescription('An entry in the sc553 TotalNetwork table.')
sc553TotalNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalNetworkIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553TotalNetworkStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalNetworkStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalNetworkStat.setDescription('Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 14 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
sc553TotalFarEndTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 6), )
if mibBuilder.loadTexts: sc553TotalFarEndTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalFarEndTable.setDescription('The sc553 TotalFarEnd table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553TotalFarEndEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 6, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553TotalFarEndIndex"))
if mibBuilder.loadTexts: sc553TotalFarEndEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalFarEndEntry.setDescription('An entry in the sc553 TotalFarEnd table.')
sc553TotalFarEndIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalFarEndIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalFarEndIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553TotalFarEndStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553TotalFarEndStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc553TotalFarEndStat.setDescription('Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 14 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 15 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
sc553UserIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 7), )
if mibBuilder.loadTexts: sc553UserIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553UserIntervalTable.setDescription('The sc553 User Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553UserIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 7, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553UserIntervalIndex"), (0, "GDC-SC553-MIB", "sc553UserIntervalNumber"))
if mibBuilder.loadTexts: sc553UserIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553UserIntervalEntry.setDescription('An entry in the DS1 Interval table.')
sc553UserIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553UserIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553UserIntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553UserIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553UserIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc553UserIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
sc553UserIntervalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553UserIntervalStats.setStatus('mandatory')
if mibBuilder.loadTexts: sc553UserIntervalStats.setDescription("Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - 2^15 CRC's bit 5 - 2^14 bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^13 CRC's bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - parity bit 6 - 2^6 CRC's bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 15 bit 7 - parity bit 6 - 2^6 Interval 1 thru 96 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ")
sc553NetworkIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 8), )
if mibBuilder.loadTexts: sc553NetworkIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkIntervalTable.setDescription('The sc553 Network Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553NetworkIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 8, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553NetworkIntervalIndex"), (0, "GDC-SC553-MIB", "sc553NetworkIntervalNumber"))
if mibBuilder.loadTexts: sc553NetworkIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkIntervalEntry.setDescription('An entry in the DS1 Interval table.')
sc553NetworkIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkIntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553NetworkIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
sc553NetworkIntervalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553NetworkIntervalStats.setStatus('mandatory')
if mibBuilder.loadTexts: sc553NetworkIntervalStats.setDescription('Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 14 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 15 bit 7 - parity bit 6 - 2^6 Interval 1 thru 96 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
sc553FarEndIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 9), )
if mibBuilder.loadTexts: sc553FarEndIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FarEndIntervalTable.setDescription('The sc553 FarEnd Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
sc553FarEndIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 9, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553FarEndIntervalIndex"), (0, "GDC-SC553-MIB", "sc553FarEndIntervalNumber"))
if mibBuilder.loadTexts: sc553FarEndIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FarEndIntervalEntry.setDescription('An entry in the DS1 Interval table.')
sc553FarEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 9, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553FarEndIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FarEndIntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
sc553FarEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553FarEndIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FarEndIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
sc553FarEndIntervalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553FarEndIntervalStats.setStatus('mandatory')
if mibBuilder.loadTexts: sc553FarEndIntervalStats.setDescription('Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 14 bit 7 - parity bit 6 - fu bit 5 - fu bit 4 - fu bit 3 - fu bit 2 - fu bit 1 - fu bit 0 - fu Octet 15 bit 7 - parity bit 6 - 2^6 Interval 1 thru 96 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
sc553StoreUserTotals = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("store", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553StoreUserTotals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553StoreUserTotals.setDescription('A set of this object will be broadcasted to every sc553 in the shelf. Upon receiving the broadcast, the sc553 will write the contents of sc553TotalUserStat to memory for collection at a later time. A get of this object will always return a 1.')
sc553StoreUserIntervals = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("store", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc553StoreUserIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553StoreUserIntervals.setDescription('A set of this object will be broadcasted to every sc553 in the shelf. Upon receiving the broadcast, the sc553 will write the contents of sc553UserIntervalStats for each interval to memory for collection at a later time. A get of this object will always return a 1.')
sc553ShelfUserTotals = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 465))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ShelfUserTotals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfUserTotals.setDescription('Collects the User Totals that were stored by the set of sc553StoreUserTotals for all sc553s in the shelf. The data for each sc553 is contained in 15 octet groupings where each grouping is encoded in the following way: Octet 1: Control Octet containing the slot (1-32) of the sc553 and an invalid/valid data flag. The data in the following 14 octets is invalid if the MSB is set. Octet 2,3: Errored Seconds Total Octet 4,5: Bursty Errored Seconds Total Octet 6,7: Severely Errored Seconds Total Octet 8,9: Unavailable Seconds Total Octet 10,11: CRC Errors Total Octet 12,13: Loss of Frame Total Octet 14,15: Controlled Slip Seconds Total If there are no sc553s in the shelf then a null string is returned.')
sc553ShelfUserIntvlsTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 13), )
if mibBuilder.loadTexts: sc553ShelfUserIntvlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfUserIntvlsTable.setDescription('The sc553ShelfUserIntvlsTable contains the user statistics for all sc553s in the shelf.')
sc553ShelfUserIntervalsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 13, 1), ).setIndexNames((0, "GDC-SC553-MIB", "sc553ShelfUserIntvlsIndex"))
if mibBuilder.loadTexts: sc553ShelfUserIntervalsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfUserIntervalsEntry.setDescription('An entry in the Shelf User Intervals table.')
sc553ShelfUserIntvlsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ShelfUserIntvlsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfUserIntvlsIndex.setDescription('The index value which uniquely determines the interval.')
sc553ShelfUserIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 11, 6, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 465))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc553ShelfUserIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc553ShelfUserIntervals.setDescription('Collects the User Statistics that were stored by the set of sc553StoreUserIntervals for the interval given by sc553ShelfUserIntervalsIndex for all sc553s in the shelf. The data for each sc553 is contained in 15 octet groupings where each grouping is encoded in the following way: Octet 1: Control Octet containing the slot (1-32) of the sc553 and an invalid/valid data flag. The data in the following 14 octets is invalid if the MSB is set. Octet 2,3: Errored Seconds Octet 4,5: Bursty Errored Seconds Octet 6,7: Severely Errored Seconds Octet 8,9: Unavailable Seconds Octet 10,11: CRC Errors Octet 12,13: Loss of Frame Octet 14,15: Controlled Slip Seconds If there are no sc553s in the shelf then a null string is returned.')
mibBuilder.exportSymbols("GDC-SC553-MIB", sc553MaintenanceTable=sc553MaintenanceTable, sc553TotalUserIndex=sc553TotalUserIndex, sc553NetworkIntervalIndex=sc553NetworkIntervalIndex, sc553TotalNetworkIndex=sc553TotalNetworkIndex, sc553ChannelNumberOfDS0s=sc553ChannelNumberOfDS0s, sc553ChannelInbandLoopdown=sc553ChannelInbandLoopdown, sc553ValidUserIntervals=sc553ValidUserIntervals, sc553ChannelLocalDSR=sc553ChannelLocalDSR, sc553NetworkTransmitClockSource=sc553NetworkTransmitClockSource, sc553CascadeConfigIndex=sc553CascadeConfigIndex, sc553DiagDS0SelfTestPattern=sc553DiagDS0SelfTestPattern, sc553SoftReset=sc553SoftReset, sc553Configuration=sc553Configuration, sc553UserIntervalNumber=sc553UserIntervalNumber, sc553DiagTestResults=sc553DiagTestResults, sc553VersionEntry=sc553VersionEntry, sc553DownloadingMode=sc553DownloadingMode, sc553DiagDS0TestDirection=sc553DiagDS0TestDirection, sc553AlarmConfigTable=sc553AlarmConfigTable, sc553Diagnostics=sc553Diagnostics, sc553TestAllLeds=sc553TestAllLeds, sc553UserIntervalTable=sc553UserIntervalTable, sc553DiagProgPattern=sc553DiagProgPattern, sc553StoreUserTotals=sc553StoreUserTotals, sc553DiagTestDuration=sc553DiagTestDuration, sc553PowerUpAlm=sc553PowerUpAlm, sc553VersionIndex=sc553VersionIndex, sc553CasReceiveLevel=sc553CasReceiveLevel, sc553TwinPackPowerSupply=sc553TwinPackPowerSupply, sc553StatusChangeAlm=sc553StatusChangeAlm, sc553DiagChannelTest=sc553DiagChannelTest, sc553StoredFirmwareRev=sc553StoredFirmwareRev, sc553NetworkLoopbackConfig=sc553NetworkLoopbackConfig, sc553Performance=sc553Performance, sc553NetworkFDLdcc=sc553NetworkFDLdcc, sc553DiagTestStatus=sc553DiagTestStatus, sc553TotalFarEndEntry=sc553TotalFarEndEntry, sc553FarEndIntervalTable=sc553FarEndIntervalTable, sc553NetworkLineCoding=sc553NetworkLineCoding, sc553VersionTable=sc553VersionTable, sc553ChannelLocalDCD=sc553ChannelLocalDCD, sc553LedStatus=sc553LedStatus, sc553BipolarViolationsAlm=sc553BipolarViolationsAlm, sc553NetworkConfigIndex=sc553NetworkConfigIndex, sc553NetworkIntervalStats=sc553NetworkIntervalStats, sc553UnsolicitedTestAlm=sc553UnsolicitedTestAlm, sc553TotalUserStat=sc553TotalUserStat, sc553AlarmConfigIndex=sc553AlarmConfigIndex, sc553FarEndIntervalStats=sc553FarEndIntervalStats, sc553CascadePresent=sc553CascadePresent, sc553DSRLossAlm=sc553DSRLossAlm, sc553DiagDS0Number=sc553DiagDS0Number, sc553CascadeFdl=sc553CascadeFdl, dsx1=dsx1, sc553NetworkFdl=sc553NetworkFdl, sc553LossOfSignalAlm=sc553LossOfSignalAlm, sc553ReceivedYellowAlm=sc553ReceivedYellowAlm, sc553DTRLossAlm=sc553DTRLossAlm, sc553CascadeFDLdcc=sc553CascadeFDLdcc, sc553MaintenanceEntry=sc553MaintenanceEntry, sc553CurrentFarEndIndex=sc553CurrentFarEndIndex, sc553CurrentFarEndTable=sc553CurrentFarEndTable, sc553CurrentNetworkIndex=sc553CurrentNetworkIndex, sc553TotalNetworkTable=sc553TotalNetworkTable, sc553MIBversion=sc553MIBversion, sc553UnitFailureAlm=sc553UnitFailureAlm, sc553NetworkIntervalEntry=sc553NetworkIntervalEntry, sc553CrcErrorsAlm=sc553CrcErrorsAlm, sc553TotalFarEndIndex=sc553TotalFarEndIndex, sc553TopPowerSupplyFail=sc553TopPowerSupplyFail, sc553NetworkAdminLineBuildout=sc553NetworkAdminLineBuildout, sc553UserIntervalEntry=sc553UserIntervalEntry, sc553CurrentUserStat=sc553CurrentUserStat, sc553CurrentFarEndStat=sc553CurrentFarEndStat, sc553SwitchActiveFirmware=sc553SwitchActiveFirmware, sc553NetworkOperLineType=sc553NetworkOperLineType, sc553NetworkOperLineBuildout=sc553NetworkOperLineBuildout, sc553NetworkOnesDensity=sc553NetworkOnesDensity, sc553ShelfUserIntervals=sc553ShelfUserIntervals, sc553MaintenanceIndex=sc553MaintenanceIndex, sc553DiagResetTestToNormal=sc553DiagResetTestToNormal, sc553CascadeOperLineBuildout=sc553CascadeOperLineBuildout, sc553=sc553, sc553ChannelNetworkNumber=sc553ChannelNetworkNumber, sc553ChannelStartingDS0=sc553ChannelStartingDS0, sc553AlarmCountWindow=sc553AlarmCountWindow, sc553FarEndIntervalIndex=sc553FarEndIntervalIndex, sc553BootRev=sc553BootRev, sc553CascadeAISLoopdown=sc553CascadeAISLoopdown, sc553TimingLossAlm=sc553TimingLossAlm, sc553ChannelConfigIndex=sc553ChannelConfigIndex, sc553ChannelChannelType=sc553ChannelChannelType, sc553DiagRxErrAlm=sc553DiagRxErrAlm, sc553NetworkIntervalNumber=sc553NetworkIntervalNumber, sc553ChannelActivePort=sc553ChannelActivePort, sc553StoreUserIntervals=sc553StoreUserIntervals, sc553UnavailableSignalStateAlm=sc553UnavailableSignalStateAlm, sc553NetworkIntervalTable=sc553NetworkIntervalTable, sc553ChannelRTSCTSControl=sc553ChannelRTSCTSControl, sc553NetworkFallbackClockSource=sc553NetworkFallbackClockSource, sc553FrontPanelTestAlm=sc553FrontPanelTestAlm, sc553DiagTable=sc553DiagTable, sc553DiagResetTestResults=sc553DiagResetTestResults, sc553CascadeConfigTable=sc553CascadeConfigTable, sc553CascadeInService=sc553CascadeInService, sc553DteStat=sc553DteStat, sc553ExternalTXClockLossAlm=sc553ExternalTXClockLossAlm, sc553ChannelDataInvert=sc553ChannelDataInvert, sc553RXDNoTransitionsAlm=sc553RXDNoTransitionsAlm, sc553ConfigChangeAlm=sc553ConfigChangeAlm, sc553CascadeOperLineType=sc553CascadeOperLineType, sc553ChannelEIAtestLeads=sc553ChannelEIAtestLeads, sc553ChannelOperClkInvert=sc553ChannelOperClkInvert, sc553RemoteNotResponding=sc553RemoteNotResponding, sc553DefaultInit=sc553DefaultInit, sc553ActiveFirmwareRev=sc553ActiveFirmwareRev, sc553InsertBitError=sc553InsertBitError, sc553ReceiveLevel=sc553ReceiveLevel, sc553ValidFarEndIntervals=sc553ValidFarEndIntervals, sc553DCDLossAlm=sc553DCDLossAlm, sc553CurrentFarEndEntry=sc553CurrentFarEndEntry, sc553ChannelNetworkPosition=sc553ChannelNetworkPosition, sc553NetworkAdminLineType=sc553NetworkAdminLineType, sc553NetworkConfigTable=sc553NetworkConfigTable, sc553ValidNetworkIntervals=sc553ValidNetworkIntervals, sc553ShelfType=sc553ShelfType, sc553LowAverageDensityAlm=sc553LowAverageDensityAlm, sc553TotalUserEntry=sc553TotalUserEntry, sc553Version=sc553Version, sc553DiagChannelSelfTestPattern=sc553DiagChannelSelfTestPattern, sc553AlarmConfigEntry=sc553AlarmConfigEntry, sc553CascadeAdminLineType=sc553CascadeAdminLineType, sc553DiagT1Test=sc553DiagT1Test, sc553ShelfUserIntvlsTable=sc553ShelfUserIntvlsTable, sc553TotalFarEndStat=sc553TotalFarEndStat, sc553ChannelSplitTiming=sc553ChannelSplitTiming, sc553Alarms=sc553Alarms, sc553AlarmCountThreshold=sc553AlarmCountThreshold, sc553UserIntervalIndex=sc553UserIntervalIndex, sc553BottomPowerSupplyFail=sc553BottomPowerSupplyFail, sc553ConfigurationSave=sc553ConfigurationSave, sc553ShelfUserIntervalsEntry=sc553ShelfUserIntervalsEntry, sc553TotalUserTable=sc553TotalUserTable, sc553ShelfUserTotals=sc553ShelfUserTotals, sc553ResetStatistics=sc553ResetStatistics, sc553FarEndIntervalEntry=sc553FarEndIntervalEntry, sc553AlarmConfigIdentifier=sc553AlarmConfigIdentifier, sc553AlarmData=sc553AlarmData, sc553TXDNoTransitionsAlm=sc553TXDNoTransitionsAlm, sc553StoredFirmwareStatus=sc553StoredFirmwareStatus, sc553ChannelAdminClkInvert=sc553ChannelAdminClkInvert, sc553AlarmIndicationSignalAlm=sc553AlarmIndicationSignalAlm, sc553DiagEntry=sc553DiagEntry, sc553NetworkAISLoopdown=sc553NetworkAISLoopdown, sc553CascadeAdminLineBuildout=sc553CascadeAdminLineBuildout, sc553ChannelInbandLoop=sc553ChannelInbandLoop, sc553CascadeInterfaceType=sc553CascadeInterfaceType, sc553CascadeLoopbackConfig=sc553CascadeLoopbackConfig, sc553DiagT1SelfTestPattern=sc553DiagT1SelfTestPattern, sc553FrontPanel=sc553FrontPanel, sc553DiagDS0Test=sc553DiagDS0Test, sc553NetworkConfigEntry=sc553NetworkConfigEntry, sc553channelRedundancy=sc553channelRedundancy, sc553NoResponseAlm=sc553NoResponseAlm, sc553ChannelInService=sc553ChannelInService, sc553CurrentUserEntry=sc553CurrentUserEntry, sc553ShelfUserIntvlsIndex=sc553ShelfUserIntvlsIndex, sc553CascadeConfigEntry=sc553CascadeConfigEntry, sc553CurrentNetworkStat=sc553CurrentNetworkStat, sc553CurrentNetworkEntry=sc553CurrentNetworkEntry, sc553TotalNetworkStat=sc553TotalNetworkStat, sc553UserIntervalStats=sc553UserIntervalStats, sc553RedundancyOn=sc553RedundancyOn, sc553ChannelConfigEntry=sc553ChannelConfigEntry, sc553ChannelDS0AllocationScheme=sc553ChannelDS0AllocationScheme, sc553NetworkInterfaceType=sc553NetworkInterfaceType, sc553LossOfFrameAlm=sc553LossOfFrameAlm, sc553WakeUpRemote=sc553WakeUpRemote, sc553ProductType=sc553ProductType, sc553CurrentNetworkTable=sc553CurrentNetworkTable, sc553ChannelConfigTable=sc553ChannelConfigTable, sc553CurrentUserTable=sc553CurrentUserTable, sc553Maintenance=sc553Maintenance, sc553CurrentUserIndex=sc553CurrentUserIndex, sc553NvRamCorruptAlm=sc553NvRamCorruptAlm, sc553NetworkPreequalization=sc553NetworkPreequalization, sc553TotalFarEndTable=sc553TotalFarEndTable, sc553DiagT1TestDirection=sc553DiagT1TestDirection, sc553DiagIndex=sc553DiagIndex, sc553ChannelBaseRate=sc553ChannelBaseRate, sc553FarEndIntervalNumber=sc553FarEndIntervalNumber, sc553ChannelInbandDccMode=sc553ChannelInbandDccMode, sc553TotalNetworkEntry=sc553TotalNetworkEntry, sc553CascadeLineCoding=sc553CascadeLineCoding, sc553CascadePreequalization=sc553CascadePreequalization)

#
# PySNMP MIB module DEPNODE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEPNODE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:38:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter64, Unsigned32, ObjectIdentity, Gauge32, iso, enterprises, ModuleIdentity, Counter32, TimeTicks, Bits, Integer32, IpAddress, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter64", "Unsigned32", "ObjectIdentity", "Gauge32", "iso", "enterprises", "ModuleIdentity", "Counter32", "TimeTicks", "Bits", "Integer32", "IpAddress", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibmSP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 117))
ibmSPDepNode = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 117, 4))
ibmSPDepNodeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1), )
if mibBuilder.loadTexts: ibmSPDepNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeTable.setDescription("This entity's table of dependent secondary nodes attached to IBM SP switch networks.")
ibmSPDepNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1), ).setIndexNames((0, "DEPNODE-MIB", "ibmSPDepNodeName"))
if mibBuilder.loadTexts: ibmSPDepNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeEntry.setDescription('Configuration information for a dependent secondary node on SP switch network.')
ibmSPDepNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSPDepNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeName.setDescription("Identifier assigned to this node in its system's administrative environment.")
ibmSPDepNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeNumber.setDescription('Relative node number assigned to this node in the SP system. Note that this is distinct from switch node number.')
ibmSPDepSwToken = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepSwToken.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepSwToken.setDescription("Opaque correlator assigned in the SP system for this node's switch connection.")
ibmSPDepSwARP = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepSwARP.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepSwARP.setDescription('Indicates whether ARP is enabled for the partition of the switch network that contains the associated dependent secondary node. NOTE: An SNMP Agent may be responsible for switch nodes in several SP system partitions, and ARP may be enabled in none, some, or all of the partitions. A value of disabled(1) indicates that ARP is not to be used to resolve network protocol addresses to switch node numbers for the switch network. Instead, the mapping of IP addresses to switch node numbers is determined via the algorithm in the description of ibmSPDepIPHostOffset. A value of enabled(2) indicates that ARP is to be used to resolve network protocol addresses to switch node numbers for the switch network.')
ibmSPDepSwNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepSwNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepSwNodeNumber.setDescription('The switch node number of the associated SP switch interface. In common networking terminology, this is the physical address for the interface on the SP switch network, and is also called the Node Device ID in the SP dependent node architecture.')
ibmSPDepIPaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepIPaddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepIPaddr.setDescription('The IP address for the associated SP switch interface.')
ibmSPDepNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNetMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the host bits set to 0.')
ibmSPDepIPMaxLinkPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepIPMaxLinkPkt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepIPMaxLinkPkt.setDescription('The maximum number of bytes in the data portion of link-layer packets for IP datagrams on the SP switch network.')
ibmSPDepIPHostOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepIPHostOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepIPHostOffset.setDescription('This value is the difference between switch node numbers and the host portion of the corresponding IP addresses when ARP is disabled on the SP switch network. It is the value to subtract from the host portion of an IP address to calculate the corresponding switch node number.')
ibmSPDepConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notConfigured", 1), ("firmwareLoadFailed", 2), ("driverLoadFailed", 3), ("diagnosticFailed", 4), ("microcodeLoadFailed", 5), ("fullyConfigured", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSPDepConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepConfigState.setDescription('This value indicates the final configuration state of the corresponding SP switch interface.')
ibmSPDepSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepSysName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepSysName.setDescription('The fully-qualified domain name of the SP system partition that contains this dependent node. This name is administratively assigned in the SP system.')
ibmSPDepNodeState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nodeUp", 1), ("nodeDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSPDepNodeState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeState.setDescription('This value indicates the state of the dependent node with respect to its capability to handle Switch Manager protocol via its SP switch interface. A value of nodeUp(1) indicates that the node has been reinitialized or reconfigured sufficiently to handle the Switch Manager protocol to unfence the node if it were previously fenced from the SP switch network. A value of nodeDown(2) indicates that the node is no longer able to handle Switch Manager protocol messages on the SP switch network.')
ibmSPDepSwChipLink = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepSwChipLink.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepSwChipLink.setDescription('The send port number for packets from the adjacent switch chip to the dependent node. The dependent node needs this value to build the packet that it sends to the adjacent switch chip to trigger that chip to reply with a clock synchronization packet.')
ibmSPDepNodeDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepNodeDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepNodeDelay.setDescription('This value is an estimate of how many clock cycles elapse before a clock synchronization packet sent from the adjacent switch chip to the dependent node results in loading of the switch time-of-day register for the node. The dependent node needs this value to build the packet that it sends to the adjacent switch chip to trigger that chip to reply with a clock synchronization packet.')
ibmSPDepAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 117, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("reconfigure", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSPDepAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSPDepAdminStatus.setDescription('This value indicates the desired state of the dependent node with respect to its capability to handle Switch Manager protocol via its SP switch interface. If the dependent node is not in the desired state, then the SNMP Agent triggers actions to change its state to the desired state. A value of up(1) indicates that the node should be initialized and configured sufficiently to handle the Switch Manager protocol. A value of down(2) indicates that the node should be reset such that it is not able to receive and handle Switch Manager protocol messages on the SP switch network. A value of reconfigure(3) indicates that the SNMP Agent must send the switchInfoNeeded trap to request new SP switch configuration information for the dependent node. This causes the SNMP Manager to send the new configuration information for the dependent node MIB objects via set-request PDU(s). Once the new values are set by the SNMP Manager, the SNMP Agent reinitializes and reconfigures the dependent node sufficiently to handle the Switch Manager protocol.')
switchInfoNeeded = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 117, 4) + (0,1)).setObjects(("DEPNODE-MIB", "ibmSPDepNodeName"))
if mibBuilder.loadTexts: switchInfoNeeded.setDescription("A switchInfoNeeded trap signifies that the sending protocol entity needs SP switch configuration information for a dependent secondary node within the sender's configuration.")
switchConfigState = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 117, 4) + (0,2)).setObjects(("DEPNODE-MIB", "ibmSPDepConfigState"))
if mibBuilder.loadTexts: switchConfigState.setDescription("A switchConfigState trap indicates the final configuration state of a dependent secondary node's SP switch interface.")
switchNodeUp = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 117, 4) + (0,3)).setObjects(("DEPNODE-MIB", "ibmSPDepNodeName"))
if mibBuilder.loadTexts: switchNodeUp.setDescription("A switchNodeUp trap indicates that a dependent secondary node in the sender's configuration has just been reinitialized or reconfigured and is able to handle SP Switch Manager protocol messages.")
switchNodeDown = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 117, 4) + (0,4)).setObjects(("DEPNODE-MIB", "ibmSPDepNodeName"))
if mibBuilder.loadTexts: switchNodeDown.setDescription("A switchNodeDown trap indicates that a dependent secondary node in the sender's configuration is no longer able to handle Switch Manager protocol messages on the switch network.")
mibBuilder.exportSymbols("DEPNODE-MIB", ibmSPDepNodeEntry=ibmSPDepNodeEntry, ibmSPDepAdminStatus=ibmSPDepAdminStatus, ibmSPDepSwARP=ibmSPDepSwARP, ibmSP=ibmSP, ibmSPDepNode=ibmSPDepNode, ibmSPDepSwToken=ibmSPDepSwToken, ibmSPDepIPMaxLinkPkt=ibmSPDepIPMaxLinkPkt, switchNodeUp=switchNodeUp, ibmSPDepNodeName=ibmSPDepNodeName, switchConfigState=switchConfigState, ibmSPDepNodeState=ibmSPDepNodeState, ibmSPDepSwChipLink=ibmSPDepSwChipLink, ibmSPDepSysName=ibmSPDepSysName, ibmSPDepNodeTable=ibmSPDepNodeTable, ibmSPDepIPaddr=ibmSPDepIPaddr, ibmProd=ibmProd, ibm=ibm, ibmSPDepNodeDelay=ibmSPDepNodeDelay, ibmSPDepNodeNumber=ibmSPDepNodeNumber, switchNodeDown=switchNodeDown, ibmSPDepSwNodeNumber=ibmSPDepSwNodeNumber, ibmSPDepNetMask=ibmSPDepNetMask, ibmSPDepIPHostOffset=ibmSPDepIPHostOffset, switchInfoNeeded=switchInfoNeeded, ibmSPDepConfigState=ibmSPDepConfigState)

#
# PySNMP MIB module CISCO-CABLE-SPECTRUM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CABLE-SPECTRUM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndexOrZero, ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex", "InterfaceIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Gauge32, Integer32, Counter32, Bits, iso, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, Counter64, Unsigned32, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Gauge32", "Integer32", "Counter32", "Bits", "iso", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "Counter64", "Unsigned32", "ObjectIdentity", "TimeTicks")
RowStatus, DisplayString, TruthValue, TextualConvention, MacAddress, DateAndTime, StorageType, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TruthValue", "TextualConvention", "MacAddress", "DateAndTime", "StorageType", "TimeStamp")
ciscoCableSpectrumMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 114))
ciscoCableSpectrumMIB.setRevisions(('2011-04-08 00:00', '2006-10-10 00:00', '2004-09-05 00:00', '2004-07-14 00:00', '2004-03-02 00:00', '2003-06-18 00:00', '2002-06-10 00:00', '2001-02-01 00:00', '2000-08-18 00:00', '2000-04-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCableSpectrumMIB.setRevisionsDescriptions(('1. Changed Range Of Ccsfrequency And Ccsmeasuredfrequency Textual-Convention To Support The Docsis 3.0 Extended Upstream Frequency Range.', '1. Added spectrum group global configuration table as ccsSpecGroupFreqTable. 2. Added ccsUpInSpecGroupTable and ccsUpInFiberNodeTable to populate all cable upstream interfaces in each spectrum group and fiber-node. 3. Added ccsUpSpecMgmtSpecGroup and ccsUpSpecMgmtSharedSpectrum into ccsUpSpecMgmtTable to populate spectrum group configuration and topology information for each upstream. 4. Included 0 as part of ccsUpSpecMgmtHopPeriod. 5. Changed the SYNTAX of ccsUpSpecMgmtFromCenterFreq and ccsUpSpecMgmtToCenterFreq from CCSFrequency to Unsigned32 (0 | 5000..65000). 6. Changed the SYNTAX of ccsUpSpecMgmtFromBandWidth and ccsUpSpecMgmtToBandWidth from CCSFrequency to Unsigned32 (200 | 400 | 800 | 1600 | 3200 | 6400). 7. Increased ccsUpSpecMgmtFecUnCorrectThres2 range to 30. Included 0 as part of it. 8. Updated the description for ccsUpSpecMgmtHopPeriod, ccsUpSpecMgmtMissedMaintMsgThres, ccsUpSpecMgmtFromCenterFreq, ccsUpSpecMgmtToCenterFreq, and ccsUpSpecMgmtFecUnCorrectThres2.', '1. Included 0 as part of ccsUpSpecMgmtSnrThres, ccsUpSpecMgmtCnrThres, ccsUpSpecMgmtFecCorrectThres, ccsUpSpecMgmtFecUnCorrectThres ranges. 2. Increased ccsUpSpecMgmtFecCorrectThres and ccsUpSpecMgmtFecUnCorrectThres range to 30', "1. Modified ccsUpSpecMgmtSNR's description to reflect its name since there's a new object defined for CNR. 2. Added ccsUpSpecMgmtCnrThres1, ccsUpSpecMgmtCnrThres1, ccsUpSpecMgmtCNR, ccsUpSpecMgmtMissedMaintMsgThres, ccsUpSpecMgmtHopPeriod, ccsUpSpecMgmtCriteria. 3. Deprecated ccsUpSpecMgmtFecCorrectThres2 4. Deprecated ccsUpSpecMgmtHopCondition and replaced it with ccsUpSpecMgmtCriteria. 5. Deprecated ccsHoppingNotification and replaced it with ccsSpecMgmtNotification.", '1. Modified description for ccsFlapListMaxSize and ccsFlapListCurrentSize. 2. Implement ccsCmFlapTable using downstream, upstream and Mac as indices to replace ccsFlapTable. 3. Modified description for ccsSNRRequestTable. 4. Added ccsUpSpecMgmtUpperBoundFreq. 5. Added ccsCompliance5.', '1. Changed range of CCSFrequency and CCSMeasuredFrequency TEXTUAL-CONVENTION to support Euro-DOCSIS and J-DOCSIS.', '1. Changed range for ccsUpSpecMgmtFecCorrectThres1, ccsUpSpecMgmtFecCorrectThres2, ccsUpSpecMgmtFecUnCorrectThres1, ccsUpSpecMgmtFecUnCorrectThres2 and ccsUpSpecMgmtSnrThres2. 2. Changed modemOffline(1) enumeration to stationMaintainenceMiss. 3. Added ccsUpSpecMgmtGroupRev1 to ccsCompliance4.', '1. Added new objects ccsFlapMissThreshold, ccsFlapPowerAdjustThreshold, ccsFlapResetAll, ccsFlapClearAll and ccsFlapLastClearTime. 2. Added new objects ccsFlapInsertionFailNum, ccsFlapHitNum, ccsFlapMissNum, ccsFlapCrcErrorNum, ccsFlapPowerAdjustmentNum, ccsFlapTotalNum, ccsFlapResetNow, ccsFlapLastResetTime into ccsFlapTable.', '1. Removed ccsSNRRequestUpperFreq and ccsSNRRequestLowFreq from ccsSNRRequestTable. 2. Changed ccsSNRRequestSNR from Unsigned32 to Integer32. 3. Modified description for ccsHoppingNotification. 4. Changed ccsSpectrumRequestResolution to Khz.', 'Added new object groups: 1. ccsSpectrumObjects to provide spectrum information 2. ccsConfigObjects to support spectrum management functions.',))
if mibBuilder.loadTexts: ciscoCableSpectrumMIB.setLastUpdated('201104080000Z')
if mibBuilder.loadTexts: ciscoCableSpectrumMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoCableSpectrumMIB.setContactInfo('Cisco Systems Customer Service Postal: cisco Systems 170 West Tasman Drive San Jose, CA 95134 U.S.A. Tel: +1 800 553-NETS E-mail: cs-ubr@cisco.com')
if mibBuilder.loadTexts: ciscoCableSpectrumMIB.setDescription('This is the MIB Module for Cable Spectrum Management for DOCSIS-compliant Cable Modem Termination Systems (CMTS). Spectrum management is a software/hardware feature provided in the CMTS so that the CMTS may sense both downstream and upstream plant impairments, report them to a management entity, and automatically mitigate them where possible. The CMTS directly senses upstream transmission errors.It may also indirectly monitor the condition of the plant by keeping a record of modem state changes. It is desireable to perform these functions without reducing throughput or latency and without creating additional packet overhead on the RF plant. The purpose of cable Spectrum Management is to prevent long term service interruptions caused by upstream noise events in the cable plant. It is also used for fault management and trouble shooting the cable network. When modems are detected to go on-line and off-line by flap detectors, the cable operators can look at the flap list and spectrum tables to determine the possible causes.')
class CCSFrequency(TextualConvention, Integer32):
    description = 'This data type represents the frequency. The unit is in KHz. A range of 5000KHz to 42000KHz is appropriate for a cable plant using a North American Sub-Split channel plan. The spectrum range has been expanded to accommodate an upper edge of 65000KHz for some European channel plans. The spectrum range has been further expanded with DOCSIS 3.0 to an upper edge of 85000KHz.If DOCSIS is extended to cover other types of channel plans (and frequency allocations) this object will be modified accordingly.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(5000, 85000)

class CCSMeasuredFrequency(TextualConvention, Integer32):
    description = 'This data type represents the actual measured frequency. The unit is in KHz.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(4000, 85000)

class CCSRequestOperation(TextualConvention, Integer32):
    description = "The CCSRequestOperation is used to control various spectrum tests. It has the following defined values: - 'none', initial value at row creation and also indicates test completion; - 'start', which is used to start the test; - 'abort', which is used to abort the test;"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("none", 0), ("start", 1), ("abort", 2))

class CCSRequestOperState(TextualConvention, Integer32):
    description = "The CCSRequestOperState is used to represent the current test status. It has the following defined values: - 'idle', which indicates the test has not been initiated; - 'pending', which indicates the test is in the pending queue; - 'running', which indicates the test is in process; - 'noError', which indicates the test has completed without error; - 'aborted', which indicates the test was stopped before the test was completed; - 'notOnLine', which indicates the Mac Address is not online; - 'invalidMac', which indicates the Mac Address is not valid; - 'timeOut', which indicates timeout has occurred while receiving data from DSP; - 'fftBusy', which indicates the FFT is busy; - 'fftFailed', which indicates the FFT is failed due to a hardware problem; - 'others', other errors;"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("idle", 0), ("pending", 1), ("running", 2), ("noError", 3), ("aborted", 4), ("notOnLine", 5), ("invalidMac", 6), ("timeOut", 7), ("fftBusy", 8), ("fftFailed", 9), ("others", 10))

ciscoCableSpectrumMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 1))
ccsFlapObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1))
ccsSpectrumObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2))
ccsConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3))
ccsFlapListMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(100)).setUnits('modems').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapListMaxSize.setStatus('current')
if mibBuilder.loadTexts: ccsFlapListMaxSize.setDescription('The maximum number of flapped modem entries (ccsCmFlapEntry) per Cable downstream interface that can be reported in the ccsCmFlapTable. If the Cable downstream interface has more flapped modems than the ccsFlapListMaxSize, some of the flapped modems will not be shown in the ccsCmFlapTable. In this case, the users may want to increase the ccsFlapMaxSize.')
ccsFlapListCurrentSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setUnits('modems').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapListCurrentSize.setStatus('current')
if mibBuilder.loadTexts: ccsFlapListCurrentSize.setDescription('The total number of flapped modem entries (ccsCmFlapEntry) that reported in the ccsCmFlapTable. The maximum value will be ccsFlapListMaxSize * <no of downstreams>.')
ccsFlapAging = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 86400)).clone(10080)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapAging.setStatus('current')
if mibBuilder.loadTexts: ccsFlapAging.setDescription('The flap entry aging threshold. Periodically, the aging process scans through the flap list and removes the cable modems that have not flapped for that many minutes.')
ccsFlapInsertionTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(90)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapInsertionTime.setStatus('current')
if mibBuilder.loadTexts: ccsFlapInsertionTime.setDescription('The insertion-time is an empirically derived, worst-case number of seconds which the cable modem requires to complete registration. The time taken by cable modems to complete their registration is measured by the cable operators and this information helps to determine the insertion time. If the cable modem has not completed the registration stage within this insertion-time setting, the cable modem will be inserted into the flap-list.')
ccsFlapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5), )
if mibBuilder.loadTexts: ccsFlapTable.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapTable.setDescription('This table keeps the records of modem state changes. It can be used to identify the problematic cable modems. An entry can be deleted from the table but can not be added to the table.')
ccsFlapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsFlapMacAddr"))
if mibBuilder.loadTexts: ccsFlapEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapEntry.setDescription('List of attributes for an entry in the ccsFlapTable. An entry in this table exists for each cable modem that triggered one of our flap detectors.')
ccsFlapMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 1), MacAddress())
if mibBuilder.loadTexts: ccsFlapMacAddr.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapMacAddr.setDescription("MAC address of the Cable Modem's Cable interface which identifies a flap-list entry for a flapping Cable Modem.")
ccsFlapUpstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapUpstreamIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapUpstreamIfIndex.setDescription('The ifIndex of the Cable upstream interface whose ifType is docsCableUpstream(129). The CMTS detects a flapping Cable Modem from its Cable upstream interface.')
ccsFlapDownstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapDownstreamIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapDownstreamIfIndex.setDescription('The ifIndex of the Cable downstream interface whose ifType is docsCableDownstream(128).')
ccsFlapInsertionFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapInsertionFails.setReference('Data over Cable Radio Frequency Interface specification, Section 7.2.')
if mibBuilder.loadTexts: ccsFlapInsertionFails.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapInsertionFails.setDescription('The number of times a Cable Modem registered more frequently than expected. Excessive registration is defined as the presence of a time span between two successive registration cycles which is less than a threshold span (ccsFlapInsertionTime). A Cable Modem may fail the ranging or registration process due to not being able to get an IP address. When the Cable Modem can not finish registration within the insertion time, it retries the process and sends the Initial Maintenance packet again. CMTS will receive the Initial Maintenance packet from the Cable Modem sooner than expected and the Cable Modem is considered a flapping modem. This count may indicate: Intermittent downstream sync loss, or DHCP or modem registration problems. The Flap Count (ccsFlapTotal) will be incremented when this counter is incremented. Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapHits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapHits.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapHits.setDescription('The number of times the CMTS receives the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance transmit opportunity at a typical rate of once every 10 seconds and waits for a Ranging request from the Cable Modem.If the CMTS receives a Ranging request then the Hit count will be increased by 1 If the FlapTotal count is high,both Hits and Misses counts are high, and other counters are relatively low then the flapping is probably caused by the modem going up and down. The Hits and Misses counts are keep-alive polling statistics. The Hits count should be much greater than the Misses count Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapMisses.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapMisses.setDescription('The number of times the CMTS misses the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance packet every 10 seconds and waits for a Ranging request from the Cable Modem. If the CMTS misses a Ranging request within 25 msec then the Misses count will be incremented. If ccsFlapTotal is high, Hits and Misses are high but ccsFlapPowerAdjustments and ccsFlapInsertionFails are low then the flapping is probably caused by the modem going up and down. Miss counts can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapCrcErrors.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapCrcErrors.setDescription('The number of times the CMTS upstream receiver flagged a packet with a CRC error. If ccsFlapCrcErrors is high, it indicates the cable upstream may have high noise level. The modem may not be flapping yet but it may be a potential problem. This count can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapPowerAdjustments = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapPowerAdjustments.setReference('Data over Cable Radio Frequency Interface specification, Section 7.2.')
if mibBuilder.loadTexts: ccsFlapPowerAdjustments.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapPowerAdjustments.setDescription('The number of times the Cable Modem upstream transmit power is adjusted during station maintenance. When the adjustment is greater than the power adjustment threshold the counter will be incremented. The power adjustment threshold is chosen in an implementation-dependent manner. The Flap Count (ccsFlapTotal) will be incremented when this counter is incremented. If ccsFlapTotal is high, ccsFlapPowerAdjustments is high but the Hits and Misses are low and ccsFlapInsertionFails are low then the flapping is probably caused by an improper transmit power level setting at the modem end. This count can indicate: Amplifier degradation, Poor connections, or Wind, moisture, or temperature sensitivity. Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapTotal.setReference('Data over Cable Radio Frequency Interface specification, Appendix B.')
if mibBuilder.loadTexts: ccsFlapTotal.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapTotal.setDescription('Whenever the Cable Modem passes flap detection, then the flap counter is increased. There are 3 flap detectors defined: (1) When ccsFlapInsertionFails is increased the Flap count will be increased. (2) When the CMTS receives a Miss followed by a Hit then the Flap count will be increased. (3) When ccsFlapPowerAdjustments is increased the Flap count will be increased. Discontinuites in the value of this counter can occur if this entry is removed from the table and then re-added, and are indicated by a change in the value of ccsFlapCreateTime.')
ccsFlapLastFlapTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapLastFlapTime.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapLastFlapTime.setDescription('The flap time is set whenever the Cable Modem triggers a flap detector.')
ccsFlapCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 11), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapCreateTime.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapCreateTime.setDescription('The time that this entry was added to the table. If an entry is removed and then later re-added, there may be a discontinuity in the counters associated with this entry. This timestamp can be used to detect those discontinuities.')
ccsFlapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapRowStatus.setDescription('Controls and reflects the status of rows in this table. When a cable modem triggers a flap detector, if an entry does not already exist for this cable modem, and ccsFlapListCurrentSize is less than ccsFlapListMaxSize, then an entry will be created in this table. The new instance of this object will be set to active(1). All flapping modems have the status of active(1). Active entries are removed from the table after they have not triggered any additional flap detectors for the period of time defined in ccsFlapAging. Alternatively, setting this instance to destroy(6) will remove the entry immediately. createAndGo(4) and createAndWait(5) are not supported.')
ccsFlapInsertionFailNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapInsertionFailNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapInsertionFailNum.setDescription('The number of times a Cable Modem registered more frequently than expected. Excessive registration is defined as the presence of a time span between two successive registration cycles which is less than a threshold span (ccsFlapInsertionTime). A Cable Modem may fail the ranging or registration process due to not being able to get an IP address. When the Cable Modem can not finish registration within the insertion time, it retries the process and sends the Initial Maintenance packet again. CMTS will receive the Initial Maintenance packet from the Cable Modem sooner than expected and the Cable Modem is considered a flapping modem. This object may indicate: Intermittent downstream sync loss, or DHCP or modem registration problems. The Flap number (ccsFlapTotalNum) will be incremented when this object is incremented. This object is going to replace the object ccsFlapInsertionFails and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if a user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapHitNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapHitNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapHitNum.setDescription('The number of times the CMTS receives the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance transmit opportunity at a typical rate of once every 10 seconds and waits for a Ranging request from the Cable Modem. If the CMTS receives a Ranging request then the Hit number will be increased by 1 If the FlapTotal object is high, both Hit and Miss objects are high, and other statistical objects are relatively low then the flapping is probably caused by the modem going up and down. The Hit and Miss objects keep-alive polling statistics. The Hit object should be much greater than the Misses count. This object is going to replace the object ccsFlapHits and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if an user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapMissNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapMissNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapMissNum.setDescription('The number of times the CMTS misses the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance packet every 10 seconds and waits for a Ranging request from the Cable Modem. If the CMTS misses a Ranging request within 25 msec then the Miss Object will be incremented. If ccsFlapTotalNum is high, Hit and Miss are high but ccsFlapPowerAdjustmentNum and ccsFlapInsertionFailNum are low then the flapping is probably caused by the modem going up and down. Miss object can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. This object is going to replace the object ccsFlapMisses and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if an user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapCrcErrorNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapCrcErrorNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapCrcErrorNum.setDescription('The number of times the CMTS upstream receiver flagged a packet with a CRC error. If ccsFlapCrcErrorNum is high, it indicates the cable upstream may have high noise level. The modem may not be flapping yet but it may be a potential problem. This object can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. This object is going to replace the object ccsFlapCrcErrors and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if a user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapPowerAdjustmentNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapPowerAdjustmentNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapPowerAdjustmentNum.setDescription('The number of times the Cable Modem upstream transmit power is adjusted during station maintenance. When the adjustment is greater than the power adjustment threshold the number will be incremented. The power adjustment threshold is chosen in an implementation-dependent manner The Flap number (ccsFlapTotalNum) will be incremented when this object is incremented. If ccsFlapTotalNum is high, ccsFlapPowerAdjustmentNum is high but the Hit and Miss are low and ccsFlapInsertionFailNum are low then the flapping is probably caused by an improper transmit power level setting at the modem end. This object can indicate: Amplifier degradation, Poor connections, or Wind, moisture, or temperature sensitivity. This object is going to replace the object ccsFlapPowerAdjustments and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if a user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapTotalNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapTotalNum.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapTotalNum.setDescription('Whenever the Cable Modem passes flap detection, then the flap number is increased. There are 3 flap detectors defined: (1) When ccsFlapInsertionFailNum is increased the Flap number will be increased. (2) When the CMTS receives a Miss followed by a Hit then the Flap number will be increased. (3) When ccsFlapPowerAdjustmentNum is increased the Flap number will be increased. This object is going to replace the object ccsFlapTotal and the value of this object can be reset to zero if this entry is removed from the table and then re-added, or if an user resets all the statistical objects for this entry. The value of the object ccsFlapLastResetTime indicates the last reset time.')
ccsFlapResetNow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapResetNow.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapResetNow.setDescription('Setting this object to true(1) will set the following objects of this entry to 0: ccsFlapInsertionFailsNum, ccsFlapHitsNum, ccsFlapMissesNum, ccsFlapCrcErrorsNum, ccsFlapPowerAdjustmentsNum and ccsFlapTotalNum. Setting this object to true does not destroy the entry, so the ccsFlapCreateTime will be unchanged. Reading this object always returns false(2).')
ccsFlapLastResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 5, 1, 20), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapLastResetTime.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapLastResetTime.setDescription("The last time that all the statistical objects of this entry are started from zero. There are several ways to restart the the statistical objects from zero. Setting the object ccsFlapResetNow or ccsFlapResetAll to true via SNMP is one way and and the other way is via command Line Interface. This timestamp can be used to know the last time the statistical objects are started from zero. The special value of all '00'Hs indicates that these statistical objects of this entry in the ccsFlapTable have never been reset.")
ccsFlapPowerAdjustThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setUnits('db').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapPowerAdjustThreshold.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapPowerAdjustThreshold.setDescription('The power adjust threshold. When the power of the modem is adjusted beyond this threshold, the modem will be inserted into the flap-list.')
ccsFlapMissThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapMissThreshold.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapMissThreshold.setDescription('Per modem miss threshold which triggers polling flap detector. When the number of times a cable modem does not acknowledge a MAC-layer keepalive message from a cable modem card exceeds the miss threshold, the cable modem is placed in the flap list.')
ccsFlapResetAll = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapResetAll.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapResetAll.setDescription('Setting this object to true(1) causes ccsFlapInsertionFailNum, ccsFlapHitNum, ccsFlapMissNum, ccsFlapCrcErrorNum, ccsFlapPowerAdjustmentNum and ccsFlapTotalNum objects of each entry in ccsFlapTable to be started from zero. Reading this object always returns false(2).')
ccsFlapClearAll = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsFlapClearAll.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapClearAll.setDescription('Setting this object to true(1) removes all cable modems from flap-list and all the entries in the ccsFlapTable are destroyed. If a modem keeps flapping, the modem will be added again into the flap list and a new entry in the ccsFlapTable will be created. The newly created entry for that modem will have new value of ccsFlapCreateTime and all the statistical objects will be started from zero. Reading this object always returns false(2).')
ccsFlapLastClearTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsFlapLastClearTime.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapLastClearTime.setDescription("The last time that all the entries in the ccsFlapTable are destroyed. There are several ways to destroy all the entries in the ccsFlapTable. Setting the object ccsFlapClearAll to true is one way, and the other way is through Command Line Interface. This timestamp can be used to know when all the entries in the ccsFlapTable are destroyed. The special value of all '00'Hs indicates that the entries in the ccsFlapTable have never been destroyed.")
ccsCmFlapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11), )
if mibBuilder.loadTexts: ccsCmFlapTable.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapTable.setDescription('This table keeps the records of modem state changes, so it can be used to identify the problematic cable modems. An entry per modem is added to the table automatically by the system when it detects any state changes to the modem. Therefore, it can be deleted but can not be added by the management system.')
ccsCmFlapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapDownstreamIfIndex"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapUpstreamIfIndex"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapMacAddr"))
if mibBuilder.loadTexts: ccsCmFlapEntry.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapEntry.setDescription('List of attributes for an entry in the ccsCmFlapTable. An entry in this table exists for each cable modem that triggered one of our flap detectors.')
ccsCmFlapDownstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ccsCmFlapDownstreamIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapDownstreamIfIndex.setDescription('The ifIndex of the Cable downstream interface whose ifType is docsCableDownstream(128).')
ccsCmFlapUpstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ccsCmFlapUpstreamIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapUpstreamIfIndex.setDescription('The ifIndex of the Cable upstream interface whose ifType is docsCableUpstream(129). The CMTS detects a flapping Cable Modem from its Cable upstream interface.')
ccsCmFlapMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 3), MacAddress())
if mibBuilder.loadTexts: ccsCmFlapMacAddr.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapMacAddr.setDescription("MAC address of the Cable Modem's Cable interface which identifies a flapping Cable Modem.")
ccsCmFlapLastFlapTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapLastFlapTime.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapLastFlapTime.setDescription('The flap time is set whenever the Cable Modem triggers a flap detector.')
ccsCmFlapCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapCreateTime.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapCreateTime.setDescription('The time that this entry was added to the table. If an entry is removed and then later re-added, there may be a discontinuity in the counters associated with this entry. This timestamp can be used to detect those discontinuities.')
ccsCmFlapInsertionFailNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapInsertionFailNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapInsertionFailNum.setDescription('The number of times a Cable Modem registered more frequently than expected. Excessive registration is defined as the presence of a time span between two successive registration cycles which is less than a threshold span (ccsFlapInsertionTime). A Cable Modem may fail the ranging or registration process due to not being able to get an IP address. When the Cable Modem can not finish registration within the insertion time, it retries the process and sends the Initial Maintenance packet again. CMTS will receive the Initial Maintenance packet from the Cable Modem sooner than expected and the Cable Modem is considered a flapping modem. This object may indicate: Intermittent downstream sync loss, or DHCP or modem registration problems. The Flap number (ccsCmFlapTotalNum) will be incremented when this object is incremented. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapHitNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapHitNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapHitNum.setDescription('The number of times the CMTS receives the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance transmit opportunity at a typical rate of once every 10 seconds and waits for a Ranging request from the Cable Modem. If the CMTS receives a Ranging request then the Hit number will be increased by 1 If the FlapTotal object is high, both Hit and Miss objects are high, and other statistical objects are relatively low then the flapping is probably caused by the modem going up and down. The Hit and Miss objects keep-alive polling statistics. The Hit object should be much greater than the Misses count. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapMissNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapMissNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapMissNum.setDescription('The number of times the CMTS misses the Ranging request from the Cable Modem. The CMTS issues a Station Maintenance packet every 10 seconds and waits for a Ranging request from the Cable Modem. If the CMTS misses a Ranging request within 25 msec then the Miss Object will be incremented. If ccsCmFlapTotalNum is high, Hit and Miss are high but ccsCmFlapPowerAdjustmentNum and ccsCmFlapInsertionFailNum are low then the flapping is probably caused by the modem going up and down. Miss object can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapCrcErrorNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapCrcErrorNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapCrcErrorNum.setDescription('The number of times the CMTS upstream receiver flagged a packet with a CRC error. If ccsCmFlapCrcErrorNum is high, it indicates the cable upstream may have high noise level. The modem may not be flapping yet but it may be a potential problem. This object can indicate: Intermittent upstream, Laser clipping, or Noise bursts. Laser clipping can happen if the signal power is too high when the upstream electrical signal is converted to an optical signal. When it happens the more input produces less output, until finally there is no more increase in output. This phenomena is called laser clipping. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapPowerAdjustmentNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapPowerAdjustmentNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapPowerAdjustmentNum.setDescription('The number of times the Cable Modem upstream transmit power is adjusted during station maintenance. When the adjustment is greater than the power adjustment threshold the number will be incremented. The power adjustment threshold is chosen in an implementation-dependent manner The Flap number (ccsCmFlapTotalNum) will be incremented when this object is incremented. If ccsCmFlapTotalNum is high, ccsCmFlapPowerAdjustmentNum is high but the Hit and Miss are low and ccsCmFlapInsertionFailNum are low then the flapping is probably caused by an improper transmit power level setting at the modem end. This object can indicate: Amplifier degradation, Poor connections, or Wind, moisture, or temperature sensitivity. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapTotalNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapTotalNum.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapTotalNum.setDescription('Whenever the Cable Modem passes flap detection, then the flap number is increased. There are 3 flap detectors defined: (1) When ccsCmFlapInsertionFailNum is increased the Flap number will be increased. (2) When the CMTS receives a Miss followed by a Hit then the Flap number will be increased. (3) When ccsCmFlapPowerAdjustmentNum is increased the Flap number will be increased. The value of this object can be reset to zero if this entry is removed from the table and then re-added, or if the ccsCmFlapResetNow object was set to true(1). The value of the object ccsCmFlapLastResetTime indicates the last reset time.')
ccsCmFlapResetNow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsCmFlapResetNow.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapResetNow.setDescription('Setting this object to true(1) will set the value of certain objects in this table to 0 and does not destroy the entry, so the ccsCmFlapCreateTime will be unchanged. Reading this object always returns false(2).')
ccsCmFlapLastResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 13), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsCmFlapLastResetTime.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapLastResetTime.setDescription("The last time that all the statistical objects of this entry are started from zero. There are several ways to restart the the statistical objects from zero. Setting the object ccsCmFlapResetNow or ccsCmFlapResetAll to true via SNMP is one way and and the other way is via command Line Interface. This timestamp can be used to know the last time the statistical objects are started from zero. The special value of all '00'Hs indicates that these statistical objects of this entry in the ccsCmFlapTable have never been reset.")
ccsCmFlapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 1, 11, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsCmFlapRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccsCmFlapRowStatus.setDescription('Controls and reflects the status of rows in this table. When a cable modem triggers a flap detector, if an entry does not already exist for this cable modem, an entry will be created in this table. The new instance of this object will be set to active(1). All flapping modems have the status of active(1). Active entries are removed from the table after they have not triggered any additional flap detectors for the period of time defined in ccsFlapAging. Alternatively, setting this instance to destroy(6) will remove the entry immediately. createAndGo(4) and createAndWait(5) are not supported.')
ccsSpectrumRequestTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1), )
if mibBuilder.loadTexts: ccsSpectrumRequestTable.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestTable.setDescription('This table contains the spectrum data requests. There are two types of request: background noise and SNR. Refer to ccsSpectrumRequestIfIndex and ccsSpectrumRequestMacAddr DESCRIPTIONS on how the type of request is determined.')
ccsSpectrumRequestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestIndex"))
if mibBuilder.loadTexts: ccsSpectrumRequestEntry.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestEntry.setDescription("Information about a spectrum data request. The management system uses ccsSpectrumRequestStatus to control entry modification, creation, and deletion. Setting ccsSpectrumRequestEntry to 'destroy' causes entry and its associated data (example: ccsSpectrumDataEntry) to be cleaned up properly. It is suggested the entry to be set to 'destroy' when the row is no longer in use.")
ccsSpectrumRequestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: ccsSpectrumRequestIndex.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestIndex.setDescription('An arbitrary integer to uniquely identify the entry.')
ccsSpectrumRequestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestIfIndex.setDescription("The ifIndex of a docsCableUpstream(129) interface. The background noise measurement is requested when ccsSpectrumRequestIfIndex is specified. The receiving power measurement is requested when ccsSpectrumRequestMacAddr is specified; In this case, ccsSpectrumRequestIfIndex is the ifIndex of the remote CM's upstream.")
ccsSpectrumRequestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 3), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestMacAddr.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestMacAddr.setDescription('A MAC address that identifies a remote CM. The default value of 0000.0000.0000 indicates that the background noise will be measured for the upstream. In this case, ccsSpectrumRequestIfIndex must be specified. Other values indicate that the receiving power test is requested for the ccsSpectrumRequestMacAddr with CM signals.')
ccsSpectrumRequestLowFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 4), CCSFrequency().clone(5000)).setUnits('KHz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestLowFreq.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestLowFreq.setDescription("Start of frequency range. The ccsSpectrumRequestLowFreq is adjusted slightly to accurately represent the actual starting point of the frequency range. The adjustment is done as follows: aFactor = (center frequency - ccsSpectrumRequestLowFreq)/12K ccsSpectrumRequestLowFreq = center frequency - (aFactor * 12K) where 12K is the FFT's bin size.")
ccsSpectrumRequestUpperFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 5), CCSFrequency().clone(42000)).setUnits('KHz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestUpperFreq.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestUpperFreq.setDescription('End of frequency range. With the adjustment done to the ccsSpectrumRequestLowFreq, ccsSpectrumRequestUpperFreq will also be adjusted to the last frequency within the specified range divisible by the bin size. Refer to the ccsSpectrumRequestLowFreq DESCRIPTION for the adjustment calculation.')
ccsSpectrumRequestResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(12, 37000)).clone(60)).setUnits('KHz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestResolution.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestResolution.setDescription("A span between two frequencies. ccsSpectrumRequestResolution dictates the amount of receiving power data to be returned in ccsSpectrumDataTable. The finer the resolution, the more data returned. ccsSpectrumRequestResolution is adjusted to a value which is divisible by FFT's 12KHz bin size.")
ccsSpectrumRequestOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 7), CCSRequestOperation().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestOperation.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestOperation.setDescription("The control that allows 'start' or 'abort' of the test. Since there is only 1 FFT engine running on the CMTS, 'start' changes ccsSpectrumRequestOperState to 'pending' state if the FFT is busy; Otherwise, it changes ccsSpectrumRequestOperState to 'running'. 'abort' changes ccsSpectrumRequestOperState to 'aborted' state. 'abort' is only allowed when ccsSpectrumRequestOperState is in 'pending' state. Only 'start' when request is to be started and 'abort' when request is to be aborted can be set by the user. It is set to 'none' only on completion of the request by the FFT engine. Note: The SNMP SET is rejected if ccsSpectrumRequestStatus is not 'active'.")
ccsSpectrumRequestOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 8), CCSRequestOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSpectrumRequestOperState.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestOperState.setDescription("The operational state of the test. ccsSpectrumRequestIfIndex, ccsSpectrumRequestMacAddr, ccsSpectrumRequestUpperFreq, ccsSpectrumRequestLowFreq and ccsSpectrumRequestResolution cannot be changed when CCSRequestOperState is in the 'running' state. For a detailed description, see the CCSRequestOperState DESCRIPTION.")
ccsSpectrumRequestStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSpectrumRequestStartTime.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestStartTime.setDescription('The value of sysUpTime when the spectrum measurement operation starts.')
ccsSpectrumRequestStoppedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSpectrumRequestStoppedTime.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestStoppedTime.setDescription('The value of sysUpTime when the spectrum measurement operation stops.')
ccsSpectrumRequestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpectrumRequestStatus.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumRequestStatus.setDescription('The control that allows modification, creation, and deletion of entries. For detailed rules, see the ccsSpectrumRequestEntry DESCRIPTION.')
ccsSpectrumDataTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 2), )
if mibBuilder.loadTexts: ccsSpectrumDataTable.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumDataTable.setDescription('This table contains the receiving power or background noise measurement based on the criteria that is set in the ccsSpectrumRequestEntry.')
ccsSpectrumDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestIndex"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumDataFreq"))
if mibBuilder.loadTexts: ccsSpectrumDataEntry.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumDataEntry.setDescription('Information about the receiving power or background noise measured at a particular frequency for the ccsSpectrumRequestEntry.')
ccsSpectrumDataFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 2, 1, 1), CCSMeasuredFrequency()).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSpectrumDataFreq.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumDataFreq.setDescription('ccsSpectrumDataPower measurement frequency. Due to the adjustment calculation the starting frequency range for the actual measured frequency if off comparing to the configured frequency. Refer to ccsSpectrumRequestLowFreq DESCRIPTIONS for the adjustment calculation.')
ccsSpectrumDataPower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, 50))).setUnits('dBmV').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSpectrumDataPower.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumDataPower.setDescription('The receiving power measured at the ccsSpectrumDataFreq.')
ccsSNRRequestTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3), )
if mibBuilder.loadTexts: ccsSNRRequestTable.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestTable.setDescription('A table of CNR requests.')
ccsSNRRequestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestIndex"))
if mibBuilder.loadTexts: ccsSNRRequestEntry.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestEntry.setDescription('Information about an CNR request. The management system uses ccsSNRRequestStatus to control entry modification, creation, and deletion.')
ccsSNRRequestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: ccsSNRRequestIndex.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestIndex.setDescription('An arbitrary integer to uniquely identify this entry.')
ccsSNRRequestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSNRRequestMacAddr.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestMacAddr.setDescription('A MAC address that identifies the remote online CM that the CNR measurement operation is being performed on.')
ccsSNRRequestSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSNRRequestSNR.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestSNR.setDescription("A snap shot of the CNR value that is measured over the in-use band frequency. The ccsSNRRequestSNR is set to 0 when ccsSNRRequestOperState is in the 'running' state.")
ccsSNRRequestOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 4), CCSRequestOperation().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSNRRequestOperation.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestOperation.setDescription("The control that allows start or abort of the test. Since there is only 1 FFT engine running on the CMTS, 'start' changes ccsSNRRequestOperState to 'pending' state if the FFT is busy; Otherwise, it changes ccsSNRRequestOperState to 'running'. 'abort' changes ccsSNRRequestOperState to 'aborted' state. Only 'start' when request is to be started and 'abort' when request is to be aborted can be set by the user. It is set to 'none' only on completion of the request by the FFT engine.")
ccsSNRRequestOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 5), CCSRequestOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSNRRequestOperState.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestOperState.setDescription("The operational state of the test. ccsSNRRequestMacAddr, cannot be changed when the ccsSNRRequestOperState is in the 'running' state.")
ccsSNRRequestStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSNRRequestStartTime.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestStartTime.setDescription('The value of sysUpTime when the CNR measurement operation starts.')
ccsSNRRequestStoppedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsSNRRequestStoppedTime.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestStoppedTime.setDescription('The value of sysUpTime when the CNR measurement operation stops.')
ccsSNRRequestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSNRRequestStatus.setStatus('current')
if mibBuilder.loadTexts: ccsSNRRequestStatus.setDescription('The control that allows modification, creation, and deletion of entries. For detailed rules see the ccsSpectrumRequestEntry DESCRIPTION.')
ccsUpInSpecGroupTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4), )
if mibBuilder.loadTexts: ccsUpInSpecGroupTable.setStatus('current')
if mibBuilder.loadTexts: ccsUpInSpecGroupTable.setDescription('This table contains the cable upstream interfaces assigned to a spectrum group. A spectrum group contains one or more fixed frequencies or frequency bands which can be assigned to cable upstream interfaces in the spectrum group.')
ccsUpInSpecGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupNumber"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupUpstreamIfIndex"))
if mibBuilder.loadTexts: ccsUpInSpecGroupEntry.setStatus('current')
if mibBuilder.loadTexts: ccsUpInSpecGroupEntry.setDescription('An entry in ccsUpInSpecGroupTable table. Each entry represents a cable upstream interface assigned to a spectrum group.')
ccsSpecGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ccsSpecGroupNumber.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupNumber.setDescription('The spectrum group number. The value of the object is same as the value of ccsUpSpecMgmtSpecGroup object except value 0.')
ccsSpecGroupUpstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ccsSpecGroupUpstreamIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupUpstreamIfIndex.setDescription("The ifIndex of the Cable upstream interface belonging to this Spectrum Group. The value of the corresponding instance of ifType is 'docsCableUpstream(129)'.")
ccsSpecGroupUpstreamStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4, 1, 3), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupUpstreamStorage.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupUpstreamStorage.setDescription('The storage type for this conceptual row.')
ccsSpecGroupUpstreamRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupUpstreamRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupUpstreamRowStatus.setDescription('The status for this conceptual row. This object is used for creating/deleting entries in ccsUpInSpecGroupTable.')
ccsUpInFiberNodeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5), )
if mibBuilder.loadTexts: ccsUpInFiberNodeTable.setStatus('current')
if mibBuilder.loadTexts: ccsUpInFiberNodeTable.setDescription('This table contains the cable upstream interfaces in a fiber-node.Each fiber-node uniquely represents an RF domain.Cable upstream interfaces in the same fiber-node are physically combined together into the same RF domain.')
ccsUpInFiberNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsFiberNodeNumber"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsFiberNodeUpstreamIfIndex"))
if mibBuilder.loadTexts: ccsUpInFiberNodeEntry.setStatus('current')
if mibBuilder.loadTexts: ccsUpInFiberNodeEntry.setDescription('An entry in ccsUpInFiberNodeTable. Each entry represents a cable upstream interface assigned to a fiber-node.')
ccsFiberNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ccsFiberNodeNumber.setStatus('current')
if mibBuilder.loadTexts: ccsFiberNodeNumber.setDescription('The fiber-node number. The value of the object is same as the value of ccsUpSpecMgmtSharedSpectrum except value 0.')
ccsFiberNodeUpstreamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ccsFiberNodeUpstreamIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccsFiberNodeUpstreamIfIndex.setDescription("The ifIndex of the Cable upstream interface belonging to this Spectrum Group. The value of the corresponding instance of ifType is 'docsCableUpstream(129)'.")
ccsFiberNodeUpstreamStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5, 1, 3), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsFiberNodeUpstreamStorage.setStatus('current')
if mibBuilder.loadTexts: ccsFiberNodeUpstreamStorage.setDescription('The storage type for this conceptual row.')
ccsFiberNodeUpstreamRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 2, 5, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsFiberNodeUpstreamRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccsFiberNodeUpstreamRowStatus.setDescription('The status for this conceptual row. This object is used for creating/deleting entries in ccsUpInFiberNodeTable.')
ccsUpSpecMgmtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1), )
if mibBuilder.loadTexts: ccsUpSpecMgmtTable.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtTable.setDescription('This table contains the attributes of the cable upstream interfaces, ifType of docsCableUpstream(129), to be used for improving performance and proactive hopping. Proactive hopping is achieved by setting the SNR polling period over the in-use band without CM signals.')
ccsUpSpecMgmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ccsUpSpecMgmtEntry.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtEntry.setDescription("Upstream interface's spectrum management information.")
ccsUpSpecMgmtHopPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("frqModChannel", 0), ("frqChannelMod", 1), ("modFrqChannel", 2), ("modChannelFrq", 3), ("channelFrqMod", 4), ("channelModFrq", 5))).clone('frqModChannel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtHopPriority.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtHopPriority.setDescription("A preference priority for changing the frequency, modulation, or channel width supporting the automatic switching of the modulation scheme when the channel becomes noisy. The default priority is frequency, modulation, and channel width. With the default preference, the frequency is changed if there is a clean band available. If there's no clean band available, the modulation is changed. And if the clean band is still not available, the bandwidth is reduced until an acceptable band is found or a minimum bandwidth of 200KHz.")
ccsUpSpecMgmtSnrThres1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 35), )).clone(25)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrThres1.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrThres1.setDescription('The Signal to Noise (SNR) threshold. This object is applicable for modulation profile 1. When the CMTS detects that the SNR goes lower than ccsUpSpecMgmtSnrThres1, it switches to profile 2. Therefore, ccsUpSpecMgmtSnrThres1 should be larger than ccsUpSpecMgmtSnrThres2. A value 0 indicates to bypass the threshold check.')
ccsUpSpecMgmtSnrThres2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 35), )).clone(15)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrThres2.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrThres2.setDescription('The Signal to Noise (SNR) threshold. This object is applicable for modulation profile 2. Refer to ccsUpSpecMgmtCriteria on how ccsUpSpecMgmtSnrThres2 can trigger a change in frequency, modulation or channel width. A value 0 indicates to bypass the threshold check. Note: The SNMP SET is rejected if both ccsUpSpecMgmtSnrThres1, ccsUpSpecMgmtSnrThres2 are non-zero and ccsUpSpecMgmtSnrThres2 is higher than ccsUpSpecMgmtSnrThres1.')
ccsUpSpecMgmtFecCorrectThres1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 30), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtFecCorrectThres1.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFecCorrectThres1.setDescription('The Forward Error Correction (FEC) correctable count threshold. This object is applicable for profile 1. A value 0 indicates to bypass the threshold check. When CMTS detects that FEC correctable count goes higher than ccsUpSpecMgmtFecCorrectThres1, it switch to Profile 2. Therefore, ccsUpSpecMgmtFecCorrectThres1 should be smaller than ccsUpSpecMgmtFecCorrectThres2.')
ccsUpSpecMgmtFecCorrectThres2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtFecCorrectThres2.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtFecCorrectThres2.setDescription('The FEC correctable count threshold. This object is applicable for profile 2. When CMTS detects that FEC correctable count goes higher than ccsUpSpecMgmtFecCorrectThres2, modulation change can occur, depending on the type of ccsUpSpecMgmtHopPriority. Note: SNMP SET will be rejected if ccsUpSpecMgmtFecCorrectThres2 is lower than ccsUpSpecMgmtFecCorrectThres1.')
ccsUpSpecMgmtFecUnCorrectThres1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 30), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtFecUnCorrectThres1.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFecUnCorrectThres1.setDescription('The FEC uncorrectable count threshold. This object is applicable for modulation profile 1. A value 0 indicates to bypass the threshold check. When CMTS detects that FEC uncorrectable count goes higher than ccsUpSpecMgmtFecUnCorrectThres1, it switches to Profile 2. Therefore, ccsUpSpecMgmtFecUnCorrectThres1 should be smaller than ccsUpSpecMgmtFecUnCorrectThres2.')
ccsUpSpecMgmtFecUnCorrectThres2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 30), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtFecUnCorrectThres2.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFecUnCorrectThres2.setDescription('The FEC uncorrectable count threshold. This object is applicable for modulation profile 2. A value 0 indicates to bypass the threshold check. Refer to ccsUpSpecMgmtCriteria on how ccsUpSpecMgmtFecUnCorrectThres2 can trigger a change in frequency, modulation or channel width. Note: SNMP SET is rejected if ccsUpSpecMgmtFecUnCorrectThres2 is lower than ccsUpSpecMgmtFecUnCorrectThres1.')
ccsUpSpecMgmtSnrPollPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 25000)).clone(500)).setUnits('msec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrPollPeriod.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtSnrPollPeriod.setDescription("A period between SNR pollings. The SNR is collected from the Fast Fourier Transform (FFT) measurement over the in-use band when there is no CM signals. When the CMTS detects that SNR doesn't meet ccsUpSpecMgmtSnrThres1 or ccsUpSpecMgmtSnrThres2, a possible hopping occurs, depending on the type of ccsUpSpecMgmtHopPriority.")
ccsUpSpecMgmtHopCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("snr", 0), ("stationMaintainenceMiss", 1), ("others", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtHopCondition.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtHopCondition.setDescription('A condition that triggers hopping. The SNR condition occurs when SNR does not meet the ccsUpSpecMgmtSnrThres1 or ccsUpSpecMgmtSnrThres2. The stationMaintainenceMiss condition occurs when the percentage of offline CMs is reached.')
ccsUpSpecMgmtFromCenterFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5000, 65000), ))).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtFromCenterFreq.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFromCenterFreq.setDescription('Center frequency before hopping occurs. A value 0 indicates that the interface has no frequency assigned.')
ccsUpSpecMgmtToCenterFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5000, 65000), ))).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtToCenterFreq.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtToCenterFreq.setDescription('Current center frequency. A value 0 indicates that the interface has no frequency assigned.')
ccsUpSpecMgmtFromBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(200, 200), ValueRangeConstraint(400, 400), ValueRangeConstraint(800, 800), ValueRangeConstraint(1600, 1600), ValueRangeConstraint(3200, 3200), ValueRangeConstraint(6400, 6400), ))).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtFromBandWidth.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFromBandWidth.setDescription('Bandwidth before hopping occurs.')
ccsUpSpecMgmtToBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(200, 200), ValueRangeConstraint(400, 400), ValueRangeConstraint(800, 800), ValueRangeConstraint(1600, 1600), ValueRangeConstraint(3200, 3200), ValueRangeConstraint(6400, 6400), ))).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtToBandWidth.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtToBandWidth.setDescription('Current bandwidth.')
ccsUpSpecMgmtFromModProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtFromModProfile.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtFromModProfile.setDescription('Modulation profile index before hopping occurs. It is the index identical to the docsIfModIndex in the docsIfCmtsModulationTable. For the detailed descriptions, see the docsIfCmtsModulationTable and docsIfCmtsModIndex DESCRIPTIONS.')
ccsUpSpecMgmtToModProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtToModProfile.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtToModProfile.setDescription('The current modulation profile index. It is the index identical to the docsIfModIndex in the docsIfCmtsModulationTable. For the detailed descriptions, see the docsIfCmtsModulationTable and docsIfCmtsModIndex DESCRIPTIONS.')
ccsUpSpecMgmtSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtSNR.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtSNR.setDescription('Current SNR. A value -99 indicates the system detected no modem on line, and a value of -100 indicates the system was unable to retrieve the SNR value.')
ccsUpSpecMgmtUpperBoundFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 17), CCSFrequency()).setUnits('KHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtUpperBoundFreq.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtUpperBoundFreq.setDescription('Upper bound frequency that the upstream supports.')
ccsUpSpecMgmtCnrThres1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 35), )).clone(25)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtCnrThres1.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtCnrThres1.setDescription('The Carrier to Noise (CNR) threshold. This object is applicable for modulation profile 1. When the CMTS detects that the CNR goes lower than ccsUpSpecMgmtCnrThres1, it switches to profile 2. Therefore, ccsUpSpecMgmtCnrThres1 should be larger than ccsUpSpecMgmtCnrThres2. A value 0 indicates to bypass the threshold check.')
ccsUpSpecMgmtCnrThres2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 35), )).clone(15)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccsUpSpecMgmtCnrThres2.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtCnrThres2.setDescription('The Carrier to Noise (CNR) threshold. This object is applicable for modulation profile 2. Refer to ccsUpSpecMgmtCriteria on how ccsUpSpecMgmtCnrThres2 can trigger a change in frequency, modulation or channel width. A value 0 indicates to bypass the threshold check. Note: The SNMP SET is rejected if both ccsUpSpecMgmtCnrThres1, ccsUpSpecMgmtCnrThres2 are non-zero and ccsUpSpecMgmtCnrThres2 is higher than ccsUpSpecMgmtCnrThres1.')
ccsUpSpecMgmtCNR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtCNR.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtCNR.setDescription('Current CNR. A value -99 indicates the system detected no modem on line, and a value of -100 indicates the system was unable to retrieve the CNR value.')
ccsUpSpecMgmtMissedMaintMsgThres = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtMissedMaintMsgThres.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtMissedMaintMsgThres.setDescription('The missed maintenance message threshold in percentage. A value 0 indicates that the interface has no spectrum group assigned. i.e. ccsUpSpecMgmtSpecGroup equals 0.')
ccsUpSpecMgmtHopPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 3600), ))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtHopPeriod.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtHopPeriod.setDescription('The minimum time between frequency hops in seconds. A value 0 indicates that the interface has no spectrum group assigned. i.e. ccsUpSpecMgmtSpecGroup equals to 0.')
ccsUpSpecMgmtCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 23), Bits().clone(namedValues=NamedValues(("snrBelowThres", 0), ("cnrBelowThres", 1), ("corrFecAboveThres", 2), ("uncorrFecAboveThres", 3), ("snrAboveThres", 4), ("cnrAboveThres", 5), ("corrFecBelowThres", 6), ("uncorrFecBelowThres", 7), ("noActiveModem", 8), ("uncorrFecAboveSecondThres", 9), ("others", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtCriteria.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtCriteria.setDescription('Defines the criteria that trigger a change in frequency hopping, modulation or channel width. Depending on the type of linecards, the criteria are slightly different: For the linecards that have no Hardware Based Spectrum Management capability like the uBR-MC1xC, change in modulation or frequency occurs in the following criteria: 1) Change from modulation profile 1 to modulation profile 2 would occur when CMTS detects the SNR that goes below the threshold and either corr FEC or uncorr FEC is above the threshold. In this case, snrBelowThres and either corrFecAboveThres or uncorrFecAboveThres bits will get set. 2) Change from modulation profile 2 to modulation profile 1 would occur when CMTS detects the SNR goes above the threshold+3 and both corr FEC and uncorr FEC are below the threshold. In this case, snrAboveThres and corrFecBelowThres and uncorrFecBelowThres bits will get set. 3) Change in frequency or frequency hopping would occur when CMTS detects no active modem on the link. In this case, noActiveModem bit will get set accordingly. For the linecards that have the Hardware Based Spectrum Management capability, change in frequency, modulation or channel width occurs in the following criteria: 1) when CMTS detects the SNR or CNR goes below the threshold and either corr FEC or uncorr FEC is above the threshold. In this case, either snrBelowThres or cnrBelowThres and either corrFecAboveThres or uncorrFecAboveThres bits will get set. 2) when CMTS detects the SNR or CNR goes above the threshold + 3 and both corr FEC and uncorr FEC are below the threshold. In this case, either snrAboveThres or cnrAboveThres and both corrFecBelowThres and uncorrFecBelowThres bits will get set. 3) when CMTS detects no active modem on the link or uncorr FEC is above ccsUpSpecMgmtFecUnCorrectThres2. In this case noActiveModem or uncorrFecAboveSecondThres bit will get set accordingly. Note: The order of frequency, modulation or channel width changes for the advanced spectrum management linecards will be determined based on the selection of the ccsUpSpecMgmtHopPriority.')
ccsUpSpecMgmtSpecGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtSpecGroup.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtSpecGroup.setDescription('The spectrum group assigned to the upstream. The value of 0 for the object indicates that the upstream has no spectrum group assigned.')
ccsUpSpecMgmtSharedSpectrum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 1, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccsUpSpecMgmtSharedSpectrum.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtSharedSpectrum.setDescription('The fiber-node assigned to the upstreams. Upstreams having same fiber-node number indicates that they physically combine together into same RF domain and must have unique frequency assigned. The value of 0 for the object indicates that the upstream is not physically combine with any others.')
ccsSpecGroupFreqTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2), )
if mibBuilder.loadTexts: ccsSpecGroupFreqTable.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqTable.setDescription('This table contains the frequency and band configuration of the spectrum group.')
ccsSpecGroupFreqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupNumber"), (0, "CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupFreqIndex"))
if mibBuilder.loadTexts: ccsSpecGroupFreqEntry.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqEntry.setDescription('An entry in ccsSpecGroupFreqTable. Each entry represents a center frequency or a frequency band configured for the spectrum group.')
ccsSpecGroupFreqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: ccsSpecGroupFreqIndex.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqIndex.setDescription('An arbitrary index to uniquely identify frequencies or bands configured in spectrum group.')
ccsSpecGroupFreqType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("centerFreq", 1), ("bandFreq", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupFreqType.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqType.setDescription('The type of the frequency configured in spectrum group. This is a mandatory object and can be modified when the row is active. If the value of centerFreq(1) is specified, the values of the corresponding instance of ccsSpecGroupFreqLower and csSpecGroupFreqUpper object must be identical. If the value of bandFreq(2) is specified, the values of the corresponding instance of ccsSpecGroupFreqLower and csSpecGroupFreqUpper must be unique.')
ccsSpecGroupFreqLower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setUnits('Hz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupFreqLower.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqLower.setDescription('The lower frequency configured in spectrum group. This is a mandatory object and can be modified when the row is active. To configure a band frequency in the spectrum group, the value of this object must be lower than the value of the corresponding instance of ccsSpecGroupFreqUpper. To configure a fixed center frequency in the spectrum group, the value of this object must be equal to the value of the corresponding instance of ccsSpecGroupFreqUpper.')
ccsSpecGroupFreqUpper = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setUnits('Hz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupFreqUpper.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqUpper.setDescription('The upper frequency configured in spectrum group. This is a mandatory object and can be modified when the row is active. To configure a band frequency in the spectrum group, the value of this object must be greater than the value of the corresponding instance of ccsSpecGroupFreqLower. To configure a fixed center frequency in the spectrum group, the value of this object must be equal to the value of the corresponding instance of ccsSpecGroupFreqLower.')
ccsSpecGroupStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupStorage.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupStorage.setDescription('The storage type for this conceptual row.')
ccsSpecGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 114, 1, 3, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccsSpecGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupRowStatus.setDescription('The status of this conceptual row. This object is used for creating/deleting entries in ccsSpecGroupFreqTable. A conceptual row may not be created via SNMP without explicitly setting the value of ccsSpecGroupRowStatus to createAndGo(4). A conceptual row can not have the status of active(1) until proper values have been assigned to the mandatory objects ccsSpecGroupFreqType, ccsSpecGroupFreqLower, and ccsSpecGroupFreqUpper. A conceptual row may be modified or deleted any time. If the frequency represents by the row has been assigned to a cable upstream interface, modifying or deleting such row would cause the cable upstream interface frequency reassignment.')
ciscoCableSpectrumMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 2))
ccsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 2, 0))
ccsHoppingNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 114, 2, 0, 1)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopCondition"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"))
if mibBuilder.loadTexts: ccsHoppingNotification.setStatus('deprecated')
if mibBuilder.loadTexts: ccsHoppingNotification.setDescription("A notification is sent when there's a change in frequency (hopping), modulation, or profile. In the case of frequency hopping, ccsUpSpecMgmtHopCondition would indicate whether SNR or modemOffline that caused the hopping.")
ccsSpecMgmtNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 114, 2, 0, 2)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCriteria"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"))
if mibBuilder.loadTexts: ccsSpecMgmtNotification.setStatus('current')
if mibBuilder.loadTexts: ccsSpecMgmtNotification.setDescription("A notification is sent when there's a change in frequency hopping, modulation, or profile. ccsUpSpecMgmtCriteria is used to indicate the cause(s).")
ciscoCableSpectrumMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 3))
ciscoCableSpectrumMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1))
ciscoCableSpectrumMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2))
ccsCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 1)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance = ccsCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ccsCompliance.setDescription('The compliance statement for devices that implement DOCSIS-compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 2)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance2 = ccsCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: ccsCompliance2.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features. This compliance is deprecated and replaced by ccsCompliance3.')
ccsCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 3)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroupRev1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance3 = ccsCompliance3.setStatus('deprecated')
if mibBuilder.loadTexts: ccsCompliance3.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 4)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroupRev1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsNotificationGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroupRev1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance4 = ccsCompliance4.setStatus('deprecated')
if mibBuilder.loadTexts: ccsCompliance4.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 5)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroupRev2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsNotificationGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroupRev2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance5 = ccsCompliance5.setStatus('deprecated')
if mibBuilder.loadTexts: ccsCompliance5.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 6)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroupRev2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsNotificationGroupRev1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroupRev3"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance6 = ccsCompliance6.setStatus('deprecated')
if mibBuilder.loadTexts: ccsCompliance6.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 1, 7)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapGroupRev2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsNotificationGroupRev1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtGroupRev4"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupFreqGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpInSpecGroupGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpInFiberNodeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsCompliance7 = ccsCompliance7.setStatus('current')
if mibBuilder.loadTexts: ccsCompliance7.setDescription('The compliance statement for devices that implement DOCSIS- compliant Radio Frequency Interfaces and Spectrum Management features.')
ccsFlapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 1)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListMaxSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListCurrentSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapAging"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapInsertionTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapUpstreamIfIndex"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapDownstreamIfIndex"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapInsertionFails"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapHits"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapMisses"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapCrcErrors"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapPowerAdjustments"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapTotal"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapLastFlapTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapCreateTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsFlapGroup = ccsFlapGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapGroup.setDescription('Group of objects implemented in CMTS providing Flap List information. This object group has been deprecated and replaced by ccsFlapGroupRev1.')
ccsSpectrumGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 2)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestIfIndex"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestMacAddr"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestUpperFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestLowFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestResolution"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestStartTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestStoppedTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestOperation"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestOperState"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumRequestStatus"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumDataFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpectrumDataPower"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestMacAddr"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestSNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestStartTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestStoppedTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestOperation"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestOperState"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSNRRequestStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsSpectrumGroup = ccsSpectrumGroup.setStatus('current')
if mibBuilder.loadTexts: ccsSpectrumGroup.setDescription('Group of objects implemented in Cable Modem Termination Systems providing upstream spectrum data information.')
ccsUpSpecMgmtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 3)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPriority"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrPollPeriod"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopCondition"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSNR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpSpecMgmtGroup = ccsUpSpecMgmtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtGroup.setDescription('Group of objects implemented in Cable Modem Termination Systems for configuring cable upstream interface attributes which are used to increase the performance and proactive hopping.')
ccsNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 4)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsHoppingNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsNotificationGroup = ccsNotificationGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ccsNotificationGroup.setDescription('The notification which a CISCO-CABLE-SPECTRUM-MIB entity is required to implement.')
ccsFlapGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 5)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListMaxSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListCurrentSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapAging"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapInsertionTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapUpstreamIfIndex"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapDownstreamIfIndex"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapLastFlapTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapCreateTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapRowStatus"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapInsertionFailNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapHitNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapMissNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapCrcErrorNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapPowerAdjustmentNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapTotalNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapResetNow"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapLastResetTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapPowerAdjustThreshold"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapMissThreshold"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapResetAll"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapClearAll"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapLastClearTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsFlapGroupRev1 = ccsFlapGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ccsFlapGroupRev1.setDescription('Group of objects implemented in CMTS providing Flap List information. This object group has been deprecated and replaced by ccsFlapGroupRev2.')
ccsUpSpecMgmtGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 6)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPriority"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopCondition"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSNR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpSpecMgmtGroupRev1 = ccsUpSpecMgmtGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtGroupRev1.setDescription('Group of objects implemented in Cable Modem Termination Systems for configuring cable upstream interface attributes which are used to increase the performance and proactive hopping. This object group has been deprecated and replaced by ccsUpSpecMgmtGroupRev2.')
ccsFlapGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 7)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListMaxSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapListCurrentSize"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapAging"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFlapInsertionTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapLastFlapTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapCreateTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapInsertionFailNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapHitNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapMissNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapCrcErrorNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapPowerAdjustmentNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapTotalNum"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapResetNow"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapLastResetTime"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsCmFlapRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsFlapGroupRev2 = ccsFlapGroupRev2.setStatus('current')
if mibBuilder.loadTexts: ccsFlapGroupRev2.setDescription('Group of objects implemented in CMTS providing Flap List information.')
ccsUpSpecMgmtGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 8)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPriority"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopCondition"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtUpperBoundFreq"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpSpecMgmtGroupRev2 = ccsUpSpecMgmtGroupRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtGroupRev2.setDescription('Group of objects implemented in Cable Modem Termination Systems for configuring cable upstream interface attributes.')
ccsNotificationGroupRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 9)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecMgmtNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsNotificationGroupRev1 = ccsNotificationGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ccsNotificationGroupRev1.setDescription('The notification which a CISCO-CABLE-SPECTRUM-MIB entity is required to implement.')
ccsUpSpecMgmtGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 10)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPriority"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtUpperBoundFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtMissedMaintMsgThres"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPeriod"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCriteria"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpSpecMgmtGroupRev3 = ccsUpSpecMgmtGroupRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ccsUpSpecMgmtGroupRev3.setDescription('Group of objects implemented in Cable Modem Termination Systems for configuring cable upstream interface attributes.')
ccsSpecGroupFreqGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 11)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupFreqType"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupFreqLower"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupFreqUpper"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupStorage"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsSpecGroupFreqGroup = ccsSpecGroupFreqGroup.setStatus('current')
if mibBuilder.loadTexts: ccsSpecGroupFreqGroup.setDescription('Global spectrum group frequency / band definition.')
ccsUpSpecMgmtGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 12)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPriority"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFecUnCorrectThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToCenterFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToBandWidth"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtFromModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtToModProfile"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtUpperBoundFreq"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCnrThres1"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCnrThres2"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCNR"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtMissedMaintMsgThres"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtHopPeriod"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtCriteria"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSpecGroup"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsUpSpecMgmtSharedSpectrum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpSpecMgmtGroupRev4 = ccsUpSpecMgmtGroupRev4.setStatus('current')
if mibBuilder.loadTexts: ccsUpSpecMgmtGroupRev4.setDescription('Group of objects implemented in Cable Modem Termination Systems for configuring cable upstream interface attributes.')
ccsUpInSpecGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 13)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupUpstreamStorage"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsSpecGroupUpstreamRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpInSpecGroupGroup = ccsUpInSpecGroupGroup.setStatus('current')
if mibBuilder.loadTexts: ccsUpInSpecGroupGroup.setDescription('Group of objects to populate all cable upstream interfaces in spectrum group.')
ccsUpInFiberNodeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 114, 3, 2, 14)).setObjects(("CISCO-CABLE-SPECTRUM-MIB", "ccsFiberNodeUpstreamStorage"), ("CISCO-CABLE-SPECTRUM-MIB", "ccsFiberNodeUpstreamRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccsUpInFiberNodeGroup = ccsUpInFiberNodeGroup.setStatus('current')
if mibBuilder.loadTexts: ccsUpInFiberNodeGroup.setDescription('Group of objects to populate all cable upstream interfaces in fiber-node.')
mibBuilder.exportSymbols("CISCO-CABLE-SPECTRUM-MIB", ccsCmFlapPowerAdjustmentNum=ccsCmFlapPowerAdjustmentNum, ccsFlapMissThreshold=ccsFlapMissThreshold, ccsSpectrumDataEntry=ccsSpectrumDataEntry, CCSRequestOperState=CCSRequestOperState, ccsSNRRequestOperation=ccsSNRRequestOperation, ccsUpSpecMgmtCriteria=ccsUpSpecMgmtCriteria, ccsCompliance5=ccsCompliance5, ccsCmFlapDownstreamIfIndex=ccsCmFlapDownstreamIfIndex, ccsSpecGroupFreqIndex=ccsSpecGroupFreqIndex, ccsFlapObjects=ccsFlapObjects, ccsUpInSpecGroupEntry=ccsUpInSpecGroupEntry, ciscoCableSpectrumMIBObjects=ciscoCableSpectrumMIBObjects, ccsFlapDownstreamIfIndex=ccsFlapDownstreamIfIndex, ccsSNRRequestIndex=ccsSNRRequestIndex, ccsNotificationGroupRev1=ccsNotificationGroupRev1, ccsUpInFiberNodeEntry=ccsUpInFiberNodeEntry, ccsSpectrumRequestLowFreq=ccsSpectrumRequestLowFreq, ccsCmFlapEntry=ccsCmFlapEntry, ccsConfigObjects=ccsConfigObjects, ccsFlapPowerAdjustmentNum=ccsFlapPowerAdjustmentNum, ccsFiberNodeUpstreamStorage=ccsFiberNodeUpstreamStorage, ccsUpSpecMgmtHopPriority=ccsUpSpecMgmtHopPriority, ccsCompliance7=ccsCompliance7, ccsFlapPowerAdjustments=ccsFlapPowerAdjustments, ccsFlapResetNow=ccsFlapResetNow, ccsUpSpecMgmtFromModProfile=ccsUpSpecMgmtFromModProfile, ccsSpectrumRequestStartTime=ccsSpectrumRequestStartTime, ccsFlapLastFlapTime=ccsFlapLastFlapTime, ccsUpSpecMgmtEntry=ccsUpSpecMgmtEntry, ccsSpecGroupFreqLower=ccsSpecGroupFreqLower, ccsFlapEntry=ccsFlapEntry, ccsSNRRequestEntry=ccsSNRRequestEntry, ccsHoppingNotification=ccsHoppingNotification, ccsSNRRequestStatus=ccsSNRRequestStatus, ccsSpectrumObjects=ccsSpectrumObjects, ccsFlapResetAll=ccsFlapResetAll, ccsCmFlapCreateTime=ccsCmFlapCreateTime, ccsSpecGroupUpstreamStorage=ccsSpecGroupUpstreamStorage, ccsUpSpecMgmtFecUnCorrectThres2=ccsUpSpecMgmtFecUnCorrectThres2, ccsUpSpecMgmtCnrThres2=ccsUpSpecMgmtCnrThres2, ccsFlapUpstreamIfIndex=ccsFlapUpstreamIfIndex, ccsCmFlapMissNum=ccsCmFlapMissNum, ccsFlapPowerAdjustThreshold=ccsFlapPowerAdjustThreshold, ccsSNRRequestStartTime=ccsSNRRequestStartTime, ccsUpSpecMgmtFecUnCorrectThres1=ccsUpSpecMgmtFecUnCorrectThres1, ccsFlapTable=ccsFlapTable, ccsSpecGroupNumber=ccsSpecGroupNumber, ccsUpSpecMgmtFromBandWidth=ccsUpSpecMgmtFromBandWidth, ccsCmFlapLastFlapTime=ccsCmFlapLastFlapTime, ccsSpectrumRequestUpperFreq=ccsSpectrumRequestUpperFreq, ccsUpSpecMgmtSNR=ccsUpSpecMgmtSNR, ccsCmFlapInsertionFailNum=ccsCmFlapInsertionFailNum, ciscoCableSpectrumMIBConformance=ciscoCableSpectrumMIBConformance, ccsSpectrumRequestResolution=ccsSpectrumRequestResolution, ccsUpSpecMgmtFecCorrectThres2=ccsUpSpecMgmtFecCorrectThres2, ccsFlapClearAll=ccsFlapClearAll, ccsSpecGroupFreqGroup=ccsSpecGroupFreqGroup, ccsFiberNodeNumber=ccsFiberNodeNumber, ccsUpSpecMgmtSharedSpectrum=ccsUpSpecMgmtSharedSpectrum, ccsSNRRequestStoppedTime=ccsSNRRequestStoppedTime, ccsUpSpecMgmtGroupRev3=ccsUpSpecMgmtGroupRev3, CCSRequestOperation=CCSRequestOperation, ccsCmFlapTotalNum=ccsCmFlapTotalNum, ciscoCableSpectrumMIB=ciscoCableSpectrumMIB, ccsFlapMissNum=ccsFlapMissNum, ccsSpectrumRequestMacAddr=ccsSpectrumRequestMacAddr, ccsSpectrumDataPower=ccsSpectrumDataPower, ciscoCableSpectrumMIBCompliances=ciscoCableSpectrumMIBCompliances, ccsFlapGroupRev1=ccsFlapGroupRev1, ccsSpectrumRequestTable=ccsSpectrumRequestTable, ccsUpSpecMgmtCnrThres1=ccsUpSpecMgmtCnrThres1, ccsFiberNodeUpstreamIfIndex=ccsFiberNodeUpstreamIfIndex, PYSNMP_MODULE_ID=ciscoCableSpectrumMIB, ccsSpectrumRequestStoppedTime=ccsSpectrumRequestStoppedTime, ccsFlapHitNum=ccsFlapHitNum, ccsSpecGroupUpstreamIfIndex=ccsSpecGroupUpstreamIfIndex, ccsFlapGroup=ccsFlapGroup, CCSFrequency=CCSFrequency, ccsCompliance2=ccsCompliance2, ccsFlapTotal=ccsFlapTotal, ccsUpSpecMgmtSpecGroup=ccsUpSpecMgmtSpecGroup, ccsCmFlapResetNow=ccsCmFlapResetNow, ccsUpSpecMgmtTable=ccsUpSpecMgmtTable, ccsUpSpecMgmtSnrThres1=ccsUpSpecMgmtSnrThres1, ccsSpecGroupRowStatus=ccsSpecGroupRowStatus, ccsUpSpecMgmtUpperBoundFreq=ccsUpSpecMgmtUpperBoundFreq, ccsFlapHits=ccsFlapHits, ccsUpSpecMgmtFromCenterFreq=ccsUpSpecMgmtFromCenterFreq, ccsCmFlapCrcErrorNum=ccsCmFlapCrcErrorNum, ccsUpSpecMgmtGroupRev1=ccsUpSpecMgmtGroupRev1, ccsCmFlapLastResetTime=ccsCmFlapLastResetTime, ccsSpecGroupUpstreamRowStatus=ccsSpecGroupUpstreamRowStatus, ccsUpSpecMgmtCNR=ccsUpSpecMgmtCNR, ccsSpecGroupStorage=ccsSpecGroupStorage, ccsSpectrumRequestIndex=ccsSpectrumRequestIndex, CCSMeasuredFrequency=CCSMeasuredFrequency, ccsFlapInsertionFailNum=ccsFlapInsertionFailNum, ccsCompliance3=ccsCompliance3, ccsSNRRequestMacAddr=ccsSNRRequestMacAddr, ccsFlapGroupRev2=ccsFlapGroupRev2, ccsFlapMisses=ccsFlapMisses, ccsFlapLastResetTime=ccsFlapLastResetTime, ccsSpectrumRequestStatus=ccsSpectrumRequestStatus, ccsFlapCrcErrorNum=ccsFlapCrcErrorNum, ccsSpecGroupFreqUpper=ccsSpecGroupFreqUpper, ccsCompliance4=ccsCompliance4, ccsUpSpecMgmtToBandWidth=ccsUpSpecMgmtToBandWidth, ccsUpSpecMgmtGroupRev4=ccsUpSpecMgmtGroupRev4, ccsSNRRequestTable=ccsSNRRequestTable, ccsNotificationGroup=ccsNotificationGroup, ccsFlapListMaxSize=ccsFlapListMaxSize, ccsSNRRequestOperState=ccsSNRRequestOperState, ccsCompliance6=ccsCompliance6, ccsSpectrumRequestOperation=ccsSpectrumRequestOperation, ccsUpSpecMgmtToModProfile=ccsUpSpecMgmtToModProfile, ccsSpectrumRequestIfIndex=ccsSpectrumRequestIfIndex, ccsUpSpecMgmtGroup=ccsUpSpecMgmtGroup, ccsMIBNotifications=ccsMIBNotifications, ccsUpSpecMgmtGroupRev2=ccsUpSpecMgmtGroupRev2, ccsSpecMgmtNotification=ccsSpecMgmtNotification, ccsFlapMacAddr=ccsFlapMacAddr, ccsUpSpecMgmtMissedMaintMsgThres=ccsUpSpecMgmtMissedMaintMsgThres, ciscoCableSpectrumMIBGroups=ciscoCableSpectrumMIBGroups, ccsSpecGroupFreqTable=ccsSpecGroupFreqTable, ccsUpInFiberNodeTable=ccsUpInFiberNodeTable, ccsCmFlapMacAddr=ccsCmFlapMacAddr, ccsCmFlapTable=ccsCmFlapTable, ccsCmFlapRowStatus=ccsCmFlapRowStatus, ccsUpInSpecGroupGroup=ccsUpInSpecGroupGroup, ciscoCableSpectrumMIBNotificationPrefix=ciscoCableSpectrumMIBNotificationPrefix, ccsSpectrumDataFreq=ccsSpectrumDataFreq, ccsUpSpecMgmtHopPeriod=ccsUpSpecMgmtHopPeriod, ccsFlapAging=ccsFlapAging, ccsSpectrumDataTable=ccsSpectrumDataTable, ccsSpectrumRequestEntry=ccsSpectrumRequestEntry, ccsSpectrumGroup=ccsSpectrumGroup, ccsSNRRequestSNR=ccsSNRRequestSNR, ccsUpInSpecGroupTable=ccsUpInSpecGroupTable, ccsCompliance=ccsCompliance, ccsFlapLastClearTime=ccsFlapLastClearTime, ccsFlapRowStatus=ccsFlapRowStatus, ccsSpecGroupFreqType=ccsSpecGroupFreqType, ccsCmFlapHitNum=ccsCmFlapHitNum, ccsUpSpecMgmtSnrThres2=ccsUpSpecMgmtSnrThres2, ccsSpectrumRequestOperState=ccsSpectrumRequestOperState, ccsUpSpecMgmtHopCondition=ccsUpSpecMgmtHopCondition, ccsFlapListCurrentSize=ccsFlapListCurrentSize, ccsSpecGroupFreqEntry=ccsSpecGroupFreqEntry, ccsFlapCreateTime=ccsFlapCreateTime, ccsFlapInsertionFails=ccsFlapInsertionFails, ccsFlapInsertionTime=ccsFlapInsertionTime, ccsFlapTotalNum=ccsFlapTotalNum, ccsFiberNodeUpstreamRowStatus=ccsFiberNodeUpstreamRowStatus, ccsUpSpecMgmtFecCorrectThres1=ccsUpSpecMgmtFecCorrectThres1, ccsCmFlapUpstreamIfIndex=ccsCmFlapUpstreamIfIndex, ccsUpSpecMgmtToCenterFreq=ccsUpSpecMgmtToCenterFreq, ccsUpInFiberNodeGroup=ccsUpInFiberNodeGroup, ccsUpSpecMgmtSnrPollPeriod=ccsUpSpecMgmtSnrPollPeriod, ccsFlapCrcErrors=ccsFlapCrcErrors)

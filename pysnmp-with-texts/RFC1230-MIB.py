#
# PySNMP MIB module RFC1230-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RFC1230-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:56:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Counter64, transmission, IpAddress, Counter32, Integer32, Unsigned32, NotificationType, Gauge32, TimeTicks, Bits, MibIdentifier, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Counter64", "transmission", "IpAddress", "Counter32", "Integer32", "Unsigned32", "NotificationType", "Gauge32", "TimeTicks", "Bits", "MibIdentifier", "iso", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dot4 = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class OctetTime(Integer32):
    pass

dot4Table = MibTable((1, 3, 6, 1, 2, 1, 10, 8, 1), )
if mibBuilder.loadTexts: dot4Table.setStatus('mandatory')
if mibBuilder.loadTexts: dot4Table.setDescription('This table contains Token Bus interface parameters and state variables, one entry per 802.5 interface.')
dot4Entry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 8, 1, 1), ).setIndexNames((0, "RFC1230-MIB", "dot4IfIndex"))
if mibBuilder.loadTexts: dot4Entry.setStatus('mandatory')
if mibBuilder.loadTexts: dot4Entry.setDescription('A list of Token Bus status and operational parameter values for an 802.4 interface.')
dot4IfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot4IfIndex.setDescription('The value of this object identifies the 802.4 interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object, defined in [4,6], for the same interface.')
dot4Options = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4Options.setStatus('mandatory')
if mibBuilder.loadTexts: dot4Options.setDescription('The optional parts of the 802.4 specification which are in use by this station. The options of the 802.4 specification are represented by the following values: 1 - Priority 2 - Request-With-Response The value of this object is given by the sum of the above representations for those options in use on this interface. The value zero indicates that no options are in use.')
dot4State = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("offline", 2), ("outOfRing", 3), ("enteringRing", 4), ("inRing", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4State.setStatus('mandatory')
if mibBuilder.loadTexts: dot4State.setDescription('The current state of the 802.4 interface. The value of other(1) is used if the state is unknown (e.g., due to an error condition).')
dot4Commands = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-op", 1), ("enterRing", 2), ("exitRing", 3), ("reset", 4), ("initialize", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4Commands.setStatus('mandatory')
if mibBuilder.loadTexts: dot4Commands.setDescription("Setting this object causes the station to change the state of the interface as indicated by the specified value. An initialize(5) command causes the interfaceto load its operational parameters from its initialization parameters; the value of dot4InitInRingDesired determines whether the station tries to enter the logical ring immediately. Note that the 802.4 specification suggests a station remain Offline after a 'remote Network Management' reset(4), until a 'local Network Management' initialize(5) is performed. Setting this object to a value of no-op(1) has no effect. When read, this object always has the value no-op(1).")
dot4MacAddrLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sixteenBit", 1), ("forty-eightBit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4MacAddrLen.setStatus('mandatory')
if mibBuilder.loadTexts: dot4MacAddrLen.setDescription('This object indicates the size of MAC addresses interpreted by this station.')
dot4NextStation = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4NextStation.setStatus('mandatory')
if mibBuilder.loadTexts: dot4NextStation.setDescription("The MAC address of this station's successor in the logical ring.")
dot4PreviousStation = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4PreviousStation.setStatus('mandatory')
if mibBuilder.loadTexts: dot4PreviousStation.setDescription('The source MAC address of the last token addressed to this station.')
dot4SlotTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 8), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4SlotTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot4SlotTime.setDescription('The maximum time any station need wait for an immediate MAC-level response from another station. This value must the same in all stations on the 802.4 network.')
dot4LastTokenRotTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 9), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4LastTokenRotTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot4LastTokenRotTime.setDescription('The observed token rotation time for the last token rotation, timed from token arrival to token arrival. A value of zero indicates that the token is not rotating.')
dot4HiPriTokenHoldTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 10), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4HiPriTokenHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot4HiPriTokenHoldTime.setDescription('The maximum duration for which a station can hold the token to transmit frames of access class 6 (if the priority option is implemented), or of any access class (if the priority option is not implemented).')
dot4TargetRotTimeClass4 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 11), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4TargetRotTimeClass4.setStatus('mandatory')
if mibBuilder.loadTexts: dot4TargetRotTimeClass4.setDescription('If the priority scheme is being used, this value specifies a limit on how long a station can transmit frames at access class 4. The limit is measured from the time the station is able to start transmitting frames at this access class on one rotation, to the time it must stop transmitting frames at this access class on the next rotation. If the priority scheme is not being used, this object has the value 0.')
dot4TargetRotTimeClass2 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 12), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4TargetRotTimeClass2.setStatus('mandatory')
if mibBuilder.loadTexts: dot4TargetRotTimeClass2.setDescription('If the priority scheme is being used, this value specifies a limit on how long a station can transmit frames at access class 2. The limit is measured from the time the station is able to start transmitting frames at this access class on one rotation, to the time it must stop transmitting frames at this access class on the next rotation. If the priority scheme is not being used, this object has the value 0.')
dot4TargetRotTimeClass0 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 13), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4TargetRotTimeClass0.setStatus('mandatory')
if mibBuilder.loadTexts: dot4TargetRotTimeClass0.setDescription('If the priority scheme is being used, this value specifies a limit on how long a station can transmit frames at access class 0. The limit is measured from the time the station is able to start transmitting frames at this access class on one rotation, to the time it must stop transmitting frames at this access class on the next rotation. If the priority scheme is not being used, this object has the value 0.')
dot4TargetRotTimeRingMaint = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 14), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4TargetRotTimeRingMaint.setStatus('mandatory')
if mibBuilder.loadTexts: dot4TargetRotTimeRingMaint.setDescription('A value used to limit the duration of a token rotation. If the duration of a token rotation exceeds this value, the station will not open the response window to solicit for a new successor.')
dot4RingMaintTimerInitValue = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 15), OctetTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4RingMaintTimerInitValue.setStatus('mandatory')
if mibBuilder.loadTexts: dot4RingMaintTimerInitValue.setDescription('The value to which the dot4TargetRotTimeRingMaint is set, each time the station enters the ring. A large value will cause the station to solicit successors immediately upon entry to the ring; a value of zero will cause the station to defer this solicitation for at least one token rotation.')
dot4MaxInterSolicitCount = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4MaxInterSolicitCount.setStatus('mandatory')
if mibBuilder.loadTexts: dot4MaxInterSolicitCount.setDescription('The maximum number of consecutive token rotations without soliciting for a successor. If this count expires, the station opens the response window to solicit for a successor (providing the duration of the current token rotation has not exceeded dot4TargetRotTimeRingMaint). The least significant two bits of the count are determined randomly by the station on a per-use basis.')
dot4MaxRetries = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4MaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: dot4MaxRetries.setDescription('The maximum number of retries of a Request-with-Response (RWR) frame. If the RWR option is not in use, this object has the value 0.')
dot4MinPostSilencePreambLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4MinPostSilencePreambLen.setStatus('mandatory')
if mibBuilder.loadTexts: dot4MinPostSilencePreambLen.setDescription("The minimum number of octets of preamble on the first frame transmitted by this station after a period of 'transmitted' silence.")
dot4StandardRevision = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("rev2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StandardRevision.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StandardRevision.setDescription('The Revision number of the 802.4 standard implemented by this station.')
dot4InitTable = MibTable((1, 3, 6, 1, 2, 1, 10, 8, 2), )
if mibBuilder.loadTexts: dot4InitTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitTable.setDescription('This table contains Token Bus initialization parameters, one entry per 802.4 interface.')
dot4InitEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 8, 2, 1), ).setIndexNames((0, "RFC1230-MIB", "dot4InitIfIndex"))
if mibBuilder.loadTexts: dot4InitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitEntry.setDescription('A list of Token Bus initialization parameters for an 802.4 interface.')
dot4InitIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4InitIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitIfIndex.setDescription('The value of this object identifies the 802.4 interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object, defined in [4,6], for the same interface.')
dot4InitSlotTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 2), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitSlotTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitSlotTime.setDescription('The value assigned to the object dot4SlotTime when the station is initialized.')
dot4InitMaxInterSolicitCount = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitMaxInterSolicitCount.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitMaxInterSolicitCount.setDescription('The value assigned to the object dot4MaxInterSolicitCount when the station is initialized.')
dot4InitMaxRetries = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitMaxRetries.setDescription('The value assigned to the object dot4MaxRetries when the station is initialized.')
dot4InitHiPriTokenHoldTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 5), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitHiPriTokenHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitHiPriTokenHoldTime.setDescription('The value assigned to the object dot4HiPriTokenHoldTime when the station is initialized.')
dot4InitTargetRotTimeClass4 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 6), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass4.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass4.setDescription('The value assigned to the object dot4TargetRotTimeClass4 when the station is initialized.')
dot4InitTargetRotTimeClass2 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 7), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass2.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass2.setDescription('The value assigned to the object dot4TargetRotTimeClass2 when the station is initialized.')
dot4InitTargetRotTimeClass0 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 8), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass0.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitTargetRotTimeClass0.setDescription('The value assigned to the object dot4TargetRotTimeClass0 when the station is initialized.')
dot4InitTargetRotTimeRingMaint = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 9), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitTargetRotTimeRingMaint.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitTargetRotTimeRingMaint.setDescription('The value assigned to the object dot4TargetRotTimeRingMaint when the station is initialized.')
dot4InitRingMaintTimerInitValue = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 10), OctetTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitRingMaintTimerInitValue.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitRingMaintTimerInitValue.setDescription('The value assigned to the object dot4RingMaintTimerInitValue when the station is initialized.')
dot4InitMinPostSilencePreambLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitMinPostSilencePreambLen.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitMinPostSilencePreambLen.setDescription('The value assigned to the object dot4MinPostSilencePreambLen when the station is initialized.')
dot4InitInRingDesired = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inRing", 1), ("outOfRing", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot4InitInRingDesired.setStatus('mandatory')
if mibBuilder.loadTexts: dot4InitInRingDesired.setDescription('This object determines whether the station will attempt to enter the logical ring immediately after initialization.')
dot4StatsTable = MibTable((1, 3, 6, 1, 2, 1, 10, 8, 3), )
if mibBuilder.loadTexts: dot4StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsTable.setDescription("A table containing Token Bus statistics. All the statistics are defined using the syntax Counter as 32 bit wrap around counters. Thus, if an interface's hardware chip set maintains these statistics in 16-bit counters, then the agent must read the hardware's counters frequently enough to prevent loss of significance, in order to maintain a 32-bit counter in software.")
dot4StatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 8, 3, 1), ).setIndexNames((0, "RFC1230-MIB", "dot4StatsIfIndex"))
if mibBuilder.loadTexts: dot4StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsEntry.setDescription('An entry containing the 802.4 statistics for a particular interface.')
dot4StatsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsIfIndex.setDescription('The value of this object identifies the 802.4 interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object, defined in [4,6], for the same interface.')
dot4StatsTokenPasses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsTokenPasses.setStatus('optional')
if mibBuilder.loadTexts: dot4StatsTokenPasses.setDescription('The number of times this station has passed the token.')
dot4StatsTokenHeards = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsTokenHeards.setStatus('optional')
if mibBuilder.loadTexts: dot4StatsTokenHeards.setDescription('The number of tokens heard by this station.')
dot4StatsNoSuccessors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsNoSuccessors.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsNoSuccessors.setDescription('The number of times the station could not find a successor while believing itself not the only station in the ring. This can signify a faulty transmitter condition in this station.')
dot4StatsWhoFollows = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsWhoFollows.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsWhoFollows.setDescription('The number of times the station has had to look for a new next station.')
dot4StatsTokenPassFails = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsTokenPassFails.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsTokenPassFails.setDescription('The number of times the station failed in passing the token to the next station.')
dot4StatsNonSilences = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsNonSilences.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsNonSilences.setDescription('The number of occurrences of non-silence followed by silence in which a start delimiter was not detected.')
dot4StatsFcsErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsFcsErrors.setDescription('The number of frames received with an incorrect FCS and the E-bit reset.')
dot4StatsEbitErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsEbitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsEbitErrors.setDescription('The number of frames the station received with the E-bit set in the end delimiter.')
dot4StatsFrameFrags = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsFrameFrags.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsFrameFrags.setDescription('The number of occurrences of receiving a start delimiter followed by another start delimiter, an invalid symbol sequence or silence, without an intervening end delimiter.')
dot4StatsFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsFrameTooLongs.setDescription("The number of frames that were received that were larger than the media's MTU.")
dot4StatsOverRuns = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsOverRuns.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsOverRuns.setDescription('The number of times a FIFO overrun was detected in the station.')
dot4StatsDupAddresses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 8, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot4StatsDupAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: dot4StatsDupAddresses.setDescription('The number of times this station detected another station using the same MAC address.')
dot4Tests = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 5))
dot4Errors = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 4))
dot4ModemInitFailed = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 4, 1))
testFifoPath = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 5, 1))
testExternalLoopback = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 5, 2))
dot4ChipSets = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 6))
chipSetMc68824 = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 8, 6, 1))
mibBuilder.exportSymbols("RFC1230-MIB", dot4StatsNoSuccessors=dot4StatsNoSuccessors, dot4=dot4, dot4NextStation=dot4NextStation, MacAddress=MacAddress, dot4State=dot4State, dot4InitInRingDesired=dot4InitInRingDesired, dot4InitEntry=dot4InitEntry, dot4InitRingMaintTimerInitValue=dot4InitRingMaintTimerInitValue, dot4Commands=dot4Commands, dot4InitHiPriTokenHoldTime=dot4InitHiPriTokenHoldTime, dot4StatsEbitErrors=dot4StatsEbitErrors, dot4StatsOverRuns=dot4StatsOverRuns, testExternalLoopback=testExternalLoopback, dot4PreviousStation=dot4PreviousStation, dot4StandardRevision=dot4StandardRevision, dot4MacAddrLen=dot4MacAddrLen, dot4TargetRotTimeClass2=dot4TargetRotTimeClass2, dot4HiPriTokenHoldTime=dot4HiPriTokenHoldTime, dot4StatsWhoFollows=dot4StatsWhoFollows, dot4StatsFrameTooLongs=dot4StatsFrameTooLongs, dot4TargetRotTimeClass0=dot4TargetRotTimeClass0, dot4MinPostSilencePreambLen=dot4MinPostSilencePreambLen, chipSetMc68824=chipSetMc68824, dot4InitMinPostSilencePreambLen=dot4InitMinPostSilencePreambLen, dot4ModemInitFailed=dot4ModemInitFailed, dot4StatsNonSilences=dot4StatsNonSilences, dot4Entry=dot4Entry, dot4InitMaxInterSolicitCount=dot4InitMaxInterSolicitCount, dot4InitMaxRetries=dot4InitMaxRetries, dot4IfIndex=dot4IfIndex, dot4Table=dot4Table, dot4Options=dot4Options, dot4TargetRotTimeClass4=dot4TargetRotTimeClass4, dot4InitTargetRotTimeClass4=dot4InitTargetRotTimeClass4, dot4StatsIfIndex=dot4StatsIfIndex, dot4InitTargetRotTimeRingMaint=dot4InitTargetRotTimeRingMaint, dot4StatsTokenPasses=dot4StatsTokenPasses, dot4InitTargetRotTimeClass2=dot4InitTargetRotTimeClass2, dot4Errors=dot4Errors, dot4InitTargetRotTimeClass0=dot4InitTargetRotTimeClass0, dot4StatsTokenPassFails=dot4StatsTokenPassFails, dot4StatsFcsErrors=dot4StatsFcsErrors, dot4StatsTable=dot4StatsTable, dot4InitTable=dot4InitTable, dot4MaxInterSolicitCount=dot4MaxInterSolicitCount, dot4MaxRetries=dot4MaxRetries, dot4LastTokenRotTime=dot4LastTokenRotTime, dot4TargetRotTimeRingMaint=dot4TargetRotTimeRingMaint, dot4InitIfIndex=dot4InitIfIndex, OctetTime=OctetTime, dot4RingMaintTimerInitValue=dot4RingMaintTimerInitValue, dot4SlotTime=dot4SlotTime, testFifoPath=testFifoPath, dot4StatsEntry=dot4StatsEntry, dot4StatsTokenHeards=dot4StatsTokenHeards, dot4StatsDupAddresses=dot4StatsDupAddresses, dot4Tests=dot4Tests, dot4StatsFrameFrags=dot4StatsFrameFrags, dot4ChipSets=dot4ChipSets, dot4InitSlotTime=dot4InitSlotTime)

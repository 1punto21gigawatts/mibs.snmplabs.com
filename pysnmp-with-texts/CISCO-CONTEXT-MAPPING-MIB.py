#
# PySNMP MIB module CISCO-CONTEXT-MAPPING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CONTEXT-MAPPING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:53:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoBridgeDomain, = mibBuilder.importSymbols("CISCO-TC", "CiscoBridgeDomain")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Gauge32, Bits, Unsigned32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, MibIdentifier, Integer32, Counter64, Counter32, IpAddress, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Bits", "Unsigned32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "MibIdentifier", "Integer32", "Counter64", "Counter32", "IpAddress", "ObjectIdentity", "iso")
TextualConvention, RowStatus, DisplayString, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "StorageType")
ciscoContextMappingMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 468))
ciscoContextMappingMIB.setRevisions(('2008-11-22 00:00', '2008-05-30 00:00', '2008-02-01 00:00', '2005-03-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoContextMappingMIB.setRevisionsDescriptions(('Added New Table cContextMappingLicenseGroupTable to provide SNMP Context support for license package groups. Added cContextMappingLicenseGroupDataGroup in OBJECT-GROUP Added cContextMappingMIBComplianceRev2 in MODULE-COMPLIANCE Updated the MIB description to indicate the use of the above additions', 'Add cContextMappingBridgeInstanceTable. Added cContextMappingBridgeInstanceDataGroup. Deprecated cContextMappingMIBComplianceRev1 and added cContextMappingMIBComplianceRev2 compliance statement.', 'Added New Table cContextMappingBridgeDomainTable to provide SNMP context support to the Bridge Domain. Added cContextMappingBridgeDomainDataGroup in OBJECT-GROUP Added cContextMappingMIBComplianceRev1 in MODULE-COMPLIANCE', 'Initial version of the MIB module.',))
if mibBuilder.loadTexts: ciscoContextMappingMIB.setLastUpdated('200811220000Z')
if mibBuilder.loadTexts: ciscoContextMappingMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoContextMappingMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoContextMappingMIB.setDescription("A single SNMP agent sometimes needs to support multiple instances of the same MIB module, and does so through the use of multiple SNMP contexts. This typically occurs because the technology has evolved to have extra dimension(s), i.e., one or more extra data and/or identifier values which are different in the different contexts, but were not defined in INDEX clause(s) of the original MIB module. In such cases, network management applications need to know the specific data/identifier values in each context, and this MIB module provides mapping tables which contain that information. Within a network there can be multiple Virtual Private Networks (VPNs) configured using Virtual Routing and Forwarding Instances (VRFs). Within a VPN there can be multiple topologies when Multi-topology Routing (MTR) is used. Also, Interior Gateway Protocols (IGPs) can have multiple protocol instances running on the device. A network can have multiple broadcast domains configured using Bridge Domain Identifiers. With MTR routing, VRFs, and Bridge domains, a router now needs to support multiple instances of several existing MIB modules, and this can be achieved if the router's SNMP agent provides access to each instance of the same MIB module via a different SNMP context (see Section 3.1.1 of RFC 3411). For MTR routing, VRFs, and Bridge domains, a different SNMP context is needed depending on one or more of the following: the VRF, the topology-identifier, the routing protocol instance, and the bridge domain identifier. In other words, the router's management information can be accessed through multiple SNMP contexts where each such context represents a specific VRF, a specific topology-identifier, a specific routing protocol instance and/or a bridge domain identifier. This MIB module provides a mapping of each such SNMP context to the corresponding VRF, the corresponding topology, the corresponding routing protocol instance, and the corresponding bridge domain identifier. Some SNMP contexts are independent of VRFs, independent of a topology, independent of a routing protocol instance, or independent of a bridge domain and in such a case, the mapping is to the zero length string. With the Cisco package licensing strategy, the features available in the image are grouped into multiple packages and each packages can be managed to operate at different feature levels based on the available license. This MIB module provides option to associate an SNMP context to a feature package group. This will allow manageability of license MIB objects specific to a feature package group. As technology evolves more we may need additional identifiers to identify the context. Then we would need to add those additional identifiers into the mapping.")
cContextMappingMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 468, 1))
cContextMappingMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 468, 2))
cContextMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1), )
if mibBuilder.loadTexts: cContextMappingTable.setStatus('current')
if mibBuilder.loadTexts: cContextMappingTable.setDescription("This table contains information on which cContextMappingVacmContextName is mapped to which VRF, topology, and routing protocol instance. This table is indexed by SNMP VACM context. Configuring a row in this table for an SNMP context does not require that the context be already defined, i.e., a row can be created in this table for a context before the corresponding row is created in RFC 3415's vacmContextTable. To create a row in this table, a manager must set cContextMappingRowStatus to either 'createAndGo' or 'createAndWait'. To delete a row in this table, a manager must set cContextMappingRowStatus to 'destroy'.")
cContextMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1), ).setIndexNames((0, "CISCO-CONTEXT-MAPPING-MIB", "cContextMappingVacmContextName"))
if mibBuilder.loadTexts: cContextMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cContextMappingEntry.setDescription('Information relating to a single mapping of cContextMappingVacmContextName to the corresponding VRF, the corresponding topology, and the corresponding routing protocol instance.')
cContextMappingVacmContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: cContextMappingVacmContextName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingVacmContextName.setDescription('The vacmContextName given to the SNMP context. This is a human readable name identifying a particular SNMP VACM context at a particular SNMP entity. The empty contextName (zero length) represents the default context.')
cContextMappingVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingVrfName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingVrfName.setDescription("The value of an instance of this object identifies the name given to the VRF to which the SNMP context is mapped to. This is typically a human-readable string. This is the same ASCII string used in the router's console interface to refer to this VRF. When the value of this object is the zero length string it indicates that the SNMP context is independent of any VRF.")
cContextMappingTopologyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingTopologyName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingTopologyName.setDescription("The value of an instance of this object identifies the name given to the topology to which the SNMP context is mapped to. This is typically a human-readable string. This is the same ASCII string used in the router's console interface to refer to this topology. When the value of this object is the zero length string it indicates that the SNMP context is independent of any topology.")
cContextMappingProtoInstName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingProtoInstName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingProtoInstName.setDescription("The value of an instance of this object identifies the name given to the protocol instance to which the SNMP context is mapped to. This is typically a human-readable string. This is the same ASCII string used in the router's console interface to refer to this protocol instance. When the value of this object is the zero length string it indicates that the SNMP context is independent of any protocol instance.")
cContextMappingStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingStorageType.setStatus('current')
if mibBuilder.loadTexts: cContextMappingStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
cContextMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: cContextMappingRowStatus.setDescription('This object facilitates the creation, modification, or deletion of a conceptual row in this table.')
cContextMappingBridgeDomainTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 2), )
if mibBuilder.loadTexts: cContextMappingBridgeDomainTable.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainTable.setDescription('This table contains information on which cContextMappingVacmContextName is mapped to which bridge domain. A Bridge Domain is one of the means by which it is possible to define an Ethernet broadcast domain on a bridging device. A network can have multiple broadcast domains configured. This table helps the network management personnel to find out the details of various broadcast domains configured in the network. An entry need to exist in cContextMappingTable, to create an entry in this table.')
cContextMappingBridgeDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 2, 1), ).setIndexNames((0, "CISCO-CONTEXT-MAPPING-MIB", "cContextMappingVacmContextName"))
if mibBuilder.loadTexts: cContextMappingBridgeDomainEntry.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainEntry.setDescription("Information relating to a single mapping of cContextMappingVacmContextName to the corresponding bridge domain. To create a row in this table, a manager must set cContextMappingBridgeDomainRowStatus to either 'createAndGo' or 'createAndWait'. To delete a row in this table, a manager must set cContextMappingBridgeDomainRowStatus to 'destroy'.")
cContextMappingBridgeDomainIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 2, 1, 1), CiscoBridgeDomain()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeDomainIdentifier.setReference('CISCO-BRIDGE-DOMAIN-MIB')
if mibBuilder.loadTexts: cContextMappingBridgeDomainIdentifier.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainIdentifier.setDescription('The value of an instance of this object identifies the bridge domain to which the SNMP context is mapped to.')
cContextMappingBridgeDomainStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 2, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeDomainStorageType.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
cContextMappingBridgeDomainRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeDomainRowStatus.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainRowStatus.setDescription('This object facilitates the creation, modification, or deletion of a conceptual row in this table.')
cContextMappingBridgeInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 3), )
if mibBuilder.loadTexts: cContextMappingBridgeInstanceTable.setReference('BRIDGE-MIB')
if mibBuilder.loadTexts: cContextMappingBridgeInstanceTable.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstanceTable.setDescription('This table contains information on mapping between cContextMappingVacmContextName and bridge instance. Bridge instance is an instance of a physical or logical bridge which has unique bridge-id. If an entry is deleted from cContextMappingTable, the corresponding entry in this table will also get deleted. If an entry needs to be created in this table, the corresponding entry must exist in cContextMappingTable.')
cContextMappingBridgeInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 3, 1), ).setIndexNames((0, "CISCO-CONTEXT-MAPPING-MIB", "cContextMappingVacmContextName"))
if mibBuilder.loadTexts: cContextMappingBridgeInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstanceEntry.setDescription("Information relating to a single mapping of cContextMappingVacmContextName to the corresponding bridge instance. To create a row in this table, a manager must set cContextMappingBridgeInstRowStatus to either 'createAndGo' or 'createAndWait'. To delete a row in this table, a manager must set cContextMappingBridgeInstRowStatus to 'destroy'.")
cContextMappingBridgeInstName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 3, 1, 1), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeInstName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstName.setDescription("The object identifies the name given to bridge instance to which the SNMP context is mapped to. Value of this object cannot be changed when the RowStatus object in the same row is 'active'. This is typically a human-readable string. This is the same ASCII string used in the router's console interface to refer to this bridge instance. When the value of this object is a zero length string, it indicates that the SNMP context is independent of any bridge instances.")
cContextMappingBridgeInstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 3, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeInstStorageType.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstStorageType.setDescription("The storage type for this conceptual row. Value of this object cannot be changed when the RowStatus object in the same row is 'active'. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
cContextMappingBridgeInstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingBridgeInstRowStatus.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstRowStatus.setDescription('This object facilitates the creation, modification, or deletion of a conceptual row in this table.')
cContextMappingLicenseGroupTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 4), )
if mibBuilder.loadTexts: cContextMappingLicenseGroupTable.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupTable.setDescription('This table contains information on which cContextMappingVacmContextName is mapped to which License Group. Group level licensing is used where each Technology Package is enabled via a License.')
cContextMappingLicenseGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 4, 1), ).setIndexNames((0, "CISCO-CONTEXT-MAPPING-MIB", "cContextMappingVacmContextName"))
if mibBuilder.loadTexts: cContextMappingLicenseGroupEntry.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupEntry.setDescription('Information relating to a single mapping of CContextMappingVacmContextName to the corresponding License Group.')
cContextMappingLicenseGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingLicenseGroupName.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupName.setDescription('The value of an instance of this object identifies the name given to the Group to which the SNMP context is mapped. Feature sets from all groups will be combined to form universal image. User can configure multiple groups as needed. For example: In Next generation ISRs will use the universal image package level licensing model for its licensing need. Each group has the feature set needed for that specific technology. Feature sets from different groups are combined to form universal image and each feature set for a group can be enabled using a valid license key. There will be a base level ipbase package in which the router boots with out any license key. The following are the different Technology Groups. 1.crypto 2.data 3.ip 4.legacy 5.novpn-security 6.security 7.uc')
cContextMappingLicenseGroupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 4, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingLicenseGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
cContextMappingLicenseGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 468, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cContextMappingLicenseGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupRowStatus.setDescription('This object facilitates the creation, modification, or deletion of a conceptual row in this table.')
cContextMappingMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 1))
cContextMappingMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 2))
cContextMappingMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 1, 1)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingDataGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingMIBCompliance = cContextMappingMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cContextMappingMIBCompliance.setDescription('The compliance statement for entities which implement the CISCO-CONTEXT-MAPPING-MIB.')
cContextMappingMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 1, 2)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainDataGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingMIBComplianceRev1 = cContextMappingMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cContextMappingMIBComplianceRev1.setDescription('The compliance statement for entities which implement the CISCO-CONTEXT-MAPPING-MIB. This compliance statement is superceded by cContextMappingMIBComplianceRev2.')
cContextMappingMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 1, 3)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeInstanceDataGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingMIBComplianceRev2 = cContextMappingMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cContextMappingMIBComplianceRev2.setDescription('The compliance statement for entities which implement the CISCO-CONTEXT-MAPPING-MIB.')
cContextMappingMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 1, 4)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeInstanceDataGroup"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingLicenseGroupDataGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingMIBComplianceRev3 = cContextMappingMIBComplianceRev3.setStatus('current')
if mibBuilder.loadTexts: cContextMappingMIBComplianceRev3.setDescription('The compliance statement for entities which implement the CISCO-CONTEXT-MAPPING-MIB.')
cContextMappingDataGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 2, 1)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingVrfName"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingTopologyName"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingProtoInstName"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingStorageType"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingDataGroup = cContextMappingDataGroup.setStatus('current')
if mibBuilder.loadTexts: cContextMappingDataGroup.setDescription('The collection of objects providing the context mapping data between the SNMP context to the corresponding VRF, the corresponding topology, and the corresponding routing protocol instance.')
cContextMappingBridgeDomainDataGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 2, 2)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainIdentifier"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainStorageType"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeDomainRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingBridgeDomainDataGroup = cContextMappingBridgeDomainDataGroup.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeDomainDataGroup.setDescription('The collection of objects providing the context mapping data between the SNMP context to the corresponding bridge domain.')
cContextMappingBridgeInstanceDataGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 2, 3)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeInstName"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeInstStorageType"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingBridgeInstRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingBridgeInstanceDataGroup = cContextMappingBridgeInstanceDataGroup.setStatus('current')
if mibBuilder.loadTexts: cContextMappingBridgeInstanceDataGroup.setDescription('The collection of objects providing the context mapping data between the SNMP context to the corresponding bridge instance.')
cContextMappingLicenseGroupDataGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 468, 2, 2, 4)).setObjects(("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingLicenseGroupName"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingLicenseGroupStorageType"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingLicenseGroupStorageType"), ("CISCO-CONTEXT-MAPPING-MIB", "cContextMappingLicenseGroupRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cContextMappingLicenseGroupDataGroup = cContextMappingLicenseGroupDataGroup.setStatus('current')
if mibBuilder.loadTexts: cContextMappingLicenseGroupDataGroup.setDescription('The collection of objects providing the context mapping data between the SNMP context to the corresponding LicenseGroupName.')
mibBuilder.exportSymbols("CISCO-CONTEXT-MAPPING-MIB", cContextMappingBridgeDomainRowStatus=cContextMappingBridgeDomainRowStatus, cContextMappingMIBComplianceRev1=cContextMappingMIBComplianceRev1, cContextMappingLicenseGroupTable=cContextMappingLicenseGroupTable, cContextMappingMIBComplianceRev2=cContextMappingMIBComplianceRev2, cContextMappingMIBObjects=cContextMappingMIBObjects, cContextMappingStorageType=cContextMappingStorageType, PYSNMP_MODULE_ID=ciscoContextMappingMIB, cContextMappingMIBComplianceRev3=cContextMappingMIBComplianceRev3, cContextMappingBridgeDomainStorageType=cContextMappingBridgeDomainStorageType, cContextMappingBridgeDomainDataGroup=cContextMappingBridgeDomainDataGroup, cContextMappingVacmContextName=cContextMappingVacmContextName, cContextMappingBridgeDomainEntry=cContextMappingBridgeDomainEntry, cContextMappingLicenseGroupRowStatus=cContextMappingLicenseGroupRowStatus, cContextMappingMIBCompliances=cContextMappingMIBCompliances, cContextMappingBridgeInstanceEntry=cContextMappingBridgeInstanceEntry, cContextMappingBridgeDomainTable=cContextMappingBridgeDomainTable, cContextMappingBridgeDomainIdentifier=cContextMappingBridgeDomainIdentifier, cContextMappingLicenseGroupDataGroup=cContextMappingLicenseGroupDataGroup, cContextMappingMIBConformance=cContextMappingMIBConformance, cContextMappingBridgeInstanceTable=cContextMappingBridgeInstanceTable, cContextMappingBridgeInstRowStatus=cContextMappingBridgeInstRowStatus, cContextMappingDataGroup=cContextMappingDataGroup, cContextMappingLicenseGroupName=cContextMappingLicenseGroupName, ciscoContextMappingMIB=ciscoContextMappingMIB, cContextMappingTopologyName=cContextMappingTopologyName, cContextMappingLicenseGroupEntry=cContextMappingLicenseGroupEntry, cContextMappingProtoInstName=cContextMappingProtoInstName, cContextMappingBridgeInstanceDataGroup=cContextMappingBridgeInstanceDataGroup, cContextMappingMIBCompliance=cContextMappingMIBCompliance, cContextMappingBridgeInstStorageType=cContextMappingBridgeInstStorageType, cContextMappingVrfName=cContextMappingVrfName, cContextMappingTable=cContextMappingTable, cContextMappingRowStatus=cContextMappingRowStatus, cContextMappingEntry=cContextMappingEntry, cContextMappingBridgeInstName=cContextMappingBridgeInstName, cContextMappingMIBGroups=cContextMappingMIBGroups, cContextMappingLicenseGroupStorageType=cContextMappingLicenseGroupStorageType)

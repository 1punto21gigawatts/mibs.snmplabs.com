#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
Unsigned32, StorageType, Counter32, RowStatus, DisplayString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Unsigned32", "StorageType", "Counter32", "RowStatus", "DisplayString")
Link, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "Link", "NonReplicated")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
mscSigChanIndex, mscSigChan = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex", "mscSigChan")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Unsigned32, Bits, ObjectIdentity, iso, Gauge32, Counter32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Integer32, NotificationType, IpAddress, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Unsigned32", "Bits", "ObjectIdentity", "iso", "Gauge32", "Counter32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Integer32", "NotificationType", "IpAddress", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
vnetMcdnSigMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142))
mscSigChanMcdn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17))
mscSigChanMcdnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1), )
if mibBuilder.loadTexts: mscSigChanMcdnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanMcdn components.')
mscSigChanMcdnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanMcdn component.')
mscSigChanMcdnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanMcdn components. These components can be added and deleted.')
mscSigChanMcdnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanMcdnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnStorageType.setDescription('This variable represents the storage type value for the mscSigChanMcdn tables.')
mscSigChanMcdnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanMcdnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnIndex.setDescription('This variable represents the index for the mscSigChanMcdn tables.')
mscSigChanMcdnL2Table = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11), )
if mibBuilder.loadTexts: mscSigChanMcdnL2Table.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnL2Table.setDescription('This group specifies the provisionable layer 2 attributes of the Q.931 ITU-T protocol.')
mscSigChanMcdnL2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnL2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnL2Entry.setDescription('An entry in the mscSigChanMcdnL2Table.')
mscSigChanMcdnT23 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT23.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT23.setDescription('This attribute specifies the layer 2 enable request timer.')
mscSigChanMcdnT200 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT200.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT200.setDescription('This attribute specifies the maximum time between a layer 2 frame and its acknowledgment.')
mscSigChanMcdnN200 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnN200.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnN200.setDescription('This attribute specifies the maximum number of re-transmissions of a layer 2 frame.')
mscSigChanMcdnT203 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 40)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT203.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT203.setDescription('This attribute specifies the maximum time for which layer 2 frames may be absent. Expiry triggers a check on whether the far end is alive.')
mscSigChanMcdnCircuitSwitchedK = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnCircuitSwitchedK.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnCircuitSwitchedK.setDescription('This attribute specifies the maximum number of sequentially numbered I frames (that is, window size (k)) that may be unacknowledged at any given time for a SAP supporting primary rate (64kbit/sec) signalling.')
mscSigChanMcdnL3Table = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12), )
if mibBuilder.loadTexts: mscSigChanMcdnL3Table.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnL3Table.setDescription('This group represents the provisionable Layer 3 timer attributes of the MCDN signalling protocol.')
mscSigChanMcdnL3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnL3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnL3Entry.setDescription('An entry in the mscSigChanMcdnL3Table.')
mscSigChanMcdnT302 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT302.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT302.setDescription('This attribute specifies the overlap receiving timer; in a UNI, this is network to user, but for Peer to Peer it is all incoming calls. This attribute is ignored if overlap signalling is disabled.')
mscSigChanMcdnT304 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 30)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT304.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT304.setDescription('This attribute specifies the overlap sending timer; in a UNI, this is user to network, but for Peer to Peer it is all outgoing calls. This attribute is ignored if overlap signalling is disabled.')
mscSigChanMcdnT309 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 120)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT309.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT309.setDescription('This attribute specifies the data link disconnect timer; used to ride out temporary failures.')
mscSigChanMcdnT310 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT310.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT310.setDescription('This attribute specifies the call proceeding state timer.')
mscSigChanMcdnT316 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(31, 180)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnT316.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT316.setDescription('This attribute specifies the restart request response timer. It must be set greater than t317.')
mscSigChanMcdnT317 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 179)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnT317.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnT317.setDescription('This attribute specifies the restart operation timer, used when a RESTART was received.')
mscSigChanMcdnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13), )
if mibBuilder.loadTexts: mscSigChanMcdnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnProvTable.setDescription('This group defines the general options of the D-channel signalling link.')
mscSigChanMcdnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnProvEntry.setDescription('An entry in the mscSigChanMcdnProvTable.')
mscSigChanMcdnSide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("user", 2))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnSide.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnSide.setDescription('This attribute specifies whether the interface provides layer 2 and 3 services equivalent to the ITU-T network or user side of the connection. If this attribute is set to network, then the interface is master during channel negotiation, and uses network side layer 2 command/response bits. If this attribute is set to user, then the interface is slave during channel negotiation, and uses user side layer 2 command/response bits. Note that although a peer to peer protocol has no true network or user side, for channel negotiation and layer 2 handling the peer to peer and UNI protocols have identical function. A true UNI may also have uni-directional messages and/or message elements; the peer to peer has all elements bidirectional.')
mscSigChanMcdnMaxNonCallConcurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnMaxNonCallConcurrent.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnMaxNonCallConcurrent.setDescription('This attribute specifies the maximum number of simultaneous active non-call transactions that are allowed.')
mscSigChanMcdnOverlapSending = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnOverlapSending.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnOverlapSending.setDescription('This attribute specifies whether overlap sending to the PBX is enabled.')
mscSigChanMcdnOverlapReceiving = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnOverlapReceiving.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnOverlapReceiving.setDescription('This attribute specifies whether overlap receiving from the PBX is enabled.')
mscSigChanMcdnChanMaintenanceHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("globalOnStartup", 0), ("serviceMessage", 1), ("restartMessage", 2))).clone('restartMessage')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnChanMaintenanceHandling.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnChanMaintenanceHandling.setDescription('This attribute specifies handling of channel maintenance events such as locking and unlocking a channel or channel registration on start-up. The decision here is whether to send individual channel RESTART messages, SERVICE messages, or nothing. Note that channel registration only occurs after the global interface restart at startup. The attribute controls start-up handling absolutely, and channel lock and unlock conditionally. That is, setting this to enable SERVICE messages ensures SERVICE messages at start-up and whenever a channel goes into or out of service. However, if this is not set to enable SERVICE messaging, a RESTART is always sent on unlocking a channel. globalOnStartup provides the minimum required function at start- up, without any individual channel confirmation. Note that when this is set, channel RESTART is still used for channel unlock. globalOnStartup applies to SigChan start-up only. serviceMessage enables sending and receiving SERVICE messages. If enabled, SERVICE messages are always used for channel maintenance on channel lock, channel unlock and start-up. restartMessage provides individual channel RESTARTs when a SigChan starts up. If enabled, the RESTART is used at start-up and channel unlock. However, if both SERVICE and RESTART messages are disabled, the RESTART will still be used when a channel unlocks.')
mscSigChanMcdnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 14), )
if mibBuilder.loadTexts: mscSigChanMcdnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscSigChanMcdnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnStateEntry.setDescription('An entry in the mscSigChanMcdnStateTable.')
mscSigChanMcdnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscSigChanMcdnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscSigChanMcdnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscSigChanMcdnStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15), )
if mibBuilder.loadTexts: mscSigChanMcdnStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnStatsTable.setDescription('This group provides the operational components for the McdnSig component.')
mscSigChanMcdnStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnStatsEntry.setDescription('An entry in the mscSigChanMcdnStatsTable.')
mscSigChanMcdnTotalCallsToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnTotalCallsToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnTotalCallsToIf.setDescription('This attribute counts the total number of calls that have been made to the interface. The value wraps when it reaches its maximum.')
mscSigChanMcdnTotalCallsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnTotalCallsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnTotalCallsFromIf.setDescription('This attribute counts the total number of calls from the interface. The value wraps when it reaches its maximum.')
mscSigChanMcdnNonCallAssocSessionsToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnNonCallAssocSessionsToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnNonCallAssocSessionsToIf.setDescription('This attribute counts the total number of non-call associated sessions to the interface. The value wraps when it reaches its maximum.')
mscSigChanMcdnNonCallAssocSessionsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnNonCallAssocSessionsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnNonCallAssocSessionsFromIf.setDescription('This attribute counts the total number of non-call associated sessions from the interface. The value wraps when it reaches its maximum.')
mscSigChanMcdnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16), )
if mibBuilder.loadTexts: mscSigChanMcdnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnOperTable.setDescription('This group provides the operational attributes for the MCDN signalling.')
mscSigChanMcdnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnOperEntry.setDescription('An entry in the mscSigChanMcdnOperTable.')
mscSigChanMcdnActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnActiveChannels.setDescription('This attribute indicates the number of currently active channels. This includes data and voice channels.')
mscSigChanMcdnActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnActiveVoiceChannels.setDescription('This attribute indicates the number of channels that are currently carrying voice.')
mscSigChanMcdnActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnActiveDataChannels.setDescription('This attribute indicates the number of channels that are currently carrying data. This does not include modem data.')
mscSigChanMcdnPeakActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveChannels.setDescription('This attribute indicates the maximum number of channels that have been active on this signalling channel during the last polling period.')
mscSigChanMcdnPeakActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveVoiceChannels.setDescription('This attribute indicates the maximum number of voice channels that have been active on this signalling channel during the last polling period.')
mscSigChanMcdnPeakActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnPeakActiveDataChannels.setDescription('This attribute indicates the maximum number of data channels that have been active on this signalling channel during the last polling period.')
mscSigChanMcdnDChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("outOfService", 0), ("establishing", 1), ("established", 2), ("enabling", 3), ("inService", 4), ("restarting", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnDChanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnDChanStatus.setDescription('This attribute indicates the state of the D-channel. outOfService means that there is no layer 2 or layer 3 connectivity to the PBX. establishing means that the signalling channel is attempting to stage the layer 2. established means that the layer 2 is enabled. If the signalling channel stays in the established state, then it is waiting for a restart from the PBX. enabling means that the resources for processing calls are being initialized. If the signalling channel stays in the enabling state then it is waiting for a restart acknowledgement from the PBX. inService means that the resources for processing calls are available. restarting means that the resources for call processing are being rei- initialized.')
mscSigChanMcdnToolsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 17), )
if mibBuilder.loadTexts: mscSigChanMcdnToolsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnToolsTable.setDescription('This contains a series of operational attributes which turn on and off several kinds of tracing.')
mscSigChanMcdnToolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnToolsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnToolsEntry.setDescription('An entry in the mscSigChanMcdnToolsTable.')
mscSigChanMcdnTracing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 17, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnTracing.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnTracing.setDescription('This attribute defines which types of tracing are active for this signalling channel. The tracing messages are sent to the debug stream. To see the messages the agentQueue attribute in Col/debug must be greater than 0 and a Telnet NMIS session must list the debug stream in in its data streams (ex. set nmis telnet session/1 dataStreams debug). Different types of tracing can be enabled simultaneously. Note that tracing consumes additional CPU resources and will slow down call processing on a heavily loaded card. If there is message block exhaustion tracing will be suspended for a period and then automatically reenabled. An alarm is generated on tracing suspension and resumption. This mechanism protects the function processor against excessive numbers of tracing messages. Types of tracing include: protocolErrors - get details of any protocol errors which are occuring. Protocol errors are also reported in summary form as alarms. q931Summary - Summary of the Q.931 messages on the signalling link, including certain call details (calling number, called number, release codes). q931Hex - Q.931 messages displayed in hex format. Useful to determine protocol compliance in case of errors reported on local or remote ends. q931Symbolic - Q.931 messages parsed to give maximum detail. Useful for understanding content of messages flowing on the link. portHex - Messages in hex format being sent and received on the link. Description of bits: protocolErrors(0) q931Summary(1) q931Hex(2) q931Symbolic(3) portHex(4)')
mscSigChanMcdnMessageTraced = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 17, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="ffffff80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnMessageTraced.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnMessageTraced.setDescription('This attribute specifies the type of ISDN messages that are to be traced. Description of bits: alerting(0) callProceeding(1) connectionlessFacility(2) congestionControl(3) connect(4) connectAcknowledge(5) disconnect(6) facility(7) facilityAcknowledge(8) facilityReject(9) information(10) notify(11) progress(12) register(13) releaseComp(14) release(15) restart(16) restartAcknowledge(17) service(18) serviceAcknowledge(19) setup(20) setupAcknowledge(21) status(22) statusEnquiry(23) userInformation(24) all(25)')
mscSigChanMcdnDirectionTraced = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 17, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnDirectionTraced.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnDirectionTraced.setDescription('This attribute indicates whether the incoming (from PBX), outgoing (to PBX), or both incoming and outgoing messages are traced. Description of bits: incoming(0) outgoing(1)')
mscSigChanMcdnClsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 18), )
if mibBuilder.loadTexts: mscSigChanMcdnClsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnClsTable.setDescription('This group enables and disables the support of the MCDN proprietary signalling for connectionless features on the local signalling channel.')
mscSigChanMcdnClsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnClsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnClsEntry.setDescription('An entry in the mscSigChanMcdnClsTable.')
mscSigChanMcdnClsFeaturesSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 18, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="ffc1")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnClsFeaturesSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnClsFeaturesSupported.setDescription("This attribute specifies the features to be supported by MCDN 'TCAP' connectionless messaging. Note that some features such as Network ACD combine connectionless and connection oriented. In the NACD case, the connectionless messaging enables the source and target PBXs to establish the networked relationship, and calls sent across the network (connection oriented) will contain basic information relating the call to the feature. Feature Definitions: networkAcd: transfer of a call from a pool of agents to a second pool of agents across the network. networkMessageService: message waiting capability (for example, lamps on sets). Also includes signalling for voice mail, but is not limited to voice mail. networkVoiceMail: a specific subset of Network Message Service, separated functionally as it always terminates on an interactive voice response mailbox application. networkRingAgain: ring again to remote sets. electronicLock: change of set capabilities by a remote user dialling the applicable code and password. remoteCallForward: call forwarding a phone via applicable code and password. callPickupNetworkWide (call pickup world wide): scan for a ringing call on another node, to enable the scanning set to pick up the call. networkPackage1: a collection of other features including but not limited to network clock synchronization. Note that on the Meridian 1, this is a general purpose group used for very small features not requiring a new ISDN Facility feature type. isdnApplicationInterface: network wide support of a number of Meridian 1 Application Module Link features. mobilityMultisiteNetworking: the capability to use a wireless phone in multiple sites, by having the phone register on arrival at the new site, and having the PBX at the new site negotiate the set 'relocation' with the base PBX. miscellaneous: Any feature that is not listed above. Description of bits: networkAcd(0) networkMessageService(1) networkRingAgain(2) networkVoiceMail(3) electronicLock(4) remoteCallForward(5) callPickupWorldWide(6) networkPackage1(7) isdnApplicationInterface(8) mobilityMultisiteNetworking(9) notused10(10) notused11(11) notused12(12) notused13(13) notused14(14) miscellaneous(15)")
mscSigChanMcdnCoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19), )
if mibBuilder.loadTexts: mscSigChanMcdnCoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnCoTable.setDescription('This group enables and disables the support of the MCDN proprietary signalling for the listed features on the local signalling channel.')
mscSigChanMcdnCoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnCoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnCoEntry.setDescription('An entry in the mscSigChanMcdnCoTable.')
mscSigChanMcdnDropBackCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noDropBackAllowed", 0), ("dropBackToOriginator", 1), ("dropBackToPriorNode", 2))).clone('dropBackToOriginator')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnDropBackCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnDropBackCongestion.setDescription('This attribute specifies if the Meridian 1 Drop Back Congestion Handling for trunks is enabled, and what type is being supported.')
mscSigChanMcdnNetworkNameDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnNetworkNameDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnNetworkNameDisplay.setDescription('This attribute specifies what Name Display is supported. nd1 corresponds to the Meridian 1 RCAP (Remote CAPability) nd1. This translates as caller provides name info in SETUP, ringing party name in ALERTING, redirection name in NOTIFY, and answering party name in CONNECT (as applicable, and if the name changes). nd2 corresponds to the Meridian 1 RCAP (Remote CAPability) nd2. This translates as caller provides name info in SETUP, answering party provides name in NOTIFY on answer. nd3 corresponds to the Meridian 1 RCAP (Remote CAPability) nd3, which is nd1 plus name information in call clearing messages (busy user, etc.) where a specific user was found but either could not answer or cleared the call. This corresponds to the QSIG name display. Description of bits: nameDisplay1(0) nameDisplay2(1) nameDisplay3(2)')
mscSigChanMcdnMultisiteBusinessGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transport", 0), ("discard", 1))).clone('transport')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnMultisiteBusinessGroup.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnMultisiteBusinessGroup.setDescription("This attribute specifies whether to enable transport for the Meridian 1 Multisite Business Group IE. The Meridian 1 allows multiple 'Tenants' to exist on a single PBX. These Tenants have limited access to each other and to system resources. That is, users associated with 'Tenant group one' cannot use trunks, attendants, and features from another group, and so forth. The Multi-Site Business Group is a single Tenant existing on more than one PBX. As an example, 'tenant one' on a PBX may 'own' resources belonging to 'tenant one' on another PBX. The Multi-Site Business Group IE as used in the Meridian 1 Network Tenant Services feature enables linking the two tenants together.")
mscSigChanMcdnConOrFeaturesSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 19, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="fff8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnConOrFeaturesSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnConOrFeaturesSupported.setDescription("This attribute indicates the features to be supported by MCDN 'ROSE' connection oriented messaging. Feature Definitions: networkAttendantService: network wide support of Attendant ('operator') services. classOfServiceTransport: this is not a ROSE feature. Class of Service transport takes place in the called party number when provisioned on the Meridian 1 to use an ESN signalling type. trunkRouteOptimization: dropping of redundant links in a call, when a set call forwards a call prior to answer. remoteVirtualQueuing: queuing at a remote node without requiring a B channel to be kept up. offHookQueuing: Queuing by maintaining the speech path to the queuing node. networkCallTrace: call progress tracing across a network (that is, call reached node a, node b, terminated at c,...). networkIntercom: network wide access to an intercom system onm a Meridian 1. callPickupNetworkWide: connection oriented messages associated with the TCAP call pickup scan operation. The messages that actually pick up the ringing call. radioPaging: access to a radio paging system network wide, allowing single radio paging facilities in a relatively dense local PBX network. networkAccess: information to enable access to PBX features from outside the network. Additional data is provided to identify access capabilities for a spoecific call. (Similar to transmittiong authorization code capabilities network wide.) antiTromboning: actually includes two capabilities - NAS (Network Attendant Setvice) and Trunk Anti-Tromboning. Calls that exit the subnet to a PBX and are transferred back to a network number via the same D channel can be optimized. If PBX A (Passport A) calls across the subnet to Passport B, D channel Z, to PBX B, and PBX B transfers across D channel Z to Passport B and therefore to PBX C/Passport C, this allows tha call to simplify to PBX/Passport A to PBX/Passport C. miscellaneous: Any feature that is not listed above. Description of bits: networkAttendantService(0) classOfServiceTransport(1) trunkRouteOptimization(2) remoteVirtualQueuing(3) networkCallId(4) offHookQueuing(5) networkCallTrace(6) networkIntercom(7) callPickupNetworkWide(8) radioPaging(9) networkAccess(10) antiTromboning(11) miscellaneous(12)")
mscSigChanMcdnFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2))
mscSigChanMcdnFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1), )
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanMcdnFramer components.')
mscSigChanMcdnFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanMcdnFramer component.')
mscSigChanMcdnFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanMcdnFramer components. These components cannot be added nor deleted.')
mscSigChanMcdnFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanMcdnFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerStorageType.setDescription('This variable represents the storage type value for the mscSigChanMcdnFramer tables.')
mscSigChanMcdnFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanMcdnFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerIndex.setDescription('This variable represents the index for the mscSigChanMcdnFramer tables.')
mscSigChanMcdnFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 10), )
if mibBuilder.loadTexts: mscSigChanMcdnFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscSigChanMcdnFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerProvEntry.setDescription('An entry in the mscSigChanMcdnFramerProvTable.')
mscSigChanMcdnFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanMcdnFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscSigChanMcdnFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 12), )
if mibBuilder.loadTexts: mscSigChanMcdnFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscSigChanMcdnFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerStateEntry.setDescription('An entry in the mscSigChanMcdnFramerStateTable.')
mscSigChanMcdnFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscSigChanMcdnFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscSigChanMcdnFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscSigChanMcdnFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13), )
if mibBuilder.loadTexts: mscSigChanMcdnFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscSigChanMcdnFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", "mscSigChanMcdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanMcdnFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerStatsEntry.setDescription('An entry in the mscSigChanMcdnFramerStatsTable.')
mscSigChanMcdnFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerFrmToIf.setDescription('This attribute counts the number of frames transmitted to the link interface by Framer. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerFrmFromIf.setDescription('This attribute counts the number of frames received from the link interface by Framer. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerOctetFromIf.setDescription('This attribute counts the number of bytes received from the link interface by Framer. This count wraps to zero when it exceeds its maximum value.')
mscSigChanMcdnFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerAborts.setDescription('This attribute counts the total number of aborts received. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerCrcErrors.setDescription('This attribute counts the total number of frames with CRC errors. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerLrcErrors.setDescription('This attribute counts the total number of frames with LRC errors. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerNonOctetErrors.setDescription('This attribute counts the total number of frames that were non octet aligned. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerOverruns.setDescription('This attribute counts the total number of frames received from the link for which overruns occurred. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerUnderruns.setDescription('This attribute counts the total number of frames transmitted to the link for which underruns occurred. This count wraps to zero after reaching its maximum value.')
mscSigChanMcdnFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 17, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanMcdnFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanMcdnFramerLargeFrmErrors.setDescription('This attribute counts the total number of frames received which were too large (longer than 500 bytes). This count wraps to zero after reaching its maximum value.')
vnetMcdnSigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 1))
vnetMcdnSigGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 1, 1))
vnetMcdnSigGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 1, 1, 3))
vnetMcdnSigGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 1, 1, 3, 2))
vnetMcdnSigCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 3))
vnetMcdnSigCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 3, 1))
vnetMcdnSigCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 3, 1, 3))
vnetMcdnSigCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 142, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VnetMcdnSigMIB", vnetMcdnSigGroupCA02=vnetMcdnSigGroupCA02, mscSigChanMcdnFramerLargeFrmErrors=mscSigChanMcdnFramerLargeFrmErrors, mscSigChanMcdnNonCallAssocSessionsToIf=mscSigChanMcdnNonCallAssocSessionsToIf, mscSigChanMcdnCircuitSwitchedK=mscSigChanMcdnCircuitSwitchedK, mscSigChanMcdnConOrFeaturesSupported=mscSigChanMcdnConOrFeaturesSupported, mscSigChanMcdnActiveDataChannels=mscSigChanMcdnActiveDataChannels, vnetMcdnSigGroupCA02A=vnetMcdnSigGroupCA02A, mscSigChanMcdnDirectionTraced=mscSigChanMcdnDirectionTraced, mscSigChanMcdnFramerFrmToIf=mscSigChanMcdnFramerFrmToIf, mscSigChanMcdnT316=mscSigChanMcdnT316, mscSigChanMcdnActiveChannels=mscSigChanMcdnActiveChannels, mscSigChanMcdnProvTable=mscSigChanMcdnProvTable, mscSigChanMcdnPeakActiveDataChannels=mscSigChanMcdnPeakActiveDataChannels, mscSigChanMcdnL3Entry=mscSigChanMcdnL3Entry, mscSigChanMcdnFramerIndex=mscSigChanMcdnFramerIndex, mscSigChanMcdnCoEntry=mscSigChanMcdnCoEntry, mscSigChanMcdnToolsTable=mscSigChanMcdnToolsTable, vnetMcdnSigCapabilitiesCA02A=vnetMcdnSigCapabilitiesCA02A, mscSigChanMcdnFramerStatsEntry=mscSigChanMcdnFramerStatsEntry, mscSigChanMcdnFramer=mscSigChanMcdnFramer, mscSigChanMcdnT203=mscSigChanMcdnT203, mscSigChanMcdnStorageType=mscSigChanMcdnStorageType, mscSigChanMcdnT317=mscSigChanMcdnT317, mscSigChanMcdnOverlapSending=mscSigChanMcdnOverlapSending, mscSigChanMcdnFramerProvTable=mscSigChanMcdnFramerProvTable, mscSigChanMcdnFramerInterfaceName=mscSigChanMcdnFramerInterfaceName, vnetMcdnSigCapabilitiesCA02=vnetMcdnSigCapabilitiesCA02, mscSigChanMcdnN200=mscSigChanMcdnN200, vnetMcdnSigGroupCA=vnetMcdnSigGroupCA, mscSigChanMcdnNonCallAssocSessionsFromIf=mscSigChanMcdnNonCallAssocSessionsFromIf, mscSigChanMcdnFramerRowStatusTable=mscSigChanMcdnFramerRowStatusTable, mscSigChanMcdnNetworkNameDisplay=mscSigChanMcdnNetworkNameDisplay, mscSigChanMcdnFramerStateTable=mscSigChanMcdnFramerStateTable, mscSigChanMcdnT309=mscSigChanMcdnT309, vnetMcdnSigMIB=vnetMcdnSigMIB, mscSigChanMcdnSide=mscSigChanMcdnSide, vnetMcdnSigGroup=vnetMcdnSigGroup, mscSigChanMcdnTotalCallsToIf=mscSigChanMcdnTotalCallsToIf, mscSigChanMcdnT23=mscSigChanMcdnT23, mscSigChanMcdnRowStatus=mscSigChanMcdnRowStatus, mscSigChanMcdnL2Table=mscSigChanMcdnL2Table, mscSigChanMcdnL2Entry=mscSigChanMcdnL2Entry, mscSigChanMcdnToolsEntry=mscSigChanMcdnToolsEntry, mscSigChanMcdnFramerOctetFromIf=mscSigChanMcdnFramerOctetFromIf, mscSigChanMcdnDChanStatus=mscSigChanMcdnDChanStatus, mscSigChanMcdnProvEntry=mscSigChanMcdnProvEntry, mscSigChanMcdnL3Table=mscSigChanMcdnL3Table, mscSigChanMcdnFramerUnderruns=mscSigChanMcdnFramerUnderruns, mscSigChanMcdnOperationalState=mscSigChanMcdnOperationalState, mscSigChanMcdnClsTable=mscSigChanMcdnClsTable, mscSigChanMcdnFramerProvEntry=mscSigChanMcdnFramerProvEntry, mscSigChanMcdnFramerCrcErrors=mscSigChanMcdnFramerCrcErrors, mscSigChanMcdnFramerOverruns=mscSigChanMcdnFramerOverruns, mscSigChanMcdnClsEntry=mscSigChanMcdnClsEntry, mscSigChanMcdnFramerOperationalState=mscSigChanMcdnFramerOperationalState, mscSigChanMcdnFramerAborts=mscSigChanMcdnFramerAborts, mscSigChanMcdnOverlapReceiving=mscSigChanMcdnOverlapReceiving, mscSigChanMcdnFramerStatsTable=mscSigChanMcdnFramerStatsTable, mscSigChanMcdn=mscSigChanMcdn, mscSigChanMcdnFramerRowStatusEntry=mscSigChanMcdnFramerRowStatusEntry, mscSigChanMcdnT302=mscSigChanMcdnT302, mscSigChanMcdnFramerComponentName=mscSigChanMcdnFramerComponentName, vnetMcdnSigCapabilitiesCA=vnetMcdnSigCapabilitiesCA, mscSigChanMcdnFramerAdminState=mscSigChanMcdnFramerAdminState, mscSigChanMcdnT200=mscSigChanMcdnT200, mscSigChanMcdnMaxNonCallConcurrent=mscSigChanMcdnMaxNonCallConcurrent, mscSigChanMcdnAdminState=mscSigChanMcdnAdminState, mscSigChanMcdnStateTable=mscSigChanMcdnStateTable, mscSigChanMcdnChanMaintenanceHandling=mscSigChanMcdnChanMaintenanceHandling, mscSigChanMcdnTracing=mscSigChanMcdnTracing, mscSigChanMcdnPeakActiveChannels=mscSigChanMcdnPeakActiveChannels, mscSigChanMcdnT310=mscSigChanMcdnT310, mscSigChanMcdnFramerUsageState=mscSigChanMcdnFramerUsageState, mscSigChanMcdnFramerRowStatus=mscSigChanMcdnFramerRowStatus, mscSigChanMcdnComponentName=mscSigChanMcdnComponentName, mscSigChanMcdnMultisiteBusinessGroup=mscSigChanMcdnMultisiteBusinessGroup, vnetMcdnSigCapabilities=vnetMcdnSigCapabilities, mscSigChanMcdnCoTable=mscSigChanMcdnCoTable, mscSigChanMcdnMessageTraced=mscSigChanMcdnMessageTraced, mscSigChanMcdnClsFeaturesSupported=mscSigChanMcdnClsFeaturesSupported, mscSigChanMcdnUsageState=mscSigChanMcdnUsageState, mscSigChanMcdnPeakActiveVoiceChannels=mscSigChanMcdnPeakActiveVoiceChannels, mscSigChanMcdnFramerLrcErrors=mscSigChanMcdnFramerLrcErrors, mscSigChanMcdnDropBackCongestion=mscSigChanMcdnDropBackCongestion, mscSigChanMcdnFramerNonOctetErrors=mscSigChanMcdnFramerNonOctetErrors, mscSigChanMcdnTotalCallsFromIf=mscSigChanMcdnTotalCallsFromIf, mscSigChanMcdnFramerFrmFromIf=mscSigChanMcdnFramerFrmFromIf, mscSigChanMcdnIndex=mscSigChanMcdnIndex, mscSigChanMcdnT304=mscSigChanMcdnT304, mscSigChanMcdnActiveVoiceChannels=mscSigChanMcdnActiveVoiceChannels, mscSigChanMcdnRowStatusEntry=mscSigChanMcdnRowStatusEntry, mscSigChanMcdnStatsTable=mscSigChanMcdnStatsTable, mscSigChanMcdnOperEntry=mscSigChanMcdnOperEntry, mscSigChanMcdnOperTable=mscSigChanMcdnOperTable, mscSigChanMcdnRowStatusTable=mscSigChanMcdnRowStatusTable, mscSigChanMcdnFramerStateEntry=mscSigChanMcdnFramerStateEntry, mscSigChanMcdnStateEntry=mscSigChanMcdnStateEntry, mscSigChanMcdnStatsEntry=mscSigChanMcdnStatsEntry, mscSigChanMcdnFramerStorageType=mscSigChanMcdnFramerStorageType)

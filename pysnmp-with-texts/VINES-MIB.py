#
# PySNMP MIB module VINES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/VINES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:34:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Integer32, ObjectIdentity, Gauge32, IpAddress, Counter32, NotificationType, iso, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter64, enterprises, NotificationType, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "ObjectIdentity", "Gauge32", "IpAddress", "Counter32", "NotificationType", "iso", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter64", "enterprises", "NotificationType", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
banyan = MibIdentifier((1, 3, 6, 1, 4, 1, 130))
vinesmibs = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1))
mib1 = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 1))
mib2 = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2))
systemsummary = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 1))
services = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 2))
peripherals = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 3))
filesystem = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 4))
commresources = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 5))
vip = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 6))
vrtp = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 7))
vspp = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 8))
vinterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 9))
os = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 10))
ossysstats = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1))
osinfo = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2))
ossummstats = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3))
nmthresholds = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 11))
trapdata = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 12))
ams = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 13))
mailservice = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 14))
vlogs = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 1, 2, 15))
ssName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssName.setStatus('mandatory')
if mibBuilder.loadTexts: ssName.setDescription('The StreetTalk name of the server, up to 15 characters long.')
ssNetid = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ssNetid.setDescription("The VINES network ID of the server, which is equal to the server's serial number. This ID may be up to 4 bytes in length.")
ssSwRev = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSwRev.setStatus('mandatory')
if mibBuilder.loadTexts: ssSwRev.setDescription('The VINES software revision for this server.')
ssLoadAvg1 = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssLoadAvg1.setStatus('mandatory')
if mibBuilder.loadTexts: ssLoadAvg1.setDescription('The one minute exponential decaying average of server load.')
ssLoadAvg5 = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssLoadAvg5.setStatus('mandatory')
if mibBuilder.loadTexts: ssLoadAvg5.setDescription('The five minute exponential decaying average of server load.')
ssLoadAvg15 = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssLoadAvg15.setStatus('mandatory')
if mibBuilder.loadTexts: ssLoadAvg15.setDescription('The 15 minute exponential decaying average of server load.')
ssMsgAvg1 = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssMsgAvg1.setStatus('mandatory')
if mibBuilder.loadTexts: ssMsgAvg1.setDescription('The one minute exponential decaying average of network messages sent and received per second.')
ssMsgsIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssMsgsIn.setStatus('mandatory')
if mibBuilder.loadTexts: ssMsgsIn.setDescription('The total number of network messages that the server has received over the network since the last reboot.')
ssMsgsOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssMsgsOut.setStatus('mandatory')
if mibBuilder.loadTexts: ssMsgsOut.setDescription('The total number of network messages that the server has sent over the network since the last reboot.')
ssDrops = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssDrops.setStatus('mandatory')
if mibBuilder.loadTexts: ssDrops.setDescription('The total number of received messages that could not be processed due to a lack of communications buffer space.')
ssSwapAvg = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSwapAvg.setStatus('mandatory')
if mibBuilder.loadTexts: ssSwapAvg.setDescription('An exponential decaying average of the number of times a process was swapped to or from disk per second over a one minute period.')
ssProcType = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("i386", 2), ("i486", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssProcType.setStatus('mandatory')
if mibBuilder.loadTexts: ssProcType.setDescription('The type of the processor.')
ssProdType = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unused", 1), ("cns", 2), ("pcvines", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssProdType.setStatus('mandatory')
if mibBuilder.loadTexts: ssProdType.setDescription('The type of banyan product.')
ssProdDescr = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssProdDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ssProdDescr.setDescription('The description of the product type.')
ssRealMemory = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssRealMemory.setStatus('mandatory')
if mibBuilder.loadTexts: ssRealMemory.setDescription('The total amount of RAM, in kilobytes, configured in the server.')
ssOsType = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("unixsystemv", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssOsType.setStatus('mandatory')
if mibBuilder.loadTexts: ssOsType.setDescription('The type of server OS. UNIX is the only operating system supported.')
ssOsRev = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssOsRev.setStatus('mandatory')
if mibBuilder.loadTexts: ssOsRev.setDescription('The operating system version.')
ssSystemUptime = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 18), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSystemUptime.setStatus('mandatory')
if mibBuilder.loadTexts: ssSystemUptime.setDescription('The amount time since this host was last initialized. Note that this is different from sysUpTime because sysUpTime is the uptime of the network management portion of the system.')
ssSystemDate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSystemDate.setStatus('mandatory')
if mibBuilder.loadTexts: ssSystemDate.setDescription('The current time on the server.')
ssSystemStatus = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("running", 1), ("shutdown", 2), ("reboot", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ssSystemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ssSystemStatus.setDescription('The status of the server. When the server is initialized this field will get set to running. When a shutdown is requested the server will shutdown all services and await a manual reboot. A reboot request will shut down all services and automatically reboot the machine.')
ssUserLicenseCfg = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssUserLicenseCfg.setStatus('mandatory')
if mibBuilder.loadTexts: ssUserLicenseCfg.setDescription('The user limit license for this server.')
svcNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcNumber.setStatus('mandatory')
if mibBuilder.loadTexts: svcNumber.setDescription('The number of services in the svcTable.')
svcTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2), )
if mibBuilder.loadTexts: svcTable.setStatus('mandatory')
if mibBuilder.loadTexts: svcTable.setDescription('A list of services on the server.')
svcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1), ).setIndexNames((0, "VINES-MIB", "svcIndex"))
if mibBuilder.loadTexts: svcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: svcEntry.setDescription('Each entry contains a set of statistics for one service.')
svcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcIndex.setDescription('A unique value for each service used by SNMP to keep track of service table entries. This value may vary if the table changes.')
svcName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcName.setStatus('mandatory')
if mibBuilder.loadTexts: svcName.setDescription("The StreetTalk name of the service, the names are of the form 'item@group@organization'.")
svcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("running", 1), ("initializing", 2), ("crashing", 3), ("inconsistent", 4), ("stopped", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: svcStatus.setDescription('The status of the service. Running - available to users. Initializing - starting and will be available shortly. Crashing - not functioning properly. Inconsistent - the name cannot be found. Stopped - not running. Only running and stopped are valid for sets.')
svcUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: svcUpTime.setDescription('The amount of time that the service has been running.')
svcMsgsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcMsgsIn.setStatus('mandatory')
if mibBuilder.loadTexts: svcMsgsIn.setDescription('The total number of messages that the service has received over the network since the service was last started.')
svcMsgsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcMsgsOut.setStatus('mandatory')
if mibBuilder.loadTexts: svcMsgsOut.setDescription('The total number of messages that the service has sent over the network since the service was last started.')
svcLocIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcLocIn.setStatus('mandatory')
if mibBuilder.loadTexts: svcLocIn.setDescription("The number of messages received by the service that were sent by entities that are local to the service's server since the service was last started.")
svcLocOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcLocOut.setStatus('mandatory')
if mibBuilder.loadTexts: svcLocOut.setDescription("The number of messages sent by the service to entities that are local to the service's server since the service was last started.")
svcActSess = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcActSess.setStatus('mandatory')
if mibBuilder.loadTexts: svcActSess.setDescription('The number of active sessions with the service.')
svcTotSess = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcTotSess.setStatus('mandatory')
if mibBuilder.loadTexts: svcTotSess.setDescription('The total number of sessions that the service has handled since it was last started.')
svcCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcCategory.setStatus('mandatory')
if mibBuilder.loadTexts: svcCategory.setDescription('The type of service defined as follows: 1 Server Service 2 File Service or DOS/UNIX bridge file service 3 Print Service 4 Mail Service 5 StreetTalk Service 6 Time 7 File Transfer Protocol (FTP) 8 Semaphore Service 9 System Network Architecture Service 10 Virtual Terminal Service 11 Asynchronous Terminal Service 12 Netbios Service 13 PC-Based Service 14 Bisynchronous Service 15 APPC Service(APPCCAT) 16 Network Management Service 17 VINES Security Service 18 StreetTalk Directory Assistance Service 19 AppleTalk Filing Protocol (AFP) 20 VINES Configuration Service 21 Event Management Service 22 Link Service 23 Backup Service 24 Unused 25 VINES Remote Service 26 Remote Execution Service 27 Tree Service 28 VINES Proxy Agent Service 29 WAN Configuration Service 30 AppleTalk Agent Service 31 Alert Management Service 32 Unused 33 Unused 34 Unused 35 Remote Program Load Service 36 StreetTalk Agent Service 37 NetWare Print Queue Service 38 NetWare Print Service 39 NetWare File Service 100 AdminList 1986 VINES Assistant Service 1888 SMTP Service Third-party services return values from 1000 to 1899.')
svcCpuTime = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcCpuTime.setStatus('mandatory')
if mibBuilder.loadTexts: svcCpuTime.setDescription('The amount of current CPU use that the service is generating.')
svcSize = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSize.setStatus('mandatory')
if mibBuilder.loadTexts: svcSize.setDescription('The amount of virtual memory that is allocated to the service.')
svcSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSockets.setStatus('mandatory')
if mibBuilder.loadTexts: svcSockets.setDescription('The number of VINES sockets that the service is currently consuming.')
svcSPPs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcSPPs.setStatus('mandatory')
if mibBuilder.loadTexts: svcSPPs.setDescription('The number of SPP connections that the service is currently consuming.')
svcLogMask = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("maskdef", 1), ("masklow", 2), ("maskmed", 3), ("maskhigh", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcLogMask.setStatus('mandatory')
if mibBuilder.loadTexts: svcLogMask.setDescription('The current log mask of a service.')
svcDiskName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 2, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcDiskName.setStatus('mandatory')
if mibBuilder.loadTexts: svcDiskName.setDescription('The location of the service.')
svcUserTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3), )
if mibBuilder.loadTexts: svcUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserTable.setDescription('A list of the users for the services.')
svcUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3, 1), ).setIndexNames((0, "VINES-MIB", "svcUserSvcIndex"), (0, "VINES-MIB", "svcUserIndex"))
if mibBuilder.loadTexts: svcUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserEntry.setDescription('An entry in the list of service users.')
svcUserSvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcUserSvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserSvcIndex.setDescription('A unique value for each service on the server, used by SNMP to order the list.')
svcUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcUserIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserIndex.setDescription('A unique value for each user of a service. This value will change as new users are added and old users deleted from the service.')
svcUserSvcName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcUserSvcName.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserSvcName.setDescription('The StreetTalk name of the service.')
svcUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 2, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcUserName.setStatus('mandatory')
if mibBuilder.loadTexts: svcUserName.setDescription('The StreetTalk name of the user of the service.')
dskNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dskNumber.setDescription('The number of disks in the disk table.')
dskTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2), )
if mibBuilder.loadTexts: dskTable.setStatus('mandatory')
if mibBuilder.loadTexts: dskTable.setDescription('A list of statistics for the disks on this server.')
dskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1), ).setIndexNames((0, "VINES-MIB", "dskIndex"))
if mibBuilder.loadTexts: dskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dskEntry.setDescription('The statistics for one disk.')
dskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dskIndex.setDescription('A unique value for each disk on the server, used by SNMP to order the table.')
dskName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskName.setStatus('mandatory')
if mibBuilder.loadTexts: dskName.setDescription('The name of the disk unit.')
dskUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 3), Integer32())
if mibBuilder.loadTexts: dskUtil.setStatus('mandatory')
if mibBuilder.loadTexts: dskUtil.setDescription('A five minute exponential decaying average showing the percentage of time that the disk unit was in use transferring data.')
dskDemand = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 4), Integer32())
if mibBuilder.loadTexts: dskDemand.setStatus('mandatory')
if mibBuilder.loadTexts: dskDemand.setDescription('A five minute exponential decaying average showing the percentage of time that the disk unit needed to be used to satisfy all requests.')
dskSizeMB = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskSizeMB.setStatus('mandatory')
if mibBuilder.loadTexts: dskSizeMB.setDescription('The size of the disk in megabytes.')
dskUsedPct = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskUsedPct.setStatus('mandatory')
if mibBuilder.loadTexts: dskUsedPct.setDescription('The percentage of disk space that is currently in use.')
dskStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dskStatus.setDescription('The disks status, 1 is non-operational, 2 is operational.')
dskNOperations = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskNOperations.setStatus('mandatory')
if mibBuilder.loadTexts: dskNOperations.setDescription('The total number of reads and writes for the disk since the server was last booted.')
dskNBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskNBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: dskNBlocks.setDescription('The total number of 1-kilobyte data blocks transferred to and from the disk since the server was last booted.')
dskResp = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskResp.setStatus('mandatory')
if mibBuilder.loadTexts: dskResp.setDescription('The total amount of time processes spent waiting for a response from the disks.')
dskActive = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskActive.setStatus('mandatory')
if mibBuilder.loadTexts: dskActive.setDescription('The total amount of the disk was active.')
dskBlkSize = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskBlkSize.setStatus('mandatory')
if mibBuilder.loadTexts: dskBlkSize.setDescription('The block size in megabytes.')
dskNMisc = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskNMisc.setStatus('mandatory')
if mibBuilder.loadTexts: dskNMisc.setDescription('The total number of miscellaneous disk operations since the server was last booted.')
dskNErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskNErrs.setStatus('mandatory')
if mibBuilder.loadTexts: dskNErrs.setDescription('The total number of disk errors that were not logged since the server was last booted.')
dskPctBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskPctBusy.setStatus('optional')
if mibBuilder.loadTexts: dskPctBusy.setDescription('A five minute exponential decaying average showing the percentage of time that the disk spent servicing data transfer requests.')
dskAvgWait = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskAvgWait.setStatus('optional')
if mibBuilder.loadTexts: dskAvgWait.setDescription('A five minute exponential decaying average showing the average amount of time that read and write requests waited on the request queue to be serviced.')
dskAvgService = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 3, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dskAvgService.setStatus('optional')
if mibBuilder.loadTexts: dskAvgService.setDescription('A five minute exponential decaying average showing the average amount of time that the disk took to service read and write requests.')
fsTotCache = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsTotCache.setStatus('mandatory')
if mibBuilder.loadTexts: fsTotCache.setDescription("The amount of server RAM, in kilobytes, that is used for caching purposes. This is configurable from the server's console. Note: The setting of this object will not take effect until the server is rebooted.")
fsCacheBufSize = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fsCacheBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: fsCacheBufSize.setDescription('The amount of server RAM, in kilobytes, that makes up a file system cache buffer. Also configurable from the console. Note: The setting of this object will not take effect until the server is rebooted.')
fsMaxOpenFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsMaxOpenFiles.setStatus('mandatory')
if mibBuilder.loadTexts: fsMaxOpenFiles.setDescription('The largest number of open files on the server at a single point in time.')
fsOpenFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsOpenFiles.setStatus('mandatory')
if mibBuilder.loadTexts: fsOpenFiles.setDescription('The number of files currently open.')
fsMaxOpensOnFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsMaxOpensOnFiles.setStatus('mandatory')
if mibBuilder.loadTexts: fsMaxOpensOnFiles.setDescription('The largest number of open operations on files at a single point in time. There can be more than one open operation on an open file. For example, two users may open the same file. This file would count as one open file and two open operations on the file.')
fsOpensOnFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsOpensOnFiles.setStatus('mandatory')
if mibBuilder.loadTexts: fsOpensOnFiles.setDescription('The current number of open operations on files.')
fsRecLocks = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsRecLocks.setStatus('mandatory')
if mibBuilder.loadTexts: fsRecLocks.setDescription('The current number of record locks.')
fsMaxRecLocks = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsMaxRecLocks.setStatus('mandatory')
if mibBuilder.loadTexts: fsMaxRecLocks.setDescription('The largest number of simultaneous record locks.')
fsPctCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsPctCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: fsPctCacheHits.setDescription('The percentage of cache buffer requests that the system was able to service using existing cache buffers, without reading new data from disk.')
fsCacheUnavail = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsCacheUnavail.setStatus('mandatory')
if mibBuilder.loadTexts: fsCacheUnavail.setDescription('The number of cache buffer requests that the server was unable to service without reading new data from disk.')
commTotBufs = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commTotBufs.setStatus('mandatory')
if mibBuilder.loadTexts: commTotBufs.setDescription("The total communications buffer space (the amount of server RAM used for network communications) in kilobytes. This is configurable from the server's console. Note: The setting of this object will not take effect until the servers is rebooted.")
commBufUsage = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commBufUsage.setStatus('mandatory')
if mibBuilder.loadTexts: commBufUsage.setDescription('The percentage of the communications buffer space currently in use.')
commAllocsFailed = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commAllocsFailed.setStatus('mandatory')
if mibBuilder.loadTexts: commAllocsFailed.setDescription('The cumulative total of the number of buffers that could not be allocated since the server was last booted.')
commSocksCfg = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commSocksCfg.setStatus('mandatory')
if mibBuilder.loadTexts: commSocksCfg.setDescription('The maximum number of sockets that can be open at one time. Configurable from the server console. Note: The setting of this object will not take effect until the servers is rebooted.')
commSocksInUse = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commSocksInUse.setStatus('mandatory')
if mibBuilder.loadTexts: commSocksInUse.setDescription('The percentage of the maximum configured sockets in use.')
commMaxOpenSocks = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commMaxOpenSocks.setStatus('mandatory')
if mibBuilder.loadTexts: commMaxOpenSocks.setDescription('The maximum number of sockets in use since the server was last booted.')
vipTotIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: vipTotIn.setDescription('The total number of VINES IP packets that the server has received since the server was last booted.')
vipTotOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: vipTotOut.setDescription('The total number of VINES IP packets that the server has sent since the server was last booted.')
vipBad = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipBad.setStatus('mandatory')
if mibBuilder.loadTexts: vipBad.setDescription('The number of packets that the server has received since the server was last booted that had an incorrect checksum.')
vipRouted = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipRouted.setStatus('mandatory')
if mibBuilder.loadTexts: vipRouted.setDescription('The total number of packets that were routed to another node since the server was last booted.')
vipRoutedHWM = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipRoutedHWM.setStatus('mandatory')
if mibBuilder.loadTexts: vipRoutedHWM.setDescription('The largest number of packets routed in 1 second since the server was last booted.')
vipBcast = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipBcast.setStatus('mandatory')
if mibBuilder.loadTexts: vipBcast.setDescription('The number of VINES IP broadcast packets sent, both generated from the server and routed from other nodes.')
vipBcastHWM = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipBcastHWM.setStatus('mandatory')
if mibBuilder.loadTexts: vipBcastHWM.setDescription('The largest number of packets broadcast in 1 second since the server was last booted.')
vipReass = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipReass.setStatus('mandatory')
if mibBuilder.loadTexts: vipReass.setDescription('The number of times packets were reassembled since the server was last booted. One VINES IP packet being broken into three message fragments is counted as one fragmentation. The three fragments being reassembled into one VINES IP packet counts as one reassembly.')
vipFrags = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipFrags.setStatus('mandatory')
if mibBuilder.loadTexts: vipFrags.setDescription('The number of packet fragmentations performed since the server was last booted.')
vipToDodIP = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipToDodIP.setStatus('mandatory')
if mibBuilder.loadTexts: vipToDodIP.setDescription('The number of packets that VINES IP passed to DARPA IP (TCP/IP) for encapsulation in IP headers since the server was last booted.')
vipFromDodIP = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipFromDodIP.setStatus('mandatory')
if mibBuilder.loadTexts: vipFromDodIP.setDescription('The number of packets that VINES IP received from DARPA IP (TCP/IP) since the server was last booted.')
vipInFragments = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipInFragments.setStatus('mandatory')
if mibBuilder.loadTexts: vipInFragments.setDescription('The number of fragments received since the server was last booted.')
vipTooSmall = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipTooSmall.setStatus('mandatory')
if mibBuilder.loadTexts: vipTooSmall.setDescription('The number of packets that the server has received since the server was last booted that were too small.')
vipBadLength = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipBadLength.setStatus('mandatory')
if mibBuilder.loadTexts: vipBadLength.setDescription('The number of packets that the server has received since the server was last booted that had an invalid packet length in the packet length field of the VINES IP header.')
vipNoBuffers = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 6, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vipNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: vipNoBuffers.setDescription('The number of packets that the server could not send, receive or route due to a lack of communication buffers since the server was last booted.')
vrtpNbrNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrNumber.setDescription('The number of entries in the neighbor table (NbrTable).')
vrtpNbrTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2), )
if mibBuilder.loadTexts: vrtpNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrTable.setDescription('A list of information about neighbors of this server.')
vrtpNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1), ).setIndexNames((0, "VINES-MIB", "vrtpNbrNetid"), (0, "VINES-MIB", "vrtpNbrSubNetid"), (0, "VINES-MIB", "vrtpNbrIfType"), (0, "VINES-MIB", "vrtpNbrLocSlot"), (0, "VINES-MIB", "vrtpNbrLocLine"))
if mibBuilder.loadTexts: vrtpNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrEntry.setDescription('The information for each entry in the table.')
vrtpNbrNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrNetid.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrNetid.setDescription("The network ID of the neighbor, which is the first part of the neighbor's VINES internet address. If the neighbor is a server the network number is the server's serial number.")
vrtpNbrSubNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrSubNetid.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrSubNetid.setDescription("The subnetwork ID of the neighbor, which is the second part of the neighbor's VINES internet address. If the neighbor is a server the subnetwork number is 1.")
vrtpNbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("server", 1), ("workstation", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrType.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrType.setDescription('The type of the neighbor (workstation = pc).')
vrtpNbrIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103))).clone(namedValues=NamedValues(("ethernet3Com", 1), ("ethernetNI5010", 2), ("ethernetBICC", 3), ("ethernetUB", 4), ("omninetCorvus", 5), ("arcnetSMC", 6), ("pcnetSytek", 7), ("proNetProteon", 8), ("frag", 9), ("prsystctrl", 10), ("hdlc", 11), ("blkAsync", 12), ("intersys", 13), ("x25EICON", 14), ("tokenRingIBM", 15), ("x25", 16), ("tokenRingUB", 17), ("ipaDavidSys", 18), ("tokenRingPronet4", 19), ("ethernetEplus3Com", 20), ("lanLinkNT", 21), ("ctrllerGanges", 22), ("ethernetNI5210", 23), ("ipTCPIP", 24), ("ipBanyan", 25), ("hdlcTCPIP", 26), ("starlanWDigital", 27), ("ethernetWDigital", 28), ("starlanATT", 29), ("starlanNI5210", 30), ("ethernet3Com3C503", 31), ("ethernet3Com3C523", 32), ("tokenRing3Com3C603", 33), ("lanLinkNTMC", 34), ("serialVGsystems", 35), ("ethernetIntelPC586E", 36), ("starlanATT10", 37), ("pronetProteonMC", 38), ("arcnetSMCMC", 39), ("tokenRingIBMMC", 40), ("ethernetNI9210MC", 41), ("ethernetICAMC", 42), ("pseudoIBM", 43), ("starlanATT10MC", 44), ("ps2UBNICMC", 45), ("llTurboNT", 46), ("tokenRingProteon", 47), ("ethernetNovellNE", 48), ("ctrlerDATACO", 49), ("hughes", 50), ("ethernetNDIS", 51), ("gatewayAPI", 52), ("tokenRingMadge", 53), ("ethernetIBMMC", 54), ("tokenRingIBMBM", 55), ("ethernetWDigitalMC", 56), ("interlanEISA", 57), ("ethernetBICC", 58), ("ethernetNT2R15", 59), ("ethernetNTMC", 60), ("ethernetNTTurbo", 61), ("tokenRingPronet", 62), ("tokenRingCompaq", 63), ("isoSvrSvr", 64), ("ethernetNovellNE3200", 65), ("ethernetPureData", 66), ("ethernetPureDataMC", 67), ("ethernetCabletron", 68), ("ftp", 69), ("arcnetNDIS", 70), ("tokenRingNDIS", 71), ("starlanATTEISA", 72), ("appleTalk", 73), ("localTalk", 74), ("etherLink3COM16", 75), ("interlanNI6510", 76), ("tokenRingProteonP1890", 77), ("ethernetBICCMC", 78), ("icaPlus", 79), ("ipNSRouting", 80), ("etherExpressIntel", 81), ("tokenRingOlicom", 82), ("tokenRingOlicomMC", 83), ("tokenRingOlicamEISA", 84), ("tokenExpressIntelISA", 85), ("tokenExpressIntelMC", 86), ("tokenExpressIntelEISA", 87), ("tokenRingIrmaTracPCAT", 88), ("tokenRingIrmaTracMCA", 89), ("ethernetDGCODE", 90), ("isdnBRIDatavoice", 91), ("wavelanNCR", 92), ("unused", 93), ("unused", 94), ("unused", 95), ("unused", 96), ("unused", 97), ("unused", 98), ("unused", 99), ("promptusT1", 100), ("promptusE1", 101), ("lapdT1", 102), ("isdnDchannel", 103)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrIfType.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrIfType.setDescription('The type of interface that the server uses to reach the neighbor.')
vrtpNbrRemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrRemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrRemAddress.setDescription("The address of the neighbor's physical interface, such as a LAN address. If the neighbor is connected via an HDLC or asynchronous line this object specifies an internal ID.")
vrtpNbrLocAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrLocAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrLocAddress.setDescription("The address of the server's physical interface, such as a LAN address.")
vrtpNbrLocSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrLocSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrLocSlot.setDescription('The slot number of the interface card that the server uses to reach the neighbor.')
vrtpNbrLocLine = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrLocLine.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpNbrLocLine.setDescription('The number of the line on the serial card that the server uses to reach the neighbor. It does not apply to neighbors that are reached over LANs.')
vrtpNbrSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrSvrName.setStatus('optional')
if mibBuilder.loadTexts: vrtpNbrSvrName.setDescription('The name of the neighbor. If the neighbor is a workstation then this object has no meaning.')
vrtpRtNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtNumber.setDescription('The number of entires in the route table (RtTable).')
vrtpRtTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4), )
if mibBuilder.loadTexts: vrtpRtTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtTable.setDescription('A list of networks and the routing information to find them.')
vrtpRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1), ).setIndexNames((0, "VINES-MIB", "vrtpRtNetid"))
if mibBuilder.loadTexts: vrtpRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtEntry.setDescription('An entry for one network.')
vrtpRtNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtNetid.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtNetid.setDescription("The network ID of the route's destination server.")
vrtpRtMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtMetric.setDescription('The routing metric used by the called server to reach the destination. The metric reflects the cost of the path to the destination, it is in 200-millisecond units.')
vrtpRtIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtIdle.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtIdle.setDescription("The time to live timer for this route's entry. This value indicicates the amount of time before the entry is removed from the called server's routing table. The value is returned in 90 second units.")
vrtpRtGateNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtGateNetid.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpRtGateNetid.setDescription('The network ID of the server that acts as the router for reaching the destination server.')
vrtpRtSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtSvrName.setStatus('optional')
if mibBuilder.loadTexts: vrtpRtSvrName.setDescription('The name of the destination server.')
vrtpRtGateSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtGateSvrName.setStatus('optional')
if mibBuilder.loadTexts: vrtpRtGateSvrName.setDescription('The name of the server that acts as the router for reaching the destination server.')
vrtpTotIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpTotIn.setDescription('The number of VINES VRTP packets received since the server was last booted.')
vrtpTotOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpTotOut.setDescription('The number of VINES VRTP packets sent since the server was last booted.')
vrtpErrsIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpErrsIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrtpErrsIn.setDescription('The number of errors the VRTP protocol encountered while receiving packets, since the server was last booted.')
vrtpNoBuffersIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNoBuffersIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNoBuffersIn.setDescription('The number of times that no communication buffers were available to process received RTP packets or create routine table entries.')
vrtpUpdatesIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpUpdatesIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpUpdatesIn.setDescription('The total number of update packets received.')
vrtpResponsesIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpResponsesIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpResponsesIn.setDescription('The number of responses received.')
vrtpRqstsIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstsIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstsIn.setDescription('The number of requests received.')
vrtpRqstLkUpIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstLkUpIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstLkUpIn.setDescription('The number of packets received that requested routing information.')
vrtpRqstSlrInfoIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstSlrInfoIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstSlrInfoIn.setDescription('The number of request packets received that requested VINES routine metric information on a source-level route (Sequenced Only).')
vrtpReinitIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpReinitIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpReinitIn.setDescription('The number reinitialization packets received (Sequenced Only).')
vrtpResyncIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpResyncIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpResyncIn.setDescription('The number of resynchronization operations or update packets received that contained information for synchronizing routing table entries.')
vrtpRedirIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRedirIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpRedirIn.setDescription('The number of redirect packets received.')
vrtpFragsIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsIn.setDescription('The number of update or response fragments received (Sequenced Only).')
vrtpFragsDropIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsDropIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsDropIn.setDescription('The number of packets dropped due to either the time taken to reassemble was too long or no communication buffer were available(SEQUENCED ONLY).')
vrtpFragsBadIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsBadIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsBadIn.setDescription('The number of RTP fragments discarded because they had packet IDs that were out-of-sequence (SEQUENCED ONLY).')
vrtpFragsDupIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsDupIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsDupIn.setDescription('The number of RTP fragments that were dropped because they were duplicates of other fragments (SEQUENCED ONLY).')
vrtpFragsDoneIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsDoneIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsDoneIn.setDescription('The number of updates and responses that were fragmented or reassembled successfully(SEQUENCED ONLY).')
vrtpReassBadIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpReassBadIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpReassBadIn.setDescription('The number of updates and responses that were not successfully fragmented or reassembled (SEQUENCED ONLY).')
vrtpOutdatedIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpOutdatedIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpOutdatedIn.setDescription('The number of received RTP packets discarded because they were outdated (SEQUENCED ONLY).')
vrtpNetInfoBad = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNetInfoBad.setStatus('optional')
if mibBuilder.loadTexts: vrtpNetInfoBad.setDescription('The number of received outdated entries for logical networks (SEQUENCED ONLY).')
vrtpBadRdrs = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpBadRdrs.setStatus('optional')
if mibBuilder.loadTexts: vrtpBadRdrs.setDescription('The number of redirect packets discarded because of a bad length.')
vrtpBdcstIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpBdcstIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpBdcstIn.setDescription('The number of broadcasted RTP update packets received.')
vrtpNoBuffersOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNoBuffersOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNoBuffersOut.setDescription('The number of times that no communication buffers were available to send RTP packets.')
vrtpUpdatesOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpUpdatesOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpUpdatesOut.setDescription('The total number of update packets sent.')
vrtpRqstLkUpOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstLkUpOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstLkUpOut.setDescription('The number of packets sent that requested routing information.')
vrtpRqstSlrInfoOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstSlrInfoOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstSlrInfoOut.setDescription('The number of request packets sent that requested VINES routine metric information on a source-level route (SEQUENCED ONLY).')
vrtpRqstsOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRqstsOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpRqstsOut.setDescription('The number of requests sent.')
vrtpReinitOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpReinitOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpReinitOut.setDescription('The number reinitialization packets sent (SEQUENCED ONLY).')
vrtpResyncOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpResyncOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpResyncOut.setDescription('The number of resynchronization operations or update packets sent that contained information for synchronizing routing table entries.')
vrtpRedirOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRedirOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpRedirOut.setDescription('The number of redirect packets sent.')
vrtpFragsOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsOut.setDescription('The number of update or response fragments sent (SEQUENCED ONLY).')
vrtpFragsDoneOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsDoneOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsDoneOut.setDescription('The number of updates and responses that were fragmented successfully (SEQUENCED ONLY).')
vrtpFragsBadOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsBadOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsBadOut.setDescription('The number of updates and responses that were fragmented unsuccessfully (SEQUENCED ONLY).')
vrtpFragsDropOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpFragsDropOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpFragsDropOut.setDescription('The number of packets dropped due to either the time taken to fragment the message was too long or no communication buffer were available (SEQUENCED ONLY).')
vrtpBdcstOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpBdcstOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpBdcstOut.setDescription('The number of broadcasted RTP update packets sent.')
vrtpRtCr = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtCr.setStatus('optional')
if mibBuilder.loadTexts: vrtpRtCr.setDescription('The number of routes created by redirect packets.')
vrtpRtMod = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpRtMod.setStatus('optional')
if mibBuilder.loadTexts: vrtpRtMod.setDescription('The number of routes modified by redirect packets.')
vrtpNbrAnchors = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrAnchors.setStatus('optional')
if mibBuilder.loadTexts: vrtpNbrAnchors.setDescription('The total entries in the neighbor table or total paths to all neighbors.')
vrtpNbrEntries = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNbrEntries.setStatus('optional')
if mibBuilder.loadTexts: vrtpNbrEntries.setDescription('The total entries in the neighbor table or total paths to all neighbors.')
vrtpNetEntries = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNetEntries.setStatus('optional')
if mibBuilder.loadTexts: vrtpNetEntries.setDescription("The total entries for networks in this server's network table.")
vrtpLkUp = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpLkUp.setStatus('optional')
if mibBuilder.loadTexts: vrtpLkUp.setDescription('The number of calls to look up network table entries by the server.')
vrtpBadLkUp = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpBadLkUp.setStatus('optional')
if mibBuilder.loadTexts: vrtpBadLkUp.setDescription('The number of calls to look up network table entries by the server that failed.')
vrtpNonSeqTotIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqTotIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqTotIn.setDescription('The number of non-sequenced RTP packets received.')
vrtpNonSeqTotOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqTotOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqTotOut.setDescription('The number of non-sequenced RTP packets sent.')
vrtpNonSeqErrsIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqErrsIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqErrsIn.setDescription('The number of errors while receiving non-sequenced RTP packets.')
vrtpNonSeqUpdIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqUpdIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqUpdIn.setDescription('The number of non-sequenced update packets received.')
vrtpNonSeqRspIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRspIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRspIn.setDescription('The number of non-sequenced responses received.')
vrtpNonSeqRqstIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRqstIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRqstIn.setDescription('The number of non-sequenced requests received.')
vrtpNonSeqRdrIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRdrIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRdrIn.setDescription('The number of non-sequenced redirect packets received.')
vrtpBadNonSeqRdrIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpBadNonSeqRdrIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpBadNonSeqRdrIn.setDescription('The number of invalid non-sequenced redirect packets received.')
vrtpNonSeqBdcstIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqBdcstIn.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqBdcstIn.setDescription('The number of non-sequenced broadcast packets received.')
vrtpNonSeqUpdOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqUpdOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqUpdOut.setDescription('The number of non-sequenced update packets sent.')
vrtpNonSeqRspOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRspOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRspOut.setDescription('The number of non-sequenced responses sent.')
vrtpNonSeqRqstOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRqstOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRqstOut.setDescription('The number of non-sequenced requests sent.')
vrtpNonSeqRdrOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqRdrOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqRdrOut.setDescription('The number of non-sequenced redirect packets sent.')
vrtpNonSeqBdcstOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpNonSeqBdcstOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpNonSeqBdcstOut.setDescription('The number of non-sequenced broadcast packets sent.')
vrtpResponsesOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 7, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtpResponsesOut.setStatus('optional')
if mibBuilder.loadTexts: vrtpResponsesOut.setDescription('The number of responses sent.')
vsppConnsInUse = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppConnsInUse.setStatus('mandatory')
if mibBuilder.loadTexts: vsppConnsInUse.setDescription('The number of SPP connections currently in use by processes on the server.')
vsppConnsCfg = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsppConnsCfg.setStatus('mandatory')
if mibBuilder.loadTexts: vsppConnsCfg.setDescription('The allowable maximum number of SPP connections that can be in use by processes on the server at one time. Note: The setting of this object will not take effect until the servers is rebooted.')
vsppMaxConns = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppMaxConns.setStatus('mandatory')
if mibBuilder.loadTexts: vsppMaxConns.setDescription('The maximum number of SPP connections in use at a single point in time since the server was last booted.')
vsppTotIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: vsppTotIn.setDescription('The total number of VINES SPP packets that the server has received since the server was last booted.')
vsppTotOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: vsppTotOut.setDescription('The total number of VINES SPP packets that the server has sent since the server was last booted.')
vsppInErrs = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppInErrs.setStatus('optional')
if mibBuilder.loadTexts: vsppInErrs.setDescription('The number of SPP errors encountered while receiving packets, since the server was last booted.')
vsppBadType = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppBadType.setStatus('optional')
if mibBuilder.loadTexts: vsppBadType.setDescription('The total number of packets received on SPP connections that had invalid SPP packet types.')
vsppNoBuffers = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppNoBuffers.setStatus('optional')
if mibBuilder.loadTexts: vsppNoBuffers.setDescription('The number of packets that the server could not send, receive or route due to a lack of communication buffers since the server was last booted.')
vsppNoPort = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppNoPort.setStatus('optional')
if mibBuilder.loadTexts: vsppNoPort.setDescription('The number of incoming packets that the server dropped due to an unmatched destination port or an unmatched connection ID.')
vsppDups = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppDups.setStatus('optional')
if mibBuilder.loadTexts: vsppDups.setDescription('The number of incoming packets that were duplicates of other packets.')
vsppBadOrder = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppBadOrder.setStatus('optional')
if mibBuilder.loadTexts: vsppBadOrder.setDescription('The number of incoming packets that were received out of order.')
vsppDataIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppDataIn.setStatus('optional')
if mibBuilder.loadTexts: vsppDataIn.setDescription('The number of packets received on SPP connections.')
vsppAcksIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppAcksIn.setStatus('optional')
if mibBuilder.loadTexts: vsppAcksIn.setDescription('The number of acknowledgement packets received.')
vsppDiscIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppDiscIn.setStatus('optional')
if mibBuilder.loadTexts: vsppDiscIn.setDescription('The number of disconnected packets received on SPP connections.')
vsppProbesIn = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppProbesIn.setStatus('optional')
if mibBuilder.loadTexts: vsppProbesIn.setDescription('The number of probe packets received on SPP connections.')
vsppDataOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppDataOut.setStatus('optional')
if mibBuilder.loadTexts: vsppDataOut.setDescription('The number of data packets sent on SPP connections.')
vsppAcksOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppAcksOut.setStatus('optional')
if mibBuilder.loadTexts: vsppAcksOut.setDescription('The number of acknowledgement packets sent.')
vsppDiscOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppDiscOut.setStatus('optional')
if mibBuilder.loadTexts: vsppDiscOut.setDescription('The number of disconnected packets sent on SPP connections.')
vsppProbesOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppProbesOut.setStatus('optional')
if mibBuilder.loadTexts: vsppProbesOut.setDescription('The number of probe packets sent on SPP connections.')
vsppAbortsOut = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppAbortsOut.setStatus('optional')
if mibBuilder.loadTexts: vsppAbortsOut.setDescription('The number of data packets that had the abort bit set.')
vsppLocal = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 8, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsppLocal.setStatus('optional')
if mibBuilder.loadTexts: vsppLocal.setDescription('The number of packets sent locally using SPP. connections.')
vifNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vifNumber.setDescription('The number of VINES interfaces configured on the server.')
vifTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2), )
if mibBuilder.loadTexts: vifTable.setStatus('mandatory')
if mibBuilder.loadTexts: vifTable.setDescription('List of interfaces with some statistics about each interface.')
vifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1), ).setIndexNames((0, "VINES-MIB", "vifSlot"))
if mibBuilder.loadTexts: vifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vifEntry.setDescription('Information about one interface.')
vifSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vifSlot.setDescription("The slot number of the interface's communications card.")
vifType = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103))).clone(namedValues=NamedValues(("ethernet3Com", 1), ("ethernetNI5010", 2), ("ethernetBICC", 3), ("ethernetUB", 4), ("omninetCorvus", 5), ("arcnetSMC", 6), ("pcnetSytek", 7), ("proNetProteon", 8), ("frag", 9), ("prsystctrl", 10), ("hdlc", 11), ("blkAsync", 12), ("intersys", 13), ("x25EICON", 14), ("tokenRingIBM", 15), ("x25", 16), ("tokenRingUB", 17), ("ipaDavidSys", 18), ("tokenRingPronet4", 19), ("ethernetEplus3Com", 20), ("lanLinkNT", 21), ("ctrllerGanges", 22), ("ethernetNI5210", 23), ("ipTCPIP", 24), ("ipBanyan", 25), ("hdlcTCPIP", 26), ("starlanWDigital", 27), ("ethernetWDigital", 28), ("starlanATT", 29), ("starlanNI5210", 30), ("ethernet3Com3C503", 31), ("ethernet3Com3C523", 32), ("tokenRing3Com3C603", 33), ("lanLinkNTMC", 34), ("serialVGsystems", 35), ("ethernetIntelPC586E", 36), ("starlanATT10", 37), ("pronetProteonMC", 38), ("arcnetSMCMC", 39), ("tokenRingIBMMC", 40), ("ethernetNI9210MC", 41), ("ethernetICAMC", 42), ("pseudoIBM", 43), ("starlanATT10MC", 44), ("ps2UBNICMC", 45), ("llTurboNT", 46), ("tokenRingProteon", 47), ("ethernetNovellNE", 48), ("ctrlerDATACO", 49), ("hughes", 50), ("ethernetNDIS", 51), ("gatewayAPI", 52), ("tokenRingMadge", 53), ("ethernetIBMMC", 54), ("tokenRingIBMBM", 55), ("ethernetWDigitalMC", 56), ("interlanEISA", 57), ("ethernetBICC", 58), ("ethernetNT2R15", 59), ("ethernetNTMC", 60), ("ethernetNTTurbo", 61), ("tokenRingPronet", 62), ("tokenRingCompaq", 63), ("isoSvrSvr", 64), ("ethernetNovellNE3200", 65), ("ethernetPureData", 66), ("ethernetPureDataMC", 67), ("ethernetCabletron", 68), ("ftp", 69), ("arcnetNDIS", 70), ("tokenRingNDIS", 71), ("starlanATTEISA", 72), ("appleTalk", 73), ("localTalk", 74), ("etherLink3COM16", 75), ("interlanNI6510", 76), ("tokenRingProteonP1890", 77), ("ethernetBICCMC", 78), ("icaPlus", 79), ("ipNSRouting", 80), ("etherExpressIntel", 81), ("tokenRingOlicom", 82), ("tokenRingOlicomMC", 83), ("tokenRingOlicamEISA", 84), ("tokenExpressIntelISA", 85), ("tokenExpressIntelMC", 86), ("tokenExpressIntelEISA", 87), ("tokenRingIrmaTracPCAT", 88), ("tokenRingIrmaTracMCA", 89), ("ethernetDGCODE", 90), ("isdnBRIDatavoice", 91), ("wavelanNCR", 92), ("unused", 93), ("unused", 94), ("unused", 95), ("unused", 96), ("unused", 97), ("unused", 98), ("unused", 99), ("promptusT1", 100), ("promptusE1", 101), ("lapdT1", 102), ("isdnDchannel", 103)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifType.setStatus('mandatory')
if mibBuilder.loadTexts: vifType.setDescription('The interface type, types are the same as defined for vrtpNbrIfType in the vrtp neighbor table.')
vifDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vifDescr.setDescription('A textual description of the interface.')
vifAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vifAddress.setDescription('The physical address of the interface, applies to LAN interfaces only.')
vifInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vifInPkts.setDescription('The total number of VINES IP packets that the server received since the last reboot.')
vifInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifInErrs.setDescription('The total number of received VINES IP packets that contained errors since the last reboot.')
vifOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vifOutPkts.setDescription('The total number of VINES IP packets that the server sent since the last reboot.')
vifOutErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifOutErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifOutErrs.setDescription('The total number of transmitted VINES IP packets that contained errors since the last reboot.')
vifLnkNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkNumber.setDescription('The number of serial links connected to the server.')
vifLnkTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4), )
if mibBuilder.loadTexts: vifLnkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkTable.setDescription('Data link level statistics for the serial lines on this server.')
vifLnkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1), ).setIndexNames((0, "VINES-MIB", "vifLnkSlot"), (0, "VINES-MIB", "vifLnkLine"))
if mibBuilder.loadTexts: vifLnkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkEntry.setDescription('Stats for one serial line.')
vifLnkSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkSlot.setDescription('The slot number of the serial communications card to which the serial line is connected.')
vifLnkLine = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkLine.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkLine.setDescription('The line number of the line on the serial communications card.')
vifLnkType = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("ate", 1), ("unused2", 2), ("unused3", 3), ("unused4", 4), ("unused5", 5), ("unused6", 6), ("blkasynch", 7), ("hdlc", 8), ("x25", 9), ("sdlcv1", 10), ("bsc3270", 11), ("sdlcv2", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkType.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkType.setDescription('The type of data link level protocol used on this line. 1 Asynchronous Terminal Emulation. 7 Block asynchronous. 8 High-level Data Link Control (HDLC). 9 X.25 10 Synchronous DataLink Control (SDLC) 1. 11 3270/BSC bisynchronous communication. 12 Same as SDLC1 except line is connected to an ICA card.')
vifLnkTotIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkTotIn.setDescription('The total number of frames received.')
vifLnkTotOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkTotOut.setDescription('The total number of frames transmitted.')
vifLnkRetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkRetrans.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkRetrans.setDescription('The total number of frames retransmitted.')
vifLnkCRCErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkCRCErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkCRCErrs.setDescription('The number of errors due to CRC or frames that the card dropped.')
vifLnkDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkDrops.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkDrops.setDescription('The number of frames that the server could not receive due to a lack of communications buffers.')
vifLnkUnders = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkUnders.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkUnders.setDescription('The total number of transmitter underrun errors on receive.')
vifLnkOvers = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkOvers.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkOvers.setDescription('The total number of receiver overrun errors on receive.')
vifLnkFrmErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifLnkFrmErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifLnkFrmErrs.setDescription('The total number of framing errors.')
vifX25VCNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCNumber.setDescription('The number of X.25 virtual circuits that are available to the server.')
vifX25VCTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6), )
if mibBuilder.loadTexts: vifX25VCTable.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCTable.setDescription('A list of X.25 packet level statistics for the virtual circuit.')
vifX25VCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1), ).setIndexNames((0, "VINES-MIB", "vifX25VCSlot"), (0, "VINES-MIB", "vifX25VCLine"), (0, "VINES-MIB", "vifX25VCSession"))
if mibBuilder.loadTexts: vifX25VCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCEntry.setDescription('Statistics for one virtual circuit.')
vifX25VCSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCSlot.setDescription("The slot number of the serial communications card to which the virtual circuit's line is connected.")
vifX25VCLine = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCLine.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCLine.setDescription('The number of the X.25 line configured on the serial communications card.')
vifX25VCSession = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCSession.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCSession.setDescription('The local session number of the virtual circuit.')
vifX25VCTotIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCTotIn.setDescription('The total number of VINES IP packets received on this VC.')
vifX25VCTotOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCTotOut.setDescription('The total number of VINES IP packets sent on this VC.')
vifX25VCInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCInErrs.setDescription('The total number of received X.25 packets that contained errors.')
vifX25VCOutErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCOutErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCOutErrs.setDescription('The total number of transmitted X.25 packets that contained errors.')
vifX25VCPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCPktsOut.setDescription('The total number of X.25 packets transmitted.')
vifX25VCPktsAwaitAck = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCPktsAwaitAck.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCPktsAwaitAck.setDescription('The total number of X.25 packets transmitted that are awaiting acknowledgement.')
vifX25VCBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCBytesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCBytesOut.setDescription('The total number of bytes transmitted.')
vifX25VCBytesAwaitAck = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCBytesAwaitAck.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCBytesAwaitAck.setDescription('The total number of bytes transmitted that are awaiting acknowledgement.')
vifX25VCPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCPktsIn.setDescription('The total number of X.25 packets that have been received.')
vifX25VCBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCBytesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCBytesIn.setDescription('The total number of bytes received.')
vifX25VCResetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCResetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCResetsIn.setDescription('The total number of X.25 reset packets received.')
vifX25VCResetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCResetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCResetsOut.setDescription('The total number of X.25 reset packets transmitted.')
vifX25VCLogChnNum = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCLogChnNum.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCLogChnNum.setDescription('The logical channel number of the X.25 VC.')
vifX25VCRemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 6, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifX25VCRemAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vifX25VCRemAddr.setDescription('The DTE address of the remote server on the other end of the VC.')
vifStatsList = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7), )
if mibBuilder.loadTexts: vifStatsList.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatsList.setDescription('A list of statistics for each LAN card in the server. The type and quantity of statistics depend on the type of the card.')
vifStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7, 1), ).setIndexNames((0, "VINES-MIB", "vifStatSlot"), (0, "VINES-MIB", "vifStatIndex"))
if mibBuilder.loadTexts: vifStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatEntry.setDescription('The statistics for one card.')
vifStatSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifStatSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatSlot.setDescription('The slot number of the LAN interface card.')
vifStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatIndex.setDescription('A unique value for each statistic, used by SNMP to order the table.')
vifStatDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifStatDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatDescr.setDescription('A brief description of the statistic.')
vifStatValue = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 9, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vifStatValue.setStatus('mandatory')
if mibBuilder.loadTexts: vifStatValue.setDescription('The value of the statistic.')
oscpuNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oscpuNum.setStatus('mandatory')
if mibBuilder.loadTexts: oscpuNum.setDescription('The number of processors.')
oscpuTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2), )
if mibBuilder.loadTexts: oscpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: oscpuTable.setDescription('A list of processors on the server.')
oscpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1), ).setIndexNames((0, "VINES-MIB", "cpuIndex"))
if mibBuilder.loadTexts: oscpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: oscpuEntry.setDescription('Each entry contains a set of statistics for one CPU.')
cpuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpuIndex.setDescription('A unique value for each processor on the server.')
cpuIdleUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuIdleUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuIdleUsage.setDescription('The amount of time that the CPU was completely idle since boot time.')
cpuUserUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUserUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUserUsage.setDescription('The amount of time the CPU spent running processes that run in user space since boot time.')
cpuSysUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuSysUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuSysUsage.setDescription('The amount of time the CPU spent running processes that run in system mode since boottime.')
cpuWIOUserUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuWIOUserUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuWIOUserUsage.setDescription('The amount of time that the CPU was idle, but at least one process was waiting for an I/O operation to complete, since boot time.')
cpuProcSwappedOut = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuProcSwappedOut.setStatus('mandatory')
if mibBuilder.loadTexts: cpuProcSwappedOut.setDescription('The amount of time that the CPU had processes swapped out.')
cpuWIOUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuWIOUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuWIOUsage.setDescription('The amout of time that the CPU waited for I/O to occur.')
cpuWSUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuWSUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuWSUsage.setDescription('The amout of time that the CPU waited for a swap to occur.')
cpuWPIOUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuWPIOUsage.setStatus('mandatory')
if mibBuilder.loadTexts: cpuWPIOUsage.setDescription('The amout of time that the CPU waited for device I/O to occur.')
osBReads = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBReads.setStatus('mandatory')
if mibBuilder.loadTexts: osBReads.setDescription('The number of transfers from disk to system buffers since boot time.')
osBWrites = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBWrites.setStatus('mandatory')
if mibBuilder.loadTexts: osBWrites.setDescription('The number of transfers from system buffers to disk since boot time.')
osLReads = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osLReads.setStatus('mandatory')
if mibBuilder.loadTexts: osLReads.setDescription('The number of reads on the system buffers since boot time.')
osLWrites = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osLWrites.setStatus('mandatory')
if mibBuilder.loadTexts: osLWrites.setDescription('The number of writes on the system buffers since boot time.')
osPReads = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osPReads.setStatus('mandatory')
if mibBuilder.loadTexts: osPReads.setDescription('The number of reads via the raw (physical) device mechanism since boot time.')
osPWrites = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osPWrites.setStatus('mandatory')
if mibBuilder.loadTexts: osPWrites.setDescription('The number of writes via the raw (physical) device mechanism since boot time.')
osInSwaps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osInSwaps.setStatus('mandatory')
if mibBuilder.loadTexts: osInSwaps.setDescription('The number of swaps in since boot time.')
osOutSwaps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osOutSwaps.setStatus('mandatory')
if mibBuilder.loadTexts: osOutSwaps.setDescription('The number of swaps out since boot time.')
osInBSwaps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osInBSwaps.setStatus('mandatory')
if mibBuilder.loadTexts: osInBSwaps.setDescription('The number of 4 KB buffers transferred in since boot time.')
osOutBSwaps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osOutBSwaps.setStatus('mandatory')
if mibBuilder.loadTexts: osOutBSwaps.setDescription('The number of 4 KB buffers transferred out since boot time.')
osProcessSwitches = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osProcessSwitches.setStatus('mandatory')
if mibBuilder.loadTexts: osProcessSwitches.setDescription('The number of process switches since boot time.')
osSystemCalls = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSystemCalls.setStatus('mandatory')
if mibBuilder.loadTexts: osSystemCalls.setDescription('The number of system calls since boot time.')
osSystemRead = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSystemRead.setStatus('mandatory')
if mibBuilder.loadTexts: osSystemRead.setDescription('The number of system read calls.')
osSystemWrite = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSystemWrite.setStatus('mandatory')
if mibBuilder.loadTexts: osSystemWrite.setDescription('The number of system write calls.')
osSystemFork = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSystemFork.setStatus('mandatory')
if mibBuilder.loadTexts: osSystemFork.setDescription('The number of system fork calls.')
osSystemExec = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSystemExec.setStatus('mandatory')
if mibBuilder.loadTexts: osSystemExec.setDescription('The number of system exec calls.')
osRunQueue = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osRunQueue.setStatus('mandatory')
if mibBuilder.loadTexts: osRunQueue.setDescription('The number of processes on the run queue.')
osRunQueueOcc = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osRunQueueOcc.setStatus('mandatory')
if mibBuilder.loadTexts: osRunQueueOcc.setDescription('The amount of time that processes were on the run queue.')
osSwapQueueTotals = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwapQueueTotals.setStatus('mandatory')
if mibBuilder.loadTexts: osSwapQueueTotals.setDescription('The number of processes on the swap queue.')
osSwapQueueOcc = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwapQueueOcc.setStatus('mandatory')
if mibBuilder.loadTexts: osSwapQueueOcc.setDescription('The amount of time that processes were on the swap queue.')
osIPCMsgOps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osIPCMsgOps.setStatus('mandatory')
if mibBuilder.loadTexts: osIPCMsgOps.setDescription('The number of times a System V IPC message operation occurred.')
osSemOps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSemOps.setStatus('mandatory')
if mibBuilder.loadTexts: osSemOps.setDescription('The number of semaphore operations performed by processes.')
osPnpFault = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osPnpFault.setStatus('mandatory')
if mibBuilder.loadTexts: osPnpFault.setDescription('The number of times a process accessed a page which had not been page faulted in.')
osWrtFault = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osWrtFault.setStatus('mandatory')
if mibBuilder.loadTexts: osWrtFault.setDescription('The number of times processes attempted to write to a page marked as copy-on-write.')
osCurrentInodes = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osCurrentInodes.setStatus('mandatory')
if mibBuilder.loadTexts: osCurrentInodes.setDescription('The number of inode table entries currently in the inode table.')
osHWInodes = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osHWInodes.setStatus('mandatory')
if mibBuilder.loadTexts: osHWInodes.setDescription('The high water mark of inode table entries in use since the last reboot of the called server.')
osCurrentFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osCurrentFiles.setStatus('mandatory')
if mibBuilder.loadTexts: osCurrentFiles.setDescription('The number of open file table entries currently in the open file table.')
osHWFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osHWFiles.setStatus('mandatory')
if mibBuilder.loadTexts: osHWFiles.setDescription('The high water mark of open file table entries in use since the last reboot of the called server.')
osMaxInodes = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osMaxInodes.setStatus('mandatory')
if mibBuilder.loadTexts: osMaxInodes.setDescription('The maximum number of inode table entries in the inode table.')
osMaxFiles = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osMaxFiles.setStatus('mandatory')
if mibBuilder.loadTexts: osMaxFiles.setDescription('The maximum number of open file table entries in the open file table.')
osMaxProcesses = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osMaxProcesses.setStatus('mandatory')
if mibBuilder.loadTexts: osMaxProcesses.setDescription('The maximum number of process table entries that UNIX on the server allocates.')
osSwapSpaceAvailable = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwapSpaceAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: osSwapSpaceAvailable.setDescription('The amount of swap space available in 512 byte blocks.')
osFreeMemoryTotal = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osFreeMemoryTotal.setStatus('mandatory')
if mibBuilder.loadTexts: osFreeMemoryTotal.setDescription('The total amount of executable space in kilobytes.')
osIOBufs = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osIOBufs.setStatus('mandatory')
if mibBuilder.loadTexts: osIOBufs.setDescription('The number of 1 KB system buffers that make up UNIX cache on the server.')
osMounts = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osMounts.setStatus('mandatory')
if mibBuilder.loadTexts: osMounts.setDescription('The number of mount table entries that UNIX on the server allocates.')
osUserMaxPu = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osUserMaxPu.setStatus('mandatory')
if mibBuilder.loadTexts: osUserMaxPu.setDescription('The maximum number of concurrent UNIX processes that can be run by users other than the superuser.')
osUserMaxFp = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osUserMaxFp.setStatus('mandatory')
if mibBuilder.loadTexts: osUserMaxFp.setDescription('The maximum number of open files per process.')
osCurrentProcesses = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osCurrentProcesses.setStatus('mandatory')
if mibBuilder.loadTexts: osCurrentProcesses.setDescription('The current number of entries in the process table.')
osSwapSpaceUsed = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwapSpaceUsed.setStatus('mandatory')
if mibBuilder.loadTexts: osSwapSpaceUsed.setDescription('The amount of swap space in use in 512 byte blocks.')
osFreeMemoryAvailable = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osFreeMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: osFreeMemoryAvailable.setDescription('The amount of executable space, in kilobytes, currently available.')
osUserUsagePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osUserUsagePct.setStatus('optional')
if mibBuilder.loadTexts: osUserUsagePct.setDescription('The percentage of time the CPU spent running processes that run in user space over the last five minutes.')
osSysUsagePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSysUsagePct.setStatus('mandatory')
if mibBuilder.loadTexts: osSysUsagePct.setDescription('The percentage of time the CPU spent running processes that run in system mode over the last five minutes.')
osWIOUsagePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osWIOUsagePct.setStatus('mandatory')
if mibBuilder.loadTexts: osWIOUsagePct.setDescription('The percentage of time that the CPU was idle, but at least one process was waiting for an I/O operation to complete, over the last five minutes.')
osIdleUsagePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osIdleUsagePct.setStatus('mandatory')
if mibBuilder.loadTexts: osIdleUsagePct.setDescription('The percentage of time that the CPU was idle over the last five minutes.')
osRunOccPct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osRunOccPct.setStatus('mandatory')
if mibBuilder.loadTexts: osRunOccPct.setDescription('The percentage of time that processes occupied the run queue over the last five minutes.')
osSwapOccPct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwapOccPct.setStatus('mandatory')
if mibBuilder.loadTexts: osSwapOccPct.setDescription('The percentage of time that processes occupied the swap queue over the last five minutes.')
osBuffRdRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBuffRdRate.setStatus('mandatory')
if mibBuilder.loadTexts: osBuffRdRate.setDescription('The average number of times per second that data was read from disk into UNIX system buffers over the last five minutes.')
osRdCachePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osRdCachePct.setStatus('mandatory')
if mibBuilder.loadTexts: osRdCachePct.setDescription('The percentage of read requests for UNIX system buffers that the kernel was able to service using existing UNIX system buffers, without reading new data from disk over the last five minutes.')
osBuffWrRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBuffWrRate.setStatus('mandatory')
if mibBuilder.loadTexts: osBuffWrRate.setDescription('The average number of times per second that data was written from UNIX system buffers to disk over the last five minutes.')
osWrCachePct = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osWrCachePct.setStatus('mandatory')
if mibBuilder.loadTexts: osWrCachePct.setDescription('The percentage of write requests for UNIX system buffers that the kernel was able to service using existing UNIX system buffers, without writing new data to disk over the last five minutes.')
osBswpInRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBswpInRate.setStatus('mandatory')
if mibBuilder.loadTexts: osBswpInRate.setDescription('The average number of 4 KB pages that were swapped or paged from disk to main memory per second over the last five minutes.')
osBswpOutRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osBswpOutRate.setStatus('mandatory')
if mibBuilder.loadTexts: osBswpOutRate.setDescription('The average number of 4 KB pages that were swapped or paged from main memory to disk per second over the last five minutes.')
osVfltRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osVfltRate.setStatus('mandatory')
if mibBuilder.loadTexts: osVfltRate.setDescription('The average number of validity faults per second over the last five minutes.')
osSwitchRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSwitchRate.setStatus('mandatory')
if mibBuilder.loadTexts: osSwitchRate.setDescription('The average number of process switches per second over the last five minutes.')
osSysCallRate = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 10, 3, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osSysCallRate.setStatus('mandatory')
if mibBuilder.loadTexts: osSysCallRate.setDescription('The average number of UNIX system calls that processes issued per second over the last five minutes.')
nmLoadAvg15HighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmLoadAvg15HighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmLoadAvg15HighThres.setDescription('A High threshold value for the 15-minute average of server load (ssLoadAvg15). If the value of ssLoadAvg15 goes above this, a VINES alert and a nmLoadAvgHigh Trap are generated.')
nmSockInUseHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmSockInUseHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmSockInUseHighThres.setDescription('A High threshold value for the percentage of maximum configured sockets currently in use (commSocksInUse). If the value of commSocksInUse goes above this, a VINES alert and a nmSockInUseHigh Trap are generated.')
nmDiskUseHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmDiskUseHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmDiskUseHighThres.setDescription('A High threshold value for the percentage of disk space in use on any given disk (dskUsedPct). If the value of dskUsedPct goes above this, a VINES alert and a nmDiskFull Trap are generated.')
nmSwapAvgHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmSwapAvgHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmSwapAvgHighThres.setDescription('A High threshold value for the 1-minute average of process swapping (ssSwapAvg). If the value of ssSwapAvg goes above this, a VINES alert and a nmSwapAvgHigh Trap are generated.')
nmDropsHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmDropsHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmDropsHighThres.setDescription('A High threshold value for the no. of messages dropped due to lack of comm buffer space (ssDrops). If the value of ssDrops goes above this, a VINES alert and a nmDropsHigh Trap are generated.')
nmSwapSpaceLowThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmSwapSpaceLowThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmSwapSpaceLowThres.setDescription('A Low threshold value for the amount of swap space available (osSwapSpaceAvailable). If the value of osSwapSpaceAvailable drops below this, a VINES alert and a nmFreeSwapLow Trap are generated.')
nmFreeMemLowThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmFreeMemLowThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmFreeMemLowThres.setDescription('A Low threshold value for the amount of memory free (osFreeMemoryAvailable). If the value of osFreeMemoryAvailable drops below this, a VINES alert and a nmFreeMemLow Trap are generated.')
nmCommBuffHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmCommBuffHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmCommBuffHighThres.setDescription('A High threshold value for the percentage of total comms buffer space currently in use (commBufUsage). If the value of commBufUsage goes above this, a VINES alert and a nmCommBuffHigh Trap are generated.')
nmAllocFailHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmAllocFailHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmAllocFailHighThres.setDescription('A High threshold value for the total of comm. buffers that could not be allocated since the last reboot (commAllocsFailed). If the value of commAllocsFailed goes above this, a VINES alert and a nmAllocFailHigh Trap are generated.')
nmCacheHitsLowThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmCacheHitsLowThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmCacheHitsLowThres.setDescription('A Low threshold value for the percentage of cache buffer requests that the system was able to service using existing cache buffers (fsPctCacheHits). If the value of fsPctCacheHits falls below this, a VINES alert and a nmCacheHitsLow Trap are generated.')
nmDiskBusyHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmDiskBusyHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmDiskBusyHighThres.setDescription('A High threshold value for the 5-minute average of the percentage of time a disk was in use transferring data (dskPctBusy). If the value of dskPctBusy rises above this, a VINES alert and a nmDiskBusy Trap are generated.')
nmMsgAvgHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmMsgAvgHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmMsgAvgHighThres.setDescription('A High threshold value for the 1-minute average of network messages sent/received per second (ssMsgAvg1). If the value of ssMsgAvg1 goes above this, a VINES alert and a nmMsgAvgHigh Trap are generated.')
nmInodeUseHighThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 11, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmInodeUseHighThres.setStatus('mandatory')
if mibBuilder.loadTexts: nmInodeUseHighThres.setDescription('A High threshold value for the number of inode table entries currently in the inode table (osCurrentInodes). If the value of osCurrentInodes rises above this, a VINES alert and a nmInodesHigh Trap are generated.')
tpAlertTime = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 1), Integer32())
if mibBuilder.loadTexts: tpAlertTime.setStatus('mandatory')
if mibBuilder.loadTexts: tpAlertTime.setDescription('The system time when alert was issued to the Alert Management Service, as specified in UNIX time() format.')
tpErrorCode = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 2), Integer32())
if mibBuilder.loadTexts: tpErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: tpErrorCode.setDescription('A VINES error code.')
tpUserName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 3), OctetString())
if mibBuilder.loadTexts: tpUserName.setStatus('mandatory')
if mibBuilder.loadTexts: tpUserName.setDescription('A VINES StreetTalk user name.')
tpSvcName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 4), OctetString())
if mibBuilder.loadTexts: tpSvcName.setStatus('mandatory')
if mibBuilder.loadTexts: tpSvcName.setDescription('The StreetTalk Service name which issued the trap.')
tpSvrName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 5), OctetString())
if mibBuilder.loadTexts: tpSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: tpSvrName.setDescription('The name of the Server on which the trap was issued.')
tpRefSvcName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 6), OctetString())
if mibBuilder.loadTexts: tpRefSvcName.setStatus('mandatory')
if mibBuilder.loadTexts: tpRefSvcName.setDescription('A StreetTalk Service name.')
tpRefSvrName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 7), OctetString())
if mibBuilder.loadTexts: tpRefSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: tpRefSvrName.setDescription('The name of a Server.')
tpJobId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 8), Integer32())
if mibBuilder.loadTexts: tpJobId.setStatus('mandatory')
if mibBuilder.loadTexts: tpJobId.setDescription('The Job Identifier for a particular job in the Print Service.')
tpPaperFormat = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 9), OctetString())
if mibBuilder.loadTexts: tpPaperFormat.setStatus('mandatory')
if mibBuilder.loadTexts: tpPaperFormat.setDescription('The paper format type specified for a print job.')
tpJobTotal = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 10), Integer32())
if mibBuilder.loadTexts: tpJobTotal.setStatus('mandatory')
if mibBuilder.loadTexts: tpJobTotal.setDescription('The current number of jobs in the print queue.')
tpConnId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 11), Integer32())
if mibBuilder.loadTexts: tpConnId.setStatus('mandatory')
if mibBuilder.loadTexts: tpConnId.setDescription('A PostScript print service connection ID.')
tpMailSender = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 12), OctetString())
if mibBuilder.loadTexts: tpMailSender.setStatus('mandatory')
if mibBuilder.loadTexts: tpMailSender.setDescription('The StreetTalk user name of a mail sender.')
tpPortId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 13), OctetString())
if mibBuilder.loadTexts: tpPortId.setStatus('mandatory')
if mibBuilder.loadTexts: tpPortId.setDescription('The Port ID being reported by VINES Security is the scene of a possible security breach.')
tpRtnName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 14), OctetString())
if mibBuilder.loadTexts: tpRtnName.setStatus('mandatory')
if mibBuilder.loadTexts: tpRtnName.setDescription('The name of the executing routine when the STDA service encountered a fatal error.')
tp162erravg = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 15), Integer32())
if mibBuilder.loadTexts: tp162erravg.setStatus('mandatory')
if mibBuilder.loadTexts: tp162erravg.setDescription('The current average of 162 errors.')
tp162errThresHigh = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 16), Integer32())
if mibBuilder.loadTexts: tp162errThresHigh.setStatus('mandatory')
if mibBuilder.loadTexts: tp162errThresHigh.setDescription('The High Threshold for 162 errors in ST.')
tp162errTotal = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 17), Integer32())
if mibBuilder.loadTexts: tp162errTotal.setStatus('mandatory')
if mibBuilder.loadTexts: tp162errTotal.setDescription('The current total of 162 errors in ST.')
tpGrpName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 18), OctetString())
if mibBuilder.loadTexts: tpGrpName.setStatus('mandatory')
if mibBuilder.loadTexts: tpGrpName.setDescription('A StreetTalk Group Name.')
tpNumGrps = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 19), Integer32())
if mibBuilder.loadTexts: tpNumGrps.setStatus('mandatory')
if mibBuilder.loadTexts: tpNumGrps.setDescription('The number of groups being maintained by StreetTalk on a given server (as a percentage of the maximum allowed no.')
tpGrpLimit = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 20), Integer32())
if mibBuilder.loadTexts: tpGrpLimit.setStatus('mandatory')
if mibBuilder.loadTexts: tpGrpLimit.setDescription('The maximum number of groups allowed on a server.')
tpOldSerNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 21), Integer32())
if mibBuilder.loadTexts: tpOldSerNum.setStatus('mandatory')
if mibBuilder.loadTexts: tpOldSerNum.setDescription("A server's old serial number.")
tpNewSerNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 22), Integer32())
if mibBuilder.loadTexts: tpNewSerNum.setStatus('mandatory')
if mibBuilder.loadTexts: tpNewSerNum.setDescription("A server's new serial number.")
tpDiskSpaceLeft = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 23), Integer32())
if mibBuilder.loadTexts: tpDiskSpaceLeft.setStatus('mandatory')
if mibBuilder.loadTexts: tpDiskSpaceLeft.setDescription('The amount of disk space left (KB) available to the Mail Service.')
tpMailMessageId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 24), OctetString())
if mibBuilder.loadTexts: tpMailMessageId.setStatus('mandatory')
if mibBuilder.loadTexts: tpMailMessageId.setDescription('The internal message ID of an item in the mail service.')
tpSockOvFlowNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 25), Integer32())
if mibBuilder.loadTexts: tpSockOvFlowNum.setStatus('mandatory')
if mibBuilder.loadTexts: tpSockOvFlowNum.setDescription('The number of packets dropped due to a socket overflow.')
tpDiskNName = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 26), OctetString())
if mibBuilder.loadTexts: tpDiskNName.setStatus('mandatory')
if mibBuilder.loadTexts: tpDiskNName.setDescription('The name of a disk unit.')
tpSvrNetId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 27), Integer32())
if mibBuilder.loadTexts: tpSvrNetId.setStatus('mandatory')
if mibBuilder.loadTexts: tpSvrNetId.setDescription('The server NetID.')
tpSubNetId = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 28), Integer32())
if mibBuilder.loadTexts: tpSubNetId.setStatus('mandatory')
if mibBuilder.loadTexts: tpSubNetId.setDescription('A VINES subnetwork ID.')
tpSlotNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 29), Integer32())
if mibBuilder.loadTexts: tpSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: tpSlotNum.setDescription('The Slot Number of a particular interface card.')
tpLineNum = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 30), Integer32())
if mibBuilder.loadTexts: tpLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: tpLineNum.setDescription('The Line Number on the interface board.')
tpFRcvd = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 31), Integer32())
if mibBuilder.loadTexts: tpFRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: tpFRcvd.setDescription('The number of frames received.')
tpFXmtd = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 32), Integer32())
if mibBuilder.loadTexts: tpFXmtd.setStatus('mandatory')
if mibBuilder.loadTexts: tpFXmtd.setDescription('The number of frames transmitted.')
tpLnkDropsThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 33), Integer32())
if mibBuilder.loadTexts: tpLnkDropsThres.setStatus('mandatory')
if mibBuilder.loadTexts: tpLnkDropsThres.setDescription('The threshold value for link-level drops - when exceeded an alert is issued.')
tpLnkReXtThres = MibScalar((1, 3, 6, 1, 4, 1, 130, 1, 2, 12, 34), Integer32())
if mibBuilder.loadTexts: tpLnkReXtThres.setStatus('mandatory')
if mibBuilder.loadTexts: tpLnkReXtThres.setDescription('The threshold value for link-level re-transmits - when exceeded an alert is isssued.')
amsRegTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1), )
if mibBuilder.loadTexts: amsRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegTable.setDescription('The Table containing entries for each seperate registration with AMS to receive alerts.')
amsRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1), ).setIndexNames((0, "VINES-MIB", "amsRegIndex"))
if mibBuilder.loadTexts: amsRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegEntry.setDescription('Entry into amsRegTable.')
amsRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegIndex.setDescription('The index value into the amsRegTable used by SNMP.')
amsRegIdInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegIdInstance.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegIdInstance.setDescription('The alert instance string that the registered party is interested in.')
amsRegIdClass = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegIdClass.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegIdClass.setDescription('The application class that the registered party is interested in receiving alerts from.')
amsRegIdTid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegIdTid.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegIdTid.setDescription('The alert template identifier that the registered party is interested in.')
amsRegPort = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegPort.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegPort.setDescription('The Port to which the alerts are to be sent. This will be NULL if amsRegAction is something other than a notification sent to an IPC Port.')
amsRegWhoAdded = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegWhoAdded.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegWhoAdded.setDescription('The StreetTalk name of the user who added this particular entry to the table.')
amsRegAlertee = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegAlertee.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegAlertee.setDescription("The StreetTalk name of the user to whom the alerts are to be sent. This will be NULL if the amsRegAction for this entry is 'sendipcport'.")
amsRegAction = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sendipcport", 1), ("bleepstname", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsRegAction.setStatus('mandatory')
if mibBuilder.loadTexts: amsRegAction.setDescription("The action to perform with alerts that match for this entry. The available options are : sendipcport - Pass the alert to the specific registered IPC port, as specified in 'amsRegPort'. bleepstname - Send a 25th-line message containing the alert to the user 'amsRegAlertee'.")
amsAlertLogTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2), )
if mibBuilder.loadTexts: amsAlertLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: amsAlertLogTable.setDescription('The Table containing entries for each each record written into each of the AMS alert log files.')
amsLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1), ).setIndexNames((0, "VINES-MIB", "amsLogFileIndex"), (0, "VINES-MIB", "amsLogRecIndex"))
if mibBuilder.loadTexts: amsLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogEntry.setDescription('Entry into amsAlertLogTable.')
amsLogFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("previous", 1), ("current", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogFileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogFileIndex.setDescription("The index value into the amsRegTable used to distinguish between the alert log files kept by AMS. Options are: previous - The previous day's log. current - Today's log file. The log files are switched at 12:00am each night, when 'today' becomes 'yesterday' and 'yesterday' is emptied and becomes 'today'.")
amsLogRecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogRecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogRecIndex.setDescription('The index value into the amsAlertLogTable used to uniquely identify each record in a given alert log.')
amsLogIdInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogIdInstance.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogIdInstance.setDescription('The alert instance string of the AlertID in the alert record.')
amsLogIdClass = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogIdClass.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogIdClass.setDescription('The application class of the AlertID in the alert record.')
amsLogIdTid = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogIdTid.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogIdTid.setDescription('The template identifier of the AlertID in the alert record.')
amsLogAlertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogAlertTime.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogAlertTime.setDescription('The time at which the alert was originally issued.')
amsLogAlertString = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 13, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amsLogAlertString.setStatus('mandatory')
if mibBuilder.loadTexts: amsLogAlertString.setDescription('The textual string description of the alert including all data values.')
mlMailBoxTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1), )
if mibBuilder.loadTexts: mlMailBoxTable.setStatus('mandatory')
if mibBuilder.loadTexts: mlMailBoxTable.setDescription('The Table containing entries for each Mailbox maintained by the Mail Service.')
mlMailBoxTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1, 1), ).setIndexNames((0, "VINES-MIB", "mlMBTableIndex"))
if mibBuilder.loadTexts: mlMailBoxTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mlMailBoxTableEntry.setDescription('Entry into mlMailBoxTable.')
mlMBTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlMBTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mlMBTableIndex.setDescription('The index value into the mlMailBoxTable used by SNMP.')
mlMBTableMBOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlMBTableMBOwner.setStatus('mandatory')
if mibBuilder.loadTexts: mlMBTableMBOwner.setDescription('The StreetTalk name of the user to whom this mailbox relates.')
mlMBTableUnreadMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlMBTableUnreadMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mlMBTableUnreadMsgs.setDescription('The number of unread messages in this mailbox.')
mlMBTableTotalMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlMBTableTotalMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mlMBTableTotalMsgs.setDescription('The total number of messages in this mailbox.')
vlogsTable = MibTable((1, 3, 6, 1, 4, 1, 130, 1, 2, 15, 1), )
if mibBuilder.loadTexts: vlogsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlogsTable.setDescription('The Table containing entries for each log.')
vlogsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 1, 2, 15, 1, 1), ).setIndexNames((0, "VINES-MIB", "vlogsFileIndex"))
if mibBuilder.loadTexts: vlogsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlogsEntry.setDescription('Entry into vlogsEntry.')
vlogsFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("patch", 1), ("backup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlogsFileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlogsFileIndex.setDescription('The index value into the vlogsTable.')
vlogsDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 1, 2, 15, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlogsDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vlogsDescr.setDescription('The record entry for the log.')
nmLoadAvgHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,1)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmLoadAvg15HighThres"))
if mibBuilder.loadTexts: nmLoadAvgHigh.setDescription('The 15 minute load average on the specified server has exceeded the specified threshold value.')
nmSwapAvgHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,2)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmSwapAvgHighThres"))
if mibBuilder.loadTexts: nmSwapAvgHigh.setDescription('The 15 minute swap average on the specified server has exceeded the specified threshold value.')
nmDropsHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,3)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmDropsHighThres"))
if mibBuilder.loadTexts: nmDropsHigh.setDescription('The 15 minute average of dropped messages (due to lack of comms buffers) on the specified server has exceeded the specified threshold value.')
nmFreeSwapLow = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,4)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmSwapSpaceLowThres"))
if mibBuilder.loadTexts: nmFreeSwapLow.setDescription('The Free Swap space on the specified server fell below the specified threshold value.')
nmFreeMemLow = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,5)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmFreeMemLowThres"))
if mibBuilder.loadTexts: nmFreeMemLow.setDescription('The Free Process memory space on the specified server fell below the specified threshold value.')
nmCommBuffHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,6)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmCommBuffHighThres"))
if mibBuilder.loadTexts: nmCommBuffHigh.setDescription('The communications buffer usage on the specified server exceeded the specified threshold value.')
nmSockInUseHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,7)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmSockInUseHighThres"))
if mibBuilder.loadTexts: nmSockInUseHigh.setDescription('The sockets in use on the specified server exceeded the specified threshold value.')
nmSockOvflow = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,8)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"), ("VINES-MIB", "tpSockOvFlowNum"))
if mibBuilder.loadTexts: nmSockOvflow.setDescription('Socket overflow for the specified service. The number of packets dropped is also provided.')
nmMsgAvgHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,9)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmMsgAvgHighThres"))
if mibBuilder.loadTexts: nmMsgAvgHigh.setDescription('The 15 minute average of message activity on the specified server has exceeded the specified threshold value.')
nmAllocFail_High = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,10)).setLabel("nmAllocFail-High").setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmAllocFailHighThres"))
if mibBuilder.loadTexts: nmAllocFail_High.setDescription('The number of failed communication buffer allocations on the specified server exceeded the specified threshold value.')
nmCacheHits_Low = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,11)).setLabel("nmCacheHits-Low").setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmCacheHitsLowThres"))
if mibBuilder.loadTexts: nmCacheHits_Low.setDescription('The percentage of cache buffer requests that the specified server was able to service using existing cache buffers, without reading new data from the disk, fell below the specified threshold value.')
nmDiskFull = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,12)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpDiskNName"), ("VINES-MIB", "nmDiskUseHighThres"))
if mibBuilder.loadTexts: nmDiskFull.setDescription('The percentage of disk space in use on the specified disk exceeded the threshold.')
nmDiskBusy = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,13)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpDiskNName"), ("VINES-MIB", "nmDiskBusyHighThres"))
if mibBuilder.loadTexts: nmDiskBusy.setDescription('The 5 minute average of percentage of time the specified disk was in use exceeded the threshold.')
nmInodesHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,14)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "nmInodeUseHighThres"))
if mibBuilder.loadTexts: nmInodesHigh.setDescription('The number of inodes in use on the specified server exceeded the threshold value.')
nmProcsHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,15)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: nmProcsHigh.setDescription('The specified server cannot run any more processes.')
nmTKRingOpen = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,16)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSlotNum"))
if mibBuilder.loadTexts: nmTKRingOpen.setDescription('The token ring adapter in the specified slot has an open/short circuit detected.')
nmTKRingSigLoss = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,17)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSlotNum"))
if mibBuilder.loadTexts: nmTKRingSigLoss.setDescription('The token ring adapter in the specified slot has been detected with a Signal Loss.')
nmTKRingHardErr = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,18)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSlotNum"))
if mibBuilder.loadTexts: nmTKRingHardErr.setDescription('The token ring adapter in the specified slot has been detected with a Hard Error.')
nmTKRingRmvHardErr = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,19)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSlotNum"))
if mibBuilder.loadTexts: nmTKRingRmvHardErr.setDescription('The token ring adapter in the specified slot removed itself from the token ring.')
nmTKRingRmvMacFrame = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,20)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSlotNum"))
if mibBuilder.loadTexts: nmTKRingRmvMacFrame.setDescription('Removing the MAC frame from the token ring adapter in the specified slot caused it to remove itself from the Token Ring.')
nmLnkDropsHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,21)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpLnkDropsThres"), ("VINES-MIB", "tpSlotNum"), ("VINES-MIB", "tpLineNum"), ("VINES-MIB", "tpFRcvd"))
if mibBuilder.loadTexts: nmLnkDropsHigh.setDescription('The percentage of frames dropped with respect to the total frames received, over the previous 15 minutes, exceeded the threshold value.')
nmLnkReTXHigh = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,22)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpLnkReXtThres"), ("VINES-MIB", "tpSlotNum"), ("VINES-MIB", "tpLineNum"), ("VINES-MIB", "tpFXmtd"))
if mibBuilder.loadTexts: nmLnkReTXHigh.setDescription('The percentage of frames retransmitted with respect to the total frames transmitted, over the previous 15 minutes, exceeded the threshold value.')
bsSysBkUpFailed = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,23)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: bsSysBkUpFailed.setDescription('The system back-up on the specified system failed with the given error code.')
bsIncBkUpAborted = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,24)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: bsIncBkUpAborted.setDescription('The incremental back-up on the specified system was aborted.')
bsIncBkUpFailed = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,25)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: bsIncBkUpFailed.setDescription('The incremental back-up on the specified system failed with the given error code.')
bsSvcBkUpFailed = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,26)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: bsSvcBkUpFailed.setDescription('The service back-up on the specified system failed with the given error code.')
psFormUnavail = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,27)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpJobId"), ("VINES-MIB", "tpPaperFormat"))
if mibBuilder.loadTexts: psFormUnavail.setDescription('The specified job requested a paper format which was not available.')
psUserNoAuth = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,28)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"), ("VINES-MIB", "tpRefSvcName"))
if mibBuilder.loadTexts: psUserNoAuth.setDescription('The specified user is not authorized to connect to the specified printer.')
psBadDest = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,29)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"))
if mibBuilder.loadTexts: psBadDest.setDescription('The specified destination cannot be started.')
psJobReject = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,30)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpJobId"), ("VINES-MIB", "tpRefSvcName"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: psJobReject.setDescription('The specified job was rejected on the specific print service by the given user.')
psQueueFull = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,31)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"), ("VINES-MIB", "tpJobTotal"))
if mibBuilder.loadTexts: psQueueFull.setDescription("The specified print queue has reached its' capacity.")
psOffline = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,32)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"))
if mibBuilder.loadTexts: psOffline.setDescription('The specified entity has gone offline.')
psPapError = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,33)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"), ("VINES-MIB", "tpConnId"))
if mibBuilder.loadTexts: psPapError.setDescription('The specified PAP error occurred on the given connection ID.')
psAtalkErr = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,34)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: psAtalkErr.setDescription('A fatal AppleTalk error occurred in the PostScript print service.')
psPsPrinterErr = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,35)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: psPsPrinterErr.setDescription('A printer error was detected on the PostScript print service.')
ssSvcNoStart = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,36)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: ssSvcNoStart.setDescription('The specified service was unable to be started by Server Service. The error code is provided.')
ssNoReconnVS = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,37)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: ssNoReconnVS.setDescription('Server Service failed to reconnect to VINES Security Service. The error code is provided.')
ssNoReconnST = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,38)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: ssNoReconnST.setDescription('Server Service failed to reconnect to StreetTalk Service. The error code is provided.')
ssSvcCrashed = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,39)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"))
if mibBuilder.loadTexts: ssSvcCrashed.setDescription('The specified service crashed.')
ssSvcRecrashed = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,40)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvcName"))
if mibBuilder.loadTexts: ssSvcRecrashed.setDescription('The specified service recrashed on a restart attempt.')
ssBadSvcDB = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,41)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssBadSvcDB.setDescription('The services database is corrupted. Server Service is halting.')
ssPowerFail = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,42)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssPowerFail.setDescription('The power has failed. Server Service is going down.')
ssDying = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,43)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: ssDying.setDescription('Server Service died with the given error. All services will be killed.')
ssPanicDBWrite = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,44)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssPanicDBWrite.setDescription('Server Service failed to write to the services database file.')
ssPanicWait = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,45)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssPanicWait.setDescription('Server Service failed to wait on child process death.')
ssPanicUlimit = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,46)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssPanicUlimit.setDescription('Server Service unable to set limit.')
ssNoMemory = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,47)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssNoMemory.setDescription('Server Service unable to allocate memory.')
ssTimeSet = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,48)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: ssTimeSet.setDescription('Server Service set the Network Time.')
msMBoxFull = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,49)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"), ("VINES-MIB", "tpMailSender"))
if mibBuilder.loadTexts: msMBoxFull.setDescription("The specified user's mailbox is full. The mail service is unable to deliver mail from the second user name.")
msDiskFull = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,50)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpDiskSpaceLeft"))
if mibBuilder.loadTexts: msDiskFull.setDescription('The Mail service disk is running out of space; only the specified number of kilobytes are left.')
msPanic = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,51)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: msPanic.setDescription('The Mail service failed with the given error code.')
msCompressFail = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,52)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpMailMessageId"))
if mibBuilder.loadTexts: msCompressFail.setDescription('Message Compression failed on the given message.')
msDecompressFail = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,53)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpMailMessageId"))
if mibBuilder.loadTexts: msDecompressFail.setDescription('Message Decompression failed on the given message.')
msMasquerade = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,54)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpMailSender"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: msMasquerade.setDescription('The specified user is sending mail masquerading as the second user name.')
msMTAPanic = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,55)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: msMTAPanic.setDescription('The mail message transport system has crashed.')
msBMSPanic = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,56)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: msBMSPanic.setDescription('The mail message store system has crashed.')
vsNoReachST = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,57)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: vsNoReachST.setDescription('The VINES Security Service cannot access the local StreetTalk Service.')
vsBadLoginPhysLoc = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,58)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpPortId"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: vsBadLoginPhysLoc.setDescription('A failed login occurred due to an invalid physical location. The attempt was from the given port and using the given user name.')
vsBadLoginDialin = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,59)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpPortId"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: vsBadLoginDialin.setDescription('A failed login occurred due to a breach of dial-in security. The attempt was from the given port and using the given user name.')
vsBadLoginTime = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,60)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: vsBadLoginTime.setDescription('A failed login occurred for the given user name due to attempt to login outside of login-time restrictions.')
vsMaxBadLogins = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,61)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpPortId"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: vsMaxBadLogins.setDescription('A failed login occurred from the given port for the given user name due to exceeding the maximum allowed password attempts.')
vsSDBInconsist = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,62)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: vsSDBInconsist.setDescription('The nonce stamp did not match with that in the session database file.')
vsNoSessAvail = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,63)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: vsNoSessAvail.setDescription('A login session was denied as the allowed no. of sessions had been reached.')
vsSvrSvrPwd = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,64)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRefSvrName"))
if mibBuilder.loadTexts: vsSvrSvrPwd.setDescription('A secure link was requested to the specified server and was not established due to a bad password.')
vsNoSTLogin = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,65)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: vsNoSTLogin.setDescription('The VINES Security Service could not login to StreetTalk, with the given error code, and hence is exiting.')
vsNoSpace = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,66)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: vsNoSpace.setDescription('The VINES Security Service could not compress the sessions file as the disk is full.')
vsLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,67)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpSvrNetId"))
if mibBuilder.loadTexts: vsLinkDown.setDescription('The point-to-point link to the specified server has been severed.')
vsPCDialTerm = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,68)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"), ("VINES-MIB", "tpSvrNetId"), ("VINES-MIB", "tpSubNetId"), ("VINES-MIB", "tpSlotNum"), ("VINES-MIB", "tpLineNum"))
if mibBuilder.loadTexts: vsPCDialTerm.setDescription('A PC Dial-In session has been severed on the indicated slot and line number.')
vsPCDialInit = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,69)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"), ("VINES-MIB", "tpSvrNetId"), ("VINES-MIB", "tpSubNetId"), ("VINES-MIB", "tpSlotNum"), ("VINES-MIB", "tpLineNum"))
if mibBuilder.loadTexts: vsPCDialInit.setDescription('A PC Dial-In session has been established on the indicated slot and line number.')
afpAtalkDown = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,70)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"))
if mibBuilder.loadTexts: afpAtalkDown.setDescription('An AppleTalk stack error was detected.')
afpSessDiscon = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,71)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpUserName"))
if mibBuilder.loadTexts: afpSessDiscon.setDescription('A Session disconnect was detected.')
daGCoreDump = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,72)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRtnName"))
if mibBuilder.loadTexts: daGCoreDump.setDescription('STDA getnames going down unexpectedly.')
daSCoreDump = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,73)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpRtnName"))
if mibBuilder.loadTexts: daSCoreDump.setDescription('STDA service going down unexpectedly.')
stCoreDump = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,74)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpErrorCode"))
if mibBuilder.loadTexts: stCoreDump.setDescription('StreetTalk service going down unexpectedly with the given error code.')
st162Errs = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,75)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tp162erravg"), ("VINES-MIB", "tp162errThresHigh"), ("VINES-MIB", "tp162errTotal"))
if mibBuilder.loadTexts: st162Errs.setDescription('The current 15 minute average of 162 (network timeout) errors has exceeded the set threshold.')
stAddedGrp = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,76)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpGrpName"), ("VINES-MIB", "tpRefSvrName"))
if mibBuilder.loadTexts: stAddedGrp.setDescription('The specified group has been added on the given server.')
stDeletedGrp = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,77)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpGrpName"), ("VINES-MIB", "tpRefSvrName"))
if mibBuilder.loadTexts: stDeletedGrp.setDescription('The specified group has been deleted on the given server.')
stRebuild = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,78)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpGrpName"))
if mibBuilder.loadTexts: stRebuild.setDescription('A data inconsistency was found in the specified group. A rebuild will be attempted.')
stGrpLimit = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,79)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpNumGrps"), ("VINES-MIB", "tpGrpLimit"))
if mibBuilder.loadTexts: stGrpLimit.setDescription('The number of groups on the server has exceeded the threshold percentage value of the maximum allowed.')
stSerialNum = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,80)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpOldSerNum"), ("VINES-MIB", "tpNewSerNum"))
if mibBuilder.loadTexts: stSerialNum.setDescription('The server serial number has been changed from the given old value to the given new value.')
stDupGrp = NotificationType((1, 3, 6, 1, 4, 1, 130, 1, 2) + (0,81)).setObjects(("VINES-MIB", "tpSvrName"), ("VINES-MIB", "tpSvcName"), ("VINES-MIB", "tpAlertTime"), ("VINES-MIB", "tpGrpName"), ("VINES-MIB", "tpSvrNetId"))
if mibBuilder.loadTexts: stDupGrp.setDescription('A duplicate of the specified group also exists on the given server.')
mibBuilder.exportSymbols("VINES-MIB", vifX25VCTotIn=vifX25VCTotIn, trapdata=trapdata, vrtpFragsDropOut=vrtpFragsDropOut, daGCoreDump=daGCoreDump, tpRtnName=tpRtnName, osPnpFault=osPnpFault, vrtpErrsIn=vrtpErrsIn, amsRegIndex=amsRegIndex, vsLinkDown=vsLinkDown, vifOutErrs=vifOutErrs, vifStatEntry=vifStatEntry, vrtpNonSeqRdrIn=vrtpNonSeqRdrIn, osSystemFork=osSystemFork, osCurrentFiles=osCurrentFiles, svcTable=svcTable, dskActive=dskActive, tpFRcvd=tpFRcvd, ossummstats=ossummstats, vifX25VCSession=vifX25VCSession, amsLogAlertTime=amsLogAlertTime, ssLoadAvg1=ssLoadAvg1, msDecompressFail=msDecompressFail, vipBcast=vipBcast, tpNumGrps=tpNumGrps, vspp=vspp, vrtpFragsOut=vrtpFragsOut, nmMsgAvgHighThres=nmMsgAvgHighThres, vrtpRqstSlrInfoIn=vrtpRqstSlrInfoIn, tp162errTotal=tp162errTotal, vsppTotIn=vsppTotIn, vrtpNbrRemAddress=vrtpNbrRemAddress, peripherals=peripherals, vrtpNbrNumber=vrtpNbrNumber, vifLnkTotOut=vifLnkTotOut, amsRegAlertee=amsRegAlertee, vifX25VCLine=vifX25VCLine, svcSize=svcSize, fsCacheBufSize=fsCacheBufSize, vrtpReinitIn=vrtpReinitIn, vlogsFileIndex=vlogsFileIndex, services=services, vrtpRtMetric=vrtpRtMetric, tpGrpName=tpGrpName, osHWFiles=osHWFiles, vrtpNonSeqUpdOut=vrtpNonSeqUpdOut, bsIncBkUpAborted=bsIncBkUpAborted, svcSockets=svcSockets, osFreeMemoryAvailable=osFreeMemoryAvailable, vifX25VCBytesAwaitAck=vifX25VCBytesAwaitAck, nmSockOvflow=nmSockOvflow, oscpuTable=oscpuTable, tpSvrNetId=tpSvrNetId, mailservice=mailservice, vsppBadOrder=vsppBadOrder, cpuUserUsage=cpuUserUsage, osLReads=osLReads, osRunQueue=osRunQueue, osRunQueueOcc=osRunQueueOcc, vrtpUpdatesOut=vrtpUpdatesOut, vifStatIndex=vifStatIndex, stRebuild=stRebuild, svcDiskName=svcDiskName, vsSvrSvrPwd=vsSvrSvrPwd, mlMBTableIndex=mlMBTableIndex, dskNBlocks=dskNBlocks, ssDrops=ssDrops, ssNoReconnST=ssNoReconnST, vrtpRqstsOut=vrtpRqstsOut, nmSwapAvgHighThres=nmSwapAvgHighThres, vrtpTotIn=vrtpTotIn, vrtpRqstSlrInfoOut=vrtpRqstSlrInfoOut, vrtpNonSeqTotIn=vrtpNonSeqTotIn, vifX25VCLogChnNum=vifX25VCLogChnNum, cpuWIOUserUsage=cpuWIOUserUsage, osHWInodes=osHWInodes, vlogs=vlogs, vipInFragments=vipInFragments, amsAlertLogTable=amsAlertLogTable, vifLnkTable=vifLnkTable, vrtpNonSeqRqstOut=vrtpNonSeqRqstOut, nmCommBuffHigh=nmCommBuffHigh, tpDiskSpaceLeft=tpDiskSpaceLeft, vrtpNbrEntry=vrtpNbrEntry, nmMsgAvgHigh=nmMsgAvgHigh, vifX25VCResetsOut=vifX25VCResetsOut, dskNErrs=dskNErrs, vrtpNonSeqRspOut=vrtpNonSeqRspOut, cpuIndex=cpuIndex, vrtpNbrLocAddress=vrtpNbrLocAddress, vifX25VCBytesOut=vifX25VCBytesOut, vifStatDescr=vifStatDescr, vrtpRtSvrName=vrtpRtSvrName, vifLnkType=vifLnkType, vipReass=vipReass, vifX25VCPktsIn=vifX25VCPktsIn, vipToDodIP=vipToDodIP, osVfltRate=osVfltRate, psBadDest=psBadDest, vifNumber=vifNumber, banyan=banyan, nmCacheHitsLowThres=nmCacheHitsLowThres, ossysstats=ossysstats, msPanic=msPanic, osSystemRead=osSystemRead, ssNetid=ssNetid, vrtpOutdatedIn=vrtpOutdatedIn, tpSlotNum=tpSlotNum, svcTotSess=svcTotSess, vifLnkCRCErrs=vifLnkCRCErrs, amsLogIdInstance=amsLogIdInstance, ssOsType=ssOsType, systemsummary=systemsummary, vsppTotOut=vsppTotOut, tpSvcName=tpSvcName, ssPanicUlimit=ssPanicUlimit, amsRegTable=amsRegTable, nmLoadAvg15HighThres=nmLoadAvg15HighThres, vrtpNonSeqUpdIn=vrtpNonSeqUpdIn, osOutBSwaps=osOutBSwaps, vrtpFragsIn=vrtpFragsIn, tpDiskNName=tpDiskNName, vsppDiscIn=vsppDiscIn, vrtpNoBuffersOut=vrtpNoBuffersOut, vrtpNonSeqBdcstIn=vrtpNonSeqBdcstIn, vlogsTable=vlogsTable, ssMsgsIn=ssMsgsIn, osBswpOutRate=osBswpOutRate, vrtpNbrAnchors=vrtpNbrAnchors, osBuffWrRate=osBuffWrRate, osWIOUsagePct=osWIOUsagePct, vsppConnsCfg=vsppConnsCfg, ssProcType=ssProcType, vsBadLoginDialin=vsBadLoginDialin, tpConnId=tpConnId, msCompressFail=msCompressFail, nmSockInUseHighThres=nmSockInUseHighThres, tpMailSender=tpMailSender, tp162errThresHigh=tp162errThresHigh, fsTotCache=fsTotCache, osPWrites=osPWrites, mlMBTableMBOwner=mlMBTableMBOwner, nmTKRingSigLoss=nmTKRingSigLoss, ssSystemDate=ssSystemDate, osFreeMemoryTotal=osFreeMemoryTotal, ssNoMemory=ssNoMemory, osMounts=osMounts, vinesmibs=vinesmibs, vifAddress=vifAddress, vsppDiscOut=vsppDiscOut, vrtpNbrSubNetid=vrtpNbrSubNetid, oscpuNum=oscpuNum, nmCommBuffHighThres=nmCommBuffHighThres, nmInodesHigh=nmInodesHigh, osOutSwaps=osOutSwaps, vrtpRqstsIn=vrtpRqstsIn, vrtpLkUp=vrtpLkUp, osSwapSpaceAvailable=osSwapSpaceAvailable, msMasquerade=msMasquerade, nmFreeMemLowThres=nmFreeMemLowThres, vrtpRtTable=vrtpRtTable, amsLogFileIndex=amsLogFileIndex, nmCacheHits_Low=nmCacheHits_Low, tpErrorCode=tpErrorCode, osSwapSpaceUsed=osSwapSpaceUsed, vsNoSpace=vsNoSpace, cpuWIOUsage=cpuWIOUsage, vsppNoPort=vsppNoPort, vrtpResyncIn=vrtpResyncIn, vrtpNonSeqRqstIn=vrtpNonSeqRqstIn, ssTimeSet=ssTimeSet, vipRouted=vipRouted, tpFXmtd=tpFXmtd, vipFrags=vipFrags, tpOldSerNum=tpOldSerNum, osSemOps=osSemOps, vrtpRtIdle=vrtpRtIdle, stAddedGrp=stAddedGrp, osWrtFault=osWrtFault, vrtpRedirOut=vrtpRedirOut, nmLnkDropsHigh=nmLnkDropsHigh, afpSessDiscon=afpSessDiscon, nmLoadAvgHigh=nmLoadAvgHigh, dskEntry=dskEntry, tpSvrName=tpSvrName, vifTable=vifTable, nmDropsHigh=nmDropsHigh, nmTKRingRmvHardErr=nmTKRingRmvHardErr, svcNumber=svcNumber, dskNumber=dskNumber, vifEntry=vifEntry, dskUtil=dskUtil, msMBoxFull=msMBoxFull, vlogsDescr=vlogsDescr, vrtpBdcstIn=vrtpBdcstIn, cpuProcSwappedOut=cpuProcSwappedOut, dskName=dskName, psOffline=psOffline, psPapError=psPapError, vrtpRedirIn=vrtpRedirIn, vifOutPkts=vifOutPkts, osBWrites=osBWrites, vip=vip, svcUserSvcName=svcUserSvcName, mlMBTableUnreadMsgs=mlMBTableUnreadMsgs, tpLineNum=tpLineNum, vrtpFragsBadOut=vrtpFragsBadOut, vrtpRtEntry=vrtpRtEntry, vifX25VCBytesIn=vifX25VCBytesIn, vifX25VCSlot=vifX25VCSlot, ssLoadAvg5=ssLoadAvg5, osIdleUsagePct=osIdleUsagePct, tpJobTotal=tpJobTotal, nmDiskBusyHighThres=nmDiskBusyHighThres, fsOpensOnFiles=fsOpensOnFiles, vsppDataIn=vsppDataIn, afpAtalkDown=afpAtalkDown, vifLnkTotIn=vifLnkTotIn, mib1=mib1, vrtpNbrEntries=vrtpNbrEntries, svcName=svcName, vrtpFragsDoneIn=vrtpFragsDoneIn, tpPortId=tpPortId, vrtpRqstLkUpOut=vrtpRqstLkUpOut, ssPanicDBWrite=ssPanicDBWrite, svcMsgsOut=svcMsgsOut, vsSDBInconsist=vsSDBInconsist, vifX25VCPktsAwaitAck=vifX25VCPktsAwaitAck, svcLocIn=svcLocIn, nmAllocFail_High=nmAllocFail_High, fsMaxRecLocks=fsMaxRecLocks, osInSwaps=osInSwaps, amsLogEntry=amsLogEntry, svcIndex=svcIndex, dskAvgService=dskAvgService, svcUserIndex=svcUserIndex, vrtpRtCr=vrtpRtCr, vsppConnsInUse=vsppConnsInUse, vifLnkOvers=vifLnkOvers, vrtpRtNetid=vrtpRtNetid, amsRegPort=amsRegPort, psQueueFull=psQueueFull, osRdCachePct=osRdCachePct, nmFreeSwapLow=nmFreeSwapLow, vifX25VCTotOut=vifX25VCTotOut, vrtpNbrLocLine=vrtpNbrLocLine, osMaxInodes=osMaxInodes, psFormUnavail=psFormUnavail, osCurrentProcesses=osCurrentProcesses, cpuSysUsage=cpuSysUsage, svcUserSvcIndex=svcUserSvcIndex, osPReads=osPReads, svcStatus=svcStatus, stDupGrp=stDupGrp, mib2=mib2)
mibBuilder.exportSymbols("VINES-MIB", osSystemExec=osSystemExec, mlMBTableTotalMsgs=mlMBTableTotalMsgs, vrtpReassBadIn=vrtpReassBadIn, fsPctCacheHits=fsPctCacheHits, vifLnkSlot=vifLnkSlot, vifX25VCResetsIn=vifX25VCResetsIn, vrtpNoBuffersIn=vrtpNoBuffersIn, osBswpInRate=osBswpInRate, amsLogIdTid=amsLogIdTid, osSysCallRate=osSysCallRate, osMaxFiles=osMaxFiles, commSocksInUse=commSocksInUse, osSwitchRate=osSwitchRate, svcCpuTime=svcCpuTime, vsBadLoginTime=vsBadLoginTime, vsMaxBadLogins=vsMaxBadLogins, vsNoReachST=vsNoReachST, tpPaperFormat=tpPaperFormat, amsLogRecIndex=amsLogRecIndex, amsRegIdInstance=amsRegIdInstance, vrtp=vrtp, ssUserLicenseCfg=ssUserLicenseCfg, nmDiskBusy=nmDiskBusy, vifType=vifType, vifStatValue=vifStatValue, nmAllocFailHighThres=nmAllocFailHighThres, vrtpNbrSvrName=vrtpNbrSvrName, vrtpNbrType=vrtpNbrType, svcUserName=svcUserName, osMaxProcesses=osMaxProcesses, tpRefSvrName=tpRefSvrName, vrtpFragsBadIn=vrtpFragsBadIn, amsRegEntry=amsRegEntry, amsRegIdTid=amsRegIdTid, msBMSPanic=msBMSPanic, stCoreDump=stCoreDump, fsMaxOpenFiles=fsMaxOpenFiles, dskIndex=dskIndex, vifX25VCPktsOut=vifX25VCPktsOut, vsppAcksIn=vsppAcksIn, vrtpNetInfoBad=vrtpNetInfoBad, vifSlot=vifSlot, osBuffRdRate=osBuffRdRate, vrtpBdcstOut=vrtpBdcstOut, vsBadLoginPhysLoc=vsBadLoginPhysLoc, vifLnkDrops=vifLnkDrops, nmFreeMemLow=nmFreeMemLow, ssSvcNoStart=ssSvcNoStart, vrtpFragsDupIn=vrtpFragsDupIn, vrtpBadLkUp=vrtpBadLkUp, vrtpNonSeqErrsIn=vrtpNonSeqErrsIn, vlogsEntry=vlogsEntry, vrtpNetEntries=vrtpNetEntries, vifLnkRetrans=vifLnkRetrans, commMaxOpenSocks=commMaxOpenSocks, vipTotIn=vipTotIn, vifInErrs=vifInErrs, cpuWSUsage=cpuWSUsage, nmTKRingRmvMacFrame=nmTKRingRmvMacFrame, ssLoadAvg15=ssLoadAvg15, commBufUsage=commBufUsage, osUserUsagePct=osUserUsagePct, vsppNoBuffers=vsppNoBuffers, nmLnkReTXHigh=nmLnkReTXHigh, vsppMaxConns=vsppMaxConns, nmSwapAvgHigh=nmSwapAvgHigh, psPsPrinterErr=psPsPrinterErr, vifInPkts=vifInPkts, ssSwRev=ssSwRev, svcMsgsIn=svcMsgsIn, vrtpRtMod=vrtpRtMod, oscpuEntry=oscpuEntry, psUserNoAuth=psUserNoAuth, tpGrpLimit=tpGrpLimit, dskStatus=dskStatus, vrtpRtGateNetid=vrtpRtGateNetid, osIOBufs=osIOBufs, vrtpNonSeqBdcstOut=vrtpNonSeqBdcstOut, vifStatSlot=vifStatSlot, vipBadLength=vipBadLength, osUserMaxFp=osUserMaxFp, bsSysBkUpFailed=bsSysBkUpFailed, vifX25VCRemAddr=vifX25VCRemAddr, vifLnkLine=vifLnkLine, tpLnkDropsThres=tpLnkDropsThres, nmTKRingOpen=nmTKRingOpen, dskAvgWait=dskAvgWait, dskSizeMB=dskSizeMB, commTotBufs=commTotBufs, vrtpFragsDoneOut=vrtpFragsDoneOut, vrtpNbrIfType=vrtpNbrIfType, vrtpResponsesIn=vrtpResponsesIn, vrtpNbrNetid=vrtpNbrNetid, fsMaxOpensOnFiles=fsMaxOpensOnFiles, nmDropsHighThres=nmDropsHighThres, vipFromDodIP=vipFromDodIP, vipBad=vipBad, osInBSwaps=osInBSwaps, osUserMaxPu=osUserMaxPu, nmDiskFull=nmDiskFull, svcUserTable=svcUserTable, commSocksCfg=commSocksCfg, vsNoSessAvail=vsNoSessAvail, commresources=commresources, ssSystemUptime=ssSystemUptime, vsppProbesOut=vsppProbesOut, ssName=ssName, daSCoreDump=daSCoreDump, vifX25VCOutErrs=vifX25VCOutErrs, vrtpRtNumber=vrtpRtNumber, vrtpBadNonSeqRdrIn=vrtpBadNonSeqRdrIn, ssSwapAvg=ssSwapAvg, psJobReject=psJobReject, osBReads=osBReads, msMTAPanic=msMTAPanic, svcLocOut=svcLocOut, vifLnkUnders=vifLnkUnders, nmInodeUseHighThres=nmInodeUseHighThres, vrtpNonSeqRdrOut=vrtpNonSeqRdrOut, svcEntry=svcEntry, osSwapQueueOcc=osSwapQueueOcc, vifLnkEntry=vifLnkEntry, vsPCDialInit=vsPCDialInit, nmSwapSpaceLowThres=nmSwapSpaceLowThres, nmDiskUseHighThres=nmDiskUseHighThres, vrtpFragsDropIn=vrtpFragsDropIn, vrtpTotOut=vrtpTotOut, osSystemWrite=osSystemWrite, nmProcsHigh=nmProcsHigh, vsNoSTLogin=vsNoSTLogin, vifX25VCTable=vifX25VCTable, osSysUsagePct=osSysUsagePct, osIPCMsgOps=osIPCMsgOps, tpUserName=tpUserName, vrtpResyncOut=vrtpResyncOut, vifX25VCEntry=vifX25VCEntry, tpNewSerNum=tpNewSerNum, osRunOccPct=osRunOccPct, vsppAcksOut=vsppAcksOut, amsRegAction=amsRegAction, tpSockOvFlowNum=tpSockOvFlowNum, stGrpLimit=stGrpLimit, ssMsgsOut=ssMsgsOut, ssProdDescr=ssProdDescr, bsIncBkUpFailed=bsIncBkUpFailed, vrtpNonSeqTotOut=vrtpNonSeqTotOut, cpuIdleUsage=cpuIdleUsage, osProcessSwitches=osProcessSwitches, svcCategory=svcCategory, vrtpNbrTable=vrtpNbrTable, nmthresholds=nmthresholds, vsppDataOut=vsppDataOut, ssSvcRecrashed=ssSvcRecrashed, vipBcastHWM=vipBcastHWM, osSwapOccPct=osSwapOccPct, ssNoReconnVS=ssNoReconnVS, dskResp=dskResp, dskPctBusy=dskPctBusy, vsppProbesIn=vsppProbesIn, ssMsgAvg1=ssMsgAvg1, vrtpReinitOut=vrtpReinitOut, fsOpenFiles=fsOpenFiles, tp162erravg=tp162erravg, tpMailMessageId=tpMailMessageId, vinterfaces=vinterfaces, vifLnkNumber=vifLnkNumber, vifDescr=vifDescr, ams=ams, ssProdType=ssProdType, svcLogMask=svcLogMask, dskTable=dskTable, bsSvcBkUpFailed=bsSvcBkUpFailed, dskNOperations=dskNOperations, fsRecLocks=fsRecLocks, mlMailBoxTableEntry=mlMailBoxTableEntry, vifLnkFrmErrs=vifLnkFrmErrs, ssSvcCrashed=ssSvcCrashed, vrtpRtGateSvrName=vrtpRtGateSvrName, vrtpNonSeqRspIn=vrtpNonSeqRspIn, vsPCDialTerm=vsPCDialTerm, vrtpNbrLocSlot=vrtpNbrLocSlot, stDeletedGrp=stDeletedGrp, vipNoBuffers=vipNoBuffers, ssBadSvcDB=ssBadSvcDB, mlMailBoxTable=mlMailBoxTable, nmTKRingHardErr=nmTKRingHardErr, amsRegIdClass=amsRegIdClass, ssDying=ssDying, svcSPPs=svcSPPs, dskBlkSize=dskBlkSize, osWrCachePct=osWrCachePct, ssPanicWait=ssPanicWait, svcUserEntry=svcUserEntry, vipTotOut=vipTotOut, tpLnkReXtThres=tpLnkReXtThres, os=os, vsppBadType=vsppBadType, osCurrentInodes=osCurrentInodes, svcActSess=svcActSess, cpuWPIOUsage=cpuWPIOUsage, osSwapQueueTotals=osSwapQueueTotals, stSerialNum=stSerialNum, fsCacheUnavail=fsCacheUnavail, st162Errs=st162Errs, svcUpTime=svcUpTime, filesystem=filesystem, vifX25VCNumber=vifX25VCNumber, commAllocsFailed=commAllocsFailed, vsppInErrs=vsppInErrs, vsppDups=vsppDups, vrtpUpdatesIn=vrtpUpdatesIn, tpRefSvcName=tpRefSvcName, psAtalkErr=psAtalkErr, ssRealMemory=ssRealMemory, amsRegWhoAdded=amsRegWhoAdded, amsLogIdClass=amsLogIdClass, ssPowerFail=ssPowerFail, vsppLocal=vsppLocal, tpSubNetId=tpSubNetId, nmSockInUseHigh=nmSockInUseHigh, vipRoutedHWM=vipRoutedHWM, vifStatsList=vifStatsList, ssOsRev=ssOsRev, vrtpRqstLkUpIn=vrtpRqstLkUpIn, amsLogAlertString=amsLogAlertString, vsppAbortsOut=vsppAbortsOut, dskDemand=dskDemand, osLWrites=osLWrites, tpAlertTime=tpAlertTime, vipTooSmall=vipTooSmall, vifX25VCInErrs=vifX25VCInErrs, osSystemCalls=osSystemCalls, dskNMisc=dskNMisc, vrtpBadRdrs=vrtpBadRdrs, msDiskFull=msDiskFull, vrtpResponsesOut=vrtpResponsesOut, tpJobId=tpJobId, ssSystemStatus=ssSystemStatus, osinfo=osinfo, dskUsedPct=dskUsedPct)

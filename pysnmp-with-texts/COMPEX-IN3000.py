#
# PySNMP MIB module COMPEX-IN3000 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/COMPEX-IN3000
# Produced by pysmi-0.3.4 at Wed May  1 12:26:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, Gauge32, Counter64, NotificationType, MibIdentifier, TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Bits, iso, enterprises, ModuleIdentity, Unsigned32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "Counter64", "NotificationType", "MibIdentifier", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Bits", "iso", "enterprises", "ModuleIdentity", "Unsigned32", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
compex = MibIdentifier((1, 3, 6, 1, 4, 1, 426))
in3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1))
hubTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 1))
tp3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 1, 1))
rp3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 1, 2))
productInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 2))
productName = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productName.setStatus('mandatory')
if mibBuilder.loadTexts: productName.setDescription('The textual description of the IN3000.')
productVersion = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productVersion.setStatus('mandatory')
if mibBuilder.loadTexts: productVersion.setDescription('The version of the IN3000 Firmware.')
releasedDate = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: releasedDate.setStatus('mandatory')
if mibBuilder.loadTexts: releasedDate.setDescription('The release date of this version.')
compexAddress = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: compexAddress.setStatus('mandatory')
if mibBuilder.loadTexts: compexAddress.setDescription('Address of Compex, Inc.')
compexPhone = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: compexPhone.setStatus('mandatory')
if mibBuilder.loadTexts: compexPhone.setDescription("Compex's phone number for technical support or sales information.")
compexImage = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: compexImage.setStatus('mandatory')
if mibBuilder.loadTexts: compexImage.setDescription('Information on the system setup. This string is not in a human readable form.')
compexMyAccess = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: compexMyAccess.setStatus('mandatory')
if mibBuilder.loadTexts: compexMyAccess.setDescription('This tells you the access you have with the community string you are using.')
devTeamTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 2, 8), )
if mibBuilder.loadTexts: devTeamTable.setStatus('mandatory')
if mibBuilder.loadTexts: devTeamTable.setDescription('This is a list of the Compex development team.')
devTeamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 2, 8, 1), ).setIndexNames((0, "COMPEX-IN3000", "cpId"))
if mibBuilder.loadTexts: devTeamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: devTeamEntry.setDescription('Information about a particular person. The index is the cpId of the person.')
cpId = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpId.setStatus('mandatory')
if mibBuilder.loadTexts: cpId.setDescription("This is the development team member's unique identifier number.")
cpName = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 2, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpName.setStatus('mandatory')
if mibBuilder.loadTexts: cpName.setDescription("This is the development team member's name.")
communityInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 3))
communityTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 3, 1), )
if mibBuilder.loadTexts: communityTable.setStatus('mandatory')
if mibBuilder.loadTexts: communityTable.setDescription('A table containing community string information.')
communityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 3, 1, 1), ).setIndexNames((0, "COMPEX-IN3000", "communityInstance"))
if mibBuilder.loadTexts: communityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: communityEntry.setDescription('Information about a particular community string. The instance of the table entries is the communityInstance.')
communityInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: communityInstance.setStatus('mandatory')
if mibBuilder.loadTexts: communityInstance.setDescription(' The table instance. This is the row number of a particular community string in the table.')
communityString = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityString.setStatus('mandatory')
if mibBuilder.loadTexts: communityString.setDescription('The community string. This is defined in RFC 1157. The community string may be up to 10 characters in length.')
communityCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2), ("clear", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityCapability.setStatus('mandatory')
if mibBuilder.loadTexts: communityCapability.setDescription("The capability of the community string. The community string may be valid for different SNMP operations. Setting this object to 'clear' will cause the entry to be cleared out.")
trapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 4))
trapTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 4, 1), )
if mibBuilder.loadTexts: trapTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapTable.setDescription('A table containing trap receiver information.')
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 4, 1, 1), ).setIndexNames((0, "COMPEX-IN3000", "trapDest"))
if mibBuilder.loadTexts: trapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapEntry.setDescription('Information about a particular trap receiver. The instance for this table is the trapDest, or the IP address of the trap receiver. This table may have up to ten entries.')
trapDest = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 4, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDest.setStatus('mandatory')
if mibBuilder.loadTexts: trapDest.setDescription('The trap destination. This is defined in RFC 1157. The trap received should be the IP address of an SNMP based network management system.')
trapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapStatus.setDescription('The trap status. This MIB variable is used to delete a trap receiver from the trap table.')
in3000StatsRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 5))
rptrFifoColls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrFifoColls.setStatus('mandatory')
if mibBuilder.loadTexts: rptrFifoColls.setDescription("The total number of Collision Designators put into the IN3000's FIFO.")
rptrShortWoPort = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrShortWoPort.setStatus('mandatory')
if mibBuilder.loadTexts: rptrShortWoPort.setDescription("The total number of short fragment put into the IN3000's FIFO without a port designator.")
rptrNoStatsDsgntr = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNoStatsDsgntr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNoStatsDsgntr.setDescription("The total number of empty statistic designators put into the IN3000's FIFO.")
rptrInvalidDesgntr = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInvalidDesgntr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrInvalidDesgntr.setDescription("The total number of entries put into the IN3000's FIFO that had invalid designators.")
rptrPortIDwoPacket = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIDwoPacket.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIDwoPacket.setDescription("The total number of entries in the IN3000's FIFO which do not have a corresponding packet in the ethernet controller's RAM buffer.")
rptrOverflows = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: rptrOverflows.setDescription("The total number of times the IN3000's FIFO has overflowed.")
rptrNoFreeBuffers = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNoFreeBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNoFreeBuffers.setDescription('The number of packets received that had to be discarded due to lack of buffers.')
rptrTxTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTxTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrTxTimeouts.setDescription('The total number of times a packet could not be sent before the transmit timer expired.')
rptrNICTxCollisions = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNICTxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNICTxCollisions.setDescription('The total number of collision that occured while the ethernet controller attempted to transmit. This error is reported by the ethernet controller.')
rptrNICTxFifoUruns = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNICTxFifoUruns.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNICTxFifoUruns.setDescription("The total number of times the ethernet controller could not gain access to the ethernet before the ethernet controller's FIFO emptied.")
rptrNICTxCDHrtbts = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNICTxCDHrtbts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNICTxCDHrtbts.setDescription('The number of times the ethernet controlled was unable to transmit a collision signal after transmission of a packet.')
rptrNICTxOutWinCls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNICTxOutWinCls.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNICTxOutWinCls.setDescription('The total number of collisions seen by the ethernet controller that occured after the slot time.')
rptrNICCarrierLost = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrNICCarrierLost.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNICCarrierLost.setDescription('The total number of times a carrier lost was detected by the ethernet controlled during the transmission of a packet.')
rptrInNoRxBuf = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 5, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInNoRxBuf.setStatus('mandatory')
if mibBuilder.loadTexts: rptrInNoRxBuf.setDescription('The total number of times a packet was discarded due to lack of receive buffers.')
in3000StatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 6))
groupOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 6, 1), )
if mibBuilder.loadTexts: groupOctetsTable.setStatus('mandatory')
if mibBuilder.loadTexts: groupOctetsTable.setDescription('This table contains Repeater Group Level octets Statistics.')
groupOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1), ).setIndexNames((0, "COMPEX-IN3000", "gsoGroupIndex"))
if mibBuilder.loadTexts: groupOctetsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: groupOctetsEntry.setDescription('Each row of this table is associated to a TP3000 or RP3000. Note the the groups are numbered from 1 to 4.')
gsoGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsoGroupIndex.setDescription('A unique value to the group. The groups are numbered from 1 to 4. The addresses set via the dip switches on the TP3000 and RP3000 are numbered 0 to 3. In order to calculate the group number add one (1) to the address set via the TP3000 or RP3000 dip switches.')
gsoHostOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoHostOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: gsoHostOctetsRxOk.setDescription('The total number of octets received by all ports in the group that were from valid packets and were addressed to the IN3000.')
gsoHostOctetsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoHostOctetsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: gsoHostOctetsRxErr.setDescription('The total number of octets received by all ports in the group that were from packets with errors and were addressed to the IN3000.')
gsoOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: gsoOctetsRxOk.setDescription('The total number of octets received by all ports in the group that were from valid packets and were no addressed to the IN3000.')
gsoOctetsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoOctetsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: gsoOctetsRxErr.setDescription('The total number of octets received by all ports in the group that were from packets with errors and were not addressed to the IN3000.')
gsobkt64Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt64Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt64Ok.setDescription('The total number of packets received from all ports in the group that were 64 bytes in length (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt64Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt64Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt64Err.setDescription('The total number of packets received from all ports in the group that were 64 bytes in length (including FCS octets and excluding framing bits) and contained errors.')
gsobkt65to127Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt65to127Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt65to127Ok.setDescription('The total number of packets received from all ports in the group that were between 65 bytes and 127 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt65to127Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt65to127Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt65to127Err.setDescription('The total number of packets received from all ports in the group that were between 65 bytes and 127 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
gsobkt128to255Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt128to255Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt128to255Ok.setDescription('The total number of packets received from all ports in the group that were between 128 bytes and 255 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt128to255Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt128to255Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt128to255Err.setDescription('The total number of packets received from all ports in the group that were between 128 bytes and 255 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
gsobkt256to511Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt256to511Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt256to511Ok.setDescription('The total number of packets received from all ports in the group that were between 256 bytes and 511 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt256to511Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt256to511Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt256to511Err.setDescription('The total number of packets received from all ports in the group that were between 256 bytes and 511 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
gsobkt512to1023Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt512to1023Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt512to1023Ok.setDescription('The total number of packets received from all ports in the group that were between 512 bytes and 1023 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt512to1023Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt512to1023Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt512to1023Err.setDescription('The total number of packets received from all ports in the group that were between 512 bytes and 1023 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
gsobkt1024to1518Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt1024to1518Ok.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt1024to1518Ok.setDescription('The total number of packets received from all ports in the group that were between 1024 bytes and 1518 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
gsobkt1024to1518Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsobkt1024to1518Err.setStatus('mandatory')
if mibBuilder.loadTexts: gsobkt1024to1518Err.setDescription('The total number of packets received from all ports in the group that were between 1024 bytes and 1518 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
gsoRuntPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoRuntPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: gsoRuntPacketsOk.setDescription('The total number of packets received from all ports in the group that were less than 64 bytes, and did not contain any other errors.')
gsoRuntPacketsErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoRuntPacketsErr.setStatus('mandatory')
if mibBuilder.loadTexts: gsoRuntPacketsErr.setDescription('The total number of packets reveived from all ports in the group that were less than 64 bytes and contained errors.')
gsoPacketsTooBigOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoPacketsTooBigOk.setStatus('mandatory')
if mibBuilder.loadTexts: gsoPacketsTooBigOk.setDescription('The total number of packets reveived from all ports in the group that were larger than 1518 bytes, and did not contain any other errors.')
gsoPacketsTooBigErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsoPacketsTooBigErr.setStatus('mandatory')
if mibBuilder.loadTexts: gsoPacketsTooBigErr.setDescription('The total number of packets reveived from all ports in the group that were larger than 1518 bytes, and contained other errors.')
groupPacketTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 6, 2), )
if mibBuilder.loadTexts: groupPacketTable.setStatus('mandatory')
if mibBuilder.loadTexts: groupPacketTable.setDescription('This table contains Repeater Group Level Packet Statistics.')
groupPacketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1), ).setIndexNames((0, "COMPEX-IN3000", "gspGroupIndex"))
if mibBuilder.loadTexts: groupPacketEntry.setStatus('mandatory')
if mibBuilder.loadTexts: groupPacketEntry.setDescription('Each row of this table is associated to a TP3000 or RP3000. Note the the groups are numbered from 1 to 4.')
gspGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gspGroupIndex.setDescription('A unique value to the group. The groups are numbered from 1 to 4. The addresses set via the dip switches on the TP3000 and RP3000 are numbered 0 to 3. In order to calculate the group number add one (1) to the address set via the dip switches.')
gspPacketsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspPacketsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: gspPacketsRxOk.setDescription('The total number of packet received by all ports in the group that were valid packets.')
gspPacketsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspPacketsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: gspPacketsRxErr.setDescription('The total number of packet received by all ports in the group that were packets with errors.')
gspPhysicalOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspPhysicalOk.setStatus('mandatory')
if mibBuilder.loadTexts: gspPhysicalOk.setDescription('The total number of packets received from all ports in the group that were unicast packets and were valid packets.')
gspPhysicalErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspPhysicalErr.setStatus('mandatory')
if mibBuilder.loadTexts: gspPhysicalErr.setDescription('The total number of packets received from all ports in the group that were unicast packets and were packets with errors.')
gspMulticastOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspMulticastOk.setStatus('mandatory')
if mibBuilder.loadTexts: gspMulticastOk.setDescription('The total number of packets received from all ports in the group that were multicast packets and were valid packets.')
gspMulticastErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspMulticastErr.setStatus('mandatory')
if mibBuilder.loadTexts: gspMulticastErr.setDescription('The total number of packets received from all ports in the group that were multicast packets and were packets with errors.')
gspBroadcastOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspBroadcastOk.setStatus('mandatory')
if mibBuilder.loadTexts: gspBroadcastOk.setDescription('The total number of packets received from all ports in the group that were broadcast packets and were valid packets.')
gspBroadcastErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspBroadcastErr.setStatus('mandatory')
if mibBuilder.loadTexts: gspBroadcastErr.setDescription('The total number of packets received from all ports in the group that were broadcast packets and were packets with errors.')
gspHostPhysicalOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspHostPhysicalOk.setStatus('mandatory')
if mibBuilder.loadTexts: gspHostPhysicalOk.setDescription('The total number of packets received from all ports in the group that were unicast packets, addressed to the IN3000 and did not have errors.')
gspHostPhysicalErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gspHostPhysicalErr.setStatus('mandatory')
if mibBuilder.loadTexts: gspHostPhysicalErr.setDescription('The total number of packets received from all ports in the group that were unicast packets, addressed to the IN3000 and had errors.')
groupMiscTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 6, 3), )
if mibBuilder.loadTexts: groupMiscTable.setStatus('mandatory')
if mibBuilder.loadTexts: groupMiscTable.setDescription('This table contains Repeater Group Level Statistics.')
groupMiscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1), ).setIndexNames((0, "COMPEX-IN3000", "gsmGroupIndex"))
if mibBuilder.loadTexts: groupMiscEntry.setStatus('mandatory')
if mibBuilder.loadTexts: groupMiscEntry.setDescription('Each row of this table is associated to a TP3000 or RP3000. Note the the groups are numbered from 1 to 4.')
gsmGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gsmGroupIndex.setDescription('A unique value to the group. The groups are numbered from 1 to 4. The addresses set via the dip switches on the TP3000 and RP3000 are numbered 0 to 3. In order to calculate the group number add one (1) to the address set via the dip switches.')
gsmNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: gsmNumPorts.setDescription('The total number of ports contained in the group.')
gsmName = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gsmName.setStatus('mandatory')
if mibBuilder.loadTexts: gsmName.setDescription('The name of the group.')
gsmType = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tp3000", 1), ("rp3000", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmType.setStatus('mandatory')
if mibBuilder.loadTexts: gsmType.setDescription('The microhub type.')
gsmNumLinkUp = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmNumLinkUp.setStatus('mandatory')
if mibBuilder.loadTexts: gsmNumLinkUp.setDescription('The total number of ports in the group that have link status.')
gsmNumLinkPulses = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmNumLinkPulses.setStatus('mandatory')
if mibBuilder.loadTexts: gsmNumLinkPulses.setDescription('The total number of ports in the group that have link pulses enabled.')
gsmCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCollisions.setDescription('The total number of collisions detected by all ports in the group.')
gsmLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: gsmLateCollisions.setDescription('The total number of late collisions detected by all ports in the group.')
gsmPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: gsmPartitions.setDescription('The total number of partitions from all ports in the group.')
gsmJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: gsmJabbers.setDescription('The total number of frames from all port in the group that were longer than 1518 bytes, and had a non integral number of bytes or a bad frame check sequence (FCS).')
gsmShortFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmShortFragments.setStatus('mandatory')
if mibBuilder.loadTexts: gsmShortFragments.setDescription('Total number of packets from all ports in the group that were less than 64 bytes, and had a non-integral number of octets or had a bad frame check sequence (FCS).')
gsmCrcFae = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCrcFae.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCrcFae.setDescription('The total number of packets reveived from all ports in the group that had frame alignment errors. Since there was a frame alignment error the packet also had a bad CRC.')
gsmCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmCrc.setStatus('mandatory')
if mibBuilder.loadTexts: gsmCrc.setDescription('The total number of packets received from all ports in the group that did not have a frame alignment error, but they had a bad CRC.')
gsmFifoOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmFifoOverrun.setStatus('mandatory')
if mibBuilder.loadTexts: gsmFifoOverrun.setDescription('The total number of packets reveived from all port in the group that caused the ethernet controlled to overrun its FIFO.')
gsmDeferring = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 6, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmDeferring.setStatus('mandatory')
if mibBuilder.loadTexts: gsmDeferring.setDescription('The total number of packets from all ports in the group that caused the ethernet controller to detect a jabber.')
in3000StatsPort = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 7))
portOctetsTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 7, 1), )
if mibBuilder.loadTexts: portOctetsTable.setStatus('mandatory')
if mibBuilder.loadTexts: portOctetsTable.setDescription('This table contains octet statistics that deal with the TP3000 and RP3000 ports.')
portOctetsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1), ).setIndexNames((0, "COMPEX-IN3000", "psoGroupIndex"), (0, "COMPEX-IN3000", "psoPortIndex"))
if mibBuilder.loadTexts: portOctetsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portOctetsEntry.setDescription('Each row in this table is associated with a port in a TP3000 or RP3000. Note that groups are numbered 1 to 4 and ports are numbered 1 to 7. The row instance is made up of the group number and the port number.')
psoGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psoGroupIndex.setDescription('The group that this port resides in. The groups are numbered 1 to 4.')
psoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psoPortIndex.setDescription('The port number of this port. Note that the ports are numbered 1 to 7. For the TP3000 the twisted pair ports are numbered 1 to 6 and the remaining ethernet port (either 10base2 or AUI) is port 7.')
psoHostOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoHostOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: psoHostOctetsRxOk.setDescription('The total number of octets received on this port that were from packets without errors and were addressed to the IN3000.')
psoHostOctetsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoHostOctetsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: psoHostOctetsRxErr.setDescription('The total number of octets received on this port that were from packets with errors and were addressed to the IN3000.')
psoOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: psoOctetsRxOk.setDescription('The total number of octets received on this port that were from packets without errors.')
psoOctetsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoOctetsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: psoOctetsRxErr.setDescription('The total number of octets received on this port that were from packets with errors.')
psobkt64Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt64Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt64Ok.setDescription('The total number of packets receive by this port that were 64 bytes in length (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt64Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt64Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt64Err.setDescription('The total number of packets receive by this port that were 64 bytes in length (including FCS octets and excluding framing bits) and contained errors.')
psobkt65to127Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt65to127Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt65to127Ok.setDescription('The total number of packets receive by this port that were between 65 and 127 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt65to127Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt65to127Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt65to127Err.setDescription('The total number of packets receive by this port that were between 65 and 127 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
psobkt128to255Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt128to255Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt128to255Ok.setDescription('The total number of packets receive by this port that were between 128 and 255 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt128to255Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt128to255Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt128to255Err.setDescription('The total number of packets receive by this port that were between 128 and 255 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
psobkt256to511Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt256to511Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt256to511Ok.setDescription('The total number of packets receive by this port that were between 256 and 511 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt256to511Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt256to511Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt256to511Err.setDescription('The total number of packets receive by this port that were between 256 and 511 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
psobkt512to1023Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt512to1023Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt512to1023Ok.setDescription('The total number of packets receive by this port that were between 512 and 1023 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt512to1023Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt512to1023Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt512to1023Err.setDescription('The total number of packets receive by this port that were between 512 and 1023 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
psobkt1024to1518Ok = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt1024to1518Ok.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt1024to1518Ok.setDescription('The total number of packets receive by this port that were between 1024 and 1518 bytes in length inclusive (including FCS octets and excluding framing bits) and did not contain errors.')
psobkt1024to1518Err = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psobkt1024to1518Err.setStatus('mandatory')
if mibBuilder.loadTexts: psobkt1024to1518Err.setDescription('The total number of packets receive by this port that were between 1024 and 1518 bytes in length inclusive (including FCS octets and excluding framing bits) and contained errors.')
psoRuntPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoRuntPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: psoRuntPacketsOk.setDescription('The total number of packets received by this port that were less than 64 bytes, but contained no other errors.')
psoRuntPacketsErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoRuntPacketsErr.setStatus('mandatory')
if mibBuilder.loadTexts: psoRuntPacketsErr.setDescription('The total number of packets received by this port that were less than 64 bytes, and contained other errors.')
psoPacketsTooBigOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoPacketsTooBigOk.setStatus('mandatory')
if mibBuilder.loadTexts: psoPacketsTooBigOk.setDescription('The total number of packets received by this port that were greater than 1518 bytes, but contained no other errors.')
psoPacketsTooBigErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psoPacketsTooBigErr.setStatus('mandatory')
if mibBuilder.loadTexts: psoPacketsTooBigErr.setDescription('The total number of packets received by this port that were greater than 1518 bytes, and contained other errors.')
portPacketTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 7, 2), )
if mibBuilder.loadTexts: portPacketTable.setStatus('mandatory')
if mibBuilder.loadTexts: portPacketTable.setDescription('This table contains statistics that deal with the TP3000 and RP3000 ports.')
portPacketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1), ).setIndexNames((0, "COMPEX-IN3000", "pspGroupIndex"), (0, "COMPEX-IN3000", "pspPortIndex"))
if mibBuilder.loadTexts: portPacketEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portPacketEntry.setDescription('Each row in this table is associated with a port in a TP3000 or RP3000. Note that groups are numbered 1 to 4 and ports are numbered 1 to 7. The row instance is made up of the group number and the port number.')
pspGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pspGroupIndex.setDescription('The group that this port resides in. The groups are numbered 1 to 4.')
pspPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pspPortIndex.setDescription('The port number of this port. Note that the ports are numbered 1 to 7. For the TP3000 the twisted pair ports are numbered 1 to 6 and the remaining ethernet port (either 10base2 or AUI) is port 7.')
pspPacketsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspPacketsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: pspPacketsRxOk.setDescription('The total number of packets received on this port that did no have any errors.')
pspPacketsRxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspPacketsRxErr.setStatus('mandatory')
if mibBuilder.loadTexts: pspPacketsRxErr.setDescription('The total number of packets received on this port that had errors.')
pspPhysicalOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspPhysicalOk.setStatus('mandatory')
if mibBuilder.loadTexts: pspPhysicalOk.setDescription('The total number of unicast packets received on this port that did not have any errors.')
pspPhysicalErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspPhysicalErr.setStatus('mandatory')
if mibBuilder.loadTexts: pspPhysicalErr.setDescription('The total number of unicast packets received on this port that had errors.')
pspMulticastOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspMulticastOk.setStatus('mandatory')
if mibBuilder.loadTexts: pspMulticastOk.setDescription('The total number of multicast packets received on this port that did no have any errors.')
pspMulticastErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspMulticastErr.setStatus('mandatory')
if mibBuilder.loadTexts: pspMulticastErr.setDescription('The total number of multicast packets received on this port that have errors.')
pspBroadcastOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspBroadcastOk.setStatus('mandatory')
if mibBuilder.loadTexts: pspBroadcastOk.setDescription('The total number of broadcast packets that were received by this port and had no errors.')
pspBroadcastErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspBroadcastErr.setStatus('mandatory')
if mibBuilder.loadTexts: pspBroadcastErr.setDescription('The total number of broadcast packets that were received by this port and had errors.')
pspHostPhysicalOk = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspHostPhysicalOk.setStatus('mandatory')
if mibBuilder.loadTexts: pspHostPhysicalOk.setDescription('The total number of unicast packets received by this port that were addressed to the IN3000 and had no errors.')
pspHostPhysicalErr = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pspHostPhysicalErr.setStatus('mandatory')
if mibBuilder.loadTexts: pspHostPhysicalErr.setDescription('The total number of unicast packets received by this port that were addressed to the IN3000 and had errors.')
portMiscTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 7, 3), )
if mibBuilder.loadTexts: portMiscTable.setStatus('mandatory')
if mibBuilder.loadTexts: portMiscTable.setDescription('This table contains statistics that deal with the TP3000 and RP3000 ports.')
portMiscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1), ).setIndexNames((0, "COMPEX-IN3000", "psmGroupIndex"), (0, "COMPEX-IN3000", "psmPortIndex"))
if mibBuilder.loadTexts: portMiscEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portMiscEntry.setDescription('Each row in this table is associated with a port in a TP3000 or RP3000. Note that groups are numbered 1 to 4 and ports are numbered 1 to 7. The row instance is made up of the group number and the port number.')
psmGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psmGroupIndex.setDescription('The group that this port resides in. The groups are numbered 1 to 4.')
psmPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psmPortIndex.setDescription('The port number of this port. Note that the ports are numbered 1 to 7. For the TP3000 the twisted pair ports are numbered 1 to 6 and the remaining ethernet port (either 10base2 or AUI) is port 7.')
psmName = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psmName.setStatus('mandatory')
if mibBuilder.loadTexts: psmName.setDescription('The name assigned to this port.')
psmType = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tenBaseT", 1), ("aui-bnc", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmType.setStatus('mandatory')
if mibBuilder.loadTexts: psmType.setDescription('The port type.')
psmLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unsupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: psmLinkState.setDescription('The link state of the port. Note that if link pulses are disabled then the link state will be up.')
psmLinkPulses = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("unsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psmLinkPulses.setStatus('mandatory')
if mibBuilder.loadTexts: psmLinkPulses.setDescription('This variable is used to check or set whether this port has link pulses enabled.')
psmCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: psmCollisions.setDescription('The total number of collisions that were received by this port.')
psmLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: psmLateCollisions.setDescription('The total number of late collisions that were received by this port.')
psmPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: psmPartitions.setDescription('The total number of times this port entered the partitioned state.')
psmJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: psmJabbers.setDescription('The total number of frames received by this port that were longer than 1518 bytes, and had a non- integral number of octets or had a bad frame check sequence (FCS).')
psmShortFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmShortFragments.setStatus('mandatory')
if mibBuilder.loadTexts: psmShortFragments.setDescription('The total number of frames received by this port that were less than 64 bytes, and had a non- integral number of octets or had a bad frame check sequence (FCS).')
psmCrcFae = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmCrcFae.setStatus('mandatory')
if mibBuilder.loadTexts: psmCrcFae.setDescription('The total number of packets reveived by this port that had frame alignment errors. Since there was a frame alignment error the packet also had a bad CRC.')
psmCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmCrc.setStatus('mandatory')
if mibBuilder.loadTexts: psmCrc.setDescription('The total number of packets reveived by this port that did not have frame alignment errors but had a bad CRC.')
psmFifoOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmFifoOverrun.setStatus('mandatory')
if mibBuilder.loadTexts: psmFifoOverrun.setDescription('The total number of packets reveived by this port that caused the ethernet controlled to overrun its FIFO.')
psmDeferring = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 7, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psmDeferring.setStatus('mandatory')
if mibBuilder.loadTexts: psmDeferring.setDescription('The total number of packets received by this port the caused the ethernet controller to detect a jabber.')
in3000StatsMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 8))
initHeapSize = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: initHeapSize.setStatus('mandatory')
if mibBuilder.loadTexts: initHeapSize.setDescription('The initial heap memory size in bytes.')
usedHeap = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usedHeap.setStatus('mandatory')
if mibBuilder.loadTexts: usedHeap.setDescription('Amount of heap memory in use in bytes.')
freeHeap = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeHeap.setStatus('mandatory')
if mibBuilder.loadTexts: freeHeap.setDescription('Amount of free heap memory in bytes.')
heapStatus = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("notOk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: heapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: heapStatus.setDescription('The status of the heap. A notOk(2) response means the heap has been corrupted, and an ok(1) reponse means the heap is OK. The heap check is preformed at the time of memory coalescing and not on demand. Therefore, the value of the variable may not match the current state of the heap. If you wish to have the heap checked on demand please use the heapTest variable to preform this test.')
mallocCalls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mallocCalls.setDescription('Number of times malloc() has been called.')
reallocCalls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reallocCalls.setStatus('mandatory')
if mibBuilder.loadTexts: reallocCalls.setDescription('Number of times realloc() has been called.')
callocCalls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: callocCalls.setStatus('mandatory')
if mibBuilder.loadTexts: callocCalls.setDescription('Number of times calloc() has been called.')
freeCalls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeCalls.setStatus('mandatory')
if mibBuilder.loadTexts: freeCalls.setDescription('Number of times free() has been called.')
noMemoryAvailable = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: noMemoryAvailable.setDescription('The number of times that there was not enough memory to complete a memory allocation operation.')
mnodeCoalesces = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mnodeCoalesces.setStatus('mandatory')
if mibBuilder.loadTexts: mnodeCoalesces.setDescription('The number of times that the memory manager coalesced mnodes.')
coalesceMemCalls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: coalesceMemCalls.setStatus('mandatory')
if mibBuilder.loadTexts: coalesceMemCalls.setDescription('The number of times that the memory manager was called to coalesced mnodes.')
coalesceThreshold = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 8, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: coalesceThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: coalesceThreshold.setDescription('This variable is used to set the number of free calls before coalescing memory. This change takes effect as soon as the variable is changed.')
in3000StatsIcmp = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 9))
inUnknownTypes = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inUnknownTypes.setStatus('mandatory')
if mibBuilder.loadTexts: inUnknownTypes.setDescription('Number of ICMP packets received with unknown type fields.')
bufferPoolEmpty = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bufferPoolEmpty.setStatus('mandatory')
if mibBuilder.loadTexts: bufferPoolEmpty.setDescription('Number of times an ICMP packet was received and there were not enough available buffers.')
dataBufferTooSmall = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBufferTooSmall.setStatus('mandatory')
if mibBuilder.loadTexts: dataBufferTooSmall.setDescription('Number of times an ICMP packet was received and the data buffer was too small.')
in3000StatsOS = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 10))
threadCreateReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threadCreateReq.setStatus('mandatory')
if mibBuilder.loadTexts: threadCreateReq.setDescription('The number of thread create requests.')
threadCreateOk = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threadCreateOk.setStatus('mandatory')
if mibBuilder.loadTexts: threadCreateOk.setDescription('The number of successful thread creates.')
threadCreateFail = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threadCreateFail.setStatus('mandatory')
if mibBuilder.loadTexts: threadCreateFail.setDescription('The number of unsuccessful thread creates.')
threadTableFull = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threadTableFull.setStatus('mandatory')
if mibBuilder.loadTexts: threadTableFull.setDescription('The number of requests to create a thread that failed because the maximum number of threads were reached.')
threadKill = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threadKill.setStatus('mandatory')
if mibBuilder.loadTexts: threadKill.setDescription('The number of threads that have been killed.')
threadMaximum = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: threadMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: threadMaximum.setDescription('The maximum number of threads that may be created. The set will take effect the next time the IN3000 is initialized.')
defaultStackSize = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultStackSize.setStatus('mandatory')
if mibBuilder.loadTexts: defaultStackSize.setDescription('The default stack size (in bytes) for each thread. The set will take effect the next time the IN3000 is initialized.')
defaultTimeSlice = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultTimeSlice.setStatus('mandatory')
if mibBuilder.loadTexts: defaultTimeSlice.setDescription('The default time slice (in milliseconds) for each thread. The set will take effect the next time the IN3000 is initialized. All newly created threads will get the new time slice.')
bogusInterrupts = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bogusInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: bogusInterrupts.setDescription('The total number of bogus interrupts.')
divideError = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: divideError.setStatus('mandatory')
if mibBuilder.loadTexts: divideError.setDescription('The total number of divide by zero error interrupts.')
singleStep = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: singleStep.setStatus('mandatory')
if mibBuilder.loadTexts: singleStep.setDescription('The total number of single step interrupts.')
breakpoint = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: breakpoint.setStatus('mandatory')
if mibBuilder.loadTexts: breakpoint.setDescription('The total number of break point interrupts.')
interruptOverflow = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interruptOverflow.setStatus('mandatory')
if mibBuilder.loadTexts: interruptOverflow.setDescription('The total number of interrupt overflows.')
arrayBoundsCheck = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arrayBoundsCheck.setStatus('mandatory')
if mibBuilder.loadTexts: arrayBoundsCheck.setDescription('The total number of array bound check interrupts.')
invalidOpcode = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: invalidOpcode.setStatus('mandatory')
if mibBuilder.loadTexts: invalidOpcode.setDescription('Th total number of invalid op code interrupts.')
escapeOpcode = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: escapeOpcode.setStatus('mandatory')
if mibBuilder.loadTexts: escapeOpcode.setDescription('The total number of escape opcode interrupts.')
coprocessorFault = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 10, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: coprocessorFault.setStatus('mandatory')
if mibBuilder.loadTexts: coprocessorFault.setDescription('Th total number of coprocessor fault interrupts.')
threadTable = MibTable((1, 3, 6, 1, 4, 1, 426, 1, 10, 18), )
if mibBuilder.loadTexts: threadTable.setStatus('mandatory')
if mibBuilder.loadTexts: threadTable.setDescription('A table containing the currently running threads.')
threadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1), ).setIndexNames((0, "COMPEX-IN3000", "tid"))
if mibBuilder.loadTexts: threadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: threadEntry.setDescription('Information about a particular thread. The instance of the table entries is the tid.')
tid = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tid.setStatus('mandatory')
if mibBuilder.loadTexts: tid.setDescription('This is the thread identifier. This is the unique number assigned to a thread. This value is also the instance of the table row.')
name = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: name.setStatus('mandatory')
if mibBuilder.loadTexts: name.setDescription("This is the thread's assigned name.")
priority = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priority.setStatus('mandatory')
if mibBuilder.loadTexts: priority.setDescription("This is the thread's priority.")
muxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muxCount.setStatus('mandatory')
if mibBuilder.loadTexts: muxCount.setDescription("This is the thread's mutual exclusion Count.")
status = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("running", 1), ("killed", 2), ("queued", 3), ("blocked", 4), ("dead", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: status.setStatus('mandatory')
if mibBuilder.loadTexts: status.setDescription("This is the thread's status at the time of the SNMP query.")
stackSize = MibTableColumn((1, 3, 6, 1, 4, 1, 426, 1, 10, 18, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackSize.setStatus('mandatory')
if mibBuilder.loadTexts: stackSize.setDescription("This is the thread's stack size.")
in3000StatsArp = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 11))
arpInReqs = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInReqs.setStatus('mandatory')
if mibBuilder.loadTexts: arpInReqs.setDescription('The number of received ARP requests.')
arpInRpls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInRpls.setStatus('mandatory')
if mibBuilder.loadTexts: arpInRpls.setDescription('The number of ARP replies received.')
arpOutReqs = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpOutReqs.setStatus('mandatory')
if mibBuilder.loadTexts: arpOutReqs.setDescription('The number of ARP requests sent.')
arpOutRpls = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpOutRpls.setStatus('mandatory')
if mibBuilder.loadTexts: arpOutRpls.setDescription('The number of ARP replies sent.')
arpGetReqs = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpGetReqs.setStatus('mandatory')
if mibBuilder.loadTexts: arpGetReqs.setDescription('The number of ARP Get requests.')
arpPutReqs = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpPutReqs.setStatus('mandatory')
if mibBuilder.loadTexts: arpPutReqs.setDescription('The number of ARP Put requests.')
arpDeadEntries = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpDeadEntries.setStatus('mandatory')
if mibBuilder.loadTexts: arpDeadEntries.setDescription('The number of dead ARP entries.')
arpCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: arpCacheSize.setDescription('The maximum number of ARP cache entries. Changing this value will take place on next reboot.')
arpEntryTimeout = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 60480))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpEntryTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: arpEntryTimeout.setDescription('The length of time (in seconds) that an ARP entry is stored. If an entry is not accessed within this time period the entry is purged. Changes to this take place immediately.')
arpNumRetries = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpNumRetries.setStatus('mandatory')
if mibBuilder.loadTexts: arpNumRetries.setDescription('The number of ARP request retries before giving up. Changes to this take place after next reboot.')
arpReplyTimeout = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 11, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpReplyTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: arpReplyTimeout.setDescription('The length of time ARP waits for an ARP response. Changes to this take place immediately.')
in3000StatsIp = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 12))
inHdrTooSmall = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHdrTooSmall.setStatus('mandatory')
if mibBuilder.loadTexts: inHdrTooSmall.setDescription('The number of IP packets with headers too small. This is a subset of ipHdrErrors.')
inHdrBadVersion = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHdrBadVersion.setStatus('mandatory')
if mibBuilder.loadTexts: inHdrBadVersion.setDescription('The number of IP packets with Incrrect version information. This is a subset of ipHdrErrors.')
inHdrBadCheckSum = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHdrBadCheckSum.setStatus('mandatory')
if mibBuilder.loadTexts: inHdrBadCheckSum.setDescription('The number of IP packets with invalid checksums. This is a subset of ipHdrErrors.')
inHdrBadOption = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHdrBadOption.setStatus('mandatory')
if mibBuilder.loadTexts: inHdrBadOption.setDescription('The number of IP packets with one or more incorrect options. This is a subset of ipHdrErrors.')
inDataNotAllocated = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inDataNotAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: inDataNotAllocated.setDescription('This is an internal error. This is a subset of inDiscards.')
inNoPacketBuffers = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inNoPacketBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: inNoPacketBuffers.setDescription('The number of IP packets received that had to be discarded due to lack of buffer space. This is a subset of inDiscards.')
outNoPacketBuffers = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outNoPacketBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: outNoPacketBuffers.setDescription('The number of IP packets that were to be sent but had to be discarded due to lack of buffer space. This is a subset of outDiscards.')
outBadTransmits = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBadTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: outBadTransmits.setDescription('The number of IP packets that could not be transmitted even though the packet was valid.')
outAddrNotResolved = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outAddrNotResolved.setStatus('mandatory')
if mibBuilder.loadTexts: outAddrNotResolved.setDescription('The number of IP packets that could not be transmitted due to ARP failure. The address could not be resolved.')
reasmTimeout = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 12, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reasmTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: reasmTimeout.setDescription('The IP reasmebly timeout.')
in3000StatsHmi = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 13))
hmiReqs = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiReqs.setStatus('mandatory')
if mibBuilder.loadTexts: hmiReqs.setDescription('The number of HMI requests received.')
hmiResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiResp.setDescription('The number of HMI reresponses sent. This does not include acknowledgement frames.')
hmiError = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiError.setStatus('mandatory')
if mibBuilder.loadTexts: hmiError.setDescription('The number of errors that occured processing HMI requests.')
hmiAckOk = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiAckOk.setStatus('mandatory')
if mibBuilder.loadTexts: hmiAckOk.setDescription('The number of HMI Good Acknowledgements sent.')
hmiAckBad = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiAckBad.setStatus('mandatory')
if mibBuilder.loadTexts: hmiAckBad.setDescription('The number of HMI Bad Acknowledgements sent.')
hmiTrap = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiTrap.setStatus('mandatory')
if mibBuilder.loadTexts: hmiTrap.setDescription('The number of HMI traps sent.')
hmiIdReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiIdReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiIdReq.setDescription('The number of HMI ID requests sent.')
hmiGetInfoReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiGetInfoReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiGetInfoReq.setDescription('The number of HMI GET INFO requests sent.')
hmiSelftestReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiSelftestReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiSelftestReq.setDescription('The number of HMI SELFTEST requests sent.')
hmiPortEnableReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortEnableReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortEnableReq.setDescription('The number of HMI PORT ENABLE requests sent.')
hmiPortDisableReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortDisableReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortDisableReq.setDescription('The number of HMI PORT DISABLE requests sent.')
hmiStatusReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiStatusReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiStatusReq.setDescription('The number of HMI STATUS requests sent.')
hmiRepeaterReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiRepeaterReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiRepeaterReq.setDescription('The number of HMI REPEATER requests sent.')
hmiPortObjectsReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortObjectsReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortObjectsReq.setDescription('The number of HMI POR OBJECTS request sent.')
hmiPortChangesReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortChangesReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortChangesReq.setDescription('The number of HMI PORT CHANGES requests sent.')
hmiSelfTestStatReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiSelfTestStatReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiSelfTestStatReq.setDescription('The number of HMI SELF TEST STATUTS requests sent.')
hmiDebugOnReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiDebugOnReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiDebugOnReq.setDescription('The number of HMI DEBUG ON requests sent.')
hmiDebugOffReq = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiDebugOffReq.setStatus('mandatory')
if mibBuilder.loadTexts: hmiDebugOffReq.setDescription('The number of HMI DEBUG OFF requests sent.')
hmiGetInfoResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiGetInfoResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiGetInfoResp.setDescription('The number of HMI GET INFO responses sent.')
hmiSelfTestResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiSelfTestResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiSelfTestResp.setDescription('The number of HMI SELF TEST responses sent.')
hmiStatusResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiStatusResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiStatusResp.setDescription('The number of HMI STATUS responses sent.')
hmiRepeaterResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiRepeaterResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiRepeaterResp.setDescription('The number of HMI REPEATER responses sent.')
hmiPortObjectsResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortObjectsResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortObjectsResp.setDescription('The number of HMI PORT OBJECTS responses sent.')
hmiPortChangesResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiPortChangesResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiPortChangesResp.setDescription('The number of HMI PORT CHANGES responses sent.')
hmiSelfTestStatResp = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 13, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmiSelfTestStatResp.setStatus('mandatory')
if mibBuilder.loadTexts: hmiSelfTestStatResp.setDescription('The number of HMI SLEF TEST STATUS responses sent.')
in3000StatsUart = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 14))
uartInOctets = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: uartInOctets.setDescription('The number of octets received by the UART driver.')
uartOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: uartOutOctets.setDescription('The number of octets sent by the UART driver.')
uartInDelivers = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: uartInDelivers.setDescription('The number of octets received by the Uart and passed to upper layer protocol, such as HMI.')
uartOutDelivers = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartOutDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: uartOutDelivers.setDescription('The number of bytes sent by the Uart there were from a higher level protocol, such as HMI.')
uartBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200))).clone(namedValues=NamedValues(("br1200", 1200), ("br2400", 2400), ("br4800", 4800), ("br9600", 9600), ("br19200", 19200), ("br38400", 38400), ("br57600", 57600), ("br115200", 115200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: uartBaudRate.setDescription('The baud rate of the serial port.')
uartDataBits = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8))).clone(namedValues=NamedValues(("five", 5), ("six", 6), ("seven", 7), ("eight", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uartDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: uartDataBits.setDescription('The the number of data bits used by the serial port.')
uartStopBits = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uartStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: uartStopBits.setDescription('The number of stop bits used by the serial port.')
uartParity = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("even", 2), ("odd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uartParity.setStatus('mandatory')
if mibBuilder.loadTexts: uartParity.setDescription('The data parity used by the serial port.')
uartHandshaking = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("xonXoff", 2), ("rtsCts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uartHandshaking.setStatus('mandatory')
if mibBuilder.loadTexts: uartHandshaking.setDescription('The handshaking used bu the serial port.')
uartOverrunErrors = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: uartOverrunErrors.setDescription('The number of time the UART has overrun causing an error.')
uartParityErrors = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: uartParityErrors.setDescription('The number frames received from the UART that had parity errors.')
uartFramingErrors = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: uartFramingErrors.setDescription('The number frames received from the UART that had framing errors.')
uartBreakIndicators = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 14, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uartBreakIndicators.setStatus('mandatory')
if mibBuilder.loadTexts: uartBreakIndicators.setDescription('The number indicators received by the UART.')
in3000SelfTests = MibIdentifier((1, 3, 6, 1, 4, 1, 426, 1, 15))
dallasTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("runTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dallasTest.setStatus('mandatory')
if mibBuilder.loadTexts: dallasTest.setDescription('This variable is used to run a diagnostic test on the Universal Clock. To run the test this variable must be set to runTest(3). Setting this to any other value will result in an error.')
flashTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("runTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flashTest.setStatus('mandatory')
if mibBuilder.loadTexts: flashTest.setDescription('This variable is used to run a diagnostic test on the Non-Volitile RAM. To run the test this variable must be set to runTest(3). Setting this to any other value will result in an error.')
uartTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("runTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uartTest.setStatus('mandatory')
if mibBuilder.loadTexts: uartTest.setDescription('This variable is used to run a diagnostic test on the serial port (UART). To run the test this variable must be set to runTest(3). Setting this to any other value will result in an error.')
nicTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("runTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nicTest.setStatus('mandatory')
if mibBuilder.loadTexts: nicTest.setDescription('This variable is used to run a diagnostic test on the ethernet controller. To run the test this variable must be set to runTest(3). Setting this to any other value will result in an error.')
netioTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("testHub1", 3), ("testHub2", 4), ("testHub3", 5), ("testHub4", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netioTest.setStatus('mandatory')
if mibBuilder.loadTexts: netioTest.setDescription('This variable is used to run a diagnostic test on the ethernet modules in the microhubs. To run the test this variable must be set to testHub1, testHub2, testHub3 or testHub4. Setting this to any other value will result in an error.')
heapTest = MibScalar((1, 3, 6, 1, 4, 1, 426, 1, 15, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testPass", 1), ("testFailed", 2), ("runTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: heapTest.setStatus('mandatory')
if mibBuilder.loadTexts: heapTest.setDescription('This variable is used to run a diagnostic test on the memory heap. To run the test this variable must be set to runTest(3). Setting this to any other value will result in an error.')
partState = NotificationType((1, 3, 6, 1, 4, 1, 426, 1) + (0,1)).setObjects(("COMPEX-IN3000", "psmGroupIndex"), ("COMPEX-IN3000", "psmPortIndex"))
if mibBuilder.loadTexts: partState.setDescription('This trap is sent whenever the partition state changes to partitioned.')
notPartState = NotificationType((1, 3, 6, 1, 4, 1, 426, 1) + (0,2)).setObjects(("COMPEX-IN3000", "psmGroupIndex"), ("COMPEX-IN3000", "psmPortIndex"))
if mibBuilder.loadTexts: notPartState.setDescription('This trap is sent whenever the partition state changes to not partitioned.')
mibBuilder.exportSymbols("COMPEX-IN3000", portOctetsEntry=portOctetsEntry, gspGroupIndex=gspGroupIndex, gsobkt128to255Ok=gsobkt128to255Ok, gsobkt512to1023Ok=gsobkt512to1023Ok, psoHostOctetsRxErr=psoHostOctetsRxErr, gspMulticastErr=gspMulticastErr, threadKill=threadKill, productInfo=productInfo, psobkt512to1023Ok=psobkt512to1023Ok, gsobkt128to255Err=gsobkt128to255Err, psmFifoOverrun=psmFifoOverrun, psobkt128to255Err=psobkt128to255Err, pspHostPhysicalOk=pspHostPhysicalOk, inHdrBadCheckSum=inHdrBadCheckSum, in3000StatsRptr=in3000StatsRptr, in3000StatsPort=in3000StatsPort, rptrInvalidDesgntr=rptrInvalidDesgntr, compexMyAccess=compexMyAccess, inHdrTooSmall=inHdrTooSmall, devTeamEntry=devTeamEntry, hmiSelfTestResp=hmiSelfTestResp, portOctetsTable=portOctetsTable, psmCollisions=psmCollisions, communityInstance=communityInstance, inDataNotAllocated=inDataNotAllocated, gspMulticastOk=gspMulticastOk, rptrNoFreeBuffers=rptrNoFreeBuffers, gsoOctetsRxOk=gsoOctetsRxOk, arpEntryTimeout=arpEntryTimeout, groupOctetsTable=groupOctetsTable, productName=productName, hmiDebugOffReq=hmiDebugOffReq, gsmJabbers=gsmJabbers, psobkt512to1023Err=psobkt512to1023Err, uartOutDelivers=uartOutDelivers, groupPacketTable=groupPacketTable, gspPacketsRxErr=gspPacketsRxErr, psobkt64Ok=psobkt64Ok, hmiStatusResp=hmiStatusResp, breakpoint=breakpoint, rptrNICTxCollisions=rptrNICTxCollisions, coalesceThreshold=coalesceThreshold, psmCrcFae=psmCrcFae, psobkt65to127Err=psobkt65to127Err, bufferPoolEmpty=bufferPoolEmpty, threadCreateFail=threadCreateFail, gsmPartitions=gsmPartitions, hmiSelfTestStatReq=hmiSelfTestStatReq, in3000StatsIcmp=in3000StatsIcmp, in3000StatsOS=in3000StatsOS, gsmType=gsmType, rptrNICTxCDHrtbts=rptrNICTxCDHrtbts, psobkt1024to1518Ok=psobkt1024to1518Ok, uartTest=uartTest, communityEntry=communityEntry, hmiAckBad=hmiAckBad, psoHostOctetsRxOk=psoHostOctetsRxOk, rptrNICCarrierLost=rptrNICCarrierLost, gsmLateCollisions=gsmLateCollisions, psoGroupIndex=psoGroupIndex, tp3000=tp3000, hmiPortChangesReq=hmiPortChangesReq, gsmGroupIndex=gsmGroupIndex, pspPortIndex=pspPortIndex, reasmTimeout=reasmTimeout, nicTest=nicTest, in3000StatsHmi=in3000StatsHmi, threadCreateReq=threadCreateReq, hmiPortDisableReq=hmiPortDisableReq, gspHostPhysicalErr=gspHostPhysicalErr, portPacketTable=portPacketTable, psobkt256to511Err=psobkt256to511Err, notPartState=notPartState, rptrOverflows=rptrOverflows, gspBroadcastErr=gspBroadcastErr, hmiPortEnableReq=hmiPortEnableReq, outAddrNotResolved=outAddrNotResolved, rptrNICTxFifoUruns=rptrNICTxFifoUruns, uartStopBits=uartStopBits, uartHandshaking=uartHandshaking, invalidOpcode=invalidOpcode, portMiscTable=portMiscTable, gsmNumLinkUp=gsmNumLinkUp, psoPacketsTooBigErr=psoPacketsTooBigErr, hmiPortObjectsReq=hmiPortObjectsReq, singleStep=singleStep, name=name, uartParity=uartParity, gsoHostOctetsRxErr=gsoHostOctetsRxErr, pspPhysicalErr=pspPhysicalErr, pspPacketsRxOk=pspPacketsRxOk, in3000StatsUart=in3000StatsUart, compexPhone=compexPhone, reallocCalls=reallocCalls, in3000StatsArp=in3000StatsArp, gsoPacketsTooBigOk=gsoPacketsTooBigOk, gsoRuntPacketsErr=gsoRuntPacketsErr, threadCreateOk=threadCreateOk, dataBufferTooSmall=dataBufferTooSmall, flashTest=flashTest, pspBroadcastOk=pspBroadcastOk, dallasTest=dallasTest, coalesceMemCalls=coalesceMemCalls, trapEntry=trapEntry, gsmCollisions=gsmCollisions, communityString=communityString, psoPacketsTooBigOk=psoPacketsTooBigOk, portPacketEntry=portPacketEntry, outBadTransmits=outBadTransmits, hmiRepeaterReq=hmiRepeaterReq, arpDeadEntries=arpDeadEntries, arpOutRpls=arpOutRpls, productVersion=productVersion, gsobkt1024to1518Ok=gsobkt1024to1518Ok, in3000StatsIp=in3000StatsIp, freeHeap=freeHeap, escapeOpcode=escapeOpcode, muxCount=muxCount, mnodeCoalesces=mnodeCoalesces, tid=tid, uartInDelivers=uartInDelivers, trapStatus=trapStatus, psobkt128to255Ok=psobkt128to255Ok, hmiReqs=hmiReqs, gsmShortFragments=gsmShortFragments, groupMiscEntry=groupMiscEntry, hmiRepeaterResp=hmiRepeaterResp, gsmCrcFae=gsmCrcFae, trapDest=trapDest, psmCrc=psmCrc, gspHostPhysicalOk=gspHostPhysicalOk, gsmDeferring=gsmDeferring, compexImage=compexImage, psobkt256to511Ok=psobkt256to511Ok, psmLinkPulses=psmLinkPulses, pspBroadcastErr=pspBroadcastErr, arpInRpls=arpInRpls, initHeapSize=initHeapSize, in3000StatsGroup=in3000StatsGroup, rptrTxTimeouts=rptrTxTimeouts, heapStatus=heapStatus, hmiError=hmiError, uartParityErrors=uartParityErrors, rptrNoStatsDsgntr=rptrNoStatsDsgntr, heapTest=heapTest, rptrShortWoPort=rptrShortWoPort, gsobkt256to511Ok=gsobkt256to511Ok, cpId=cpId, in3000=in3000, rptrNICTxOutWinCls=rptrNICTxOutWinCls, trapInfo=trapInfo, rp3000=rp3000, hmiSelfTestStatResp=hmiSelfTestStatResp, hmiSelftestReq=hmiSelftestReq, compexAddress=compexAddress, uartFramingErrors=uartFramingErrors, arpReplyTimeout=arpReplyTimeout, inHdrBadVersion=inHdrBadVersion, defaultStackSize=defaultStackSize, threadTable=threadTable, pspGroupIndex=pspGroupIndex, psmPortIndex=psmPortIndex, noMemoryAvailable=noMemoryAvailable, gsobkt256to511Err=gsobkt256to511Err, arpPutReqs=arpPutReqs, hmiAckOk=hmiAckOk, hmiGetInfoResp=hmiGetInfoResp, psmType=psmType, communityTable=communityTable, uartOverrunErrors=uartOverrunErrors, gsmFifoOverrun=gsmFifoOverrun, callocCalls=callocCalls, uartOutOctets=uartOutOctets, pspMulticastErr=pspMulticastErr, rptrPortIDwoPacket=rptrPortIDwoPacket, uartBreakIndicators=uartBreakIndicators, bogusInterrupts=bogusInterrupts, psoRuntPacketsOk=psoRuntPacketsOk, gsoHostOctetsRxOk=gsoHostOctetsRxOk, gsobkt65to127Err=gsobkt65to127Err, compex=compex, devTeamTable=devTeamTable, gsmNumPorts=gsmNumPorts, priority=priority, arpOutReqs=arpOutReqs, pspMulticastOk=pspMulticastOk, psoOctetsRxErr=psoOctetsRxErr, stackSize=stackSize, arpGetReqs=arpGetReqs, groupMiscTable=groupMiscTable, pspPacketsRxErr=pspPacketsRxErr, threadMaximum=threadMaximum, rptrInNoRxBuf=rptrInNoRxBuf, gspPhysicalOk=gspPhysicalOk, arpNumRetries=arpNumRetries, inNoPacketBuffers=inNoPacketBuffers, gsoPacketsTooBigErr=gsoPacketsTooBigErr, uartInOctets=uartInOctets, psmShortFragments=psmShortFragments, arrayBoundsCheck=arrayBoundsCheck, arpInReqs=arpInReqs, uartDataBits=uartDataBits, releasedDate=releasedDate, usedHeap=usedHeap, mallocCalls=mallocCalls, gsmName=gsmName, gspBroadcastOk=gspBroadcastOk, trapTable=trapTable, gsoGroupIndex=gsoGroupIndex, divideError=divideError, psmPartitions=psmPartitions, gsmNumLinkPulses=gsmNumLinkPulses, status=status, psoPortIndex=psoPortIndex, arpCacheSize=arpCacheSize, gspPhysicalErr=gspPhysicalErr, gsobkt512to1023Err=gsobkt512to1023Err, pspHostPhysicalErr=pspHostPhysicalErr, hmiGetInfoReq=hmiGetInfoReq, gsobkt64Err=gsobkt64Err, partState=partState, psoRuntPacketsErr=psoRuntPacketsErr, hubTypes=hubTypes, psmName=psmName, hmiStatusReq=hmiStatusReq, inHdrBadOption=inHdrBadOption, hmiResp=hmiResp, in3000SelfTests=in3000SelfTests, gsoRuntPacketsOk=gsoRuntPacketsOk, gsobkt1024to1518Err=gsobkt1024to1518Err, psmLateCollisions=psmLateCollisions, psmJabbers=psmJabbers, gspPacketsRxOk=gspPacketsRxOk, cpName=cpName, psobkt1024to1518Err=psobkt1024to1518Err, freeCalls=freeCalls, communityCapability=communityCapability, psmLinkState=psmLinkState, uartBaudRate=uartBaudRate, gsobkt64Ok=gsobkt64Ok, hmiPortChangesResp=hmiPortChangesResp, defaultTimeSlice=defaultTimeSlice, psmDeferring=psmDeferring, portMiscEntry=portMiscEntry, outNoPacketBuffers=outNoPacketBuffers, psobkt64Err=psobkt64Err, hmiDebugOnReq=hmiDebugOnReq, hmiTrap=hmiTrap, netioTest=netioTest, gsoOctetsRxErr=gsoOctetsRxErr, gsobkt65to127Ok=gsobkt65to127Ok, gsmCrc=gsmCrc, threadEntry=threadEntry, pspPhysicalOk=pspPhysicalOk)
mibBuilder.exportSymbols("COMPEX-IN3000", rptrFifoColls=rptrFifoColls, threadTableFull=threadTableFull, interruptOverflow=interruptOverflow, inUnknownTypes=inUnknownTypes, groupOctetsEntry=groupOctetsEntry, psobkt65to127Ok=psobkt65to127Ok, psmGroupIndex=psmGroupIndex, coprocessorFault=coprocessorFault, hmiPortObjectsResp=hmiPortObjectsResp, communityInfo=communityInfo, psoOctetsRxOk=psoOctetsRxOk, groupPacketEntry=groupPacketEntry, hmiIdReq=hmiIdReq, in3000StatsMemory=in3000StatsMemory)

#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-MPLS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ALCATEL-IND1-TIMETRA-MPLS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:19:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
tmnxSRNotifyPrefix, tmnxSRObjs, tmnxSRConfs, timetraSRMIBModules = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "tmnxSRNotifyPrefix", "tmnxSRObjs", "tmnxSRConfs", "timetraSRMIBModules")
TmnxOperState, TmnxVRtrMplsLspID, TmnxActionType, TNamedItemOrEmpty, TmnxAdminState, TNamedItem = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TmnxOperState", "TmnxVRtrMplsLspID", "TmnxActionType", "TNamedItemOrEmpty", "TmnxAdminState", "TNamedItem")
vRtrID, vRtrIfIndex = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID", "vRtrIfIndex")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressIPv6, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6")
mplsXCLspId, MplsLabel, MplsLSPID = mibBuilder.importSymbols("MPLS-LSR-MIB", "mplsXCLspId", "MplsLabel", "MplsLSPID")
mplsTunnelIndex, mplsTunnelInstance, mplsTunnelIngressLSRId, mplsTunnelARHopEntry = mibBuilder.importSymbols("MPLS-TE-MIB", "mplsTunnelIndex", "mplsTunnelInstance", "mplsTunnelIngressLSRId", "mplsTunnelARHopEntry")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
IpAddress, NotificationType, Integer32, Counter32, Unsigned32, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ModuleIdentity, ObjectIdentity, MibIdentifier, iso, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "NotificationType", "Integer32", "Counter32", "Unsigned32", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "iso", "Gauge32")
TruthValue, DisplayString, RowPointer, TestAndIncr, TimeInterval, RowStatus, TimeStamp, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "RowPointer", "TestAndIncr", "TimeInterval", "RowStatus", "TimeStamp", "TextualConvention")
timetraMplsMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 6))
timetraMplsMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-03-23 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1900-09-07 00:00', '1900-08-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraMplsMIBModule.setRevisionsDescriptions(('Rev 6.0 01 Jan 2008 00:00 6.0 release of the TIMETRA-MPLS-MIB.', 'Rev 5.0 01 Jan 2007 00:00 5.0 release of the TIMETRA-MPLS-MIB.', 'Rev 4.0 23 Mar 2006 00:00 4.0 release of the TIMETRA-MPLS-MIB.', 'Rev 3.0 31 Aug 2005 00:00 3.0 release of the TIMETRA-MPLS-MIB.', 'Rev 2.1 24 Jan 2005 00:00 2.1 release of the TIMETRA-MPLS-MIB.', 'Rev 2.0 15 Jan 2004 00:00 2.0 release of the TIMETRA-MPLS-MIB.', 'Rev 1.2 15 Aug 2003 00:00 1.2 release of the TIMETRA-MPLS-MIB.', 'Rev 1.0 20 Jan 2003 00:00 1.0 Release of the TIMETRA-MPLS-MIB.', 'Rev 0.1 14 Aug 2000 00:00 Initial version of the TIMETRA-MPLS-MIB.',))
if mibBuilder.loadTexts: timetraMplsMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: timetraMplsMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: timetraMplsMIBModule.setContactInfo('Alcatel 7x50 Support Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: timetraMplsMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the MPLS extensions for the Alcatel 7x50 device. Copyright 2003-2008 Alcatel-Lucent. All rights reserved. Reproduction of this document is authorized on the condition that the foregoing copyright notice is included. This SNMP MIB module (Specification) embodies Alcatel's proprietary intellectual property. Alcatel retains all title and ownership in the Specification, including any revisions. Alcatel grants all interested parties a non-exclusive license to use and distribute an unmodified copy of this Specification in connection with management of Alcatel products, and without fee, provided this copyright notice and license appear on all copies. This Specification is supplied 'as is', and Alcatel makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
tmnxMplsObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6))
tmnxMplsConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6))
tmnxMplsNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6))
tmnxMplsNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0))
class TmnxMplsLspFailCode(TextualConvention, Integer32):
    description = 'TmnxMplsLspFailCode is an enumerated integer that defines the reason for LSP Path and LSP Crossconnect failure.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26))
    namedValues = NamedValues(("noError", 0), ("admissionControlError", 1), ("noRouteToDestination", 2), ("trafficControlSystemError", 3), ("routingError", 4), ("noResourcesAvailable", 5), ("badNode", 6), ("routingLoop", 7), ("labelAllocationError", 8), ("badL3PID", 9), ("tunnelLocallyRepaired", 10), ("unknownObjectClass", 11), ("unknownCType", 12), ("noEgressMplsInterface", 13), ("noEgressRsvpInterface", 14), ("looseHopsInFRRLsp", 15), ("unknown", 16), ("retryExceeded", 17), ("noCspfRouteOwner", 18), ("noCspfRouteToDestination", 19), ("hopLimitExceeded", 20), ("looseHopsInManualBypassLsp", 21), ("emptyPathInManualBypassLsp", 22), ("lspFlowControlled", 23), ("srlgSecondaryNotDisjoint", 24), ("srlgPrimaryCspfDisabled", 25), ("srlgPrimaryPathDown", 26))

class TmnxMplsLabelOwner(TextualConvention, Integer32):
    description = 'TmnxMplsLabelOwner is an enumerated integer that specifies the module that owns a particular MPLS label.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("none", 0), ("rsvp", 1), ("tldp", 2), ("ildp", 3), ("svcmgr", 4), ("bgp", 5), ("mirror", 6), ("static", 7), ("vprn", 8))

class TmnxMplsOperDownReasonCode(TextualConvention, Integer32):
    description = 'TmnxMplsOperDownReasonCode is an enumerated integer that specifies the reason that the MPLS instance is operationally down.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("operUp", 0), ("adminDown", 1), ("noResources", 2), ("systemIpDown", 3), ("iomFailure", 4), ("clearDown", 5))

vRtrMplsLspTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1), )
if mibBuilder.loadTexts: vRtrMplsLspTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTable.setDescription('The vRtrMplsLspTable has an entry for each Labeled Switch Path (LSP) configured for a virtual router in the system.')
vRtrMplsLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"))
if mibBuilder.loadTexts: vRtrMplsLspEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspEntry.setDescription("Each row entry represents a Labeled Switch Path (LSP) configured for a virtual router in the system. Entries can be created and deleted via SNMP SET operations. Setting RowStatus to 'active' requires vRtrMplsLspName to have been assigned a valid value.")
vRtrMplsLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 1), TmnxVRtrMplsLspID()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspIndex.setDescription('The unique value which identifies this Labeled Switch Path (LSP) for this virtual router in the Alcatel 7x50 SR system. It is a unique value among entries with the same value of vRtrID.')
vRtrMplsLspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRowStatus.setDescription("The row status used for creation, deletion, or control of vRtrMplsLspTable entries. Before the row can be placed into the 'active' state vRtrMplsLspName must have been assigned a valid value.")
vRtrMplsLspLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsLspName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 4), TNamedItemOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspName.setDescription('Administrative name for this Labeled Switch Path. The vRtrMplsLspName must be unique within a virtual router instance.')
vRtrMplsLspAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 5), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminState.setDescription('The desired administrative state for this LSP.')
vRtrMplsLspOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperState.setDescription('The current operational state of this LSP.')
vRtrMplsLspFromAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 7), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFromAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFromAddr.setDescription('Source IP address of this LSP. If vRtrMplsLspFromAddr has not been explicitly set, the system IP address will be used.')
vRtrMplsLspToAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspToAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspToAddr.setDescription('Destination IP address of this LSP. This LSP will not be signaled until vRtrMplsLspToAddr is explicitly set.')
vRtrMplsLspType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("dynamic", 2), ("static", 3), ("bypass-only", 4))).clone('dynamic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspType.setDescription('The vRtrMplsLspType object is an enumerated value that indicates whether the label value is statically or dynamically assigned or whether the LSP will be used exclusively for bypass protection.')
vRtrMplsLspOutSegIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspOutSegIndx.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOutSegIndx.setDescription("The vRtrMplsLspOutSegIndx is the index value of the entry in the mplsOutSegmentTable associated with this vRtrMplsLspEntry when vRtrMplsLspType is 'static'. If vRtrMplsLspType is 'dynamic', the value of this object will be zero (0).")
vRtrMplsLspRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRetryTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRetryTimer.setDescription('The value of vRtrMplsLspRetryTimer specifies the time in seconds the software will wait before attempting the establish the failed LSP.')
vRtrMplsLspRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRetryLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRetryLimit.setDescription('The value of vRtrMplsLspRetryLimit specifies the number of attempts the software should make to reestablish a failed LSP before the LSP is disabled. A value of 0 indicates that an infinite number of retry attempts should be made.')
vRtrMplsLspMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspMetric.setDescription('The value of vRtrMplsLspMetric specifies the metric for this LSP which is used to select an LSP among a set of LSPs which are destined to the same egress 7x50 router. The LSP with the lowest metric will be selected. In LDP-over-RSVP, LDP performs a lookup in the Routing Table Manager (RTM) which provides the next hop to the destination PE and the advertising router (ABR or destination PE itself). If the advertising router matches the targeted LDP peer, LDP then performs a second lookup for the advertising router in the Tunnel Table Manager (TTM). This lookup returns the best RSVP LSP to use to forward packets for an LDP FEC learned through the targeted LDP session. The lookup returns the LSP with the lowest metric. If multiple LSPs have the same metric, then the result of the lookup will be to select the first one available in the TTM.')
vRtrMplsLspDecrementTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 14), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspDecrementTtl.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspDecrementTtl.setDescription("When the value of vRtrMplsLspDecrementTtl is 'true', the ingress ESR writes the TTL of the IP packet into the label and each transit ESR decrements the TTL in the label. At the egress ESR the TTL value from the label is written into the IP packet. When the value of vRtrMplsLspDecrementTtl is 'false', the ingress ESR ignores the IP packet TTL and writes the value of 255 into the label; and the egress ESR does not write the label's TTL into the IP packet.")
vRtrMplsLspCspf = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspCspf.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspCspf.setDescription("When the value of vRtrMplsLspCspf is 'true', CSPF computation for constrained-path LSP is enabled. When the value of vRtrMplsLspCspf is 'false' CSPF computation is disabled.")
vRtrMplsLspFastReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFastReroute.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFastReroute.setDescription("When the value of vRtrMplsLspFastReroute is 'true', fast reroute is enabled. A pre-computed detour LSP is created from each node in the primary path of this LSP. In case of a failure of a link or LSP between two nodes, traffic is immediately rerouted on the pre-computed detour LSP thus avoiding packet loss. Each node along the primary path of the LSP tries to establish a detour LSP as follows: Each upstream node will setup a detour LSP that avoids only the immediate downstream node and merges back onto the actual path of the LSP as soon as possible. The detour LSP may take one or more hops (upto the value of vRtrMplsLspFRHopLimit) before merging back onto the main LSP path. When the upstream node detects a downstream link or node failure, it immediately send traffic for that LSP on the detour path and at the same time signals back to the ingress ESR about the failure. Fast reroute applies only to the primary path of this LSP. No configuration is required on the transit hops of the LSP. The ingress ESR will signal all intermediate ESRs using RSVP to setup their detours. When the value of vRtrMplsLspFastReroute is 'false', fast rerouting is disabled.")
vRtrMplsLspFRHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRHopLimit.setDescription('The value of vRtrMplsLspFRHopLimit specifies the total number of hops a detour LSP can take before merging back onto the main LSP path.')
vRtrMplsLspFRBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 18), Unsigned32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRBandwidth.setDescription('The value of vRtrMplsLspFRBandwidth specified the amount of bandwidth in mega-bits per second (Mbps) to be reserved for the detour LSP. A value of zero (0) indicates that no bandwidth is reserved.')
vRtrMplsLspClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 19), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspClassOfService.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspClassOfService.setDescription("The name of the class of service value to be assigned to all packets on the LSP is specified with vRtrMplsLspClassOfService. The EXP bits in the MPLS header are set based on the global mapping table that specified the mapping between the forwarding class and the EXP bits. When class of service is specified, all packets will be marked with the same EXP bits that match the vRtrMplsLspClassOfService name in the mapping table. An empty string, ''H, specifies no class of service. Packets are assigned EXP bits based on the same mapping table, however each packet is marked with EXP bits based on the forwarding class from which it is serviced. When the value of vRtrMplsLspPathCosSource is set to 'inherit', the value of vRtrMplsLspClassOfService is applied to that specific LSP/path.")
vRtrMplsLspSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspSetupPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspSetupPriority.setDescription("The value of vRtrMplsLspSetupPriority specifies the setup priority to use when insufficient bandwidth is available to setup a LSP. The setup priority is compared against the hold priority of existing LSPs. If the setup priority is higher than the hold priority of the established LSPs, this LSP may preempt the other LSPs. A value of zero (0) is the highest priority and a value of seven (7) is the lowest priority. When the value of vRtrMplsLspPathSetupPriority is set to '-1', the value of vRtrMplsLspSetupPriority is applied to that specific LSP/path.")
vRtrMplsLspHoldPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspHoldPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHoldPriority.setDescription("The value of vRtrMplsLspHoldPriority specifies the hold priority to use when insufficient bandwidth is available to setup a LSP. The setup priority is compared against the hold priority of existing LSPs. If the setup priority is higher than the hold priority of the established LSPs, this LSP may preempt the other LSPs. A value of zero (0) is the highest priority and a value of seven (7) is the lowest priority. When the value of vRtrMplsLspPathHoldPriority is set to '-1', the value of vRtrMplsLspHoldPriority is applied to that specific LSP/path.")
vRtrMplsLspRecord = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 22), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRecord.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRecord.setDescription("When the value of vRtrMplsLspRecord is 'true', recording of all the hops that a LSP traverses is enabled. When the value of vRtrMplsLspRecord is 'false, recording of all the hops that a LSP traverses is disabled.")
vRtrMplsLspPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPreference.setDescription('The value of vRtrMplsLspPreference specifies the preference for the LSP. This value is used for load balancing between multiple LSPs that exist between the same ingress and egress routers. By default, traffic is load balanced among the LSPs, since all LSPs have the same preference. To prefer one LSP over another, change the preference value for that LSP. The LSP with the lowest preference is used. When the value of vRtrMplsLspPathPreference is set to zero (0), the value of vRtrMplsLspPreference is applied to that specific LSP/path.')
vRtrMplsLspBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 24), Integer32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspBandwidth.setDescription('The value of vRtrMplsLspBandwidth specifies the amount of bandwidth in mega-bits per second (Mbps) to be reserved for the LSP. A value of zero (0) indicates that no bandwidth is reserved. When vRtrMplsLspPathBandwidth is set to -1, the value of vRtrMplsLspBandwidth is applied to that specific LSP/path.')
vRtrMplsLspBwProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspBwProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspBwProtect.setDescription("When vRtrMplsLspBwProtect has a value of 'true', bandwidth protection is enabled on a LSP. LSPs that reserve bandwidth will be used for EF services where customers need guaranteed bandwidth. It is expected that multiple EF services will be assigned to a single LSP. When bandwidth protection is enabled on an LSP, each time this LSP is used for a certain service the bandwidth allocated on that service is deducted from the bandwidth reserved for the LSP. Once the bandwidth is exhausted on the LSP, the ESR will provide feedback to the provider indicating that this LSP has exhausted its resources.")
vRtrMplsLspHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHopLimit.setDescription('The value of vRtrMplsLspHopLimit specifies the maximum number of hops that a LSP will traverse including the ingress and egress ESRs. A LSP will not be setup if the hop limit is exceeded. When the value of vRtrMplsLspPathHopLimit is set to zero (0), the value of vRtrMplsLspHopLimit is applied to that specific LSP/path.')
vRtrMplsLspNegotiatedMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspNegotiatedMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspNegotiatedMTU.setDescription('The value of vRtrMplsLspNegotiatedMTU specifies the size for the Maximum transmission unit (MTU) that is negotiated during LSP establishment.')
vRtrMplsLspRsvpResvStyle = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("se", 1), ("ff", 2))).clone('se')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRsvpResvStyle.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRsvpResvStyle.setDescription("The value of vRtrMplsLspRsvpResvStyle specifies the reservation style for RSVP. The reservation style can be set to 'Shared- Explicit' (se) or 'Fixed-Filter' (ff).")
vRtrMplsLspRsvpAdspec = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 29), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspRsvpAdspec.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspRsvpAdspec.setDescription("When the value of vRtrMplsLspRsvpAdspec is 'true', the ADSPEC object will be included in RSVP messages. When the value of vRtrMplsLspRsvpAdspec is 'false', the ADSPEC object will not be included in RSVP messages.")
vRtrMplsLspFRMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oneToOneBackup", 1), ("facilityBackup", 2))).clone('oneToOneBackup')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRMethod.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRMethod.setDescription("The value of vRtrMplsLspFRMethod specifies the fast reroute method used. In the 'One-to-one Backup' method, a backup LSP is established which will intersect the original LSP somewhere downstream of the point of link or node failure. For each LSP that is backed up, a separate backup LSP is established. In the 'Facility Backup' method, instead of creating a separate LSP for every LSP that is to be backed up, a single LSP is created which serves as a backup for a set of LSPs. Such an LSP tunnel is called a 'bypass tunnel'.")
vRtrMplsLspFRNodeProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 31), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRNodeProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRNodeProtect.setDescription("Setting the value of vRtrMplsLspFRNodeProtect to 'true' enables node protection i.e. protection against the failure of a node on the LSP. Setting the value to 'false' disables node protection.")
vRtrMplsLspAdminGroupInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 32), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupInclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupInclude.setDescription("The value of vRtrMplsLspAdminGroupInclude is a bit-map that specifies a list of admin groups that should be included when this LSP is setup. If bit 'n' is set, then the admin group with value 'n' is included for this LSP. This implies that each link that this LSP goes through must be associated with at least one of the admin groups in the include list. By default, all admin groups are in the include list.")
vRtrMplsLspAdminGroupExclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 33), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupExclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdminGroupExclude.setDescription("The value of vRtrMplsLspAdminGroupExclude is a bit-map that specifies a list of admin groups that should be excluded when this LSP is setup. If bit 'n' is set, then the admin group with value 'n' is excluded for this LSP. This implies that each link that this LSP goes through must not be associated with any of the admin groups in the exclude list. By default, no admin groups are in the exclude list.")
vRtrMplsLspAdaptive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 34), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspAdaptive.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAdaptive.setDescription("Setting the value of vRtrMplsLspAdaptive to 'true' enables make-before-break functionality for the LSP. When the attributes of an already established LSP are changed, either through manual configuration or due to a change in network topology, make-before-break functionality ensures that the resources of the existing LSP will not be released until a new path (with the same LSP Id) has been established and traffic flowing over the existing path is seamlessly transferred to the new path. Setting the value to 'false' disables make-before-break functionality.")
vRtrMplsLspInheritance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 35), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspInheritance.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspInheritance.setDescription("For each writable object in this row that can be configured to inherit its value from the corresponding object in the vRtrMplsGeneralTable, there is bit within vRtrMplsLspInheritance that controls whether to inherit the operational value of the object or use the administratively set value. This object is a bit-mask, with the following positions: vRtrMplsLspOptimizeTimer 0x1 vRtrMplsLspFRObject 0x2 When the bit for an object is set to one, then the object's administrative and operational value are whatever the DEFVAL or most recently SET value is. When the bit for an object is set to zero, then the object's administrative and operational value are inherited from the corresponding object in vRtrMplsGeneralTable.")
vRtrMplsLspOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOptimizeTimer.setDescription('The value of vRtrMplsLspOptimizeTimer specifies the time, in seconds, the software will wait before attempting to re-optimize the LSP. When CSPF is enabled, changes in the network topology may cause the existing path of a loose-hop LSP to become sub-optimal. Such LSPs can be re-optimized and re-routed through more optimal paths by recalculating the path for the LSP at periodic intervals. This interval is controlled by the optimize timer. A value of 0 indicates that optimization has been disabled. When the vRtrMplsLspOptimizeTimer bit in vRtrMplsLspInheritance is cleared (0), the value returned in the GET request is inherited from vRtrMplsGeneralOptimizeTimer.')
vRtrMplsLspOperFastReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 37), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperFastReroute.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperFastReroute.setDescription('The value of vRtrMplsLspOperFastReroute specifies whether the operational LSP has fast reroute enabled or disabled. When make-before-break functionality for the LSP is enabled and if the fast reroute setting is changed, the resources for the existing LSP will not be released until a new path with the new attribute settings has been established. While a new path is being signaled, the administrative value and the operational values of fast reroute setting for the LSP may differ. The value of vRtrMplsLspFastReroute specifies the setting used for the new LSP path trying to be established whereas the value of vRtrMplsLspOperFastReroute specifies the setting for the existing LSP path.')
vRtrMplsLspFRObject = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 38), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspFRObject.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspFRObject.setDescription("The value of vRtrMplsLspFRObject specifies whether fast reroute, for LSPs using 'Facility Backup', is signalled with or without the fast reroute object. The value of vRtrMplsLspFRObject is ignored if fast reroute is disabled for the LSP or if the LSP is using 'One-to-one Backup'. When the vRtrMplsLspFRObject bit in vRtrMplsLspInheritance is cleared (0), the value returned in the GET request is inherited from vRtrMplsGeneralFRObject.")
vRtrMplsLspHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 39), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspHoldTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspHoldTimer.setDescription('The value of vRtrMplsLspHoldTimer specifies the time, in seconds, for which the ingress node holds a bit before programming its data plane and declaring the lsp up to the service module. The value of vRtrMplsLspHoldTimer is inherited from the value of vRtrMplsGeneralHoldTimer.')
vRtrMplsLspCspfTeMetricEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 1, 1, 40), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspCspfTeMetricEnabled.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspCspfTeMetricEnabled.setDescription("The value of vRtrMplsLspCspfTeMetricEnabled specifies whether the TE metric would be used for the purpose of the LSP path computation by CSPF. When the value of this object is 'false', the IGP metric is used to compute the path of the LSP by CSPF.")
vRtrMplsLspStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2), )
if mibBuilder.loadTexts: vRtrMplsLspStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStatTable.setDescription('The vRtrMplsLspStatTable has an entry for each Labeled Switch Path (LSP) configured for a virtual router in the system.')
vRtrMplsLspStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1), )
vRtrMplsLspEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStatEntry"))
vRtrMplsLspStatEntry.setIndexNames(*vRtrMplsLspEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsLspStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStatEntry.setDescription('Each row entry represents a collection of statistics for a Labeled Switch Path (LSP) configured for a virtual router in the system. Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsLspOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOctets.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOctets.setDescription('The number of octets that have been forwarded over current LSP active path. The number reported is not realtime, may be subject to several minutes delay. The delay is controllable by MPLS statistics gathering interval, which by default is once every 5 minutes. If MPLS statistics gathering is not enabled, this number will not increment.')
vRtrMplsLspPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPackets.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPackets.setDescription('The number of packets that have been forwarded over current LSP active path. The number reported is not realtime, may be subject to several minutes delay. The delay is controllable by MPLS statistics gathering interval, which by default is once every 5 minutes. If MPLS statistics gathering is not enabled, this number will not increment.')
vRtrMplsLspAge = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 3), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspAge.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspAge.setDescription('The age (i.e., time from creation till now) of this LSP in 10-millisecond periods.')
vRtrMplsLspTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTimeUp.setDescription('The total time in 10-millisecond units that this LSP has been been operational. For example, the percentage up time can be determined by computing (vRtrMplsLspTimeUp/vRtrMplsLspAge * 100 %).')
vRtrMplsLspTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTimeDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTimeDown.setDescription('The total time in 10-millisecond units that this LSP has not been operational.')
vRtrMplsLspPrimaryTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 6), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPrimaryTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPrimaryTimeUp.setDescription("The total time in 10-millisecond units that this LSP's primary path has been operational. For example, the percentage contribution of the primary path to the operational time is given by (vRtrMplsLspPrimaryTimeUp/vRtrMplsLspTimeUp * 100) %.")
vRtrMplsLspTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspTransitions.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspTransitions.setDescription('The number of state transitions (up -> down and down -> up) this LSP has undergone.')
vRtrMplsLspLastTransition = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastTransition.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastTransition.setDescription('The time in 10-millisecond units since the last transition occurred on this LSP.')
vRtrMplsLspPathChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathChanges.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathChanges.setDescription('The number of path changes this LSP has had. For every path change (path down, path up, path change), a corresponding syslog/trap (if enabled) is generated for it.')
vRtrMplsLspLastPathChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 10), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspLastPathChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspLastPathChange.setDescription('The time in 10-millisecond units since the last change occurred on this LSP.')
vRtrMplsLspConfiguredPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspConfiguredPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspConfiguredPaths.setDescription('The number of paths configured for this LSP.')
vRtrMplsLspStandbyPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspStandbyPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspStandbyPaths.setDescription('The number of standby paths configured for this LSP.')
vRtrMplsLspOperationalPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspOperationalPaths.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspOperationalPaths.setDescription('The number of operational paths for this LSP. This includes the path currently active, as well as operational standby paths.')
vRtrMplsLspPathTableSpinlock = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 3), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vRtrMplsLspPathTableSpinlock.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTableSpinlock.setDescription('voluntary serialization control for vRtrMplsLspPathTable. Primarily used by SNMP manager to coordinate changes to vRtrMplsLspPathInheritance.')
vRtrMplsLspPathTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4), )
if mibBuilder.loadTexts: vRtrMplsLspPathTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTable.setDescription('The vRtrMplsLspPathTable provides an association between an LSP and a path. An LSP can have more than one path association, but only one of those paths can be specified as the primary path type. Paths are defined in as Tunnel entries in the mplsTunnelTable in the MPLS-TE-MIB.')
vRtrMplsLspPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), (0, "MPLS-TE-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-MIB", "mplsTunnelIngressLSRId"))
if mibBuilder.loadTexts: vRtrMplsLspPathEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathEntry.setDescription("Each row entry represents an association between a Labeled Switch Path (LSP) in the vRtrMplsLspTable and a path (or tunnel) entry in the mplsTunnelTable. Entries in this table can be created and deleted via SNMP SET operations. Setting RowStatus to 'active' requires vRtrMplsLspPathType to have been assigned a valid value.")
vRtrMplsLspPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRowStatus.setDescription("The row status used for creation, deletion, or control of vRtrMplsLspPathTable entries. Before the row can be placed into the 'active' state vRtrMplsLspPathType must have been assigned a valid value.")
vRtrMplsLspPathLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsLspPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("primary", 2), ("standby", 3), ("secondary", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathType.setDescription('This variable is an enum that represents the role this path is taking within this LSP.')
vRtrMplsLspPathCos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathCos.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCos.setDescription('The configured Class Of Service (COS) for this path. If the value is between 0 and 7 inclusive, this value will be inserted in the 3 bit COS field in the label. If the value is 255, the value in the COS field of the label will depend on other factors.')
vRtrMplsLspPathProperties = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 5), Bits().clone(namedValues=NamedValues(("record-route", 0), ("adaptive", 1), ("cspf", 2), ("mergeable", 3), ("fast-reroute", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathProperties.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathProperties.setDescription('The set of configured properties for this path expressed as a bit map. For example, if the path is an adaptive path, the bit corresponding to bit value 1 is set.')
vRtrMplsLspPathBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 6), Integer32()).setUnits('mega-bits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathBandwidth.setDescription('The value of vRtrMplsLspPathBandwidth specifies the amount of bandwidth in mega-bits per seconds (Mbps) to be reserved for this LSP path. A value of zero (0) indicates that no bandwidth is reserved.')
vRtrMplsLspPathBwProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathBwProtect.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathBwProtect.setDescription("When vRtrMplsLspPathBwProtect has a value of 'true', bandwidth protection is enabled on a LSP. LSPs that reserve bandwidth will be used for EF services where customers need guaranteed bandwidth. It is expected that multiple EF services will be assigned to a single LSP. When bandwidth protection is enabled on an LSP, each time this LSP is used for a certain service the bandwidth allocated on that service is deducted from the bandwidth reserved for the LSP. Once the bandwidth is exhausted on the LSP, the ESR will provide feedback to the provider indicating that this LSP has exhausted its resources.")
vRtrMplsLspPathState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("inactive", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathState.setDescription('The current working state of this path within this LSP.')
vRtrMplsLspPathPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathPreference.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathPreference.setDescription("When there is no path in the LSP with vRtrMplsLspPathType value of 'primary', 'secondary' type paths of this LSP with the same value of vRtrMplsLspPathPreference are used for load sharing. When a 'primary' type path exists in the LSP, vRtrMplsLspPathPreference is used to denote at which priority one 'secondary' path will supercede another when the 'primary' fails. 1 indicates the highest priority value. When the vRtrMplsLspPathPreference bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspPreference.")
vRtrMplsLspPathCosSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathCosSource.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCosSource.setDescription("When vRtrMplsLspPathCosSource is set to 'true', the value of vRtrMplsLspPathClassOfService overrides vRtrMplsLspClassOfService. When 'false', the value of vRtrMplsLspClassOfService is used.")
vRtrMplsLspPathClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 11), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathClassOfService.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathClassOfService.setDescription("The name of the class of service value to be assigned to all packets on the LSP is specified with vRtrMplsLspPathClassOfService. The EXP bits in the MPLS header are set based on the global mapping table that specified the mapping between the forwarding class and the EXP bits. When class of service is specified, all packets will be marked with the same EXP bits that match the vRtrMplsLspPathClassOfService name in the mapping table. An empty string, ''H, specifies no class of service. Packets are assigned EXP bits based on the same mapping table, however each packet is marked with EXP bits based on the forwarding class from which it is serviced.")
vRtrMplsLspPathSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathSetupPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathSetupPriority.setDescription('The value of vRtrMplsLspPathSetupPriority specifies the setup priority to use when insufficient bandwidth is available to setup a LSP. The setup priority is compared against the hold priority of existing LSPs. If the setup priority is higher than the hold priority of the established LSPs, this LSP may preempt the other LSPs. A value of zero (0) is the highest priority and a value of seven (7) is the lowest priority. When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspHopLimit.')
vRtrMplsLspPathHoldPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathHoldPriority.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathHoldPriority.setDescription('The value of vRtrMplsLspPathHoldPriority specifies the hold priority to use when insufficient bandwidth is available to setup a LSP. The setup priority is compared against the hold priority of existing LSPs. If the setup priority is higher than the hold priority of the established LSPs, this LSP may preempt the other LSPs. A value of zero (0) is the highest priority and a value of seven (7) is the lowest priority. When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspHopLimit.')
vRtrMplsLspPathRecord = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("record", 1), ("noRecord", 2))).clone('record')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRecord.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRecord.setDescription("When the value of vRtrMplsLspPathRecord is 'record', recording of all the hops that a LSP traverses is enabled. When the value of vRtrMplsLspPathRecord is 'noRecord', recording of all the hops that a LSP traverses is disabled.")
vRtrMplsLspPathHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathHopLimit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathHopLimit.setDescription('The value of vRtrMplsLspPathHopLimit specifies the maximum number of hops that a LSP will traverse including the ingress and egress ESRs. A LSP will not be setup if the hop limit is exceeded. When the vRtrMplsLspPathHopLimit bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspHopLimit.')
vRtrMplsLspPathSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathSharing.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathSharing.setDescription("When vRtrMplsLspPathSharing has a value of 'true', path-sharing is enabled for the secondary path. Path-sharing is used to control the hops of the secondary path. When vRtrMplsLspPathSharing have a value of 'false', CSPF attempts to find a path for the secondary that does not include any node or link that is common to the active primary path. This variable is valid only if vRtrMplsLspPathType is set to 'secondary'.")
vRtrMplsLspPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 17), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminState.setDescription('The desired administrative state for this LSP path.')
vRtrMplsLspPathOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 18), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperState.setDescription('The current operational state of this LSP path.')
vRtrMplsLspPathInheritance = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 19), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathInheritance.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathInheritance.setDescription("For each writable object in this row that can be configured to inherit its value from its corresponding object in the vRtrMplsLspTable, controls whether to inherit the operational value of that object, or use the administratively set value. This object is a bit-mask, with the following positions: vRtrMplsLspPathBandwidth 0x10 vRtrMplsLspPathPreference 0x80 vRtrMplsLspPathSetupPriority 0x400 vRtrMplsLspPathHoldPriority 0x800 vRtrMplsLspPathHopLimit 0x2000 vRtrMplsLspPathAdminGroupInclude 0x20000 vRtrMplsLspPathAdminGroupExclude 0x40000 vRtrMplsLspPathAdaptive 0x80000 vRtrMplsLspPathOptimizeTimer 0x100000 When the bit for an object is set to one, then the object's administrative and operational value are whatever the DEFVAL or most recently SET value is. When the bit for an object is set to zero, then the object's administrative and operational value are inherited from the corresponding object in vRtrMplsLspTable.")
vRtrMplsLspPathLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 20), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathLspId.setDescription('This value identifies the label switched path that is signaled for this entry.')
vRtrMplsLspPathRetryTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathRetryTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRetryTimeRemaining.setDescription('The time in 10-millisecond units to signal this path.')
vRtrMplsLspPathTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelARHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelARHopListIndex.setDescription('Primary index into the mplsTunnelARHopTable identifying a particular recorded hop list. A value of 0 implies that there is no recored hop list associated with this LSP path.')
vRtrMplsLspPathNegotiatedMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathNegotiatedMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNegotiatedMTU.setDescription('The value of vRtrMplsLspPathNegotiatedMTU specifies the size for the Maximum transmission unit (MTU) that is negotiated during establishment of this LSP Path.')
vRtrMplsLspPathFailCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 24), TmnxMplsLspFailCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathFailCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathFailCode.setDescription('The value of vRtrMplsLspPathFailCode specifies the reason code for LSP Path failure. A value of 0 indicates that no failure has occurred.')
vRtrMplsLspPathFailNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathFailNodeAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathFailNodeAddr.setDescription('The value of vRtrMplsLspPathFailNodeAddr specifies the IP address of the node in the LSP path at which the LSP path failed. When no failure has occurred, this value is 0.')
vRtrMplsLspPathAdminGroupInclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 26), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupInclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupInclude.setDescription("The value of vRtrMplsLspPathAdminGroupInclude is a bit-map that specifies a list of admin groups that should be included when this LSP path is setup. If bit 'n' is set, then the admin group with value 'n' is included for this LSP path. This implies that each link that this LSP path goes through must be associated with at least one of the admin groups in the include list. When the vRtrMplsLspPathAdminGroupInclude bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspAdminGroupInclude.")
vRtrMplsLspPathAdminGroupExclude = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 27), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupExclude.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdminGroupExclude.setDescription("The value of vRtrMplsLspPathAdminGroupExclude is a bit-map that specifies a list of admin groups that should be excluded when this LSP path is setup. If bit 'n' is set, then the admin group with value 'n' is excluded for this LSP path. This implies that each link that this LSP path goes through must not be associated with any of the admin groups in the exclude list. When the vRtrMplsLspPathAdminGroupExclude bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspAdminGroupExclude.")
vRtrMplsLspPathAdaptive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 28), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathAdaptive.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathAdaptive.setDescription("Setting the value of vRtrMplsLspPathAdaptive to 'true', enables make-before-break functionality for the LSP path. Setting the value to 'false', disables make-before-break functionality for the path. When the vRtrMplsLspPathAdaptive bit in vRtrMplsLspPathInheritance is cleared (0), the value returned to a GET request is inherited from vRtrMplsLspAdaptive.")
vRtrMplsLspPathOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOptimizeTimer.setDescription('The value of vRtrMplsLspPathOptimizeTimer specifies the time, in seconds, the software will wait before attempting to re-optimize the LSP path. When CSPF is enabled, changes in the network topology may cause the existing path of a loose-hop LSP to become sub-optimal. Such LSPs can be re-optimized and re-routed through more optimal paths by recalculating the path for the LSP at periodic intervals. This interval is controlled by the optimize timer. A value of 0 indicates that optimization has been disabled. When the vRtrMplsLspPathOptimizeTimer bit in vRtrMplsLspPathInheritance is cleared (0), the value returned in the GET request is inherited from vRtrMplsLspOptimizeTimer.')
vRtrMplsLspPathNextOptimize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathNextOptimize.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNextOptimize.setDescription('The value of vRtrMplsLspPathNextOptimize specifies the current value of the optimize timer. This is the time, in seconds, remaining till the optimize timer will expire and optimization will be started for the LSP path.')
vRtrMplsLspPathOperBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 31), Integer32()).setUnits('mega-bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperBandwidth.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperBandwidth.setDescription('The value of vRtrMplsLspPathOperBandwidth specifies the amount of bandwidth in mega-bits per seconds (Mbps) that has been reserved for the operational LSP path. When make-before-break functionality for the LSP is enabled and if the path bandwidth is changed, the resources allocated to the existing LSP paths will not be released until a new path with the new bandwidth settings has been established. While a new path is being signaled, the administrative value and the operational values of the path bandwidth may differ. The value of vRtrMplsLspPathBandwidth specifies the bandwidth requirements for the new LSP path trying to be established whereas the value of vRtrMplsLspPathOperBandwidth specifies the bandwidth reserved for the existing LSP path.')
vRtrMplsLspPathMBBState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("inProgress", 3), ("fail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathMBBState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathMBBState.setDescription('The value of vRtrMplsLspPathMBBState specifies the state of the most recent invocation of the make-before-break functionality. Possible states are: none (1) - no make-before-break invoked success (2) - make-before-break successful inProgress (3) - make-before-break in progress fail (4) - make-before-break failed.')
vRtrMplsLspPathResignal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 33), TmnxActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathResignal.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathResignal.setDescription("Setting the value of vRtrMplsLspPathResignal to 'doAction' triggers the re-signaling of the LSP path. If the LSP path is operationally down either due to network failure or due to the retry attempts count being exceeded, setting this variable to 'doAction' will initiate the signaling for the path. A make-before-break signaling for the path will be initiated if the LSP is operationally up but the make-before-break retry attempts count was exceeded. Make-before-break signaling will also be initiated for any LSP that is operationally up. This may be used to cause a loose-hop LSP to be optimized. If a re-signal is triggered while a re-signaling is already in progress, the old transient state will be destroyed and a new transaction being triggered. An SNMP GET request on this object should return 'notApplicable'.")
vRtrMplsLspPathTunnelCRHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelCRHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTunnelCRHopListIndex.setDescription('Primary index into the vRtrMplsTunnelCHopTable identifying a particular computed hop list. A value of 0 implies that there is no computed hop list associated with this LSP path.')
vRtrMplsLspPathOperMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathOperMTU.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathOperMTU.setDescription('The value of vRtrMplsLspPathOperMTU specifies the size for the Maximum transmission unit (MTU) that is currently operation for this LSP Path.')
vRtrMplsLspPathRecordLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 4, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("record", 1), ("noRecord", 2))).clone('record')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsLspPathRecordLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRecordLabel.setDescription("When the value of vRtrMplsLspPathRecordLabel is 'record', recording of labels at each node that a LSP traverses is enabled. When the value of vRtrMplsLspPathRecordLabel is 'noRecord', recording of labels at each node that a LSP traverses is disabled.")
vRtrMplsLspPathStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5), )
if mibBuilder.loadTexts: vRtrMplsLspPathStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathStatTable.setDescription('The vRtrMplsLspPathStatTable has an entry for an association between a Labeled Switch Path (LSP) in the vRtrMplsLspTable and a path (or tunnel) entry in the mplsTunnelTable.')
vRtrMplsLspPathStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1), )
vRtrMplsLspPathEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathStatEntry"))
vRtrMplsLspPathStatEntry.setIndexNames(*vRtrMplsLspPathEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsLspPathStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathStatEntry.setDescription('Each row entry represents a collection of statistics for an association between a Labeled Switch Path (LSP) in the vRtrMplsLspTable and a path (or tunnel) entry in the mplsTunnelTable. Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsLspPathTimeUp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 1), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTimeUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTimeUp.setDescription('The total time in 10-millisecond units that this LSP path has been operational. For example, the percentage up time can be determined by computing (vRtrMplsLspPathTimeUp/vRtrMplsLspAge * 100 %).')
vRtrMplsLspPathTimeDown = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 2), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTimeDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTimeDown.setDescription('The total time in 10-millisecond units that this LSP Path has not been operational.')
vRtrMplsLspPathRetryAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathRetryAttempts.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRetryAttempts.setDescription('The number of unsuccessful attempts which have been made to signal this path. As soon as the path gets signalled, this is set to 0.')
vRtrMplsLspPathTransitionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathTransitionCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathTransitionCount.setDescription('The object vRtrMplsLspPathTransitionCount maintains the number of transitions that have occurred for this LSP.')
vRtrMplsLspPathCspfQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLspPathCspfQueries.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathCspfQueries.setDescription('The value of vRtrMplsLspPathCspfQueries specifies the number of CSPF queries that have been made for this LSP path.')
vRtrMplsXCTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6), )
if mibBuilder.loadTexts: vRtrMplsXCTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCTable.setDescription('This table has an entry for each mplsXCEntry in the mplsXCTable. It serves as an another indirect index to the mplsXCTable.')
vRtrMplsXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1), ).setIndexNames((0, "MPLS-LSR-MIB", "mplsXCLspId"))
if mibBuilder.loadTexts: vRtrMplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCEntry.setDescription('An entry in this table represents the indices to be used to search the mplsXCTable.')
vRtrMplsXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCIndex.setDescription('An index of the mplsXCTable. It represents mplsXCIndex, a field of the mplsXCTable.')
vRtrMplsInSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsInSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsInSegmentIfIndex.setDescription('An index of the mplsXCTable. It represents mplsInSegmentIfIndex of the mplsInSegmentTable.')
vRtrMplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 3), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsInSegmentLabel.setDescription('An index of the mplsXCTable. It represents mplsInSegmentLabel of the mplsInSegmentTable.')
vRtrMplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsOutSegmentIndex.setDescription('An index of the mplsXCTable. It represents mplsOutSegmentIndex of the mplsOutSegmentTable.')
vRtrMplsERHopTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsERHopTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsERHopTunnelIndex.setDescription('Primary index into the mplsTunnelHopTable identifying a particular recorded hop list (stores ERO in LSR).')
vRtrMplsARHopTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsARHopTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsARHopTunnelIndex.setDescription('Primary index into the mplsTunnelARHopTable identifying a particular recorded hop list (stores RRO in LSR).')
vRtrMplsRsvpSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsRsvpSessionIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsRsvpSessionIndex.setDescription('An index into the vRtrRsvpSessionTable identifying a particular RSVP session.')
vRtrMplsXCFailCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 8), TmnxMplsLspFailCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCFailCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCFailCode.setDescription('The value of vRtrMplsXCFailCode specifies the reason code for cross-connect failure. A value of 0 indicates that no failure occurred.')
vRtrMplsXCCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsXCCHopTableIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsXCCHopTableIndex.setDescription('Index to the vRtrMplsTunnelCHopTable entries that specify the hops for the CSPF path for a detour LSP for this tunnel.')
vRtrMplsGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7), )
if mibBuilder.loadTexts: vRtrMplsGeneralTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralTable.setDescription('The vRtrMplsGeneralTable contains objects for general control and management of an MPLS protocol instance within a virtual router.')
vRtrMplsGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"))
if mibBuilder.loadTexts: vRtrMplsGeneralEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralEntry.setDescription("Each row entry represents an instance of the MPLS protocol running within a virtual router. Entries in this table cannot be created and deleted via SNMP SET operations. An entry in this table is created by the agent when vRtrMplsStatus in the vRtrConfTable is set to 'create'. The entry is destroyed when vRtrMplsStatus is set to 'delete'")
vRtrMplsGeneralLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralLastChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralLastChange.setDescription('The sysUpTime when this row was last modified.')
vRtrMplsGeneralAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 2), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralAdminState.setDescription("When vRtrMplsGeneralAdminState is set to 'inService', the agent attempts to enable the MPLS protocol instance on this router. When vRtrMplsGeneralAdminState is set to 'outOfService', the agent attempts to disable the MPLS protocol instance on this router.")
vRtrMplsGeneralOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 3), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOperState.setDescription('vRtrMplsGeneralOperState indicates the current operating state of this MPLS protocol instance on this router.')
vRtrMplsGeneralPropagateTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralPropagateTtl.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralPropagateTtl.setDescription("When vRtrMplsGeneralPropagateTtl is set to 'true', for all LSPs, the ingress ESR writes the TTL of the IP packet in the label and each transit ESR decrements the TTL in the label. At the egress ESR the TTL value from the label is written into the IP packet. When vRtrMplsGeneralPropagateTtl is set to 'false', the ingress ESR ignores the IP packet TTl and writes the value of 255 into the label, while the egress ESR does not write the label TTL into the IP packet. This assumes that all ESRs have been configured to have vRtrMplsGeneralPropagateTtl set to 'false', or this may result in unpredictable behavior.")
vRtrMplsGeneralTE = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bgp", 2), ("bgpigp", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralTE.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralTE.setDescription('The value of vRtrMplsGeneralTE specifies the type of traffic engineering used with this MPLS instance.')
vRtrMplsGeneralNewLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 6), TestAndIncr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralNewLspIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralNewLspIndex.setDescription("This object is used to assign values to vRtrMplsLspIndex as described in 'Textual Conventions for SNMPv2'. The network manager reads the object, and then writes the value back in the SET request that creates a new instance of vRtrMplsLspEntry. If the SET fails with the code 'inconsistentValue', then the process must be repeated. If the the SET succeeds, then the object is incremented and the new instance is created according to the manager's directions.")
vRtrMplsGeneralOptimizeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralOptimizeTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOptimizeTimer.setDescription('The value of vRtrMplsGeneralOptimizeTimer specifies the time, in seconds, the software will wait before attempting to re-optimize the LSPs. When CSPF is enabled, changes in the network topology may cause the existing path of a loose-hop LSP to become sub-optimal. Such LSPs can be re-optimized and re-routed through more optimal paths by recalculating the path for the LSP at periodic intervals. This interval is controlled by the optimize timer. A value of 0 indicates that optimization has been disabled. The value for vRtrMplsGeneralOptimizeTimer is by default inherited by all LSPs and their paths.')
vRtrMplsGeneralFRObject = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralFRObject.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralFRObject.setDescription("The value of vRtrMplsGeneralFRObject specifies whether fast reroute, for LSPs using 'Facility Backup', is signalled with or without the fast reroute object. The value of vRtrMplsGeneralFRObject is ignored if fast reroute is disabled for the LSP or if the LSP is using 'One-to-one Backup'. The value for vRtrMplsGeneralFRObject is by default inherited by all LSPs.")
vRtrMplsGeneralResignalTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 9), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(30, 10080), ))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralResignalTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralResignalTimer.setDescription('The value of vRtrMplsGeneralResignalTimer specifies the value for the LSP resignal timer, that is the time, in minutes, the software will wait before attempting to resignal the LSPs. When the resignal timer expires, if the new recorded hop list (RRO) for an LSP has a better metric than the current recorded hop list, an attempt will be made to resignal that LSP using the make-before-break mechanism. If the attempt to resignal an LSP fails, the LSP will continue to use the existing path and a resignal will be attempted the next time the timer expires. A value of 0 for the resignal timer indicates that timer-based LSP resignalling has been disabled.')
vRtrMplsGeneralHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralHoldTimer.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralHoldTimer.setDescription('The value of vRtrMplsGeneralHoldTimer specifies the time, in seconds, for which the ingress node holds a bit before programming its data plane and declaring the lsp up to the service module. A value of 0 indicates that the hold timer has been disabled.')
vRtrMplsGeneralDynamicBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicBypass.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicBypass.setDescription('The value of vRtrMplsGeneralDynamicBypass specifies whether dynamic bypass tunnels are enabled. By default, dynamic bypass tunnels are enabled.')
vRtrMplsGeneralNextResignal = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralNextResignal.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralNextResignal.setDescription('The value of vRtrMplsGeneralNextResignal indicates the time remaining, in minutes, for the vRtrMplsGeneralResignalTimer to expire.')
vRtrMplsGeneralOperDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 13), TmnxMplsOperDownReasonCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralOperDownReason.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralOperDownReason.setDescription('The value of vRtrMplsGeneralOperDownReason indicates the reason due to which the MPLS instance is operationally down.')
vRtrMplsGeneralSrlgFrr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrr.setDescription("The value of vRtrMplsGeneralSrlgFrr specifies whether Shared Risk Link Group (SRLG) constraint will be used in the computation of FRR bypass or detour to be associated with any primary LSP path on the system. When the value of vRtrMplsGeneralSrlgFrr is 'true' the use of SRLG constraint is enabled. By default, the use of SRLG constraint is disabled.")
vRtrMplsGeneralSrlgFrrStrict = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 7, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrrStrict.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralSrlgFrrStrict.setDescription("The value of vRtrMplsGeneralSrlgFrrStrict specifies whether to associate the LSP with a bypass or signal a detour if a bypass or detour satisfies all other constraints except the SRLG constraints. When the value of vRtrMplsGeneralSrlgFrrStrict is 'true' and a path that meets SRLG constraints is not found, the bypass or detour is not setup. If this value is set to 'true' when vRtrMplsGeneralSrlgFrr is set to 'false', vRtrMplsGeneralSrlgFrr is set to 'true' also. By default, the value of vRtrMplsGeneralSrlgFrrStrict is 'false'.")
vRtrMplsGeneralStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8), )
if mibBuilder.loadTexts: vRtrMplsGeneralStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStatTable.setDescription('The vRtrMplsGeneralStatTable contains statistics for an MPLS protocol instance within a virtual router.')
vRtrMplsGeneralStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1), )
vRtrMplsGeneralEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStatEntry"))
vRtrMplsGeneralStatEntry.setIndexNames(*vRtrMplsGeneralEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsGeneralStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStatEntry.setDescription('Each row entry represents a collection of statistics for an instance of the MPLS protocol running within a virtual router. Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsGeneralStaticLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspOriginate.setDescription('This object counts the number of static LSPs that originate at this virtual router.')
vRtrMplsGeneralStaticLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTransit.setDescription('This object counts the number of static LSPs that transit through this virtual router.')
vRtrMplsGeneralStaticLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralStaticLspTerminate.setDescription('This object counts the number of static LSPs that terminate at this virtual router.')
vRtrMplsGeneralDynamicLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspOriginate.setDescription('This object counts the number of dynamic LSPs that originate at this virtual router.')
vRtrMplsGeneralDynamicLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTransit.setDescription('This object counts the number of dynamic LSPs that transit through this virtual router.')
vRtrMplsGeneralDynamicLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDynamicLspTerminate.setDescription('This object counts the number of dynamic LSPs that terminate at this virtual router.')
vRtrMplsGeneralDetourLspOriginate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspOriginate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspOriginate.setDescription('This object counts the number of detour LSPs that originate at this virtual router.')
vRtrMplsGeneralDetourLspTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTransit.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTransit.setDescription('This object counts the number of detour LSPs that transit through this virtual router.')
vRtrMplsGeneralDetourLspTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTerminate.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsGeneralDetourLspTerminate.setDescription('This object counts the number of detour LSPs that terminate at this virtual router.')
vRtrMplsIfTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9), )
if mibBuilder.loadTexts: vRtrMplsIfTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTable.setDescription('The vRtrMplsIfTable has an entry for each router interface configured for MPLS in the system.')
vRtrMplsIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"))
if mibBuilder.loadTexts: vRtrMplsIfEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfEntry.setDescription("Each row entry represents an interface on this virtual router that participates in the MPLS protocol. A row cannot be created or deleted via SNMP SET requests. A row with default attribute values is created by setting the vRtrIfEntry attribute, vRtrIfMplsStatus, to 'create'. A row is removed if vRtrIfMplsStatus is set to 'delete'. However, an attempt to destroy a row will fail if vRtrMplsIfAdminState has not first been set to 'outOfService'.")
vRtrMplsIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 1), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfAdminState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfAdminState.setDescription('The desired administrative state for the MPLS protocol running on this MPLS interface.')
vRtrMplsIfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 2), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfOperState.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfOperState.setDescription('This variable indicates the current status of the MPLS protocol running on this MPLS interface.')
vRtrMplsIfAdminGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 3), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfAdminGroup.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfAdminGroup.setDescription("The value of vRtrMplsIfAdminGroup is a bit-map that identifies the admin groups to which the interface belongs. If bit 'n' is set, then the interface belongs to the admin group with value 'n'. By default, the interface does not belong to any admin groups.")
vRtrMplsIfTeMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 9, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16777215), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfTeMetric.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTeMetric.setDescription('The value of vRtrMplsIfTeMetric specifies the traffic engineering metric for this interface. The TE metric is exchanged in addition to the IGP metric by the IGPs. Depending on the value configured for vRtrMplsLspCspfTeMetricEnabled, either the TE metric or the native IGP metric is used in CSPF computations of the LSP paths. The maximum value that can be configured is a 24 bit value.')
vRtrMplsIfStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10), )
if mibBuilder.loadTexts: vRtrMplsIfStatTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStatTable.setDescription('The vRtrMplsIfStatTable has an entry for each router interface configured for MPLS in the system.')
vRtrMplsIfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1), )
vRtrMplsIfEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfStatEntry"))
vRtrMplsIfStatEntry.setIndexNames(*vRtrMplsIfEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsIfStatEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStatEntry.setDescription('Each row entry represents a collection of statistics for an interface on this virtual router that participates in the MPLS protocol. Entries cannot be created and deleted via SNMP SET operations.')
vRtrMplsIfTxPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfTxPktCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTxPktCount.setDescription('The total number of MPLS labeled packets transmitted from this interface.')
vRtrMplsIfRxPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfRxPktCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfRxPktCount.setDescription('The total number of MPLS labeled packets received on this interface.')
vRtrMplsIfTxOctetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfTxOctetCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfTxOctetCount.setDescription('The total number of bytes in MPLS labeled packets transmitted on this interface.')
vRtrMplsIfRxOctetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 10, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfRxOctetCount.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfRxOctetCount.setDescription('The total number of bytes in MPLS labeled packets received on this interface.')
vRtrMplsTunnelARHopTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11), )
if mibBuilder.loadTexts: vRtrMplsTunnelARHopTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopTable.setDescription('The vRtrMplsTunnelARHopTable augments the mplsTunnelARHopEntry in the MPLS-TE-MIB.')
vRtrMplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1), )
mplsTunnelARHopEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopEntry"))
vRtrMplsTunnelARHopEntry.setIndexNames(*mplsTunnelARHopEntry.getIndexNames())
if mibBuilder.loadTexts: vRtrMplsTunnelARHopEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopEntry.setDescription('A row entry in this table corresponds to a row entry in the mplsTunnelARHopTable and adds to the information contained in that table')
vRtrMplsTunnelARHopProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 1), Bits().clone(namedValues=NamedValues(("localAvailable", 0), ("localInUse", 1), ("bandwidthProtected", 2), ("nodeProtected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopProtection.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopProtection.setDescription("If the 'localAvailable' bit is set, it indicates that the link downstream of this node has been protected by means of a local repair mechanism. This mechanism can be either the one-to-one backup method or the facility backup method. If the 'localInUse' bit is set, then it indicates that the local protection mechanism is being used to maintain this tunnel. If the 'bandwidthProtected' bit is set, then it indicates that the backup path is guaranteed to provide the desired bandwidth. If the 'nodeProtected' bit is set, then it indicates that the backup path provides protection against the failure of the next LSR along the LSP.")
vRtrMplsTunnelARHopRecordLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 2), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRecordLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRecordLabel.setDescription('If label recording is enabled, vRtrMplsTunnelARHopRecordLabel specifies the label that is advertised to the previous hop in the hop list. If label recording is disabled, vRtrMplsTunnelARHopRecordLabel will have a value of 4294967295')
vRtrMplsTunnelARHopRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRouterId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelARHopRouterId.setDescription('vRtrMplsTunnelARHopRouterId specifies the router ID of the node corresponding to this hop.')
vRtrMplsTunnelCHopTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12), )
if mibBuilder.loadTexts: vRtrMplsTunnelCHopTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopTable.setDescription('The vRtrMplsTunnelCHopTable is used to hold the CSPF path for a detour LSP. Each entry indicates a single hop. Primary index is the vRtrMplsTunnelCHopListIndex which associates multiple entries (hops) in the vRtrMplsTunnelCHopTable to a single mplsTunnelEntry specified in the mplsTunnelTable. The first row in the table is the first hop after the origination point of the tunnel.')
vRtrMplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopListIndex"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIndex"))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopEntry.setDescription('An entry in this table represents a CSPF tunnel hop. Entries are created and deleted by the system.')
vRtrMplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopListIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopListIndex.setDescription('Primary index into this table identifying a particular explicit route object.')
vRtrMplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIndex.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIndex.setDescription('Secondary index into this table identifying a particular hop.')
vRtrMplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ipV4", 1), ("ipV6", 2), ("asNumber", 3), ("lspid", 4))).clone('ipV4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAddrType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAddrType.setDescription('Denotes the address type of this tunnel hop.')
vRtrMplsTunnelCHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4Addr.setDescription('If vRtrMplsTunnelCHopAddrType is set to ipV4(1), then this value will contain the IPv4 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
vRtrMplsTunnelCHopIpv4PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4PrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv4PrefixLen.setDescription("If vRtrMplsTunnelCHopAddrType is ipV4(1), then the prefix length for this hop's IPv4 address is contained herein. This object is otherwise insignificant and should contain a value of 0.")
vRtrMplsTunnelCHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6Addr.setDescription('If the vRtrMplsTunnelCHopAddrType is set to ipV6(2), then this variable contains the IPv6 address of this hop. This object is otherwise insignificant and should contain a value of 0.')
vRtrMplsTunnelCHopIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopIpv6PrefixLen.setDescription("If vRtrMplsTunnelCHopAddrType is set to ipV6(2), this value will contain the prefix length for this hop's IPv6 address. This object is otherwise insignificant and should contain a value of 0.")
vRtrMplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAsNumber.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopAsNumber.setDescription('If vRtrMplsTunnelCHopAddrType is set to asNumber(3), then this value will contain the AS number of this hop. This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
vRtrMplsTunnelCHopLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 9), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopLspId.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopLspId.setDescription('If vRtrMplsTunnelCHopAddrType is set to lspid(4), then this value will contain the LSPID of a tunnel of this hop. The present tunnel being configured is tunneled through this hop (using label stacking). This object is otherwise insignificant and should contain a value of 0 to indicate this fact.')
vRtrMplsTunnelCHopStrictOrLoose = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsTunnelCHopStrictOrLoose.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsTunnelCHopStrictOrLoose.setDescription('Denotes whether this tunnel hop is routed in a strict or loose fashion.')
vRtrMplsAdminGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13), )
if mibBuilder.loadTexts: vRtrMplsAdminGroupTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupTable.setDescription('The vRtrMplsAdminGroupTable has an entry for each administrative group configured for the virtual router in the system. Administrative groups are resource constructs that define a link color or resource class. They provide the ability to classify network resources (links) into groups or colors based on zones, geographic location, link location, etc. By doing so, network administrators are able to do more granular traffic engineering of LSPs.')
vRtrMplsAdminGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupName"))
if mibBuilder.loadTexts: vRtrMplsAdminGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupEntry.setDescription("Each row entry in the vRtrMplsAdminGroupTable represents an administrative group which is simply a mapping between a group name (an ASCII string) and a group value (a number in the range 0 to 31). Entries in this table are created and deleted via SNMP SET operations. An entry is created by setting the value of vRtrMplsAdminGroupRowStatus to 'createAndWait'. The row status for this entry can be set to active only once the value of vRtrMplsAdminGroupValue has been set to a valid number in the range 0 to 31. The entry is destroyed when vRtrMplsAdminGroupRowStatus is set to 'destroy'.")
vRtrMplsAdminGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsAdminGroupName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupName.setDescription('The value of vRtrMplsAdminGroupName uniquely identifies the name of the administrative group within a virtual router instance.')
vRtrMplsAdminGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsAdminGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupRowStatus.setDescription("vRtrMplsAdminGroupRowStatus is used to create, delete or control entries in the vRtrMplsAdminGroupTable. To create a row entry, the row status should be set to 'createAndWait'. Before the row can be placed into the 'active' state, vRtrMplsAdminGroupValue must be set to a value between 0 and 31. To delete a row entry, the row status should be set to 'destroy'")
vRtrMplsAdminGroupValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 31), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsAdminGroupValue.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsAdminGroupValue.setDescription('The value of vRtrMplsAdminGroupValue specifies the group value associated with this administrative group. This value is unique within a virtual router instance. A value of -1 indicates that the group value for this entry has not been set.')
vRtrMplsFSGroupTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14), )
if mibBuilder.loadTexts: vRtrMplsFSGroupTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupTable.setDescription('The vRtrMplsFSGroupTable has an entry for each group that is a part of the fate sharing database configured for the virtual router in the system. A fate sharing group is used to define a group of links and nodes in the network that share common risk attributes. To minimize a single point of failure, backup paths can be created that not only avoid the nodes and links of the primary path but also any other nodes and links that share risk with the nodes and links of the primary path.')
vRtrMplsFSGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupName"))
if mibBuilder.loadTexts: vRtrMplsFSGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupEntry.setDescription("Each row entry in the vRtrMplsFSGroupTable represents a fate sharing group which is a database of nodes and links that share common risk attributes. Entries in this table are created and deleted via SNMP SET operations. An entry is created by setting the value of vRtrMplsFSGroupRowStatus to 'createAndGo'. An entry can be deleted by setting vRtrMplsFSGroupRowStatus to 'destroy'.")
vRtrMplsFSGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsFSGroupName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupName.setDescription('The value of vRtrMplsFSGroupName uniquely identifies the name of the fate sharing group within a virtual router instance.')
vRtrMplsFSGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupRowStatus.setDescription("vRtrMplsFSGroupRowStatus is used to create, delete or control entries in the vRtrMplsFSGroupTable. To create a row entry, the row status should be set to 'createAndGo'. To delete a row entry, the row status should be set to 'destroy'")
vRtrMplsFSGroupCost = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupCost.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupCost.setDescription('The value of vRtrMplsFSGroupCost specifies the cost assigned to the fate sharing group. This cost is applied to all nodes and links that are part of this group and used for CSPF calculations. The higher the cost of the node or link, the lesser its chance of being selected as part of the path.')
vRtrMplsFSGroupParamsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15), )
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsTable.setDescription('The vRtrMplsFSGroupParamsTable has an entry for each node or link that is part of a fate sharing group on this virtual router.')
vRtrMplsFSGroupParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupName"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsFromAddr"), (0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsToAddr"))
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsEntry.setDescription("Each row entry in the vRtrMplsFSGroupParamsTable represents either a node or a link that is a part of a fate sharing group defined in the vRtrMplsFSGroupTable. Entries in this table are created and deleted via SNMP SET operations. An entry is created by setting the value of vRtrMplsFSGroupParamsRowStatus to 'createAndGo'. An entry can be deleted by setting vRtrMplsFSGroupParamsRowStatus to 'destroy'. To configure a node to be part of the group, create an entry in this table with vRtrMplsFSGroupParamsFromAddr set to a valid non-zero IP address and vRtrMplsFSGroupParamsToAddr set to 0. To configure a link to be part of the group, create an entry in this table with both vRtrMplsFSGroupParamsFromAddr and vRtrMplsFSGroupParamsToAddr set to valid non-zero IP addresses.")
vRtrMplsFSGroupParamsFromAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 1), IpAddress())
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsFromAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsFromAddr.setDescription('The value of vRtrMplsFSGroupParamsFromAddr along with the value of vRtrMplsFSGroupParamsToAddr uniquely identifies a link or node within a fate sharing group. This value must be non-zero for all row entries whether it represents a node or a link.')
vRtrMplsFSGroupParamsToAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 2), IpAddress())
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsToAddr.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsToAddr.setDescription('The value of vRtrMplsFSGroupParamsToAddr along with the value of vRtrMplsFSGroupParamsFromAddr uniquely identifies a link or node within a fate sharing group. This value must be 0 for row entries that represent a node and must be non-zero for row entries that represent a link.')
vRtrMplsFSGroupParamsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 15, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsFSGroupParamsRowStatus.setDescription("vRtrMplsFSGroupParamsRowStatus is used to create, delete or control entries in the vRtrMplsFSGroupParamsTable. To create a row entry, the row status should be set to 'createAndGo'. To delete a row entry, the row status should be set to 'destroy'")
vRtrMplsLabelRangeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17), )
if mibBuilder.loadTexts: vRtrMplsLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeTable.setDescription('The vRtrMplsLabelRangeTable has an entry for each type of label, the minimum and maximum value in the label range and information on total available and aging labels in each range. This is a read-only table.')
vRtrMplsLabelRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelType"))
if mibBuilder.loadTexts: vRtrMplsLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeEntry.setDescription('Each row entry in the vRtrMplsLabelRangeTable represents a type of label. Each entry contains the label range used by that label type and the number of aging and allocated labels in the range.')
vRtrMplsLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("staticLsp", 1), ("staticSvc", 2), ("dynamic", 3))))
if mibBuilder.loadTexts: vRtrMplsLabelType.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelType.setDescription('The value of vRtrMplsLabelType specifies the type of label and is the index for this table.')
vRtrMplsLabelRangeMin = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeMin.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeMin.setDescription('The value of vRtrMplsLabelRangeMin specifies the minimum label value in the range for a particular label type.')
vRtrMplsLabelRangeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeMax.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeMax.setDescription('The value of vRtrMplsLabelRangeMax specifies the maximum label value in the range for a particular label type.')
vRtrMplsLabelRangeAging = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeAging.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeAging.setDescription('The value of vRtrMplsLabelRangeAging represents the number of labels that are currently allocated and aging.')
vRtrMplsLabelRangeAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 17, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsLabelRangeAvailable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLabelRangeAvailable.setDescription('The value of vRtrMplsLabelRangeAvailable represents the number of labels that are currently available for each label type.')
vRtrMplsStaticLSPLabelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18), )
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelTable.setDescription('The vRtrMplsStaticLSPLabelTable has an entry for each allocated label that is part of the static LSP label range. This is a read-only table.')
vRtrMplsStaticLSPLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticLSPLabel"))
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelEntry.setDescription('Each row entry in the vRtrMplsStaticLSPLabelTable represents a label of type static LSP that is currently allocated. The entry includes information about the current owner for that label.')
vRtrMplsStaticLSPLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1, 1), MplsLabel().subtype(subtypeSpec=ValueRangeConstraint(32, 1023)))
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabel.setDescription('The value of vRtrMplsStaticLSPLabel specifies the label value.')
vRtrMplsStaticLSPLabelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 18, 1, 2), TmnxMplsLabelOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelOwner.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticLSPLabelOwner.setDescription('The value of vRtrMplsStaticLSPLabelOwner specifies the owner for the label value vRtrMplsStaticLSPLabel.')
vRtrMplsStaticSvcLabelTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19), )
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelTable.setDescription('The vRtrMplsStaticSvcLabelTable has an entry for each allocated label that is part of the static service label range. This is a read-only table.')
vRtrMplsStaticSvcLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticSvcLabel"))
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelEntry.setDescription('Each row entry in the vRtrMplsStaticSvcLabelTable represents a label of type static-svc that is currently allocated. The entry includes information about the current owner for that label.')
vRtrMplsStaticSvcLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1, 1), MplsLabel().subtype(subtypeSpec=ValueRangeConstraint(2048, 18431)))
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabel.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabel.setDescription('The value of vRtrMplsStaticSvcLabel specifies the label value.')
vRtrMplsStaticSvcLabelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 19, 1, 2), TmnxMplsLabelOwner().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelOwner.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStaticSvcLabelOwner.setDescription('The value of vRtrMplsStaticSvcLabelOwner specifies the owner for the label value vRtrMplsStaticSvcLabel.')
vRtrMplsSrlgGrpTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTableLastChanged.setDescription('The value of vRtrMplsSrlgGrpTableLastChanged indicates the sysUpTime at the time of the last modification to vRtrMplsSrlgGrpTable by adding, deleting an entry or change to a writable object in the table. If no changes were made to the table since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
vRtrMplsSrlgGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21), )
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpTable.setDescription('The vRtrMplsSrlgGrpTable has an entry for each Shared Risk Link Groups (SRLG) group configured for MPLS in the system.')
vRtrMplsSrlgGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpName"))
if mibBuilder.loadTexts: vRtrMplsSrlgGrpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpEntry.setDescription('Each row entry represents a SRLG group on this virtual router that participates in the MPLS protocol. A row can be created or deleted via SNMP SET requests.')
vRtrMplsSrlgGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsSrlgGrpName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpName.setDescription('The value of vRtrMplsSrlgGrpName indicates the SRLG group name.')
vRtrMplsSrlgGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpRowStatus.setDescription("vRtrMplsSrlgGrpRowStatus is used to create, delete or control entries in the vRtrMplsSrlgGrpTable. A value must also be set for vRtrMplsSrlgGrpValue before the row entry can transition to the 'active' state.")
vRtrMplsSrlgGrpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpLastChanged.setDescription('The value of vRtrMplsSrlgGrpLastChanged indicates the timestamp of last change to this row in vRtrMplsSrlgGrpTable.')
vRtrMplsSrlgGrpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 21, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsSrlgGrpValue.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsSrlgGrpValue.setDescription('The value of vRtrMplsSrlgGrpValue specifies the group value associated with vRtrMplsSrlgGrpName. This value is unique within a virtual router instance. At the time of row creation, a value for vRtrMplsSrlgGrpValue must be specified or else row creation would fail.')
vRtrMplsIfSrlgGrpTblLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTblLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTblLastChanged.setDescription('The value of vRtrMplsIfSrlgGrpTblLastChanged indicates the sysUpTime at the time of the last modification to vRtrMplsIfSrlgGrpTable by adding, deleting an entry or change to a writable object in the table. If no changes were made to the table since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
vRtrMplsIfSrlgGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23), )
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTable.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpTable.setDescription('The vRtrMplsIfSrlgGrpTable has an entry for each Shared Risk Link Group (SRLG) groups associated with a router interface configured for MPLS in the system.')
vRtrMplsIfSrlgGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), (0, "ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), (1, "ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpName"))
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpEntry.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpEntry.setDescription('Each row entry represents an SRLG group associated with a interface on this virtual router that participates in the MPLS protocol. A row can be created or deleted via SNMP SET requests.')
vRtrMplsIfSrlgGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 1), TNamedItem())
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpName.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpName.setDescription('The value of vRtrMplsIfSrlgGrpName indicates the SRLG group name.')
vRtrMplsIfSrlgGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpRowStatus.setDescription('vRtrMplsIfSrlgGrpRowStatus is used to create, delete or control entries in the vRtrMplsIfSrlgGrpTable.')
vRtrMplsIfSrlgGrpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 23, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpLastChanged.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfSrlgGrpLastChanged.setDescription('The value of vRtrMplsIfSrlgGrpLastChanged indicates the timestamp of last change to this row in vRtrMplsIfSrlgGrpTable.')
tmnxMplsNotificationlObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16))
vRtrMplsLspNotificationReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("noPathIsOperational", 1)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspNotificationReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspNotificationReasonCode.setDescription('Used by vRtrMplsLspDown, the value indicates the reason for the LSP going down.')
vRtrMplsLspPathNotificationReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 2), TmnxMplsLspFailCode()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsLspPathNotificationReasonCode.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathNotificationReasonCode.setDescription('Used by vRtrMplsLspPathDown, the value indicates the reason for the LSP path going down.')
vRtrMplsNotifyRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 6, 16, 3), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vRtrMplsNotifyRow.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsNotifyRow.setDescription('used by Alcatel 7x50 SR series MPLS Configuration change Notifications, the object ID indicates the MPLS table and entry.')
vRtrMplsStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"))
if mibBuilder.loadTexts: vRtrMplsStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsStateChange.setDescription('This Notification is generated when the MPLS module changes state')
vRtrMplsIfStateChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrIfIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfOperState"))
if mibBuilder.loadTexts: vRtrMplsIfStateChange.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsIfStateChange.setDescription('This Notification is generated when the MPLS interface changes state')
vRtrMplsLspUp = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"))
if mibBuilder.loadTexts: vRtrMplsLspUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspUp.setDescription("This Notification is generated when a LSP transitions to the 'inService' state from any other state.")
vRtrMplsLspDown = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNotificationReasonCode"))
if mibBuilder.loadTexts: vRtrMplsLspDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspDown.setDescription("This Notification is generated when a LSP transitions out of 'inService' state to any other state.")
vRtrMplsLspPathUp = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelIngressLSRId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathUp.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathUp.setDescription("This Notification is generated when a LSP Path transitions to the 'inService' state from any other state.")
vRtrMplsLspPathDown = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 6)).setObjects(("ALCATEL-IND1-TIMETRA-VRTR-MIB", "vRtrID"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"), ("MPLS-TE-MIB", "mplsTunnelIndex"), ("MPLS-TE-MIB", "mplsTunnelInstance"), ("MPLS-TE-MIB", "mplsTunnelIngressLSRId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNotificationReasonCode"))
if mibBuilder.loadTexts: vRtrMplsLspPathDown.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathDown.setDescription("This Notification is generated when a LSP Path transitions out of 'inService' state to any other state.")
vRtrMplsLspPathRerouted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 7)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathRerouted.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathRerouted.setDescription('The vRtrMplsLspPathRerouted notification is generated when an LSP Path is rerouted.')
vRtrMplsLspPathResignaled = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 6, 0, 8)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"))
if mibBuilder.loadTexts: vRtrMplsLspPathResignaled.setStatus('current')
if mibBuilder.loadTexts: vRtrMplsLspPathResignaled.setDescription('The vRtrMplsLspPathResignaled notification is generated when an LSP Path is resignaled.')
tmnxMplsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1))
tmnxMplsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2))
tmnxMplsV3v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 3)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV3v0Compliance = tmnxMplsV3v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsV3v0Compliance.setDescription('The compliance statement for management of extended MPLS on Alcatel 7x50 SR series systems 3.0 Release.')
tmnxMplsV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 4)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV5v0Compliance = tmnxMplsV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsV5v0Compliance.setDescription('The compliance statement for management of extended MPLS on Alcatel 7xxx SR series systems 5.0 Release.')
tmnxMplsV6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 1, 5)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsGlobalV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV5v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspPathGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsXCGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelARHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsTunnelCHopGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsAdminGroupGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsNotificationR2r1Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLabelRangeGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsSrlgV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsIfV6v0Group"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "tmnxMplsLspV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsV6v0Compliance = tmnxMplsV6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsV6v0Compliance.setDescription('The compliance statement for management of extended MPLS on Alcatel 7xxx SR series systems 6.0 Release.')
tmnxMplsLspPathGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 3)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTableSpinlock"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCos"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathProperties"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCosSource"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathSharing"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathLspId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRetryTimeRemaining"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTunnelARHopListIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathFailCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathFailNodeAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNextOptimize"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathMBBState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathResignal"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTunnelCRHopListIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathOperMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRecordLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRetryAttempts"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathTransitionCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathCspfQueries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspPathGroup = tmnxMplsLspPathGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspPathGroup.setDescription('The group of objects supporting management of extended MPLS LSP to path mapping on Alcatel 7x50 SR series systems.')
tmnxMplsXCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 4)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsInSegmentIfIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsInSegmentLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsOutSegmentIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsERHopTunnelIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsARHopTunnelIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsRsvpSessionIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCFailCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsXCCHopTableIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsXCGroup = tmnxMplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsXCGroup.setDescription('The group of objects supporting management of extended MPLS LSP to cross-connection mapping on Alcatel 7x50 SR series systems.')
tmnxMplsIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 5)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfAdminGroup"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTxPktCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfRxPktCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTxOctetCount"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfRxOctetCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsIfGroup = tmnxMplsIfGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsIfGroup.setDescription('The group of objects supporting management of extended MPLS interfaces on Alcatel 7x50 SR series systems.')
tmnxMplsTunnelARHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 6)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopProtection"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopRecordLabel"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelARHopRouterId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsTunnelARHopGroup = tmnxMplsTunnelARHopGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsTunnelARHopGroup.setDescription('The group of objects supporting management of extended MPLS Tunnel AR hops on Alcatel 7x50 SR series systems.')
tmnxMplsTunnelCHopGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 7)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopAddrType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv4Addr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv4PrefixLen"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv6Addr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopIpv6PrefixLen"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopAsNumber"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopLspId"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsTunnelCHopStrictOrLoose"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsTunnelCHopGroup = tmnxMplsTunnelCHopGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsTunnelCHopGroup.setDescription('The group of objects supporting management of extended MPLS CSPF Tunnel hops on Alcatel 7x50 SR series systems.')
tmnxMplsAdminGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 8)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsAdminGroupValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsAdminGroupGroup = tmnxMplsAdminGroupGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsAdminGroupGroup.setDescription('The group of objects supporting management of extended MPLS administrative groups on Alcatel 7x50 SR series systems.')
tmnxMplsFSGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 9)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupCost"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsFSGroupParamsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsFSGroupGroup = tmnxMplsFSGroupGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsFSGroupGroup.setDescription('The group of objects supporting management of extended MPLS fate sharing groups on Alcatel 7x50 SR series systems.')
tmnxMplsNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 10)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNotificationReasonCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathNotificationReasonCode"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsNotifyRow"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsNotifyObjsGroup = tmnxMplsNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsNotifyObjsGroup.setDescription('The group of objects supporting extended MPLS notifications on Alcatel 7x50 SR series systems.')
tmnxMplsGlobalR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 12)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalR2r1Group = tmnxMplsGlobalR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsGlobalR2r1Group.setDescription('The group of objects supporting general management of extended MPLS on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsLspR2r1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 13)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspName"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFromAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspToAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOutSegIndx"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspMetric"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDecrementTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspf"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpResvStyle"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpAdspec"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRMethod"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRNodeProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOctets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPackets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAge"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPrimaryTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTransitions"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastTransition"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathChanges"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastPathChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspConfiguredPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStandbyPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperationalPaths"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspR2r1Group = tmnxMplsLspR2r1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsLspR2r1Group.setDescription('The group of objects supporting management of extended MPLS LSPs on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsNotificationR2r1Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 14)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStateChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfStateChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathRerouted"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathResignaled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsNotificationR2r1Group = tmnxMplsNotificationR2r1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsNotificationR2r1Group.setDescription('The group of notifications supporting the extended MPLS feature on Alcatel 7x50 SR series systems 2.1 Release.')
tmnxMplsLabelRangeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 15)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeMin"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeMax"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeAging"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLabelRangeAvailable"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticLSPLabelOwner"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsStaticSvcLabelOwner"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLabelRangeGroup = tmnxMplsLabelRangeGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLabelRangeGroup.setDescription('The group of objects supporting management of extended MPLS label ranges on Alcatel 7x50 SR series systems.')
tmnxMplsGlobalV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralHoldTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicBypass"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalV5v0Group = tmnxMplsGlobalV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMplsGlobalV5v0Group.setDescription('The group of objects supporting general management of extended MPLS on Alcatel 7x50 SR series systems 5.0 Release.')
tmnxMplsLspV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspName"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFromAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspToAddr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspType"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOutSegIndx"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRetryLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspMetric"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspDecrementTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspf"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspClassOfService"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspSetupPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldPriority"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRecord"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPreference"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBandwidth"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspBwProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHopLimit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspNegotiatedMTU"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpResvStyle"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspRsvpAdspec"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRMethod"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRNodeProtect"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupInclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdminGroupExclude"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAdaptive"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspInheritance"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperFastReroute"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOctets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPackets"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspAge"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTimeDown"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPrimaryTimeUp"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspTransitions"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastTransition"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspPathChanges"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspLastPathChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspConfiguredPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspStandbyPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspOperationalPaths"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspHoldTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspV5v0Group = tmnxMplsLspV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspV5v0Group.setDescription('The group of objects supporting management of extended MPLS LSPs on Alcatel 7x50 SR series systems 5.0 Release.')
tmnxMplsGlobalV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 18)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralLastChange"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralAdminState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperState"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralPropagateTtl"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralTE"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNewLspIndex"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOptimizeTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralFRObject"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralResignalTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralStaticLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspOriginate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTransit"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDetourLspTerminate"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralHoldTimer"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralDynamicBypass"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralNextResignal"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralOperDownReason"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralSrlgFrr"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsGeneralSrlgFrrStrict"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsGlobalV6v0Group = tmnxMplsGlobalV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsGlobalV6v0Group.setDescription('The group of objects supporting general management of extended MPLS on Alcatel 7x50 SR series systems 6.0 Release.')
tmnxMplsSrlgV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 19)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpTableLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsSrlgGrpValue"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpTblLastChanged"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpRowStatus"), ("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfSrlgGrpLastChanged"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsSrlgV6v0Group = tmnxMplsSrlgV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsSrlgV6v0Group.setDescription('The group of objects supporting management of SRLG on Alcatel 7xxx SR series systems release 6.0.')
tmnxMplsIfV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsIfTeMetric"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsIfV6v0Group = tmnxMplsIfV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsIfV6v0Group.setDescription('The group of objects supporting management of Te metric feature on extended MPLS interfaces on 6.0 release Alcatel 7xxx SR series systems.')
tmnxMplsLspV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 6, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-MPLS-MIB", "vRtrMplsLspCspfTeMetricEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMplsLspV6v0Group = tmnxMplsLspV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMplsLspV6v0Group.setDescription('The group of objects supporting management of Te metric feature extended MPLS LSPs on 6.0 release Alcatel 7xxx SR series systems.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-MPLS-MIB", vRtrMplsLspStandbyPaths=vRtrMplsLspStandbyPaths, vRtrMplsSrlgGrpRowStatus=vRtrMplsSrlgGrpRowStatus, vRtrMplsLspPathProperties=vRtrMplsLspPathProperties, vRtrMplsAdminGroupValue=vRtrMplsAdminGroupValue, vRtrMplsIfTable=vRtrMplsIfTable, vRtrMplsGeneralOperState=vRtrMplsGeneralOperState, vRtrMplsGeneralDynamicLspTransit=vRtrMplsGeneralDynamicLspTransit, vRtrMplsFSGroupParamsRowStatus=vRtrMplsFSGroupParamsRowStatus, vRtrMplsLspIndex=vRtrMplsLspIndex, vRtrMplsIfOperState=vRtrMplsIfOperState, vRtrMplsGeneralEntry=vRtrMplsGeneralEntry, vRtrMplsLspOctets=vRtrMplsLspOctets, vRtrMplsTunnelARHopTable=vRtrMplsTunnelARHopTable, tmnxMplsXCGroup=tmnxMplsXCGroup, vRtrMplsLspToAddr=vRtrMplsLspToAddr, vRtrMplsLspPathRetryAttempts=vRtrMplsLspPathRetryAttempts, tmnxMplsFSGroupGroup=tmnxMplsFSGroupGroup, vRtrMplsInSegmentIfIndex=vRtrMplsInSegmentIfIndex, vRtrMplsTunnelCHopListIndex=vRtrMplsTunnelCHopListIndex, vRtrMplsGeneralResignalTimer=vRtrMplsGeneralResignalTimer, vRtrMplsSrlgGrpValue=vRtrMplsSrlgGrpValue, vRtrMplsLspFRMethod=vRtrMplsLspFRMethod, vRtrMplsTunnelCHopAsNumber=vRtrMplsTunnelCHopAsNumber, vRtrMplsLspPathRecordLabel=vRtrMplsLspPathRecordLabel, vRtrMplsTunnelCHopIpv6Addr=vRtrMplsTunnelCHopIpv6Addr, vRtrMplsStaticLSPLabelOwner=vRtrMplsStaticLSPLabelOwner, vRtrMplsLspPathUp=vRtrMplsLspPathUp, tmnxMplsNotifyObjsGroup=tmnxMplsNotifyObjsGroup, vRtrMplsLspPathResignal=vRtrMplsLspPathResignal, vRtrMplsGeneralNextResignal=vRtrMplsGeneralNextResignal, vRtrMplsLspHopLimit=vRtrMplsLspHopLimit, vRtrMplsLspPathPreference=vRtrMplsLspPathPreference, vRtrMplsLspBwProtect=vRtrMplsLspBwProtect, vRtrMplsLspTimeDown=vRtrMplsLspTimeDown, vRtrMplsLspPathOperBandwidth=vRtrMplsLspPathOperBandwidth, vRtrMplsInSegmentLabel=vRtrMplsInSegmentLabel, vRtrMplsOutSegmentIndex=vRtrMplsOutSegmentIndex, vRtrMplsGeneralPropagateTtl=vRtrMplsGeneralPropagateTtl, vRtrMplsSrlgGrpName=vRtrMplsSrlgGrpName, tmnxMplsIfGroup=tmnxMplsIfGroup, vRtrMplsLspRetryLimit=vRtrMplsLspRetryLimit, vRtrMplsLspFRHopLimit=vRtrMplsLspFRHopLimit, tmnxMplsTunnelCHopGroup=tmnxMplsTunnelCHopGroup, vRtrMplsLspSetupPriority=vRtrMplsLspSetupPriority, vRtrMplsLspPathCos=vRtrMplsLspPathCos, vRtrMplsGeneralStatTable=vRtrMplsGeneralStatTable, vRtrMplsARHopTunnelIndex=vRtrMplsARHopTunnelIndex, vRtrMplsLspAdminGroupInclude=vRtrMplsLspAdminGroupInclude, vRtrMplsStaticLSPLabelEntry=vRtrMplsStaticLSPLabelEntry, vRtrMplsLspOutSegIndx=vRtrMplsLspOutSegIndx, vRtrMplsLspPathChanges=vRtrMplsLspPathChanges, vRtrMplsGeneralStaticLspTerminate=vRtrMplsGeneralStaticLspTerminate, vRtrMplsLspLastTransition=vRtrMplsLspLastTransition, vRtrMplsLspPathType=vRtrMplsLspPathType, vRtrMplsFSGroupParamsToAddr=vRtrMplsFSGroupParamsToAddr, vRtrMplsIfSrlgGrpLastChanged=vRtrMplsIfSrlgGrpLastChanged, vRtrMplsLspPathFailCode=vRtrMplsLspPathFailCode, vRtrMplsGeneralHoldTimer=vRtrMplsGeneralHoldTimer, vRtrMplsTunnelCHopEntry=vRtrMplsTunnelCHopEntry, vRtrMplsLabelRangeAvailable=vRtrMplsLabelRangeAvailable, vRtrMplsFSGroupCost=vRtrMplsFSGroupCost, vRtrMplsSrlgGrpTable=vRtrMplsSrlgGrpTable, vRtrMplsAdminGroupTable=vRtrMplsAdminGroupTable, tmnxMplsNotificationlObjects=tmnxMplsNotificationlObjects, vRtrMplsStateChange=vRtrMplsStateChange, tmnxMplsV6v0Compliance=tmnxMplsV6v0Compliance, vRtrMplsLspDecrementTtl=vRtrMplsLspDecrementTtl, tmnxMplsIfV6v0Group=tmnxMplsIfV6v0Group, vRtrMplsLspAdminGroupExclude=vRtrMplsLspAdminGroupExclude, vRtrMplsLspPathLastChange=vRtrMplsLspPathLastChange, vRtrMplsLspPathSharing=vRtrMplsLspPathSharing, vRtrMplsGeneralDetourLspTransit=vRtrMplsGeneralDetourLspTransit, vRtrMplsXCIndex=vRtrMplsXCIndex, vRtrMplsLspPathStatEntry=vRtrMplsLspPathStatEntry, vRtrMplsXCTable=vRtrMplsXCTable, vRtrMplsSrlgGrpTableLastChanged=vRtrMplsSrlgGrpTableLastChanged, vRtrMplsLspPathRecord=vRtrMplsLspPathRecord, tmnxMplsLspV6v0Group=tmnxMplsLspV6v0Group, vRtrMplsIfSrlgGrpRowStatus=vRtrMplsIfSrlgGrpRowStatus, vRtrMplsLspPathSetupPriority=vRtrMplsLspPathSetupPriority, vRtrMplsFSGroupParamsFromAddr=vRtrMplsFSGroupParamsFromAddr, vRtrMplsLspFRBandwidth=vRtrMplsLspFRBandwidth, vRtrMplsStaticLSPLabelTable=vRtrMplsStaticLSPLabelTable, vRtrMplsLspRetryTimer=vRtrMplsLspRetryTimer, vRtrMplsLspConfiguredPaths=vRtrMplsLspConfiguredPaths, vRtrMplsLspOperationalPaths=vRtrMplsLspOperationalPaths, vRtrMplsLspOperFastReroute=vRtrMplsLspOperFastReroute, vRtrMplsGeneralStaticLspTransit=vRtrMplsGeneralStaticLspTransit, vRtrMplsLabelType=vRtrMplsLabelType, vRtrMplsLspAdaptive=vRtrMplsLspAdaptive, vRtrMplsGeneralSrlgFrr=vRtrMplsGeneralSrlgFrr, vRtrMplsLspStatEntry=vRtrMplsLspStatEntry, vRtrMplsLspPathRowStatus=vRtrMplsLspPathRowStatus, vRtrMplsLspPathTable=vRtrMplsLspPathTable, vRtrMplsIfStatEntry=vRtrMplsIfStatEntry, vRtrMplsIfTxPktCount=vRtrMplsIfTxPktCount, vRtrMplsLspPathTimeDown=vRtrMplsLspPathTimeDown, TmnxMplsOperDownReasonCode=TmnxMplsOperDownReasonCode, vRtrMplsLspMetric=vRtrMplsLspMetric, vRtrMplsLspPathOperMTU=vRtrMplsLspPathOperMTU, tmnxMplsGroups=tmnxMplsGroups, vRtrMplsIfAdminGroup=vRtrMplsIfAdminGroup, tmnxMplsGlobalV5v0Group=tmnxMplsGlobalV5v0Group, vRtrMplsLspCspfTeMetricEnabled=vRtrMplsLspCspfTeMetricEnabled, vRtrMplsLspPathOptimizeTimer=vRtrMplsLspPathOptimizeTimer, vRtrMplsLspPathNotificationReasonCode=vRtrMplsLspPathNotificationReasonCode, TmnxMplsLspFailCode=TmnxMplsLspFailCode, vRtrMplsLspNegotiatedMTU=vRtrMplsLspNegotiatedMTU, vRtrMplsIfAdminState=vRtrMplsIfAdminState, vRtrMplsERHopTunnelIndex=vRtrMplsERHopTunnelIndex, vRtrMplsTunnelCHopStrictOrLoose=vRtrMplsTunnelCHopStrictOrLoose, vRtrMplsTunnelCHopIpv4PrefixLen=vRtrMplsTunnelCHopIpv4PrefixLen, vRtrMplsLspTimeUp=vRtrMplsLspTimeUp, vRtrMplsGeneralDynamicLspTerminate=vRtrMplsGeneralDynamicLspTerminate, vRtrMplsLspStatTable=vRtrMplsLspStatTable, vRtrMplsTunnelARHopEntry=vRtrMplsTunnelARHopEntry, vRtrMplsTunnelCHopIpv6PrefixLen=vRtrMplsTunnelCHopIpv6PrefixLen, vRtrMplsFSGroupTable=vRtrMplsFSGroupTable, tmnxMplsLspV5v0Group=tmnxMplsLspV5v0Group, vRtrMplsLspCspf=vRtrMplsLspCspf, vRtrMplsGeneralTE=vRtrMplsGeneralTE, vRtrMplsLspAge=vRtrMplsLspAge, vRtrMplsLspRsvpAdspec=vRtrMplsLspRsvpAdspec, vRtrMplsLspPathNextOptimize=vRtrMplsLspPathNextOptimize, vRtrMplsTunnelCHopIpv4Addr=vRtrMplsTunnelCHopIpv4Addr, vRtrMplsLspName=vRtrMplsLspName, vRtrMplsNotifyRow=vRtrMplsNotifyRow, vRtrMplsLspPathResignaled=vRtrMplsLspPathResignaled, vRtrMplsGeneralTable=vRtrMplsGeneralTable, vRtrMplsTunnelARHopRouterId=vRtrMplsTunnelARHopRouterId, vRtrMplsStaticSvcLabelEntry=vRtrMplsStaticSvcLabelEntry, vRtrMplsLspPathClassOfService=vRtrMplsLspPathClassOfService, vRtrMplsIfTeMetric=vRtrMplsIfTeMetric, tmnxMplsLabelRangeGroup=tmnxMplsLabelRangeGroup, vRtrMplsTunnelARHopProtection=vRtrMplsTunnelARHopProtection, vRtrMplsStaticSvcLabelOwner=vRtrMplsStaticSvcLabelOwner, PYSNMP_MODULE_ID=timetraMplsMIBModule, vRtrMplsLspFRNodeProtect=vRtrMplsLspFRNodeProtect, vRtrMplsFSGroupEntry=vRtrMplsFSGroupEntry, vRtrMplsGeneralOptimizeTimer=vRtrMplsGeneralOptimizeTimer, vRtrMplsXCCHopTableIndex=vRtrMplsXCCHopTableIndex, vRtrMplsLspPathRerouted=vRtrMplsLspPathRerouted, vRtrMplsTunnelCHopTable=vRtrMplsTunnelCHopTable, vRtrMplsLspUp=vRtrMplsLspUp, vRtrMplsLspPathAdaptive=vRtrMplsLspPathAdaptive, vRtrMplsFSGroupName=vRtrMplsFSGroupName, vRtrMplsLspPathCspfQueries=vRtrMplsLspPathCspfQueries, vRtrMplsFSGroupParamsEntry=vRtrMplsFSGroupParamsEntry, tmnxMplsConformance=tmnxMplsConformance, vRtrMplsIfRxOctetCount=vRtrMplsIfRxOctetCount, vRtrMplsLspPreference=vRtrMplsLspPreference, vRtrMplsXCFailCode=vRtrMplsXCFailCode, vRtrMplsLspRsvpResvStyle=vRtrMplsLspRsvpResvStyle, vRtrMplsLspDown=vRtrMplsLspDown, vRtrMplsLspOperState=vRtrMplsLspOperState, vRtrMplsIfSrlgGrpName=vRtrMplsIfSrlgGrpName, vRtrMplsLspPathTunnelARHopListIndex=vRtrMplsLspPathTunnelARHopListIndex, vRtrMplsGeneralLastChange=vRtrMplsGeneralLastChange, vRtrMplsIfSrlgGrpTblLastChanged=vRtrMplsIfSrlgGrpTblLastChanged, vRtrMplsLspClassOfService=vRtrMplsLspClassOfService, vRtrMplsLspOptimizeTimer=vRtrMplsLspOptimizeTimer, vRtrMplsLspTable=vRtrMplsLspTable, vRtrMplsIfStatTable=vRtrMplsIfStatTable, vRtrMplsLspRowStatus=vRtrMplsLspRowStatus, vRtrMplsTunnelCHopAddrType=vRtrMplsTunnelCHopAddrType, vRtrMplsLspPathMBBState=vRtrMplsLspPathMBBState, vRtrMplsSrlgGrpEntry=vRtrMplsSrlgGrpEntry, vRtrMplsTunnelCHopIndex=vRtrMplsTunnelCHopIndex, tmnxMplsNotifyPrefix=tmnxMplsNotifyPrefix, vRtrMplsLabelRangeEntry=vRtrMplsLabelRangeEntry, vRtrMplsLspPathStatTable=vRtrMplsLspPathStatTable, vRtrMplsLspEntry=vRtrMplsLspEntry, vRtrMplsLspTransitions=vRtrMplsLspTransitions, vRtrMplsFSGroupParamsTable=vRtrMplsFSGroupParamsTable, vRtrMplsIfTxOctetCount=vRtrMplsIfTxOctetCount, tmnxMplsAdminGroupGroup=tmnxMplsAdminGroupGroup, tmnxMplsCompliances=tmnxMplsCompliances, vRtrMplsLspPackets=vRtrMplsLspPackets, tmnxMplsV5v0Compliance=tmnxMplsV5v0Compliance, vRtrMplsLabelRangeMin=vRtrMplsLabelRangeMin, vRtrMplsLspType=vRtrMplsLspType, vRtrMplsLspPathTimeUp=vRtrMplsLspPathTimeUp, vRtrMplsGeneralFRObject=vRtrMplsGeneralFRObject, vRtrMplsGeneralDetourLspTerminate=vRtrMplsGeneralDetourLspTerminate, timetraMplsMIBModule=timetraMplsMIBModule, tmnxMplsLspR2r1Group=tmnxMplsLspR2r1Group, vRtrMplsLspPathBandwidth=vRtrMplsLspPathBandwidth, tmnxMplsGlobalR2r1Group=tmnxMplsGlobalR2r1Group, vRtrMplsLspHoldPriority=vRtrMplsLspHoldPriority, vRtrMplsIfSrlgGrpTable=vRtrMplsIfSrlgGrpTable, vRtrMplsLspPathState=vRtrMplsLspPathState, vRtrMplsLspPathTransitionCount=vRtrMplsLspPathTransitionCount, vRtrMplsLspPathAdminState=vRtrMplsLspPathAdminState, vRtrMplsStaticLSPLabel=vRtrMplsStaticLSPLabel, vRtrMplsGeneralAdminState=vRtrMplsGeneralAdminState, vRtrMplsLspLastChange=vRtrMplsLspLastChange, vRtrMplsLspPathTableSpinlock=vRtrMplsLspPathTableSpinlock, tmnxMplsObjs=tmnxMplsObjs, vRtrMplsLspPrimaryTimeUp=vRtrMplsLspPrimaryTimeUp, TmnxMplsLabelOwner=TmnxMplsLabelOwner, vRtrMplsLspPathNegotiatedMTU=vRtrMplsLspPathNegotiatedMTU, vRtrMplsLspPathCosSource=vRtrMplsLspPathCosSource, vRtrMplsLspPathAdminGroupExclude=vRtrMplsLspPathAdminGroupExclude, vRtrMplsLspPathEntry=vRtrMplsLspPathEntry, vRtrMplsGeneralStaticLspOriginate=vRtrMplsGeneralStaticLspOriginate, vRtrMplsGeneralDetourLspOriginate=vRtrMplsGeneralDetourLspOriginate, vRtrMplsLabelRangeTable=vRtrMplsLabelRangeTable, vRtrMplsLspFRObject=vRtrMplsLspFRObject, vRtrMplsGeneralStatEntry=vRtrMplsGeneralStatEntry, vRtrMplsAdminGroupEntry=vRtrMplsAdminGroupEntry, vRtrMplsLspPathInheritance=vRtrMplsLspPathInheritance, vRtrMplsGeneralNewLspIndex=vRtrMplsGeneralNewLspIndex, vRtrMplsLspInheritance=vRtrMplsLspInheritance, vRtrMplsXCEntry=vRtrMplsXCEntry, vRtrMplsLabelRangeMax=vRtrMplsLabelRangeMax, vRtrMplsTunnelCHopLspId=vRtrMplsTunnelCHopLspId, vRtrMplsAdminGroupName=vRtrMplsAdminGroupName, vRtrMplsLspFromAddr=vRtrMplsLspFromAddr, vRtrMplsLspLastPathChange=vRtrMplsLspLastPathChange, vRtrMplsRsvpSessionIndex=vRtrMplsRsvpSessionIndex, vRtrMplsLspPathDown=vRtrMplsLspPathDown, tmnxMplsNotificationR2r1Group=tmnxMplsNotificationR2r1Group, vRtrMplsTunnelARHopRecordLabel=vRtrMplsTunnelARHopRecordLabel, vRtrMplsLspPathRetryTimeRemaining=vRtrMplsLspPathRetryTimeRemaining, tmnxMplsV3v0Compliance=tmnxMplsV3v0Compliance, vRtrMplsLspAdminState=vRtrMplsLspAdminState, vRtrMplsIfSrlgGrpEntry=vRtrMplsIfSrlgGrpEntry, vRtrMplsLspRecord=vRtrMplsLspRecord, tmnxMplsTunnelARHopGroup=tmnxMplsTunnelARHopGroup, vRtrMplsFSGroupRowStatus=vRtrMplsFSGroupRowStatus, vRtrMplsLspPathBwProtect=vRtrMplsLspPathBwProtect, vRtrMplsLspBandwidth=vRtrMplsLspBandwidth, tmnxMplsLspPathGroup=tmnxMplsLspPathGroup, tmnxMplsSrlgV6v0Group=tmnxMplsSrlgV6v0Group, vRtrMplsIfStateChange=vRtrMplsIfStateChange, vRtrMplsSrlgGrpLastChanged=vRtrMplsSrlgGrpLastChanged, vRtrMplsLspPathFailNodeAddr=vRtrMplsLspPathFailNodeAddr, vRtrMplsLspHoldTimer=vRtrMplsLspHoldTimer, vRtrMplsLspPathHoldPriority=vRtrMplsLspPathHoldPriority, vRtrMplsLspPathAdminGroupInclude=vRtrMplsLspPathAdminGroupInclude, vRtrMplsLspPathTunnelCRHopListIndex=vRtrMplsLspPathTunnelCRHopListIndex, vRtrMplsGeneralDynamicBypass=vRtrMplsGeneralDynamicBypass, vRtrMplsGeneralOperDownReason=vRtrMplsGeneralOperDownReason, vRtrMplsGeneralSrlgFrrStrict=vRtrMplsGeneralSrlgFrrStrict, vRtrMplsIfRxPktCount=vRtrMplsIfRxPktCount, vRtrMplsGeneralDynamicLspOriginate=vRtrMplsGeneralDynamicLspOriginate, vRtrMplsAdminGroupRowStatus=vRtrMplsAdminGroupRowStatus, vRtrMplsStaticSvcLabelTable=vRtrMplsStaticSvcLabelTable, vRtrMplsLspFastReroute=vRtrMplsLspFastReroute, vRtrMplsStaticSvcLabel=vRtrMplsStaticSvcLabel, vRtrMplsLspNotificationReasonCode=vRtrMplsLspNotificationReasonCode, vRtrMplsIfEntry=vRtrMplsIfEntry, tmnxMplsNotifications=tmnxMplsNotifications, vRtrMplsLspPathOperState=vRtrMplsLspPathOperState)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-MPLS-MIB", tmnxMplsGlobalV6v0Group=tmnxMplsGlobalV6v0Group, vRtrMplsLspPathLspId=vRtrMplsLspPathLspId, vRtrMplsLspPathHopLimit=vRtrMplsLspPathHopLimit, vRtrMplsLabelRangeAging=vRtrMplsLabelRangeAging)
